# Comparing `tmp/PyMieSim-1.8.0-cp312-cp312-win_amd64.whl.zip` & `tmp/PyMieSim-1.8.1-cp312-cp312-win_amd64.whl.zip`

## zipinfo {}

```diff
@@ -1,205 +1,205 @@
-Zip file size: 8023814 bytes, number of entries: 203
--rw-rw-rw-  2.0 fat        7 b- defN 24-Apr-15 21:54 PyMieSim/VERSION
--rw-rw-rw-  2.0 fat        0 b- defN 24-Apr-15 21:54 PyMieSim/__init__.py
--rw-rw-rw-  2.0 fat      230 b- defN 24-Apr-15 21:54 PyMieSim/__main__.py
--rw-rw-rw-  2.0 fat      418 b- defN 24-Apr-15 21:54 PyMieSim/materials.py
--rw-rw-rw-  2.0 fat     3780 b- defN 24-Apr-15 21:54 PyMieSim/measure.py
--rw-rw-rw-  2.0 fat     7864 b- defN 24-Apr-15 21:54 PyMieSim/mesh.py
--rw-rw-rw-  2.0 fat     1988 b- defN 24-Apr-15 21:54 PyMieSim/physics.py
--rw-rw-rw-  2.0 fat     2084 b- defN 24-Apr-15 21:54 PyMieSim/polarization.py
--rw-rw-rw-  2.0 fat   818688 b- defN 24-Apr-15 21:58 PyMieSim/binary/CoreShellInterface.cp310-win_amd64.pyd
--rw-rw-rw-  2.0 fat   818688 b- defN 24-Apr-15 22:02 PyMieSim/binary/CoreShellInterface.cp311-win_amd64.pyd
--rw-rw-rw-  2.0 fat   818688 b- defN 24-Apr-15 22:05 PyMieSim/binary/CoreShellInterface.cp312-win_amd64.pyd
--rw-rw-rw-  2.0 fat   802304 b- defN 24-Apr-15 21:58 PyMieSim/binary/CylinderInterface.cp310-win_amd64.pyd
--rw-rw-rw-  2.0 fat   802304 b- defN 24-Apr-15 22:02 PyMieSim/binary/CylinderInterface.cp311-win_amd64.pyd
--rw-rw-rw-  2.0 fat   802304 b- defN 24-Apr-15 22:05 PyMieSim/binary/CylinderInterface.cp312-win_amd64.pyd
--rw-rw-rw-  2.0 fat   842240 b- defN 24-Apr-15 21:58 PyMieSim/binary/DetectorInterface.cp310-win_amd64.pyd
--rw-rw-rw-  2.0 fat   842240 b- defN 24-Apr-15 22:02 PyMieSim/binary/DetectorInterface.cp311-win_amd64.pyd
--rw-rw-rw-  2.0 fat   842240 b- defN 24-Apr-15 22:05 PyMieSim/binary/DetectorInterface.cp312-win_amd64.pyd
--rw-rw-rw-  2.0 fat   970752 b- defN 24-Apr-15 21:58 PyMieSim/binary/Experiment.cp310-win_amd64.pyd
--rw-rw-rw-  2.0 fat   970752 b- defN 24-Apr-15 22:02 PyMieSim/binary/Experiment.cp311-win_amd64.pyd
--rw-rw-rw-  2.0 fat   982528 b- defN 24-Apr-15 22:05 PyMieSim/binary/Experiment.cp312-win_amd64.pyd
--rw-rw-rw-  2.0 fat   358912 b- defN 24-Apr-15 21:58 PyMieSim/binary/Fibonacci.cp310-win_amd64.pyd
--rw-rw-rw-  2.0 fat   358912 b- defN 24-Apr-15 22:02 PyMieSim/binary/Fibonacci.cp311-win_amd64.pyd
--rw-rw-rw-  2.0 fat   358400 b- defN 24-Apr-15 22:05 PyMieSim/binary/Fibonacci.cp312-win_amd64.pyd
--rw-rw-rw-  2.0 fat   829952 b- defN 24-Apr-15 21:58 PyMieSim/binary/Sets.cp310-win_amd64.pyd
--rw-rw-rw-  2.0 fat   829952 b- defN 24-Apr-15 22:02 PyMieSim/binary/Sets.cp311-win_amd64.pyd
--rw-rw-rw-  2.0 fat   829440 b- defN 24-Apr-15 22:05 PyMieSim/binary/Sets.cp312-win_amd64.pyd
--rw-rw-rw-  2.0 fat   818688 b- defN 24-Apr-15 21:58 PyMieSim/binary/SphereInterface.cp310-win_amd64.pyd
--rw-rw-rw-  2.0 fat   818176 b- defN 24-Apr-15 22:02 PyMieSim/binary/SphereInterface.cp311-win_amd64.pyd
--rw-rw-rw-  2.0 fat   819712 b- defN 24-Apr-15 22:05 PyMieSim/binary/SphereInterface.cp312-win_amd64.pyd
--rw-rw-rw-  2.0 fat        0 b- defN 24-Apr-15 21:54 PyMieSim/binary/__init__.py
--rw-rw-rw-  2.0 fat   133174 b- defN 24-Apr-15 22:05 PyMieSim/binary/libZBessel.a
--rw-rw-rw-  2.0 fat      165 b- defN 24-Apr-15 21:54 PyMieSim/experiment/__init__.py
--rw-rw-rw-  2.0 fat    12877 b- defN 24-Apr-15 21:54 PyMieSim/experiment/detector.py
--rw-rw-rw-  2.0 fat    16508 b- defN 24-Apr-15 21:54 PyMieSim/experiment/scatterer.py
--rw-rw-rw-  2.0 fat     4421 b- defN 24-Apr-15 21:54 PyMieSim/experiment/setup.py
--rw-rw-rw-  2.0 fat     5019 b- defN 24-Apr-15 21:54 PyMieSim/experiment/source.py
--rw-rw-rw-  2.0 fat      143 b- defN 24-Apr-15 21:54 PyMieSim/gui/__init__.py
--rw-rw-rw-  2.0 fat     3241 b- defN 24-Apr-15 21:54 PyMieSim/gui/axis_tab.py
--rw-rw-rw-  2.0 fat     3382 b- defN 24-Apr-15 21:54 PyMieSim/gui/base_tab.py
--rw-rw-rw-  2.0 fat     6652 b- defN 24-Apr-15 21:54 PyMieSim/gui/detector_tab.py
--rw-rw-rw-  2.0 fat     7719 b- defN 24-Apr-15 21:54 PyMieSim/gui/main_window.py
--rw-rw-rw-  2.0 fat     7526 b- defN 24-Apr-15 21:54 PyMieSim/gui/scatterer_tab.py
--rw-rw-rw-  2.0 fat     2705 b- defN 24-Apr-15 21:54 PyMieSim/gui/source_tab.py
--rw-rw-rw-  2.0 fat    10629 b- defN 24-Apr-15 21:54 PyMieSim/gui/utils.py
--rw-rw-rw-  2.0 fat        0 b- defN 24-Apr-15 21:54 PyMieSim/modes/__init__.py
--rw-rw-rw-  2.0 fat     4320 b- defN 24-Apr-15 21:54 PyMieSim/modes/hermite_gauss.py
--rw-rw-rw-  2.0 fat     4395 b- defN 24-Apr-15 21:54 PyMieSim/modes/laguerre_gauss.py
--rw-rw-rw-  2.0 fat     4073 b- defN 24-Apr-15 21:54 PyMieSim/modes/linearly_polarized.py
--rw-rw-rw-  2.0 fat      139 b- defN 24-Apr-15 21:54 PyMieSim/single/__init__.py
--rw-rw-rw-  2.0 fat    11561 b- defN 24-Apr-15 21:54 PyMieSim/single/detector.py
--rw-rw-rw-  2.0 fat    19695 b- defN 24-Apr-15 21:54 PyMieSim/single/representations.py
--rw-rw-rw-  2.0 fat    20197 b- defN 24-Apr-15 21:54 PyMieSim/single/scatterer.py
--rw-rw-rw-  2.0 fat     5579 b- defN 24-Apr-15 21:54 PyMieSim/single/source.py
--rw-rw-rw-  2.0 fat        0 b- defN 24-Apr-15 21:54 PyMieSim/tools/__init__.py
--rw-rw-rw-  2.0 fat     1184 b- defN 24-Apr-15 21:54 PyMieSim/tools/directories.py
--rw-rw-rw-  2.0 fat     6229 b- defN 24-Apr-15 21:54 PyMieSim/tools/special_functions.py
--rw-rw-rw-  2.0 fat    10073 b- defN 24-Apr-15 21:54 PyMieSim/validation_data/Figure810BH.csv
--rw-rw-rw-  2.0 fat    40002 b- defN 24-Apr-15 21:54 PyMieSim/validation_data/Figure87BH.csv
--rw-rw-rw-  2.0 fat    40002 b- defN 24-Apr-15 21:54 PyMieSim/validation_data/Figure88BH.csv
--rw-rw-rw-  2.0 fat    20800 b- defN 24-Apr-15 21:54 PyMieSim/validation_data/PyMieScattQsca.csv
--rw-rw-rw-  2.0 fat    10400 b- defN 24-Apr-15 21:54 PyMieSim/validation_data/PyMieScattQscaCoreShell.csv
--rw-rw-rw-  2.0 fat    10400 b- defN 24-Apr-15 21:54 PyMieSim/validation_data/PyMieScattQscaCoreShellMedium.csv
--rw-rw-rw-  2.0 fat    20800 b- defN 24-Apr-15 21:54 PyMieSim/validation_data/PyMieScattQscaMedium.csv
--rw-rw-rw-  2.0 fat     1424 b- defN 24-Apr-15 21:54 development/LPMOdes.py
--rw-rw-rw-  2.0 fat    13670 b- defN 24-Apr-15 21:54 development/gui.py
--rw-rw-rw-  2.0 fat      906 b- defN 24-Apr-15 21:54 docs/examples/detector/plot_HG01.py
--rw-rw-rw-  2.0 fat      906 b- defN 24-Apr-15 21:54 docs/examples/detector/plot_HG11.py
--rw-rw-rw-  2.0 fat      913 b- defN 24-Apr-15 21:54 docs/examples/detector/plot_LG11.py
--rw-rw-rw-  2.0 fat      885 b- defN 24-Apr-15 21:54 docs/examples/detector/plot_LP01.py
--rw-rw-rw-  2.0 fat      702 b- defN 24-Apr-15 21:54 docs/examples/detector/plot_LP02.py
--rw-rw-rw-  2.0 fat      701 b- defN 24-Apr-15 21:54 docs/examples/detector/plot_LP11.py
--rw-rw-rw-  2.0 fat      559 b- defN 24-Apr-15 21:54 docs/examples/detector/plot_integrating_sphere.py
--rw-rw-rw-  2.0 fat      666 b- defN 24-Apr-15 21:54 docs/examples/detector/plot_photodiode.py
--rw-rw-rw-  2.0 fat     1909 b- defN 24-Apr-15 21:54 docs/examples/experiment/plot_coreshell_Qback_vs_corediameter.py
--rw-rw-rw-  2.0 fat     2119 b- defN 24-Apr-15 21:54 docs/examples/experiment/plot_coreshell_a1_vs_corediameter.py
--rw-rw-rw-  2.0 fat     2051 b- defN 24-Apr-15 21:54 docs/examples/experiment/plot_coreshell_b1_vs_corediameter.py
--rw-rw-rw-  2.0 fat     2212 b- defN 24-Apr-15 21:54 docs/examples/experiment/plot_coreshell_coupling_vs_corediameter.py
--rw-rw-rw-  2.0 fat     1879 b- defN 24-Apr-15 21:54 docs/examples/experiment/plot_cylinder_Qabs_vs_diameter.py
--rw-rw-rw-  2.0 fat     1655 b- defN 24-Apr-15 21:54 docs/examples/experiment/plot_cylinder_Qsca_vs_diameter.py
--rw-rw-rw-  2.0 fat     1648 b- defN 24-Apr-15 21:54 docs/examples/experiment/plot_cylinder_Qsca_vs_index.py
--rw-rw-rw-  2.0 fat     1979 b- defN 24-Apr-15 21:54 docs/examples/experiment/plot_cylinder_Qsca_vs_wavelength.py
--rw-rw-rw-  2.0 fat     1176 b- defN 24-Apr-15 21:54 docs/examples/experiment/plot_cylinder_Qsca_vs_wavelength_std.py
--rw-rw-rw-  2.0 fat     1625 b- defN 24-Apr-15 21:54 docs/examples/experiment/plot_cylinder_a11_vs_diameter.py
--rw-rw-rw-  2.0 fat     1538 b- defN 24-Apr-15 21:54 docs/examples/experiment/plot_cylinder_b11_vs_diameter.py
--rw-rw-rw-  2.0 fat     2056 b- defN 24-Apr-15 21:54 docs/examples/experiment/plot_cylinder_coupling_vs_diameter.py
--rw-rw-rw-  2.0 fat     2077 b- defN 24-Apr-15 21:54 docs/examples/experiment/plot_cylinder_coupling_vs_phioffset.py
--rw-rw-rw-  2.0 fat     2241 b- defN 24-Apr-15 21:54 docs/examples/experiment/plot_cylinder_coupling_vs_wavelength.py
--rw-rw-rw-  2.0 fat     1128 b- defN 24-Apr-15 21:54 docs/examples/experiment/plot_sphere_Qabs_vs_diameter.py
--rw-rw-rw-  2.0 fat     1055 b- defN 24-Apr-15 21:54 docs/examples/experiment/plot_sphere_Qsca_vs_diameter.py
--rw-rw-rw-  2.0 fat     1038 b- defN 24-Apr-15 21:54 docs/examples/experiment/plot_sphere_Qsca_vs_index.py
--rw-rw-rw-  2.0 fat     1063 b- defN 24-Apr-15 21:54 docs/examples/experiment/plot_sphere_Qsca_vs_wavelength.py
--rw-rw-rw-  2.0 fat     1173 b- defN 24-Apr-15 21:54 docs/examples/experiment/plot_sphere_Qsca_vs_wavelength_std.py
--rw-rw-rw-  2.0 fat     1051 b- defN 24-Apr-15 21:54 docs/examples/experiment/plot_sphere_a1_vs_diameter.py
--rw-rw-rw-  2.0 fat     1048 b- defN 24-Apr-15 21:54 docs/examples/experiment/plot_sphere_b1_vs_diameter.py
--rw-rw-rw-  2.0 fat     1411 b- defN 24-Apr-15 21:54 docs/examples/experiment/plot_sphere_coupling_vs_diameter.py
--rw-rw-rw-  2.0 fat     1473 b- defN 24-Apr-15 21:54 docs/examples/experiment/plot_sphere_coupling_vs_filter.py
--rw-rw-rw-  2.0 fat     1388 b- defN 24-Apr-15 21:54 docs/examples/experiment/plot_sphere_coupling_vs_phioffset.py
--rw-rw-rw-  2.0 fat     1459 b- defN 24-Apr-15 21:54 docs/examples/experiment/plot_sphere_coupling_vs_wavelength.py
--rw-rw-rw-  2.0 fat     1010 b- defN 24-Apr-15 21:54 docs/examples/extras/SphereProperties.py
--rw-rw-rw-  2.0 fat     1628 b- defN 24-Apr-15 21:54 docs/examples/extras/plot_Qsca_vs_permittivity_vs_size_parameter.py
--rw-rw-rw-  2.0 fat     1788 b- defN 24-Apr-15 21:54 docs/examples/extras/plot_coupling_heatmap.py
--rw-rw-rw-  2.0 fat     1048 b- defN 24-Apr-15 21:54 docs/examples/scatterer/plot_farfield.py
--rw-rw-rw-  2.0 fat     1367 b- defN 24-Apr-15 21:54 docs/examples/scatterer/plot_footprint.py
--rw-rw-rw-  2.0 fat      940 b- defN 24-Apr-15 21:54 docs/examples/scatterer/plot_s1s2.py
--rw-rw-rw-  2.0 fat      593 b- defN 24-Apr-15 21:54 docs/examples/scatterer/plot_source.py
--rw-rw-rw-  2.0 fat      999 b- defN 24-Apr-15 21:54 docs/examples/scatterer/plot_spf.py
--rw-rw-rw-  2.0 fat      946 b- defN 24-Apr-15 21:54 docs/examples/scatterer/plot_stokes.py
--rw-rw-rw-  2.0 fat     1215 b- defN 24-Apr-15 21:54 docs/examples/validation/plot_BH810.py
--rw-rw-rw-  2.0 fat     1666 b- defN 24-Apr-15 21:54 docs/examples/validation/plot_BH87.py
--rw-rw-rw-  2.0 fat     1671 b- defN 24-Apr-15 21:54 docs/examples/validation/plot_BH88.py
--rw-rw-rw-  2.0 fat     2485 b- defN 24-Apr-15 21:54 docs/examples/validation/plot_phase_function_detector.py
--rw-rw-rw-  2.0 fat     1455 b- defN 24-Apr-15 21:54 docs/examples/validation/plot_pymiescatt_0.py
--rw-rw-rw-  2.0 fat     1613 b- defN 24-Apr-15 21:54 docs/examples/validation/plot_pymiescatt_1.py
--rw-rw-rw-  2.0 fat     1811 b- defN 24-Apr-15 21:54 docs/examples/validation/plot_pymiescatt_2.py
--rw-rw-rw-  2.0 fat     1809 b- defN 24-Apr-15 21:54 docs/examples/validation/plot_pymiescatt_3.py
--rw-rw-rw-  2.0 fat     4717 b- defN 24-Apr-15 21:54 docs/source/conf.py
--rw-rw-rw-  2.0 fat     2872 b- defN 24-Apr-15 21:54 extern/pybind11/noxfile.py
--rw-rw-rw-  2.0 fat     5027 b- defN 24-Apr-15 21:54 extern/pybind11/setup.py
--rw-rw-rw-  2.0 fat     2943 b- defN 24-Apr-15 21:54 extern/pybind11/docs/benchmark.py
--rw-rw-rw-  2.0 fat    11942 b- defN 24-Apr-15 21:54 extern/pybind11/docs/conf.py
--rw-rw-rw-  2.0 fat      446 b- defN 24-Apr-15 21:54 extern/pybind11/pybind11/__init__.py
--rw-rw-rw-  2.0 fat     1606 b- defN 24-Apr-15 21:54 extern/pybind11/pybind11/__main__.py
--rw-rw-rw-  2.0 fat      245 b- defN 24-Apr-15 21:54 extern/pybind11/pybind11/_version.py
--rw-rw-rw-  2.0 fat     1244 b- defN 24-Apr-15 21:54 extern/pybind11/pybind11/commands.py
--rw-rw-rw-  2.0 fat        0 b- defN 24-Apr-15 21:54 extern/pybind11/pybind11/py.typed
--rw-rw-rw-  2.0 fat    18134 b- defN 24-Apr-15 21:54 extern/pybind11/pybind11/setup_helpers.py
--rw-rw-rw-  2.0 fat     5847 b- defN 24-Apr-15 21:54 extern/pybind11/tests/conftest.py
--rw-rw-rw-  2.0 fat      953 b- defN 24-Apr-15 21:54 extern/pybind11/tests/env.py
--rw-rw-rw-  2.0 fat      560 b- defN 24-Apr-15 21:54 extern/pybind11/tests/test_async.py
--rw-rw-rw-  2.0 fat     5012 b- defN 24-Apr-15 21:54 extern/pybind11/tests/test_buffers.py
--rw-rw-rw-  2.0 fat    17771 b- defN 24-Apr-15 21:54 extern/pybind11/tests/test_builtin_casters.py
--rw-rw-rw-  2.0 fat     6796 b- defN 24-Apr-15 21:54 extern/pybind11/tests/test_call_policies.py
--rw-rw-rw-  2.0 fat     7014 b- defN 24-Apr-15 21:54 extern/pybind11/tests/test_callbacks.py
--rw-rw-rw-  2.0 fat     5896 b- defN 24-Apr-15 21:54 extern/pybind11/tests/test_chrono.py
--rw-rw-rw-  2.0 fat    15242 b- defN 24-Apr-15 21:54 extern/pybind11/tests/test_class.py
--rw-rw-rw-  2.0 fat      622 b- defN 24-Apr-15 21:54 extern/pybind11/tests/test_const_name.py
--rw-rw-rw-  2.0 fat     1550 b- defN 24-Apr-15 21:54 extern/pybind11/tests/test_constants_and_functions.py
--rw-rw-rw-  2.0 fat     4928 b- defN 24-Apr-15 21:54 extern/pybind11/tests/test_copy_move.py
--rw-rw-rw-  2.0 fat     4114 b- defN 24-Apr-15 21:54 extern/pybind11/tests/test_custom_type_casters.py
--rw-rw-rw-  2.0 fat     1139 b- defN 24-Apr-15 21:54 extern/pybind11/tests/test_custom_type_setup.py
--rw-rw-rw-  2.0 fat     2487 b- defN 24-Apr-15 21:54 extern/pybind11/tests/test_docstring_options.py
--rw-rw-rw-  2.0 fat    29835 b- defN 24-Apr-15 21:54 extern/pybind11/tests/test_eigen_matrix.py
--rw-rw-rw-  2.0 fat     9702 b- defN 24-Apr-15 21:54 extern/pybind11/tests/test_eigen_tensor.py
--rw-rw-rw-  2.0 fat     9205 b- defN 24-Apr-15 21:54 extern/pybind11/tests/test_enum.py
--rw-rw-rw-  2.0 fat     1193 b- defN 24-Apr-15 21:54 extern/pybind11/tests/test_eval.py
--rw-rw-rw-  2.0 fat      123 b- defN 24-Apr-15 21:54 extern/pybind11/tests/test_eval_call.py
--rw-rw-rw-  2.0 fat    13389 b- defN 24-Apr-15 21:54 extern/pybind11/tests/test_exceptions.py
--rw-rw-rw-  2.0 fat    17007 b- defN 24-Apr-15 21:54 extern/pybind11/tests/test_factory_constructors.py
--rw-rw-rw-  2.0 fat     8749 b- defN 24-Apr-15 21:54 extern/pybind11/tests/test_gil_scoped.py
--rw-rw-rw-  2.0 fat     7493 b- defN 24-Apr-15 21:54 extern/pybind11/tests/test_iostream.py
--rw-rw-rw-  2.0 fat    13989 b- defN 24-Apr-15 21:54 extern/pybind11/tests/test_kwargs_and_defaults.py
--rw-rw-rw-  2.0 fat     8311 b- defN 24-Apr-15 21:54 extern/pybind11/tests/test_local_bindings.py
--rw-rw-rw-  2.0 fat    18629 b- defN 24-Apr-15 21:54 extern/pybind11/tests/test_methods_and_attributes.py
--rw-rw-rw-  2.0 fat     4160 b- defN 24-Apr-15 21:54 extern/pybind11/tests/test_modules.py
--rw-rw-rw-  2.0 fat    12367 b- defN 24-Apr-15 21:54 extern/pybind11/tests/test_multiple_inheritance.py
--rw-rw-rw-  2.0 fat    21011 b- defN 24-Apr-15 21:54 extern/pybind11/tests/test_numpy_array.py
--rw-rw-rw-  2.0 fat    14712 b- defN 24-Apr-15 21:54 extern/pybind11/tests/test_numpy_dtypes.py
--rw-rw-rw-  2.0 fat     9924 b- defN 24-Apr-15 21:54 extern/pybind11/tests/test_numpy_vectorize.py
--rw-rw-rw-  2.0 fat     1905 b- defN 24-Apr-15 21:54 extern/pybind11/tests/test_opaque_types.py
--rw-rw-rw-  2.0 fat     4483 b- defN 24-Apr-15 21:54 extern/pybind11/tests/test_operator_overloading.py
--rw-rw-rw-  2.0 fat     2813 b- defN 24-Apr-15 21:54 extern/pybind11/tests/test_pickling.py
--rw-rw-rw-  2.0 fat    24514 b- defN 24-Apr-15 21:54 extern/pybind11/tests/test_pytypes.py
--rw-rw-rw-  2.0 fat     8291 b- defN 24-Apr-15 21:54 extern/pybind11/tests/test_sequences_and_iterators.py
--rw-rw-rw-  2.0 fat     9845 b- defN 24-Apr-15 21:54 extern/pybind11/tests/test_smart_ptr.py
--rw-rw-rw-  2.0 fat    12610 b- defN 24-Apr-15 21:54 extern/pybind11/tests/test_stl.py
--rw-rw-rw-  2.0 fat     9475 b- defN 24-Apr-15 21:54 extern/pybind11/tests/test_stl_binders.py
--rw-rw-rw-  2.0 fat      769 b- defN 24-Apr-15 21:54 extern/pybind11/tests/test_tagbased_polymorphic.py
--rw-rw-rw-  2.0 fat      868 b- defN 24-Apr-15 21:54 extern/pybind11/tests/test_thread.py
--rw-rw-rw-  2.0 fat      156 b- defN 24-Apr-15 21:54 extern/pybind11/tests/test_union.py
--rw-rw-rw-  2.0 fat    13371 b- defN 24-Apr-15 21:54 extern/pybind11/tests/test_virtual_functions.py
--rw-rw-rw-  2.0 fat     8582 b- defN 24-Apr-15 21:54 extern/pybind11/tests/extra_python_package/test_files.py
--rw-rw-rw-  2.0 fat     4304 b- defN 24-Apr-15 21:54 extern/pybind11/tests/extra_setuptools/test_setuphelper.py
--rw-rw-rw-  2.0 fat      206 b- defN 24-Apr-15 21:54 extern/pybind11/tests/test_cmake_build/test.py
--rw-rw-rw-  2.0 fat      251 b- defN 24-Apr-15 21:54 extern/pybind11/tests/test_embed/test_interpreter.py
--rw-rw-rw-  2.0 fat      291 b- defN 24-Apr-15 21:54 extern/pybind11/tests/test_embed/test_trampoline.py
--rw-rw-rw-  2.0 fat     1156 b- defN 24-Apr-15 21:54 extern/pybind11/tools/codespell_ignore_lines_from_errors.py
--rw-rw-rw-  2.0 fat     1067 b- defN 24-Apr-15 21:54 extern/pybind11/tools/libsize.py
--rw-rw-rw-  2.0 fat     1373 b- defN 24-Apr-15 21:54 extern/pybind11/tools/make_changelog.py
--rw-rw-rw-  2.0 fat        0 b- defN 24-Apr-15 21:54 tests/detectors/__init__.py
--rw-rw-rw-  2.0 fat     1008 b- defN 24-Apr-15 21:54 tests/detectors/test_coherent_mode.py
--rw-rw-rw-  2.0 fat      761 b- defN 24-Apr-15 21:54 tests/detectors/test_integration_sphere.py
--rw-rw-rw-  2.0 fat      836 b- defN 24-Apr-15 21:54 tests/detectors/test_photodiode.py
--rw-rw-rw-  2.0 fat        0 b- defN 24-Apr-15 21:54 tests/experiments/__init__.py
--rw-rw-rw-  2.0 fat     2171 b- defN 24-Apr-15 21:54 tests/experiments/test_coreshell.py
--rw-rw-rw-  2.0 fat     1637 b- defN 24-Apr-15 21:54 tests/experiments/test_cylinder.py
--rw-rw-rw-  2.0 fat     1705 b- defN 24-Apr-15 21:54 tests/experiments/test_sphere.py
--rw-rw-rw-  2.0 fat        0 b- defN 24-Apr-15 21:54 tests/extra/__init__.py
--rw-rw-rw-  2.0 fat      222 b- defN 24-Apr-15 21:54 tests/extra/test_mesh.py
--rw-rw-rw-  2.0 fat        0 b- defN 24-Apr-15 21:54 tests/scatterers/__init__.py
--rw-rw-rw-  2.0 fat     2952 b- defN 24-Apr-15 21:54 tests/scatterers/test_coreshell.py
--rw-rw-rw-  2.0 fat     2264 b- defN 24-Apr-15 21:54 tests/scatterers/test_cylinder.py
--rw-rw-rw-  2.0 fat     2873 b- defN 24-Apr-15 21:54 tests/scatterers/test_sphere.py
--rw-rw-rw-  2.0 fat        0 b- defN 24-Apr-15 21:54 tests/validation/__init__.py
--rw-rw-rw-  2.0 fat     3155 b- defN 24-Apr-15 21:54 tests/validation/test_coreshell_pymiescatt.py
--rw-rw-rw-  2.0 fat     1990 b- defN 24-Apr-15 21:54 tests/validation/test_detector.py
--rw-rw-rw-  2.0 fat     2180 b- defN 24-Apr-15 21:54 tests/validation/test_sphere_internal.py
--rw-rw-rw-  2.0 fat     2589 b- defN 24-Apr-15 21:54 tests/validation/test_sphere_pymiescatt.py
--rw-rw-rw-  2.0 fat      954 b- defN 24-Apr-15 21:54 tests/validation/test_sphere_scott_prahl.py
--rw-rw-rw-  2.0 fat     1109 b- defN 24-Apr-15 22:05 PyMieSim-1.8.0.dist-info/LICENSE
--rw-rw-rw-  2.0 fat     9453 b- defN 24-Apr-15 22:05 PyMieSim-1.8.0.dist-info/METADATA
--rw-rw-rw-  2.0 fat      102 b- defN 24-Apr-15 22:05 PyMieSim-1.8.0.dist-info/WHEEL
--rw-rw-rw-  2.0 fat       72 b- defN 24-Apr-15 22:05 PyMieSim-1.8.0.dist-info/top_level.txt
--rw-rw-r--  2.0 fat    19745 b- defN 24-Apr-15 22:05 PyMieSim-1.8.0.dist-info/RECORD
-203 files, 17374095 bytes uncompressed, 7991916 bytes compressed:  54.0%
+Zip file size: 8046718 bytes, number of entries: 203
+-rw-rw-rw-  2.0 fat        7 b- defN 24-Apr-18 17:13 PyMieSim/VERSION
+-rw-rw-rw-  2.0 fat        0 b- defN 24-Apr-18 17:13 PyMieSim/__init__.py
+-rw-rw-rw-  2.0 fat      230 b- defN 24-Apr-18 17:13 PyMieSim/__main__.py
+-rw-rw-rw-  2.0 fat      464 b- defN 24-Apr-18 17:13 PyMieSim/materials.py
+-rw-rw-rw-  2.0 fat     3780 b- defN 24-Apr-18 17:13 PyMieSim/measure.py
+-rw-rw-rw-  2.0 fat     7864 b- defN 24-Apr-18 17:13 PyMieSim/mesh.py
+-rw-rw-rw-  2.0 fat     1988 b- defN 24-Apr-18 17:13 PyMieSim/physics.py
+-rw-rw-rw-  2.0 fat     2084 b- defN 24-Apr-18 17:13 PyMieSim/polarization.py
+-rw-rw-rw-  2.0 fat   818688 b- defN 24-Apr-18 17:17 PyMieSim/binary/CoreShellInterface.cp310-win_amd64.pyd
+-rw-rw-rw-  2.0 fat   818176 b- defN 24-Apr-18 17:21 PyMieSim/binary/CoreShellInterface.cp311-win_amd64.pyd
+-rw-rw-rw-  2.0 fat   818688 b- defN 24-Apr-18 17:24 PyMieSim/binary/CoreShellInterface.cp312-win_amd64.pyd
+-rw-rw-rw-  2.0 fat   802816 b- defN 24-Apr-18 17:17 PyMieSim/binary/CylinderInterface.cp310-win_amd64.pyd
+-rw-rw-rw-  2.0 fat   802816 b- defN 24-Apr-18 17:21 PyMieSim/binary/CylinderInterface.cp311-win_amd64.pyd
+-rw-rw-rw-  2.0 fat   802816 b- defN 24-Apr-18 17:24 PyMieSim/binary/CylinderInterface.cp312-win_amd64.pyd
+-rw-rw-rw-  2.0 fat   842240 b- defN 24-Apr-18 17:17 PyMieSim/binary/DetectorInterface.cp310-win_amd64.pyd
+-rw-rw-rw-  2.0 fat   842240 b- defN 24-Apr-18 17:21 PyMieSim/binary/DetectorInterface.cp311-win_amd64.pyd
+-rw-rw-rw-  2.0 fat   842240 b- defN 24-Apr-18 17:24 PyMieSim/binary/DetectorInterface.cp312-win_amd64.pyd
+-rw-rw-rw-  2.0 fat   945152 b- defN 24-Apr-18 17:17 PyMieSim/binary/Experiment.cp310-win_amd64.pyd
+-rw-rw-rw-  2.0 fat   945152 b- defN 24-Apr-18 17:21 PyMieSim/binary/Experiment.cp311-win_amd64.pyd
+-rw-rw-rw-  2.0 fat   946688 b- defN 24-Apr-18 17:24 PyMieSim/binary/Experiment.cp312-win_amd64.pyd
+-rw-rw-rw-  2.0 fat   358912 b- defN 24-Apr-18 17:17 PyMieSim/binary/Fibonacci.cp310-win_amd64.pyd
+-rw-rw-rw-  2.0 fat   358912 b- defN 24-Apr-18 17:21 PyMieSim/binary/Fibonacci.cp311-win_amd64.pyd
+-rw-rw-rw-  2.0 fat   358400 b- defN 24-Apr-18 17:24 PyMieSim/binary/Fibonacci.cp312-win_amd64.pyd
+-rw-rw-rw-  2.0 fat   850944 b- defN 24-Apr-18 17:17 PyMieSim/binary/Sets.cp310-win_amd64.pyd
+-rw-rw-rw-  2.0 fat   850432 b- defN 24-Apr-18 17:21 PyMieSim/binary/Sets.cp311-win_amd64.pyd
+-rw-rw-rw-  2.0 fat   849920 b- defN 24-Apr-18 17:24 PyMieSim/binary/Sets.cp312-win_amd64.pyd
+-rw-rw-rw-  2.0 fat   818688 b- defN 24-Apr-18 17:17 PyMieSim/binary/SphereInterface.cp310-win_amd64.pyd
+-rw-rw-rw-  2.0 fat   818688 b- defN 24-Apr-18 17:21 PyMieSim/binary/SphereInterface.cp311-win_amd64.pyd
+-rw-rw-rw-  2.0 fat   819200 b- defN 24-Apr-18 17:24 PyMieSim/binary/SphereInterface.cp312-win_amd64.pyd
+-rw-rw-rw-  2.0 fat        0 b- defN 24-Apr-18 17:13 PyMieSim/binary/__init__.py
+-rw-rw-rw-  2.0 fat   133174 b- defN 24-Apr-18 17:24 PyMieSim/binary/libZBessel.a
+-rw-rw-rw-  2.0 fat      165 b- defN 24-Apr-18 17:13 PyMieSim/experiment/__init__.py
+-rw-rw-rw-  2.0 fat    11930 b- defN 24-Apr-18 17:13 PyMieSim/experiment/detector.py
+-rw-rw-rw-  2.0 fat    16798 b- defN 24-Apr-18 17:13 PyMieSim/experiment/scatterer.py
+-rw-rw-rw-  2.0 fat     5268 b- defN 24-Apr-18 17:13 PyMieSim/experiment/setup.py
+-rw-rw-rw-  2.0 fat     5540 b- defN 24-Apr-18 17:13 PyMieSim/experiment/source.py
+-rw-rw-rw-  2.0 fat      143 b- defN 24-Apr-18 17:13 PyMieSim/gui/__init__.py
+-rw-rw-rw-  2.0 fat     3251 b- defN 24-Apr-18 17:13 PyMieSim/gui/axis_tab.py
+-rw-rw-rw-  2.0 fat     3382 b- defN 24-Apr-18 17:13 PyMieSim/gui/base_tab.py
+-rw-rw-rw-  2.0 fat     6162 b- defN 24-Apr-18 17:13 PyMieSim/gui/detector_tab.py
+-rw-rw-rw-  2.0 fat     7715 b- defN 24-Apr-18 17:13 PyMieSim/gui/main_window.py
+-rw-rw-rw-  2.0 fat     6876 b- defN 24-Apr-18 17:13 PyMieSim/gui/scatterer_tab.py
+-rw-rw-rw-  2.0 fat     2560 b- defN 24-Apr-18 17:13 PyMieSim/gui/source_tab.py
+-rw-rw-rw-  2.0 fat    10629 b- defN 24-Apr-18 17:13 PyMieSim/gui/utils.py
+-rw-rw-rw-  2.0 fat        0 b- defN 24-Apr-18 17:13 PyMieSim/modes/__init__.py
+-rw-rw-rw-  2.0 fat     4320 b- defN 24-Apr-18 17:13 PyMieSim/modes/hermite_gauss.py
+-rw-rw-rw-  2.0 fat     4395 b- defN 24-Apr-18 17:13 PyMieSim/modes/laguerre_gauss.py
+-rw-rw-rw-  2.0 fat     4073 b- defN 24-Apr-18 17:13 PyMieSim/modes/linearly_polarized.py
+-rw-rw-rw-  2.0 fat      139 b- defN 24-Apr-18 17:13 PyMieSim/single/__init__.py
+-rw-rw-rw-  2.0 fat    11561 b- defN 24-Apr-18 17:13 PyMieSim/single/detector.py
+-rw-rw-rw-  2.0 fat    19695 b- defN 24-Apr-18 17:13 PyMieSim/single/representations.py
+-rw-rw-rw-  2.0 fat    20233 b- defN 24-Apr-18 17:13 PyMieSim/single/scatterer.py
+-rw-rw-rw-  2.0 fat     5579 b- defN 24-Apr-18 17:13 PyMieSim/single/source.py
+-rw-rw-rw-  2.0 fat        0 b- defN 24-Apr-18 17:13 PyMieSim/tools/__init__.py
+-rw-rw-rw-  2.0 fat     1184 b- defN 24-Apr-18 17:13 PyMieSim/tools/directories.py
+-rw-rw-rw-  2.0 fat     6229 b- defN 24-Apr-18 17:13 PyMieSim/tools/special_functions.py
+-rw-rw-rw-  2.0 fat    10073 b- defN 24-Apr-18 17:13 PyMieSim/validation_data/Figure810BH.csv
+-rw-rw-rw-  2.0 fat    40002 b- defN 24-Apr-18 17:13 PyMieSim/validation_data/Figure87BH.csv
+-rw-rw-rw-  2.0 fat    40002 b- defN 24-Apr-18 17:13 PyMieSim/validation_data/Figure88BH.csv
+-rw-rw-rw-  2.0 fat    20800 b- defN 24-Apr-18 17:13 PyMieSim/validation_data/PyMieScattQsca.csv
+-rw-rw-rw-  2.0 fat    10400 b- defN 24-Apr-18 17:13 PyMieSim/validation_data/PyMieScattQscaCoreShell.csv
+-rw-rw-rw-  2.0 fat    10400 b- defN 24-Apr-18 17:13 PyMieSim/validation_data/PyMieScattQscaCoreShellMedium.csv
+-rw-rw-rw-  2.0 fat    20800 b- defN 24-Apr-18 17:13 PyMieSim/validation_data/PyMieScattQscaMedium.csv
+-rw-rw-rw-  2.0 fat      732 b- defN 24-Apr-18 17:13 development/LPMOdes.py
+-rw-rw-rw-  2.0 fat    13670 b- defN 24-Apr-18 17:13 development/gui.py
+-rw-rw-rw-  2.0 fat      906 b- defN 24-Apr-18 17:13 docs/examples/detector/plot_HG01.py
+-rw-rw-rw-  2.0 fat      906 b- defN 24-Apr-18 17:13 docs/examples/detector/plot_HG11.py
+-rw-rw-rw-  2.0 fat      913 b- defN 24-Apr-18 17:13 docs/examples/detector/plot_LG11.py
+-rw-rw-rw-  2.0 fat      885 b- defN 24-Apr-18 17:13 docs/examples/detector/plot_LP01.py
+-rw-rw-rw-  2.0 fat      702 b- defN 24-Apr-18 17:13 docs/examples/detector/plot_LP02.py
+-rw-rw-rw-  2.0 fat      701 b- defN 24-Apr-18 17:13 docs/examples/detector/plot_LP11.py
+-rw-rw-rw-  2.0 fat      559 b- defN 24-Apr-18 17:13 docs/examples/detector/plot_integrating_sphere.py
+-rw-rw-rw-  2.0 fat      666 b- defN 24-Apr-18 17:13 docs/examples/detector/plot_photodiode.py
+-rw-rw-rw-  2.0 fat     1910 b- defN 24-Apr-18 17:13 docs/examples/experiment/plot_coreshell_Qback_vs_corediameter.py
+-rw-rw-rw-  2.0 fat     2160 b- defN 24-Apr-18 17:13 docs/examples/experiment/plot_coreshell_a1_vs_corediameter.py
+-rw-rw-rw-  2.0 fat     2052 b- defN 24-Apr-18 17:13 docs/examples/experiment/plot_coreshell_b1_vs_corediameter.py
+-rw-rw-rw-  2.0 fat     2198 b- defN 24-Apr-18 17:13 docs/examples/experiment/plot_coreshell_coupling_vs_corediameter.py
+-rw-rw-rw-  2.0 fat     1880 b- defN 24-Apr-18 17:13 docs/examples/experiment/plot_cylinder_Qabs_vs_diameter.py
+-rw-rw-rw-  2.0 fat     1656 b- defN 24-Apr-18 17:13 docs/examples/experiment/plot_cylinder_Qsca_vs_diameter.py
+-rw-rw-rw-  2.0 fat     1649 b- defN 24-Apr-18 17:13 docs/examples/experiment/plot_cylinder_Qsca_vs_index.py
+-rw-rw-rw-  2.0 fat     1980 b- defN 24-Apr-18 17:13 docs/examples/experiment/plot_cylinder_Qsca_vs_wavelength.py
+-rw-rw-rw-  2.0 fat     1177 b- defN 24-Apr-18 17:13 docs/examples/experiment/plot_cylinder_Qsca_vs_wavelength_std.py
+-rw-rw-rw-  2.0 fat     1626 b- defN 24-Apr-18 17:13 docs/examples/experiment/plot_cylinder_a11_vs_diameter.py
+-rw-rw-rw-  2.0 fat     1539 b- defN 24-Apr-18 17:13 docs/examples/experiment/plot_cylinder_b11_vs_diameter.py
+-rw-rw-rw-  2.0 fat     2057 b- defN 24-Apr-18 17:13 docs/examples/experiment/plot_cylinder_coupling_vs_diameter.py
+-rw-rw-rw-  2.0 fat     2079 b- defN 24-Apr-18 17:13 docs/examples/experiment/plot_cylinder_coupling_vs_phioffset.py
+-rw-rw-rw-  2.0 fat     2242 b- defN 24-Apr-18 17:13 docs/examples/experiment/plot_cylinder_coupling_vs_wavelength.py
+-rw-rw-rw-  2.0 fat     1129 b- defN 24-Apr-18 17:13 docs/examples/experiment/plot_sphere_Qabs_vs_diameter.py
+-rw-rw-rw-  2.0 fat     1056 b- defN 24-Apr-18 17:13 docs/examples/experiment/plot_sphere_Qsca_vs_diameter.py
+-rw-rw-rw-  2.0 fat     1039 b- defN 24-Apr-18 17:13 docs/examples/experiment/plot_sphere_Qsca_vs_index.py
+-rw-rw-rw-  2.0 fat     1067 b- defN 24-Apr-18 17:13 docs/examples/experiment/plot_sphere_Qsca_vs_wavelength.py
+-rw-rw-rw-  2.0 fat     1174 b- defN 24-Apr-18 17:13 docs/examples/experiment/plot_sphere_Qsca_vs_wavelength_std.py
+-rw-rw-rw-  2.0 fat     1052 b- defN 24-Apr-18 17:13 docs/examples/experiment/plot_sphere_a1_vs_diameter.py
+-rw-rw-rw-  2.0 fat     1049 b- defN 24-Apr-18 17:13 docs/examples/experiment/plot_sphere_b1_vs_diameter.py
+-rw-rw-rw-  2.0 fat     1412 b- defN 24-Apr-18 17:13 docs/examples/experiment/plot_sphere_coupling_vs_diameter.py
+-rw-rw-rw-  2.0 fat     1472 b- defN 24-Apr-18 17:13 docs/examples/experiment/plot_sphere_coupling_vs_filter.py
+-rw-rw-rw-  2.0 fat     1390 b- defN 24-Apr-18 17:13 docs/examples/experiment/plot_sphere_coupling_vs_phioffset.py
+-rw-rw-rw-  2.0 fat     1460 b- defN 24-Apr-18 17:13 docs/examples/experiment/plot_sphere_coupling_vs_wavelength.py
+-rw-rw-rw-  2.0 fat     1033 b- defN 24-Apr-18 17:13 docs/examples/extras/SphereProperties.py
+-rw-rw-rw-  2.0 fat     1632 b- defN 24-Apr-18 17:13 docs/examples/extras/plot_Qsca_vs_permittivity_vs_size_parameter.py
+-rw-rw-rw-  2.0 fat     1792 b- defN 24-Apr-18 17:13 docs/examples/extras/plot_coupling_heatmap.py
+-rw-rw-rw-  2.0 fat     1052 b- defN 24-Apr-18 17:13 docs/examples/scatterer/plot_farfield.py
+-rw-rw-rw-  2.0 fat     1367 b- defN 24-Apr-18 17:13 docs/examples/scatterer/plot_footprint.py
+-rw-rw-rw-  2.0 fat      940 b- defN 24-Apr-18 17:13 docs/examples/scatterer/plot_s1s2.py
+-rw-rw-rw-  2.0 fat      593 b- defN 24-Apr-18 17:13 docs/examples/scatterer/plot_source.py
+-rw-rw-rw-  2.0 fat     1003 b- defN 24-Apr-18 17:13 docs/examples/scatterer/plot_spf.py
+-rw-rw-rw-  2.0 fat      946 b- defN 24-Apr-18 17:13 docs/examples/scatterer/plot_stokes.py
+-rw-rw-rw-  2.0 fat     1219 b- defN 24-Apr-18 17:13 docs/examples/validation/plot_BH810.py
+-rw-rw-rw-  2.0 fat     1670 b- defN 24-Apr-18 17:13 docs/examples/validation/plot_BH87.py
+-rw-rw-rw-  2.0 fat     2692 b- defN 24-Apr-18 17:13 docs/examples/validation/plot_BH88.py
+-rw-rw-rw-  2.0 fat     2763 b- defN 24-Apr-18 17:13 docs/examples/validation/plot_phase_function_detector.py
+-rw-rw-rw-  2.0 fat     1966 b- defN 24-Apr-18 17:13 docs/examples/validation/plot_pymiescatt_0.py
+-rw-rw-rw-  2.0 fat     2046 b- defN 24-Apr-18 17:13 docs/examples/validation/plot_pymiescatt_1.py
+-rw-rw-rw-  2.0 fat     2242 b- defN 24-Apr-18 17:13 docs/examples/validation/plot_pymiescatt_2.py
+-rw-rw-rw-  2.0 fat     2344 b- defN 24-Apr-18 17:13 docs/examples/validation/plot_pymiescatt_3.py
+-rw-rw-rw-  2.0 fat     4717 b- defN 24-Apr-18 17:13 docs/source/conf.py
+-rw-rw-rw-  2.0 fat     2872 b- defN 24-Apr-18 17:13 extern/pybind11/noxfile.py
+-rw-rw-rw-  2.0 fat     5027 b- defN 24-Apr-18 17:13 extern/pybind11/setup.py
+-rw-rw-rw-  2.0 fat     2943 b- defN 24-Apr-18 17:13 extern/pybind11/docs/benchmark.py
+-rw-rw-rw-  2.0 fat    11942 b- defN 24-Apr-18 17:13 extern/pybind11/docs/conf.py
+-rw-rw-rw-  2.0 fat      446 b- defN 24-Apr-18 17:13 extern/pybind11/pybind11/__init__.py
+-rw-rw-rw-  2.0 fat     1606 b- defN 24-Apr-18 17:13 extern/pybind11/pybind11/__main__.py
+-rw-rw-rw-  2.0 fat      245 b- defN 24-Apr-18 17:13 extern/pybind11/pybind11/_version.py
+-rw-rw-rw-  2.0 fat     1244 b- defN 24-Apr-18 17:13 extern/pybind11/pybind11/commands.py
+-rw-rw-rw-  2.0 fat        0 b- defN 24-Apr-18 17:13 extern/pybind11/pybind11/py.typed
+-rw-rw-rw-  2.0 fat    18134 b- defN 24-Apr-18 17:13 extern/pybind11/pybind11/setup_helpers.py
+-rw-rw-rw-  2.0 fat     5847 b- defN 24-Apr-18 17:13 extern/pybind11/tests/conftest.py
+-rw-rw-rw-  2.0 fat      953 b- defN 24-Apr-18 17:13 extern/pybind11/tests/env.py
+-rw-rw-rw-  2.0 fat      560 b- defN 24-Apr-18 17:13 extern/pybind11/tests/test_async.py
+-rw-rw-rw-  2.0 fat     5012 b- defN 24-Apr-18 17:13 extern/pybind11/tests/test_buffers.py
+-rw-rw-rw-  2.0 fat    17771 b- defN 24-Apr-18 17:13 extern/pybind11/tests/test_builtin_casters.py
+-rw-rw-rw-  2.0 fat     6796 b- defN 24-Apr-18 17:13 extern/pybind11/tests/test_call_policies.py
+-rw-rw-rw-  2.0 fat     7014 b- defN 24-Apr-18 17:13 extern/pybind11/tests/test_callbacks.py
+-rw-rw-rw-  2.0 fat     5896 b- defN 24-Apr-18 17:13 extern/pybind11/tests/test_chrono.py
+-rw-rw-rw-  2.0 fat    15242 b- defN 24-Apr-18 17:13 extern/pybind11/tests/test_class.py
+-rw-rw-rw-  2.0 fat      622 b- defN 24-Apr-18 17:13 extern/pybind11/tests/test_const_name.py
+-rw-rw-rw-  2.0 fat     1550 b- defN 24-Apr-18 17:13 extern/pybind11/tests/test_constants_and_functions.py
+-rw-rw-rw-  2.0 fat     4928 b- defN 24-Apr-18 17:13 extern/pybind11/tests/test_copy_move.py
+-rw-rw-rw-  2.0 fat     4114 b- defN 24-Apr-18 17:13 extern/pybind11/tests/test_custom_type_casters.py
+-rw-rw-rw-  2.0 fat     1139 b- defN 24-Apr-18 17:13 extern/pybind11/tests/test_custom_type_setup.py
+-rw-rw-rw-  2.0 fat     2487 b- defN 24-Apr-18 17:13 extern/pybind11/tests/test_docstring_options.py
+-rw-rw-rw-  2.0 fat    29835 b- defN 24-Apr-18 17:13 extern/pybind11/tests/test_eigen_matrix.py
+-rw-rw-rw-  2.0 fat     9702 b- defN 24-Apr-18 17:13 extern/pybind11/tests/test_eigen_tensor.py
+-rw-rw-rw-  2.0 fat     9205 b- defN 24-Apr-18 17:13 extern/pybind11/tests/test_enum.py
+-rw-rw-rw-  2.0 fat     1193 b- defN 24-Apr-18 17:13 extern/pybind11/tests/test_eval.py
+-rw-rw-rw-  2.0 fat      123 b- defN 24-Apr-18 17:13 extern/pybind11/tests/test_eval_call.py
+-rw-rw-rw-  2.0 fat    13389 b- defN 24-Apr-18 17:13 extern/pybind11/tests/test_exceptions.py
+-rw-rw-rw-  2.0 fat    17007 b- defN 24-Apr-18 17:13 extern/pybind11/tests/test_factory_constructors.py
+-rw-rw-rw-  2.0 fat     8749 b- defN 24-Apr-18 17:13 extern/pybind11/tests/test_gil_scoped.py
+-rw-rw-rw-  2.0 fat     7493 b- defN 24-Apr-18 17:13 extern/pybind11/tests/test_iostream.py
+-rw-rw-rw-  2.0 fat    13989 b- defN 24-Apr-18 17:13 extern/pybind11/tests/test_kwargs_and_defaults.py
+-rw-rw-rw-  2.0 fat     8311 b- defN 24-Apr-18 17:13 extern/pybind11/tests/test_local_bindings.py
+-rw-rw-rw-  2.0 fat    18629 b- defN 24-Apr-18 17:13 extern/pybind11/tests/test_methods_and_attributes.py
+-rw-rw-rw-  2.0 fat     4160 b- defN 24-Apr-18 17:13 extern/pybind11/tests/test_modules.py
+-rw-rw-rw-  2.0 fat    12367 b- defN 24-Apr-18 17:13 extern/pybind11/tests/test_multiple_inheritance.py
+-rw-rw-rw-  2.0 fat    21011 b- defN 24-Apr-18 17:13 extern/pybind11/tests/test_numpy_array.py
+-rw-rw-rw-  2.0 fat    14712 b- defN 24-Apr-18 17:13 extern/pybind11/tests/test_numpy_dtypes.py
+-rw-rw-rw-  2.0 fat     9924 b- defN 24-Apr-18 17:13 extern/pybind11/tests/test_numpy_vectorize.py
+-rw-rw-rw-  2.0 fat     1905 b- defN 24-Apr-18 17:13 extern/pybind11/tests/test_opaque_types.py
+-rw-rw-rw-  2.0 fat     4483 b- defN 24-Apr-18 17:13 extern/pybind11/tests/test_operator_overloading.py
+-rw-rw-rw-  2.0 fat     2813 b- defN 24-Apr-18 17:13 extern/pybind11/tests/test_pickling.py
+-rw-rw-rw-  2.0 fat    24514 b- defN 24-Apr-18 17:13 extern/pybind11/tests/test_pytypes.py
+-rw-rw-rw-  2.0 fat     8291 b- defN 24-Apr-18 17:13 extern/pybind11/tests/test_sequences_and_iterators.py
+-rw-rw-rw-  2.0 fat     9845 b- defN 24-Apr-18 17:13 extern/pybind11/tests/test_smart_ptr.py
+-rw-rw-rw-  2.0 fat    12610 b- defN 24-Apr-18 17:13 extern/pybind11/tests/test_stl.py
+-rw-rw-rw-  2.0 fat     9475 b- defN 24-Apr-18 17:13 extern/pybind11/tests/test_stl_binders.py
+-rw-rw-rw-  2.0 fat      769 b- defN 24-Apr-18 17:13 extern/pybind11/tests/test_tagbased_polymorphic.py
+-rw-rw-rw-  2.0 fat      868 b- defN 24-Apr-18 17:13 extern/pybind11/tests/test_thread.py
+-rw-rw-rw-  2.0 fat      156 b- defN 24-Apr-18 17:13 extern/pybind11/tests/test_union.py
+-rw-rw-rw-  2.0 fat    13371 b- defN 24-Apr-18 17:13 extern/pybind11/tests/test_virtual_functions.py
+-rw-rw-rw-  2.0 fat     8582 b- defN 24-Apr-18 17:13 extern/pybind11/tests/extra_python_package/test_files.py
+-rw-rw-rw-  2.0 fat     4304 b- defN 24-Apr-18 17:13 extern/pybind11/tests/extra_setuptools/test_setuphelper.py
+-rw-rw-rw-  2.0 fat      206 b- defN 24-Apr-18 17:13 extern/pybind11/tests/test_cmake_build/test.py
+-rw-rw-rw-  2.0 fat      251 b- defN 24-Apr-18 17:13 extern/pybind11/tests/test_embed/test_interpreter.py
+-rw-rw-rw-  2.0 fat      291 b- defN 24-Apr-18 17:13 extern/pybind11/tests/test_embed/test_trampoline.py
+-rw-rw-rw-  2.0 fat     1156 b- defN 24-Apr-18 17:13 extern/pybind11/tools/codespell_ignore_lines_from_errors.py
+-rw-rw-rw-  2.0 fat     1067 b- defN 24-Apr-18 17:13 extern/pybind11/tools/libsize.py
+-rw-rw-rw-  2.0 fat     1373 b- defN 24-Apr-18 17:13 extern/pybind11/tools/make_changelog.py
+-rw-rw-rw-  2.0 fat        0 b- defN 24-Apr-18 17:13 tests/detectors/__init__.py
+-rw-rw-rw-  2.0 fat     1012 b- defN 24-Apr-18 17:13 tests/detectors/test_coherent_mode.py
+-rw-rw-rw-  2.0 fat      765 b- defN 24-Apr-18 17:13 tests/detectors/test_integration_sphere.py
+-rw-rw-rw-  2.0 fat      840 b- defN 24-Apr-18 17:13 tests/detectors/test_photodiode.py
+-rw-rw-rw-  2.0 fat        0 b- defN 24-Apr-18 17:13 tests/experiments/__init__.py
+-rw-rw-rw-  2.0 fat     2871 b- defN 24-Apr-18 17:13 tests/experiments/test_coreshell.py
+-rw-rw-rw-  2.0 fat     2256 b- defN 24-Apr-18 17:13 tests/experiments/test_cylinder.py
+-rw-rw-rw-  2.0 fat     2337 b- defN 24-Apr-18 17:13 tests/experiments/test_sphere.py
+-rw-rw-rw-  2.0 fat        0 b- defN 24-Apr-18 17:13 tests/extra/__init__.py
+-rw-rw-rw-  2.0 fat      222 b- defN 24-Apr-18 17:13 tests/extra/test_mesh.py
+-rw-rw-rw-  2.0 fat        0 b- defN 24-Apr-18 17:13 tests/scatterers/__init__.py
+-rw-rw-rw-  2.0 fat     3535 b- defN 24-Apr-18 17:13 tests/scatterers/test_coreshell.py
+-rw-rw-rw-  2.0 fat     2658 b- defN 24-Apr-18 17:13 tests/scatterers/test_cylinder.py
+-rw-rw-rw-  2.0 fat     3107 b- defN 24-Apr-18 17:13 tests/scatterers/test_sphere.py
+-rw-rw-rw-  2.0 fat        0 b- defN 24-Apr-18 17:13 tests/validation/__init__.py
+-rw-rw-rw-  2.0 fat     3147 b- defN 24-Apr-18 17:13 tests/validation/test_coreshell_pymiescatt.py
+-rw-rw-rw-  2.0 fat     1994 b- defN 24-Apr-18 17:13 tests/validation/test_detector.py
+-rw-rw-rw-  2.0 fat     2180 b- defN 24-Apr-18 17:13 tests/validation/test_sphere_internal.py
+-rw-rw-rw-  2.0 fat     2581 b- defN 24-Apr-18 17:13 tests/validation/test_sphere_pymiescatt.py
+-rw-rw-rw-  2.0 fat      954 b- defN 24-Apr-18 17:13 tests/validation/test_sphere_scott_prahl.py
+-rw-rw-rw-  2.0 fat     1109 b- defN 24-Apr-18 17:24 PyMieSim-1.8.1.dist-info/LICENSE
+-rw-rw-rw-  2.0 fat     9453 b- defN 24-Apr-18 17:24 PyMieSim-1.8.1.dist-info/METADATA
+-rw-rw-rw-  2.0 fat      102 b- defN 24-Apr-18 17:24 PyMieSim-1.8.1.dist-info/WHEEL
+-rw-rw-rw-  2.0 fat       72 b- defN 24-Apr-18 17:24 PyMieSim-1.8.1.dist-info/top_level.txt
+-rw-rw-r--  2.0 fat    19745 b- defN 24-Apr-18 17:24 PyMieSim-1.8.1.dist-info/RECORD
+203 files, 17355324 bytes uncompressed, 8014820 bytes compressed:  53.8%
```

## zipnote {}

```diff
@@ -588,23 +588,23 @@
 
 Filename: tests/validation/test_sphere_pymiescatt.py
 Comment: 
 
 Filename: tests/validation/test_sphere_scott_prahl.py
 Comment: 
 
-Filename: PyMieSim-1.8.0.dist-info/LICENSE
+Filename: PyMieSim-1.8.1.dist-info/LICENSE
 Comment: 
 
-Filename: PyMieSim-1.8.0.dist-info/METADATA
+Filename: PyMieSim-1.8.1.dist-info/METADATA
 Comment: 
 
-Filename: PyMieSim-1.8.0.dist-info/WHEEL
+Filename: PyMieSim-1.8.1.dist-info/WHEEL
 Comment: 
 
-Filename: PyMieSim-1.8.0.dist-info/top_level.txt
+Filename: PyMieSim-1.8.1.dist-info/top_level.txt
 Comment: 
 
-Filename: PyMieSim-1.8.0.dist-info/RECORD
+Filename: PyMieSim-1.8.1.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## PyMieSim/VERSION

```diff
@@ -1 +1 @@
-1.8.0
+1.8.1
```

## PyMieSim/materials.py

```diff
@@ -8,10 +8,11 @@
 SodaLimeGlass = DataMeasurement('sodalimeglass')
 Silver = DataMeasurement('silver')
 Gold = DataMeasurement('gold')
 Aluminium = DataMeasurement('aluminium')
 SI = Sellmeier('silica')
 SIO2 = DataMeasurement('sio2')
 TIO2 = DataMeasurement('tio2')
+Polystyrene = DataMeasurement('polystyrene')
 
 
 # -
```

## PyMieSim/binary/libZBessel.a

### file list

```diff
@@ -1,5 +1,5 @@
-----------   0        0        0      564 2024-04-15 22:05:00.000000 /
+----------   0        0        0      564 2024-04-18 17:24:29.000000 /
 ----------   0        0        0        0 1970-01-01 00:00:00.000000 //
--rw-rw-rw-   0        0        0     2312 2024-04-15 22:04:58.000000 amos_iso_c_fortran_wrapper.f90.obj
--rw-rw-rw-   0        0        0     7208 2024-04-15 22:04:59.000000 machine.for.obj
--rw-rw-rw-   0        0        0   122746 2024-04-15 22:05:00.000000 zbesh.for.obj
+-rw-rw-rw-   0        0        0     2312 2024-04-18 17:24:27.000000 amos_iso_c_fortran_wrapper.f90.obj
+-rw-rw-rw-   0        0        0     7208 2024-04-18 17:24:27.000000 machine.for.obj
+-rw-rw-rw-   0        0        0   122746 2024-04-18 17:24:29.000000 zbesh.for.obj
```

## PyMieSim/experiment/detector.py

```diff
@@ -52,35 +52,39 @@
         Initializes and prepares the detector instance by formatting inputs, computing field arrays,
         determining rotation angles, building parameters for visualization, and initializing C++ bindings.
         This method is automatically called after the class has been initialized.
 
         Returns:
             NoReturn
         """
-        self.format_inputs()
+        self.mapping = {
+            'scalarfield': None,
+            'NA': None,
+            'phi_offset': None,
+            'gamma_offset': None,
+            'polarization_filter': None,
+        }
 
         self.compute_scalar_fields()
 
         self.get_rotation_angle_from_mode_number()
 
         self.initialize_binding()
 
-        self.build_x_parameters()
-
     def get_rotation_angle_from_mode_number(self) -> NoReturn:
         """
         Computes the rotation angle from the mode number for CoherentMode detectors; for others, sets it to zero.
         This method establishes the orientation of the detector based on its mode number, which is crucial
         for accurate simulation of light detection.
 
         Returns:
             NoReturn
         """
         if self.name.lower() == 'photodiode':
-            self.rotation_angle = numpy.zeros(self.scalarfield.base_values.size)
+            self.rotation_angle = numpy.zeros(self.scalar_fields.size)
             return
 
         rotation_angle_list = []
 
         self.mode_number = [
             mode if ":" in mode else mode + ":00" for mode in self.mode_number
         ]
@@ -88,121 +92,103 @@
         for mode_number in self.mode_number:
             _, rotation_angle = mode_number.split(':')
 
             rotation_angle_list.append(rotation_angle)
 
         self.rotation_angle = numpy.asarray(rotation_angle_list).astype(float)
 
-    def format_inputs(self) -> NoReturn:
-        """
-        Formats the input attributes (NA, phi_offset, gamma_offset, polarization_filter) into numpy arrays
-        for further processing. This ensures that all input parameters are correctly structured for the
-        simulation and C++ binding processes.
-
-        Returns:
-            NoReturn
-        """
-        self.NA = numpy.atleast_1d(self.NA).astype(float)
-        self.phi_offset = numpy.atleast_1d(self.phi_offset).astype(float)
-        self.gamma_offset = numpy.atleast_1d(self.gamma_offset).astype(float)
-        self.polarization_filter = numpy.atleast_1d(self.polarization_filter).astype(float)
-
     def bind_to_experiment(self, experiment: Setup) -> NoReturn:
         """
         Binds this detector to a specified experimental setup, integrating it into the simulation workflow.
 
         Parameters:
             experiment (Setup): The experimental setup to which the detector will be bound.
 
         Returns:
             NoReturn
         """
         experiment.binding.set_detector(self.binding)
 
-    def build_x_parameters(self) -> NoReturn:
+    def get_datavisual_table(self) -> NoReturn:
         """
-        Constructs the BaseUnit for visualization, translating the detector's attributes into a format
-        suitable for inclusion in data visualization tools. This facilitates the graphical representation
-        of simulation results.
+        Appends the scatterer's properties to a given table for visualization purposes. This enables the
+        representation of scatterer properties in graphical formats.
+
+        Parameters:
+            table (list): The table to which the scatterer's properties will be appended.
 
         Returns:
-            NoReturn
+            list: The updated table with the scatterer's properties included.
         """
-        self.NA = units.Index(
+
+        self.mapping['scalarfield'] = units.Custom(
+            long_label='Field',
+            short_label='field',
+            base_values=self.scalar_fields,
+            value_representation=self.detector_name
+        )
+
+        self.mapping['NA'] = units.Index(
             long_label='Numerical aperture',
             short_label='NA',
-            base_values=numpy.array(self.NA),
+            base_values=self.NA,
             use_prefix=False,
             string_format=""
         )
 
-        self.gamma_offset = units.Degree(
-            long_label='Gamma angle',
+        self.mapping['phi_offset'] = units.Degree(
+            long_label='Phi angle',
             short_label=r'$\phi_{offset}$',
-            base_values=numpy.array(self.gamma_offset),
+            base_values=self.phi_offset,
             use_prefix=False,
             string_format='.1f'
         )
 
-        self.phi_offset = units.Degree(
-            long_label='Phi angle',
+        self.mapping['gamma_offset'] = units.Degree(
+            long_label='Gamma angle',
             short_label=r'$\phi_{offset}$',
-            base_values=numpy.array(self.phi_offset),
+            base_values=self.gamma_offset,
             use_prefix=False,
             string_format='.1f'
         )
 
-        self.polarization_filter = units.Degree(
+        self.mapping['polarization_filter'] = units.Degree(
             long_label=r'Polarization filter',
             short_label=r'f$_{pol}$',
-            base_values=numpy.array(self.polarization_filter),
+            base_values=self.polarization_filter,
             use_prefix=False,
             string_format='.1f'
         )
 
-    def append_to_table(self, table: list) -> list:
-        """
-        Appends the detector's attributes to a given visualization table.
-
-        Parameters:
-            table (list): The table to which the detector's attributes will be appended.
-
-        Returns:
-            list: The updated table with the detector's attributes included.
-        """
-        return [*table, self.scalarfield, self.NA, self.phi_offset, self.gamma_offset, self.polarization_filter]
+        return [v for k, v in self.mapping.items() if v is not None]
 
     def initialize_binding(self) -> NoReturn:
         """
         Initializes the C++ binding for the detector, configuring it with the necessary parameters for
         simulation. This step is essential for integrating the Python-defined detector with the underlying
         C++ simulation engine.
 
         Returns:
             NoReturn
         """
         point_coupling = True if self.coupling_mode == 'point' else False
 
-        phi_offset_rad = numpy.deg2rad(self.phi_offset)
-
-        gamma_offset_rad = numpy.deg2rad(self.gamma_offset)
-
-        polarization_filter_rad = numpy.deg2rad(self.polarization_filter)
-
-        self.binding = CppDetectorSet(
-            scalar_field=self.scalarfield.base_values.astype(complex),
-            NA=self.NA,
-            phi_offset=phi_offset_rad,
-            gamma_offset=gamma_offset_rad,
-            polarization_filter=polarization_filter_rad,
+        self.binding_kwargs = dict(
+            scalar_field=self.scalar_fields.astype(complex),
+            NA=numpy.atleast_1d(self.NA).astype(float),
+            phi_offset=numpy.deg2rad(numpy.atleast_1d(self.phi_offset).astype(float)),
+            gamma_offset=numpy.deg2rad(numpy.atleast_1d(self.gamma_offset).astype(float)),
+            polarization_filter=numpy.deg2rad(numpy.atleast_1d(self.polarization_filter).astype(float)),
             point_coupling=point_coupling,
             coherent=self.coherent,
             rotation_angle=self.rotation_angle.astype(float)
         )
 
+        self.binding = CppDetectorSet(**self.binding_kwargs)
+
     def interpret_mode_name(self, mode_name: str) -> tuple[int, int, float]:
         """
         Intepret the mode_number parameter to check if there is a rotation associated
 
         :returns:   The two mode numbers plus rotation angle
         :rtype:     tuple[int, int, float]
         """
@@ -255,23 +241,17 @@
         """
         Generates a scalar field array representing the photodiode detection scheme. This method overrides
         the BaseDetector's compute_scalar_fields method to provide functionality specific to photodiode detectors.
 
         Returns:
             numpy.ndarray: An array of scalar fields corresponding to the photodiode detection scheme.
         """
-        scalarfield = numpy.ones([1, self.sampling])
+        self.scalar_fields = numpy.ones([1, self.sampling])
 
-        self.scalarfield = units.Custom(
-            long_label='Field',
-            short_label=r'field',
-            base_values=scalarfield,
-            use_long_label_for_repr=True,
-            value_representation=['Photodiode']
-        )
+        self.detector_name = ['Photodiode']
 
 
 @dataclass
 class CoherentMode(BaseDetector):
     mode_number: Iterable
     """ List of mode to be used. """
     coupling_mode: str = 'point'
@@ -295,34 +275,30 @@
             max_angle=0.3,
             phi_offset=0,
             gamma_offset=0,
             sampling=self.sampling,
             rotation_angle=0
         )
 
-        scalar_fields = numpy.zeros([len(self.mode_number), self.sampling]).astype(complex)
+        self.scalar_fields = numpy.zeros([len(self.mode_number), self.sampling]).astype(complex)
+
+        self.detector_name = self.mode_number
 
         for idx, mode_name in enumerate(self.mode_number):
             mode_family_name, number_0, number_1, rotation_angle = self.interpret_mode_name(mode_name)
 
             match mode_family_name:
                 case 'lp':
                     mode_module = linearly_polarized
                 case 'hg':
                     mode_module = hermite_gauss
                 case 'lg':
                     mode_module = laguerre_gauss
                 case _:
                     raise ValueError('Invalid mode family name, it has to be in either: LP, HG or LG')
 
-            scalar_fields[idx] = mode_module.interpolate_from_fibonacci_mesh(
+            self.scalar_fields[idx] = mode_module.interpolate_from_fibonacci_mesh(
                 fibonacci_mesh=proxy_fibonacci_mesh,
                 number_0=number_0,
                 number_1=number_1,
             )
-
-        self.scalarfield = units.Custom(
-            long_label='Field',
-            short_label='field',
-            base_values=scalar_fields,
-            value_representation=self.mode_number
-        )
+# -
```

## PyMieSim/experiment/scatterer.py

```diff
@@ -20,464 +20,358 @@
 @dataclass
 class BaseScatterer():
     """
     Base class for scatterer objects. This class handles the initialization and setup of
     scatterer parameters for use in PyMieSim simulations.
 
     Attributes:
-        n_medium (Iterable): Refractive index of the medium in which the scatterers are placed.
+        medium_index (Iterable): Refractive index of the medium in which the scatterers are placed.
         source_set (Union[Gaussian, PlaneWave]): Light source configuration for the simulation.
     """
-    n_medium: Iterable
     source_set: Gaussian | PlaneWave
 
     def __post_init__(self) -> NoReturn:
         """
         Initializes the scatterer instance by asserting inputs, formatting them, building binding
         arguments, and Units for visualization. This method is automatically called after the
         class has been initialized.
 
         Returns:
             NoReturn
         """
-        self.validate_material_or_index()
-
-        self.format_inputs()
-
         self.build_binding_kwargs()
 
-        self.build_x_parameters()
-
-    def _validate_and_cleanup(self, part: str = '') -> NoReturn:
-        """
-        Validates and cleans up parameters for either the core or the shell.
-
-        Args:
-            part (str): Specifies the part to validate, either 'core' or 'shell' or ''.
-        """
-        material = getattr(self, f"{part}material")
-        index = getattr(self, f"{part}index")
-
-        if material is not None and index is not None:
-            raise ValueError(f"Either {part} material or index must be provided, not both.")
-        if material is None and index is None:
-            raise ValueError(f"One of {part} material or index must be provided.")
-
-        # Cleanup parameters
-        if material is not None:
-            del self.parameter_dictionnary[f'{part}index']
-            self.cpp_binding_str.remove(f'{part}index')
-        else:
-            del self.parameter_dictionnary[f'{part}material']
-            self.cpp_binding_str.remove(f'{part}material_index')
-
-    def format_inputs(self) -> NoReturn:
-        """
-        Formats the input attributes into numpy arrays for further processing and ensures compatibility
-        with C++ binding. This method standardizes the input parameters for simulation.
-
-        Returns:
-            None
-        """
-        for parameter_str in self.parameter_dictionnary.keys():
-            parameter = getattr(self, parameter_str)
-
-            parameter = numpy.atleast_1d(parameter)
-
-            setattr(self, parameter_str, parameter)
-
     def bind_to_experiment(self, experiment: Setup) -> NoReturn:
         """
-        Binds the scatterer to a specific experiment setup, enabling its properties to be evaluated within
-        the given experimental context.
+        Binds this scatterer instance to a given experimental setup. This method is crucial for integrating
+        the scatterer into the simulation environment, allowing its optical properties to be evaluated
+        within the context of the specified experiment.
 
         Parameters:
-            experiment (Setup): The experiment setup to which the scatterer will be bound.
-
-        Returns:
-            None
+            experiment (Setup): The experimental setup to which the scatterer will be bound. The setup
+                                should be capable of integrating scatterers and managing their interactions
+                                with defined light sources and measurement configurations.
         """
         method_str = 'set_' + self.name
 
         getattr(experiment.binding, method_str)(self.binding)
 
-    def build_binding_kwargs(self) -> NoReturn:
-        """
-        Prepares the keyword arguments for the C++ binding based on the scatterer's properties. This
-        involves evaluating material indices and organizing them into a dictionary for the C++ interface.
-
-        Returns:
-            None
+    def add_material_index_to_mapping(self, name: str = None) -> NoReturn:
         """
-        self.evaluate_index_material()
-
-        self.binding_kwargs = dict()
-
-        for parameter_str in self.cpp_binding_str:
-            values = getattr(self, parameter_str)
-
-            self.binding_kwargs[parameter_str] = values
-
-    def append_to_table(self, table: list) -> list:
-        """
-        Appends the scatterer's properties to a given table for visualization purposes. This enables the
-        representation of scatterer properties in graphical formats.
+        Adds material or refractive index details to a mapping dictionary used for visualization or further processing.
+        This method is used to create a mapping of material properties to human-readable and accessible formats for
+        UI or data outputs.
 
         Parameters:
-            table (list): The table to which the scatterer's properties will be appended.
-
-        Returns:
-            list: The updated table with the scatterer's properties included.
-        """
-        return [*table, *self.x_table]
-
-    def initialize_binding(self) -> NoReturn:
-        """
-        Initializes the C++ binding for the scatterer, setting up the interface for simulation within the
-        C++ computational framework.
-
-        Returns:
-            None
-        """
-        self.binding = self.binding_class(**self.binding_kwargs)
+            name (str, optional): The base name to use for the keys in the mapping dictionary. This name is used
+                                  to differentiate between different materials or indices if multiple exist within
+                                  the same scatterer.
+        """
+        detached_material_name = f"{name} material" if name else "material"
+        attached_material_name = detached_material_name.replace(' ', '_').lower()
+
+        detached_index_name = f"{name} index" if name else "index"
+        attached_index_name = detached_index_name.replace(' ', '_').lower()
+
+        if getattr(self, attached_material_name):
+            self.mapping[attached_material_name] = units.Custom(
+                long_label=detached_material_name,
+                short_label=attached_material_name,
+                value_representation=getattr(self, attached_material_name),
+                base_values=getattr(self, attached_material_name),
+                use_prefix=False,
+            )
 
-    def evaluate_index_material(self) -> NoReturn:
-        """
-        Evaluates the indices of materials for all scatterer sets that are specified by their material
-        properties. This is crucial for accurately simulating the scatterer's interaction with light.
+        else:
+            self.mapping[attached_index_name] = units.Index(
+                long_label=detached_index_name,
+                short_label=attached_index_name,
+                base_values=self.binding_kwargs.get(attached_index_name),
+                string_format='.2f'
+            )
 
-        Returns:
-            None
+    def add_material_index_to_binding_kwargs(self, name: str, data_type: type) -> NoReturn:
         """
-        for parameter_str, value in self.parameter_dictionnary.items():
-            if parameter_str.endswith('material'):
-                materials = getattr(self, parameter_str)
-
-                material_index = [
-                    material.get_refractive_index(self.source_set.wavelength.values) for material in materials
-                ]
+        Adds either material properties or a refractive index to the binding keyword arguments for the experiment.
+        This method validates and processes the material or index information, converting it into a format suitable
+        for simulation use, and ensuring that either a material or an index is provided but not both.
 
-                material_index = numpy.asarray(material_index).astype(complex)
+        Parameters:
+            name (str): The base name for the material or index. This name helps identify the property and is used
+                        to handle multiple materials or indices.
+            data_type (type): The expected Python data type (e.g., float, numpy.ndarray) to which the material
+                              or index values should be converted for simulation purposes.
+
+        Raises:
+            ValueError: If both a material and an index are provided, or if neither is provided.
+        """
+        detached_material_name = f"{name} material" if name else "material"
+        attached_material_name = detached_material_name.replace(' ', '_').lower()
+
+        detached_index_name = f"{name} index" if name else "index"
+        attached_index_name = detached_index_name.replace(' ', '_').lower()
+
+        material_value = getattr(self, attached_material_name)
+        index_value = getattr(self, attached_index_name)
+
+        if material_value is not None and index_value is not None:
+            raise ValueError(f"Either {name} material or {name} index must be provided, not both.")
+        if material_value is None and index_value is None:
+            raise ValueError(f"One of {name} material or {name} index must be provided.")
+
+        if material_value:
+            self.binding_kwargs[attached_material_name] = numpy.asarray([
+                mat.get_refractive_index(self.source_set.wavelength) for mat in numpy.atleast_1d(getattr(self, attached_material_name))
+            ]).astype(data_type)
 
-                setattr(self, parameter_str + '_index', material_index)
+        else:
+            self.binding_kwargs[attached_index_name] = numpy.atleast_1d(index_value).astype(data_type)
 
 
 @dataclass
 class Sphere(BaseScatterer):
     """
-    Represents a spherical scatterer configuration for PyMieSim simulations.
+    A data class that represents a spherical scatterer configuration used in PyMieSim simulations.
+
+    This class provides specific implementations for setting up and binding spherical scatterers
+    with their properties to a simulation environment. It extends the `BaseScatterer` class by
+    adding spherical-specific attributes and methods for handling simulation setups.
 
     Attributes:
-        diameter (Iterable): Diameter(s) of the scatterers in meters.
-        index (Iterable, optional): Refractive index of the scatterers.
+        diameter (Iterable): Diameter(s) of the spherical scatterers in meters.
+        medium_index (Iterable, optional): Refractive index or indices of the medium surrounding the scatterers.
+        medium_material (Iterable, optional): Material(s) defining the medium, used if `medium_index` is not provided.
+        index (Iterable, optional): Refractive index or indices of the spherical scatterers themselves.
         material (Iterable, optional): Material(s) of the scatterers, used if `index` is not provided.
+        name (str): Name identifier for the scatterer type, defaulted to 'sphere' and not intended for initialization.
     """
     diameter: Iterable
+    medium_index: Iterable | None = None
+    medium_material: Iterable | None = None
     index: Iterable | None = None
     material: Iterable | None = None
-
     name: str = field(default="sphere", init=False)
-
     available_measure_list = measure.__sphere__
-    
 
     def __post_init__(self):
-        self.cpp_binding_str: list = [
-            'diameter',
-            'material_index',
-            'index',
-            'n_medium',
-        ]
-
-        self.parameter_dictionnary: dict = dict(
-            diameter=dict(type=float, value=None),
-            material=dict(type=complex, value=None),
-            index=dict(type=complex, value=None),
-            n_medium=dict(type=float, value=None),
-        )
-
-        self.binding_class: type = CppSphereSet
+        """
+        Extends the base class post-initialization process by setting up additional properties specific to spherical scatterers.
+        Initializes a mapping dictionary to support visualization and other operations.
+        """
+        self.mapping: dict = {
+            'diameter': None,
+            'index': None,
+            'material': None,
+            'medium_index': None,
+            'medium_material': None
+        }
 
         super().__post_init__()
 
-    def build_x_parameters(self) -> NoReturn:
+    def build_binding_kwargs(self) -> NoReturn:
         """
-        Constructs Units for inclusion in the XTable for DataVisual, facilitating the visualization
-        of the scatterer's properties.
+        Constructs the keyword arguments necessary for the C++ binding interface, specifically tailored for spherical scatterers.
+        This includes processing material indices and organizing them into a structured dictionary for simulation interaction.
 
-        Returns:
-            None
+        This method automatically configures the `binding_kwargs` attribute with appropriately formatted values.
         """
-        self.x_table = []
-
-        self.diameter = units.Length(
-            long_label='Scatterer diameter',
-            short_label='diameter',
-            base_values=self.diameter,
-            string_format='.1f'
+        self.binding_kwargs = dict(
+            diameter=numpy.atleast_1d(self.diameter).astype(float),
         )
-        self.x_table.append(self.diameter)
 
-        if self.material is not None:
-            self.material = units.Custom(
-                long_label='Scatterer material',
-                short_label='material',
-                value_representation=self.material,
-                use_prefix=False
-            )
-            self.x_table.append(self.material)
+        self.add_material_index_to_binding_kwargs(name=None, data_type=complex)
+        self.add_material_index_to_binding_kwargs(name='medium', data_type=float)
 
-        else:
-            self.index = units.Index(
-                long_label='Refractive index',
-                short_label='index',
-                base_values=self.index,
-                string_format='.1f'
-            )
-            self.x_table.append(self.index)
+        self.binding = CppSphereSet(**self.binding_kwargs)
 
-        self.n_medium = units.Index(
-            long_label=r'Refractive index of medium',
-            short_label=r'n$_{medium}$',
-            base_values=self.n_medium,
-            string_format='.1f'
-        )
-        self.x_table.append(self.n_medium)
-
-    def validate_material_or_index(self) -> NoReturn:
+    def get_datavisual_table(self) -> NoReturn:
         """
-        Validates the inputs for the CoreShell scatterer, ensuring that both core and shell are defined
-        either by their material or by their refractive index, but not both simultaneously. This ensures
-        accurate modeling of core-shell scatterers.
+        Constructs a table of the scatterer's properties formatted for data visualization.
+        This method populates the `mapping` dictionary with user-friendly descriptions and formats of the scatterer properties.
 
         Returns:
-            NoReturn
+            list: A list of visual representations for each property in the `mapping` dictionary that has been populated.
         """
-        self._validate_and_cleanup()
+        self.mapping['diameter'] = units.Length(
+            long_label='Scatterer diameter',
+            short_label='diameter',
+            base_values=self.binding_kwargs.get('diameter'),
+            string_format='.1f'
+        )
+
+        self.add_material_index_to_mapping(name=None)
+        self.add_material_index_to_mapping(name='Medium')
+
+        return [v for k, v in self.mapping.items() if v is not None]
 
 
 @dataclass
 class CoreShell(BaseScatterer):
     """
-    Represents a core-shell scatterer configuration for PyMieSim simulations.
+    A data class representing a core-shell scatterer configuration used in PyMieSim simulations.
+
+    This class facilitates the setup and manipulation of core-shell scatterers by providing structured
+    attributes and methods that ensure the scatterers are configured correctly for simulations.
+    It extends the BaseScatterer class, adding specific attributes and methods relevant to core-shell geometries.
 
     Attributes:
-        core_diameter (Iterable): Diameter(s) of the core in meters.
-        shell_thickness (Iterable): Thickness(es) of the shell in meters.
-        core_index (Iterable, optional): Refractive index of the core.
-        shell_index (Iterable, optional): Refractive index of the shell.
+        core_diameter (Iterable): Diameters of the core components in meters.
+        shell_width (Iterable): Thicknesses of the shell components in meters.
+        medium_index (Iterable, optional): Refractive index or indices of the medium where the scatterers are placed.
+        medium_material (Iterable, optional): Material(s) defining the medium, used if `medium_index` is not provided.
+        core_index (Iterable, optional): Refractive index or indices of the core.
+        shell_index (Iterable, optional): Refractive index or indices of the shell.
         core_material (Iterable, optional): Material(s) of the core, used if `core_index` is not provided.
         shell_material (Iterable, optional): Material(s) of the shell, used if `shell_index` is not provided.
+        name (str): An identifier for the scatterer type, defaulted to 'coreshell' and not intended for initialization.
     """
     core_diameter: Iterable
     shell_width: Iterable
+    medium_index: Iterable | None = None
+    medium_material: Iterable | None = None
     core_index: Iterable | None = None
     shell_index: Iterable | None = None
     core_material: Iterable | None = None
     shell_material: Iterable | None = None
-
     name: str = field(default="coreshell", init=False)
 
     available_measure_list = measure.__coreshell__
 
     def __post_init__(self):
-        self.cpp_binding_str: list = [
-            'core_diameter',
-            'shell_width',
-            'core_material_index',
-            'shell_material_index',
-            'core_index',
-            'shell_index',
-            'n_medium',
-        ]
-
-        self.parameter_dictionnary: dict = dict(
-            core_diameter=dict(type=float, value=None),
-            shell_width=dict(type=float, value=None),
-            core_material=dict(type=complex, value=None),
-            core_index=dict(type=complex, value=None),
-            shell_material=dict(type=complex, value=None),
-            shell_index=dict(type=complex, value=None),
-            n_medium=dict(type=float, value=None),
-        )
+        """
+        Extends the BaseScatterer post-initialization by setting up additional mappings specific to core-shell scatterers.
+        Initializes mappings for visualizing and interacting with scatterer properties.
+        """
+        self.mapping = {
+            'core_diameter': None,
+            'shell_diameter': None,
+            'core_index': None,
+            'core_material': None,
+            'shell_index': None,
+            'shell_material': None,
+            'medium_index': None,
+            'medium_material': None
+        }
 
         self.binding_class: type = CppCoreShellSet
 
         super().__post_init__()
 
-    def build_x_parameters(self) -> NoReturn:
+    def build_binding_kwargs(self) -> NoReturn:
         """
-        Constructs Units for inclusion in the XTable for DataVisual, facilitating the visualization
-        of the scatterer's properties.
+        Assembles the keyword arguments necessary for C++ binding, tailored for core-shell scatterers.
+        Prepares structured data from scatterer properties for efficient simulation integration.
 
-        Returns:
-            None
+        This function populates `binding_kwargs` with values formatted appropriately for the C++ backend used in simulations.
         """
-        self.x_table = []
+        self.binding_kwargs = dict(
+            core_diameter=numpy.atleast_1d(self.core_diameter).astype(float),
+            shell_width=numpy.atleast_1d(self.shell_width).astype(float),
+        )
+
+        self.add_material_index_to_binding_kwargs(name='Core', data_type=complex)
+        self.add_material_index_to_binding_kwargs(name='Shell', data_type=complex)
+        self.add_material_index_to_binding_kwargs(name='medium', data_type=float)
 
-        self.core_diameter = units.Length(
+        self.binding = CppCoreShellSet(**self.binding_kwargs)
+
+    def get_datavisual_table(self) -> NoReturn:
+        """
+        Generates a list of data visualizations for the scatterer's properties, which can be used in user interfaces or reports.
+        Each property is formatted into a user-friendly structure, making it easier to visualize and understand.
+
+        Returns:
+            list: A collection of formatted representations for the scatterer properties.
+        """
+        self.mapping['core_diameter'] = units.Length(
             long_label='Core diameter',
             short_label='core_diameter',
-            base_values=self.core_diameter,
+            base_values=self.binding_kwargs.get('core_diameter'),
             string_format='.2f'
         )
-        self.x_table.append(self.core_diameter)
 
-        self.shell_width = units.Length(
+        self.mapping['shell_width'] = units.Length(
             long_label='Shell width',
             short_label='shell_width',
-            base_values=self.shell_width,
-            string_format='.2f'
-        )
-        self.x_table.append(self.shell_width)
-
-        if self.core_material is not None:
-            self.core_material = units.Custom(
-                long_label='Core material',
-                short_label='core_material',
-                value_representation=self.core_material,
-                use_prefix=False,
-            )
-            self.x_table.append(self.core_material)
-
-        else:
-            self.core_index = units.Index(
-                long_label='Core index',
-                short_label='core_index',
-                base_values=self.core_index,
-                string_format='.2f'
-            )
-            self.x_table.append(self.core_index)
-
-        if self.shell_material is not None:
-            self.shell_material = units.Custom(
-                long_label='Shell material',
-                short_label='shell_material',
-                base_values=self.shell_material,
-                use_prefix=False
-            )
-            self.x_table.append(self.shell_material)
-
-        else:
-            self.shell_index = units.Index(
-                long_label='Shell index',
-                short_label='shell_index',
-                base_values=self.shell_index,
-                string_format='.2f'
-            )
-            self.x_table.append(self.shell_index)
-
-        self.n_medium = units.Index(
-            long_label=r'Refractive index of medium',
-            short_label=r'n$_{medium}$',
-            base_values=self.n_medium,
+            base_values=self.binding_kwargs.get('shell_width'),
             string_format='.2f'
         )
-        self.x_table.append(self.n_medium)
 
-    def validate_material_or_index(self) -> NoReturn:
-        """
-        Validates the inputs for the CoreShell scatterer, ensuring that both core and shell are defined
-        either by their material or by their refractive index, but not both simultaneously. This ensures
-        accurate modeling of core-shell scatterers.
+        self.add_material_index_to_mapping(name='Core')
+        self.add_material_index_to_mapping(name='Shell')
+        self.add_material_index_to_mapping(name='Medium')
 
-        Returns:
-            NoReturn
-        """
-        self._validate_and_cleanup('core_')
-        self._validate_and_cleanup('shell_')
+        return [v for k, v in self.mapping.items() if v is not None]
 
 
 @dataclass
 class Cylinder(BaseScatterer):
     """
     Represents a cylindrical scatterer configuration for PyMieSim simulations.
 
     Attributes:
         diameter (Iterable): Diameter(s) of the cylinder in meters.
         height (Iterable): Height(s) of the cylinder in meters.
         index (Iterable, optional): Refractive index of the cylinder.
         material (Iterable, optional): Material(s) of the cylinder, used if `index` is not provided.
     """
     diameter: Iterable
+    medium_index: Iterable | None = None
+    medium_material: Iterable | None = None
     index: Iterable | None = None
     material: Iterable | None = None
-
     name: str = field(default="cylinder", init=False)
 
     available_measure_list = measure.__cylinder__
 
     def __post_init__(self):
-        self.cpp_binding_str: list = [
-            'diameter',
-            'material_index',
-            'index',
-            'n_medium',
-        ]
-
-        self.parameter_dictionnary: dict = dict(
-            diameter=dict(type=float, value=None),
-            material=dict(type=complex, value=None),
-            index=dict(type=complex, value=None),
-            n_medium=dict(type=float, value=None),
-        )
-
-        self.binding_class: type = CppCylinderSet
+        self.mapping = {
+            'diameter': None,
+            'index': None,
+            'material': None,
+            'medium_index': None,
+            'medium_material': None
+        }
 
         super().__post_init__()
 
-    def build_x_parameters(self) -> NoReturn:
+    def build_binding_kwargs(self) -> NoReturn:
         """
-        Constructs Units for inclusion in the XTable for DataVisual, facilitating the visualization
-        of the scatterer's properties.
+        Prepares the keyword arguments for the C++ binding based on the scatterer's properties. This
+        involves evaluating material indices and organizing them into a dictionary for the C++ interface.
 
         Returns:
             None
         """
-        self.x_table = []
-
-        self.diameter = units.Length(
-            long_label='Scatterer diameter',
-            short_label='diameter',
-            base_values=self.diameter,
-            string_format='.2f'
+        self.binding_kwargs = dict(
+            diameter=numpy.atleast_1d(self.diameter).astype(float),
         )
-        self.x_table.append(self.diameter)
 
-        if self.material is not None:
-            self.material = units.Custom(
-                long_label='Scatterer material',
-                short_label='material',
-                base_values=self.material,
-                value_representation=self.material
-            )
-            self.x_table.append(self.material)
+        self.add_material_index_to_binding_kwargs(name=None, data_type=complex)
+        self.add_material_index_to_binding_kwargs(name='medium', data_type=float)
 
-        else:
-            self.index = units.Index(
-                long_label='Refractive index',
-                short_label='index',
-                base_values=self.index,
-                string_format='.2f'
-            )
-            self.x_table.append(self.index)
-
-        self.n_medium = units.Index(
-            long_label=r'Refractive index of medium',
-            short_label=r'n$_{medium}$',
-            base_values=self.n_medium,
-            string_format='.2f'
-        )
-        self.x_table.append(self.n_medium)
+        self.binding = CppCylinderSet(**self.binding_kwargs)
 
-    def validate_material_or_index(self) -> NoReturn:
+    def get_datavisual_table(self) -> NoReturn:
         """
-        Validates the inputs for the CoreShell scatterer, ensuring that both core and shell are defined
-        either by their material or by their refractive index, but not both simultaneously. This ensures
-        accurate modeling of core-shell scatterers.
+        Appends the scatterer's properties to a given table for visualization purposes. This enables the
+        representation of scatterer properties in graphical formats.
+
+        Parameters:
+            table (list): The table to which the scatterer's properties will be appended.
 
         Returns:
-            NoReturn
+            list: The updated table with the scatterer's properties included.
         """
-        self._validate_and_cleanup()
+        self.mapping['diameter'] = units.Length(
+            long_label='Scatterer diameter',
+            short_label='diameter',
+            base_values=self.binding_kwargs.get('diameter'),
+            string_format='.1f'
+        )
+
+        self.add_material_index_to_mapping(name=None)
+        self.add_material_index_to_mapping(name='Medium')
+
+        return [v for k, v in self.mapping.items() if v is not None]
 
 # -
```

## PyMieSim/experiment/setup.py

```diff
@@ -8,16 +8,15 @@
     from PyMieSim.experiment.scatterer import Sphere, Cylinder, CoreShell
     from PyMieSim.experiment.detector import Photodiode, LPMode
     from PyMieSim.experiment.source import Gaussian, PlaneWave
 
 import numpy
 from dataclasses import dataclass
 
-from DataVisual import Array
-from DataVisual import Table
+from DataVisual import Array, Table
 from PyMieSim.binary.Experiment import CppExperiment
 
 
 @dataclass
 class Setup(object):
     """
     Orchestrates the setup and execution of light scattering experiments using PyMieSim.
@@ -40,41 +39,43 @@
     def __post_init__(self):
         """
         Initializes the experiment by setting the source for the scatterer and establishing bindings
         between the components and the simulation environment.
         """
         self.initialize_experiment()
         self.bind_components()
-        self.generate_x_table()
 
     def initialize_experiment(self) -> NoReturn:
         """
         Initializes the experiment with necessary bindings.
         """
         self.scatterer_set.source_set = self.source_set
-        self.scatterer_set.initialize_binding()
+
         self.binding = CppExperiment()
 
     def bind_components(self):
         """Binds the experiment components to the CppExperiment instance."""
         for component in [self.source_set, self.scatterer_set, self.detector_set]:
             if component:
                 component.bind_to_experiment(experiment=self)
 
-    def generate_x_table(self) -> NoReturn:
+    def generate_datavisual_table(self) -> NoReturn:
         """
         Generates and populates the 'x_table' with parameters from the source, scatterer, and detector sets.
         This table is instrumental for data visualization and analysis.
 
         Returns:
             NoReturn
         """
-        table = self.source_set.append_to_table(table=[])
-        table = self.scatterer_set.append_to_table(table=table)
-        self.x_table = table if not self.detector_set else self.detector_set.append_to_table(table=table)
+        self.x_table = []
+        self.x_table.extend(self.source_set.get_datavisual_table())
+        self.x_table.extend(self.scatterer_set.get_datavisual_table())
+
+        if self.detector_set:
+            self.x_table.extend(self.detector_set.get_datavisual_table())
 
     def get(self, measure: Table, export_as_numpy: bool = False) -> numpy.ndarray | Array:
         """
         Executes the simulation to compute and retrieve the specified measure.
 
         Parameters:
             measure (Table): The measure to be computed by the simulation, defined by the user.
@@ -85,18 +86,42 @@
             Union[numpy.ndarray, Array]: The computed data in the specified format, either as raw numerical
                                               values in a numpy array or structured for visualization with Array.
         """
         if measure.short_label not in self.scatterer_set.available_measure_list:
             raise ValueError(f"Cannot compute {measure.short_label} for {self.scatterer_set.name}")
 
         measure_string = f'get_{self.scatterer_set.name}_{measure.short_label}'
-        print(self.binding, measure_string)
+
         array = getattr(self.binding, measure_string)()
 
         if export_as_numpy:
-            return array
+            return self._export_as_numpy(array)
+
+        return self._export_as_data_visual(measure, array)
+
+    def _export_as_numpy(self, array):
+        for k, v in self.source_set.binding_kwargs.items():
+            setattr(self, k, v)
+        for k, v in self.scatterer_set.binding_kwargs.items():
+            setattr(self, k, v)
+        if self.detector_set is not None:
+            for k, v in self.detector_set.binding_kwargs.items():
+                print('hllo', k)
+                setattr(self, k, v)
 
+        return array
+
+    def _export_as_data_visual(self, measure, array):
+        self.generate_datavisual_table()
         measure.set_base_values(array)
-        return Array(x_table=Table(self.x_table), y=measure)
 
+        for k, v in self.source_set.mapping.items():
+            setattr(self, k, v)
+        for k, v in self.scatterer_set.mapping.items():
+            setattr(self, k, v)
+        if self.detector_set is not None:
+            for k, v in self.detector_set.mapping.items():
+                setattr(self, k, v)
+
+        return Array(x_table=Table(self.x_table), y=measure)
 
 # -
```

## PyMieSim/experiment/source.py

```diff
@@ -1,12 +1,12 @@
 #!/usr/bin/env python
 # -*- coding: utf-8 -*-
 
 from __future__ import annotations
-from typing import TYPE_CHECKING, Iterable
+from typing import TYPE_CHECKING, Iterable, NoReturn
 if TYPE_CHECKING:
     from PyMieSim.experiment.setup import Setup
 
 import numpy
 from dataclasses import dataclass, field
 
 from PyMieSim.physics import power_to_amplitude
@@ -26,82 +26,65 @@
         name (str): The name of the source set, defaults to 'PlaneWave'.
     """
     wavelength: Iterable
     polarization_value: Iterable
     name: str = field(default='PlaneWave', init=False)
 
     def __post_init__(self):
+        self.mapping = {
+            'wavelength': None,
+            'polarization': None
+        }
+
         self.format_inputs()
-        self.generate_polarization_attribute()
+        # self.generate_polarization_attribute()
         self.generate_amplitude()
         self.generate_binding()
-        self.build_x_parameters()
 
     def format_inputs(self):
         """Formats input wavelengths and polarization values into numpy arrays."""
         self.polarization_value = numpy.atleast_1d(self.polarization_value).astype(float)
         self.wavelength = numpy.atleast_1d(self.wavelength).astype(float)
 
-    def generate_polarization_attribute(self):
-        """
-        Generates the polarization attribute based on specified polarization values.
-        Raises an error for invalid polarization types not handled in subclasses.
+    def get_datavisual_table(self) -> NoReturn:
         """
-        self.polarization = polarization.Linear(*self.polarization_value)
-        self.jones_vector = numpy.atleast_1d(self.polarization.jones_vector).astype(numpy.complex128).T
+        Appends the scatterer's properties to a given table for visualization purposes. This enables the
+        representation of scatterer properties in graphical formats.
 
-    def generate_amplitude(self):
-        """Abstract method for generating amplitude, to be implemented by subclasses."""
-        raise NotImplementedError("Subclass must implement this method.")
+        Parameters:
+            table (list): The table to which the scatterer's properties will be appended.
 
-    def build_x_parameters(self):
-        """Builds Xparameters for wavelength and linear polarization for DataVisual representations."""
-        self.wavelength = units.Length(
+        Returns:
+            list: The updated table with the scatterer's properties included.
+        """
+        self.mapping['wavelength'] = units.Length(
             long_label='Wavelength',
             short_label=r'$\lambda$',
             base_values=self.wavelength,
             string_format='.2f'
         )
 
-        self.linear_polarization = units.Degree(
+        self.mapping['polarization'] = units.Degree(
             long_label='Polarization',
-            short_label=r'Pol.',
+            short_label=r'Pol',
             base_values=self.polarization_value,
             string_format='.2f'
         )
 
-    def generate_binding(self):
-        """Generates the C++ binding for the source set."""
-        self.binding = CppSourceSet(
-            wavelength=self.wavelength,
-            jones_vector=self.jones_vector,
-            amplitude=self.amplitude
-        )
+        return [v for k, v in self.mapping.items() if v is not None]
 
     def bind_to_experiment(self, experiment: Setup):
         """
         Binds the source set to an experiment.
 
         Parameters:
             experiment (Setup): The experiment setup to bind the source to.
         """
         experiment.binding.set_source(self.binding)
 
-    def append_to_table(self, table: list) -> list:
-        """
-        Appends the wavelength and linear polarization to a given table.
-
-        Parameters:
-            table (list): The table to append data to.
-
-        Returns:
-            list: The updated table with appended data.
-        """
-        return [*table, self.wavelength, self.linear_polarization]
-
 
 @dataclass
 class Gaussian(BaseSource):
     """
     Represents a Gaussian light source with a specified numerical aperture and optical power.
 
     Inherits from BaseSource and adds specific attributes for Gaussian sources.
@@ -111,14 +94,32 @@
         optical_power (float): The optical power of the source, in Watts.
         polarization_type (str): The type of polarization, defaults to 'linear'.
     """
     NA: Iterable
     optical_power: float
     polarization_type: str = 'linear'
 
+    def generate_binding(self) -> NoReturn:
+        """
+        Prepares the keyword arguments for the C++ binding based on the scatterer's properties. This
+        involves evaluating material indices and organizing them into a dictionary for the C++ interface.
+
+        Returns:
+            None
+        """
+        linear_polarization = polarization.Linear(*self.polarization_value)
+
+        self.binding_kwargs = dict(
+            wavelength=numpy.atleast_1d(self.wavelength).astype(float),
+            jones_vector=numpy.atleast_2d(linear_polarization.jones_vector).astype(complex).T,
+            amplitude=numpy.atleast_1d(self.amplitude).astype(float),
+        )
+
+        self.binding = CppSourceSet(**self.binding_kwargs)
+
     def generate_amplitude(self):
         """Generates the amplitude of the Gaussian source based on its optical power and numerical aperture."""
         self.amplitude = power_to_amplitude(
             wavelength=self.wavelength,
             optical_power=self.optical_power,
             NA=self.NA
         )
@@ -134,10 +135,26 @@
     Attributes:
         amplitude (float): The amplitude of the plane wave, in Watts.
         polarization_type (str): The type of polarization, defaults to 'linear'.
     """
     amplitude: float
     polarization_type: str = 'linear'
 
+    def generate_binding(self) -> NoReturn:
+        """
+        Prepares the keyword arguments for the C++ binding based on the scatterer's properties. This
+        involves evaluating material indices and organizing them into a dictionary for the C++ interface.
+
+        Returns:
+            None
+        """
+        self.binding_kwargs = dict(
+            wavelength=self.wavelength,
+            jones_vector=self.jones_vector,
+            amplitude=self.amplitude
+        )
+
+        self.binding = CppSourceSet(**self.binding_kwargs)
+
     def generate_amplitude(self):
         """Sets the amplitude of the plane wave as a numpy array."""
         self.amplitude = numpy.atleast_1d(self.amplitude)
```

## PyMieSim/gui/axis_tab.py

```diff
@@ -71,10 +71,10 @@
         Combines mappings from all other tabs to provide a comprehensive dictionary of available axis options.
 
         Returns:
             Dict[str, str]: A dictionary mapping UI labels to internal scatterer parameter names.
         """
         _axis_mapping = {}
         for tab in self.other_tabs:
-            _axis_mapping.update(tab.mapping)
+            _axis_mapping.update(tab.component.mapping)
 
         return _axis_mapping
```

## PyMieSim/gui/detector_tab.py

```diff
@@ -122,24 +122,11 @@
             setup_method()
         else:
             raise ValueError(f"Unsupported scatterer type: {detector_type}")
 
     def setup_photodiode_component(self) -> NoReturn:
         self.component = Photodiode(**self.widget_collection.to_component_dict())
 
-        self.mapping = {
-            'NA': self.component.NA,
-            'gamma': self.component.gamma_offset,
-            'phi': self.component.phi_offset,
-            'polarization_filter': self.component.polarization_filter
-        }
-
     def setup_coherentmode_component(self) -> NoReturn:
         self.component = CoherentMode(**self.widget_collection.to_component_dict())
 
-        self.mapping = {
-            'NA': self.component.NA,
-            'gamma': self.component.gamma_offset,
-            'phi': self.component.phi_offset,
-            'polarization_filter': self.component.polarization_filter
-        }
 # -
```

## PyMieSim/gui/main_window.py

```diff
@@ -178,14 +178,15 @@
         if hasattr(self, 'new_window'):
             self.new_window.destroy()
 
         self.new_window = tk.Toplevel(self.master)
         self.new_window.title("Plot Window")
 
         x_axis = self.axis_tab.x_axis
+
         std_axis = None if self.axis_tab.std_axis == "none" else self.axis_tab.std_axis
 
         figure = self.data.plot(x=x_axis, std=std_axis)
         figure.unit_size = (9, 4)
         figure._render_()
         self.figure = figure._mpl_figure
 
@@ -203,15 +204,15 @@
 
         self.y_axis = self.axis_tab.measure_map[y_axis]
 
         self.setup_PyMieSim()
 
         self.data = self.experiment.get(self.y_axis)
 
-        self.x_axis = self.axis_tab.axis_mapping['wavelength']
+        self.x_axis = self.axis_tab.axis_mapping[x_axis]
 
         try:
             self.generate_figure()
 
         except ValueError as e:
             messagebox.showerror("Input Error", str(e))
```

## PyMieSim/gui/scatterer_tab.py

```diff
@@ -84,41 +84,41 @@
     def setup_sphere_widgets(self) -> NoReturn:
         """
         Sets up the configuration widgets for a Sphere scatterer and initializes the component.
         """
         self.widget_collection = WidgetCollection(
             InputWidget(default_value='500', label='Diameter [nm]', component_label='diameter', multiplicative_factor=1e-9, frame=self.frame),
             InputWidget(default_value='1.4', label='Refractive Index', component_label='index', frame=self.frame),
-            InputWidget(default_value='1.0', label='Medium Refractive Index', component_label='n_medium', frame=self.frame)
+            InputWidget(default_value='1.0', label='Medium Refractive Index', component_label='medium_index', frame=self.frame)
         )
         self.widget_collection.setup_widgets(self.frame)
         self.setup_sphere_component()
 
     def setup_cylinder_widgets(self) -> NoReturn:
         """
         Sets up the configuration widgets for a Cylinder scatterer and initializes the component.
         """
         self.widget_collection = WidgetCollection(
             InputWidget(default_value='1000', label='Diameter [nm]', component_label='diameter', multiplicative_factor=1e-9, frame=self.frame),
             InputWidget(default_value='1.4', label='Refractive Index', component_label='index', frame=self.frame),
-            InputWidget(default_value='1.0', label='Medium Refractive Index', component_label='n_medium', frame=self.frame)
+            InputWidget(default_value='1.0', label='Medium Refractive Index', component_label='medium_index', frame=self.frame)
         )
         self.widget_collection.setup_widgets(self.frame)
         self.setup_cylinder_component()
 
     def setup_coreshell_widgets(self) -> NoReturn:
         """
         Sets up the configuration widgets for a CoreShell scatterer and initializes the component.
         """
         self.widget_collection = WidgetCollection(
             InputWidget(default_value='1000', label='Core Diameter [nm]', component_label='core_diameter', multiplicative_factor=1e-9, frame=self.frame),
             InputWidget(default_value='200', label='Shell Width [nm]', component_label='shell_width', multiplicative_factor=1e-9, frame=self.frame),
             InputWidget(default_value='1.4', label='Core Refractive Index', component_label='core_index', frame=self.frame),
             InputWidget(default_value='1.4', label='Shell Refractive Index', component_label='shell_index', frame=self.frame),
-            InputWidget(default_value='1.0', label='Medium Refractive Index', component_label='n_medium', frame=self.frame)
+            InputWidget(default_value='1.0', label='Medium Refractive Index', component_label='medium_index', frame=self.frame)
         )
         self.widget_collection.setup_widgets(self.frame)
         self.setup_coreshell_component()
 
     def setup_component(self, event=None) -> NoReturn:
         """
         Handles the event triggered by a change in the selected scatterer type. It updates the UI to match
@@ -134,35 +134,14 @@
             setup_method()
         else:
             raise ValueError(f"Unsupported scatterer type: {scatterer_type}")
 
     def setup_sphere_component(self) -> NoReturn:
         self.component = scatterer.Sphere(**self.widget_collection.to_component_dict(), source_set=self.source_tab.component)
 
-        self.mapping = dict(
-            diameter=self.component.diameter,
-            index=self.component.index,
-            n_medium=self.component.n_medium,
-        )
-
     def setup_cylinder_component(self) -> NoReturn:
         self.component = scatterer.Cylinder(**self.widget_collection.to_component_dict(), source_set=self.source_tab.component)
 
-        self.mapping = dict(
-            diameter=self.component.diameter,
-            index=self.component.index,
-            n_medium=self.component.n_medium,
-        )
-
     def setup_coreshell_component(self) -> NoReturn:
         self.component = scatterer.CoreShell(**self.widget_collection.to_component_dict(), source_set=self.source_tab.component)
 
-        self.mapping = dict(
-            core_diameter=self.component.core_diameter,
-            shell_width=self.component.shell_width,
-            core_index=self.component.core_index,
-            shell_index=self.component.shell_index,
-            n_medium=self.component.n_medium,
-        )
-
-
 # -
```

## PyMieSim/gui/source_tab.py

```diff
@@ -36,16 +36,16 @@
 
         This method sets up labels and entry fields for each source parameter, facilitating
         user interaction for the configuration of the light source.
         """
         self.widget_collection = WidgetCollection(
             InputWidget(default_value='1310', label='Wavelength [nm]', component_label='wavelength', multiplicative_factor=1e-9, frame=self.frame),
             InputWidget(default_value='0', label='Polarization angle [degree]', component_label='polarization_value', frame=self.frame),
-            InputWidget(default_value='1.0', label='Optical Power [mW]', component_label='optical_power', multiplicative_factor=1e-3, frame=self.frame),
-            InputWidget(default_value='0.2', label='Numerical Aperture (NA)', component_label='NA', frame=self.frame)
+            InputWidget(default_value='1.0', label='Optical Power [mW] [fix]', component_label='optical_power', multiplicative_factor=1e-3, frame=self.frame),
+            InputWidget(default_value='0.2', label='Numerical Aperture (NA) [fix]', component_label='NA', frame=self.frame)
         )
 
         self.widget_collection.setup_widgets(frame=self.frame)
         self.setup_component()
 
     def setup_component(self) -> NoReturn:
         """
@@ -53,13 +53,8 @@
 
         This method reads input values from the UI widgets and uses them to configure
         a Gaussian source component for the simulation.
         """
         self.widget_collection.update()
         self.component = Gaussian(**self.widget_collection.to_component_dict())
 
-        self.mapping = {
-            'wavelength': self.component.wavelength,
-            'polarization': self.component.linear_polarization
-        }
-
 # -
```

## PyMieSim/single/scatterer.py

```diff
@@ -323,15 +323,15 @@
     """ Class representing a homogeneous spherical scatterer """
     diameter: float
     """ diameter of the single scatterer in unit of meter. """
     source: PlaneWave | Gaussian
     """ Light source object containing info on polarization and wavelength. """
     index: complex = None
     """ Refractive index of scatterer. """
-    n_medium: float = 1.0
+    medium_index: float = 1.0
     """ Refractive index of scatterer medium. """
     material: DataMeasurement | Sellmeier | None = None
     """ Material of which the scatterer is made of. Only if index is not specified. """
 
     def __post_init__(self):
         self.index, self.material = self._assign_index_or_material(self.index, self.material)
 
@@ -345,15 +345,15 @@
         from PyMieSim.binary.SphereInterface import SPHERE
 
         self.Bind = SPHERE(
             wavelength=self.source.wavelength,
             amplitude=self.source.amplitude,
             diameter=self.diameter,
             index=self.index,
-            n_medium=self.n_medium,
+            medium_index=self.medium_index,
             jones_vector=self.source.polarization.jones_vector.squeeze(),
         )
 
     def an(self, max_order: int = None) -> numpy.array:
         r"""
         Compute :math:`a_n` coefficient as defined in Eq:III.88 of B&B:
 
@@ -430,15 +430,15 @@
     """ Refractive index of the core of the scatterer. """
     shell_index: complex = None
     """ Refractive index of the shell of the scatterer. """
     core_material: DataMeasurement | Sellmeier | None = None
     """ Core material of which the scatterer is made of. Only if core_index is not specified.  """
     shell_material: DataMeasurement | Sellmeier | None = None
     """ Shell material of which the scatterer is made of. Only if shell_index is not specified.  """
-    n_medium: float = 1.0
+    medium_index: float = 1.0
     """ Refractive index of scatterer medium. """
 
     def __post_init__(self):
         self.core_index, self.core_material = self._assign_index_or_material(self.core_index, self.core_material)
 
         self.shell_index, self.shell_material = self._assign_index_or_material(self.shell_index, self.shell_material)
 
@@ -454,15 +454,15 @@
 
         self.Bind = CORESHELL(
             shell_index=self.shell_index,
             core_index=self.core_index,
             shell_width=self.shell_width,
             core_diameter=self.core_diameter,
             wavelength=self.source.wavelength,
-            n_medium=self.n_medium,
+            medium_index=self.medium_index,
             jones_vector=self.source.polarization.jones_vector.squeeze(),
             amplitude=self.source.amplitude
         )
 
     def an(self, max_order: int = None) -> numpy.array:
         r"""
         Compute :math:`a_n` coefficient
@@ -490,15 +490,15 @@
 
     diameter: float
     """ diameter of the single scatterer in unit of meter. """
     source: PlaneWave | Gaussian
     """ Light source object containing info on polarization and wavelength. """
     index: complex = None
     """ Refractive index of scatterer. """
-    n_medium: float = 1.0
+    medium_index: float = 1.0
     """ Material of which the scatterer is made of. Only if index is not specified. """
     material: DataMeasurement | Sellmeier | None = None
     """ Refractive index of scatterer medium. """
 
     def __post_init__(self):
         self.index, self.material = self._assign_index_or_material(
             index=self.index,
@@ -513,15 +513,15 @@
         """
         from PyMieSim.binary.CylinderInterface import CYLINDER
 
         self.Bind = CYLINDER(
             index=self.index,
             diameter=self.diameter,
             wavelength=self.source.wavelength,
-            n_medium=self.n_medium,
+            medium_index=self.medium_index,
             amplitude=self.source.amplitude,
             jones_vector=self.source.polarization.jones_vector.squeeze()
         )
 
     def a1n(self, max_order: int = None) -> numpy.array:
         r"""
         Compute :math:`a_n` coefficient as defined ref[5]:
```

## development/LPMOdes.py

```diff
@@ -4,65 +4,33 @@
 """
 
 
 # %%
 # Importing the package dependencies: numpy, PyMieSim
 import numpy as np
 
-from PyMieSim.experiment.detector import LGMode
-from PyMieSim.experiment.scatterer import Sphere
-from PyMieSim.experiment.source import Gaussian
-from PyMieSim.experiment import Setup
+from PyMieSim.single.scatterer import Sphere
+from PyMieSim.single.source import Gaussian
 
 from PyMieSim import measure
 from PyMieSim.materials import BK7
 
 # %%
 # Defining the source to be employed.
-source_set = Gaussian(
-    wavelength=np.linspace(950e-9, 1050e-9, 200),
+source = Gaussian(
+    wavelength=632.8e-9,
     polarization_value=0,
     polarization_type='linear',
     optical_power=1e-3,
     NA=0.2
 )
 
 # %%
 # Defining the ranging parameters for the scatterer distribution
-scatterer_set = Sphere(
-    diameter=5000e-9,
-    material=BK7,
-    n_medium=1,
-    source_set=source_set
+scatterer = Sphere(
+    diameter=1000e-9,
+    index=1.4,
+    medium_index=1.21,
+    source=source
 )
 
-# %%
-# Defining the detector to be employed.
-detector_set = LGMode(
-    mode_number=["LG11:00", "LG11:120"],
-    NA=0.05,
-    phi_offset=-180,
-    gamma_offset=0,
-    polarization_filter=None,
-    sampling=300
-)
-
-# %%
-# Defining the experiment setup
-experiment = Setup(
-    scatterer_set=scatterer_set,
-    source_set=source_set,
-    detector_set=detector_set
-)
-
-# %%
-# Measuring the properties
-data = experiment.get(measure.coupling)
-
-# %%
-# Plotting the results
-figure = data.plot(
-    x=source_set.wavelength,
-    std=scatterer_set.diameter
-)
-
-_ = figure.show()
+print(scatterer.print_properties())
```

## docs/examples/experiment/plot_coreshell_Qback_vs_corediameter.py

```diff
@@ -28,15 +28,15 @@
 # %%
 # Defining the scatterer distribution
 scatterer_set = CoreShell(
     core_diameter=numpy.geomspace(100e-9, 600e-9, 400),  # Core diameters from 100 nm to 600 nm
     shell_width=800e-9,  # Shell width of 800 nm
     core_material=Silver,  # Core material
     shell_material=BK7,  # Shell material
-    n_medium=1,  # Surrounding medium's refractive index
+    medium_index=1,  # Surrounding medium's refractive index
     source_set=source_set
 )
 
 # %%
 # Setting up the experiment
 experiment = Setup(
     scatterer_set=scatterer_set,
@@ -48,14 +48,14 @@
 # For demonstrating the measurement of Qsca, a separate call to `experiment.get()` with `measure.Qsca` is needed.
 data = experiment.get(measure.Qback)
 
 # %%
 # Plotting the results
 # Visualizing how the backscattering efficiency varies with the core diameter.
 figure = data.plot(
-    x=scatterer_set.core_diameter,  # Core diameter as the x-axis
+    x=experiment.core_diameter,  # Core diameter as the x-axis
     y_scale='log'  # Logarithmic scale for the y-axis
 )
 
 # %%
 # Displaying the plot
 _ = figure.show()
```

## docs/examples/experiment/plot_coreshell_a1_vs_corediameter.py

```diff
@@ -7,15 +7,15 @@
 
 # %%
 # Importing the package dependencies: numpy, PyMieSim
 import numpy as np
 from PyMieSim.experiment.scatterer import CoreShell
 from PyMieSim.experiment.source import Gaussian
 from PyMieSim.experiment import Setup
-from PyMieSim.materials import BK7
+from PyMieSim.materials import BK7, Silver
 from PyMieSim import measure
 
 # %%
 # Defining the source
 # In the LMT framework, the source is always considered a plane wave with a default amplitude of one.
 source_set = Gaussian(
     wavelength=800e-9,  # 800 nm
@@ -28,16 +28,17 @@
 # %%
 # Defining the scatterer distribution
 # Here, we explore core/shell scatterers with a constant shell diameter and variable core diameter.
 scatterer_set = CoreShell(
     core_diameter=np.geomspace(100e-9, 3000e-9, 5000),  # Geometrically spaced core diameters
     shell_width=800e-9,  # Shell width of 800 nm
     core_index=1.6,  # Refractive index of the core
-    shell_material=BK7,  # BK7 glass material for the shell
-    n_medium=1,  # Refractive index of the surrounding medium
+    shell_material=[BK7, Silver],  # BK7 glass material for the shell
+    # shell_index=1,
+    medium_index=1,  # Refractive index of the surrounding medium
     source_set=source_set
 )
 
 # %%
 # Defining the experiment setup
 # Integrating the defined source and scatterers into a single experimental setup.
 experiment = Setup(
@@ -50,14 +51,14 @@
 # Here, we're interested in the a3 (first magnetic coefficient) parameter, which seems to be a typo for B1.
 data = experiment.get(measure.a3)
 
 # %%
 # Plotting the results
 # Visualizing how the B1 (a3) parameter varies with the core diameter.
 figure = data.plot(
-    x=scatterer_set.core_diameter,  # Core diameter as the x-axis
+    x=experiment.core_diameter,  # Core diameter as the x-axis
     y_scale='linear'  # Linear scale for the y-axis
 )
 
 # %%
 # Displaying the plot
 _ = figure.show()
```

## docs/examples/experiment/plot_coreshell_b1_vs_corediameter.py

```diff
@@ -31,15 +31,15 @@
 # Here we look at core/shell scatterers and use constant shell diameter
 # with variable core diameter
 scatterer_set = CoreShell(
     core_diameter=np.geomspace(100e-9, 3000e-9, 5000),  # Geometrically spaced core diameters
     shell_width=800e-9,  # Shell width of 800 nm
     core_index=1.6,  # Refractive index of the core
     shell_material=BK7,  # BK7 glass material for the shell
-    n_medium=1,  # Refractive index of the surrounding medium
+    medium_index=1,  # Refractive index of the surrounding medium
     source_set=source_set
 )
 
 # %%
 # Defining the experiment setup
 # Integrating the defined source and scatterers into a single experimental setup.
 experiment = Setup(
@@ -51,14 +51,14 @@
 # Measuring the B1 scattering parameter
 data = experiment.get(measure.b1)
 
 # %%
 # Plotting the results
 # Visualizing how the B1 parameter varies with the core diameter.
 figure = data.plot(
-    x=scatterer_set.core_diameter,  # Core diameter as the x-axis
+    x=experiment.core_diameter,  # Core diameter as the x-axis
     y_scale='linear'  # Linear scale for the y-axis
 )
 
 # %%
 # Displaying the plot
 _ = figure.show()
```

## docs/examples/experiment/plot_coreshell_coupling_vs_corediameter.py

```diff
@@ -26,17 +26,19 @@
 )
 
 # %%
 # Defining the scatterer distribution
 scatterer_set = CoreShell(
     core_diameter=numpy.geomspace(100e-9, 600e-9, 400),  # Core diameters from 100 nm to 600 nm
     shell_width=800e-9,  # Shell width of 800 nm
-    core_material=Silver,  # Core material
-    shell_material=BK7,  # Shell material
-    n_medium=1,  # Surrounding medium's refractive index
+    # core_material=Silver,  # Core material
+    core_index=1.3,
+    shell_index=1.3,
+    # shell_material=BK7,  # Shell material
+    medium_index=1,  # Surrounding medium's refractive index
     source_set=source_set
 )
 
 # %%
 # Defining the detector
 detector_set = Photodiode(
     NA=[0.1, 0.05],  # Numerical Apertures for the detector
@@ -58,16 +60,15 @@
 # Measuring the coupling efficiency
 data = experiment.get(measure.coupling)
 
 # %%
 # Plotting the results
 # Visualizing how the coupling efficiency varies with the core diameter.
 figure = data.plot(
-    x=scatterer_set.core_diameter,  # Core diameter as the x-axis
+    x=experiment.core_diameter,  # Core diameter as the x-axis
     y_scale='linear',  # Linear scale for the y-axis
     normalize=True,  # Normalizing the results
-    add_box=True  # Adding a box around the plot for clarity
 )
 
 # %%
 # Displaying the plot
 _ = figure.show()
```

## docs/examples/experiment/plot_cylinder_Qabs_vs_diameter.py

```diff
@@ -25,15 +25,15 @@
 )
 
 # %%
 # Defining the scatterer distribution
 scatterer_set = Cylinder(
     diameter=np.linspace(1e-9, 800e-9, 300),  # Diameters ranging from 1 nm to 800 nm
     material=[Silver, Gold, Aluminium],  # Scatterer materials
-    n_medium=1,  # Refractive index of the surrounding medium
+    medium_index=1,  # Refractive index of the surrounding medium
     source_set=source_set
 )
 
 # %%
 # Setting up the experiment
 experiment = Setup(
     scatterer_set=scatterer_set,
@@ -46,14 +46,14 @@
 # If Qsca measurement is intended, ensure to use the correct measure object from PyMieSim.
 data = experiment.get(measure.Qabs)  # Assuming Qabs was intended, replace with measure.Qsca if needed
 
 # %%
 # Plotting the results
 # Visualizing how the scattering efficiency varies with the cylinder diameter.
 figure = data.plot(
-    x=scatterer_set.diameter,  # Cylinder diameter as the x-axis
+    x=experiment.diameter,  # Cylinder diameter as the x-axis
     y_scale="linear"  # Linear scale for the y-axis
 )
 
 # %%
 # Displaying the plot
 _ = figure.show()
```

## docs/examples/experiment/plot_cylinder_Qsca_vs_diameter.py

```diff
@@ -24,15 +24,15 @@
 )
 
 # %%
 # Defining the scatterer distribution
 scatterer_set = Cylinder(
     diameter=np.geomspace(6.36e-9, 10000e-9, 1000),  # Diameters ranging from ~6.36 nm to 10000 nm
     index=[1.4],  # Refractive index of the cylinder
-    n_medium=1,  # Refractive index of the surrounding medium
+    medium_index=1,  # Refractive index of the surrounding medium
     source_set=source_set
 )
 
 # %%
 # Setting up the experiment
 experiment = Setup(
     scatterer_set=scatterer_set,
@@ -43,14 +43,14 @@
 # Measuring the scattering efficiency (Qsca)
 data = experiment.get(measure.Qsca)
 
 # %%
 # Plotting the results
 # Visualizing how the Qsca varies with the cylinder diameter.
 figure = data.plot(
-    x=scatterer_set.diameter,  # Cylinder diameter as the x-axis
+    x=experiment.diameter,  # Cylinder diameter as the x-axis
     y_scale='linear'  # Linear scale for the y-axis
 )
 
 # %%
 # Displaying the plot
 _ = figure.show()
```

## docs/examples/experiment/plot_cylinder_Qsca_vs_index.py

```diff
@@ -24,15 +24,15 @@
 )
 
 # %%
 # Defining the scatterer distribution
 scatterer_set = Cylinder(
     diameter=800e-9,  # Fixed diameter of 800 nm
     index=np.linspace(1.3, 1.9, 1500),  # Refractive index ranging from 1.3 to 1.9
-    n_medium=1,  # Refractive index of the surrounding medium
+    medium_index=1,  # Refractive index of the surrounding medium
     source_set=source_set
 )
 
 # %%
 # Setting up the experiment
 experiment = Setup(
     scatterer_set=scatterer_set,
@@ -43,14 +43,14 @@
 # Measuring the scattering efficiency (Qsca)
 data = experiment.get(measure.Qsca)
 
 # %%
 # Plotting the results
 # Visualizing how the Qsca varies with the refractive index of the cylinder.
 figure = data.plot(
-    x=scatterer_set.index,  # Refractive index as the x-axis
+    x=experiment.index,  # Refractive index as the x-axis
     y_scale='linear'  # Linear scale for the y-axis
 )
 
 # %%
 # Displaying the plot
 _ = figure.show()
```

## docs/examples/experiment/plot_cylinder_Qsca_vs_wavelength.py

```diff
@@ -26,35 +26,35 @@
 
 # %%
 # Defining the scatterer distribution
 # Considering cylinders with specific diameters and refractive indices.
 scatterer_set = Cylinder(
     diameter=[200e-9, 150e-9, 100e-9],  # Array of diameters: 200 nm, 150 nm, 100 nm
     index=[2, 3, 4],  # Array of refractive indices: 2, 3, 4
-    n_medium=1,  # Refractive index of the surrounding medium
+    medium_index=1,  # Refractive index of the surrounding medium
     source_set=source_set
 )
 
 # %%
 # Setting up the experiment
 experiment = Setup(
     scatterer_set=scatterer_set,
     source_set=source_set
 )
 
 # %%
 # Measuring the scattering efficiency (Qsca)
 # Averaging the data across the different indices to simplify visualization.
 data = experiment.get(measure.Qsca)
-data = data.mean(scatterer_set.index)
+data = data.mean(experiment.index)
 
 # %%
 # Plotting the results
 # Visualizing how the Qsca varies with wavelength for the given cylinder configurations.
 figure = data.plot(
-    x=source_set.wavelength,  # Wavelength as the x-axis
+    x=experiment.wavelength,  # Wavelength as the x-axis
     y_scale='linear'  # Linear scale for the y-axis
 )
 
 # %%
 # Displaying the plot
 _ = figure.show()
```

## docs/examples/experiment/plot_cylinder_Qsca_vs_wavelength_std.py

```diff
@@ -26,15 +26,15 @@
     NA=0.2
 )
 # %%
 # Defining the ranging parameters for the scatterer distribution
 scatterer_set = Cylinder(
     diameter=np.linspace(400e-9, 1400e-9, 10),
     material=Silver,
-    n_medium=1,
+    medium_index=1,
     source_set=source_set
 )
 
 
 # %%
 # Defining the experiment setup
 experiment = Setup(
@@ -45,13 +45,13 @@
 # %%
 # Measuring the properties
 data = experiment.get(measure.Qsca)
 
 # %%
 # Plotting the results
 figure = data.plot(
-    x=source_set.wavelength,
+    x=experiment.wavelength,
     y_scale='log',
-    std=scatterer_set.diameter
+    std=experiment.diameter
 )
 
 _ = figure.show()
```

## docs/examples/experiment/plot_cylinder_a11_vs_diameter.py

```diff
@@ -24,15 +24,15 @@
 )
 
 # %%
 # Defining the scatterer distribution
 scatterer_set = Cylinder(
     diameter=np.linspace(100e-9, 10000e-9, 800),  # Diameters ranging from 100 nm to 10000 nm
     index=1.4,  # Refractive index of the cylinder
-    n_medium=1,  # Refractive index of the surrounding medium
+    medium_index=1,  # Refractive index of the surrounding medium
     source_set=source_set
 )
 
 # %%
 # Setting up the experiment
 experiment = Setup(
     scatterer_set=scatterer_set,
@@ -44,13 +44,13 @@
 # Note: The original request was for "a21"; assuming it meant A1, as "a21" might be a typo.
 data = experiment.get(measure.a21)
 
 # %%
 # Plotting the results
 # Visualizing how the A1 scattering coefficient varies with the cylinder diameter.
 figure = data.plot(
-    x=scatterer_set.diameter  # Cylinder diameter as the x-axis
+    x=experiment.diameter  # Cylinder diameter as the x-axis
 )
 
 # %%
 # Displaying the plot
 _ = figure.show()
```

## docs/examples/experiment/plot_cylinder_b11_vs_diameter.py

```diff
@@ -24,15 +24,15 @@
 )
 
 # %%
 # Defining the scatterer distribution
 scatterer_set = Cylinder(
     diameter=np.linspace(100e-9, 10000e-9, 800),  # Diameters ranging from 100 nm to 10000 nm
     index=1.4,  # Refractive index of the cylinder
-    n_medium=1,  # Refractive index of the surrounding medium
+    medium_index=1,  # Refractive index of the surrounding medium
     source_set=source_set
 )
 
 # %%
 # Setting up the experiment
 experiment = Setup(
     scatterer_set=scatterer_set,
@@ -43,13 +43,13 @@
 # Measuring the B1 scattering coefficient
 data = experiment.get(measure.b11)
 
 # %%
 # Plotting the results
 # Visualizing how the B1 scattering coefficient varies with the cylinder diameter.
 figure = data.plot(
-    x=scatterer_set.diameter  # Cylinder diameter as the x-axis
+    x=experiment.diameter  # Cylinder diameter as the x-axis
 )
 
 # %%
 # Displaying the plot
 _ = figure.show()
```

## docs/examples/experiment/plot_cylinder_coupling_vs_diameter.py

```diff
@@ -26,15 +26,15 @@
 )
 
 # %%
 # Defining the scatterer distribution
 scatterer_set = Cylinder(
     diameter=np.linspace(100e-9, 3000e-9, 200),  # Diameters ranging from 100 nm to 3000 nm
     material=BK7,  # Material of the cylinder
-    n_medium=1.0,  # Refractive index of the surrounding medium
+    medium_index=1.0,  # Refractive index of the surrounding medium
     source_set=source_set
 )
 
 # %%
 # Defining the detector
 detector_set = Photodiode(
     NA=[0.1, 0.05],  # Numerical Apertures for the detector
@@ -56,15 +56,15 @@
 # Measuring the coupling efficiency
 data = experiment.get(measure.coupling)
 
 # %%
 # Plotting the results
 # Visualizing how the coupling efficiency varies with the cylinder diameter.
 figure = data.plot(
-    x=scatterer_set.diameter,  # Cylinder diameter as the x-axis
+    x=experiment.diameter,  # Cylinder diameter as the x-axis
     y_scale='linear',  # Linear scale for the y-axis
     normalize=True  # Normalizing the results
 )
 
 # %%
 # Displaying the plot
 _ = figure.show()
```

## docs/examples/experiment/plot_cylinder_coupling_vs_phioffset.py

```diff
@@ -26,15 +26,15 @@
 )
 
 # %%
 # Defining the scatterer distribution
 scatterer_set = Cylinder(
     diameter=2e-6,  # 2000 nm
     material=BK7,  # Material of the cylinder
-    n_medium=1,  # Refractive index of the surrounding medium
+    medium_index=1,  # Refractive index of the surrounding medium
     source_set=source_set
 )
 
 # %%
 # Defining the detector
 detector_set = Photodiode(
     NA=[0.5, 0.3, 0.1, 0.05],  # Array of Numerical Apertures for the detector
@@ -56,15 +56,15 @@
 # Measuring the coupling efficiency
 data = experiment.get(measure.coupling)
 
 # %%
 # Plotting the results
 # Visualizing how the coupling efficiency varies with angular displacement.
 figure = data.plot(
-    x=detector_set.phi_offset,  # Angular displacement as the x-axis
+    x=experiment.phi_offset,  # Angular displacement as the x-axis
     y_scale='log',  # Logarithmic scale for the y-axis
     normalize=True  # Normalizing the results
 )
 
 # %%
 # Displaying the plot
 _ = figure.show()
```

## docs/examples/experiment/plot_cylinder_coupling_vs_wavelength.py

```diff
@@ -27,15 +27,15 @@
 
 # %%
 # Defining the scatterer distribution
 # Here we look at cylinders with a set diameter, refractive index, and medium.
 scatterer_set = Cylinder(
     diameter=np.linspace(100e-9, 8000e-9, 5),  # Diameters ranging from 100 nm to 8000 nm
     material=BK7,  # Material of the cylinder
-    n_medium=1,  # Refractive index of the surrounding medium
+    medium_index=1,  # Refractive index of the surrounding medium
     source_set=source_set
 )
 
 # %%
 # Defining the detector
 detector_set = CoherentMode(
     mode_number="LP11",  # Specifying the LP11 mode
@@ -58,14 +58,14 @@
 # Measuring the coupling efficiency
 data = experiment.get(measure.coupling)
 
 # %%
 # Plotting the results
 # Visualizing how the coupling efficiency varies with the wavelength.
 figure = data.plot(
-    x=source_set.wavelength,  # Wavelength as the x-axis
-    std=scatterer_set.diameter  # Standard deviation with respect to cylinder diameter
+    x=experiment.wavelength,  # Wavelength as the x-axis
+    std=experiment.diameter  # Standard deviation with respect to cylinder diameter
 )
 
 # %%
 # Displaying the plot
 _ = figure.show()
```

## docs/examples/experiment/plot_sphere_Qabs_vs_diameter.py

```diff
@@ -25,15 +25,15 @@
     NA=0.2
 )
 # %%
 # Defining the ranging parameters for the scatterer distribution
 scatterer_set = Sphere(
     diameter=np.linspace(1e-09, 800e-9, 300),
     material=[Silver, Gold, Aluminium],
-    n_medium=1,
+    medium_index=1,
     source_set=source_set
 )
 
 # %%
 # Defining the experiment setup
 experiment = Setup(
     scatterer_set=scatterer_set,
@@ -43,12 +43,12 @@
 # %%
 # Measuring the properties
 data = experiment.get(measure.Qabs)
 
 # %%
 # Plotting the results
 figure = data.plot(
-    x=scatterer_set.diameter,
+    x=experiment.diameter,
     y_scale="log"
 )
 
 _ = figure.show()
```

## docs/examples/experiment/plot_sphere_Qsca_vs_diameter.py

```diff
@@ -24,15 +24,15 @@
     NA=0.2
 )
 # %%
 # Defining the ranging parameters for the scatterer distribution
 scatterer_set = Sphere(
     diameter=np.geomspace(6.36e-09, 10000e-9, 1500),
     index=1.4,
-    n_medium=1,
+    medium_index=1,
     source_set=source_set
 )
 
 # %%
 # Defining the experiment setup
 experiment = Setup(
     scatterer_set=scatterer_set,
@@ -42,11 +42,11 @@
 # %%
 # Measuring the properties
 data = experiment.get(measure.Csca)
 
 # %%
 # Plotting the results
 figure = data.plot(
-    x=scatterer_set.diameter
+    x=experiment.diameter
 )
 
 _ = figure.show()
```

## docs/examples/experiment/plot_sphere_Qsca_vs_index.py

```diff
@@ -24,15 +24,15 @@
     NA=0.2
 )
 # %%
 # Defining the ranging parameters for the scatterer distribution
 scatterer_set = Sphere(
     diameter=800e-9,
     index=np.linspace(1.3, 1.9, 1500),
-    n_medium=1,
+    medium_index=1,
     source_set=source_set
 )
 
 # %%
 # Defining the experiment setup
 experiment = Setup(
     scatterer_set=scatterer_set,
@@ -42,11 +42,11 @@
 # %%
 # Measuring the properties
 data = experiment.get(measure.Qsca)
 
 # %%
 # Plotting the results
 figure = data.plot(
-    x=scatterer_set.index
+    x=experiment.index
 )
 
 _ = figure.show()
```

## docs/examples/experiment/plot_sphere_Qsca_vs_wavelength.py

```diff
@@ -24,15 +24,15 @@
     NA=0.2
 )
 # %%
 # Defining the ranging parameters for the scatterer distribution
 scatterer_set = Sphere(
     diameter=[200e-9, 150e-9, 100e-9],
     index=[2, 4],
-    n_medium=1,
+    medium_index=1,
     source_set=source_set
 )
 
 # %%
 # Defining the experiment setup
 experiment = Setup(
     scatterer_set=scatterer_set,
@@ -42,11 +42,11 @@
 # %%
 # Measuring the properties
 data = experiment.get(measure.Csca)
 
 # %%
 # Plotting the results
 figure = data.plot(
-    x=source_set.wavelength
+    x=experiment.wavelength
 )
 
 _ = figure.show()
```

## docs/examples/experiment/plot_sphere_Qsca_vs_wavelength_std.py

```diff
@@ -25,15 +25,15 @@
     NA=0.2
 )
 # %%
 # Defining the ranging parameters for the scatterer distribution
 scatterer_set = Sphere(
     diameter=np.linspace(400e-9, 1400e-9, 10),
     material=Silver,
-    n_medium=1,
+    medium_index=1,
     source_set=source_set
 )
 
 
 # %%
 # Defining the experiment setup
 experiment = Setup(
@@ -44,15 +44,15 @@
 # %%
 # Measuring the properties
 data = experiment.get(measure.Qsca)
 
 # %%
 # Plotting the results
 figure = data.plot(
-    x=source_set.wavelength,
+    x=experiment.wavelength,
     y_scale='log',
-    std=scatterer_set.diameter
+    std=experiment.diameter
 )
 
 _ = figure.show()
 
 # -
```

## docs/examples/experiment/plot_sphere_a1_vs_diameter.py

```diff
@@ -25,15 +25,15 @@
     NA=0.2
 )
 # %%
 # Defining the ranging parameters for the scatterer distribution
 scatterer_set = Sphere(
     diameter=np.linspace(100e-9, 10000e-9, 1000),
     index=1.4,
-    n_medium=1,
+    medium_index=1,
     source_set=source_set
 )
 
 # %%
 # Defining the experiment setup
 experiment = Setup(
     scatterer_set=scatterer_set,
@@ -43,11 +43,11 @@
 # %%
 # Measuring the properties
 data = experiment.get(measure.a1)
 
 # %%
 # Plotting the results
 figure = data.plot(
-    x=scatterer_set.diameter
+    x=experiment.diameter
 )
 
 _ = figure.show()
```

## docs/examples/experiment/plot_sphere_b1_vs_diameter.py

```diff
@@ -25,15 +25,15 @@
     NA=0.2
 )
 # %%
 # Defining the ranging parameters for the scatterer distribution
 scatterer_set = Sphere(
     diameter=np.linspace(100e-9, 10000e-9, 800),
     index=1.4,
-    n_medium=1,
+    medium_index=1,
     source_set=source_set
 )
 
 # %%
 # Defining the experiment setup
 experiment = Setup(
     scatterer_set=scatterer_set,
@@ -43,11 +43,11 @@
 # %%
 # Measuring the properties
 data = experiment.get(measure.b1)
 
 # %%
 # Plotting the results
 figure = data.plot(
-    x=scatterer_set.diameter
+    x=experiment.diameter
 )
 
 _ = figure.show()
```

## docs/examples/experiment/plot_sphere_coupling_vs_diameter.py

```diff
@@ -25,15 +25,15 @@
     NA=0.2
 )
 # %%
 # Defining the ranging parameters for the scatterer distribution
 scatterer_set = Sphere(
     diameter=numpy.linspace(100e-9, 3000e-9, 600),
     material=BK7,
-    n_medium=1.0,
+    medium_index=1.0,
     source_set=source_set
 )
 
 # %%
 # Defining the detector to be employed.
 detector_set = Photodiode(
     NA=[0.15, 0.1, 0.05],
@@ -54,13 +54,13 @@
 # %%
 # Measuring the properties
 data = experiment.get(measure.coupling)
 
 # %%
 # Plotting the results
 figure = data.plot(
-    x=scatterer_set.diameter,
+    x=experiment.diameter,
     y_scale='linear',
     normalize=True
 )
 
 _ = figure.show()
```

## docs/examples/experiment/plot_sphere_coupling_vs_filter.py

```diff
@@ -27,15 +27,15 @@
 )
 
 # %%
 # Defining the ranging parameters for the scatterer distribution
 scatterer_set = Sphere(
     diameter=np.linspace(100e-9, 2000e-9, 20),
     material=BK7,
-    n_medium=1,
+    medium_index=1,
     source_set=source_set
 )
 
 # %%
 # Defining the detector to be employed.
 detector_set = CoherentMode(
     mode_number="HG11:00",
@@ -57,12 +57,12 @@
 # %%
 # Measuring the properties
 data = experiment.get(measure.coupling)
 
 # %%
 # Plotting the results
 figure = data.plot(
-    x=detector_set.polarization_filter,
-    std=scatterer_set.diameter
+    x=experiment.polarization_filter,
+    std=experiment.diameter
 )
 
 _ = figure.show()
```

## docs/examples/experiment/plot_sphere_coupling_vs_phioffset.py

```diff
@@ -27,15 +27,15 @@
     NA=0.2
 )
 # %%
 # Defining the ranging parameters for the scatterer distribution
 scatterer_set = Sphere(
     diameter=2000e-9,
     material=BK7,
-    n_medium=1,
+    medium_index=1,
     source_set=source_set
 )
 
 # %%
 # Defining the detector to be employed.
 detector_set = Photodiode(
     NA=[0.5, 0.3, 0.1, 0.05],
@@ -56,13 +56,13 @@
 # %%
 # Measuring the properties
 data = experiment.get(measure.coupling)
 
 # %%
 # Plotting the results
 figure = data.plot(
-    x=detector_set.phi_offset,
+    x=experiment.phi_offset,
     y_scale='log',
     normalize=True
 )
 
 _ = figure.show()
```

## docs/examples/experiment/plot_sphere_coupling_vs_wavelength.py

```diff
@@ -27,15 +27,15 @@
 )
 
 # %%
 # Defining the ranging parameters for the scatterer distribution
 scatterer_set = Sphere(
     diameter=np.linspace(100e-9, 8000e-9, 5),
     material=BK7,
-    n_medium=1,
+    medium_index=1,
     source_set=source_set
 )
 
 # %%
 # Defining the detector to be employed.
 detector_set = CoherentMode(
     mode_number="LP11:00",
@@ -57,12 +57,12 @@
 # %%
 # Measuring the properties
 data = experiment.get(measure.coupling)
 
 # %%
 # Plotting the results
 figure = data.plot(
-    x=source_set.wavelength,
-    std=scatterer_set.diameter
+    x=experiment.wavelength,
+    std=experiment.diameter
 )
 
 _ = figure.show()
```

## docs/examples/extras/SphereProperties.py

```diff
@@ -15,15 +15,16 @@
 )
 
 source.plot().show()
 
 scatterer = Sphere(
     diameter=800e-9,
     source=source,
-    index=1.4
+    index=1.4,
+    medium_index=1.0
 )
 
 
 farfield = scatterer.get_far_field(sampling=300)
 
 farfield.plot().show()
```

## docs/examples/extras/plot_Qsca_vs_permittivity_vs_size_parameter.py

```diff
@@ -35,15 +35,15 @@
     NA=0.2
 )
 
 
 scatterer_set = Sphere(
     diameter=diameter,
     index=index,
-    n_medium=1,
+    medium_index=1,
     source_set=source_set
 )
 
 experiment = Setup(
     scatterer_set=scatterer_set,
     source_set=source_set
 )
```

## docs/examples/extras/plot_coupling_heatmap.py

```diff
@@ -32,15 +32,15 @@
     NA=0.2
 )
 
 
 scatterer_set = Sphere(
     diameter=diameter,
     index=index,
-    n_medium=1,
+    medium_index=1,
     source_set=source_set
 )
 
 
 detector_set = Photodiode(
     polarization_filter=None,
     NA=0.3,
```

## docs/examples/scatterer/plot_farfield.py

```diff
@@ -22,15 +22,15 @@
 
 # %%
 # Defining the scatterer
 scatterer = Sphere(
     diameter=1.5e-6,  # 1500 nm
     source=source,
     index=1.4,  # Refractive index of the scatterer
-    n_medium=1.0  # Refractive index of the surrounding medium
+    medium_index=1.0  # Refractive index of the surrounding medium
 )
 
 # %%
 # Computing the data
 data = scatterer.get_far_field(sampling=100)  # Specify the number of sampling points
 
 # %%
```

## docs/examples/scatterer/plot_spf.py

```diff
@@ -22,15 +22,15 @@
 
 # %%
 # Defining the scatterer
 scatterer = Sphere(
     diameter=1.2e-6,  # 1200 nm
     source=source,
     index=1.4,  # Refractive index of the scatterer
-    n_medium=1.0,  # Refractive index of the surrounding medium
+    medium_index=1.0,  # Refractive index of the surrounding medium
 )
 
 # %%
 # Computing the data
 data = scatterer.get_spf(sampling=300)  # Specify the number of sampling points
 
 # %%
```

## docs/examples/validation/plot_BH810.py

```diff
@@ -26,15 +26,15 @@
     NA=0.1,
 )
 
 scatterer_set = Cylinder(
     diameter=3000e-9,
     source=source,
     index=1.0 + 0.07j,
-    n_medium=1.0
+    medium_index=1.0
 )
 
 S1S2 = scatterer_set.get_s1s2(sampling=800)
 Data = (numpy.abs(S1S2.S1)**2 + numpy.abs(S1S2.S2)**2) * (0.5 / (numpy.pi * source.k))**(1 / 4)
 
 plt.figure(figsize=(8, 4))
 plt.plot(S1S2.phi, Data, 'C1-', linewidth=3, label='PyMieSim')
```

## docs/examples/validation/plot_BH87.py

```diff
@@ -29,15 +29,15 @@
     optical_power=1e-3,
     NA=0.2
 )
 
 scatterer_set = Cylinder(
     diameter=diameter,
     index=1.55,
-    n_medium=1,
+    medium_index=1,
     source_set=source_set
 )
 
 experiment = Setup(
     scatterer_set=scatterer_set,
     source_set=source_set,
     detector_set=None
```

## docs/examples/validation/plot_BH88.py

```diff
@@ -1,65 +1,77 @@
 """
-Bohren-Huffman (figure~8.8)
-===========================
+Comparison of PyMieSim and Theoretical Bohren-Huffman Data for Cylinder Scattering
+==================================================================================
 
 """
 
-# %%
-# Importing the dependencies: numpy, matplotlib, PyMieSim
-import numpy
+# Standard library imports
+import numpy as np
 import matplotlib.pyplot as plt
 
+# PyMieSim imports
 from PyMieSim.tools.directories import validation_data_path
-
 from PyMieSim.experiment.scatterer import Cylinder
 from PyMieSim.experiment.source import Gaussian
 from PyMieSim.experiment import Setup
+import PyMieSim.measure as measure
 
-from PyMieSim import measure
-
-theoretical = numpy.genfromtxt(f"{validation_data_path}/Figure88BH.csv", delimiter=',')
+# Load theoretical data
+theoretical_data = np.genfromtxt(f"{validation_data_path}/Figure88BH.csv", delimiter=',')
 
-diameter = numpy.geomspace(10e-9, 6e-6, 800)
-volume = numpy.pi * (diameter / 2)**2
-
-source_set = Gaussian(
-    wavelength=632.8e-9,
-    polarization_value=[0, 90],
+# Define parameters
+wavelength = 632.8e-9  # Wavelength of the source in meters
+polarization_values = [0, 90]  # Polarization values in degrees
+optical_power = 1e-3  # Optical power in watts
+NA = 0.2  # Numerical aperture
+diameters = np.geomspace(10e-9, 6e-6, 800)  # Diameters from 10 nm to 6 μm
+index = 1.55  # Refractive index of the cylinder
+medium_index = 1.335  # Refractive index of the medium
+
+# Calculate the volume of the cylinders
+volumes = np.pi * (diameters / 2)**2
+
+# Configure the Gaussian source
+source = Gaussian(
+    wavelength=wavelength,
+    polarization_value=polarization_values,
     polarization_type='linear',
-    optical_power=1e-3,
-    NA=0.2
-)
-scatterer_set = Cylinder(
-    diameter=diameter,
-    index=1.55,
-    n_medium=1.335,
-    source_set=source_set
+    optical_power=optical_power,
+    NA=NA
 )
 
+# Setup cylindrical scatterers
+scatterer = Cylinder(
+    diameter=diameters,
+    index=index,
+    medium_index=medium_index,
+    source_set=source
+)
 
+# Create experimental setup
 experiment = Setup(
-    scatterer_set=scatterer_set,
-    source_set=source_set,
+    scatterer_set=scatterer,
+    source_set=source,
     detector_set=None
 )
 
-data = experiment.get(measure.Csca, export_as_numpy=True)
-data = data.squeeze() / volume * 1e-4 / 100
+# Compute PyMieSim scattering cross section data
+csca_data = experiment.get(measure.Csca, export_as_numpy=True).squeeze()
+normalized_csca = csca_data / volumes * 1e-4 / 100  # Normalize the data as per specific needs
 
+# Plotting the results
 plt.figure(figsize=(8, 4))
-plt.plot(diameter, data[0], 'C0-', linewidth=3, label='PyMieSim')
-plt.plot(diameter, data[1], 'C1-', linewidth=3, label='PyMieSim')
-
-plt.plot(diameter, theoretical[0], 'k--', linewidth=1, label='BH 8.8')
-plt.plot(diameter, theoretical[1], 'k--', linewidth=1, label='BH 8.8')
-
-plt.xlabel(r'diameter [$\mu$m]')
-plt.ylabel('Scattering cross section [Cylinder]')
+plt.plot(diameters * 1e6, normalized_csca[0], 'C0-', linewidth=3, label='PyMieSim Polarization: 0')
+plt.plot(diameters * 1e6, normalized_csca[1], 'C1-', linewidth=3, label='PyMieSim Polarization: 90')
+plt.plot(diameters * 1e6, theoretical_data[0], 'k--', linewidth=1, label='Theoretical BH 8.8 Polarization: 0')
+plt.plot(diameters * 1e6, theoretical_data[1], 'k--', linewidth=1, label='Theoretical BH 8.8 Polarization: 90')
+
+plt.xlabel('Diameter (μm)')
+plt.ylabel('Normalized Scattering Cross Section')
+plt.title('Comparison of Scattering Cross Sections for Cylinders')
 plt.grid(True)
 plt.legend()
 plt.tight_layout()
 plt.show()
 
-assert numpy.all(numpy.isclose(data, theoretical, 1e-9)), 'Error: mismatch on BH_8.8 calculation occuring'
-
-# -
+# Verify data accuracy
+assert np.allclose(normalized_csca, theoretical_data, atol=1e-9), 'Error: mismatch on BH 8.8 calculation occurring'
```

### encoding

```diff
@@ -1 +1 @@
-us-ascii
+utf-8
```

## docs/examples/validation/plot_phase_function_detector.py

```diff
@@ -1,94 +1,94 @@
 """
-Goniometrique coupling vs S1 S2
-===============================
+Goniometric Coupling vs S1 S2 Comparison
+========================================
 
 """
 
-# %%
-# Importing the dependencies: numpy, matplotlib, PyMieSim
-import numpy
+# Standard library imports
+import numpy as np
 import matplotlib.pyplot as plt
 
+# PyMieSim imports
 from PyMieSim.experiment.detector import Photodiode
-from PyMieSim.experiment.scatterer import Sphere as SetSphere
-from PyMieSim.experiment.source import Gaussian as SetGaussian
+from PyMieSim.experiment.scatterer import Sphere as ExperimentSphere
+from PyMieSim.experiment.source import Gaussian as ExperimentGaussian
 from PyMieSim.experiment import Setup
 
 from PyMieSim import measure
 from PyMieSim.single.scatterer import Sphere as SingleSphere
 from PyMieSim.single.source import Gaussian as SingleGaussian
 
-scatterer_diameter = 0.3e-6
-scatterer_index = 1.4
-source_wavelength = 1.2e-6
+# Setup parameters
+scatterer_diameter = 0.3e-6  # Diameter of the scatterer in meters
+scatterer_index = 1.4  # Refractive index of the scatterer
+source_wavelength = 1.2e-6  # Wavelength of the source in meters
 
-source_set = SetGaussian(
+# Experiment source and scatterer setup
+source = ExperimentGaussian(
     wavelength=source_wavelength,
     polarization_value=[0, 90],
     polarization_type='linear',
     optical_power=1,
     NA=0.2
 )
-scatterer_set = SetSphere(
+
+scatterer = ExperimentSphere(
     diameter=scatterer_diameter,
     index=scatterer_index,
-    n_medium=1.0,
-    source_set=source_set
+    medium_index=1.0,
+    source_set=source
 )
 
-
-detector_set = Photodiode(
+# Detector setup
+detector = Photodiode(
     NA=[0.1],
-    phi_offset=numpy.linspace(-180, 180, 100),
+    phi_offset=np.linspace(-180, 180, 100),
     gamma_offset=0.0,
     sampling=1000,
     polarization_filter=None
 )
 
+# Configure experiment
 experiment = Setup(
-    scatterer_set=scatterer_set,
-    source_set=source_set,
-    detector_set=detector_set
+    scatterer_set=scatterer,
+    source_set=source,
+    detector_set=detector
 )
 
-data = experiment.get(measure.coupling, export_as_numpy=True)
+# Gather data
+coupling_data = experiment.get(measure.coupling, export_as_numpy=True).squeeze()
+coupling_data /= coupling_data.max()  # Normalize data
 
-source = SingleGaussian(
+# Single scatterer simulation for S1 and S2
+single_source = SingleGaussian(
     wavelength=source_wavelength,
     polarization_value=90,
     polarization_type='linear',
     optical_power=1,
     NA=0.2
 )
 
-scatterer = SingleSphere(
+single_scatterer = SingleSphere(
     diameter=scatterer_diameter,
-    source=source,
+    source=single_source,
     index=scatterer_index,
-    n_medium=1.0
+    medium_index=1.0
 )
 
-s1s2 = scatterer.get_s1s2()
-phi, s1, s2 = s1s2.phi, s1s2.S1, s1s2.S2
-
-figure, (ax0, ax1) = plt.subplots(1, 2, figsize=(10, 4), subplot_kw={'projection': 'polar'})
+s1s2 = single_scatterer.get_s1s2()
+phi, s1, s2 = s1s2.phi, np.abs(s1s2.S1)**2, np.abs(s1s2.S2)**2
+s1 /= s1.max()  # Normalize S1 data
+s2 /= s2.max()  # Normalize S2 data
 
-data0_S1 = numpy.abs(s1)**2
-data0_S1 /= data0_S1.max()
-data0_S2 = numpy.abs(s2)**2
-data0_S2 /= data0_S2.max()
+# Plotting the results
+fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(10, 4), subplot_kw={'projection': 'polar'})
+ax1.plot(np.deg2rad(phi), s1, 'b-', linewidth=3, label='Computed S1')
+ax1.plot(np.deg2rad(detector.phi_offset), coupling_data[0], 'k--', linewidth=1, label='Coupling for polarization: 0')
 
-data1 = data.squeeze()
-data1 /= data1.max()
+ax2.plot(np.deg2rad(phi), s2, 'r-', linewidth=3, label='Computed S2')
+ax2.plot(np.deg2rad(detector.phi_offset), coupling_data[1], 'k--', linewidth=1, label='Coupling for polarization: 90')
 
-ax0.plot(numpy.deg2rad(phi), data0_S1, linewidth=3, zorder=1, label='Computed s1')
-ax0.plot(numpy.deg2rad(detector_set.phi_offset.values.squeeze()), data1[0], linestyle='--', color='k', zorder=10, label='Computed coupling for polarization: 0')
-
-ax1.plot(numpy.deg2rad(phi), data0_S2, linewidth=3, zorder=1, label='Computed s2')
-ax1.plot(numpy.deg2rad(detector_set.phi_offset.values.squeeze()), data1[1], linestyle='--', color='k', zorder=10, label='Computed coupling for polarization: 90')
-
-ax0.legend()
-ax1.legend()
+ax1.legend(loc='upper right')
+ax2.legend(loc='upper right')
+plt.tight_layout()
 plt.show()
-
-# -
```

## docs/examples/validation/plot_pymiescatt_0.py

```diff
@@ -1,73 +1,72 @@
 """
-PyMieSim vs PyMieScatt: 0
-=========================
-
+PyMieSim vs PyMieScatt Comparison
+=================================
 """
 
-# %%
-# Importing the dependencies: numpy, matplotlib, PyMieSim
-import numpy
+# Standard library imports
+import numpy as np
 import matplotlib.pyplot as plt
 
-from PyMieSim.tools.directories import validation_data_path
-
+# PyMieSim imports
 from PyMieSim.experiment.scatterer import Sphere
 from PyMieSim.experiment.source import Gaussian
 from PyMieSim.experiment import Setup
+import PyMieSim.measure as measure
 
-from PyMieSim import measure
-
-data_directory = validation_data_path.joinpath('PyMieScattQscaMedium.csv')
-theoretical = numpy.genfromtxt(data_directory, delimiter=',')
+# PyMieScatt import
+import PyMieScatt as pms
 
-diameter = numpy.geomspace(10e-9, 6e-6, 800)
-
-source_set = Gaussian(
-    wavelength=632.8e-9,
-    polarization_value=0,
-    polarization_type='linear',
-    optical_power=1e-3,
-    NA=0.2
-)
-scatterer_set = Sphere(
-    diameter=diameter,
-    index=1.4,
-    n_medium=1.21,
-    source_set=source_set
+# Define parameters
+wavelength = 632.8e-9  # Wavelength of the light source in meters
+polarization_value = 0
+polarization_type = 'linear'
+optical_power = 1e-3  # Power in watts
+NA = 0.2  # Numerical aperture
+medium_index = 1.21
+refractive_index = 1.4
+diameter_range = np.geomspace(10e-9, 1e-6, 50)  # Geometric space for diameters
+
+# Setup source
+source = Gaussian(
+    wavelength=wavelength,
+    polarization_value=polarization_value,
+    polarization_type=polarization_type,
+    optical_power=optical_power,
+    NA=NA
 )
 
+# Setup scatterer
+scatterer = Sphere(
+    diameter=diameter_range,
+    index=refractive_index,
+    medium_index=medium_index,
+    source_set=source
+)
 
+# Define experiment setup
 experiment = Setup(
-    scatterer_set=scatterer_set,
-    source_set=source_set,
-    detector_set=None
+    scatterer_set=scatterer,
+    source_set=source,
+    detector_set=None  # No detector set specified
 )
 
-data = experiment.get(measure.Qsca, export_as_numpy=True)
-data = data.squeeze()
+# Simulate using PyMieSim
+sim_data = experiment.get(measure.Qsca, export_as_numpy=True).squeeze()
 
-plt.figure(figsize=(8, 4))
-plt.plot(
-    diameter,
-    data,
-    'C1-',
-    linewidth=3,
-    label='PyMieSim'
-)
-
-plt.plot(
-    diameter,
-    theoretical,
-    'k--',
-    linewidth=1,
-    label='PyMieScatt'
-)
+# Simulate using PyMieScatt
+scatt_data = np.array([
+    pms.MieQ(m=refractive_index, diameter=d, wavelength=wavelength, nMedium=medium_index)[1]
+    for d in diameter_range
+])
 
-plt.xlabel(r'diameter [$\mu$m]')
-plt.ylabel('Scattering efficiency [Sphere + n_medium]')
+# Plot results
+plt.figure(figsize=(8, 4))
+plt.plot(diameter_range * 1e6, sim_data, 'C1-', linewidth=3, label='PyMieSim')
+plt.plot(diameter_range * 1e6, scatt_data, 'k--', linewidth=1, label='PyMieScatt')
+plt.xlabel('Diameter (μm)')
+plt.ylabel('Scattering Efficiency')
+plt.title('Comparison of Scattering Efficiency: PyMieSim vs PyMieScatt')
 plt.grid(True)
 plt.legend()
 plt.tight_layout()
 plt.show()
-
-# -
```

### encoding

```diff
@@ -1 +1 @@
-us-ascii
+utf-8
```

## docs/examples/validation/plot_pymiescatt_1.py

```diff
@@ -1,83 +1,74 @@
 """
-PyMieSim vs PyMieScatt: 1
-=========================
+Comparison of Scattering Efficiency Using PyMieSim vs PyMieScatt
+================================================================
 
 """
 
-# %%
-# Importing the dependencies: numpy, matplotlib, PyMieSim, PyMieScatt
-import numpy
+# Standard library imports
+import numpy as np
 import matplotlib.pyplot as plt
 
+# PyMieSim imports
 from PyMieSim.experiment.scatterer import Sphere
 from PyMieSim.experiment.source import Gaussian
 from PyMieSim.experiment import Setup
+import PyMieSim.measure as measure
 
-from PyMieSim import measure
+# PyMieScatt import
+import PyMieScatt as pms
 
-import PyMieScatt as ps
-
-diameters = numpy.geomspace(10e-9, 6e-6, 800)
-index = 1.4
-
-source_set = Gaussian(
-    wavelength=632.8e-9,
+# Define parameters
+wavelength = 632.8e-9  # Wavelength of the source in meters
+index = 1.4  # Refractive index of the sphere
+medium_index = 1.0  # Refractive index of the medium
+optical_power = 1  # Power of the light source in watts
+NA = 0.2  # Numerical aperture
+diameters = np.geomspace(10e-9, 6e-6, 800)  # Diameters from 10 nm to 6 μm
+
+# Configure the Gaussian source
+source = Gaussian(
+    wavelength=wavelength,
     polarization_value=0,
     polarization_type='linear',
-    optical_power=1,
-    NA=0.2
+    optical_power=optical_power,
+    NA=NA
 )
 
-scatterer_set = Sphere(
+# Setup spherical scatterer
+scatterer = Sphere(
     diameter=diameters,
     index=index,
-    n_medium=1.,
-    source_set=source_set
+    medium_index=medium_index,
+    source_set=source
 )
 
-PyMieScatt_data = []
-for diameter in diameters:
-    efficiencies = ps.MieQ(
-        m=index,
-        wavelength=source_set.wavelength.base_values,
-        diameter=diameter,
-    )
-
-    PyMieScatt_data.append(efficiencies[1])
-
-PyMieScatt_data = numpy.asarray(PyMieScatt_data).squeeze()
-
+# Create experimental setup
 experiment = Setup(
-    scatterer_set=scatterer_set,
-    source_set=source_set,
-    detector_set=None
+    scatterer_set=scatterer,
+    source_set=source,
+    detector_set=None  # No detector configuration
 )
 
-data = experiment.get(measure.Qsca, export_as_numpy=True)
-PyMieSim_data = data.squeeze()
+# Compute PyMieSim scattering efficiency data
+sim_data = experiment.get(measure.Qsca, export_as_numpy=True).squeeze()
 
-plt.figure(figsize=(8, 4))
-plt.plot(
-    diameters,
-    PyMieSim_data,
-    'C1-',
-    linewidth=3,
-    label='PyMieSim'
-)
-
-plt.plot(
-    diameters,
-    PyMieScatt_data,
-    'k--',
-    linewidth=1,
-    label='PyMieScatt'
-)
+# Compute PyMieScatt scattering efficiency data
+scatt_data = np.array([
+    pms.MieQ(
+        m=index,
+        wavelength=wavelength,
+        diameter=d
+    )[1] for d in diameters
+]).squeeze()
 
-plt.xlabel(r'diameter [$\mu$m]')
-plt.ylabel('Scattering efficiency [Sphere]')
+# Plotting the results
+plt.figure(figsize=(8, 4))
+plt.plot(diameters * 1e6, sim_data, 'C1-', linewidth=3, label='PyMieSim')
+plt.plot(diameters * 1e6, scatt_data, 'k--', linewidth=1, label='PyMieScatt')
+plt.xlabel('Diameter (μm)')
+plt.ylabel('Scattering Efficiency')
+plt.title('Scattering Efficiency Comparison: Sphere')
 plt.grid(True)
 plt.legend()
 plt.tight_layout()
 plt.show()
-
-# -
```

### encoding

```diff
@@ -1 +1 @@
-us-ascii
+utf-8
```

## docs/examples/validation/plot_pymiescatt_2.py

```diff
@@ -1,77 +1,83 @@
 """
-PyMieSim vs PyMieScatt: 2
-=========================
-
+PyMieSim vs PyMieScatt for Core-Shell Particles
+===============================================
 """
 
-# %%
-# Importing the dependencies: numpy, matplotlib, PyMieSim, PyMieScatt
-import numpy
+# Standard library imports
+import numpy as np
 import matplotlib.pyplot as plt
-import PyMieScatt as ps
 
+# PyMieSim imports
 from PyMieSim.experiment.scatterer import CoreShell
 from PyMieSim.experiment.source import Gaussian
 from PyMieSim.experiment import Setup
+import PyMieSim.measure as measure
 
-from PyMieSim import measure
+# PyMieScatt import
+import PyMieScatt as pms
 
-core_diameters = numpy.geomspace(10e-9, 500e-9, 400)
-shell_width = 600e-9
+# Define parameters
+wavelength = 600e-9  # Light source wavelength in meters
+polarization_value = 0
+polarization_type = 'linear'
+optical_power = 1  # Power in watts
+NA = 0.2  # Numerical aperture
+medium_index = 1.2
 core_index = 1.5
 shell_index = 1.4
+shell_width = 600e-9  # Shell width in meters
+core_diameters = np.geomspace(10e-9, 500e-9, 400)  # Core diameters in meters
 
-source_set = Gaussian(
-    wavelength=600e-9,
-    polarization_value=0,
-    polarization_type='linear',
-    optical_power=1,
-    NA=0.2
+# Setup source
+source = Gaussian(
+    wavelength=wavelength,
+    polarization_value=polarization_value,
+    polarization_type=polarization_type,
+    optical_power=optical_power,
+    NA=NA
 )
 
-scatterer_set = CoreShell(
+# Setup scatterer
+scatterer = CoreShell(
     core_diameter=core_diameters,
     shell_width=shell_width,
     core_index=core_index,
     shell_index=shell_index,
-    n_medium=1.0,
-    source_set=source_set
+    medium_index=medium_index,
+    source_set=source
 )
 
-PyMieScatt_data = []
-for core_diameter in core_diameters:
-    efficiencies = ps.MieQCoreShell(
-        mCore=core_index,
-        mShell=shell_index,
-        wavelength=source_set.wavelength.base_values,
-        dCore=core_diameter,
-        dShell=core_diameter + shell_width
-    )
-
-    PyMieScatt_data.append(efficiencies[1])
-
-PyMieScatt_data = numpy.asarray(PyMieScatt_data).squeeze()
-
+# Define experiment setup
 experiment = Setup(
-    scatterer_set=scatterer_set,
-    source_set=source_set,
-    detector_set=None
+    scatterer_set=scatterer,
+    source_set=source,
+    detector_set=None  # No detector set specified
 )
 
-data = experiment.get(measure.Qsca, export_as_numpy=True)
+# Simulate using PyMieSim
+sim_data = experiment.get(measure.Qsca, export_as_numpy=True).squeeze()
 
-PyMieSim_data = data.squeeze()
+# Simulate using PyMieScatt
+scatt_data = np.array([
+    pms.MieQCoreShell(
+        mCore=core_index,
+        mShell=shell_index,
+        wavelength=wavelength,
+        dCore=diameter,
+        dShell=diameter + shell_width,
+        nMedium=medium_index
+    )[1]
+    for diameter in core_diameters
+])
 
+# Plot results
 plt.figure(figsize=(8, 4))
-plt.plot(core_diameters, PyMieSim_data, 'C1-', linewidth=3, label='PyMieSim')
-
-plt.plot(core_diameters, PyMieScatt_data, 'k--', linewidth=1, label='PyMieScatt')
-
-plt.xlabel(r'diameter [$\mu$m]')
-plt.ylabel('Scattering efficiency [CoreShell]')
+plt.plot(core_diameters * 1e6, sim_data, 'C1-', linewidth=3, label='PyMieSim')
+plt.plot(core_diameters * 1e6, scatt_data, 'k--', linewidth=1, label='PyMieScatt')
+plt.xlabel('Core Diameter (μm)')
+plt.ylabel('Scattering Efficiency')
+plt.title('Scattering Efficiency Comparison for Core-Shell Particles')
 plt.grid(True)
 plt.legend()
 plt.tight_layout()
 plt.show()
-
-# -
```

### encoding

```diff
@@ -1 +1 @@
-us-ascii
+utf-8
```

## docs/examples/validation/plot_pymiescatt_3.py

```diff
@@ -1,77 +1,82 @@
 """
-PyMieSim vs PyMieScatt: 3
-=========================
+PyMieSim vs PyMieScatt Scattering Efficiency Comparison for Core-Shell Particles
+================================================================================
 
 """
 
-# %%
-# Importing the dependencies: numpy, matplotlib, PyMieSim, PyMieScatt
-import numpy
+# Standard library imports
+import numpy as np
 import matplotlib.pyplot as plt
 
+# PyMieSim imports
 from PyMieSim.experiment.scatterer import CoreShell
 from PyMieSim.experiment.source import Gaussian
 from PyMieSim.experiment import Setup
+import PyMieSim.measure as measure
 
-from PyMieSim import measure
+# PyMieScatt import
+import PyMieScatt as pms
 
-import PyMieScatt as ps
-
-core_diameters = numpy.geomspace(10e-9, 500e-9, 400)
-shell_width = 600e-9
+# Define parameters
+wavelength = 600e-9  # Light source wavelength in meters
+polarization_value = 0
+polarization_type = 'linear'
+optical_power = 1  # Optical power in watts
+NA = 0.2  # Numerical aperture
+medium_index = 1.0
 core_index = 1.5
 shell_index = 1.4
+shell_width = 600e-9  # Shell width in meters
+core_diameters = np.geomspace(10e-9, 500e-9, 400)  # Core diameters in meters
 
-source_set = Gaussian(
-    wavelength=600e-9,
-    polarization_value=0,
-    polarization_type='linear',
-    optical_power=1,
-    NA=0.2
+# Configure the Gaussian source
+source = Gaussian(
+    wavelength=wavelength,
+    polarization_value=polarization_value,
+    polarization_type=polarization_type,
+    optical_power=optical_power,
+    NA=NA
 )
 
-scatterer_set = CoreShell(
+# Setup core-shell scatterer
+scatterer = CoreShell(
     core_diameter=core_diameters,
     shell_width=shell_width,
     core_index=core_index,
     shell_index=shell_index,
-    n_medium=1.0,
-    source_set=source_set
+    medium_index=medium_index,
+    source_set=source
 )
 
-PyMieScatt_data = []
-for core_diameter in core_diameters:
-    efficiencies = ps.MieQCoreShell(
-        mCore=core_index,
-        mShell=shell_index,
-        wavelength=source_set.wavelength.base_values,
-        dCore=core_diameter,
-        dShell=core_diameter + shell_width
-    )
-
-    PyMieScatt_data.append(efficiencies[1])
-
-PyMieScatt_data = numpy.asarray(PyMieScatt_data).squeeze()
-
+# Create experimental setup
 experiment = Setup(
-    scatterer_set=scatterer_set,
-    source_set=source_set,
+    scatterer_set=scatterer,
+    source_set=source,
     detector_set=None
 )
 
-data = experiment.get(measure.Qsca)
-PyMieSim_data = data.y.values.squeeze()
+# Compute PyMieSim scattering efficiency data
+sim_data = experiment.get(measure.Qsca, export_as_numpy=True).squeeze()
 
-plt.figure(figsize=(8, 4))
-plt.plot(core_diameters, PyMieSim_data, 'C1-', linewidth=3, label='PyMieSim')
-
-plt.plot(core_diameters, PyMieScatt_data, 'k--', linewidth=1, label='PyMieScatt')
+# Compute PyMieScatt scattering efficiency data
+scatt_data = np.array([
+    pms.MieQCoreShell(
+        mCore=core_index,
+        mShell=shell_index,
+        wavelength=wavelength,
+        dCore=diameter,
+        dShell=diameter + shell_width
+    )[1] for diameter in core_diameters
+]).squeeze()
 
-plt.xlabel(r'diameter [$\mu$m]')
-plt.ylabel('Scattering efficiency [CoreShell + n_medium]')
+# Plotting the results
+plt.figure(figsize=(8, 4))
+plt.plot(core_diameters * 1e6, sim_data, 'C1-', linewidth=3, label='PyMieSim')
+plt.plot(core_diameters * 1e6, scatt_data, 'k--', linewidth=1, label='PyMieScatt')
+plt.xlabel('Core Diameter (μm)')
+plt.ylabel('Scattering Efficiency')
+plt.title('Comparison of Scattering Efficiency for Core-Shell Particles')
 plt.grid(True)
 plt.legend()
 plt.tight_layout()
 plt.show()
-
-# -
```

### encoding

```diff
@@ -1 +1 @@
-us-ascii
+utf-8
```

## tests/detectors/test_coherent_mode.py

```diff
@@ -30,15 +30,15 @@
         NA=0.3
     )
 
     scatterer = Sphere(
         diameter=100e-9,
         source=source,
         index=1.4,
-        n_medium=1.0
+        medium_index=1.0
     )
 
     detector = CoherentMode(
         mode_number=mode_number,
         NA=0.2,
         sampling=100,
         gamma_offset=0,
```

## tests/detectors/test_integration_sphere.py

```diff
@@ -20,15 +20,15 @@
         NA=0.3
     )
 
     scatterer = Sphere(
         diameter=100e-9,
         source=source,
         index=1.4,
-        n_medium=1.0
+        medium_index=1.0
     )
 
     detector = IntegratingSphere(sampling=sampling)
 
     detector.get_footprint(scatterer=scatterer)
 
     detector.plot()
```

## tests/detectors/test_photodiode.py

```diff
@@ -19,15 +19,15 @@
         optical_power=1,
         NA=0.3
     )
     scatterer = Sphere(
         diameter=100e-9,
         source=source,
         index=1.4,
-        n_medium=1.0
+        medium_index=1.0
     )
 
     detector = Photodiode(
         NA=0.2,
         sampling=sampling,
         gamma_offset=0,
         phi_offset=0
```

## tests/experiments/test_coreshell.py

```diff
@@ -1,76 +1,86 @@
 #!/usr/bin/env python
 # -*- coding: utf-8 -*-
 
 import pytest
-import numpy
+import numpy as np
 
 from PyMieSim.experiment.detector import Photodiode
 from PyMieSim.experiment.scatterer import CoreShell
 from PyMieSim.experiment.source import Gaussian
 from PyMieSim.experiment import Setup
-from PyMieSim import measure
+import PyMieSim.measure as pms_measure
 from PyMieSim.materials import Silver, BK7, Aluminium
 
-core_type = [
-    {'name': 'BK7', 'kwarg': {'core_material': BK7}},
-    {'name': 'Silver', 'kwarg': {'core_material': Silver}},
-    {'name': 'Aluminium', 'kwarg': {'core_material': Aluminium}},
-    {'name': 'Index', 'kwarg': {'core_index': 1.4}}
+# Define core materials and properties
+core_options = [
+    {'name': 'BK7', 'properties': {'core_material': BK7}},
+    {'name': 'Silver', 'properties': {'core_material': Silver}},
+    {'name': 'Aluminium', 'properties': {'core_material': Aluminium}},
+    {'name': 'Index', 'properties': {'core_index': 1.4}}
 ]
 
-shell_type = [
-    {'name': 'BK7', 'kwarg': {'shell_material': BK7}},
-    {'name': 'Silver', 'kwarg': {'shell_material': Silver}},
-    {'name': 'Aluminium', 'kwarg': {'shell_material': Aluminium}},
-    {'name': 'Index', 'kwarg': {'shell_index': 1.4}}
+# Define shell materials and properties
+shell_options = [
+    {'name': 'BK7', 'properties': {'shell_material': BK7}},
+    {'name': 'Silver', 'properties': {'shell_material': Silver}},
+    {'name': 'Aluminium', 'properties': {'shell_material': Aluminium}},
+    {'name': 'Index', 'properties': {'shell_index': 1.4}}
 ]
 
+# Define medium materials and properties
+medium_options = [
+    {'name': 'BK7', 'properties': {'medium_material': BK7}},
+    {'name': 'Index', 'properties': {'medium_index': 1.1}}
+]
+
+# Define measures to test
 measures = [
-    measure.Qsca,
-    measure.Qabs,
-    measure.Qback,
-    measure.g,
-    measure.a1,
-    measure.b1,
-    measure.coupling
+    pms_measure.Qsca, pms_measure.Qabs, pms_measure.Qback,
+    pms_measure.g, pms_measure.a1, pms_measure.b1, pms_measure.coupling
 ]
 
 
-@pytest.mark.parametrize('shell_type', [p['kwarg'] for p in core_type], ids=[p['name'] for p in core_type])
-@pytest.mark.parametrize('core_type', [p['kwarg'] for p in shell_type], ids=[p['name'] for p in shell_type])
-@pytest.mark.parametrize('measure', measures, ids=[p.short_label for p in measures])
-def test_coreshell_experiment(measure, core_type, shell_type):
+@pytest.mark.parametrize('medium_config', [m['properties'] for m in medium_options], ids=[m['name'] for m in medium_options])
+@pytest.mark.parametrize('shell_config', [s['properties'] for s in shell_options], ids=[s['name'] for s in shell_options])
+@pytest.mark.parametrize('core_config', [c['properties'] for c in core_options], ids=[c['name'] for c in core_options])
+@pytest.mark.parametrize('measure', measures, ids=[m.short_label for m in measures])
+def test_coreshell_scattering_properties(measure, medium_config, core_config, shell_config):
+    # Setup Gaussian source
     source_set = Gaussian(
-        wavelength=numpy.linspace(400e-9, 1800e-9, 50),
+        wavelength=np.linspace(400e-9, 1800e-9, 50),
         polarization_value=0,
         polarization_type='linear',
         optical_power=1e-3,
         NA=0.2
     )
 
+    # Setup core-shell scatterer
     scatterer_set = CoreShell(
-        n_medium=1,
-        core_diameter=numpy.linspace(400e-9, 1400e-9, 10),
+        core_diameter=np.linspace(400e-9, 1400e-9, 10),
         shell_width=300e-9,
-        **core_type,
-        **shell_type,
-        source_set=source_set
+        source_set=source_set,
+        **medium_config,
+        **core_config,
+        **shell_config
     )
 
+    # Setup detector
     detector_set = Photodiode(
         NA=0.2,
         polarization_filter=None,
         gamma_offset=0,
         phi_offset=0,
         sampling=100
     )
 
+    # Configure and run the experiment
     experiment = Setup(
         scatterer_set=scatterer_set,
         source_set=source_set,
         detector_set=detector_set
     )
 
+    # Execute measurement
     experiment.get(measure)
 
 # -
```

## tests/experiments/test_cylinder.py

```diff
@@ -1,62 +1,76 @@
 #!/usr/bin/env python
 # -*- coding: utf-8 -*-
 
 import pytest
-import numpy
+import numpy as np
 
 from PyMieSim.experiment.detector import Photodiode
 from PyMieSim.experiment.scatterer import Cylinder
 from PyMieSim.experiment.source import Gaussian
 from PyMieSim.experiment import Setup
-from PyMieSim import measure
+import PyMieSim.measure as pms_measure
 from PyMieSim.materials import Silver, BK7, Aluminium
 
-core_type = [
-    {'name': 'BK7', 'kwarg': {'material': BK7}},
-    {'name': 'Silver', 'kwarg': {'material': Silver}},
-    {'name': 'Aluminium', 'kwarg': {'material': Aluminium}},
-    {'name': 'Index', 'kwarg': {'index': 1.4}}
+# Material configurations for the cylinder core
+core_options = [
+    {'name': 'BK7', 'properties': {'material': BK7}},
+    {'name': 'Silver', 'properties': {'material': Silver}},
+    {'name': 'Aluminium', 'properties': {'material': Aluminium}},
+    {'name': 'Index', 'properties': {'index': 1.4}}
 ]
 
+# Medium configurations
+medium_options = [
+    {'name': 'BK7', 'properties': {'medium_material': BK7}},
+    {'name': 'Index', 'properties': {'medium_index': 1.1}}
+]
+
+# Measures to be tested
 measures = [
-    measure.Qsca,
-    measure.Qabs,
-    measure.coupling
+    pms_measure.Qsca,
+    pms_measure.Qabs,
+    pms_measure.coupling
 ]
 
 
-@pytest.mark.parametrize('core_type', [p['kwarg'] for p in core_type], ids=[p['name'] for p in core_type])
-@pytest.mark.parametrize('measure', measures, ids=[p.short_label for p in measures])
-def test_cylinder_experiment(measure, core_type):
+@pytest.mark.parametrize('medium_config', [m['properties'] for m in medium_options], ids=[m['name'] for m in medium_options])
+@pytest.mark.parametrize('core_config', [c['properties'] for c in core_options], ids=[c['name'] for c in core_options])
+@pytest.mark.parametrize('measure', measures, ids=[m.short_label for m in measures])
+def test_cylinder_scattering_properties(measure, medium_config, core_config):
+    # Setup Gaussian source
     source_set = Gaussian(
-        wavelength=numpy.linspace(400e-9, 1800e-9, 50),
+        wavelength=np.linspace(400e-9, 1800e-9, 50),
         polarization_value=0,
         polarization_type='linear',
         optical_power=1e-3,
         NA=0.2
     )
 
+    # Setup cylindrical scatterer
     scatterer_set = Cylinder(
-        n_medium=1,
-        diameter=numpy.linspace(400e-9, 1400e-9, 10),
-        **core_type,
-        source_set=source_set
+        diameter=np.linspace(400e-9, 1400e-9, 10),
+        source_set=source_set,
+        **medium_config,
+        **core_config
     )
 
+    # Setup detector
     detector_set = Photodiode(
         NA=0.2,
         polarization_filter=None,
         gamma_offset=0,
         phi_offset=0,
         sampling=100
     )
 
+    # Configure and run the experiment
     experiment = Setup(
         scatterer_set=scatterer_set,
         source_set=source_set,
         detector_set=detector_set
     )
 
+    # Execute measurement
     experiment.get(measure)
 
 # -
```

## tests/experiments/test_sphere.py

```diff
@@ -1,68 +1,75 @@
 #!/usr/bin/env python
 # -*- coding: utf-8 -*-
 
 import pytest
-import numpy
+import numpy as np
 
 from PyMieSim.experiment.detector import Photodiode
 from PyMieSim.experiment.scatterer import Sphere
 from PyMieSim.experiment.source import Gaussian
 from PyMieSim.experiment import Setup
-from PyMieSim import measure
+import PyMieSim.measure as pms_measure
 from PyMieSim.materials import Silver, BK7, Aluminium
 
-
-core_type = [
-    {'name': 'BK7', 'kwarg': {'material': BK7}},
-    {'name': 'Silver', 'kwarg': {'material': Silver}},
-    {'name': 'Aluminium', 'kwarg': {'material': Aluminium}},
-    {'name': 'Index', 'kwarg': {'index': 1.4}}
+# Configure the core materials for the sphere
+core_options = [
+    {'name': 'BK7', 'properties': {'material': BK7}},
+    {'name': 'Silver', 'properties': {'material': Silver}},
+    {'name': 'Aluminium', 'properties': {'material': Aluminium}},
+    {'name': 'Index', 'properties': {'index': 1.4}}
 ]
 
+# Define medium options
+medium_options = [
+    {'name': 'BK7', 'properties': {'medium_material': BK7}},
+    {'name': 'Index', 'properties': {'medium_index': 1.1}}
+]
 
+# List of measures to be tested
 measures = [
-    measure.Qsca,
-    measure.Qabs,
-    measure.Qback,
-    measure.g,
-    measure.a1,
-    measure.b1,
-    measure.coupling
+    pms_measure.Qsca, pms_measure.Qabs, pms_measure.Qback,
+    pms_measure.g, pms_measure.a1, pms_measure.b1, pms_measure.coupling
 ]
 
 
-@pytest.mark.parametrize('core_type', [p['kwarg'] for p in core_type], ids=[p['name'] for p in core_type])
-@pytest.mark.parametrize('measure', measures, ids=[p.short_label for p in measures])
-def test_sphere_experiment(measure, core_type):
+@pytest.mark.parametrize('medium_config', [m['properties'] for m in medium_options], ids=[m['name'] for m in medium_options])
+@pytest.mark.parametrize('core_config', [c['properties'] for c in core_options], ids=[c['name'] for c in core_options])
+@pytest.mark.parametrize('measure', measures, ids=[m.short_label for m in measures])
+def test_sphere_scattering_properties(measure, core_config, medium_config):
+    # Set up the Gaussian source
     source_set = Gaussian(
-        wavelength=numpy.linspace(400e-9, 1800e-9, 50),
+        wavelength=np.linspace(400e-9, 1800e-9, 50),
         polarization_value=0,
         polarization_type='linear',
         optical_power=1e-3,
         NA=0.2
     )
 
+    # Configure the spherical scatterer
     scatterer_set = Sphere(
-        n_medium=1,
-        diameter=numpy.linspace(400e-9, 1400e-9, 10),
-        **core_type,
-        source_set=source_set
+        diameter=np.linspace(400e-9, 1400e-9, 10),
+        source_set=source_set,
+        **medium_config,
+        **core_config
     )
 
+    # Configure the detector
     detector_set = Photodiode(
         NA=0.2,
         polarization_filter=None,
         gamma_offset=0,
         phi_offset=0,
         sampling=100
     )
 
+    # Set up and run the experiment
     experiment = Setup(
         scatterer_set=scatterer_set,
         source_set=source_set,
         detector_set=detector_set
     )
 
+    # Perform the measurement
     experiment.get(measure)
 
 # -
```

## tests/scatterers/test_coreshell.py

```diff
@@ -1,30 +1,31 @@
 #!/usr/bin/env python
 # -*- coding: utf-8 -*-
 
 import pytest
-
 from PyMieSim.single.scatterer import CoreShell
 from PyMieSim.single.source import Gaussian
 from PyMieSim.single.detector import Photodiode
 from PyMieSim.materials import Silver, BK7, Aluminium
 
-cores_type = [
-    {'core_material': BK7},
-    {'core_material': Silver},
-    {'core_index': 1.4}
+# Core and shell configurations with clear separation of test ids and parameters
+core_configs = [
+    {'config': {'core_material': BK7}, 'id': 'BK7'},
+    {'config': {'core_material': Silver}, 'id': 'Silver'},
+    {'config': {'core_index': 1.4}, 'id': 'Index 1.4'}
 ]
 
-shells_type = [
-    {'shell_material': BK7},
-    {'shell_material': Silver},
-    {'shell_material': Aluminium},
-    {'shell_index': 1.4}
+shell_configs = [
+    {'config': {'shell_material': BK7}, 'id': 'BK7'},
+    {'config': {'shell_material': Silver}, 'id': 'Silver'},
+    {'config': {'shell_material': Aluminium}, 'id': 'Aluminium'},
+    {'config': {'shell_index': 1.4}, 'id': 'Index 1.4'}
 ]
 
+# Methods and attributes to test
 methods = [
     "get_far_field",
     "get_stokes",
     "get_spf",
     "get_s1s2",
     "an",
     "bn",
@@ -42,85 +43,83 @@
     "Cext",
     "Cback",
     "Cratio",
     "Cpr",
 ]
 
 
-@pytest.mark.parametrize('shell_type', shells_type, ids=['BK7', 'Silver', 'Aluminum', 'Index'])
-@pytest.mark.parametrize('core_type', cores_type, ids=['BK7', 'Silver', 'Index'])
+@pytest.mark.parametrize('shell_config', shell_configs, ids=[config['id'] for config in shell_configs])
+@pytest.mark.parametrize('core_config', core_configs, ids=[config['id'] for config in core_configs])
 @pytest.mark.parametrize('method', methods)
-def test_coreshell_method(method, core_type, shell_type):
+def test_coreshell_method(method, core_config, shell_config):
     source = Gaussian(
         wavelength=750e-9,
         polarization_value=0,
         polarization_type='linear',
         optical_power=1,
         NA=0.3
     )
-
     scatterer = CoreShell(
         core_diameter=100e-9,
         shell_width=200e-9,
         source=source,
-        **core_type,
-        **shell_type,
-        n_medium=1.0
+        medium_index=1.0,
+        **core_config['config'],
+        **shell_config['config']
     )
 
+    # Execute the method
     _ = getattr(scatterer, method)()
 
 
-@pytest.mark.parametrize('shell_type', shells_type, ids=['BK7', 'Silver', 'Aluminum', 'Index'])
-@pytest.mark.parametrize('core_type', cores_type, ids=['BK7', 'Silver', 'Index'])
-def test_coreshell_coupling(core_type, shell_type):
+@pytest.mark.parametrize('shell_config', shell_configs, ids=[config['id'] for config in shell_configs])
+@pytest.mark.parametrize('core_config', core_configs, ids=[config['id'] for config in core_configs])
+def test_coreshell_coupling(core_config, shell_config):
     detector = Photodiode(
         NA=0.2,
         gamma_offset=0,
         phi_offset=0,
     )
-
     source = Gaussian(
         wavelength=750e-9,
         polarization_value=0,
         polarization_type='linear',
         optical_power=1,
         NA=0.3
     )
-
     scatterer = CoreShell(
         core_diameter=100e-9,
         shell_width=200e-9,
         source=source,
-        **core_type,
-        **shell_type,
-        n_medium=1.0
+        medium_index=1.0,
+        **core_config['config'],
+        **shell_config['config']
     )
 
+    # Calculate optical coupling
     _ = detector.coupling(scatterer)
 
 
-@pytest.mark.parametrize('shell_type', shells_type, ids=['BK7', 'Silver', 'Aluminum', 'Index'])
-@pytest.mark.parametrize('core_type', cores_type, ids=['BK7', 'Silver', 'Index'])
+@pytest.mark.parametrize('shell_config', shell_configs, ids=[config['id'] for config in shell_configs])
+@pytest.mark.parametrize('core_config', core_configs, ids=[config['id'] for config in core_configs])
 @pytest.mark.parametrize('attribute', attributes)
-def test_coreshell_attribute(attribute, core_type, shell_type):
+def test_coreshell_attribute(attribute, core_config, shell_config):
     source = Gaussian(
         wavelength=750e-9,
         polarization_value=0,
         polarization_type='linear',
         optical_power=1,
         NA=0.3
     )
-
     scatterer = CoreShell(
         core_diameter=100e-9,
         shell_width=200e-9,
         source=source,
-        **core_type,
-        **shell_type,
-        n_medium=1.0
+        medium_index=1.0,
+        **core_config['config'],
+        **shell_config['config']
     )
 
+    # Access and verify the attribute
     _ = getattr(scatterer, attribute)
 
-
 # -
```

## tests/scatterers/test_cylinder.py

```diff
@@ -1,109 +1,109 @@
 #!/usr/bin/env python
 # -*- coding: utf-8 -*-
 
 import pytest
-
 from PyMieSim.single.scatterer import Cylinder
 from PyMieSim.single.source import Gaussian
 from PyMieSim.single.detector import Photodiode
 from PyMieSim.materials import Silver, BK7
 
-cores_type = [
-    {'material': BK7},
-    {'material': Silver},
-    {'index': 1.4}
+# Core configurations separated for clarity and functionality
+core_configs = [
+    {'config': {'material': BK7}, 'id': 'BK7'},
+    {'config': {'material': Silver}, 'id': 'Silver'},
+    {'config': {'index': 1.4}, 'id': 'Index 1.4'}
 ]
 
+# Methods to be tested
 methods = [
     "get_far_field",
     "get_stokes",
     "get_spf",
     "get_s1s2",
     "a1n",
     "a2n",
     "b1n",
     "b2n",
 ]
 
-
+# Attributes to check
 attributes = [
     "size_parameter",
     "area",
     "Qsca",
     "Qext",
     "Qabs",
     "Csca",
     "Cext",
     "Cabs",
     "g",
 ]
 
 
-@pytest.mark.parametrize('core_type', cores_type, ids=['BK7', 'Silver', 'Index'])
+@pytest.mark.parametrize('core_config', core_configs, ids=[config['id'] for config in core_configs])
 @pytest.mark.parametrize('method', methods)
-def test_cylinder_methods(method, core_type):
+def test_cylinder_methods(method, core_config):
     source = Gaussian(
         wavelength=750e-9,
         polarization_value=0,
         polarization_type='linear',
         optical_power=1,
         NA=0.3
     )
     scatterer = Cylinder(
         diameter=100e-9,
         source=source,
-        **core_type,
-        n_medium=1.0
+        medium_index=1.0,
+        **core_config['config']
     )
 
+    # Execute method
     _ = getattr(scatterer, method)()
 
 
-@pytest.mark.parametrize('core_type', cores_type, ids=['BK7', 'Silver', 'Index'])
-def test_cylinder_coupling(core_type: object):
+@pytest.mark.parametrize('core_config', core_configs, ids=[config['id'] for config in core_configs])
+def test_cylinder_coupling(core_config):
     detector = Photodiode(
         NA=0.2,
         gamma_offset=0,
         phi_offset=0,
     )
-
     source = Gaussian(
         wavelength=750e-9,
         polarization_value=0,
         polarization_type='linear',
         optical_power=1,
         NA=0.3
     )
-
     scatterer = Cylinder(
         diameter=100e-9,
         source=source,
-        **core_type,
-        n_medium=1.0
+        medium_index=1.0,
+        **core_config['config']
     )
 
+    # Calculate optical coupling
     _ = detector.coupling(scatterer)
 
 
-@pytest.mark.parametrize('core_type', cores_type, ids=['BK7', 'Silver', 'Index'])
+@pytest.mark.parametrize('core_config', core_configs, ids=[config['id'] for config in core_configs])
 @pytest.mark.parametrize('attribute', attributes)
-def test_cylinder_attributes(attribute, core_type):
+def test_cylinder_attributes(attribute, core_config):
     source = Gaussian(
         wavelength=750e-9,
         polarization_value=0,
         polarization_type='linear',
         optical_power=1,
         NA=0.3
     )
-
     scatterer = Cylinder(
         diameter=100e-9,
         source=source,
-        **core_type,
-        n_medium=1.0
+        medium_index=1.0,
+        **core_config['config']
     )
 
+    # Access and validate the specified attribute
     _ = getattr(scatterer, attribute)
 
-
 # -
```

## tests/scatterers/test_sphere.py

```diff
@@ -1,136 +1,105 @@
-#!/usr/bin/env python
-# -*- coding: utf-8 -*-
-
 import pytest
-
 from PyMieSim.single.scatterer import Sphere
 from PyMieSim.single.source import Gaussian
 from PyMieSim.single.detector import Photodiode
 from PyMieSim.materials import Silver, BK7
 
-cores_type = [
-    {'material': BK7},
-    {'material': Silver},
-    {'index': 1.4}
+# Define the core configurations for testing, now separated 'id' for clarity in tests
+core_configs = [
+    {'config': {'material': BK7}, 'id': 'BK7'},
+    {'config': {'material': Silver}, 'id': 'Silver'},
+    {'config': {'index': 1.4}, 'id': 'Index 1.4'}
 ]
 
-methods = [
-    "an",
-    "bn",
-]
+methods = ["an", "bn"]
 
 attributes = [
-    "size_parameter",
-    "area",
-    "Qsca",
-    "Qext",
-    "Qback",
-    "Qratio",
-    "Qpr",
-    "Csca",
-    "Cext",
-    "Cback",
-    "Cratio",
-    "Cpr",
+    "size_parameter", "area", "Qsca", "Qext", "Qback", "Qratio",
+    "Qpr", "Csca", "Cext", "Cback", "Cratio", "Cpr",
 ]
 
 plottings = [
-    "get_far_field",
-    "get_stokes",
-    "get_spf",
-    "get_s1s2",
+    "get_far_field", "get_stokes", "get_spf", "get_s1s2",
 ]
 
 
-@pytest.mark.parametrize('core_type', cores_type, ids=['BK7', 'Silver', 'Index'])
+@pytest.mark.parametrize('core_config', core_configs, ids=[config['id'] for config in core_configs])
 @pytest.mark.parametrize('method', methods)
-def test_sphere_method(method: str, core_type: object):
+def test_sphere_method(method, core_config):
     source = Gaussian(
         wavelength=750e-9,
         polarization_value=0,
         polarization_type='linear',
         optical_power=1,
         NA=0.3
     )
-
+    # Pass only the actual configuration dictionary to the constructor
     scatterer = Sphere(
         diameter=100e-9,
         source=source,
-        **core_type,
-        n_medium=1.0
+        medium_index=1.0,
+        **core_config['config']
     )
-
     _ = getattr(scatterer, method)()
 
 
-@pytest.mark.parametrize('core_type', cores_type, ids=['BK7', 'Silver', 'Index'])
+@pytest.mark.parametrize('core_config', core_configs, ids=[config['id'] for config in core_configs])
 @pytest.mark.parametrize('attribute', attributes)
-def test_sphere_attribute(attribute: str, core_type: object):
+def test_sphere_attribute(attribute, core_config):
     source = Gaussian(
         wavelength=750e-9,
         polarization_value=0,
         polarization_type='linear',
         optical_power=1,
         NA=0.3
     )
-
     scatterer = Sphere(
         diameter=100e-9,
         source=source,
-        **core_type,
-        n_medium=1.0
+        medium_index=1.0,
+        **core_config['config']
     )
-
     _ = getattr(scatterer, attribute)
 
 
-@pytest.mark.parametrize('core_type', cores_type, ids=['BK7', 'Silver', 'Index'])
-def test_sphere_coupling(core_type: object):
+@pytest.mark.parametrize('core_config', core_configs, ids=[config['id'] for config in core_configs])
+def test_sphere_coupling(core_config):
     detector = Photodiode(
         NA=0.2,
         gamma_offset=0,
         phi_offset=0,
     )
-
     source = Gaussian(
         wavelength=750e-9,
         polarization_value=0,
         polarization_type='linear',
         optical_power=1,
         NA=0.3
     )
-
     scatterer = Sphere(
         diameter=100e-9,
         source=source,
-        **core_type,
-        n_medium=1.0
+        medium_index=1.0,
+        **core_config['config']
     )
-
     _ = detector.coupling(scatterer)
 
 
-@pytest.mark.parametrize('core_type', cores_type, ids=['BK7', 'Silver', 'Index'])
+@pytest.mark.parametrize('core_config', core_configs, ids=[config['id'] for config in core_configs])
 @pytest.mark.parametrize('plotting', plottings)
-def test_sphere_plottings(plotting: str, core_type: object):
+def test_sphere_plottings(plotting, core_config):
     source = Gaussian(
         wavelength=750e-9,
         polarization_value=0,
         polarization_type='linear',
         optical_power=1,
         NA=0.3
     )
-
     scatterer = Sphere(
         diameter=100e-9,
         source=source,
-        **core_type,
-        n_medium=1.0
+        medium_index=1.0,
+        **core_config['config']
     )
-
     data = getattr(scatterer, plotting)()
-
-    data.plot()
-
-
-# -
+    assert data is not None, "Plotting data should not be None"
```

## tests/validation/test_coreshell_pymiescatt.py

```diff
@@ -24,15 +24,15 @@
 
 def get_PyMieSim_data(source_set, core_index, shell_index, core_diameters, shell_width, measure_string: str):
     scatterer_set = CoreShell(
         core_diameter=core_diameters,
         shell_width=shell_width,
         core_index=core_index,
         shell_index=shell_index,
-        n_medium=1.,
+        medium_index=1.,
         source_set=source_set
     )
 
     experiment = Setup(
         scatterer_set=scatterer_set,
         source_set=source_set,
         detector_set=None
@@ -45,15 +45,15 @@
 
 def get_PyMieScatt_data(source_set, core_index, shell_index, core_diameters, shell_width, measure_string: str):
     PyMieScatt_data = []
     for core_diameter in core_diameters:
         efficiencies = ps.MieQCoreShell(
             mCore=core_index,
             mShell=shell_index,
-            wavelength=source_set.wavelength.base_values[0],
+            wavelength=source_set.wavelength[0],
             dCore=core_diameter,
             dShell=core_diameter + shell_width
         )
 
         measure_idx = PyMieScatt_measures.get(measure_string)
         data = efficiencies[measure_idx]
         PyMieScatt_data.append(float(data))
```

## tests/validation/test_detector.py

```diff
@@ -45,15 +45,15 @@
         polarization_value=0,
         polarization_type='linear',
         optical_power=1,
         NA=0.3
     )
 
     scatterer = experiment.scatterer.Sphere(
-        n_medium=1.0,
+        medium_index=1.0,
         diameter=1e-6,
         index=1.5 + 0.5j,
         source_set=source_set
     )
 
     detector = experiment.detector.Photodiode(
         NA=0.1,
```

## tests/validation/test_sphere_pymiescatt.py

```diff
@@ -22,15 +22,15 @@
 }
 
 
 def get_PyMieSim_data(source_set, index, diameters, measure_string: str):
     scatterer_set = Sphere(
         diameter=diameters,
         index=index,
-        n_medium=1.,
+        medium_index=1.,
         source_set=source_set
     )
 
     experiment = Setup(
         scatterer_set=scatterer_set,
         source_set=source_set,
         detector_set=None
@@ -42,15 +42,15 @@
 
 
 def get_PyMieScatt_data(source_set, index, diameters, measure_string: str):
     PyMieScatt_data = []
     for diameter in diameters:
         efficiencies = ps.MieQ(
             m=index,
-            wavelength=source_set.wavelength.base_values[0],
+            wavelength=source_set.wavelength[0],
             diameter=diameter,
         )
 
         measure_idx = PyMieScatt_measures.get(measure_string)
         data = efficiencies[measure_idx]
         PyMieScatt_data.append(float(data))
```

## Comparing `PyMieSim-1.8.0.dist-info/LICENSE` & `PyMieSim-1.8.1.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `PyMieSim-1.8.0.dist-info/METADATA` & `PyMieSim-1.8.1.dist-info/METADATA`

 * *Files 0% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: PyMieSim
-Version: 1.8.0
+Version: 1.8.1
 Summary: A package for light scattering computation.
 Home-page: https://github.com/MartinPdeS/PyMieSim
 Author: Martin Poinsinet de Sivry
 Author-email: Martin.poinsinet.de.sivry@gmail.com
 License: MIT
 Keywords: mie,scattering,backscatter,sphere,cylinder,nanoparticle,phase function,efficiency,rayleigh,backscattering
 Platform: unix
@@ -25,15 +25,15 @@
 Classifier: Intended Audience :: Science/Research
 Description-Content-Type: text/x-rst
 License-File: LICENSE
 Requires-Dist: numpy >=1.26.0
 Requires-Dist: scipy ==1.11.3
 Requires-Dist: matplotlib ==3.8.2
 Requires-Dist: DataVisual ==1.4.*
-Requires-Dist: PyOptik >=0.7.4
+Requires-Dist: PyOptik >=0.7.7
 Requires-Dist: tabulate ==0.9.0
 Provides-Extra: documentation
 Requires-Dist: numpydoc ==1.6.0 ; extra == 'documentation'
 Requires-Dist: sphinx >=5.1.1 ; extra == 'documentation'
 Requires-Dist: sphinx-gallery ==0.15.0 ; extra == 'documentation'
 Requires-Dist: sphinx-rtd-theme ==2.0.0 ; extra == 'documentation'
 Requires-Dist: pydata-sphinx-theme ==0.14.1 ; extra == 'documentation'
```

## Comparing `PyMieSim-1.8.0.dist-info/RECORD` & `PyMieSim-1.8.1.dist-info/RECORD`

 * *Files 10% similar despite different names*

```diff
@@ -1,122 +1,122 @@
-PyMieSim/VERSION,sha256=J9njNqhPMt1-vG61wkLYlsEOrNnES40v5EfgyKmAaXA,7
+PyMieSim/VERSION,sha256=RLAW2E_hYGFfZGQ3NNQPtfVVTlpuXLVS0GrziztQLkU,7
 PyMieSim/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 PyMieSim/__main__.py,sha256=gyDuEzcfopHfNbkK0mI9UALzu2aG9uctC6gPXQdYLd4,230
-PyMieSim/materials.py,sha256=yVJr6UFGQUSuWUHwY2e_FKTxzPRJ5LA_wYdTARfSz5M,418
+PyMieSim/materials.py,sha256=EtkyMlZqkc-lqTHhWlAsJ8tFTePwEIpATM8oS-A4v1U,464
 PyMieSim/measure.py,sha256=sQQhwAZIRDH73-HDG58mX8GHXa0ibywmbEUk4vnOWVs,3780
 PyMieSim/mesh.py,sha256=-Bkdz6ZAsNkdceLguXiS-tiA1Rdj8DjTkfU78hkm_ms,7864
 PyMieSim/physics.py,sha256=1AT6Ke_FxsUB-oAV1tzt34LzXqoPK1yOdtsBdzo0XQs,1988
 PyMieSim/polarization.py,sha256=ZQj4x5465pqfopu9TgKdqMIuJtk1jNIypA4fO5QP5-k,2084
-PyMieSim/binary/CoreShellInterface.cp310-win_amd64.pyd,sha256=YfgbEozmBTtKZlSPJmeAlxJIAR1nypr8nSDDX4ctt7o,818688
-PyMieSim/binary/CoreShellInterface.cp311-win_amd64.pyd,sha256=EyRYx3ygxfMgFq_eNGcAJW0cDz75VQ5ftzlkUxvBA-4,818688
-PyMieSim/binary/CoreShellInterface.cp312-win_amd64.pyd,sha256=_AhwDXlEJq789kAas3R_UwXqsNjkWjr2y0bR94tOQW8,818688
-PyMieSim/binary/CylinderInterface.cp310-win_amd64.pyd,sha256=GsX6lXVRGrC2iJK5MbwqmZzK2-oImKajHJl-aYNtKVQ,802304
-PyMieSim/binary/CylinderInterface.cp311-win_amd64.pyd,sha256=xHP3cQ_lYt7wsxpbIBfqCYFc4r1G3xzV2Lj7E0w9SDs,802304
-PyMieSim/binary/CylinderInterface.cp312-win_amd64.pyd,sha256=20xU0OHYebCojBSWr9DL_W7j29eYQKg1MZP71SB33j4,802304
-PyMieSim/binary/DetectorInterface.cp310-win_amd64.pyd,sha256=c_BsmWVZc8ttYbd23BqqsMHp7n1eRolsliJC6LxAkko,842240
-PyMieSim/binary/DetectorInterface.cp311-win_amd64.pyd,sha256=DfaSVWxya2l0MqDQ3cH9PkcQNDhDUj3NABVzGOBjl-M,842240
-PyMieSim/binary/DetectorInterface.cp312-win_amd64.pyd,sha256=KpIBluGBc6c7P50jfoOveEG5v4WVE5WY1GJ4wcfTwLM,842240
-PyMieSim/binary/Experiment.cp310-win_amd64.pyd,sha256=pQWVBrJQ3Q2sbshvJAw3Xy7ZtCx-aAgQSZovoNPHu9E,970752
-PyMieSim/binary/Experiment.cp311-win_amd64.pyd,sha256=s-t7ueRu5teG1Zqx39DRJKIAkNyOVd-NyY5SIaNzhkE,970752
-PyMieSim/binary/Experiment.cp312-win_amd64.pyd,sha256=HQ6hHDCL85JXcgRsuS70NijqMTypKM3OXXKEd7nf9Yg,982528
-PyMieSim/binary/Fibonacci.cp310-win_amd64.pyd,sha256=PVDfj_s-mD0AyyIFv62dAfpnRQkg5qOmTBabIbBMdVs,358912
-PyMieSim/binary/Fibonacci.cp311-win_amd64.pyd,sha256=qPe0mFFNXB6BwYHlraAh0rGefhdT6TskErLKmAaqOoU,358912
-PyMieSim/binary/Fibonacci.cp312-win_amd64.pyd,sha256=KgFBUaWtzK1lO3TrzG9X-m__Ni7I0DCr5N5NXFAGhW8,358400
-PyMieSim/binary/Sets.cp310-win_amd64.pyd,sha256=klXS5QHVoQpE2-zpZIBWhhEd_E7J8nWiwh3p5pYVVeY,829952
-PyMieSim/binary/Sets.cp311-win_amd64.pyd,sha256=mL9FiD6qYrz0dNhUqk4jCrO2PQ8YRf_KsioIGqX0nVw,829952
-PyMieSim/binary/Sets.cp312-win_amd64.pyd,sha256=M8snlfWfze9_jctpdDOITYxwaGfIywCg7EfgsnUlFZo,829440
-PyMieSim/binary/SphereInterface.cp310-win_amd64.pyd,sha256=XmXHSQQxGVTyIALekRLFBljH2BmTIY_fqUOAQUCdGmI,818688
-PyMieSim/binary/SphereInterface.cp311-win_amd64.pyd,sha256=8ESc4nmMLRPx6AOhXfn1vvpUJFxsf8nUVI1Kv1GjzXQ,818176
-PyMieSim/binary/SphereInterface.cp312-win_amd64.pyd,sha256=YSUJvHe339ivK1vCBZV--nbqhZ7MEMSmutnpNYMyqik,819712
+PyMieSim/binary/CoreShellInterface.cp310-win_amd64.pyd,sha256=XtUxYYuHbB4HTJLmt10tS_iu3JDfgUNjZ9DyvzwQDIs,818688
+PyMieSim/binary/CoreShellInterface.cp311-win_amd64.pyd,sha256=RTJcI44u5FIdidk4GdQnVi9a0cnwNONI3hzTdZ-kHb8,818176
+PyMieSim/binary/CoreShellInterface.cp312-win_amd64.pyd,sha256=pqL7A5cf_eLSofExSjA_3oS0951eAwm7s0FTOaqbTvU,818688
+PyMieSim/binary/CylinderInterface.cp310-win_amd64.pyd,sha256=WIsJWCLccOKTYxI5wuWJrS9bxl6775REyZW621q5tDU,802816
+PyMieSim/binary/CylinderInterface.cp311-win_amd64.pyd,sha256=PI-AXI3_9WEai92nDB4CT2wNnhncuSDm2Zoxl6FX2m4,802816
+PyMieSim/binary/CylinderInterface.cp312-win_amd64.pyd,sha256=JWuONyBI3Ku3k2mqO02frE5c47wczrd77Z58heWgXVA,802816
+PyMieSim/binary/DetectorInterface.cp310-win_amd64.pyd,sha256=tKvA1-ba3iHwKYTmINwCV2LwV2u14hMG_oFlle-PgLg,842240
+PyMieSim/binary/DetectorInterface.cp311-win_amd64.pyd,sha256=OXq7IgPM6DvcdDPliXdRsGA6cVKcZPssFx-8ENSnmts,842240
+PyMieSim/binary/DetectorInterface.cp312-win_amd64.pyd,sha256=CWtIAOOiFfghmESZsSlik2muoCP95iUbFJQ1t3Jv_Bs,842240
+PyMieSim/binary/Experiment.cp310-win_amd64.pyd,sha256=RIUlTPD0HTB7EEmAHy-qxlXfhq6jKcNXLsABfSnuK1w,945152
+PyMieSim/binary/Experiment.cp311-win_amd64.pyd,sha256=7sJY6eC9oIxR8c-r9Dq6lNXckZ12kq7Of9kIp4HP3ZI,945152
+PyMieSim/binary/Experiment.cp312-win_amd64.pyd,sha256=buEBCg0rFUJcfZyz5j56ibW5uVU_-stPejNLKXZvpIg,946688
+PyMieSim/binary/Fibonacci.cp310-win_amd64.pyd,sha256=nv_1cVV4RiCuhToa5I44nT2EdcHzVZsc1joTw3_mvgo,358912
+PyMieSim/binary/Fibonacci.cp311-win_amd64.pyd,sha256=qJcQ_Ui74qH7VUodzILc6qho4k0_OoodpOlCRqWoISA,358912
+PyMieSim/binary/Fibonacci.cp312-win_amd64.pyd,sha256=KUFgxQDbfdL15G8mHcCKy1kREnRsoLsJxLJAT68JqxI,358400
+PyMieSim/binary/Sets.cp310-win_amd64.pyd,sha256=2GA5DOY-5aBKhIXrHXq3FtTZy0dFhU0srmsVp99biTo,850944
+PyMieSim/binary/Sets.cp311-win_amd64.pyd,sha256=8bO0SM0dlOlbVNBW2u79rpvCrI74k5WYuZ8FerYqac4,850432
+PyMieSim/binary/Sets.cp312-win_amd64.pyd,sha256=wVcXJb5wjjJsgZoYbh8PPYt96rVUDLivRVJwIZSfuMs,849920
+PyMieSim/binary/SphereInterface.cp310-win_amd64.pyd,sha256=dMRC1W_nW__stxU2AKEDIh7Uz02gXZPnl9mgGm3lJ8M,818688
+PyMieSim/binary/SphereInterface.cp311-win_amd64.pyd,sha256=_Z_kzCcaE3kE2C_Yvfd6cMbjV5p5NZejMBdbfKKAx8g,818688
+PyMieSim/binary/SphereInterface.cp312-win_amd64.pyd,sha256=LnF5410AcdXEZrllVnc69Vtsjc8yXX4dhi8wG316Qy0,819200
 PyMieSim/binary/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-PyMieSim/binary/libZBessel.a,sha256=MMLuLjfCQApj1z_kbFLKxTrvnG0SyVyAhghZCkv2_Mc,133174
+PyMieSim/binary/libZBessel.a,sha256=RlH8JHfIJJ1_oPsn3bN43aLGU8fL9srBEJDSwhWipH4,133174
 PyMieSim/experiment/__init__.py,sha256=-vnICKYVqY7jaJFO1uKEOXNhIBOE9x5r6pIHXwNwbDY,165
-PyMieSim/experiment/detector.py,sha256=K6YrezLV8ggBs3biQZAE_Mk88g6y6i90lXOoDGjxENo,12877
-PyMieSim/experiment/scatterer.py,sha256=GTF4lPeZfB5wbxeblqGbPW8LdqCB8yUx1ryek_N8qMo,16508
-PyMieSim/experiment/setup.py,sha256=huaoGMAbUekrN52pBGkh9BnftYwRLWRfgae-ebxlL6c,4421
-PyMieSim/experiment/source.py,sha256=HbKnPIAG0Aj3XBha8PRTGf-Ts8Tgp7Rub3BEZnRdRF4,5019
+PyMieSim/experiment/detector.py,sha256=861sWipFvdQnzx_cpfjl90ibqOoKF3yOwtwSjSEO0Cw,11930
+PyMieSim/experiment/scatterer.py,sha256=HIWCTvGdYsDEO6J0qlvi8JGyCn3roNMSuxKrczlprWY,16798
+PyMieSim/experiment/setup.py,sha256=7kmTAI5f0BxLSebXIJshH44_aCMxjfkokNhQowXgXJg,5268
+PyMieSim/experiment/source.py,sha256=uRxu0OTIkdSHQyOD0Fa52KbzalXy7D95KeSXYVJqJ2U,5540
 PyMieSim/gui/__init__.py,sha256=YFyM9bysLwkYwvrLPLpSOKCoS7hIGXtfGXpyyzX5cUE,143
-PyMieSim/gui/axis_tab.py,sha256=2HR8sLNladg3wrY9iascebwE2K2L69qJIZtEZyEcc5M,3241
+PyMieSim/gui/axis_tab.py,sha256=8UTd5pm1is30_xNnYbeRJOFTnLKSeV6NHGLAT-qJ_aY,3251
 PyMieSim/gui/base_tab.py,sha256=xhL9_V7PTzA55xv9EkKcqXjeUe8RmZI7A5u5gL00wF0,3382
-PyMieSim/gui/detector_tab.py,sha256=4fDEqnD_FXX_OoLZiBTxlhbzrHEYK3Fena-e5Kqpiek,6652
-PyMieSim/gui/main_window.py,sha256=1PaG-6jLjDpPaRZzVhSVs9MW3N5hdrea1bw49nrs0CM,7719
-PyMieSim/gui/scatterer_tab.py,sha256=N1MZhFGx8OsR5WAnTtFrH56PGbi5WrwMf3p0m3Wvl_M,7526
-PyMieSim/gui/source_tab.py,sha256=3pRX_6GwHV4duOpZtkzjOnguUhuxwUwBtnkEpbqE2T0,2705
+PyMieSim/gui/detector_tab.py,sha256=GJE_pQ5-MzVbCz8Cbj1NV7cDzwjlMHmSpC7iBmgz710,6162
+PyMieSim/gui/main_window.py,sha256=BAhlhERWOxt_WNiVPAMVnT7EkeGy-wKDEZz1wziKzs0,7715
+PyMieSim/gui/scatterer_tab.py,sha256=ZZ888K_VeL0_AqhwluNCwAe3oGHFSS6fYgd8EatDFP8,6876
+PyMieSim/gui/source_tab.py,sha256=N8BjW8bbCUEUcwWWmEll3wH8XZVDhMbr67XlpsSE1JU,2560
 PyMieSim/gui/utils.py,sha256=ciOdzMRi3MgPPQG0xU6EKjaw1AWzLExxSUO-2gsCfnE,10629
 PyMieSim/modes/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 PyMieSim/modes/hermite_gauss.py,sha256=zzjXCP9f9amdq92VWujJe-TVW2Ain06Ibmd1vkJRqqk,4320
 PyMieSim/modes/laguerre_gauss.py,sha256=Oj4bRrBPU1FAi44-ttfNv9Ss3GWq8sAG6PYA2j2z9KY,4395
 PyMieSim/modes/linearly_polarized.py,sha256=8Ifn1hcJ3ZmLKLUMpmf16B5WnoWrFSLfG-AiM8Zzqf4,4073
 PyMieSim/single/__init__.py,sha256=mzpMGNZTXEjpnq5cH0by4gM3TRmdJbtBdIe-H9ELxG0,139
 PyMieSim/single/detector.py,sha256=0AjlxoJisDZk3B6tuZKM22c8XlUZbOeEht4kzrXau4A,11561
 PyMieSim/single/representations.py,sha256=_YljgSgb8ZPdfbx0zaPu7ANdQMQ0ZMFPu6xKkMqstqg,19695
-PyMieSim/single/scatterer.py,sha256=19EsWePtL4iBmGbLb0ylPCZKUXfxSOzr5yR9e0IXPmI,20197
+PyMieSim/single/scatterer.py,sha256=LgV1wYyqYVlZzttqUcBAMTQCL9IikhjLq5cXqSiDcWA,20233
 PyMieSim/single/source.py,sha256=RhrVyBlQJSpu-WjoDDDMYZFNFF7tvC2kfBbksE_AzQw,5579
 PyMieSim/tools/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 PyMieSim/tools/directories.py,sha256=Lc7ScDTwxX5DFGkWnWxd-cidPr3tFwBugiSixXMOH-s,1184
 PyMieSim/tools/special_functions.py,sha256=V5r6kenbGsDtL4C94mWEutKoX7mCgQFmbJKahgnWen8,6229
 PyMieSim/validation_data/Figure810BH.csv,sha256=a16WSB7y7_TuGcboXUINj7y-mX0mkG_Vo0CFtE-pfF8,10073
 PyMieSim/validation_data/Figure87BH.csv,sha256=6vf5uPxzYP7N1rD8GgQJxi4-Yme8Q3ycPpsavXlQQZY,40002
 PyMieSim/validation_data/Figure88BH.csv,sha256=c30NQRjxlPz6plBcuG3kMVdTYQ0sHmRXRnzS67gyFnQ,40002
 PyMieSim/validation_data/PyMieScattQsca.csv,sha256=1TqB7ky435UxeNJSAn6YR3_qUuUKZNLxVAbCLmrnLDk,20800
 PyMieSim/validation_data/PyMieScattQscaCoreShell.csv,sha256=khOJo3N54CqvrG9sxpuvvv5mZlcF3awOk738WHLougI,10400
 PyMieSim/validation_data/PyMieScattQscaCoreShellMedium.csv,sha256=fW1paOgE4ez_26Er4sfqoXujcMtuooj9I6RO6qRCXPo,10400
 PyMieSim/validation_data/PyMieScattQscaMedium.csv,sha256=7PE_F3sLIKmKPhcoMUxeByZHw3lzDfc3TH9g9bh3Noo,20800
-development/LPMOdes.py,sha256=czVzSmx7TRGVsHblceF2fajSQfL4qDDSLVvizHslgOk,1424
+development/LPMOdes.py,sha256=Bt3Z9RaI6xDZQHDrbSQ_iENpeyXHpoDt2xr9pztQ4XA,732
 development/gui.py,sha256=LYma4E1_T8xOqXzy4g-wnDhacH4MzSpNaZvje6onyC0,13670
 docs/examples/detector/plot_HG01.py,sha256=F_MTgYcxxIQTWXKsRYwsNZSB01HF4_VOdM4rWi9oAHk,906
 docs/examples/detector/plot_HG11.py,sha256=Av8P3P6kuNTd_BwCQD0aiQaX3X_guBCOs06xmwq_E8c,906
 docs/examples/detector/plot_LG11.py,sha256=EBRdpT6hdi7UeUDrARX_6VgpDdf35K64GHzIop7cYEY,913
 docs/examples/detector/plot_LP01.py,sha256=9xA1aFLtFNZ3iydb8W9M5bw5PxJtzY8FKKqRmORb1fM,885
 docs/examples/detector/plot_LP02.py,sha256=8yGDZV1PygiOMSlyk49R2qAj8MHQOw48GQE5uTm71kQ,702
 docs/examples/detector/plot_LP11.py,sha256=3UH5iUqu-xdQkMWsJnv8suawPE0wq2If6Sg64xSgyJs,701
 docs/examples/detector/plot_integrating_sphere.py,sha256=iW_FFeKuEQAv0iRwP8IYK_AYj54-ifODOuj5gPuCB-E,559
 docs/examples/detector/plot_photodiode.py,sha256=lueGQSTcQwfiX7qGJAAur3UFjEe9QQbJ3AWo_e0ZZ-8,666
-docs/examples/experiment/plot_coreshell_Qback_vs_corediameter.py,sha256=O7yRhP2tRuTvY9qaSFE0Z-fldaGopU2TWAg-PyKv6_w,1909
-docs/examples/experiment/plot_coreshell_a1_vs_corediameter.py,sha256=_YoVBDtbvAxqBQvEVY-4Xx_8qlSC6fVey3Sl_2hBXgE,2119
-docs/examples/experiment/plot_coreshell_b1_vs_corediameter.py,sha256=2rZ_NYvNQSWKmZaF7CI-awt3ByOJvPL46VJ_O4Larlo,2051
-docs/examples/experiment/plot_coreshell_coupling_vs_corediameter.py,sha256=jD8E48LU95IWNWMaV8ZJnSj6pVZaTJGmEmlbbOOoUD8,2212
-docs/examples/experiment/plot_cylinder_Qabs_vs_diameter.py,sha256=iRvNlcGUWqMrsoXGSOX_oYF1dTi-Sq2j-o53oMu1_jo,1879
-docs/examples/experiment/plot_cylinder_Qsca_vs_diameter.py,sha256=sKC_dMCJF9OyS_jTXDfUGU7bnnuy2Eece5UcJxb1X2k,1655
-docs/examples/experiment/plot_cylinder_Qsca_vs_index.py,sha256=zFwErJm0Zz_Bw3e6YKmNW1wS3JBGN89nnyzKgmYN01g,1648
-docs/examples/experiment/plot_cylinder_Qsca_vs_wavelength.py,sha256=CLVyADVSZCeCL70yfuP_0nVk76eCdp7_05kCvqJAA9A,1979
-docs/examples/experiment/plot_cylinder_Qsca_vs_wavelength_std.py,sha256=0WLIzJFftJ1ubeAltGUmok5-AqoxCgcHbIup8cprwow,1176
-docs/examples/experiment/plot_cylinder_a11_vs_diameter.py,sha256=SA20IcZeNgyIa0i6Jzf0OXDIAQo_UOYvAQK0zNWq9Gw,1625
-docs/examples/experiment/plot_cylinder_b11_vs_diameter.py,sha256=eOWMbpA-cplFIFRTHaZoDb_akthoqyfoGEirVPYs6XE,1538
-docs/examples/experiment/plot_cylinder_coupling_vs_diameter.py,sha256=b2gk_6No2jTnPGIY2Khkc4wTGc94CPH-ryIwzEQJZaE,2056
-docs/examples/experiment/plot_cylinder_coupling_vs_phioffset.py,sha256=hQj0Mj6DtSn2H93NBxeGjcfeGKcxo8W7ZL9_GjDrmok,2077
-docs/examples/experiment/plot_cylinder_coupling_vs_wavelength.py,sha256=ZuzUYl6oU6qBh9-KUFt6KOHEXrmkHv-9cvIM6hXh0EM,2241
-docs/examples/experiment/plot_sphere_Qabs_vs_diameter.py,sha256=jc_Okfnqvk_pIxzN9WeqxsLZGEwmz78YSgezNIwDjHA,1128
-docs/examples/experiment/plot_sphere_Qsca_vs_diameter.py,sha256=dVKhuDmYr3gw8ffBJTXl_zRxvVynvI21Gl09MFEQwdk,1055
-docs/examples/experiment/plot_sphere_Qsca_vs_index.py,sha256=kpiVY3chfIqr9oS9v1uSMdhEzInkd34EpngKBxY6_MU,1038
-docs/examples/experiment/plot_sphere_Qsca_vs_wavelength.py,sha256=tW3JIxnh7W1E1ArL6vWD8ZMGJeNJbQBYgPKfyQBisvM,1063
-docs/examples/experiment/plot_sphere_Qsca_vs_wavelength_std.py,sha256=x199R1tlyrZ3Pe2-HbEshgGLtDeGybe9_dWi_z8dff8,1173
-docs/examples/experiment/plot_sphere_a1_vs_diameter.py,sha256=QLiIrb8-stKDbjW2i2LVukyvY2q7g5Zr209S_3qDDMU,1051
-docs/examples/experiment/plot_sphere_b1_vs_diameter.py,sha256=iwfkISwTJYs8c_KkySGqYD_4olmVdtlKI1icLdOa5eQ,1048
-docs/examples/experiment/plot_sphere_coupling_vs_diameter.py,sha256=6sHpjQt-uv57pxzU5kjkvSOo7jAjz5ZFQIehnMcFgas,1411
-docs/examples/experiment/plot_sphere_coupling_vs_filter.py,sha256=SCVQ3eHkQzN4N0wob00S-6q3T28fK4V_Gb0JiYWZPFo,1473
-docs/examples/experiment/plot_sphere_coupling_vs_phioffset.py,sha256=Z_23PRORHzcnB6Al-r8GXMMG-x8pVqQOKQ7WIGHrnlI,1388
-docs/examples/experiment/plot_sphere_coupling_vs_wavelength.py,sha256=jXoQzGsKhxzJy0Yg2Hbdnk0DybU0cMSQ6FpBM4Bwkt8,1459
-docs/examples/extras/SphereProperties.py,sha256=MsopMcsFletWsTVkm1M2xqiD9hxYQEHYX2NuQwreQD4,1010
-docs/examples/extras/plot_Qsca_vs_permittivity_vs_size_parameter.py,sha256=9hb5NxuDnosf5mur6UzNOVSXRY7BEAjVCjUd3Kp1qEU,1628
-docs/examples/extras/plot_coupling_heatmap.py,sha256=Ihhr1uiprXYZQEUMkHqeIGRN63caX4OJDzOm81rMzXo,1788
-docs/examples/scatterer/plot_farfield.py,sha256=qW0JInwT_wpCsoF-TjpH_6rX2SpSXZ-obB_I3uo5VVc,1048
+docs/examples/experiment/plot_coreshell_Qback_vs_corediameter.py,sha256=aGfNltsYNEdT-PArJkelEcOmzZjhJApROpfTcGaGTtM,1910
+docs/examples/experiment/plot_coreshell_a1_vs_corediameter.py,sha256=IKM6vlgwb_qxCOx92i7wD_NvB5Qi7Sl1lwCdRFj3Xzc,2160
+docs/examples/experiment/plot_coreshell_b1_vs_corediameter.py,sha256=QwFSZEKs7K4o48ntP-j4c6l-bTJq5S45teQta3w8FZ8,2052
+docs/examples/experiment/plot_coreshell_coupling_vs_corediameter.py,sha256=32Z9IV3cPF1aUuY5rQazm_2z3YhTvIpbz4HXReqanAk,2198
+docs/examples/experiment/plot_cylinder_Qabs_vs_diameter.py,sha256=9L2RyQ4HtBKayTCUG0QffQGgDlW4btHqKjBK3KtHbGk,1880
+docs/examples/experiment/plot_cylinder_Qsca_vs_diameter.py,sha256=6cznlxwuezUEd83T-QiI7SDQwYPhy7N-j-aDpvX8F9c,1656
+docs/examples/experiment/plot_cylinder_Qsca_vs_index.py,sha256=RTpUGJPHiB6BsbOi28KCkjL1RfE4H9bTOONsaYcwuFQ,1649
+docs/examples/experiment/plot_cylinder_Qsca_vs_wavelength.py,sha256=X1F3DsYXPTWIqpd9ulEPejeO3teh7hB28oyKq4OpnRU,1980
+docs/examples/experiment/plot_cylinder_Qsca_vs_wavelength_std.py,sha256=eF9c2qHXcLm8DKSU6ZbGQj66qJP7YoGnsSK2CuLW8OI,1177
+docs/examples/experiment/plot_cylinder_a11_vs_diameter.py,sha256=IVpbHY2k10Cuay57DPTvVIh5zl7gqiPI0ZiWKkJAvGY,1626
+docs/examples/experiment/plot_cylinder_b11_vs_diameter.py,sha256=eKKVcmIqwOPQTJoHBNvPu7uPNAcbwR2m1mxqCox8ym8,1539
+docs/examples/experiment/plot_cylinder_coupling_vs_diameter.py,sha256=63mNFkTPxqJNWU69aGRAznbZeqMc22jty4ToxDiOM-U,2057
+docs/examples/experiment/plot_cylinder_coupling_vs_phioffset.py,sha256=Md-dKtLk9Q2AiWqLPrIvRidr2vKteNPULixsPyHvyog,2079
+docs/examples/experiment/plot_cylinder_coupling_vs_wavelength.py,sha256=UD7eLYn2xirSbxkerHuxvOasWSZSXOaEhYH7GjzjCa8,2242
+docs/examples/experiment/plot_sphere_Qabs_vs_diameter.py,sha256=0Vj_23DC48O0usJ98DnM_8J0VbgFJwT7ERhyBsSHaf0,1129
+docs/examples/experiment/plot_sphere_Qsca_vs_diameter.py,sha256=JNnr1oiqSXutpVqKD1E8hzGA100aEUPwEutH89eJwjQ,1056
+docs/examples/experiment/plot_sphere_Qsca_vs_index.py,sha256=UetMC-SGZEnOoHg3TiXyIbHtERdpQBdstuxo2_J1JF8,1039
+docs/examples/experiment/plot_sphere_Qsca_vs_wavelength.py,sha256=NlFXxX7g38TQWss3Qx7qux7cKoGpE_qbiNFrbarukkY,1067
+docs/examples/experiment/plot_sphere_Qsca_vs_wavelength_std.py,sha256=8ln4tf6Jsgo1BZgGCbETwfY8fxXFm3aJysKyChdX1BY,1174
+docs/examples/experiment/plot_sphere_a1_vs_diameter.py,sha256=XR3VrXj2DHLigtpubNO1TVqe1BT1EohpkVRR9D-In4k,1052
+docs/examples/experiment/plot_sphere_b1_vs_diameter.py,sha256=j1fuHGUcyX5NyTGfP4WDcUi6FEt8JrkyaXmpiDQe2YM,1049
+docs/examples/experiment/plot_sphere_coupling_vs_diameter.py,sha256=iCPTRl8Xahd-RsK1fi0Aho6nS_7lGkwa73sj1KptQwk,1412
+docs/examples/experiment/plot_sphere_coupling_vs_filter.py,sha256=oNcG0pWmrI1V8mui73YIS-JEuU0AwRw6a8AtSDKx3tE,1472
+docs/examples/experiment/plot_sphere_coupling_vs_phioffset.py,sha256=dOEd9a2w0ZBq3jcr_F85biYmR0fvkGtvaQVvjTHc3TY,1390
+docs/examples/experiment/plot_sphere_coupling_vs_wavelength.py,sha256=Enszsux8lFqmxmeXmS-wl1P78moQ8T4Sn4Tr8WZAh_c,1460
+docs/examples/extras/SphereProperties.py,sha256=fNAHB4Xsyon5EaCZByureltLWqMHzszPXPzbwDE0HkM,1033
+docs/examples/extras/plot_Qsca_vs_permittivity_vs_size_parameter.py,sha256=v5hVh73t2QMX7oM1xw49Wkxoixn9yt9rfD8bINXEquc,1632
+docs/examples/extras/plot_coupling_heatmap.py,sha256=3f1kqHKB-tRITK7qhv1BwIyqtBauMwKxDQQTFHMA7ao,1792
+docs/examples/scatterer/plot_farfield.py,sha256=2Y36x0fCgnS2Uq-FaRi-xOkC0ZZ8tLLqvrIKaVtNYs8,1052
 docs/examples/scatterer/plot_footprint.py,sha256=9GfQGq315iTWu6y9T_CP1eJXuXlyyQ2CSm4ZACU4PQc,1367
 docs/examples/scatterer/plot_s1s2.py,sha256=j2aD457_aXyDhNq66FZr4QCAEx2cLgW17XOsrN2wclU,940
 docs/examples/scatterer/plot_source.py,sha256=BAw8KjynsrsUdL3Q8_Ko6i08HPv6ZCO84oZYay6yqJw,593
-docs/examples/scatterer/plot_spf.py,sha256=B_5PWEFhuWHBZ1TWCN_HeG4b2eIzhaEf-d2COWVNApE,999
+docs/examples/scatterer/plot_spf.py,sha256=D8pSUoekXsa9ZJfr-YwkmtG0hXX8T9pMbPmVI_ocRRk,1003
 docs/examples/scatterer/plot_stokes.py,sha256=bQ_xJi-kK-hcsqzwI97TQM-Fay5Ghvnhhn1TzOlOcfk,946
-docs/examples/validation/plot_BH810.py,sha256=iDAqzK94O4YicvE8gxkQPuz8O75ynRjaua_LG6VXlH0,1215
-docs/examples/validation/plot_BH87.py,sha256=tKXO6kPHRCVCcYHEnnnCh7miebe5jQe96C9EQZVXcE8,1666
-docs/examples/validation/plot_BH88.py,sha256=4pAUJTOisZMjkqNdj5uvB3BE3WOt-HaBan9euvh_4K4,1671
-docs/examples/validation/plot_phase_function_detector.py,sha256=VnZw_9oQJVbm2Q6KWMBSa4xg-vTqs5fRdC53e1BDVQI,2485
-docs/examples/validation/plot_pymiescatt_0.py,sha256=PTGMxsN4a-rQv50nPeIylgsQGl6ijJI3A7M6sn-nRsM,1455
-docs/examples/validation/plot_pymiescatt_1.py,sha256=QgVxqd74YArF-hYoR8hmYPI345S4Cs_UNZXAJdPXxq4,1613
-docs/examples/validation/plot_pymiescatt_2.py,sha256=5wrw74Y1oXegzoQx5ZbipwNrXqzmm2QHXvu8Unmvb_Y,1811
-docs/examples/validation/plot_pymiescatt_3.py,sha256=0Eu3viZN9WUWKisU5tNsXClfSYT3Y1HOeQDPCbeJQ-0,1809
+docs/examples/validation/plot_BH810.py,sha256=zs58v08mYthcVCXcM6DCE0PGO5-xcRR1cx8Ztw4ci70,1219
+docs/examples/validation/plot_BH87.py,sha256=Da0JMA3n7prDijKkDFepysEV0RElZOaUD95fUal-h7Y,1670
+docs/examples/validation/plot_BH88.py,sha256=i3VDSXWV6S8ebfCyQPf8lmCh55CtWUTVCMYZAIdzSkQ,2692
+docs/examples/validation/plot_phase_function_detector.py,sha256=qSb-UmZzCduoCKlZVHNxfgHwrDzL7C3JB_sj68FfDuQ,2763
+docs/examples/validation/plot_pymiescatt_0.py,sha256=V6pPbrKqgrdOzmguRZ2Fu5TUSHzO0UhtJGWnFXM-wVY,1966
+docs/examples/validation/plot_pymiescatt_1.py,sha256=RInA4JvdtNREpLYKa4e8vMVAIKb8HhFG0MqDdXP9JZs,2046
+docs/examples/validation/plot_pymiescatt_2.py,sha256=8_kTLidwKvi7cD3-yRL4Bl4T_GQUDa9Bc9sV6Quzu7I,2242
+docs/examples/validation/plot_pymiescatt_3.py,sha256=lwJAL1PP4tCGJS_oSIXMVWtSUoDp7DqPpABqOccHzLU,2344
 docs/source/conf.py,sha256=kQcXsOr9ovBFf86xxo9KU0SpglPQLrtOxDrp9ilGwRs,4717
 extern/pybind11/noxfile.py,sha256=GBm2vlcsgIEW_M3UnfIc4QSb-fe4Pg0vsAObCb8U3qU,2872
 extern/pybind11/setup.py,sha256=-Xpv99Fm-Y4cEU6fwadbPh4RptQ5WyTrJUQOp88ajVs,5027
 extern/pybind11/docs/benchmark.py,sha256=tYlMVW_GtxknuS-C3wC5fLP69K-64No0-h2J2rcQUWs,2943
 extern/pybind11/docs/conf.py,sha256=0QNgwuj4TUvnRT8cVh-prR0QFsZWVdYYGI1xEhjME5k,11942
 extern/pybind11/pybind11/__init__.py,sha256=dksfY3nzoZ03AJcx_f2hcVJM3ux4iRtkFEQIOUav3GQ,446
 extern/pybind11/pybind11/__main__.py,sha256=14R-y51seeb0de65x1CZt2picXBvL-N96jdtzUCC5CU,1606
@@ -173,31 +173,31 @@
 extern/pybind11/tests/test_cmake_build/test.py,sha256=FIAyjOQkxy8mScsPccANS8lIkxEHMXucr2D0IzjxY2Q,206
 extern/pybind11/tests/test_embed/test_interpreter.py,sha256=unuIU5dE-Ie8L2l6UkUuFfE2s_dTyboWkITp2TrjzuA,251
 extern/pybind11/tests/test_embed/test_trampoline.py,sha256=fa6Pm_kP3TZFriK4zGkJT98JF6GDWFoFGZ5fUAoP9zw,291
 extern/pybind11/tools/codespell_ignore_lines_from_errors.py,sha256=-uOBDpMzC32MQ-TtfYpWtBjb-9PzXcFNOIqCHuLcqgM,1156
 extern/pybind11/tools/libsize.py,sha256=xp1nJIl4vHGMbSpYOydVV9kzcraSNRXNS52eImM7a94,1067
 extern/pybind11/tools/make_changelog.py,sha256=8s1y9yPnWxYuX7-RjQKuIdZq3qpFCfLn_0g6kfxxU5s,1373
 tests/detectors/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-tests/detectors/test_coherent_mode.py,sha256=i0PaXbdjGucMqR7pVea-Edx30ZFnfTjxSsKg6HV5Q9U,1008
-tests/detectors/test_integration_sphere.py,sha256=yGtXF1TcqZrNsYXsyAffgK5TkCHj3gFGp_w6X8LE2rk,761
-tests/detectors/test_photodiode.py,sha256=OaQjOJNMD5zEikBHvyboXHXP5dqYqtRHBjaUenOjjpg,836
+tests/detectors/test_coherent_mode.py,sha256=3v-JDO687QI9s4K9FKMe0mULkUhj_FLSPCv10-Zkt88,1012
+tests/detectors/test_integration_sphere.py,sha256=oEBv6M2HZZW5qbzZoJHfypoYEgvdYEKT6yt3zSZS-0o,765
+tests/detectors/test_photodiode.py,sha256=j5j77PPmpkJTgk6RfVbMedI0nopp0e9pnVCcNcKFd9I,840
 tests/experiments/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-tests/experiments/test_coreshell.py,sha256=NOjATTCzkU5f1RlebjgGtYiD0kKl9p_G1CL5y-a7Uq8,2171
-tests/experiments/test_cylinder.py,sha256=_qGOzT-sZX9eikCAvJSV8BRFQ9PRuHxHk5in1mcrYPk,1637
-tests/experiments/test_sphere.py,sha256=1psGIgvtpfLr7DfOWkxrSdyUfjOJLJR6em93D9rRMcQ,1705
+tests/experiments/test_coreshell.py,sha256=iHmDukhkbOI9EPrEsfZ1MuJGoVsPkW6fdqXcv7vQS2w,2871
+tests/experiments/test_cylinder.py,sha256=Q9L876C8mTA-Wu5dQo5AS_gngQxRtoWm_Ku4L5gy13o,2256
+tests/experiments/test_sphere.py,sha256=B8tIo6skUM8H5NkqDEALKVBksDBkbtDSPbraYFG5DBQ,2337
 tests/extra/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 tests/extra/test_mesh.py,sha256=6L5tCwlC3m5uY9UbibX1mwoW3knyzqlVFztnOWIVjqU,222
 tests/scatterers/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-tests/scatterers/test_coreshell.py,sha256=-hnY0s0s59_BTUXa3tgXLmLJY2qKbKBaC7Vs2aVOZ9k,2952
-tests/scatterers/test_cylinder.py,sha256=Y4mmfQK8OJNdo_MGK9AZUmzm5FCTPFdPzmV_3X5vt7c,2264
-tests/scatterers/test_sphere.py,sha256=0GEDmdQyuCbzMRidqZ6vDL9bf72J9sjFl8m6pBhJjuk,2873
+tests/scatterers/test_coreshell.py,sha256=wnhKztlLSLmyODJyd1uytVvYDML88R8ZyT706bdkrlo,3535
+tests/scatterers/test_cylinder.py,sha256=5M2qL__wgBxf-AOFrT2XlcXzasGHEpiJvQmuB3UFV-0,2658
+tests/scatterers/test_sphere.py,sha256=a0I0DwYBSnyv7eyL_pdfkwMuldPDLw4bJQylMX-WxMg,3107
 tests/validation/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-tests/validation/test_coreshell_pymiescatt.py,sha256=YKk_JCnle_-dkpipLt7WPw4Yk12FliF7r1WYNh6UVHg,3155
-tests/validation/test_detector.py,sha256=WTCCpSTQthvPzfZjh8rDl0I0ITU_uD_muJ8GjR9Uht8,1990
+tests/validation/test_coreshell_pymiescatt.py,sha256=h4BTvqIMubj9N48yyZ20o-YQEL21KUcJ1Z2NHpUyYEg,3147
+tests/validation/test_detector.py,sha256=Ml5wBrK81pNzBwMQ8yHKksUZEv5R6oCM0KGUFB0Qa3I,1994
 tests/validation/test_sphere_internal.py,sha256=mc2vgvqGjSvbsA3Wknfew_k_yxkoUSEPZ3YINqfQmHA,2180
-tests/validation/test_sphere_pymiescatt.py,sha256=6QEkDMivbpcm7TTjuTNdwnJORtKkRRkHTuLKQxd3Nq0,2589
+tests/validation/test_sphere_pymiescatt.py,sha256=GJnNzIk6lEQMtEy5Y9W1nmu6CSxUqTLqBUhx1mbGwbs,2581
 tests/validation/test_sphere_scott_prahl.py,sha256=74T6lgF9yyeGfSM5R88J9EpCSew3vSYDCQrSZwnueEA,954
-PyMieSim-1.8.0.dist-info/LICENSE,sha256=Iiz1zBIAocPfqqVpPTakp8OKXY9K5j4bIRbgaXy2iAE,1109
-PyMieSim-1.8.0.dist-info/METADATA,sha256=PkFdYV0Q1E-SwzbNowx9pSz6pgWZPUE9Isj3-HN8Eho,9453
-PyMieSim-1.8.0.dist-info/WHEEL,sha256=fZWyj_84lK0cA-ZNCsdwhbJl0OTrpWkxInEn424qrSs,102
-PyMieSim-1.8.0.dist-info/top_level.txt,sha256=QC3b6aFV2qIGEOt4YzIHvFOTfelhUO2SFy-2gt4UcGY,72
-PyMieSim-1.8.0.dist-info/RECORD,,
+PyMieSim-1.8.1.dist-info/LICENSE,sha256=Iiz1zBIAocPfqqVpPTakp8OKXY9K5j4bIRbgaXy2iAE,1109
+PyMieSim-1.8.1.dist-info/METADATA,sha256=HKM-vgfhEc7R7NRhcTUgsjIgYSFCgsT77-AE2f-W9D0,9453
+PyMieSim-1.8.1.dist-info/WHEEL,sha256=fZWyj_84lK0cA-ZNCsdwhbJl0OTrpWkxInEn424qrSs,102
+PyMieSim-1.8.1.dist-info/top_level.txt,sha256=QC3b6aFV2qIGEOt4YzIHvFOTfelhUO2SFy-2gt4UcGY,72
+PyMieSim-1.8.1.dist-info/RECORD,,
```

