# Comparing `tmp/PyMonCtl-0.7-py3-none-any.whl.zip` & `tmp/PyMonCtl-0.91-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,24 +1,15 @@
-Zip file size: 86200 bytes, number of entries: 22
--rw-rw-rw-  2.0 fat     1202 b- defN 23-Sep-14 06:28 ewmhlib/__init__.py
--rw-rw-rw-  2.0 fat   155796 b- defN 23-Sep-20 10:11 ewmhlib/_ewmhlib.py
--rw-rw-rw-  2.0 fat      572 b- defN 23-Sep-14 06:28 ewmhlib/_main.py
--rw-rw-rw-  2.0 fat       66 b- defN 23-Aug-28 15:05 ewmhlib/py.typed
--rw-rw-rw-  2.0 fat      204 b- defN 23-Sep-13 13:38 ewmhlib/Props/__init__.py
--rw-rw-rw-  2.0 fat     4192 b- defN 23-Sep-13 13:39 ewmhlib/Props/_props.py
--rw-rw-rw-  2.0 fat      129 b- defN 23-Sep-13 13:49 ewmhlib/Structs/__init__.py
--rw-rw-rw-  2.0 fat     3844 b- defN 23-Sep-13 13:43 ewmhlib/Structs/_structs.py
--rw-rw-rw-  2.0 fat     1557 b- defN 23-Sep-20 10:49 pymonctl/__init__.py
--rw-rw-rw-  2.0 fat    24917 b- defN 23-Jun-16 12:19 pymonctl/_display_manager_lib.py
--rw-rw-rw-  2.0 fat    32376 b- defN 23-Sep-15 22:20 pymonctl/_main.py
--rw-rw-rw-  2.0 fat    34678 b- defN 23-Sep-20 14:57 pymonctl/_pymonctl_linux.py
--rw-rw-rw-  2.0 fat    27716 b- defN 23-Sep-18 16:13 pymonctl/_pymonctl_macos.py
--rw-rw-rw-  2.0 fat    41089 b- defN 23-Sep-18 16:13 pymonctl/_pymonctl_win.py
--rw-rw-rw-  2.0 fat     8900 b- defN 23-Sep-12 16:36 pymonctl/_structs.py
+Zip file size: 45551 bytes, number of entries: 13
+-rw-rw-rw-  2.0 fat     1662 b- defN 24-Apr-18 19:51 pymonctl/__init__.py
+-rw-rw-rw-  2.0 fat    37348 b- defN 24-Apr-04 12:32 pymonctl/_main.py
+-rw-rw-rw-  2.0 fat    46302 b- defN 24-Apr-17 11:12 pymonctl/_pymonctl_linux.py
+-rw-rw-rw-  2.0 fat    32558 b- defN 24-Apr-18 19:24 pymonctl/_pymonctl_macos.py
+-rw-rw-rw-  2.0 fat    45385 b- defN 24-Apr-08 08:47 pymonctl/_pymonctl_win.py
+-rw-rw-rw-  2.0 fat     9589 b- defN 23-Oct-21 10:48 pymonctl/_structs.py
 -rw-rw-rw-  2.0 fat       67 b- defN 23-May-23 09:29 pymonctl/py.typed
--rw-rw-rw-  2.0 fat      200 b- defN 23-Sep-20 14:59 PyMonCtl-0.7.dist-info/AUTHORS.txt
--rw-rw-rw-  2.0 fat     1543 b- defN 23-Sep-20 14:59 PyMonCtl-0.7.dist-info/LICENSE.txt
--rw-rw-rw-  2.0 fat    11786 b- defN 23-Sep-20 14:59 PyMonCtl-0.7.dist-info/METADATA
--rw-rw-rw-  2.0 fat       92 b- defN 23-Sep-20 14:59 PyMonCtl-0.7.dist-info/WHEEL
--rw-rw-rw-  2.0 fat       17 b- defN 23-Sep-20 14:59 PyMonCtl-0.7.dist-info/top_level.txt
--rw-rw-r--  2.0 fat     1745 b- defN 23-Sep-20 14:59 PyMonCtl-0.7.dist-info/RECORD
-22 files, 352688 bytes uncompressed, 83408 bytes compressed:  76.4%
+-rw-rw-rw-  2.0 fat      528 b- defN 24-Apr-18 19:51 PyMonCtl-0.91.dist-info/AUTHORS.txt
+-rw-rw-rw-  2.0 fat     1543 b- defN 24-Apr-18 19:51 PyMonCtl-0.91.dist-info/LICENSE.txt
+-rw-rw-rw-  2.0 fat    12243 b- defN 24-Apr-18 19:51 PyMonCtl-0.91.dist-info/METADATA
+-rw-rw-rw-  2.0 fat       92 b- defN 24-Apr-18 19:51 PyMonCtl-0.91.dist-info/WHEEL
+-rw-rw-rw-  2.0 fat        9 b- defN 24-Apr-18 19:51 PyMonCtl-0.91.dist-info/top_level.txt
+-rw-rw-r--  2.0 fat     1035 b- defN 24-Apr-18 19:51 PyMonCtl-0.91.dist-info/RECORD
+13 files, 188361 bytes uncompressed, 43839 bytes compressed:  76.7%
```

## zipnote {}

```diff
@@ -1,37 +1,10 @@
-Filename: ewmhlib/__init__.py
-Comment: 
-
-Filename: ewmhlib/_ewmhlib.py
-Comment: 
-
-Filename: ewmhlib/_main.py
-Comment: 
-
-Filename: ewmhlib/py.typed
-Comment: 
-
-Filename: ewmhlib/Props/__init__.py
-Comment: 
-
-Filename: ewmhlib/Props/_props.py
-Comment: 
-
-Filename: ewmhlib/Structs/__init__.py
-Comment: 
-
-Filename: ewmhlib/Structs/_structs.py
-Comment: 
-
 Filename: pymonctl/__init__.py
 Comment: 
 
-Filename: pymonctl/_display_manager_lib.py
-Comment: 
-
 Filename: pymonctl/_main.py
 Comment: 
 
 Filename: pymonctl/_pymonctl_linux.py
 Comment: 
 
 Filename: pymonctl/_pymonctl_macos.py
@@ -42,26 +15,26 @@
 
 Filename: pymonctl/_structs.py
 Comment: 
 
 Filename: pymonctl/py.typed
 Comment: 
 
-Filename: PyMonCtl-0.7.dist-info/AUTHORS.txt
+Filename: PyMonCtl-0.91.dist-info/AUTHORS.txt
 Comment: 
 
-Filename: PyMonCtl-0.7.dist-info/LICENSE.txt
+Filename: PyMonCtl-0.91.dist-info/LICENSE.txt
 Comment: 
 
-Filename: PyMonCtl-0.7.dist-info/METADATA
+Filename: PyMonCtl-0.91.dist-info/METADATA
 Comment: 
 
-Filename: PyMonCtl-0.7.dist-info/WHEEL
+Filename: PyMonCtl-0.91.dist-info/WHEEL
 Comment: 
 
-Filename: PyMonCtl-0.7.dist-info/top_level.txt
+Filename: PyMonCtl-0.91.dist-info/top_level.txt
 Comment: 
 
-Filename: PyMonCtl-0.7.dist-info/RECORD
+Filename: PyMonCtl-0.91.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## pymonctl/__init__.py

```diff
@@ -1,29 +1,29 @@
 #!/usr/bin/python
 # -*- coding: utf-8 -*-
 
 __all__ = [
-    "getAllMonitors", "getAllMonitorsDict", "getMonitorsCount", "getPrimary", "findMonitorsAtPoint",
-    "findMonitorsAtPointInfo",
-    "arrangeMonitors", "getMousePos", "version", "Monitor",
+    "getAllMonitors", "getAllMonitorsDict", "getMonitorsCount", "getPrimary",
+    "findMonitorsAtPoint", "findMonitorsAtPointInfo", "findMonitorWithName", "findMonitorWithNameInfo",
+    "saveSetup", "restoreSetup", "arrangeMonitors", "getMousePos", "version", "Monitor",
     "enableUpdateInfo", "disableUpdateInfo", "isUpdateInfoEnabled", "isWatchdogEnabled", "updateWatchdogInterval",
     "plugListenerRegister", "plugListenerUnregister", "isPlugListenerRegistered",
     "changeListenerRegister", "changeListenerUnregister", "isChangeListenerRegistered",
     "DisplayMode", "ScreenValue", "Size", "Point", "Box", "Rect", "Position", "Orientation"
 ]
 
-__version__ = "0.7"
+__version__ = "0.91"
 
 
 def version(numberOnly: bool = True) -> str:
     """Returns the current version of PyMonCtl module, in the form ''x.x.xx'' as string"""
     return ("" if numberOnly else "PyMonCtl-")+__version__
 
 
 from ._main import (getAllMonitors, getAllMonitorsDict, getMonitorsCount, getPrimary,
                     findMonitorsAtPoint, findMonitorsAtPointInfo, findMonitorWithName, findMonitorWithNameInfo,
-                    arrangeMonitors, getMousePos, Monitor,
+                    saveSetup, restoreSetup, arrangeMonitors, getMousePos, Monitor,
                     enableUpdateInfo, disableUpdateInfo, isUpdateInfoEnabled, isWatchdogEnabled, updateWatchdogInterval,
                     plugListenerRegister, plugListenerUnregister, isPlugListenerRegistered,
                     changeListenerRegister, changeListenerUnregister, isChangeListenerRegistered,
                     DisplayMode, ScreenValue, Size, Point, Box, Rect, Position, Orientation
                     )
```

## pymonctl/_main.py

```diff
@@ -2,15 +2,15 @@
 # -*- coding: utf-8 -*-
 from __future__ import annotations
 
 import sys
 import threading
 from abc import abstractmethod, ABC
 from collections.abc import Callable
-from typing import List, Optional, Union, Tuple
+from typing import List, Optional, Union, Tuple, cast
 
 from ._structs import DisplayMode, ScreenValue, Size, Point, Box, Rect, Position, Orientation
 
 
 def _pointInBox(x: int, y: int, left: int, top: int, width: int, height: int) -> bool:
     """Returns ``True`` if the ``(x, y)`` point is within the box described
     by ``(left, top, width, height)``."""
@@ -73,14 +73,24 @@
     global _updateScreens
     if _updateScreens is None:
         return _getAllMonitorsDict()
     else:
         return _updateScreens.getScreens()
 
 
+def getMonitorsData(handle: Optional[int] = None):
+    # Linux ONLY since X11 is not thread-safe (randr crashes when querying in parallel from separate thread)
+    if sys.platform == "linux":
+        if _updateScreens is None:
+            return _getMonitorsData(handle)
+        else:
+            return _updateScreens.getMonitorsData(handle)
+    return []
+
+
 def getMonitorsCount() -> int:
     """
     Get the number of monitors currently connected to the system.
 
     :return: number of monitors as integer
     """
     return _getMonitorsCount()
@@ -150,15 +160,15 @@
     for monitor in monitors.keys():
         if monitor == name:
             info[monitor] = monitors[monitor]
             break
     return info
 
 
-def arrangeMonitors(arrangement: dict[str, dict[str, Union[str, int, Position, Point, Size]]]):
+def arrangeMonitors(arrangement: dict[str, dict[str, Optional[Union[str, int, Position, Point, Size]]]]):
     """
     Arrange all monitors in a given shape.
 
     For that, you must pass a dict with the following structure:
         "Monitor name":
             monitor name as keys() returned by getAllMonitorsDict() (don't use "system_name" value for this)
                 "relativePos":
@@ -189,15 +199,72 @@
 
 def getMousePos() -> Point:
     """
     Get the current (x, y) coordinates of the mouse pointer on screen, in pixels
 
     :return: Point struct
     """
-    return _getMousePos()
+    return cast(Point, _getMousePos())
+
+
+def saveSetup() -> List[Tuple[Monitor, ScreenValue]]:
+    """
+    Save current monitors setup information to be restored afterward.
+
+    If you just need monitors information in dictionary format, use getAllMonitorsDict() instead.
+
+    If you need all monitors instances to access all methods, use getAllMonitors() instead.
+
+    :return: list of tuples containing all necessary info to restore saved setup as required by restoreSetup()
+    """
+    result: List[Tuple[Monitor, ScreenValue]] = []
+    monDict: dict[str, ScreenValue] = getAllMonitorsDict()
+    for monName in monDict.keys():
+        result.append((Monitor(monDict[monName]["id"]), monDict[monName]))
+    return result
+
+
+def restoreSetup(setup: List[Tuple[Monitor, ScreenValue]]):
+    """
+    Restore given monitors setup (position, mode, orientation, scale, etc.). The function will also
+    try to re-attach / turn on / wake monitors if needed.
+
+    In case you want to just reposition monitors without changing all other settings, use arrangeMonitors() instead.
+
+    :param setup: monitors info dictionary as returned by saveSetup()
+    """
+    arrangement: dict[str, dict[str, Optional[Union[str, int, Position, Point, Size]]]] = {}
+    for monData in setup:
+        monitor, monDict = monData
+        if not monitor.isAttached:
+            try:
+                monitor.attach()
+            except:
+                continue
+        if monitor.isAttached:
+            if monitor.isSuspended or not monitor.isOn:
+                monitor.turnOn()
+            if monDict["is_primary"]:
+                monitor.setPrimary()
+            mode = DisplayMode(monDict["size"].width, monDict["size"].height, monDict["frequency"])
+            if mode and monitor.mode != mode:
+                monitor.setMode(mode)
+            orientation = monDict["orientation"]
+            if orientation is not None and monitor.orientation != orientation:
+                monitor.setOrientation(orientation)
+            scale = monDict["scale"]
+            if monitor.scale != scale:
+                monitor.setScale(scale)
+            if monitor.isPrimary and sys.platform != "linux":
+                pos = Position.PRIMARY
+            else:
+                pos = monDict["position"]
+            arrangement[monitor.name] = {"relativePos": pos, "relativeTo": None}
+    if arrangement:
+        arrangeMonitors(arrangement)
 
 
 class BaseMonitor(ABC):
 
     @property
     @abstractmethod
     def size(self) -> Optional[Size]:
@@ -287,49 +354,56 @@
     @property
     @abstractmethod
     def scale(self) -> Optional[Tuple[float, float]]:
         """
         Get scale for the monitor
 
         Note not all scales will be allowed for all monitors and/or modes
+
+        :return: tuple of float scale value in X, Y coordinates
         """
         raise NotImplementedError
 
     @abstractmethod
-    def setScale(self, scale: Tuple[float, float]):
+    def setScale(self, scale: Tuple[float, float], applyGlobally: bool = True):
         """
         Change scale for the monitor
 
         Note not all scales will be allowed for all monitors and/or modes
 
-        :param scale: target percentage as float value
+        :param scale: target percentage as tuple of float value
+        :param applyGlobally: (GNOME/X11 ONLY) Will affect all monitors (''True'', default) or selected one only (''False'')
         """
         raise NotImplementedError
 
     @property
     @abstractmethod
     def dpi(self) -> Optional[Tuple[float, float]]:
         """
         Get the dpi (dots/pixels per inch) value for the monitor
 
         This property can not be set
+
+        :return: tuple of dpi float value in X, Y coordinates
         """
         raise NotImplementedError
 
     @property
     @abstractmethod
     def orientation(self) -> Optional[Union[int, Orientation]]:
         """
         Get current orientation for the monitor identified by name (or primary if empty)
 
         The available orientations are:
             0 - 0 degrees (normal)
             1 - 90 degrees (right)
             2 - 180 degrees (inverted)
             3 - 270 degrees (left)
+
+        :return: current orientation value as int (or Orientation value)
         """
         raise NotImplementedError
 
     @abstractmethod
     def setOrientation(self, orientation: Optional[Union[int, Orientation]]):
         """
         Change orientation for the monitor identified by name (or primary if empty)
@@ -348,64 +422,72 @@
     @abstractmethod
     def frequency(self) -> Optional[float]:
         """
         Get current refresh rate of monitor.
 
         This property can not be set independently. To do so, choose an allowed mode (from monitor.allModes)
         and set the monitor mode property (monitor.mode = selectedMode)
+
+        :return: float
         """
         raise NotImplementedError
 
     @property
     @abstractmethod
     def colordepth(self) -> Optional[int]:
         """
         Get the colordepth (bits per pixel to describe color) value for the monitor
 
         This property can not be set
+
+        :return: int
         """
         raise NotImplementedError
 
     @property
     @abstractmethod
     def brightness(self) -> Optional[int]:
         """
         Get the brightness of monitor. The return value is normalized to 0-100 (as a percentage)
 
-        :return: brightness as float
+        :return: brightness as int (1-100)
         """
         raise NotImplementedError
 
     @abstractmethod
     def setBrightness(self, brightness: Optional[int]):
         """
         Change the brightness of monitor. The input parameter must be defined as a percentage (0-100)
+
+        :param brightness: brightness value to be set (0-100)
         """
         raise NotImplementedError
 
     @property
     @abstractmethod
     def contrast(self) -> Optional[int]:
         """
         Get the contrast of monitor. The return value is normalized to 0-100 (as a percentage)
 
         WARNING: In Linux and macOS contrast is calculated from Gamma RGB values.
 
-        :return: contrast as float
+        :return: contrast as int (1-100)
         """
         raise NotImplementedError
 
     @abstractmethod
     def setContrast(self, contrast: Optional[int]):
         """
         Change the contrast of monitor. The input parameter must be defined as a percentage (0-100)
 
         WARNING: In Linux and macOS the change will apply to Gamma homogeneously for all color components (R, G, B).
 
         Example for Linux: A value of 50.0 (50%), will result in a Gamma of ''0.5:0.5:0.5''
+
+        :param contrast: contrast value to be set (0-100)
         """
         raise NotImplementedError
 
     @property
     @abstractmethod
     def mode(self) -> Optional[DisplayMode]:
         """
@@ -450,14 +532,15 @@
         Get all allowed modes for the monitor
 
         :return: list of DisplayMode (width, height, frequency)
         """
         raise NotImplementedError
 
     @property
+    @abstractmethod
     def isPrimary(self) -> bool:
         """
         Check if given monitor is primary.
 
         :return: ''True'' if given monitor is primary, ''False'' otherwise
         """
         raise NotImplementedError
@@ -491,14 +574,26 @@
                 To address a specific monitor, try using detach() method
 
             macOS:
                 Didn't find a way to programmatically turn off a given monitor. Use suspend instead.
         """
         raise NotImplementedError
 
+    @property
+    @abstractmethod
+    def isOn(self) -> Optional[bool]:
+        """
+        Check if monitor is on
+
+        WARNING: not working in macOS (... yet?)
+
+        :return: ''True'' if monitor is on
+        """
+        raise NotImplementedError
+
     @abstractmethod
     def suspend(self):
         """
         Suspend (standby) monitor
 
         WARNING:
 
@@ -512,76 +607,90 @@
             macOS:
                 This method will suspend ALL monitors.
         """
         raise NotImplementedError
 
     @property
     @abstractmethod
-    def isOn(self) -> Optional[bool]:
+    def isSuspended(self) -> Optional[bool]:
         """
-        Check if monitor is on
+        Check if monitor is in standby mode
 
-        WARNING: not working in macOS (... yet?)
+        :return: ''True'' if monitor is in standby mode
         """
         raise NotImplementedError
 
     @abstractmethod
     def attach(self):
         """
         Attach a previously detached monitor to system
 
-        All monitor IDs will change after detaching or attaching a monitor. The module will try to refresh them for
-        all existing instances
+        WARNING: In Windows, all IDs may change when attach / detach / plug / unplug a monitor. The module
+                 will try to refresh all IDs from all Monitor class instances... but take into account it may fail!
 
         WARNING: not working in macOS (... yet?)
         """
         raise NotImplementedError
 
     @abstractmethod
     def detach(self, permanent: bool = False):
         """
         Detach monitor from system.
 
         Be aware that if you detach a monitor and the script ends, you will have to physically re-attach the monitor.
 
-        All monitor IDs will change after detaching or attaching a monitor. The module will try to refresh them for
-        all existing instances
-
         It will not likely work if system has just one monitor plugged.
 
+        WARNING: In Windows, all IDs may change when attach / detach / plug / unplug a monitor. The module
+                 will try to refresh all IDs from all Monitor class instances... but take into account it may fail!
+
         WARNING: not working in macOS (... yet?)
+
+        :param permanent: set to ''True'' to permanently detach the monitor from system
         """
         raise NotImplementedError
 
     @property
     @abstractmethod
     def isAttached(self) -> Optional[bool]:
         """
         Check if monitor is attached (not necessarily ON) to system
+
+        :return: ''True'' if monitor is attached
         """
         raise NotImplementedError
 
 
 _updateRequested = False
 _plugListeners: List[Callable[[List[str], dict[str, ScreenValue]], None]] = []
-_lockPlug = threading.RLock()
 _changeListeners: List[Callable[[List[str], dict[str, ScreenValue]], None]] = []
-_lockChange = threading.RLock()
 _kill = threading.Event()
+_interval = 0.5
 
 
 class _UpdateScreens(threading.Thread):
 
-    def __init__(self, kill: threading.Event):
+    def __init__(self, kill: threading.Event, interval: float = 0.5):
         threading.Thread.__init__(self)
 
         self._kill = kill
-        self._interval = 0.5
-        self._screens: dict[str, ScreenValue] = _getAllMonitorsDict()
-        self._monitors: list[Monitor] = []
+        self._interval = interval
+        self._screens: dict[str, ScreenValue] = {}
+        if sys.platform == "linux":
+            import Xlib.display
+            from Xlib.ext import randr
+            from Xlib.protocol.rq import Struct
+            from Xlib.xobject.drawable import Window as XWindow
+            self._monitorsData: List[Tuple[Xlib.display.Display, Struct, XWindow,randr.GetScreenResourcesCurrent,
+                                                     randr.MonitorInfo, str, int, randr.GetOutputInfo,
+                                                     int, randr.GetCrtcInfo]] = []
+            self._screens, self._monitorsData = _getAllMonitorsDictThread()
+        else:
+            self._screens = _getAllMonitorsDict()
+            self._monitorsData = []  # type: ignore[var-annotated]
 
     def run(self):
 
         # _eventLoop(self._kill, self._interval)
 
         """
             id
@@ -596,56 +705,73 @@
             colordepth
 
             brightness
             contrast
             On / Off / Standby
             Attach / Detach
         """
-
         global _updateRequested
         global _plugListeners
         global _changeListeners
 
         while not self._kill.is_set():
 
-            if _updateRequested or _plugListeners or _changeListeners:
-
+            if sys.platform == "linux":
+                # Linux ONLY since X11 is not thread-safe (randr crashes when querying in parallel from separate thread)
+                screens, self._monitorsData = _getAllMonitorsDictThread()
+            else:
                 screens = _getAllMonitorsDict()
-                newScreens = list(screens.keys())
-                currentScreens = list(self._screens.keys())
 
-                if currentScreens != newScreens:
-                    names = [s for s in newScreens if s not in currentScreens] + \
-                            [s for s in currentScreens if s not in newScreens]
+            newScreens = list(screens.keys())
+            currentScreens = list(self._screens.keys())
+
+            if _plugListeners:
+                names = [s for s in newScreens if s not in currentScreens] + \
+                        [s for s in currentScreens if s not in newScreens]
+                if names:
                     for listener in _plugListeners:
                         listener(names, screens)
 
-                if self._screens != screens:
-                    names = [s for s in newScreens if s in currentScreens and screens[s] != self._screens[s]]
-                    self._screens = screens
-                    if names:
-                        for listener in _changeListeners:
-                            listener(names, screens)
+            if _changeListeners:
+                names = [s for s in newScreens if s in currentScreens and screens[s] != self._screens[s]]
+                if names:
+                    for listener in _changeListeners:
+                        listener(names, screens)
 
-                self._monitors = _getAllMonitors()
+            self._screens = screens
 
             self._kill.wait(self._interval)
 
     def updateInterval(self, interval: float):
         self._interval = interval
 
     def getScreens(self) -> dict[str, ScreenValue]:
         return self._screens
 
     def getMonitors(self) -> list[Monitor]:
-        return self._monitors
+        monitors: list[Monitor] = []
+        for screen in self._screens.keys():
+            try:
+                monitors.append(Monitor(self._screens[screen]["id"]))
+            except:
+                pass
+        return monitors
+
+    def getMonitorsData(self, handle):
+        # Linux ONLY to avoid randr crashing when querying from separate thread and/or too quickly in parallel
+        if handle:
+            for monitorData in self._monitorsData:
+                display, screen, root, res, monitor, monName, output, outputInfo, crtc, crtcInfo = monitorData
+                if handle == output:
+                    return [(display, screen, root, res, monitor, monName, output, outputInfo, crtc, crtcInfo)]
+            return []
+        return self._monitorsData
 
 
 _updateScreens: Optional[_UpdateScreens] = None
-_lockUpdate = threading.RLock()
 
 
 def enableUpdateInfo():
     """
     Enable this only if you need to keep track of monitor-related events like changing its resolution, position,
     or if monitors can be dynamically plugged or unplugged in a multi-monitor setup. This function can also be
     useful in scenarios in which monitors list or properties need to be queried quickly and repeatedly, thus keeping
@@ -655,28 +781,29 @@
     their properties (see getAllMonitors() and getAllMonitorsDict() functions).
 
     If disabled, the information on the monitors connected to the system will be updated right at the moment,
     but this might be slow and CPU-consuming, especially if quickly and repeatedly invoked.
     """
     global _updateRequested
     _updateRequested = True
-    if _updateScreens is None:
-        _startUpdateScreens()
+    _startUpdateScreens()
 
 
 def disableUpdateInfo():
     """
     The monitors information will be immediately queried after disabling this feature, not taking advantage of
     keeping information updated on a separate thread.
 
     Enable this process again, or invoke getMonitors() function if you need updated info.
     """
     global _updateRequested
     _updateRequested = False
-    if not _plugListeners and not _changeListeners and not _updateRequested:
+    global _plugListeners
+    global _changeListeners
+    if not _plugListeners and not _changeListeners:
         _killUpdateScreens()
 
 
 def plugListenerRegister(monitorCountChanged: Callable[[List[str], dict[str, ScreenValue]], None]):
     """
     Use this only if you need to keep track of monitor that can be dynamically plugged or unplugged in a
     multi-monitor setup.
@@ -688,37 +815,34 @@
         - All screens info, as returned by getAllMonitorsDict() function.
 
     It is possible to access all monitors information by using screen name as dictionary key
 
     :param monitorCountChanged: callback to be invoked in case the number of monitor connected changes
     """
     global _plugListeners
-    global _lockPlug
-    with _lockPlug:
-        if monitorCountChanged not in _plugListeners:
-            _plugListeners.append(monitorCountChanged)
-    if _updateScreens is None:
+    if monitorCountChanged not in _plugListeners:
+        _plugListeners.append(monitorCountChanged)
         _startUpdateScreens()
 
 
 def plugListenerUnregister(monitorCountChanged: Callable[[List[str], dict[str, ScreenValue]], None]):
     """
     Use this function to un-register your custom callback. The callback will not be invoked anymore in case
     the number of monitor changes.
 
     :param monitorCountChanged: callback previously registered
     """
     global _plugListeners
-    global _lockPlug
-    with _lockPlug:
-        try:
-            objIndex = _plugListeners.index(monitorCountChanged)
-            _plugListeners.pop(objIndex)
-        except:
-            pass
+    try:
+        objIndex = _plugListeners.index(monitorCountChanged)
+        _plugListeners.pop(objIndex)
+    except:
+        pass
+    global _changeListeners
+    global _updateRequested
     if not _plugListeners and not _changeListeners and not _updateRequested:
         _killUpdateScreens()
 
 
 def changeListenerRegister(monitorPropsChanged: Callable[[List[str], dict[str, ScreenValue]], None]):
     """
     Use this only if you need to keep track of monitor properties changes (position, size, refresh-rate, etc.) in a
@@ -731,76 +855,56 @@
         - All screens info, as returned by getAllMonitorsDict() function.
 
     It is possible to access all monitor information by using screen name as dictionary key
 
     :param monitorPropsChanged: callback to be invoked in case the number of monitor properties change
     """
     global _changeListeners
-    global _lockChange
-    with _lockChange:
-        if monitorPropsChanged not in _changeListeners:
-            _changeListeners.append(monitorPropsChanged)
-    if _updateScreens is None:
+    if monitorPropsChanged not in _changeListeners:
+        _changeListeners.append(monitorPropsChanged)
         _startUpdateScreens()
 
 
 def changeListenerUnregister(monitorPropsChanged: Callable[[List[str], dict[str, ScreenValue]], None]):
     """
     Use this function to un-register your custom callback. The callback will not be invoked anymore in case
     the monitor properties change.
 
     :param monitorPropsChanged: callback previously registered
     """
     global _changeListeners
-    global _lockChange
-    with _lockChange:
-        try:
-            objIndex = _plugListeners.index(monitorPropsChanged)
-            _plugListeners.pop(objIndex)
-        except:
-            pass
+    try:
+        objIndex = _changeListeners.index(monitorPropsChanged)
+        _changeListeners.pop(objIndex)
+    except:
+        pass
+    global _plugListeners
+    global _updateRequested
     if not _plugListeners and not _changeListeners and not _updateRequested:
         _killUpdateScreens()
 
 
 def _startUpdateScreens():
     global _updateScreens
-    global _lockUpdate
-    with _lockUpdate:
-        if _updateScreens is None:
-            _kill.clear()
-            _updateScreens = _UpdateScreens(_kill)
-            _updateScreens.daemon = True
-            _updateScreens.start()
+    if _updateScreens is None:
+        global _kill
+        _kill.clear()
+        global _interval
+        _updateScreens = _UpdateScreens(_kill, _interval)
+        _updateScreens.daemon = True
+        _updateScreens.start()
 
 
 def _killUpdateScreens():
     global _updateScreens
-    global _lockUpdate
-    global _kill
-    with _lockUpdate:
-        if _updateScreens is not None:
-            timer = threading.Timer(_updateScreens._interval * 2, _timerHandler)
-            timer.start()
-            try:
-                _kill.set()
-                _updateScreens.join(_updateScreens._interval * 3)
-            except:
-                pass
-            _updateScreens = None
-            timer.cancel()
-
-
-class _TimeOutException(Exception):
-    pass
-
-
-def _timerHandler():
-    global _updateScreens
-    raise _TimeOutException()
+    if _updateScreens is not None:
+        global _kill
+        _kill.set()
+        _updateScreens.join()
+        _updateScreens = None
 
 
 def isWatchdogEnabled() -> bool:
     """
     Check if the daemon updating screens information and (if applies) invoking callbacks when needed is alive.
 
     If it is not, just enable update process, or register the callbacks you need. It will be automatically started.
@@ -853,14 +957,16 @@
     may not necessarily produce better (faster) results.
 
     :param interval: new interval value in seconds (or fractions), as float.
     """
     global _updateScreens
     if interval > 0 and _updateScreens is not None:
         _updateScreens.updateInterval(interval)
+        global _interval
+        _interval = interval
 
 
 def _getRelativePosition(monitor, relativeTo) -> Tuple[int, int]:
     relPos = monitor["relativePos"]
     if relPos == Position.PRIMARY:
         x = y = 0
     elif relPos == Position.LEFT_TOP:
@@ -909,12 +1015,13 @@
                                   _findMonitor, _arrangeMonitors, _getMousePos, MacOSMonitor as Monitor
                                   )
 elif sys.platform == "win32":
     from ._pymonctl_win import (_getAllMonitors, _getAllMonitorsDict, _getMonitorsCount, _getPrimary,
                                 _findMonitor, _arrangeMonitors, _getMousePos, Win32Monitor as Monitor
                                 )
 elif sys.platform == "linux":
-    from ._pymonctl_linux import (_getAllMonitors, _getAllMonitorsDict, _getMonitorsCount, _getPrimary,
-                                  _findMonitor, _arrangeMonitors, _getMousePos, LinuxMonitor as Monitor
+    from ._pymonctl_linux import (_getAllMonitors, _getAllMonitorsDict, _getAllMonitorsDictThread, _getMonitorsData,
+                                  _getMonitorsCount, _getPrimary, _findMonitor, _arrangeMonitors, _getMousePos,
+                                  LinuxMonitor as Monitor
                                   )
 else:
     raise NotImplementedError('PyMonCtl currently does not support this platform. If you think you can help, please contribute! https://github.com/Kalmat/PyMonCtl')
```

## pymonctl/_pymonctl_linux.py

```diff
@@ -1,618 +1,624 @@
 #!/usr/bin/python
 # -*- coding: utf-8 -*-
 from __future__ import annotations
 
 import sys
+
 assert sys.platform == "linux"
 
+import math
+import os
 import subprocess
 import threading
 
-import math
-from typing import Optional, List, Union, Tuple
+from typing import Optional, List, Union, Tuple, NamedTuple
 
 import Xlib.display
 import Xlib.X
 import Xlib.protocol
 import Xlib.xobject
+from Xlib.protocol.rq import Struct
+from Xlib.xobject.drawable import Window as XWindow
 from Xlib.ext import randr
+from Xlib.ext.randr import GetScreenResourcesCurrent, MonitorInfo, GetOutputInfo, GetCrtcInfo
 
-from ._main import BaseMonitor, _pointInBox, _getRelativePosition, \
+from ._main import BaseMonitor, _pointInBox, _getRelativePosition, getMonitorsData, isWatchdogEnabled, \
                    DisplayMode, ScreenValue, Box, Rect, Point, Size, Position, Orientation
-from ewmhlib import defaultEwmhRoot, getProperty, getPropertyValue, getRoots, getRootsInfo, Props
+from ewmhlib import defaultEwmhRoot, getProperty, getPropertyValue, getRoots, Props
 
 
 def _getAllMonitors() -> list[LinuxMonitor]:
-    monitors = []
-    outputs = _XgetAllOutputs()
-    for outputData in outputs:
-        display, screen, root, res, output, outputInfo = outputData
-        if outputInfo.crtc:
-            monitors.append(LinuxMonitor(output))
-    return monitors
+    return [LinuxMonitor(monitor.crtcs[0]) for monitor in _XgetMonitors()]
 
 
 def _getAllMonitorsDict() -> dict[str, ScreenValue]:
     # https://stackoverflow.com/questions/8705814/get-display-count-and-resolution-for-each-display-in-python-without-xrandr
     # https://www.x.org/releases/X11R7.7/doc/libX11/libX11/libX11.html#Obtaining_Information_about_the_Display_Image_Formats_or_Screens
     # https://github.com/alexer/python-xlib/blob/master/examples/xrandr.py
-    result: dict[str, ScreenValue] = {}
-
-    outputs = _XgetAllOutputs()
-    for monitorData in _XgetAllMonitors():
-        display, root, monitor, monitorName = monitorData
-
-        for outputData in outputs:
-            display, screen, root, res, output, outputInfo = outputData
+    monitorsDict: dict[str, ScreenValue] = {}
+    for monitorData in getMonitorsData():
+        display, screen, root, res, monitor, monName, output, outputInfo, crtc, crtcInfo = monitorData
+        monitorsDict[monName] = _buildMonitorsDict(display, screen, root, res, monitor, monName, output, outputInfo, crtc, crtcInfo)
+    return monitorsDict
+
+
+def _getAllMonitorsDictThread() -> (Tuple[dict[str, ScreenValue],
+                                          List[Tuple[Xlib.display.Display, Struct, XWindow, GetScreenResourcesCurrent,
+                                                     MonitorInfo, str, int, GetOutputInfo, int, GetCrtcInfo]]]):
+    # display connections seem to fail when shared amongst threads and/or queried too quickly in parallel
+    monitorsDict: dict[str, ScreenValue] = {}
+    monitorsData: List[Tuple[Xlib.display.Display, Struct, XWindow, GetScreenResourcesCurrent,
+                             MonitorInfo, str, int, GetOutputInfo, int, GetCrtcInfo]] = []
+    for monitorData in _getMonitorsData():
+        display, screen, root, res, monitor, monName, output, outputInfo, crtc, crtcInfo = monitorData
+        monitorsDict[monName] = _buildMonitorsDict(display, screen, root, res, monitor, monName, output, outputInfo, crtc, crtcInfo)
+        monitorsData.append((display, screen, root, res, monitor, monName, output, outputInfo, crtc, crtcInfo))
+    return monitorsDict, monitorsData
+
+
+def _buildMonitorsDict(display, screen, root, res, monitor, monName, output, outputInfo, crtc, crtcInfo) -> ScreenValue:
+
+    is_primary = monitor.primary == 1
+    x, y, w, h = monitor.x, monitor.y, monitor.width_in_pixels, monitor.height_in_pixels
+    wa: List[int] = getPropertyValue(getProperty(window=root, prop=Props.Root.WORKAREA, display=display),
+                                     display=display)
+    # Thanks to odknt (https://github.com/odknt) for his HELP!!!
+    if isinstance(wa, list) and len(wa) >= 4:
+        wx, wy, wr, wb = wa[0], wa[1], wa[2], wa[3]
+    else:
+        wx, wy, wr, wb = x, y, w, h
+    mm_width = monitor.width_in_millimeters or outputInfo.mm_width
+    mm_height = monitor.height_in_millimeters or outputInfo.mm_height
+    if mm_width != 0 and mm_height != 0:
+        dpiX, dpiY = round((w * 25.4) / mm_width), round((h * 25.4) / mm_height)
+    else:
+        dpiX, dpiY = 0.0, 0.0
+    scaleX, scaleY = _scale(monName) or (0.0, 0.0)
+    rotValue = int(math.log(crtcInfo.rotation, 2))
+    if rotValue in (Orientation.NORMAL, Orientation.LEFT, Orientation.RIGHT, Orientation.INVERTED):
+        rot = Orientation(rotValue)
+    else:
+        rot = rotValue
+    freq = 0.0
+    for mode in res.modes:
+        if crtcInfo.mode == mode.id:
+            if mode.h_total != 0 and mode.v_total != 0:
+                freq = round(mode.dot_clock / (mode.h_total * mode.v_total), 2)
+            break
+    depth = screen.root_depth
 
-            if outputInfo.name == monitorName and outputInfo.crtc:
-                crtcInfo = randr.get_crtc_info(display, outputInfo.crtc, res.config_timestamp)
-                is_primary = monitor.primary == 1
-                x, y, w, h = monitor.x, monitor.y, monitor.width_in_pixels, monitor.height_in_pixels
-                # https://askubuntu.com/questions/1124149/how-to-get-taskbar-size-and-position-with-python
-                wa: List[int] = getPropertyValue(getProperty(window=root, prop=Props.Root.WORKAREA, display=display), display=display)
-                wx, wy, wr, wb = wa[0], wa[1], wa[2], wa[3]
-                dpiX, dpiY = round((w * 25.4) / (monitor.width_in_millimeters or 1)), round((h * 25.4) / (monitor.height_in_millimeters or 1))
-                scaleX, scaleY = _scale(monitorName) or (0.0, 0.0)
-                rot = int(math.log(crtcInfo.rotation, 2))
-                freq = 0.0
-                for mode in res.modes:
-                    if crtcInfo.mode == mode.id:
-                        freq = round(mode.dot_clock / ((mode.h_total * mode.v_total) or 1), 2)
-                        break
-                depth = screen.root_depth
-
-                result[outputInfo.name] = {
-                    "system_name": outputInfo.name,
-                    'id': output,
-                    'is_primary': is_primary,
-                    'position': Point(x, y),
-                    'size': Size(w, h),
-                    'workarea': Rect(wx, wy, wr, wb),
-                    'scale': (scaleX, scaleY),
-                    'dpi': (dpiX, dpiY),
-                    'orientation': rot,
-                    'frequency': freq,
-                    'colordepth': depth
-                }
-                break
-    return result
+    return {
+        "system_name": monName,
+        'id': output,
+        'is_primary': is_primary,
+        'position': Point(x, y),
+        'size': Size(w, h),
+        'workarea': Rect(wx, wy, wr, wb),
+        'scale': (scaleX, scaleY),
+        'dpi': (dpiX, dpiY),
+        'orientation': rot,
+        'frequency': freq,
+        'colordepth': depth
+    }
 
 
 def _getMonitorsCount() -> int:
-    count = 0
-    for root in getRoots():
-        count += len(randr.get_monitors(root).monitors)
-    return count
+    return len(_XgetMonitors())
 
 
 def _findMonitor(x: int, y: int) -> List[LinuxMonitor]:
     monitors = []
-    for monitor in _getAllMonitors():
-        if monitor.position is not None and monitor.size is not None:
-            if _pointInBox(x, y, monitor.position.x, monitor.position.y, monitor.size.width, monitor.size.height):
-                monitors.append(monitor)
+    for monitor in _XgetMonitors():
+        if _pointInBox(x, y, monitor.x, monitor.y, monitor.width_in_pixels, monitor.height_in_pixels):
+            monitors.append(LinuxMonitor(monitor.crtcs[0]))
     return monitors
 
 
 def _getPrimary() -> LinuxMonitor:
     return LinuxMonitor()
 
 
-def _arrangeMonitors(arrangement: dict[str, dict[str, Union[str, int, Position, Point, Size]]]):
+def _arrangeMonitors(arrangement: dict[str, dict[str, Optional[Union[str, int, Position, Point, Size]]]]):
 
-    monitors = _XgetAllMonitorsDict()
+    monitors = _XgetMonitorsDict()
     setAsPrimary = ""
-    primaryPresent = False
     for monName in arrangement.keys():
         relPos = arrangement[monName]["relativePos"]
         relMon = arrangement[monName].get("relativeTo", "")
         if (monName not in monitors.keys() or
                 ((isinstance(relPos, Position) or isinstance(relPos, int)) and
                  ((relMon and relMon not in monitors.keys()) or (not relMon and relPos != Position.PRIMARY)))):
             return
-        elif relPos == Position.PRIMARY:
+        elif relPos == Position.PRIMARY or relPos == (0, 0) or relPos == Point(0, 0):
             setAsPrimary = monName
-            primaryPresent = True
-    if not primaryPresent:
-        return
 
     newArrangement: dict[str, dict[str, Union[int, bool]]] = {}
     newPos: dict[str, dict[str, int]] = {}
     xOffset = yOffset = 0
 
+    if setAsPrimary:
+
+        targetMonInfo = monitors[setAsPrimary]["monitor"]
+        newArrangement[setAsPrimary] = {
+            "setPrimary": True,
+            "x": 0,
+            "y": 0,
+            "w": targetMonInfo.width_in_pixels,
+            "h": targetMonInfo.height_in_pixels
+        }
+        newPos[setAsPrimary] = {"x": 0, "y": 0}
+        arrangement.pop(setAsPrimary)
+
     for monName in arrangement.keys():
 
         arrInfo = arrangement[monName]
-        relativePos: Union[Position, Point] = arrInfo["relativePos"]
+        relativePos: Union[Position, int, Point, Tuple[int, int]] = arrInfo["relativePos"]
         targetMonInfo = monitors[monName]["monitor"]
+        setPrimary = not setAsPrimary and targetMonInfo.primary == 1
 
-        if monName == setAsPrimary:
-            setPrimary = True
-            x, y = 0, 0
+        if setPrimary:
 
-        else:
+            x, y = 0, 0
 
-            setPrimary = False
+        elif isinstance(relativePos, Position) or isinstance(relativePos, int):
 
-            if isinstance(relativePos, Position) or isinstance(relativePos, int):
+            relativeTo: str = arrInfo["relativeTo"]
 
-                relativeTo: str = arrInfo["relativeTo"]
+            targetMon = {"relativePos": relativePos, "relativeTo": relativeTo,
+                         "position": Point(targetMonInfo.x, targetMonInfo.y),
+                         "size": Size(targetMonInfo.width_in_pixels, targetMonInfo.height_in_pixels)}
 
-                targetMon = {"relativePos": relativePos, "relativeTo": relativeTo,
-                             "position": Point(targetMonInfo.x, targetMonInfo.y),
-                             "size": Size(targetMonInfo.width_in_pixels, targetMonInfo.height_in_pixels)}
+            relMonInfo = monitors[relativeTo]["monitor"]
+            if relativeTo in newPos.keys():
+                relX, relY = newPos[relativeTo]["x"], newPos[relativeTo]["y"]
+            else:
+                relX, relY = relMonInfo.x, relMonInfo.y
+            relMon = {"position": Point(relX, relY),
+                      "size": Size(relMonInfo.width_in_pixels, relMonInfo.height_in_pixels)}
 
-                relMonInfo = monitors[relativeTo]["monitor"]
-                if relativeTo in newPos.keys():
-                    relX, relY = newPos[relativeTo]["x"], newPos[relativeTo]["y"]
-                else:
-                    relX, relY = relMonInfo.x, relMonInfo.y
-                relMon = {"position": Point(relX, relY),
-                          "size": Size(relMonInfo.width_in_pixels, relMonInfo.height_in_pixels)}
+            x, y = _getRelativePosition(targetMon, relMon)
 
-                x, y = _getRelativePosition(targetMon, relMon)
+        else:
 
-            else:
-                x, y = relativePos
+            x, y = relativePos
 
-            if x < 0:
-                xOffset += abs(x)
-            if y < 0:
-                yOffset += abs(y)
+        if x < 0:
+            xOffset += abs(x)
+        if y < 0:
+            yOffset += abs(y)
         newPos[monName] = {"x": x, "y": y}
-        w, h = targetMonInfo.width_in_pixels, targetMonInfo.height_in_pixels
 
         newArrangement[monName] = {
             "setPrimary": setPrimary,
             "x": x,
             "y": y,
-            "w": w,
-            "h": h
+            "w": targetMonInfo.width_in_pixels,
+            "h": targetMonInfo.height_in_pixels
         }
 
     if newArrangement:
         cmd = _buildCommand(newArrangement, xOffset, yOffset)
-        _ = _runProc(cmd)
+        _, _ = _runProc(cmd)
 
 
 def _getMousePos() -> Point:
     """
     Get the current coordinates (x, y) of the mouse pointer on given monitor, in pixels
 
     :return: Point struct
     """
     mp = defaultEwmhRoot.root.query_pointer()
     return Point(mp.root_x, mp.root_y)
 
 
+_rotations = ["normal", "left", "inverted", "right"]
+
+
 class LinuxMonitor(BaseMonitor):
 
     def __init__(self, handle: Optional[int] = None):
         """
         Class to access all methods and functions to get info and manage monitors plugged to the system.
 
         This class is not meant to be directly instantiated. Instead, use convenience functions like getAllMonitors(),
         getPrimary() or findMonitor(x, y).
 
         It can raise ValueError exception in case provided handle is not valid
         """
         monitorData = _XgetMonitorData(handle)
-        if monitorData is not None:
-            self.display, self.screen, self.root, self.resources, self.handle, self.name = monitorData
+        if monitorData:
+            self.display, self.screen, self.root, _, self.handle, self.name = monitorData
         else:
             raise ValueError
-        self._crtc: dict[str, Union[int, Xlib.ext.randr.GetCrtcInfo]] = {}
 
     @property
     def size(self) -> Optional[Size]:
-        size: Optional[Size] = None
-        for monitorData in _XgetAllMonitors(self.name):
-            display, root, monitor, monName = monitorData
-            size = Size(monitor.width_in_pixels, monitor.height_in_pixels)
-        return size
+        monitors = _XgetMonitors(self.name)
+        if monitors:
+            monitor = monitors[0]
+            return Size(monitor.width_in_pixels, monitor.height_in_pixels)
+        return None
 
     @property
     def workarea(self) -> Optional[Rect]:
-        res: Optional[Rect] = None
         # https://askubuntu.com/questions/1124149/how-to-get-taskbar-size-and-position-with-python
         wa: List[int] = getPropertyValue(
             getProperty(window=self.root, prop=Props.Root.WORKAREA, display=self.display), display=self.display)
         if wa:
             wx, wy, wr, wb = wa[0], wa[1], wa[2], wa[3]
-            res = Rect(wx, wy, wr, wb)
-        return res
+            return Rect(wx, wy, wr, wb)
+        return None
 
     @property
     def position(self) -> Optional[Point]:
-        pos: Optional[Point] = None
-        for monitorData in _XgetAllMonitors(self.name):
-            display, root, monitor, monName = monitorData
-            pos = Point(monitor.x, monitor.y)
-        return pos
+        monitors = _XgetMonitors(self.name)
+        if monitors:
+            monitor = monitors[0]
+            return Point(monitor.x, monitor.y)
+        return None
 
     def setPosition(self, relativePos: Union[int, Position, Point, Tuple[int, int]], relativeTo: Optional[str]):
         # https://askubuntu.com/questions/1193940/setting-monitor-scaling-to-200-with-xrandr
-        _setPosition(relativePos, relativeTo, self.name)
+        arrangement: dict[str, dict[str, Optional[Union[str, int, Position, Point, Size]]]] = {}
+        monitors: dict[str, dict[str, MonitorInfo]] = _XgetMonitorsDict()
+        monKeys = list(monitors.keys())
+        if relativePos == Position.PRIMARY:
+            monitor = monitors[self.name]["monitor"]
+            if monitor.primary == 1:
+                return
+            # For homogeneity, placing PRIMARY at (0, 0) and all the rest to RIGHT_TOP
+            try:
+                index = monKeys.index(self.name)
+                monKeys.pop(index)
+            except:
+                return
+            arrangement[self.name] = {"relativePos": relativePos, "relativeTo": None}
+            xOffset = monitor.width_in_pixels
+            for monName in monKeys:
+                relPos = Point(xOffset, 0)
+                arrangement[monName] = {"relativePos": relPos, "relativeTo": None}
+                xOffset += monitors[monName]["monitor"].width_in_pixels
+
+        else:
+
+            for monName in monitors.keys():
+                if monName == self.name:
+                    relPos = relativePos
+                    relTo = relativeTo
+                else:
+                    monitor = monitors[monName]["monitor"]
+                    relPos = Point(monitor.x, monitor.y)
+                    relTo = None
+                arrangement[monName] = {"relativePos": relPos, "relativeTo": relTo}
+
+        _arrangeMonitors(arrangement)
 
     @property
     def box(self) -> Optional[Box]:
-        box: Optional[Box] = None
-        for monitorData in _XgetAllMonitors(self.name):
-            display, root, monitor, monName = monitorData
-            box = Box(monitor.x, monitor.y, monitor.width_in_pixels, monitor.height_in_pixels)
-            break
-        return box
+        monitors = _XgetMonitors(self.name)
+        if monitors:
+            monitor = monitors[0]
+            return Box(monitor.x, monitor.y, monitor.width_in_pixels, monitor.height_in_pixels)
+        return None
 
     @property
     def rect(self) -> Optional[Rect]:
-        rect: Optional[Rect] = None
-        for monitorData in _XgetAllMonitors(self.name):
-            display, root, monitor, monName = monitorData
-            rect = Rect(monitor.x, monitor.y, monitor.x + monitor.width_in_pixels, monitor.y + monitor.height_in_pixels)
-            break
-        return rect
+        monitors = _XgetMonitors(self.name)
+        if monitors:
+            monitor = monitors[0]
+            return Rect(monitor.x, monitor.y, monitor.x + monitor.width_in_pixels, monitor.y + monitor.height_in_pixels)
+        return None
 
     @property
     def scale(self) -> Optional[Tuple[float, float]]:
         return _scale(self.name)
 
-    def setScale(self, scale: Optional[Tuple[float, float]]):
-        if scale is not None:
-            # https://askubuntu.com/questions/1193940/setting-monitor-scaling-to-200-with-xrandr
-            scaleX, scaleY = round(100 / scale[0], 1), round(100 / scale[1], 1)
-            if 0 < scaleX <= 1 and 0 < scaleY <= 1:
-                cmd = "xrandr --output %s --scale %sx%s --filter nearest" % (self.name, scaleX, scaleY)
-                ret = _runProc(cmd)
-                if not ret:
+    def setScale(self, scale: Optional[Tuple[float, float]], applyGlobally: bool = True):
+        # https://askubuntu.com/questions/1193940/setting-monitor-scaling-to-200-with-xrandr
+        # https://wiki.archlinux.org/title/HiDPI#GNOME
+        cmd = ""
+        if scale is not None and isinstance(scale, tuple):
+            if "gnome" in os.environ.get('XDG_CURRENT_DESKTOP', '').lower():
+                _GNOME_setGlobalScaling(applyGlobally)
+                if applyGlobally:
+                    targetScale = min((1.0, 2.0, 3.0), key=lambda x: abs(x-(scale[0]/100)))
+                    cmd = '''gsettings set org.gnome.settings-daemon.plugins.xsettings overrides "[{'Gdk/WindowScalingFactor', <%s>}]"''' % int(targetScale)
+
+            if not cmd and "wayland" not in os.environ.get('XDG_SESSION_TYPE', '').lower():
+                scaleX, scaleY = round(100 / scale[0], 1), round(100 / scale[1], 1)
+                if 0 < scaleX <= 3 and 0 < scaleY <= 3:
+                    # This is simpler but may lead to blurry results...
                     cmd = "xrandr --output %s --scale %sx%s" % (self.name, scaleX, scaleY)
-                    _ = _runProc(cmd)
+                    # ... try this instead? (must re-calculate monitor positions)
+                    # cmd = self._buildScaleCmd((scaleX, scaleY)
+            if cmd:
+                _, _ = _runProc(cmd)
+
+    def _buildScaleCmd(self, scale: Tuple[float, float]) -> str:
+        # https://unix.stackexchange.com/questions/596887/how-to-scale-the-resolution-display-of-the-desktop-and-or-applications
+        scaleX, scaleY = scale
+        cmd = ""
+        monitors = _getAllMonitorsDict()
+        for monName in monitors.keys():
+            monitor = monitors[monName]
+
+            if monName == self.name:
+                defMode = self.defaultMode
+                if defMode is not None:
+                    width, height = defMode.width, defMode.height
+                    panX, panY = int(width * scaleX), int(height * scaleY)
+                    newScaleX, newScaleY = scaleX, scaleY
+                else:
+                    return ""
+
+            else:
+                mode = monitor["size"]
+                width, height = mode.width, mode.height
+                panX, panY = width, height
+                currScale = monitor["scale"]
+                if currScale is not None:
+                    newScaleX, newScaleY = currScale[0] / 100, currScale[1] / 100
+                else:
+                    newScaleX, newScaleY = 1, 1
+
+            x, y = monitor["position"]
+
+            cmd += (" --output %s --mode %sx%s --panning %sx%s --scale %sx%s --pos %sx%s %s"
+                    % (monName, width, height, panX, panY, newScaleX, newScaleY, x, y,
+                       "--primary" if monitor.get("is_primary", False) else ""))
+        if cmd:
+            cmd = "xrandr" + cmd
+        return cmd
 
     @property
     def dpi(self) -> Optional[Tuple[float, float]]:
-        for monitorData in _XgetAllMonitors(self.name):
-            display, root, monitor, monName = monitorData
+        monitors = _XgetMonitors(self.name)
+        if monitors:
+            monitor = monitors[0]
             x, y, w, h = monitor.x, monitor.y, monitor.width_in_pixels, monitor.height_in_pixels
-            dpiX, dpiY = round((w * 25.4) / monitor.width_in_millimeters), round((h * 25.4) / monitor.height_in_millimeters)
+            if monitor.width_in_millimeters != 0 and monitor.height_in_millimeters != 0:
+                dpiX, dpiY = round((w * 25.4) / monitor.width_in_millimeters), round((h * 25.4) / monitor.height_in_millimeters)
+            else:
+                dpiX, dpiY = 0.0, 0.0
             return dpiX, dpiY
         return None
 
     @property
     def orientation(self) -> Optional[Union[int, Orientation]]:
-        for outputData in _XgetAllOutputs(self.name):
-            display, screen, root, res, output, outputInfo = outputData
-            if outputInfo.crtc:
-                crtcInfo = randr.get_crtc_info(display, outputInfo.crtc, res.config_timestamp)
-                rot = int(math.log(crtcInfo.rotation, 2))
-                return rot
+        monitorData = getMonitorsData(self.handle)
+        if monitorData:
+            display, screen, root, res, monitor, monName, output, outputInfo, crtc, crtcInfo = monitorData[0]
+            orientation = int(math.log(crtcInfo.rotation, 2))
+            if orientation in (Orientation.NORMAL, Orientation.INVERTED, Orientation.LEFT, Orientation.RIGHT):
+                return Orientation(int(math.log(crtcInfo.rotation, 2)))
         return None
 
     def setOrientation(self, orientation: Optional[Union[int, Orientation]]):
-        if orientation in (Orientation.NORMAL, Orientation.INVERTED, Orientation.LEFT, Orientation.RIGHT):
-            # outputs = _XgetAllOutputs(self.name)
-            # for outputData in outputs:
-            #     display, screen, root, res, output, outputInfo = outputData
-            #     crtcInfo = randr.get_crtc_info(display, outputInfo.crtc, res.config_timestamp)
-            #     if crtcInfo and crtcInfo.mode:
-            #         randr.set_crtc_config(display, outputInfo.crtc, Xlib.X.CurrentTime, crtcInfo.x, crtcInfo.y,
-            #                               crtcInfo.mode, (orientation or 1) ** 2, crtcInfo.outputs)
-
-            if orientation == Orientation.RIGHT:
-                direction = "right"
-            elif orientation == Orientation.INVERTED:
-                direction = "inverted"
-            elif orientation == Orientation.LEFT:
-                direction = "left"
-            else:
-                direction = "normal"
+        if orientation is not None and orientation in (Orientation.NORMAL, Orientation.INVERTED, Orientation.LEFT, Orientation.RIGHT):
+            global _rotations
+            direction = _rotations[orientation]
             cmd = "xrandr --output %s --rotate %s" % (self.name, direction)
-            _ = _runProc(cmd)
+            _, _ = _runProc(cmd)
 
     @property
     def frequency(self) -> Optional[float]:
-        outputs = _XgetAllOutputs(self.name)
-        for outputData in outputs:
-            display, screen, root, res, output, outputInfo = outputData
-            crtcInfo = randr.get_crtc_info(display, outputInfo.crtc, res.config_timestamp)
+        monitorData = getMonitorsData(self.handle)
+        if monitorData:
+            display, screen, root, res, monitor, monName, output, outputInfo, crtc, crtcInfo = monitorData[0]
             for mode in res.modes:
                 if crtcInfo.mode == mode.id:
-                    return float(round(mode.dot_clock / ((mode.h_total * mode.v_total) or 1), 2))
+                    if mode.h_total != 0 and mode.v_total != 0:
+                        return float(round(mode.dot_clock / (mode.h_total * mode.v_total), 2))
+                    else:
+                        return 0.0
         return None
     refreshRate = frequency
 
     @property
     def colordepth(self) -> int:
         return int(self.screen.root_depth)
 
     @property
     def brightness(self) -> Optional[int]:
         # https://manerosss.wordpress.com/2017/05/16/brightness-linux-xrandr/
         value = None
-        cmd = "xrandr --verbose | grep %s -A 10 | grep Brightness | grep -o '[0-9].*'" % self.name
-        ret = _runProc(cmd)
+        cmd = 'xrandr --verbose | grep %s -A 10 | grep "Brightness" | grep -o "[0-9].*"' % self.name
+        code, ret = _runProc(cmd)
         if ret:
-            value = int(float(ret)) * 100
+            try:
+                value = int(float(ret) * 100)
+            except:
+                pass
         return value
 
-        # Pointers to misc solutions
-        #     # https://stackoverflow.com/questions/16402672/control-screen-with-python
-        #     if int(brightness) > 15:
-        #         raise TypeError("Need int 0 < and > 15")
-        #     elif int(brightness) < 0:
-        #         raise TypeError("Need int 0 < and > 15")
-        #     with open("/sys/devices/pci0000:00/0000:00:02.0/backlight/acpi_video0/brightness", "w") as bright:
-        #         bright.write(str(brightness))
-        #         bright.close()
-        #
-        #     # https://github.com/arjun024/turn-off-screen/blob/master/platform-specific/turnoff_win8.1.py
-        #     os.system("xset dpms force off")
-        #
-        #     # https://stackoverflow.com/questions/47026351/change-backlight-brightness-in-linux-with-python
-        #     os.system('gdbus call --session '
-        #               '--dest org.gnome.SettingsDaemon.Power '
-        #               '--object-path /org/gnome/SettingsDaemon/Power '
-        #               '--method org.freedesktop.DBus.Properties.Set org.gnome.SettingsDaemon.Power.Screen '
-        #               'Brightness "<int32 %s>"' % str(brightness))
-        #     os.system('gdbus call --session '
-        #               '--dest org.gnome.SettingsDaemon.Power '
-        #               '--object-path /org/gnome/SettingsDaemon/Power '
-        #               '--method org.freedesktop.DBus.Properties.Get org.gnome.SettingsDaemon.Power.Screen '
-        #               'Brightness')
-
     def setBrightness(self, brightness: Optional[int]):
-        if brightness is not None:
+        if brightness is not None and 0 <= brightness <= 100:
             value = brightness / 100
             if 0 <= value <= 1:
                 cmd = "xrandr --output %s --brightness %s" % (self.name, str(value))
-                _ = _runProc(cmd)
+                _, _ = _runProc(cmd)
 
     @property
     def contrast(self) -> Optional[int]:
         value = None
-        cmd = "xrandr --verbose | grep %s -A 10 | grep Gamma | grep -o '[0-9].*'" % self.name
-        ret = _runProc(cmd)
+        cmd = 'xrandr --verbose | grep %s -A 10 | grep "Gamma" | grep -o "[0-9].*"' % self.name
+        code, ret = _runProc(cmd)
         if ret:
-            r, g, b = ret.split(":")
-            value = int(((1 / (float(r) or 1)) + (1 / (float(g) or 1)) + (1 / (float(b) or 1))) / 3) * 100
+            try:
+                r, g, b = ret.split(":")
+                value = int((((1 / (float(r) or 1)) + (1 / (float(g) or 1)) + (1 / (float(b) or 1))) / 3) * 100)
+            except:
+                pass
         return value
 
     def setContrast(self, contrast: Optional[int]):
-        if contrast is not None:
+        if contrast is not None and 0<= contrast <= 100:
             value = contrast / 100
             if 0 <= value <= 1:
                 rgb = str(round(value, 1))
                 gamma = rgb + ":" + rgb + ":" + rgb
                 cmd = "xrandr --output %s --gamma %s" % (self.name, gamma)
-                _ = _runProc(cmd)
+                _, _ = _runProc(cmd)
 
     @property
     def mode(self) -> Optional[DisplayMode]:
-        for crtcData in _XgetAllCrtcs(self.name):
-            display, screen, root, res, output, outputInfo, crtc, crtcInfo = crtcData
-            if self.handle == output:
-                if outputInfo.crtc == crtc:
-                    mode = crtcInfo.mode
-                    for resMode in res.modes:
-                        if resMode.id == mode:
-                            retMode = DisplayMode(resMode.width, resMode.height,
-                                                round(resMode.dot_clock / ((resMode.h_total * resMode.v_total) or 1), 2))
-                            return retMode
+        monitorData = getMonitorsData(self.handle)
+        if monitorData:
+            display, screen, root, res, monitor, monName, output, outputInfo, crtc, crtcInfo = monitorData[0]
+            for resMode in res.modes:
+                if resMode.id == crtcInfo.mode:
+                    if resMode.h_total != 0 and resMode.v_total != 0:
+                        freq = round(resMode.dot_clock / (resMode.h_total * resMode.v_total), 2)
+                    else:
+                        freq = 0.0
+                    return DisplayMode(resMode.width, resMode.height, freq)
         return None
 
     def setMode(self, mode: Optional[DisplayMode]):
         # https://stackoverflow.com/questions/12706631/x11-change-resolution-and-make-window-fullscreen
-        # Xlib.ext.randr.set_screen_size(defaultEwmhRoot.root, mode.width, mode.height, 0, 0)
-        # Xlib.ext.randr.set_screen_config(defaultEwmhRoot.root, size_id, 0, 0, round(mode.frequency), 0)
-        # Xlib.ext.randr.change_output_property()
-        if mode is not None:
-            cmd = "xrandr --output %s --mode %sx%s -r %s" % (self.name, mode.width, mode.height, round(mode.frequency, 2))
-            _ = _runProc(cmd)
+        # randr.set_screen_size(defaultEwmhRoot.root, mode.width, mode.height, 0, 0)
+        # randr.set_screen_config(defaultEwmhRoot.root, size_id, 0, 0, round(mode.frequency), 0)
+        # randr.change_output_property()
+        if mode:
+            cmd = "xrandr --output %s --mode %sx%s -r %s" % (self.name, mode.width, mode.height, mode.frequency)
+            _, _ = _runProc(cmd)
 
     @property
     def defaultMode(self) -> Optional[DisplayMode]:
-        for outputData in _XgetAllOutputs(self.name):
-            display, screen, root, res, output, outputInfo = outputData
-            if self.handle == output:
-                for outMode in outputInfo.modes:
-                    for resMode in res.modes:
-                        if outMode == resMode.id:
-                            return DisplayMode(resMode.width, resMode.height,
-                                               round(resMode.dot_clock / ((resMode.h_total * resMode.v_total) or 1), 2))
-                break
+        # Assuming first mode is default (perhaps not the best way)
+        monitorData = getMonitorsData(self.handle)
+        if monitorData:
+            display, screen, root, res, monitor, monName, output, outputInfo, crtc, crtcInfo = monitorData[0]
+            outMode = outputInfo.modes[0]
+            for resMode in res.modes:
+                if outMode == resMode.id:
+                    if resMode.h_total != 0 and resMode.v_total != 0:
+                        freq = round(resMode.dot_clock / (resMode.h_total * resMode.v_total), 2)
+                    else:
+                        freq = 0.0
+                    return DisplayMode(resMode.width, resMode.height, freq)
         return None
 
     def setDefaultMode(self):
         cmd = "xrandr --output %s --auto" % self.name
-        _ = _runProc(cmd)
+        _, _ = _runProc(cmd)
 
     @property
     def allModes(self) -> list[DisplayMode]:
         modes: List[DisplayMode] = []
-        for outputData in _XgetAllOutputs(self.name):
-            display, screen, root, res, output, outputInfo = outputData
-            if self.handle == output:
-                for outMode in outputInfo.modes:
-                    for resMode in res.modes:
-                        if outMode == resMode.id:
-                            modes.append(DisplayMode(resMode.width, resMode.height,
-                                                     round(resMode.dot_clock / ((resMode.h_total * resMode.v_total) or 1), 2)))
-                break
+        monitorData = getMonitorsData(self.handle)
+        if monitorData:
+            display, screen, root, res, monitor, monName, output, outputInfo, crtc, crtcInfo = monitorData[0]
+            outputModes = outputInfo.modes
+            for resMode in res.modes:
+                if resMode.id in outputModes:
+                    if resMode.h_total != 0 and resMode.v_total != 0:
+                        freq = round(resMode.dot_clock / (resMode.h_total * resMode.v_total), 2)
+                    else:
+                        freq = 0.0
+                    modes.append(DisplayMode(resMode.width, resMode.height, freq))
         return modes
 
     @property
     def isPrimary(self) -> bool:
-        for monitorData in _XgetAllMonitors(self.name):
-            display, root, monitor, monName = monitorData
-            return bool(monitor.primary == 1)
+        if isWatchdogEnabled():
+            monitorData = getMonitorsData(self.handle)
+            if monitorData:
+                display, screen, root, res, monitor, monName, output, outputInfo, crtc, crtcInfo = monitorData[0]
+                return bool(monitor.primary == 1)
+        else:
+            ret = randr.get_output_primary(self.root)
+            if ret and hasattr(ret, "output"):
+                return bool(ret.output == self.handle)
         return False
 
     def setPrimary(self):
-        _setPrimary(self.name)
+        # https://smithay.github.io/smithay////x11rb/protocol/randr/fn.set_monitor.html
+        if not self.isPrimary:
+            cmd = "xrandr --output %s --primary" % self.name
+            _, _ = _runProc(cmd)
 
     def turnOn(self):
-        cmd = ""
         if self.isSuspended:
             cmd = "xset dpms force on"
-        elif not self.isOn:
+            _, _ = _runProc(cmd)
+        if not self.isOn:
+            targetX = 0
+            targetName = ""
+            for monitor in _XgetMonitors():
+                if self.name != monitor.name and targetX <= monitor.x + monitor.width_in_pixels:
+                    targetX = monitor.x + monitor.width_in_pixels
+                    targetName = monitor.name
             cmdPart = ""
-            relativeTo = self.name
-            for monName in _XgetAllMonitorsNames():
-                if monName != self.name:
-                    cmdPart += " --output %s --left-of %s" % (monName, relativeTo)
-                    relativeTo = monName
+            if targetName:
+                cmdPart = " --right-of %s" % targetName
             cmd = str("xrandr --output %s --auto" % self.name) + cmdPart
-        if cmd:
-            _ = _runProc(cmd)
-
+            _, _ = _runProc(cmd)
 
     def turnOff(self):
         if self.isOn:
             cmd = "xrandr --output %s --off" % self.name
-            _ = _runProc(cmd)
+            _, _ = _runProc(cmd)
 
     @property
     def isOn(self) -> Optional[bool]:
         # https://stackoverflow.com/questions/3433203/how-to-determine-if-lcd-monitor-is-turned-on-from-linux-command-line
         cmd = "xrandr --listactivemonitors"
+        code, ret = _runProc(cmd)
         res: Optional[bool] = None
-        ret = _runProc(cmd)
         if ret:
             res = self.name in ret
         isSuspended = self.isSuspended
         return (res and not isSuspended) if isSuspended is not None else res
 
     def suspend(self):
         # xrandr has no standby option. xset doesn't allow to target just one output (it works at display level)
-        cmd = "xset dpms force standby"
-        _ = _runProc(cmd)
+        if not self.isSuspended:
+            cmd = "xset dpms force standby"
+            _, _ = _runProc(cmd)
 
     @property
     def isSuspended(self) -> Optional[bool]:
-        cmd = "xset -q | grep ' Monitor is '"
-        ret = _runProc(cmd)
+        cmd = 'xset -q | grep " Monitor is "'
+        code, ret = _runProc(cmd)
         if ret:
             return bool("Standby" in ret)
         return None
 
     def attach(self):
-        # This produces the same effect, but requires to keep track of last mode used
-        if self._crtc:
-            crtc: int = self._crtc["crtc"]
-            crtcInfo: Xlib.ext.randr.GetCrtcInfo = self._crtc["crtc_info"]
-            randr.set_crtc_config(self.display, crtc, Xlib.X.CurrentTime, crtcInfo.x, crtcInfo.y, crtcInfo.mode, crtcInfo.rotation, crtcInfo.outputs)
-            self._crtc = {}
-            cmdPart = ""
-            relativeTo = self.name
-            for monName in _XgetAllMonitorsNames():
-                if monName != self.name:
-                    cmdPart += " --output %s --left-of %s" % (monName, relativeTo)
-                    relativeTo = monName
-            cmd = str("xrandr --output %s --auto" % self.name) + cmdPart
-            _ = _runProc(cmd)
-
+        # This produces the same effect that re-attaching a monitor, but will reset monitor to default mode
+        targetX = 0
+        targetName = ""
+        for monitor in _XgetMonitors():
+            if self.name != monitor.name and targetX <= monitor.x + monitor.width_in_pixels:
+                targetX = monitor.x + monitor.width_in_pixels
+                targetName = monitor.name
+        cmdPart = ""
+        if targetName:
+            cmdPart = " --right-of %s" % targetName
+        cmd = str("xrandr --output %s --auto" % self.name) + cmdPart
+        _, _ = _runProc(cmd)
 
     def detach(self, permanent: bool = False):
-        # This produces the same effect, but requires to keep track of last mode used
-        outputs = _XgetAllOutputs(self.name)
-        for outputData in outputs:
-            display, screen, root, res, output, outputInfo = outputData
-            if outputInfo.crtc:
-                crtcInfo: Xlib.ext.randr.GetCrtcInfo = randr.get_crtc_info(display, outputInfo.crtc, Xlib.X.CurrentTime)
-                randr.set_crtc_config(display, outputInfo.crtc, Xlib.X.CurrentTime, crtcInfo.x, crtcInfo.y, 0, crtcInfo.rotation, [])
-                self._crtc = {"crtc": outputInfo.crtc, "crtc_info": crtcInfo}
+        # Setting mode to 0 produces the same effect that detaching a monitor.
+        monitorData = getMonitorsData(self.handle)
+        if monitorData:
+            display, screen, root, res, monitor, monName, output, outputInfo, crtc, crtcInfo = monitorData[0]
+            try:
+                # randr.set_crtc_config() fails in Cinnamon
+                randr.set_crtc_config(self.display, crtc, Xlib.X.CurrentTime, crtcInfo.x, crtcInfo.y, 0, crtcInfo.rotation, [])
+            except:
+                cmd = "xrandr --output %s --mode %sx%s" % (self.name, 0, 0)
+                _, _ = _runProc(cmd)
 
     @property
     def isAttached(self) -> bool:
-        outputs = _XgetAllOutputs(self.name)
-        for outputData in outputs:
-            display, screen, root, res, output, outputInfo = outputData
-            if outputInfo.crtc:
-                crtcInfo = randr.get_crtc_info(display, outputInfo.crtc, Xlib.X.CurrentTime)
-                if crtcInfo.mode != 0:
-                    return True
-                break
-        return False
-
-
-def _setPrimary(name: str):
-    cmd = "xrandr --output %s --primary" % name
-    _ = _runProc(cmd)
-
-
-def _getPosition(name):
-    pos: Optional[Point] = None
-    for monitorData in _XgetAllMonitors(name):
-        display, root, monitor, monName = monitorData
-        pos = Point(monitor.x, monitor.y)
-    return pos
-
-
-def _setPosition(relativePos: Union[int, Position, Point, Tuple[int, int]], relativeTo: Optional[str], name: str):
-    if relativePos == Position.PRIMARY:
-        _setPrimary(name)
-
-    else:
-        monitors = _XgetAllMonitorsDict()
-        monitorsKeys = list(monitors.keys())
-        arrangement: dict[str, dict[str, Union[int, bool]]] = {}
-        xOffset = yOffset = 0
-
-        if (name not in monitorsKeys or
-                ((isinstance(relativePos, Position) or isinstance(relativePos, int)) and
-                 (not relativeTo or (relativeTo and relativeTo not in monitors.keys())))):
-            return
-
-        newPos: dict[str, dict[str, int]] = {}
-        for monitor in monitorsKeys:
-
-            targetMonInfo = monitors[monitor]["monitor"]
-            w, h = targetMonInfo.width_in_pixels, targetMonInfo.height_in_pixels
-            setPrimary = targetMonInfo.primary == 1
-
-            if name == monitor:
-
-                if isinstance(relativePos, Position) or isinstance(relativePos, int):
-                    targetMon = {"relativePos": relativePos, "relativeTo": relativeTo,
-                                 "position": Point(targetMonInfo.x, targetMonInfo.y),
-                                 "size": Size(targetMonInfo.width_in_pixels, targetMonInfo.height_in_pixels)}
-
-                    relMonInfo = monitors[relativeTo]["monitor"]
-                    if relativeTo in newPos.keys():
-                        x, y = newPos[relativeTo]["x"], newPos[relativeTo]["y"]
-                    else:
-                        x, y = relMonInfo.x, relMonInfo.y
-                    relMon = {"position": Point(x, y),
-                              "size": Size(relMonInfo.width_in_pixels, relMonInfo.height_in_pixels)}
-
-                    x, y = _getRelativePosition(targetMon, relMon)
-
-                else:
-                    x, y = relativePos
-
-                newPos[monitor] = {"x": x, "y": y, "w": w, "h": h}
-
-            else:
-                x, y = targetMonInfo.x, targetMonInfo.y
-                setPrimary = targetMonInfo.primary == 1
-            if x < 0:
-                xOffset += abs(x)
-            if y < 0:
-                yOffset += abs(y)
-
-            arrangement[monitor] = {
-                "setPrimary": setPrimary,
-                "x": x,
-                "y": y,
-                "w": w,
-                "h": h
-            }
-        if arrangement:
-            cmd = _buildCommand(arrangement, xOffset, yOffset)
-            _ = _runProc(cmd)
+        monitor = _XgetMonitors(self.name)
+        return bool(monitor)
 
 
 def _buildCommand(arrangement: dict[str, dict[str, Union[int, bool]]], xOffset: int, yOffset: int):
     cmd = "xrandr"
     for monName in arrangement.keys():
         arrInfo = arrangement[monName]
         cmd += " --output %s" % monName
@@ -621,149 +627,384 @@
         cmd += " --pos %sx%s" % (str(int(arrInfo["x"]) + xOffset), str(int(arrInfo["y"]) + yOffset))
         cmd += " --mode %sx%s" % (arrInfo["w"], arrInfo["h"])
         if arrInfo["setPrimary"]:
             cmd += " --primary"
     return cmd
 
 
-def _scale(name: str = "") -> Optional[Tuple[float, float]]:
-    value = None
-    cmd = "xrandr -q | grep %s -A 5 | grep ' +\\|*+'" % name
-    ret = _runProc(cmd)
-    if ret:
+def _GNOME_isScalingGlobal() -> Optional[bool]:
+    cmd = '''gsettings get org.gnome.mutter experimental-features'''
+    try:
+        proc = subprocess.run(cmd, text=True, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
+        if "wayland" in os.environ.get('XDG_SESSION_TYPE', '').lower():
+            return bool("scale-monitor-framebuffer" not in proc.stdout)
+        else:
+            return bool("x11-randr-fractional-scaling" not in proc.stdout)
+    except:
+        pass
+    return None
+
+
+def _GNOME_setGlobalScaling(setGlobal=True):
+    if setGlobal:
+        cmd = '''gsettings set org.gnome.mutter experimental-features "[]"'''
+        _, _ = _runProc(cmd)
+    else:
+        cmd = ""
+        if "wayland" in os.environ.get('XDG_SESSION_TYPE', '').lower():
+            try:
+                proc = subprocess.run("grep -sl mutter /proc/*/maps", text=True, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
+                if "/maps" in proc.stdout:
+                    cmd = '''gsettings set org.gnome.mutter experimental-features "['scale-monitor-framebuffer']"'''
+            except:
+                pass
+        else:
+            cmd = '''gsettings set org.gnome.mutter experimental-features "['x11-randr-fractional-scaling']"'''
+        if cmd:
+            _, _ = _runProc(cmd)
+  
+                    
+def _GNOME_getScalingFactor() -> Optional[int]:
+    cmd = '''gsettings get org.gnome.settings-daemon.plugins.xsettings overrides'''
+    code, ret = _runProc(cmd)
+    if "WindowScalingFactor" in ret:
         try:
-            res = ret.split(" ")
-            lines: List[str] = list(filter(None, res))
-            a, b = lines[0].split("x")
-            w = int(a)
-            h = int(b)
-            r = float(lines[1].replace("+", "").replace("*", ""))
-            value = DisplayMode(w, h, r)
+            return int(ret.split("WindowScalingFactor': <")[1][0])
         except:
             pass
-    if value:
-        for monitorData in _XgetAllMonitors(name):
-            display, root, monitor, monName = monitorData
-            w, h = monitor.width_in_pixels, monitor.height_in_pixels
-            wm, hm = monitor.width_in_millimeters, monitor.height_in_millimeters
-            if wm and hm:
-                wDef, hDef = value.width, value.height
-                dpiXDef, dpiYDef = round((wDef * 25.4) / wm), round((hDef * 25.4) / hm)
-                dpiX, dpiY = round((w * 25.4) / wm), round((h * 25.4) / hm)
-                if dpiX and dpiY and dpiXDef and dpiYDef:
-                    scaleX, scaleY = (100 / (dpiX / dpiXDef), 100 / (dpiY / dpiYDef))
-                    return scaleX, scaleY
     return None
 
 
-def _XgetAllOutputs(name: str = ""):
-    outputs = []
-    for rootData in getRootsInfo(forceUpdate=True):
-        display, screen, root, res = rootData
-        if res:
-            for output in res.outputs:
-                try:
-                    outputInfo = randr.get_output_info(display, output, res.config_timestamp)
-                    if not name or (name and name == outputInfo.name):
-                        outputs.append([display, screen, root, res, output, outputInfo])
-                except:
-                    pass
-    return outputs
+# def _MUTTER_getMonitorsInfo() -> Tuple[dict[str, dict], dict[str, dict], dict[str, dict]]:
+#     # https://askubuntu.com/questions/1035718/how-change-display-scale-from-the-command-line-in-ubuntu-18-04-xorg
+#     # https://github.com/jadahl/gnome-monitor-config/blob/master/src/org.gnome.Mutter.DisplayConfig.xml
+#     # https://askubuntu.com/questions/253910/does-kwin-have-a-d-bus-api
+#     # https://blog.fpmurphy.com/2012/02/d-bus-cinnamon-and-the-gnome-shell.html
+#     # https://bbs.archlinux.org/viewtopic.php?id=278808
+#
+#     #     # https://stackoverflow.com/questions/47026351/change-backlight-brightness-in-linux-with-python
+#     #     os.system('gdbus call --session '
+#     #               '--dest org.gnome.SettingsDaemon.Power '
+#     #               '--object-path /org/gnome/SettingsDaemon/Power '
+#     #               '--method org.freedesktop.DBus.Properties.Set org.gnome.SettingsDaemon.Power.Screen '
+#     #               'Brightness "<int32 %s>"' % str(brightness))
+#     #     os.system('gdbus call --session '
+#     #               '--dest org.gnome.SettingsDaemon.Power '
+#     #               '--object-path /org/gnome/SettingsDaemon/Power '
+#     #               '--method org.freedesktop.DBus.Properties.Get org.gnome.SettingsDaemon.Power.Screen '
+#     #               'Brightness')
+#
+#     try:
+#         import dbus
+#     except:
+#         return {}, {}, {}
+#
+#     namespace = "org.gnome.Mutter.DisplayConfig"
+#     dbus_path = "/org/gnome/Mutter/DisplayConfig"
+#
+#     session_bus = dbus.SessionBus()
+#     obj = session_bus.get_object(namespace, dbus_path)
+#     interface = dbus.Interface(obj, dbus_interface=namespace)
+#
+#     serial, connected_monitors, logical_monitors, general_config = interface.GetCurrentState()
+#
+#     connectedInfo = {}
+#     for monitor in connected_monitors:
+#         monName = monitor[0][0]
+#         current_mode = {}
+#         default_mode = {}
+#         availableModes = {}
+#         scale = None
+#         availableScales = []
+#         for mode in monitor[1]:
+#             modeName, width, height, freq, scale, scales = mode[:6]
+#             availableModes[str(modeName)] = {"width": int(width), "height": int(height), "frequency": float(freq)}
+#             if len(mode) >= 7:
+#                 if mode[6].get("is-current", 0):
+#                     current_mode = {"name": str(modeName), "width": int(width), "height": int(height), "frequency": float(freq)}
+#                     availableScales = [float(value) for value in scales]
+#                 if mode[6].get("is-preferred", 0):
+#                     default_mode = {"name": str(modeName), "width": int(width), "height": int(height), "frequency": float(freq)}
+#         connectedInfo[str(monName)] = {"current_mode": current_mode, "default_mode": default_mode,
+#                                        "available_modes": availableModes, "scale": float(scale), "available_scales": availableScales}
+#     logicalInfo = {}
+#     for monIndex, logMon in enumerate(logical_monitors):
+#         x, y, scale, transform, primary, monitors, props = logMon
+#         monsNames = [str(name) for name in monitors[0] if name and name != 'unknown']
+#         logicalInfo[str(monIndex)] = {"position": Point(int(x), int(y)), "scale": float(scale), "transform": int(transform),
+#                                       "is_primary": int(primary), "props": dict(props), "monitors": monsNames}
+#     return connectedInfo, logicalInfo, dict(general_config)
+#
+#
+# def _MUTTER_setMonitorConfig(name: str, x: int, y: int, scale: float, transform: int, primary: bool, modeName: str, monInfo: dict[str, dict]):
+#     # https://askubuntu.com/questions/1035718/how-change-display-scale-from-the-command-line-in-ubuntu-18-04-xorg
+#     # Just a test. Not properly working at all!!!
+#
+#     try:
+#         import dbus
+#     except:
+#         return
+#
+#     namespace = "org.gnome.Mutter.DisplayConfig"
+#     dbus_path = "/org/gnome/Mutter/DisplayConfig"
+#
+#     session_bus = dbus.SessionBus()
+#     obj = session_bus.get_object(namespace, dbus_path)
+#     interface = dbus.Interface(obj, dbus_interface=namespace)
+#
+#     # ApplyMonitorsConfig() needs (connector name, mode ID) for each connected
+#     # monitor of a logical monitor, but GetCurrentState() only returns the
+#     # connector name for each connected monitor of a logical monitor. So iterate
+#     # through the globally connected monitors to find the mode ID.
+#     serial, connected_monitors, logical_monitors, general_config = interface.GetCurrentState()
+#
+#     # If someday updating this script: a logical monitor may appear on multiple
+#     # connected monitors due to mirroring.
+#     monConfig = []
+#     for logMon in logical_monitors:
+#         x, y, scale, transform, primary, monitors, props = logMon
+#         monsNames = [str(name) for name in monitors[0]]
+#         for info in monInfo:
+#             monName, modeName, _ = info
+#             if monName in monsNames:
+#                 monConfig.append([x, y, scale, transform, primary, info])
+#                 break
+#
+#     # Change the 1 to a 2 if you want a "Revert Settings / Keep Changes" dialog
+#     interface.ApplyMonitorsConfig(serial, 1, monConfig, {})
+
+
+def _scale(name: str) -> Optional[Tuple[float, float]]:
+    if "gnome" in os.environ.get('XDG_CURRENT_DESKTOP', '').lower() and _GNOME_isScalingGlobal():
+        value = _GNOME_getScalingFactor()
+        if value is not None:
+            scaleX, scaleY = value * 100.0, value * 100.0
+            return scaleX, scaleY
 
+    if "wayland" not in os.environ.get('XDG_SESSION_TYPE', '').lower():
+        value = None
+        cmd = 'xrandr -q | grep %s -A 5 | grep " +\\|*+"' % name
+        code, ret = _runProc(cmd)
+        if ret:
+            try:
+                res = ret.split(" ")
+                lines: List[str] = list(filter(None, res))
+                a, b = lines[0].split("x")
+                w = int(a)
+                h = int(b)
+                r = float(lines[1].replace("+", "").replace("*", ""))
+                value = DisplayMode(w, h, r)
+            except:
+                pass
+        if value:
+            monitors = _XgetMonitors(name)
+            if monitors:
+                monitor = monitors[0]
+                w, h = monitor.width_in_pixels, monitor.height_in_pixels
+                wm, hm = monitor.width_in_millimeters, monitor.height_in_millimeters
+                if wm and hm:
+                    wDef, hDef = value.width, value.height
+                    dpiXDef, dpiYDef = round((wDef * 25.4) / wm), round((hDef * 25.4) / hm)
+                    dpiX, dpiY = round((w * 25.4) / wm), round((h * 25.4) / hm)
+                    if dpiX and dpiY and dpiXDef and dpiYDef:
+                        scaleX, scaleY = (100 / (dpiX / dpiXDef), 100 / (dpiY / dpiYDef))
+                        return scaleX, scaleY
+    return None
 
-def _XgetAllCrtcs(name: str = ""):
-    crtcs = []
-    outputs = _XgetAllOutputs(name)
-    for outputData in outputs:
-        display, screen, root, res, output, outputInfo = outputData
-        if not name or (name and name == outputInfo.name):
-            for crtc in outputInfo.crtcs:
-                try:
-                    crtcInfo = randr.get_crtc_info(display, crtc, res.config_timestamp)
-                    crtcs.append([display, screen, root, res, output, outputInfo, crtc, crtcInfo])
-                except:
-                    pass
-            if name:
-                return crtcs
-    return crtcs
+
+def _runProc(cmd: str):
+    try:
+        # Some commands will take some time to be executed and return required value
+        proc = subprocess.run(cmd, text=True, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) #, timeout=3)
+        return proc.returncode, proc.stdout
+    except:
+        pass
+    return -1, ""
+
+
+class _Monitor(NamedTuple):
+    name: str
+    primary: int
+    x: int
+    y: int
+    width_in_pixels: int
+    height_in_pixels: int
+    width_in_millimeters: int
+    height_in_millimeters: int
+    crtcs: List[int]
+
+
+def _getMonitorsData(handle: Optional[int] = None) -> (
+                        List[Tuple[Xlib.display.Display, Struct, XWindow, GetScreenResourcesCurrent,
+                        MonitorInfo, str, int, GetOutputInfo, int, GetCrtcInfo]]):
+    monitors: List[Tuple[Xlib.display.Display, Struct, XWindow, GetScreenResourcesCurrent,
+                         MonitorInfo, str, int, GetOutputInfo, int, GetCrtcInfo]] = []
+    stopSearching = False
+    roots: List[Tuple[Xlib.display.Display, Struct, XWindow]] = getRoots()
+    for rootData in roots:
+        display, screen, root = rootData
+        try:
+            mons = randr.get_monitors(root).monitors
+        except:
+            # In Cinnamon randr extension has no get_monitors() method (?!?!?!?)
+            mons = _RgetAllMonitors()
+            stopSearching = True
+        for monitor in mons:
+            if isinstance(monitor.name, int):
+                monitor.name = display.get_atom_name(monitor.name)
+            res = randr.get_screen_resources_current(root)
+            output = monitor.crtcs[0]
+            outputInfo = randr.get_output_info(display, output, res.config_timestamp)
+            if outputInfo.crtc:
+                if handle:
+                    if handle == output:
+                        crtcInfo = randr.get_crtc_info(display, outputInfo.crtc, res.config_timestamp)
+                        return [(display, screen, root, res, monitor, monitor.name, output, outputInfo, outputInfo.crtc, crtcInfo)]
+                else:
+                    crtcInfo = randr.get_crtc_info(display, outputInfo.crtc, res.config_timestamp)
+                    monitors.append((display, screen, root, res, monitor, monitor.name, output, outputInfo, outputInfo.crtc, crtcInfo))
+        if stopSearching:
+            break
+    return monitors
 
 
 def _XgetAllMonitors(name: str = ""):
     monitors = []
-    for rootData in getRootsInfo():
-        display, screen, root, res = rootData
-        for monitor in randr.get_monitors(root).monitors:
-            monName = display.get_atom_name(monitor.name)
-            if not name or (name and name == monName):
-                monitors.append([display, root, monitor, monName])
+    if isWatchdogEnabled():
+        for monitorData in getMonitorsData():
+            display, screen, root, res, monitor, monName, output, outputInfo, crtc, crtcInfo = monitorData
+            if name:
+                if name and name == monName:
+                    return [(display, screen, root, monitor, monName)]
+            else:
+                monitors.append((display, screen, root, monitor, monName))
+    else:
+        stopSearching = False
+        roots: List[Tuple[Xlib.display.Display, Struct, XWindow]] = getRoots()
+        for rootData in roots:
+            display, screen, root = rootData
+            try:
+                mons = randr.get_monitors(root).monitors
+            except:
+                # In Cinnamon randr extension has no get_monitors() method (?!?!?!?)
+                mons = _RgetAllMonitors()
+                stopSearching = True
+            for monitor in mons:
+                if isinstance(monitor.name, int):
+                    monitor.name = display.get_atom_name(monitor.name)
                 if name:
-                    return monitors
+                    if name == monitor.name:
+                        return [(display, screen, root, monitor, monitor.name)]
+                else:
+                    monitors.append((display, screen, root, monitor, monitor.name))
+            if stopSearching:
+                break
     return monitors
 
 
-def _XgetAllMonitorsDict():
-    monitors = {}
-    for rootData in getRootsInfo():
-        display, screen, root, res = rootData
-        for monitor in randr.get_monitors(root).monitors:
-            monitors[display.get_atom_name(monitor.name)] = {"display": display, "root": root, "monitor": monitor}
+def _RgetAllMonitors():
+    # Check if this works in actual Cinnamon
+    monitors: List[_Monitor] = []
+    outputDict = {}
+    for outputData in _XgetAllOutputs():
+        display, screen, root, output, outputInfo = outputData
+        outputDict[outputInfo.name] = {"outputData": outputData}
+
+    namesData = _RgetMonitorsInfo()
+    for item in namesData:
+        monName, primary, x, y, w, h = item
+        if monName in outputDict.keys():
+            display, screen, root, output, outputInfo = outputDict[monName]["outputData"]
+            wm, hm = outputInfo.mm_width, outputInfo.mm_height
+            crtcs = [output]
+            monitors.append(_Monitor(monName, primary, x, y, w, h, wm, hm, crtcs))
     return monitors
 
 
-def _XgetAllMonitorsNames():
-    monNames = []
-    for rootData in getRootsInfo():
-        display, screen, root, res = rootData
-        for monitor in randr.get_monitors(root).monitors:
-            monNames.append(display.get_atom_name(monitor.name))
-    return monNames
+def _RgetMonitorsInfo(activeOnly: bool = True):
+    monInfo = []
+    cmd = "xrandr -q | grep %s" % ("' connected '" if activeOnly else "'connected '")
+    code, ret = _runProc(cmd)
+    if ret:
+        try:
+            lines = ret.split("\n")[:-1]
+            for line in lines:
+                items = line.split(" ")
+                name = items[0]
+                if name:
+                    primary = 1 if "primary" in items[2] else 0
+                    info = items[2 + primary]
+                    if "x" in info and "+" in info:
+                        parts = info.split("+")
+                        x = parts[1]
+                        y = parts[2]
+                        w, h = parts[0].split("x")
+                        monInfo.append((name, primary, int(x), int(y), int(w), int(h)))
+        except:
+            pass
+    return monInfo
 
 
-def _XgetPrimary():
-    outputs = _XgetAllOutputs()
-    for monitorData in _XgetAllMonitors():
-        display, root, monitor, monName = monitorData
-        if monitor.primary == 1:
-            for outputData in outputs:
-                display, screen, root, res, output, outputInfo = outputData
-                if outputInfo.name == monName:
-                    handle = output
-                    return handle, monName
-    return None
+def _XgetAllOutputs(name: str = ""):
+    outputs: List[Tuple[Xlib.display.Display, Xlib.protocol.rq.Struct, Xlib.xobject.drawable.Window,
+                        int, GetOutputInfo]] = []
+    roots: List[Tuple[Xlib.display.Display, Struct, XWindow]] = getRoots()
+    for rootData in roots:
+        display, screen, root = rootData
+        res = randr.get_screen_resources_current(root)
+        for output in res.outputs:
+            outputInfo = randr.get_output_info(display, output, res.config_timestamp)
+            if os.environ.get('DESKTOP_SESSION', "").lower() == "cinnamon" and outputInfo.name.startswith("ual"):
+                outputInfo.name = _fixCinnamonName(outputInfo.name)
+            if name:
+                if name == outputInfo.name and outputInfo.crtc:
+                    return [(display, screen, root, output, outputInfo)]
+            else:
+                outputs.append((display, screen, root, output, outputInfo))
+    return outputs
 
 
-def _XgetMonitorData(handle: Optional[int] = None):
-    outputs = _XgetAllOutputs()
-    if handle:
-        for outputData in outputs:
-            display, screen, root, res, output, outputInfo = outputData
-            if output == handle:
-                return display, screen, root, res, output, outputInfo.name
-    else:
-        monitors = _XgetAllMonitors()
-        for monitorData in monitors:
-            display, root, monitor, monName = monitorData
-            if monitor.primary == 1 or len(monitors) == 1:
-                for outputData in outputs:
-                    display, screen, root, res, output, outputInfo = outputData
-                    if monName == outputInfo.name and outputInfo.crtc:
-                        return display, screen, root, res, output, outputInfo.name
-    for outputData in outputs:
-        display, screen, root, res, output, outputInfo = outputData
-        if root.id == defaultEwmhRoot.root.id:
-            return display, screen, root, res, output, outputInfo.name
-    return None
+_cinnamon_names = []
+if os.environ.get('DESKTOP_SESSION', "").lower() == "cinnamon":
+    _cinnamon_names = [item[0] for item in _RgetMonitorsInfo(False)]
+
+
+def _fixCinnamonName(outputName: str):
+    # in Cinnamon VMs, output.name seems to be cut to the last 4 chars
+    outName = outputName
+    global _cinnamon_names
+    for name in _cinnamon_names:
+        if name.endswith(outputName):
+            outName = name
+            break
+    return outName
 
 
-def _runProc(cmd: str, timeout: int = 1):
-    if timeout <= 0:
-        timeout = 1
-    proc = subprocess.run(cmd, text=True, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, timeout=timeout)
-    if proc.returncode == 0:
-        return proc.stdout
+def _XgetMonitors(name: str = ""):
+    monitors = []
+    for monitorData in _XgetAllMonitors(name):
+        display, screen, root, monitor, monName = monitorData
+        monitors.append(monitor)
+    return monitors
+
+
+def _XgetMonitorsDict():
+    monitors = {}
+    for monitorData in _XgetAllMonitors():
+        display, screen, root, monitor, monName = monitorData
+        monitors[monName] = {"monitor": monitor}
+    return monitors
+
+
+def _XgetMonitorData(handle: Optional[int] = None) -> Optional[Tuple[Xlib.display.Display, Struct, XWindow, MonitorInfo, int, str]]:
+    for monitorData in _XgetAllMonitors():
+        display, screen, root, monitor, monName = monitorData
+        output = monitor.crtcs[0]
+        if (handle and handle == output) or (not handle and monitor.primary == 1):
+            return display, screen, root, monitor, output, monName
     return None
 
 
 def _checkEnvironment():
 
     # Check if randr extension is available
     if not defaultEwmhRoot.display.has_extension('RANDR'):
@@ -772,22 +1013,21 @@
         print(ext)
         sys.stderr.write("\n".join(defaultEwmhRoot.display.list_extensions()))
         if ext is None:
             sys.exit(1)
 
     # Check if Xorg is running and xset is present (this will not work on Wayland or alike)
     cmd = "xset -q"
-    ret = _runProc(cmd)
+    code, ret = _runProc(cmd)
     if not ret:
-        sys.stderr.write('{}: Xorg and/or xset are not available\n'.format(sys.argv[0]))
-        sys.exit(1)
+        sys.stderr.write("{}: xset is not available. 'suspend' and 'isSuspended' methods will not work\n".format(sys.argv[0]))
 
     # Check if xrandr is present (it will not in distributions like Arch or Manjaro)
     cmd = "xrandr -q"
-    ret = _runProc(cmd)
+    code, ret = _runProc(cmd)
     if not ret:
         sys.stderr.write(
             '{}: Xorg and/or xrandr are not available\n'.format(sys.argv[0]))
         sys.exit(1)
 _checkEnvironment()
```

## pymonctl/_pymonctl_macos.py

```diff
@@ -1,65 +1,62 @@
 #!/usr/bin/python
 # -*- coding: utf-8 -*-
 # Incomplete type stubs for pyobjc
 # mypy: disable_error_code = no-any-return
 from __future__ import annotations
 
+import ctypes
+from ctypes import util
+
 import sys
 assert sys.platform == "darwin"
 
+import platform
 import subprocess
 import threading
-import time
 
 from typing import Optional, List, Union, cast, Tuple
 
 import AppKit
 import Quartz
 import Quartz.CoreGraphics as CG
+import CoreFoundation as CF
 
 from ._main import BaseMonitor, _pointInBox, _getRelativePosition, \
                    DisplayMode, ScreenValue, Box, Rect, Point, Size, Position, Orientation
-from ._display_manager_lib import Display
 
 
 def _getAllMonitors() -> list[MacOSMonitor]:
     monitors = []
-    screens = AppKit.NSScreen.screens()
-    for screen in screens:
-        desc = screen.deviceDescription()
-        displayId = desc['NSScreenNumber']  # Quartz.NSScreenNumber seems to be wrong
+    v, ids, cnt = CG.CGGetOnlineDisplayList(10, None, None)  # --> How to get display name from this?
+    for displayId in ids:
         monitors.append(MacOSMonitor(displayId))
-    # Alternatives to test:
-    # v, ids, cnt = CG.CGGetOnlineDisplayList(10, None, None)
-    # v, ids, cnt = CG.CGGetActiveDisplayList(10, None, None)
     return monitors
 
 
-def _getAllMonitorsDict(forceUpdate: bool = True) -> dict[str, ScreenValue]:
+def _getAllMonitorsDict() -> dict[str, ScreenValue]:
     result: dict[str, ScreenValue] = {}
     for mon in _NSgetAllMonitors():
         screen, desc, displayId, scrName = mon
 
         try:
             name = screen.localizedName()
         except:
             # In older macOS, screen doesn't have localizedName() method
             name = "Display" + "_" + str(displayId)
-        display = displayId
-        is_primary = Quartz.CGDisplayIsMain(display) == 1
+        is_primary = Quartz.CGDisplayIsMain(displayId) == 1
         x, y, w, h = int(screen.frame().origin.x), int(screen.frame().origin.y), int(screen.frame().size.width), int(screen.frame().size.height)
         wa = screen.visibleFrame()
         wx, wy, wr, wb = int(wa.origin.x), int(wa.origin.y), int(wa.size.width), int(wa.size.height)
-        scale = _getScale(screen)
+        scale = _scale(displayId)
         dpi = desc[Quartz.NSDeviceResolution].sizeValue()
         dpiX, dpiY = int(dpi.width), int(dpi.height)
-        rot = int(Quartz.CGDisplayRotation(display))
-        freq = Quartz.CGDisplayModeGetRefreshRate(Quartz.CGDisplayCopyDisplayMode(display))
-        depth = Quartz.CGDisplayBitsPerPixel(display)
+        rot = Orientation(int(Quartz.CGDisplayRotation(displayId) / 90))
+        freq = Quartz.CGDisplayModeGetRefreshRate(Quartz.CGDisplayCopyDisplayMode(displayId))
+        depth = Quartz.CGDisplayBitsPerPixel(displayId)
 
         result[scrName] = {
             'system_name': name,
             'id': displayId,
             'is_primary': is_primary,
             'position': Point(x, y),
             'size': Size(w, h),
@@ -70,63 +67,60 @@
             'frequency': freq,
             'colordepth': depth
         }
     return result
 
 
 def _getMonitorsCount() -> int:
-    return len(AppKit.NSScreen.screens())
+    v, ids, cnt = CG.CGGetOnlineDisplayList(10, None, None)
+    return cnt
 
 
 def _findMonitor(x: int, y: int) -> List[MacOSMonitor]:
-    ret, monIds, count = CG.CGGetDisplaysWithPoint((x, y), 10, None, None)
-    monitors = []
-    if ret == 0:
-        for i in range(count):
-            monitors.append(MacOSMonitor(monIds[i]))
-    return monitors
+    v, ids, cnt = CG.CGGetDisplaysWithPoint((x, y), 10, None, None)
+    return [MacOSMonitor(displayId) for displayId in ids]
 
 
 def _getPrimary() -> MacOSMonitor:
     return MacOSMonitor()
 
 
-def _arrangeMonitors(arrangement: dict[str, dict[str, Union[str, int, Position, Point, Size]]]):
+def _arrangeMonitors(arrangement: dict[str, dict[str, Optional[Union[str, int, Position, Point, Size]]]]):
 
     monitors = _NSgetAllMonitorsDict()
     primaryPresent = False
     setAsPrimary = ""
     for monName in arrangement.keys():
         relPos = arrangement[monName]["relativePos"]
         relMon = arrangement[monName].get("relativeTo", "")
         if (monName not in monitors.keys() or
                 ((isinstance(relPos, Position) or isinstance(relPos, int)) and
                  ((relMon and relMon not in monitors.keys()) or (not relMon and relPos != Position.PRIMARY)))):
             return
-        elif relPos == Position.PRIMARY:
+        elif relPos == Position.PRIMARY or relPos == (0, 0) or relPos == Point(0, 0):
             setAsPrimary = monName
             primaryPresent = True
     if not primaryPresent:
         return
 
-    newPos: dict[str, dict[str, int]] = {}
-    newPos[setAsPrimary] = {"x": 0, "y": 0}
+    newPos: dict[str, dict[str, int]] = {setAsPrimary: {"x": 0, "y": 0}}
     commitChanges = True
     ret, configRef = Quartz.CGBeginDisplayConfiguration(None)
     if ret != 0:
         return
 
     x, y = 0, 0
     ret = Quartz.CGConfigureDisplayOrigin(configRef, monitors[setAsPrimary]["displayId"], x, y)
     if ret != 0:
-        commitChanges = False
+        Quartz.CGCancelDisplayConfiguration(configRef)
+        return
 
     for monName in arrangement.keys():
 
-        relativePos = cast(Position, arrangement[monName]["relativePos"])
+        relativePos: Union[Position, int, Point, Tuple[int, int]] = arrangement[monName]["relativePos"]
 
         if monName != setAsPrimary:
 
             if isinstance(relativePos, Position) or isinstance(relativePos, int):
 
                 relativeTo = str(arrangement[monName]["relativeTo"])
 
@@ -147,14 +141,15 @@
             else:
                 x, y = relativePos
 
             ret = Quartz.CGConfigureDisplayOrigin(configRef, monitors[monName]["displayId"], x, y)
             newPos[monName] = {"x": x, "y": y}
             if ret != 0:
                 commitChanges = False
+                break
 
     if commitChanges:
         Quartz.CGCompleteDisplayConfiguration(configRef, Quartz.kCGConfigurePermanently)
     else:
         Quartz.CGCancelDisplayConfiguration(configRef)
 
 
@@ -203,15 +198,25 @@
                 desc = screen.deviceDescription()
                 displayId = desc['NSScreenNumber']  # Quartz.NSScreenNumber seems to be wrong
                 if handle == displayId:
                     self.screen = screen
                     break
         if self.screen is not None:
             self.name = _getName(self.handle, self.screen)
-            self._dm = Display(self.handle)
+            self._ds: Optional[ctypes.CDLL] = None
+            self._useDS = True
+            self._cd: Optional[ctypes.CDLL] = None
+            self._useCD = True
+            # self._iokit: Optional[ctypes.CDLL] = None
+            self._useIOBrightness = True
+            self._useIOOrientation = True
+            self._ioservice: Optional[int] = None
+            # In Catalina and above IOKit.IODisplayGetFloatParameter fails
+            v = platform.mac_ver()[0].split(".")
+            self._ver = float(v[0] + "." + v[1])
         else:
             raise ValueError
 
     @property
     def size(self, ) -> Optional[Size]:
         size = self.screen.frame().size
         res = Size(int(size.width), int(size.height))
@@ -227,15 +232,52 @@
     @property
     def position(self) -> Optional[Point]:
         origin = self.screen.frame().origin
         res = Point(int(origin.x), int(origin.y))
         return res
 
     def setPosition(self, relativePos: Union[int, Position, Point, Tuple[int, int]], relativeTo: Optional[str]):
-        _setPosition(relativePos, relativeTo, self.name)
+        # https://apple.stackexchange.com/questions/249447/change-display-arrangement-in-os-x-macos-programmatically
+        arrangement: dict[str, dict[str, Optional[Union[str, int, Position, Point, Size]]]] = {}
+        monitors = _NSgetAllMonitorsDict()
+        monKeys = list(monitors.keys())
+        if relativePos == Position.PRIMARY or relativePos == (0, 0):
+            if self.isPrimary:
+                return
+            # For homogeneity, placing PRIMARY at (0, 0) and all the rest to RIGHT_TOP
+            try:
+                index = monKeys.index(self.name)
+                monKeys.pop(index)
+            except:
+                return
+            arrangement[self.name] = {"relativePos": Position.PRIMARY, "relativeTo": None}
+            xOffset = self.screen.frame().size.width
+
+            for monName in monKeys:
+                relPos = Point(xOffset, 0)
+                arrangement[monName] = {"relativePos": relPos, "relativeTo": None}
+                xOffset += monitors[monName]["screen"].frame().size.width
+
+        else:
+
+            for monName in monKeys:
+                if monName == self.name:
+                    relPos = relativePos
+                    relTo = relativeTo
+                else:
+                    monitor = monitors[monName]["screen"]
+                    x, y = monitor.frame().origin
+                    if (x, y) == (0, 0):
+                        relPos = Position.PRIMARY
+                    else:
+                        relPos = Point(x, y)
+                    relTo = None
+                arrangement[monName] = {"relativePos": relPos, "relativeTo": relTo}
+
+        _arrangeMonitors(arrangement)
 
     @property
     def box(self) -> Optional[Box]:
         frame = self.screen.frame()
         res = Box(int(frame.origin.x), int(frame.origin.y), int(frame.size.width), int(frame.size.height))
         return res
 
@@ -244,163 +286,283 @@
         frame = self.screen.frame()
         res = Rect(int(frame.origin.x), int(frame.origin.y),
                    int(frame.origin.x) + int(frame.size.width), int(frame.origin.y) + int(frame.size.height))
         return res
 
     @property
     def scale(self) -> Optional[Tuple[float, float]]:
-        scale = _getScale(self.screen)
-        # mode = Quartz.CGDisplayCopyDisplayMode(self.handle)
-        # w = Quartz.CGDisplayModeGetWidth(mode)
-        # pw = Quartz.CGDisplayModeGetPixelWidth(mode)
-        # h = Quartz.CGDisplayModeGetHeight(mode)
-        # ph = Quartz.CGDisplayModeGetPixelHeight(mode)
-        # f = Quartz.CGDisplayModeGetRefreshRate(mode)
-        # scale2 = ((pw / w) * 100, (ph / h) * 100)
-        return scale
+        return _scale(self.handle)
 
-    def setScale(self, scale: Tuple[float, float]):
+    def setScale(self, scale: Tuple[float, float], applyGlobally: bool = True):
         # https://www.eizoglobal.com/support/compatibility/dpi_scaling_settings_mac_os_x/
-        # if scale is not None:
-        #     scaleX, scaleY = scale
-        #     currWidth, currHeight = self.size
-        #     currScaleX, currScaleY = self.scale
-        #     targetWidth = currScaleX / scaleX * currWidth
-        #     targetHeight = currScaleY / scaleY * currHeight
-        #     for mode in _CGgetAllModes(self.handle):
-        #         w = Quartz.CGDisplayModeGetWidth(mode)
-        #         pw = Quartz.CGDisplayModeGetPixelWidth(mode)
-        #         h = Quartz.CGDisplayModeGetHeight(mode)
-        #         ph = Quartz.CGDisplayModeGetPixelHeight(mode)
-        #         f = Quartz.CGDisplayModeGetRefreshRate(mode)
-        #         if targetWidth == pw or targetHeight == ph:
-        #             CG.CGDisplaySetDisplayMode(self.handle, mode, None)
-        #             break
-        pass
+
+        if scale is not None and isinstance(scale, tuple) and scale[0] >= 100 and scale[1] >= 100:
+
+            scaleX, scaleY = scale
+
+            defaultMode = self.defaultMode
+            if defaultMode:
+                defaultHeight = defaultMode.height  # Taking default mode height as 100% scale
+                currMode = self.mode
+                if currMode:
+                    currHeight = currMode.height
+                    if currHeight:
+                        if defaultHeight / currHeight == scaleY:
+                            return
+                    currRate = currMode.frequency
+                else:
+                    return
+            else:
+                return
+
+            def filterValue(itemIn):
+                valueIn, freqIn, modeIn = itemIn
+                return valueIn, freqIn
+
+            # Retrieve all modes and their size ratio vs. default
+            modes = []
+            for mode in _CGgetAllModes(self.handle):
+                modeHeight = Quartz.CGDisplayModeGetHeight(mode)
+                ratio = int((defaultHeight / modeHeight) * 100)
+                freq = Quartz.CGDisplayModeGetRefreshRate(mode)
+                modes.append((ratio, freq, mode))
+            modes.sort(key=filterValue)
+            ratio, freq, targetMode = modes[len(modes) - 1]
+
+            # Find modes with target ratio and their refresh rate
+            if ratio > scaleY:
+                targetRatio = 0
+                for item in modes:
+                    ratio, freq, mode = item
+                    if ratio >= scaleY:
+                        targetMode = mode
+                        if targetRatio == 0:
+                            targetRatio = ratio
+                        if ratio == targetRatio:
+                            if freq >= currRate:
+                                break
+                        else:
+                            break
+
+            if targetMode != Quartz.CGDisplayCopyDisplayMode(self.handle):
+                CG.CGDisplaySetDisplayMode(self.handle, targetMode, None)
 
     @property
     def dpi(self) -> Optional[Tuple[float, float]]:
         desc = self.screen.deviceDescription()
         dpi = desc[Quartz.NSDeviceResolution].sizeValue()
         dpiX, dpiY = int(dpi.width), int(dpi.height)
         return dpiX, dpiY
 
     @property
     def orientation(self) -> Optional[Union[int, Orientation]]:
         orientation = int(Quartz.CGDisplayRotation(self.handle) / 90)
         if orientation in (Orientation.NORMAL, Orientation.INVERTED, Orientation.LEFT, Orientation.RIGHT):
-            return orientation
+            return Orientation(orientation)
         return None
 
     def setOrientation(self, orientation: Optional[Union[int, Orientation]]):
-        if orientation in (Orientation.NORMAL, Orientation.INVERTED, Orientation.LEFT, Orientation.RIGHT):
-            self._dm.setRotate(orientation * 90)
+        if (self._useIOOrientation
+                and orientation and orientation in (Orientation.NORMAL, Orientation.INVERTED, Orientation.LEFT, Orientation.RIGHT)):
+            if self._ioservice is None:
+                self._ioservice = _loadIOKit(self.handle)
+            if self._ioservice is not None:
+                swapAxes = 0x10
+                invertX = 0x20
+                invertY = 0x40
+                angleCodes = {
+                    0: 0,
+                    90: (swapAxes | invertX) << 16,
+                    180: (invertX | invertY) << 16,
+                    270: (swapAxes | invertY) << 16,
+                }
+                rotateCode = 0x400
+                options = rotateCode | angleCodes[(orientation*90) % 360]
+
+                try:
+                    ret = globals()["IOServiceRequestProbe"](self._ioservice, options)
+                except:
+                    ret = 1
+                if ret != 0:
+                    self._useIOOrientation = False
+            else:
+                self._useIOOrientation = False
 
     @property
     def frequency(self) -> Optional[float]:
         freq = Quartz.CGDisplayModeGetRefreshRate(Quartz.CGDisplayCopyDisplayMode(self.handle))
         return freq
 
     @property
     def colordepth(self) -> Optional[int]:
         depth = Quartz.CGDisplayBitsPerPixel(self.handle)
         return depth
 
     @property
     def brightness(self) -> Optional[int]:
-        return self._dm.brightness
-        # https://stackoverflow.com/questions/46885603/is-there-a-programmatic-way-to-check-if-brightness-is-at-max-or-min-value-on-osx
-        # value = None
-        # cmd = """nvram backlight-level | awk '{print $2}'"""
-        # err, ret = subprocess.check_output(cmd, shell=True).decode(encoding="utf-8").replace("\n", "")
-        # if err == 0 and ret:
-        #     value = int(float(ret)) * 100
-        # return value
+        res = None
+        ret = 1
+        if self._useDS:
+            if self._ds is None:
+                self._ds = _loadDisplayServices()
+            if self._ds is not None:
+                value = ctypes.c_float()
+                try:
+                    ret = self._ds.DisplayServicesGetBrightness(self.handle, ctypes.byref(value))
+                except:
+                    ret = 1
+                if ret == 0:
+                    res = value.value
+                else:
+                    self._useDS = False
+            else:
+                self._useDS = False
+        if ret != 0 and self._useCD:
+            if self._cd is None:
+                self._cd = _loadCoreDisplay()
+            if self._cd is not None:
+                value = ctypes.c_double()
+                try:
+                    ret = self._cd.CoreDisplay_Display_GetUserBrightness(self.handle, ctypes.byref(value))
+                except:
+                    ret = 1
+                if ret == 0:
+                    res = value.value
+                else:
+                    self._useCD = False
+            else:
+                self._useCD = False
+        if ret != 0 and self._useIOBrightness: # and self._ver > 10.15:
+            if self._ioservice is None:
+                self._ioservice = _loadIOKit(self.handle)
+            if self._ioservice is not None:
+                try:
+                    (ret, value) = globals()["IODisplayGetFloatParameter"](self._ioservice, 0, globals()["kIODisplayBrightnessKey"], None)
+                except:
+                    ret = 1
+                if ret == 0:
+                    res = value
+                else:
+                    self._useIOBrightness = False
+            else:
+                self._useIOBrightness = False
+        if res is not None:
+            return int(res * 100)
+        return None
 
     def setBrightness(self, brightness: Optional[int]):
-        try:
-            self._dm.setBrightness(brightness)
-        except:
-            pass
-        # https://github.com/thevickypedia/pybrightness/blob/main/pybrightness/controller.py
-        # https://eastmanreference.com/complete-list-of-applescript-key-codes
-        # for _ in range(32):
-        #     os.system("""osascript -e 'tell application "System Events"' -e 'key code 145' -e ' end tell'""")
-        # for _ in range(round((32 * int(brightness)) / 100)):
-        #     os.system("""osascript -e 'tell application "System Events"' -e 'key code 144' -e ' end tell'""")
+        # https://stackoverflow.com/questions/46885603/is-there-a-programmatic-way-to-check-if-brightness-is-at-max-or-min-value-on-osx
+        if brightness is not None and 0 < brightness < 100:
+            ret = 1
+            if self._useDS:
+                if self._ds is None:
+                    self._ds = _loadDisplayServices()
+                if self._ds is not None:
+                    value = ctypes.c_float(brightness / 100)
+                    try:
+                        ret = 0
+                        if self._ds.DisplayServicesCanChangeBrightness(self.handle):
+                            ret = self._ds.DisplayServicesSetBrightness(self.handle, value)
+                    except:
+                        ret = 1
+                    if ret != 0:
+                        self._useDS = False
+                else:
+                    self._useDS = False
+            if ret != 0 and self._useDS:
+                if self._cd is None:
+                    self._cd = _loadCoreDisplay()
+                if self._cd is not None:
+                    value = ctypes.c_double(brightness / 100)
+                    try:
+                        ret = self._cd.CoreDisplay_Display_SetUserBrightness(self.handle, value)
+                    except:
+                        ret = 1
+                    if ret != 0:
+                        self._useCD = False
+                else:
+                    self._useCD = False
+            if ret != 0 and self._useIOBrightness and self._ver > 10.15:
+                if self._ioservice is None:
+                    self._ioservice = _loadIOKit(self.handle)
+                if self._ioservice is not None:
+                    value = ctypes.c_float(brightness / 100)
+                    try:
+                        ret = globals()["IODisplaySetFloatParameter"](self._ioservice, 0, globals()["kIODisplayBrightnessKey"], value)
+                    except:
+                        ret = 1
+                    if ret != 0:
+                        self._useIOBrightness = False
+                else:
+                    self._useIOBrightness = False
 
     @property
     def contrast(self) -> Optional[int]:
         # https://searchcode.com/file/2207916/pyobjc-framework-Quartz/PyObjCTest/test_cgdirectdisplay.py/
         contrast = None
         try:
             ret, redMin, redMax, redGamma, greenMin, greenMax, greenGamma, blueMin, blueMax, blueGamma = (
                 CG.CGGetDisplayTransferByFormula(self.handle, None, None, None, None, None, None, None, None, None))
             if ret == 0:
-                contrast = int(((1 / (float(redGamma) or 1)) + (1 / (float(greenGamma) or 1)) + (1 / (float(blueGamma) or 1))) / 3) * 100
+                contrast = int((float(redGamma) + float(greenGamma) + float(blueGamma)) / 3 * 100)
         except:
             pass
         return contrast
 
     def setContrast(self, contrast: Optional[int]):
         # https://searchcode.com/file/2207916/pyobjc-framework-Quartz/PyObjCTest/test_cgdirectdisplay.py/
-        if contrast is not None:
-            try:
-                ret, redMin, redMax, redGamma, greenMin, greenMax, greenGamma, blueMin, blueMax, blueGamma = (
-                    CG.CGGetDisplayTransferByFormula(self.handle, None, None, None, None, None, None, None, None, None))
-                if ret == 0:
-                    newRedGamma = contrast / 100
-                    if newRedGamma < redMin:
-                        newRedGamma = redMin
-                    elif newRedGamma > redMax:
-                        newRedGamma = redMax
-                    newGreenGamma = contrast / 100
-                    if newGreenGamma < greenMin:
-                        newGreenGamma = greenMin
-                    elif newGreenGamma > greenMax:
-                        newGreenGamma = greenMax
-                    newBlueGamma = contrast / 100
-                    if newBlueGamma < blueMin:
-                        newBlueGamma = blueMin
-                    elif newBlueGamma > blueMax:
-                        newBlueGamma = blueMax
-                    ret = CG.CGSetDisplayTransferByFormula(self.handle,
-                                                           redMin, redMax, newRedGamma,
-                                                           greenMin, greenMax, newGreenGamma,
-                                                           blueMin, blueMax, newBlueGamma
-                                                           )
-            except:
-                pass
+        if contrast is not None and 0 <= contrast <= 100:
+            ret, redMin, redMax, redGamma, greenMin, greenMax, greenGamma, blueMin, blueMax, blueGamma = (
+                CG.CGGetDisplayTransferByFormula(self.handle, None, None, None, None, None, None, None, None, None))
+            if ret == 0:
+                newRedGamma = contrast / 100
+                if newRedGamma < redMin:
+                    newRedGamma = redMin
+                elif newRedGamma > redMax:
+                    newRedGamma = redMax
+                newGreenGamma = contrast / 100
+                if newGreenGamma < greenMin:
+                    newGreenGamma = greenMin
+                elif newGreenGamma > greenMax:
+                    newGreenGamma = greenMax
+                newBlueGamma = contrast / 100
+                if newBlueGamma < blueMin:
+                    newBlueGamma = blueMin
+                elif newBlueGamma > blueMax:
+                    newBlueGamma = blueMax
+                ret = CG.CGSetDisplayTransferByFormula(self.handle,
+                                                       redMin, redMax, newRedGamma,
+                                                       greenMin, greenMax, newGreenGamma,
+                                                       blueMin, blueMax, newBlueGamma
+                                                       )
 
     @property
     def mode(self) -> Optional[DisplayMode]:
         mode = Quartz.CGDisplayCopyDisplayMode(self.handle)
         w = Quartz.CGDisplayModeGetWidth(mode)
         h = Quartz.CGDisplayModeGetHeight(mode)
         r = Quartz.CGDisplayModeGetRefreshRate(mode)
         return DisplayMode(w, h, r)
 
     def setMode(self, mode: Optional[DisplayMode]):
         # https://stackoverflow.com/questions/10596489/programmatically-change-resolution-os-x
         # https://searchcode.com/file/2207916/pyobjc-framework-Quartz/PyObjCTest/test_cgdirectdisplay.py/
         if mode is not None:
+            # bestMode, ret = CG.CGDisplayBestModeForParametersAndRefreshRate(self.handle, self.colordepth,
+            #                                                                 mode.width, mode.height, mode.frequency,
+            #                                                                 None)
+            mw, mh, mr = mode.width, mode.height, mode.frequency
             allModes = _CGgetAllModes(self.handle)
             for m in allModes:
-                if (mode.width == Quartz.CGDisplayModeGetWidth(m) and
-                        mode.height == Quartz.CGDisplayModeGetHeight(m) and
-                        mode.frequency == Quartz.CGDisplayModeGetRefreshRate(m)):
+                w = Quartz.CGDisplayModeGetWidth(m)
+                h = Quartz.CGDisplayModeGetHeight(m)
+                r = Quartz.CGDisplayModeGetRefreshRate(m)
+                if w == mw and h == mh and r == mr:
                     CG.CGDisplaySetDisplayMode(self.handle, m, None)
                     break
-            # Look for best mode to apply or stick to input?
-            #         return
-            # bestMode, ret = CG.CGDisplayBestModeForParametersAndRefreshRate(self.handle, self.colordepth,
-            #                                                                 mode.width, mode.height, mode.frequency,
-            #                                                                 None)
-            # CG.CGDisplaySwitchToMode(self.handle, bestMode)
-
 
     @property
     def defaultMode(self) -> Optional[DisplayMode]:
         res: Optional[DisplayMode] = None
         modes = _CGgetAllModes(self.handle)
         for mode in modes:
             if bin(Quartz.CGDisplayModeGetIOFlags(mode))[-3] == '1':
@@ -431,181 +593,82 @@
 
     @property
     def isPrimary(self):
         return self.handle == Quartz.CGMainDisplayID()
 
     def setPrimary(self):
         # https://stackoverflow.com/questions/13722508/change-main-monitor-on-mac-programmatically#:~:text=To%20change%20the%20secondary%20monitor%20to%20be%20the,%28%29.%20A%20full%20sample%20can%20be%20found%20Here
-        self.setPosition(Position.PRIMARY, "")
+        if not self.isPrimary:
+            self.setPosition(Position.PRIMARY, "")
 
     def turnOn(self):
-        # This works, but won't wake up the display despite if the mouse is moving and/or clicking
-
-        def mouseEvent(eventType, posx, posy):
-            ev = CG.CGEventCreateMouseEvent(None, eventType, CG.CGPointMake(posx, posy), CG.kCGMouseButtonLeft)
-            CG.CGEventSetType(ev, eventType)
-            # or kCGSessionEventTap?
-            CG.CGEventPost(CG.kCGHIDEventTap, ev)
-            # CG.CFRelease(ev)   # Produces a Hardware error?!?!?!
-
-        def mousemove(posx, posy):
-            # Alternatives:
-            # mouseEvent(CG.kCGEventMouseMoved, posx, posy)
-            CG.CGDisplayMoveCursorToPoint(self.handle, (posx, posy))
-
-        def mouseclick(posx, posy):
-            # Not necessary to previously move the mouse to given location
-            # mouseEvent(CG.kCGEventMouseMoved, posx, posy)
-            mouseEvent(CG.kCGEventLeftMouseDown, posx, posy)
-            time.sleep(0.1)
-            mouseEvent(CG.kCGEventLeftMouseUp, posx, posy)
-
-        if CG.CGDisplayIsAsleep(self.handle):
-            mousemove(200, 200)
-            mouseclick(200, 200)
-            # This won't wake up monitor either (refers to the whole system)
-            # cmd = """pmset wake"""
-            # subprocess.run(cmd, shell=True, stdout=subprocess.DEVNULL, timeout=1)
-
-        elif not CG.CGDisplayIsActive(self.handle):
-            # CG.CGDisplayRelease(self.handle)
+        cmd = "caffeinate -u -t 2"
+        try:
+            _ = subprocess.run(cmd, text=True, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, timeout=1)
+        except:
             pass
 
     def turnOff(self):
-        # https://stackoverflow.com/questions/32319778/check-if-display-is-sleeping-in-applescript
-        # CG.CGDisplayCapture(self.handle)  # This turns display black, not off
-        pass
+        self.suspend()
 
     @property
     def isOn(self) -> Optional[bool]:
         return bool(CG.CGDisplayIsActive(self.handle) == 1)
 
     def suspend(self):
-        # Also injecting: ControlShiftMedia Eject
-        cmd = """pmset displaysleepnow"""
+        # Also injecting: ControlShiftMedia_Eject
+        cmd = "pmset displaysleepnow"
         try:
             _ = subprocess.run(cmd, text=True, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, timeout=1)
         except:
             pass
 
     @property
     def isSuspended(self) -> Optional[bool]:
         return bool(CG.CGDisplayIsAsleep(self.handle) == 1)
 
-    def attach(self, width: int = 0, height: int = 0):
+    def attach(self):
         pass
 
     def detach(self, permanent: bool = False):
-        # Maybe manipulating position, size and/or mode?
+        # Maybe manipulating brightness, contrast, position, size and/or mode?
         pass
 
     @property
     def isAttached(self) -> Optional[bool]:
-        return CG.CGDisplayIsOnline(self.handle) == 1
-
-
-def _setPosition(relativePos: Union[int, Position, Point, Tuple[int, int]], relativeTo: Optional[str], name: str):
-    # https://apple.stackexchange.com/questions/249447/change-display-arrangement-in-os-x-macos-programmatically
-    monitors = _NSgetAllMonitorsDict()
-    monitorsKeys = list(monitors.keys())
-
-    if (name not in monitorsKeys or
-            ((isinstance(relativePos, Position) or isinstance(relativePos, int)) and
-             (not relativeTo or (relativeTo and relativeTo not in monitors.keys())))):
-        return
-
-    if relativePos == Position.PRIMARY or relativePos == Point(0, 0) or relativePos == (0, 0):
-
-        # If this display becomes primary (0, 0). MUST reposition primary monitor first!
-        commitChanges = True
-        ret, configRef = Quartz.CGBeginDisplayConfiguration(None)
-        if ret != 0:
-            return
-        relativePos = Position.LEFT_TOP
-        relativeTo = name
-
-        newPos: dict[str, dict[str, int]] = {}
-        for monitor in monitorsKeys:
-
-            if monitor != name:
-
-                if isinstance(relativePos, Position) or isinstance(relativePos, int):
-                    frame = monitors[name]["screen"].frame()
-                    targetMon = {"relativePos": relativePos, "relativeTo": relativeTo,
-                                 "position": Point(frame.origin.x, frame.origin.y),
-                                 "size": Size(frame.size.width, frame.size.height)}
-
-                    frame = monitors[relativeTo]["screen"].frame()
-                    if relativeTo in newPos.keys():
-                        relX, relY = newPos[relativeTo]["x"], newPos[relativeTo]["y"]
-                    else:
-                        relX, relY = frame.origin.x, frame.origin.y
-                    relMon = {"position": Point(relX, relY),
-                              "size": Size(frame.size.width, frame.size.height)}
-
-                    x, y = _getRelativePosition(targetMon, relMon)
-
-                else:
-                    x, y = relativePos
-
-                ret = Quartz.CGConfigureDisplayOrigin(configRef, monitors[monitor]["displayId"], x, y)
-                newPos[monitor] = {"x": x, "y": y}
-                if ret != 0:
-                    commitChanges = False
-                relativeTo = monitor
-
-        x, y = 0, 0
-        ret = Quartz.CGConfigureDisplayOrigin(configRef, monitors[name]["displayId"], x, y)
-        if ret != 0:
-            commitChanges = False
-
-        if commitChanges:
-            Quartz.CGCompleteDisplayConfiguration(configRef, Quartz.kCGConfigurePermanently)
-        else:
-            Quartz.CGCancelDisplayConfiguration(configRef)
-
-    else:
-
-        if isinstance(relativePos, Position) or isinstance(relativePos, int):
-            frame = monitors[name]["screen"].frame()
-            targetMon = {"relativePos": relativePos, "relativeTo": relativeTo,
-                         "position": Point(frame.origin.x, frame.origin.y),
-                         "size": Size(frame.size.width, frame.size.height)}
-
-            frame = monitors[relativeTo]["screen"].frame()
-            relMon = {"position": Point(frame.origin.x, frame.origin.y),
-                      "size": Size(frame.size.width, frame.size.height)}
-
-            x, y = _getRelativePosition(targetMon, relMon)
-
-        else:
-            x, y = relativePos
-
-        ret, configRef = Quartz.CGBeginDisplayConfiguration(None)
-        if ret == 0:
-            ret = Quartz.CGConfigureDisplayOrigin(configRef, monitors[name]["displayId"], x, y)
-            if ret == 0:
-                Quartz.CGCompleteDisplayConfiguration(configRef, Quartz.kCGConfigurePermanently)
-            else:
-                Quartz.CGCancelDisplayConfiguration(configRef)
+        return bool(CG.CGDisplayIsOnline(self.handle) == 1)
 
 
 def _getName(displayId: int, screen: Optional[AppKit.NSScreen] = None):
     if not screen:
-        screen = AppKit.NSScreen.mainScreen()
+        for scr in AppKit.NSScreen.screens():
+            desc = scr.deviceDescription()
+            if desc['NSScreenNumber'] == displayId:
+                screen = scr
+                break
     try:
         scrName = cast(AppKit.NSScreen, screen).localizedName() + "_" + str(displayId)
     except:
         # In older macOS, screen doesn't have localizedName() method
         scrName = "Display" + "_" + str(displayId)
     return scrName
 
 
-def _getScale(screen):
-    value = float(screen.backingScaleFactor() * 100)
+def _scale(handle):
+    # value = float(screen.backingScaleFactor() * 100)
+    value = 0.0
+    dh = 0
+    for mode in _CGgetAllModes(handle):
+        if bin(Quartz.CGDisplayModeGetIOFlags(mode))[-3] == '1':
+            dh = Quartz.CGDisplayModeGetHeight(mode)
+            break
+    currMode = Quartz.CGDisplayCopyDisplayMode(handle)
+    ch = Quartz.CGDisplayModeGetHeight(currMode)
+    if ch:
+        value = float(int((dh / ch) * 100))
     scale = (value, value)
     return scale
 
 
 def _CGgetAllModes(handle, showHiDpi: bool = True):
     # Test this with all combinations:
     flags = {}
@@ -632,14 +695,86 @@
         desc = screen.deviceDescription()
         displayId = desc['NSScreenNumber']  # Quartz.NSScreenNumber seems to be wrong
         scrName = _getName(displayId, screen)
         monitors[scrName] = {"screen": screen, "desc": desc, "displayId": displayId}
     return monitors
 
 
+# https://stackoverflow.com/questions/30816183/iokit-ioservicegetmatchingservices-broken-under-python3
+# https://stackoverflow.com/questions/65150131/iodisplayconnect-is-gone-in-big-sur-of-apple-silicon-what-is-the-replacement
+# https://alexdelorenzo.dev/programming/2018/08/16/reverse_engineering_private_apple_apis
+# https://github.com/nriley/brightness/blob/master/brightness.c
+
+def _loadDisplayServices():
+    # Display Services Framework can be used in modern systems. It takes A LOT to load
+    try:
+        ds: ctypes.CDLL = ctypes.cdll.LoadLibrary('/System/Library/PrivateFrameworks/DisplayServices.framework/DisplayServices')
+    except:
+        return None
+    return ds
+
+
+def _loadCoreDisplay():
+    # Another option is to use Core Display Services
+    try:
+        lib = ctypes.util.find_library("CoreDisplay")
+        if lib:
+            cd: ctypes.CDLL = ctypes.cdll.LoadLibrary(lib)
+            cd.CoreDisplay_Display_SetUserBrightness.argtypes = [ctypes.c_int, ctypes.c_double]
+            cd.CoreDisplay_Display_GetUserBrightness.argtypes = [ctypes.c_int, ctypes.c_void_p]
+        else:
+            return None
+    except:
+        return None
+    return cd
+
+
+def _loadIOKit(displayID = Quartz.CGMainDisplayID()):
+    # https://gist.github.com/wadimw/4ac972d07ed1f3b6f22a101375ecac41?permalink_comment_id=4932162
+    # In other systems, we can try to use IOKit
+    try:
+        # lib = ctypes.util.find_library('IOKit')
+        # if lib:
+        #     iokit: ctypes.CDLL = ctypes.cdll.LoadLibrary(lib)
+        #     iokit.IODisplayGetFloatParameter.argtypes = [ctypes.c_int, ctypes.c_int, ctypes.c_void_p, ctypes.c_void_p]
+        #     iokit.IODisplayGetFloatParameter.restype = ctypes.py_object
+        import objc  # type: ignore[import-untyped, import-not-found]
+        iokit = AppKit.NSBundle.bundleWithIdentifier_("com.apple.framework.IOKit")
+        functions = [
+            ("IOServiceGetMatchingService", b"II@"),
+            ("IOServiceMatching", b"@*"),
+            ("IODisplayGetFloatParameter", b"iII@o^f"),
+            ("IODisplaySetFloatParameter", b"iII@f"),
+            ("IOServiceRequestProbe", b"iII"),
+            ("IOObjectRelease", b"iI")
+        ]
+        objc.loadBundleFunctions(iokit, globals(), functions)
+        variables = [
+            ("kIOMasterPortDefault", b"I")
+        ]
+        objc.loadBundleVariables(iokit, globals(), variables)
+        globals()['kIODisplayBrightnessKey'] = CF.CFSTR("brightness")
+
+        try:
+            service: Optional[int] = Quartz.CGDisplayIOServicePort(displayID)
+        except:
+            service = None
+
+        if not service:
+            err, service = globals()["IOServiceGetMatchingService"](
+                globals()["kIOMasterPortDefault"],
+                globals()["IOServiceMatching"](b'IODisplayConnect')
+            )
+            if err != 0 or not service:
+                service = None
+    except:
+        service = None
+    return service
+
+
 def _eventLoop(kill: threading.Event, interval: float):
 
     def reconfig(displayId, flags, userInfo):
         '''
         FLAGS:
         beginConfigurationFlag:
             The display configuration is about to change.
```

## pymonctl/_pymonctl_win.py

```diff
@@ -2,114 +2,126 @@
 # -*- coding: utf-8 -*-
 from __future__ import annotations
 
 import sys
 assert sys.platform == "win32"
 
 import gc
+import platform
 import threading
+import time
 
 import ctypes.wintypes
 import pywintypes
 from typing import Optional, List, Union, Tuple, cast
 import win32api
+import win32gui
 import win32con
 import win32evtlog
-import win32gui
 
 from ._main import (BaseMonitor, _getRelativePosition,
                     DisplayMode, ScreenValue, Box, Rect, Point, Size, Position, Orientation)
-from pymonctl._structs import (_QDC_ONLY_ACTIVE_PATHS, _DISPLAYCONFIG_PATH_INFO, _DISPLAYCONFIG_MODE_INFO, _LUID,
-                               _DISPLAYCONFIG_SOURCE_DPI_SCALE_GET, _DISPLAYCONFIG_SOURCE_DPI_SCALE_SET, _DPI_VALUES,
-                               _DISPLAYCONFIG_DEVICE_INFO_GET_DPI_SCALE, _DISPLAYCONFIG_DEVICE_INFO_SET_DPI_SCALE,
-                               _DISPLAYCONFIG_SOURCE_DEVICE_NAME, _DISPLAYCONFIG_DEVICE_INFO_GET_SOURCE_NAME
-                               )
+from ._structs import (_QDC_ONLY_ACTIVE_PATHS, _DISPLAYCONFIG_PATH_INFO, _DISPLAYCONFIG_MODE_INFO, _LUID,
+                       _DISPLAYCONFIG_SOURCE_DPI_SCALE_GET, _DISPLAYCONFIG_SOURCE_DPI_SCALE_SET, _DPI_VALUES,
+                       _DISPLAYCONFIG_DEVICE_INFO_GET_DPI_SCALE, _DISPLAYCONFIG_DEVICE_INFO_SET_DPI_SCALE,
+                       _DISPLAYCONFIG_SOURCE_DEVICE_NAME, _DISPLAYCONFIG_DEVICE_INFO_GET_SOURCE_NAME
+                       )
 
 
-dpiAware = ctypes.windll.user32.GetAwarenessFromDpiAwarenessContext(ctypes.windll.user32.GetThreadDpiAwarenessContext())
+# Thanks to lappely (https://github.com/poipoiPIO) for his HELP!!!
+try:
+    dpiAware = ctypes.windll.user32.GetAwarenessFromDpiAwarenessContext(ctypes.windll.user32.GetThreadDpiAwarenessContext())
+except AttributeError:  # Windows server does not implement GetAwarenessFromDpiAwarenessContext
+    dpiAware = 0
+
 if dpiAware == 0:
-    # It seems that this can't be invoked twice. Setting it to 2 for apps having 0 (unaware) may have less impact
-    ctypes.windll.shcore.SetProcessDpiAwareness(2)
+    # It seems that this can't be invoked twice. Setting it to 1 for apps having 0 (unaware) may have less impact
+    ctypes.windll.shcore.SetProcessDpiAwareness(1)
 
 
 def _getAllMonitors() -> list[Win32Monitor]:
+    # Monitors IDs may change in case of one of them is attached / detached / plugged / unplugged
     monitors: list[Win32Monitor] = []
-    for monitor in win32api.EnumDisplayMonitors():
-        monitors.append(Win32Monitor(monitor[0].handle))
+    mons = win32api.EnumDisplayMonitors()
+    for mon in mons:
+        hMon = mon[0].handle
+        try:
+            monitors.append(Win32Monitor(hMon))
+        except:
+            pass
     return monitors
 
 
 def _getAllMonitorsDict() -> dict[str, ScreenValue]:
     # https://stackoverflow.com/questions/35814309/winapi-changedisplaysettingsex-does-not-work
     result: dict[str, ScreenValue] = {}
-    monitors = win32api.EnumDisplayMonitors()
-    for monitor in monitors:
-        hMon = monitor[0].handle
-        monitorInfo = win32api.GetMonitorInfo(hMon)
-        monName = monitorInfo.get("Device", "")
-
-        dev = None
+    monitors = _win32getAllMonitorsDict()
+    for monName in monitors:
+        hMon = monitors[monName]["hMon"]
+        monitorInfo = monitors[monName]["monitor"]
+
+        x, y, r, b = monitorInfo["Monitor"]
+        wx, wy, wr, wb = monitorInfo["Work"]
+        is_primary = monitorInfo.get("Flags", 0) == win32con.MONITORINFOF_PRIMARY
+        pScale = ctypes.c_uint()
+        ctypes.windll.shcore.GetScaleFactorForMonitor(hMon, ctypes.byref(pScale))
+        scale = pScale.value
+        dpiX = ctypes.c_uint()
+        dpiY = ctypes.c_uint()
+        ctypes.windll.shcore.GetDpiForMonitor(hMon, 0, ctypes.byref(dpiX), ctypes.byref(dpiY))
         try:
-            # Device content: http://timgolden.me.uk/pywin32-docs/PyDISPLAY_DEVICE.html
-            dev = win32api.EnumDisplayDevices(monName, 0, 0)
-        except:
-            pass
-        if dev and dev.StateFlags & win32con.DISPLAY_DEVICE_ATTACHED_TO_DESKTOP:
-            name = monName
-            x, y, r, b = monitorInfo["Monitor"]
-            wx, wy, wr, wb = monitorInfo["Work"]
-            is_primary = monitorInfo.get("Flags", 0) == win32con.MONITORINFOF_PRIMARY
-            pScale = ctypes.c_uint()
-            ctypes.windll.shcore.GetScaleFactorForMonitor(hMon, ctypes.byref(pScale))
-            scale = pScale.value
-            dpiX = ctypes.c_uint()
-            dpiY = ctypes.c_uint()
-            ctypes.windll.shcore.GetDpiForMonitor(hMon, 0, ctypes.byref(dpiX), ctypes.byref(dpiY))
-            # Settings content: http://timgolden.me.uk/pywin32-docs/PyDEVMODE.html
             settings = win32api.EnumDisplaySettings(monName, win32con.ENUM_CURRENT_SETTINGS)
-            rot = settings.DisplayOrientation
-            freq = settings.DisplayFrequency
-            depth = settings.BitsPerPel
-
-            result[name] = {
-                "system_name": name,
-                "id": hMon,
-                "is_primary": is_primary,
-                "position": Point(x, y),
-                "size": Size(abs(r - x), abs(b - y)),
-                "workarea": Rect(wx, wy, wr, wb),
-                "scale": (scale, scale),
-                "dpi": (dpiX.value, dpiY.value),
-                "orientation": rot,
-                "frequency": freq,
-                "colordepth": depth
-            }
+        except:
+            try:
+                settings = win32api.EnumDisplaySettings(monName, win32con.ENUM_REGISTRY_SETTINGS)
+            except:
+                continue
+
+        rot = Orientation(settings.DisplayOrientation)
+        freq = settings.DisplayFrequency
+        depth = settings.BitsPerPel
+
+        result[monName] = {
+            "system_name": monName,
+            "id": hMon,
+            "is_primary": is_primary,
+            "position": Point(x, y),
+            "size": Size(abs(r - x), abs(b - y)),
+            "workarea": Rect(wx, wy, wr, wb),
+            "scale": (scale, scale),
+            "dpi": (dpiX.value, dpiY.value),
+            "orientation": rot,
+            "frequency": freq,
+            "colordepth": depth
+        }
     return result
 
 
 def _getMonitorsCount() -> int:
     return len(win32api.EnumDisplayMonitors())
 
 
 def _findMonitor(x: int, y: int) -> List[Win32Monitor]:
     # Watch this: started to fail when repeatedly and quickly invoking it in Python 3.10 (it was ok in 3.9)
     hMon = win32api.MonitorFromPoint((x, y), win32con.MONITOR_DEFAULTTONEAREST)
     if hMon and hasattr(hMon, "handle"):
-        return [Win32Monitor(hMon.handle)]
+        try:
+            return [Win32Monitor(hMon.handle)]
+        except:
+            pass
     return []
 
 
 def _getPrimary() -> Win32Monitor:
     return Win32Monitor()
 
 
-def _arrangeMonitors(arrangement: dict[str, dict[str, Union[str, int, Position, Point, Size]]]):
+def _arrangeMonitors(arrangement: dict[str, dict[str, Optional[Union[str, int, Position, Point, Size]]]]):
     # https://stackoverflow.com/questions/35814309/winapi-changedisplaysettingsex-does-not-work
     # https://stackoverflow.com/questions/195267/use-windows-api-from-c-sharp-to-set-primary-monitor
-
     monitors = _win32getAllMonitorsDict()
     primaryPresent = False
     setAsPrimary = ""
     for monName in arrangement.keys():
         relPos = arrangement[monName]["relativePos"]
         relMon = arrangement[monName].get("relativeTo", "")
         if (monName not in monitors.keys() or
@@ -133,15 +145,15 @@
     win32api.ChangeDisplaySettingsEx(setAsPrimary, devmode, flags)
     newPos[setAsPrimary] = {"x": 0, "y": 0}
 
     for monName in arrangement.keys():
 
         if monName != setAsPrimary:
 
-            relativePos = cast(Position, arrangement[monName]["relativePos"])
+            relativePos: Union[Position, int, Point, Tuple[int, int]] = arrangement[monName]["relativePos"]
 
             if isinstance(relativePos, Position) or isinstance(relativePos, int):
 
                 targetMonInfo = monitors[monName]["monitor"]
                 x, y, r, b = targetMonInfo["Monitor"]
                 w = abs(r - x)
                 h = abs(b - y)
@@ -192,66 +204,110 @@
         It can raise ValueError exception in case provided handle is not valid
         """
         if not handle:
             hMon = win32api.MonitorFromPoint((0, 0), win32con.MONITOR_DEFAULTTOPRIMARY)
             if hMon and hasattr(hMon, "handle"):
                 handle = hMon.handle
         if handle:
-            self.handle = handle
             monitorInfo = win32api.GetMonitorInfo(handle)
+            self.handle = handle
             self.name = monitorInfo.get("Device", "")
         else:
             raise ValueError
-        self._hasVCPSupport = _win32hasVCPSupport(self.handle)
-        self._hasVCPPowerSupport = _win32hasVCPPowerSupport(self.handle)
+        self._hasVCPSupport: Optional[bool] = None
+        self._hasVCPPowerSupport: Optional[bool] = None
         self._sourceAdapterId: Optional[_LUID] = None
         self._sourceId: Optional[int] = None
+        self._isWindows11 = False
+        try:
+            self._isWindows11 = bool(int(platform.win32_ver()[1].rsplit(".", 1)[1]) >= 22000)
+        except:
+            self._isWindows11 = False
 
     @property
     def size(self) -> Optional[Size]:
-        monitorInfo = win32api.GetMonitorInfo(self.handle)
+        monitorInfo = _getMonitorInfo(self.handle)
         if monitorInfo:
             x, y, r, b = monitorInfo["Monitor"]
             if x is not None:
                 return Size(abs(r - x), abs(b - y))
         return None
 
     @property
     def workarea(self) -> Optional[Rect]:
-        monitorInfo = win32api.GetMonitorInfo(self.handle)
+        monitorInfo = _getMonitorInfo(self.handle)
         if monitorInfo:
             wx, wy, wr, wb = monitorInfo["Work"]
             if wx is not None:
                 return Rect(wx, wy, wr, wb)
         return None
 
     @property
     def position(self) -> Optional[Point]:
-        monitorInfo = win32api.GetMonitorInfo(self.handle)
+        monitorInfo = _getMonitorInfo(self.handle)
         if monitorInfo:
             x, y, r, b = monitorInfo["Monitor"]
             if x is not None:
                 return Point(x, y)
         return None
 
     def setPosition(self, relativePos: Union[int, Position, Point, Tuple[int, int]], relativeTo: Optional[str]):
-        _setPosition(relativePos, relativeTo, self.name)
+        # https://stackoverflow.com/questions/35814309/winapi-changedisplaysettingsex-does-not-work
+        # https://stackoverflow.com/questions/195267/use-windows-api-from-c-sharp-to-set-primary-monitor
+        arrangement: dict[str, dict[str, Optional[Union[str, int, Position, Point, Size]]]] = {}
+        monitors = _win32getAllMonitorsDict()
+        monKeys = list(monitors.keys())
+        if relativePos == Position.PRIMARY or relativePos == (0, 0):
+            if self.isPrimary:
+                return
+            # For homogeneity, placing PRIMARY at (0, 0) and all the rest to RIGHT_TOP
+            try:
+                index = monKeys.index(self.name)
+                monKeys.pop(index)
+            except:
+                return
+            arrangement[self.name] = {"relativePos": Position.PRIMARY, "relativeTo": None}
+            x, y, r, b = monitors[self.name]["monitor"]["Monitor"]
+            xOffset = abs(r - x)
+
+            for monName in monKeys:
+                relPos = Point(xOffset, 0)
+                arrangement[monName] = {"relativePos": relPos, "relativeTo": None}
+                x, y, r, b = monitors[monName]["monitor"]["Monitor"]
+                xOffset += abs(r - x)
+
+        else:
+
+            for monName in monKeys:
+                if monName == self.name:
+                    relPos = relativePos
+                    relTo = relativeTo
+                else:
+                    x, y, r, b = monitors[monName]["monitor"]["Monitor"]
+                    if (x, y) == (0, 0):
+                        relPos = Position.PRIMARY
+                    else:
+                        relPos = Point(x, y)
+                    relTo = None
+                arrangement[monName] = {"relativePos": relPos, "relativeTo": relTo}
+
+        _arrangeMonitors(arrangement)
 
     @property
     def box(self) -> Optional[Box]:
-        monitorInfo = win32api.GetMonitorInfo(self.handle)
+        monitorInfo = _getMonitorInfo(self.handle)
         if monitorInfo:
             x, y, r, b = monitorInfo["Monitor"]
             if x is not None:
                 return Box(x, y, abs(r - x), abs(b - y))
         return None
 
     @property
     def rect(self) -> Optional[Rect]:
-        monitorInfo = win32api.GetMonitorInfo(self.handle)
+        monitorInfo = _getMonitorInfo(self.handle)
         if monitorInfo:
             x, y, r, b = monitorInfo["Monitor"]
             if x is not None:
                 return Rect(x, y, r, b)
         return None
 
     @property
@@ -299,17 +355,17 @@
                         if sourceName.viewGdiDeviceName == self.name:
                             return path.sourceInfo.adapterId, i
                     else:
                         break
                     i += 1
         return None, None
 
-    def setScale(self, scale: Optional[Tuple[float, float]]):
+    def setScale(self, scale: Optional[Tuple[float, float]], applyGlobally: bool = True):
 
-        if scale is not None:
+        if scale is not None and isinstance(scale, tuple) and scale[0] >= 100 and scale[1] >= 100:
             # https://github.com/lihas/windows-DPI-scaling-sample/blob/master/DPIHelper/DpiHelper.cpp
             # https://github.com/lihas/windows-DPI-scaling-sample/blob/master/DPIHelper/DpiHelper.cpp
             # HOW to GET adapterId and sourceId values???? -> QueryDisplayConfig
             # https://stackoverflow.com/questions/67332814/how-to-properly-clone-and-extend-two-specific-monitors-on-windows
             # Seriously all that to just get the adapterId and the sourceId???? I definitely love you, MS
 
             if self._sourceAdapterId is None:
@@ -358,61 +414,90 @@
         dpiY = ctypes.c_uint()
         ctypes.windll.shcore.GetDpiForMonitor(self.handle, 0, ctypes.byref(dpiX), ctypes.byref(dpiY))
         return dpiX.value, dpiY.value
 
     @property
     def orientation(self) -> Optional[Union[int, Orientation]]:
         # Settings content: http://timgolden.me.uk/pywin32-docs/PyDEVMODE.html
-        settings = win32api.EnumDisplaySettings(self.name, win32con.ENUM_CURRENT_SETTINGS)
+        settings = None
+        try:
+            settings = win32api.EnumDisplaySettings(self.name, win32con.ENUM_CURRENT_SETTINGS)
+        except:
+            try:
+                settings = win32api.EnumDisplaySettings(self.name, win32con.ENUM_REGISTRY_SETTINGS)
+            except:
+                pass
         if settings:
-            return settings.DisplayOrientation
+            return Orientation(settings.DisplayOrientation)
         return None
 
     def setOrientation(self, orientation: Optional[Union[int, Orientation]]):
-        if orientation in (Orientation.NORMAL, Orientation.INVERTED, Orientation.LEFT, Orientation.RIGHT):
-            # Sometimes an empty struct is required, but others we need to retrieve Display Settings first
-            settings = win32api.EnumDisplaySettings(self.name, win32con.ENUM_CURRENT_SETTINGS)
+        if orientation is not None and orientation in (Orientation.NORMAL, Orientation.INVERTED, Orientation.LEFT, Orientation.RIGHT):
+            # In most cases an empty struct is required, but in this case we need to retrieve Display Settings first
+            try:
+                settings = win32api.EnumDisplaySettings(self.name, win32con.ENUM_CURRENT_SETTINGS)
+            except:
+                try:
+                    settings = win32api.EnumDisplaySettings(self.name, win32con.ENUM_REGISTRY_SETTINGS)
+                except:
+                    return
             devmode = cast(pywintypes.DEVMODEType, settings)  # type: ignore[attr-defined, name-defined]
             if (settings.DisplayOrientation + orientation) % 2 == 1:
                 devmode.PelsWidth, devmode.PelsHeight = devmode.PelsHeight, devmode.PelsWidth
             devmode.DisplayOrientation = orientation
             # Not working if setting Fields (!?!?!?)
             # devmode.Fields = devmode.Fields | win32con.DM_DISPLAYORIENTATION | win32con.DM_PELSWIDTH | win32con.DM_PELSHEIGHT
-            win32api.ChangeDisplaySettingsEx(self.name, devmode, win32con.CDS_UPDATEREGISTRY)
+            win32api.ChangeDisplaySettingsEx(self.name, devmode,win32con.CDS_RESET | win32con.CDS_UPDATEREGISTRY)
+            # win32api.ChangeDisplaySettingsEx()
 
     @property
     def frequency(self) -> Optional[float]:
-        settings = win32api.EnumDisplaySettings(self.name, win32con.ENUM_CURRENT_SETTINGS)
+        settings = None
+        try:
+            settings = win32api.EnumDisplaySettings(self.name, win32con.ENUM_CURRENT_SETTINGS)
+        except:
+            try:
+                settings = win32api.EnumDisplaySettings(self.name, win32con.ENUM_REGISTRY_SETTINGS)
+            except:
+                pass
         if settings:
             return settings.DisplayFrequency
         return None
     refreshRate = frequency
 
     @property
     def colordepth(self) -> Optional[int]:
-        settings = win32api.EnumDisplaySettings(self.name, win32con.ENUM_CURRENT_SETTINGS)
+        settings = None
+        try:
+            settings = win32api.EnumDisplaySettings(self.name, win32con.ENUM_CURRENT_SETTINGS)
+        except:
+            try:
+                settings = win32api.EnumDisplaySettings(self.name, win32con.ENUM_REGISTRY_SETTINGS)
+            except:
+                pass
         if settings:
             return settings.BitsPerPel
         return None
 
     @property
     def brightness(self) -> Optional[int]:
         minBright = ctypes.c_uint()
         currBright = ctypes.c_uint()
         maxBright = ctypes.c_uint()
         hDevices = _win32getPhysicalMonitorsHandles(self.handle)
         for hDevice in hDevices:
-            ctypes.windll.dxva2.GetMonitorBrightness(hDevice, ctypes.byref(minBright), ctypes.byref(currBright),
-                                                     ctypes.byref(maxBright))
+            ret = ctypes.windll.dxva2.GetMonitorBrightness(hDevice, ctypes.byref(minBright), ctypes.byref(currBright),
+                                                           ctypes.byref(maxBright))
             _win32destroyPhysicalMonitors(hDevices)
-            return currBright.value
+            if ret != 0:
+                return currBright.value
         return None
 
     def setBrightness(self, brightness: Optional[int]):
-        if brightness is not None:
+        if brightness is not None and 0 <= brightness <= 100:
             minBright = ctypes.c_uint()
             currBright = ctypes.c_uint()
             maxBright = ctypes.c_uint()
             hDevices = _win32getPhysicalMonitorsHandles(self.handle)
             for hDevice in hDevices:
                 ctypes.windll.dxva2.GetMonitorBrightness(hDevice, ctypes.byref(minBright), ctypes.byref(currBright),
                                                          ctypes.byref(maxBright))
@@ -426,22 +511,23 @@
     @property
     def contrast(self) -> Optional[int]:
         minCont = ctypes.c_uint()
         currCont = ctypes.c_uint()
         maxCont = ctypes.c_uint()
         hDevices = _win32getPhysicalMonitorsHandles(self.handle)
         for hDevice in hDevices:
-            ctypes.windll.dxva2.GetMonitorContrast(hDevice, ctypes.byref(minCont), ctypes.byref(currCont),
-                                                   ctypes.byref(maxCont))
+            ret = ctypes.windll.dxva2.GetMonitorContrast(hDevice, ctypes.byref(minCont), ctypes.byref(currCont),
+                                                         ctypes.byref(maxCont))
             _win32destroyPhysicalMonitors(hDevices)
-            return currCont.value
+            if ret != 0:
+                return currCont.value
         return None
 
     def setContrast(self, contrast: Optional[int]):
-        if contrast is not None:
+        if contrast is not None and 0 <= contrast <= 100:
             minCont = ctypes.c_uint()
             currCont = ctypes.c_uint()
             maxCont = ctypes.c_uint()
             hDevices = _win32getPhysicalMonitorsHandles(self.handle)
             for hDevice in hDevices:
                 ctypes.windll.dxva2.GetMonitorContrast(hDevice, ctypes.byref(minCont), ctypes.byref(currCont),
                                                        ctypes.byref(maxCont))
@@ -450,26 +536,36 @@
                 elif contrast > maxCont.value:
                     contrast = maxCont.value
                 ctypes.windll.dxva2.SetMonitorContrast(hDevice, contrast)
                 ctypes.windll.dxva2.DestroyPhysicalMonitor(hDevice)
 
     @property
     def mode(self) -> Optional[DisplayMode]:
-        winSettings = win32api.EnumDisplaySettings(self.name, win32con.ENUM_CURRENT_SETTINGS)
-        return DisplayMode(winSettings.PelsWidth, winSettings.PelsHeight, winSettings.DisplayFrequency)
+        settings = None
+        try:
+            settings = win32api.EnumDisplaySettings(self.name, win32con.ENUM_CURRENT_SETTINGS)
+        except:
+            try:
+                settings = win32api.EnumDisplaySettings(self.name, win32con.ENUM_REGISTRY_SETTINGS)
+            except:
+                pass
+        if settings:
+            return DisplayMode(settings.PelsWidth, settings.PelsHeight, settings.DisplayFrequency)
+        return None
 
     def setMode(self, mode: Optional[DisplayMode]):
         if mode is not None:
             # devmode = win32api.EnumDisplaySettings(self.name, win32con.ENUM_CURRENT_SETTINGS)
             devmode = pywintypes.DEVMODEType()  # type: ignore[attr-defined]
             devmode.PelsWidth = mode.width
             devmode.PelsHeight = mode.height
             devmode.DisplayFrequency = mode.frequency
             devmode.Fields = win32con.DM_PELSWIDTH | win32con.DM_PELSHEIGHT
-            win32api.ChangeDisplaySettingsEx(self.name, devmode, win32con.CDS_UPDATEREGISTRY)
+            win32api.ChangeDisplaySettingsEx(self.name, devmode, win32con.CDS_RESET | win32con.CDS_UPDATEREGISTRY)
+            # win32api.ChangeDisplaySettingsEx()
 
     @property
     def defaultMode(self) -> Optional[DisplayMode]:
         settings = win32api.EnumDisplaySettings(self.name, win32con.ENUM_REGISTRY_SETTINGS)
         return DisplayMode(settings.PelsWidth, settings.PelsHeight, settings.DisplayFrequency)
 
     def setDefaultMode(self):
@@ -488,55 +584,90 @@
             except:
                 break
             i += 1
         return modes
 
     @property
     def isPrimary(self) -> bool:
-        return self.position == Point(0, 0)
+        return bool(self.position == Point(0, 0))
 
     def setPrimary(self):
         if not self.isPrimary:
             _setPrimary(self.name)
 
     def turnOn(self):
         # https://stackoverflow.com/questions/16402672/control-screen-with-python
+        if self._hasVCPSupport is None:
+            self._hasVCPSupport = _win32hasVCPSupport(self.handle)
+            self._hasVCPPowerSupport = _win32hasVCPPowerSupport(self.handle)
         if self._hasVCPSupport and self._hasVCPPowerSupport:
             if not self.isOn:
                 hDevices = _win32getPhysicalMonitorsHandles(self.handle)
                 for hDevice in hDevices:
                     # code and value according to: VESA Monitor Control Command Set (MCCS) standard, version 1.0 and 2.0.
                     ctypes.windll.dxva2.SetVCPFeature(hDevice, 0xD6, 0x01)
                     ctypes.windll.dxva2.DestroyPhysicalMonitor(hDevice)
         else:
-            # This will not work in modern systems
-            win32gui.SendMessageTimeout(win32con.HWND_BROADCAST, win32con.WM_SYSCOMMAND, win32con.SC_MONITORPOWER, -1,
-                                        win32con.SMTO_ABORTIFHUNG, 100)
-            # A mouse move can do the trick (for ALL monitors)
+            # This produces weird behavior in Win11 (it was OK in Win10)
+            if self._isWindows11:
+                hwnd = win32gui.GetDesktopWindow()
+            else:
+                hwnd = win32con.HWND_BROADCAST
+            win32gui.SendMessageTimeout(hwnd, win32con.WM_SYSCOMMAND, win32con.SC_MONITORPOWER,
+                                        -1, win32con.SMTO_ABORTIFHUNG, 100)
+            # The code above will not work in modern systems. A mouse move can do the trick (for ALL monitors)
             mx, my = _getMousePos()
             _win32moveMouse(mx + 1, my + 1)
             _win32moveMouse(mx, my)
 
     def turnOff(self):
         # https://stackoverflow.com/questions/16402672/control-screen-with-python
+        if self._hasVCPSupport is None:
+            self._hasVCPSupport = _win32hasVCPSupport(self.handle)
+            self._hasVCPPowerSupport = _win32hasVCPPowerSupport(self.handle)
         if self._hasVCPSupport and self._hasVCPPowerSupport:
             if self.isOn:
                 hDevices = _win32getPhysicalMonitorsHandles(self.handle)
                 for hDevice in hDevices:
                     # code and value according to: VESA Monitor Control Command Set (MCCS) standard, version 1.0 and 2.0.
                     ctypes.windll.dxva2.SetVCPFeature(hDevice, 0xD6, 0x05)
                     ctypes.windll.dxva2.DestroyPhysicalMonitor(hDevice)
         else:
-            # hMon / hDevice won't work
-            win32gui.SendMessageTimeout(win32con.HWND_BROADCAST, win32con.WM_SYSCOMMAND, win32con.SC_MONITORPOWER, 2,
-                                        win32con.SMTO_ABORTIFHUNG, 100)
+            # Using win32con.HWND_BROADCAST produces weird behavior in Win11 (it was OK in Win10)
+            # Using any other window handle, weird effects go away, but doesn't work in Win11
+            if self._isWindows11:
+                hwnd = win32gui.GetDesktopWindow()
+                # hinst = win32api.GetModuleHandle(None)
+                # wndclass = win32gui.WNDCLASS()
+                # wndclass.hInstance = hinst  # type: ignore[misc]
+                # wndclass.lpszClassName = "DummyWindowClass"  # type: ignore[misc]
+                # myWindowClass = win32gui.RegisterClass(wndclass)
+                # hwnd = win32gui.CreateWindowEx(win32con.WS_EX_LEFT,
+                #                                myWindowClass,  # type: ignore[misc, arg-type]
+                #                                "DummyWindow",
+                #                                0,
+                #                                0,
+                #                                0,
+                #                                win32con.CW_USEDEFAULT,
+                #                                win32con.CW_USEDEFAULT,
+                #                                0,
+                #                                0,
+                #                                hinst,
+                #                                None)
+            else:
+                hwnd = win32con.HWND_BROADCAST
+            win32gui.SendMessageTimeout(hwnd, win32con.WM_SYSCOMMAND, win32con.SC_MONITORPOWER,
+                                        2, win32con.SMTO_ABORTIFHUNG, 100)
 
     @property
     def isOn(self) -> Optional[bool]:
         ret: Optional[bool] = None
+        if self._hasVCPSupport is None:
+            self._hasVCPSupport = _win32hasVCPSupport(self.handle)
+            self._hasVCPPowerSupport = _win32hasVCPPowerSupport(self.handle)
         if self._hasVCPSupport and self._hasVCPPowerSupport:
             hDevices = _win32getPhysicalMonitorsHandles(self.handle)
             for hDevice in hDevices:
                 # code and value according to: VESA Monitor Control Command Set (MCCS) standard, version 1.0 and 2.0.
                 pvct = ctypes.c_uint()
                 currValue = ctypes.c_uint()
                 maxValue = ctypes.c_uint()
@@ -552,28 +683,38 @@
             res = ctypes.windll.kernel32.GetDevicePowerState(self.handle, ctypes.byref(is_working))
             if res:
                 ret = bool(is_working.value)
         isSuspended = self.isSuspended
         return (ret and not isSuspended) if isSuspended is not None else ret
 
     def suspend(self):
+        if self._hasVCPSupport is None:
+            self._hasVCPSupport = _win32hasVCPSupport(self.handle)
+            self._hasVCPPowerSupport = _win32hasVCPPowerSupport(self.handle)
         if self._hasVCPSupport and self._hasVCPPowerSupport:
             hDevices = _win32getPhysicalMonitorsHandles(self.handle)
             for hDevice in hDevices:
                 # code and value according to: VESA Monitor Control Command Set (MCCS) standard, version 1.0 and 2.0.
                 ctypes.windll.dxva2.SetVCPFeature(hDevice, 0xD6, 0x04)
                 ctypes.windll.dxva2.DestroyPhysicalMonitor(hDevice)
         else:
-            # hMon / hDevice won't work
-            win32gui.SendMessageTimeout(win32con.HWND_BROADCAST, win32con.WM_SYSCOMMAND, win32con.SC_MONITORPOWER, 1,
-                                        win32con.SMTO_ABORTIFHUNG, 100)
+            # This produces weird behavior in Win11 (it was OK in Win10)
+            if self._isWindows11:
+                hwnd = win32gui.GetDesktopWindow()
+            else:
+                hwnd = win32con.HWND_BROADCAST
+            win32gui.SendMessageTimeout(hwnd, win32con.WM_SYSCOMMAND, win32con.SC_MONITORPOWER,
+                                        1, win32con.SMTO_ABORTIFHUNG, 100)
 
     @property
     def isSuspended(self) -> Optional[bool]:
         ret: Optional[bool] = None
+        if self._hasVCPSupport is None:
+            self._hasVCPSupport = _win32hasVCPSupport(self.handle)
+            self._hasVCPPowerSupport = _win32hasVCPPowerSupport(self.handle)
         if self._hasVCPSupport and self._hasVCPPowerSupport:
             hDevices = _win32getPhysicalMonitorsHandles(self.handle)
             for hDevice in hDevices:
                 # code and value according to: VESA Monitor Control Command Set (MCCS) standard, version 1.0 and 2.0.
                 pvct = ctypes.c_uint()
                 currValue = ctypes.c_uint()
                 maxValue = ctypes.c_uint()
@@ -585,46 +726,49 @@
         return ret
 
     def attach(self):
         if not self.isAttached:
             # devmode = win32api.EnumDisplaySettings(self.name, win32con.ENUM_REGISTRY_SETTINGS)
             devmode = pywintypes.DEVMODEType()  # type: ignore[attr-defined]
             devmode.Fields = win32con.DM_PELSWIDTH | win32con.DM_PELSHEIGHT
-            win32api.ChangeDisplaySettingsEx(self.name, devmode, win32con.CDS_UPDATEREGISTRY)
+            win32api.ChangeDisplaySettingsEx(self.name, devmode, win32con.CDS_RESET | win32con.CDS_UPDATEREGISTRY)
+            # win32api.ChangeDisplaySettingsEx()
             _findNewHandles()
 
     def detach(self, permanent: bool = False):
         if self.isAttached:
             # devmode = win32api.EnumDisplaySettings(self.name, win32con.ENUM_CURRENT_SETTINGS)
             devmode = pywintypes.DEVMODEType()  # type: ignore[attr-defined]
             devmode.PelsWidth = 0
             devmode.PelsHeight = 0
-            devmode.Position_x = 0
-            devmode.Position_y = 0
+            # devmode.Position_x = 0
+            # devmode.Position_y = 0
             devmode.Fields = win32con.DM_PELSWIDTH | win32con.DM_PELSHEIGHT | win32con.DM_POSITION
-            win32api.ChangeDisplaySettingsEx(self.name, devmode, win32con.CDS_UPDATEREGISTRY if permanent else 0)
+            win32api.ChangeDisplaySettingsEx(self.name, devmode, win32con.CDS_RESET | (win32con.CDS_UPDATEREGISTRY if permanent else 0))
+            # win32api.ChangeDisplaySettingsEx()
             _findNewHandles()
 
     @property
     def isAttached(self) -> Optional[bool]:
-        dev = win32api.EnumDisplayDevices(self.name, 0, 0)
-        return bool(dev and dev.StateFlags & win32con.DISPLAY_DEVICE_ATTACHED_TO_DESKTOP)
+        # Settings content: http://timgolden.me.uk/pywin32-docs/PyDEVMODE.html
+        # This seems to return invalid values (2 instead of 3) in some cases (monitor 1 affected by monitor 3!?!?!?!)
+        # dev = win32api.EnumDisplayDevices(self.name, 0, 0)
+        # return bool(dev and dev.StateFlags & win32con.DISPLAY_DEVICE_ATTACHED_TO_DESKTOP)
+        return self.name in list(_win32getAllMonitorsDict().keys())
 
 
 def _setPrimary(name: str):
     # https://stackoverflow.com/questions/35814309/winapi-changedisplaysettingsex-does-not-work
     monitors = _win32getAllMonitorsDict()
     if len(monitors.keys()) > 1:
         xOffset = 0
-        yOffset = 0
         for monName in monitors.keys():
             if monName == name:
                 monInfo = monitors[monName]["monitor"]
-                xOffset = monInfo["Monitor"][0]
-                yOffset = monInfo["Monitor"][1]
+                xOffset = abs(monInfo["Monitor"][2] - monInfo["Monitor"][0])
                 if monInfo.get("Flags", 0) == win32con.MONITORINFOF_PRIMARY:
                     return
                 else:
                     # settings = win32api.EnumDisplaySettings(name, win32con.ENUM_CURRENT_SETTINGS)
                     devmode = pywintypes.DEVMODEType()  # type: ignore[attr-defined]
                     devmode.Position_x = 0
                     devmode.Position_y = 0
@@ -635,95 +779,69 @@
 
         flags = win32con.CDS_UPDATEREGISTRY | win32con.CDS_NORESET
         for monName in monitors.keys():
             if monName != name:
                 monInfo = monitors[monName]["monitor"]
                 # settings = win32api.EnumDisplaySettings(monName, win32con.ENUM_CURRENT_SETTINGS)
                 devmode = pywintypes.DEVMODEType()  # type: ignore[attr-defined]
-                x = monInfo["Monitor"][0] - xOffset
-                y = monInfo["Monitor"][1] - yOffset
-                devmode.Position_x = x
-                devmode.Position_y = y
+                devmode.Position_x = xOffset
+                devmode.Position_y = 0
                 devmode.Fields = win32con.DM_POSITION
                 win32api.ChangeDisplaySettingsEx(monName, devmode, flags)
-        win32api.ChangeDisplaySettingsEx()
-
-
-def _setPosition(relativePos: Union[int, Position, Point, Tuple[int, int]], relativeTo: Optional[str], name: str):
-    # https://stackoverflow.com/questions/35814309/winapi-changedisplaysettingsex-does-not-work
-    # https://stackoverflow.com/questions/195267/use-windows-api-from-c-sharp-to-set-primary-monitor
-
-    if relativePos == Position.PRIMARY or relativePos == Point(0, 0) or relativePos == (0, 0):
-        _setPrimary(name)
-
-    else:
-        monitors = _win32getAllMonitorsDict()
-        monitorsKeys = list(monitors.keys())
-
-        if (name not in monitorsKeys or
-            ((isinstance(relativePos, Position) or isinstance(relativePos, int)) and
-             (not relativeTo or (relativeTo and relativeTo not in monitors.keys())))):
-            return
-
-        for monitor in monitorsKeys:
-
-            # settings = win32api.EnumDisplaySettings(monitor, win32con.ENUM_CURRENT_SETTINGS)
-            devmode = pywintypes.DEVMODEType()  # type: ignore[attr-defined]
-
-            if monitor == name:
-
-                if isinstance(relativePos, Position) or isinstance(relativePos, int):
-                    targetMonInfo = monitors[name]["monitor"]
-                    x, y, r, b = targetMonInfo["Monitor"]
-                    w = abs(r - x)
-                    h = abs(b - y)
-                    targetMon = {"relativePos": relativePos, "relativeTo": relativeTo,
-                                 "position": Point(x, y), "size": Size(w, h)}
-
-                    relMonInfo = monitors[relativeTo]["monitor"]
-                    x, y, r, b = relMonInfo["Monitor"]
-                    w = abs(r - x)
-                    h = abs(b - y)
-                    relMon = {"position": Point(x, y), "size": Size(w, h)}
-
-                    x, y = _getRelativePosition(targetMon, relMon)
-
-                else:
-                    x, y = relativePos
-
-                # Monitors can not overlap. Existing monitor must be re-positioned first
-                for monName in monitorsKeys:
-                    if monName != name:
-                        mx, my, mr, mb = monitors[monName]["monitor"]["Monitor"]
-                        if mx < x < mr and my < y < mb:
-                            return
-                devmode.Position_x = x
-                devmode.Position_y = y
-                devmode.Fields = win32con.DM_POSITION
-
-            # It seems there is no need to fill in any value
-            # else:
-            #     devmode.DisplayOrientation = settings.DisplayOrientation
-            #     devmode.PelsWidth, devmode.PelsHeight = settings.PelsWidth, settings.PelsHeight
-            #     devmode.Fields = win32con.DM_PELSWIDTH | win32con.DM_PELSHEIGHT
-
-            win32api.ChangeDisplaySettingsEx(monitor, devmode, win32con.CDS_UPDATEREGISTRY | win32con.CDS_NORESET)
-
+                xOffset += abs(monInfo["Monitor"][2] - monInfo["Monitor"][0])
         win32api.ChangeDisplaySettingsEx()
 
 
 def _win32getAllMonitorsDict():
     monitors = {}
     for monitor in win32api.EnumDisplayMonitors():
         hMon = monitor[0].handle
-        monitorInfo = win32api.GetMonitorInfo(hMon)
-        monitors[monitorInfo.get("Device", "")] = {"hMon": hMon, "monitor": monitorInfo}
+        try:
+            monitorInfo = win32api.GetMonitorInfo(hMon)
+            monitors[monitorInfo["Device"]] = {"hMon": hMon, "monitor": monitorInfo}
+        except:
+            pass
     return monitors
 
 
+def _findNewHandles():
+    # https://stackoverflow.com/questions/328851/printing-all-instances-of-a-class
+    # Monitor IDs may change after detaching or attaching a monitor. This will try to refresh them in all instances
+    stopSearching = True
+    while True:
+        monitors = win32api.EnumDisplayMonitors()
+        otherMonitorInstances = [obj for obj in gc.get_objects() if isinstance(obj, Win32Monitor)]
+        for instance in otherMonitorInstances:
+            for monitor in monitors:
+                instance.handle = None
+                instance._sourceAdapterId = None
+                instance._sourceId = None
+                hMon = monitor[0].handle
+                try:
+                    monInfo = win32api.GetMonitorInfo(hMon)
+                    if instance.name == monInfo.get("Device", ""):
+                        instance.handle = hMon
+                        break
+                except:
+                    stopSearching = False
+                    break
+        if stopSearching:
+            break
+        time.sleep(0.2)
+
+
+def _getMonitorInfo(handle: int):
+    try:
+        monitorInfo = win32api.GetMonitorInfo(handle)
+        return monitorInfo
+    except:
+        pass
+    return None
+
+
 def _win32getPhysicalMonitorsHandles(hMon):
     # https://stackoverflow.com/questions/60580536/changing-monitor-input-source-programmatically
 
     class _PHYSICAL_MONITOR(ctypes.Structure):
         _fields_ = [('handle', ctypes.wintypes.HANDLE),
                     ('description', ctypes.wintypes.WCHAR * 128)]
 
@@ -753,24 +871,24 @@
         win32api.mouse_event(win32con.MOUSEEVENTF_LEFTDOWN, x, y, 0, 0)
         win32api.mouse_event(win32con.MOUSEEVENTF_LEFTUP, x, y, 0, 0)
 
 
 def _win32hasVCPSupport(handle: int):
     # https://github.com/dot-osk/monitor_ctrl/blob/master/vcp.py
     # https://github.com/newAM/monitorcontrol/blob/main/monitorcontrol/vcp
-    ret = False
+    res = False
     hDevices = _win32getPhysicalMonitorsHandles(handle)
     for hDevice in hDevices:
         size = ctypes.wintypes.DWORD()
         ret = ctypes.windll.dxva2.GetCapabilitiesStringLength(hDevice, ctypes.byref(size))
         if ret and size.value > 0:
-            ret = True
+            res = True
             break
     _win32destroyPhysicalMonitors(hDevices)
-    return ret
+    return res
 
 
 def _win32getVCPCapabilities(handle: int):
     # https://github.com/dot-osk/monitor_ctrl/blob/master/vcp.py
     # https://www.ddcutil.com/monitor_notes/
     ret = ""
     hDevices = _win32getPhysicalMonitorsHandles(handle)
@@ -787,31 +905,14 @@
     return ret
 
 
 def _win32hasVCPPowerSupport(handle: int):
     return "D6(" in _win32getVCPCapabilities(handle)
 
 
-def _findNewHandles():
-    # https://stackoverflow.com/questions/328851/printing-all-instances-of-a-class
-    # All monitor IDs will change after detaching or attaching a monitor
-    monitors = win32api.EnumDisplayMonitors()
-    otherMonitorInstances = [obj for obj in gc.get_objects() if isinstance(obj, Win32Monitor)]
-    for instance in otherMonitorInstances:
-        for monitor in monitors:
-            hMon = monitor[0].handle
-            monitorInfo = win32api.GetMonitorInfo(hMon)
-            monName = monitorInfo.get("Device", "")
-            if instance.name == monName:
-                instance.handle = hMon
-                instance._sourceAdapterId = None
-                instance._sourceId = None
-                break
-
-
 def _eventLoop(kill: threading.Event, interval: float):
     # https://stackoverflow.com/questions/48720924/python-3-detect-monitor-power-state-in-windows
     # https://wiki.wxpython.org/HookingTheWndProc
     # https://stackoverflow.com/questions/48720924/python-3-detect-monitor-power-state-in-windows
     # https://stackoverflow.com/questions/4273252/detect-inserted-usb-on-windows
 
     class NotificationWindow:
```

## pymonctl/_structs.py

```diff
@@ -1,12 +1,12 @@
 #!/usr/bin/python
 # -*- coding: utf-8 -*-
 from __future__ import annotations
 
-import ctypes.wintypes
+import sys
 from enum import IntEnum
 from typing import NamedTuple, Tuple
 from typing_extensions import TypedDict
 
 
 class Box(NamedTuple):
     """Container class to handle Box struct (left, top, width, height)"""
@@ -101,228 +101,232 @@
     RIGHT = 1
     ROTATE_180 = 2
     INVERTED = 2
     ROTATE_270 = 3
     LEFT = 3
 
 
-# ==================================== QueryDisplayConfig =========================================
+if sys.platform == "win32":
+    import ctypes.wintypes
 
-# ==================================== PathsInfo
+    # ==================================== QueryDisplayConfig =========================================
 
-class _DUMMYSTRUCTNAME(ctypes.Structure):
-    _fields_ = [
-        ('cloneGroupId', ctypes.c_uint32),
-        ('sourceModeInfoIdx', ctypes.c_uint32)
-    ]
+    # ==================================== PathsInfo
 
+    class _DUMMYSTRUCTNAME(ctypes.Structure):
+        _fields_ = [
+            ('cloneGroupId', ctypes.c_uint32),
+            ('sourceModeInfoIdx', ctypes.c_uint32)
+        ]
 
-class _DUMMYUNIONNAME(ctypes.Union):
-    _fields_ = [
-        ('modeInfoIdx', ctypes.c_uint32),
-        ('dummyStructName', _DUMMYSTRUCTNAME)
-    ]
 
+    class _DUMMYUNIONNAME(ctypes.Union):
+        _fields_ = [
+            ('modeInfoIdx', ctypes.c_uint32),
+            ('dummyStructName', _DUMMYSTRUCTNAME)
+        ]
 
-class _LUID(ctypes.Structure):
-    _fields_ = [
-        ('lowPart', ctypes.wintypes.DWORD),
-        ('highPart', ctypes.wintypes.LONG)
-    ]
 
 
-class _DISPLAYCONFIG_PATH_SOURCE_INFO(ctypes.Structure):
-    _fields_ = [
-        ('adapterId', _LUID),
-        ('id', ctypes.c_uint32),
-        ('dummyUnionName', _DUMMYUNIONNAME),
-        ('statusFlags', ctypes.c_uint32)
-    ]
+    class _LUID(ctypes.Structure):
+        _fields_ = [
+            ('lowPart', ctypes.wintypes.DWORD),
+            ('highPart', ctypes.wintypes.LONG)
+        ]
 
 
-class _DISPLAYCONFIG_RATIONAL(ctypes.Structure):
-    _fields_ = [
-        ('numerator', ctypes.c_uint32),
-        ('denominator', ctypes.c_uint32)
-    ]
+    class _DISPLAYCONFIG_PATH_SOURCE_INFO(ctypes.Structure):
+        _fields_ = [
+            ('adapterId', _LUID),
+            ('id', ctypes.c_uint32),
+            ('dummyUnionName', _DUMMYUNIONNAME),
+            ('statusFlags', ctypes.c_uint32)
+        ]
 
 
-class _DISPLAYCONFIG_PATH_TARGET_INFO(ctypes.Structure):
-    _fields_ = [
-        ('adapterId', _LUID),
-        ('id', ctypes.c_uint32),
-        ('dummyUnionName', _DUMMYUNIONNAME),
-        ('outputTechnology', ctypes.c_uint32),
-        ('rotation', ctypes.c_uint32),
-        ('scaling', ctypes.c_uint32),
-        ('refreshRate', _DISPLAYCONFIG_RATIONAL),
-        ('scanLineOrdering', ctypes.c_uint32),
-        ('targetAvailable', ctypes.c_bool),
-        ('statusFlags', ctypes.c_uint32)
-    ]
+    class _DISPLAYCONFIG_RATIONAL(ctypes.Structure):
+        _fields_ = [
+            ('numerator', ctypes.c_uint32),
+            ('denominator', ctypes.c_uint32)
+        ]
 
 
-class _DISPLAYCONFIG_PATH_INFO(ctypes.Structure):
-    _fields_ = [
-        ('sourceInfo', _DISPLAYCONFIG_PATH_SOURCE_INFO),
-        ('targetInfo', _DISPLAYCONFIG_PATH_TARGET_INFO),
-        ('flags', ctypes.c_uint32)
-    ]
+    class _DISPLAYCONFIG_PATH_TARGET_INFO(ctypes.Structure):
+        _fields_ = [
+            ('adapterId', _LUID),
+            ('id', ctypes.c_uint32),
+            ('dummyUnionName', _DUMMYUNIONNAME),
+            ('outputTechnology', ctypes.c_uint32),
+            ('rotation', ctypes.c_uint32),
+            ('scaling', ctypes.c_uint32),
+            ('refreshRate', _DISPLAYCONFIG_RATIONAL),
+            ('scanLineOrdering', ctypes.c_uint32),
+            ('targetAvailable', ctypes.c_bool),
+            ('statusFlags', ctypes.c_uint32)
+        ]
 
 
-# ==================================== ModesInfo
+    class _DISPLAYCONFIG_PATH_INFO(ctypes.Structure):
+        _fields_ = [
+            ('sourceInfo', _DISPLAYCONFIG_PATH_SOURCE_INFO),
+            ('targetInfo', _DISPLAYCONFIG_PATH_TARGET_INFO),
+            ('flags', ctypes.c_uint32)
+        ]
 
-class _DISPLAYCONFIG_2DREGION(ctypes.Structure):
-    _fields_ = [
-        ('cx', ctypes.c_uint32),
-        ('cy', ctypes.c_uint32)
-    ]
 
+    # ==================================== ModesInfo
 
-class _ADDITIONAL_SIGNAL_INFO(ctypes.Structure):
-    _fields_ = [
-        ('videoStandard', ctypes.c_uint32),
-        ('vSyncFreqDivider', ctypes.c_uint32),
-        ('reserved', ctypes.c_uint32)
-    ]
+    class _DISPLAYCONFIG_2DREGION(ctypes.Structure):
+        _fields_ = [
+            ('cx', ctypes.c_uint32),
+            ('cy', ctypes.c_uint32)
+        ]
 
 
-class _DUMMYUNIONNAME_MODE_SIGNAL(ctypes.Union):
-    _fields_ = [
-        ('additionalSignalInfo', _ADDITIONAL_SIGNAL_INFO),
-        ('videoStandard', ctypes.c_uint32)
-    ]
+    class _ADDITIONAL_SIGNAL_INFO(ctypes.Structure):
+        _fields_ = [
+            ('videoStandard', ctypes.c_uint32),
+            ('vSyncFreqDivider', ctypes.c_uint32),
+            ('reserved', ctypes.c_uint32)
+        ]
 
 
-class _DISPLAYCONFIG_VIDEO_SIGNAL_INFO(ctypes.Structure):
-    _fields_ = [
-        ('pixelRate', ctypes.c_uint64),
-        ('hSyncFreq', _DISPLAYCONFIG_RATIONAL),
-        ('vSyncFreq', _DISPLAYCONFIG_RATIONAL),
-        ('activeSize', _DISPLAYCONFIG_2DREGION),
-        ('totalSize', _DISPLAYCONFIG_2DREGION),
-        ('dummyUnionName', _DUMMYUNIONNAME_MODE_SIGNAL),
-        ('scanLineOrdering', ctypes.c_uint32)
-    ]
+    class _DUMMYUNIONNAME_MODE_SIGNAL(ctypes.Union):
+        _fields_ = [
+            ('additionalSignalInfo', _ADDITIONAL_SIGNAL_INFO),
+            ('videoStandard', ctypes.c_uint32)
+        ]
 
 
-class _DISPLAYCONFIG_TARGET_MODE(ctypes.Structure):
-    _fields_ = [
-        ('targetVideoSignalInfo', _DISPLAYCONFIG_VIDEO_SIGNAL_INFO)
-    ]
+    class _DISPLAYCONFIG_VIDEO_SIGNAL_INFO(ctypes.Structure):
+        _fields_ = [
+            ('pixelRate', ctypes.c_uint64),
+            ('hSyncFreq', _DISPLAYCONFIG_RATIONAL),
+            ('vSyncFreq', _DISPLAYCONFIG_RATIONAL),
+            ('activeSize', _DISPLAYCONFIG_2DREGION),
+            ('totalSize', _DISPLAYCONFIG_2DREGION),
+            ('dummyUnionName', _DUMMYUNIONNAME_MODE_SIGNAL),
+            ('scanLineOrdering', ctypes.c_uint32)
+        ]
 
 
-class _POINTL(ctypes.Structure):
-    _fields_ = [
-        ('x', ctypes.wintypes.LONG),
-        ('y', ctypes.wintypes.LONG)
-    ]
+    class _DISPLAYCONFIG_TARGET_MODE(ctypes.Structure):
+        _fields_ = [
+            ('targetVideoSignalInfo', _DISPLAYCONFIG_VIDEO_SIGNAL_INFO)
+        ]
 
 
-class _DISPLAYCONFIG_SOURCE_MODE(ctypes.Structure):
-    _fields_ = [
-        ('width', ctypes.c_uint32),
-        ('height', ctypes.c_uint32),
-        ('pixelFormat', ctypes.c_uint32),
-        ('position', _POINTL)
-    ]
+    class _POINTL(ctypes.Structure):
+        _fields_ = [
+            ('x', ctypes.wintypes.LONG),
+            ('y', ctypes.wintypes.LONG)
+        ]
 
 
-class _RECTL(ctypes.Structure):
-    _fields_ = [
-        ('left', ctypes.c_uint32),
-        ('top', ctypes.c_uint32),
-        ('right', ctypes.c_uint32),
-        ('bottom', ctypes.c_uint32)
-    ]
+    class _DISPLAYCONFIG_SOURCE_MODE(ctypes.Structure):
+        _fields_ = [
+            ('width', ctypes.c_uint32),
+            ('height', ctypes.c_uint32),
+            ('pixelFormat', ctypes.c_uint32),
+            ('position', _POINTL)
+        ]
 
 
-class _DISPLAYCONFIG_DESKTOP_IMAGE_INFO(ctypes.Structure):
-    _fields_ = [
-        ('pathSourceSize', _POINTL),
-        ('desktopImageRegion', _RECTL),
-        ('desktopImageClip', _RECTL)
-    ]
+    class _RECTL(ctypes.Structure):
+        _fields_ = [
+            ('left', ctypes.c_uint32),
+            ('top', ctypes.c_uint32),
+            ('right', ctypes.c_uint32),
+            ('bottom', ctypes.c_uint32)
+        ]
 
 
-class _DUMMYUNIONNAME_MODE(ctypes.Union):
-    _fields_ = [
-        ('targetMode', _DISPLAYCONFIG_TARGET_MODE),
-        ('sourceMode', _DISPLAYCONFIG_SOURCE_MODE),
-        ('desktopImageInfo', _DISPLAYCONFIG_DESKTOP_IMAGE_INFO)
-    ]
+    class _DISPLAYCONFIG_DESKTOP_IMAGE_INFO(ctypes.Structure):
+        _fields_ = [
+            ('pathSourceSize', _POINTL),
+            ('desktopImageRegion', _RECTL),
+            ('desktopImageClip', _RECTL)
+        ]
 
 
-class _DISPLAYCONFIG_MODE_INFO(ctypes.Structure):
-    _fields_ = [
-        ('infoType', ctypes.c_uint32),
-        ('id', ctypes.c_uint32),
-        ('adapterId', _LUID),
-        ('dummyUnionName', _DUMMYUNIONNAME_MODE)
-    ]
+    class _DUMMYUNIONNAME_MODE(ctypes.Union):
+        _fields_ = [
+            ('targetMode', _DISPLAYCONFIG_TARGET_MODE),
+            ('sourceMode', _DISPLAYCONFIG_SOURCE_MODE),
+            ('desktopImageInfo', _DISPLAYCONFIG_DESKTOP_IMAGE_INFO)
+        ]
 
 
-_QDC_ONLY_ACTIVE_PATHS = 2
-_DISPLAYCONFIG_PATH_ACTIVE = 1
+    class _DISPLAYCONFIG_MODE_INFO(ctypes.Structure):
+        _fields_ = [
+            ('infoType', ctypes.c_uint32),
+            ('id', ctypes.c_uint32),
+            ('adapterId', _LUID),
+            ('dummyUnionName', _DUMMYUNIONNAME_MODE)
+        ]
 
 
-# ==================================== DisplayConfig[Get/Set]DeviceInfo =========================================
+    _QDC_ONLY_ACTIVE_PATHS = 2
+    _DISPLAYCONFIG_PATH_ACTIVE = 1
 
 
-_DPI_VALUES = [100, 125, 150, 175, 200, 225, 250, 300, 350, 400, 450, 500]
+    # ==================================== DisplayConfig[Get/Set]DeviceInfo =========================================
 
 
-class _DISPLAYCONFIG_DEVICE_INFO_HEADER(ctypes.Structure):
-    _fields_ = [
-        ('type', ctypes.c_uint32),
-        ('size', ctypes.c_uint32),
-        ('adapterId', _LUID),
-        ('id', ctypes.c_uint32)
-    ]
+    _DPI_VALUES = [100, 125, 150, 175, 200, 225, 250, 300, 350, 400, 450, 500]
 
 
-_DISPLAYCONFIG_DEVICE_INFO_GET_DPI_SCALE = -3  # returns min, max, and currently applied DPI scaling values
+    class _DISPLAYCONFIG_DEVICE_INFO_HEADER(ctypes.Structure):
+        _fields_ = [
+            ('type', ctypes.c_uint32),
+            ('size', ctypes.c_uint32),
+            ('adapterId', _LUID),
+            ('id', ctypes.c_uint32)
+        ]
 
 
-class _DISPLAYCONFIG_SOURCE_DPI_SCALE_GET(ctypes.Structure):
-    _fields_ = [
-        ('header', _DISPLAYCONFIG_DEVICE_INFO_HEADER),
-        ('minScaleRel', ctypes.c_uint32),
-        ('curScaleRel', ctypes.c_uint32),
-        ('maxScaleRel', ctypes.c_uint32)
-    ]
+    _DISPLAYCONFIG_DEVICE_INFO_GET_DPI_SCALE = -3  # returns min, max, and currently applied DPI scaling values
 
 
-_DISPLAYCONFIG_DEVICE_INFO_SET_DPI_SCALE = -4  # set current dpi scaling value for a display
+    class _DISPLAYCONFIG_SOURCE_DPI_SCALE_GET(ctypes.Structure):
+        _fields_ = [
+            ('header', _DISPLAYCONFIG_DEVICE_INFO_HEADER),
+            ('minScaleRel', ctypes.c_uint32),
+            ('curScaleRel', ctypes.c_uint32),
+            ('maxScaleRel', ctypes.c_uint32)
+        ]
 
 
-class _DISPLAYCONFIG_SOURCE_DPI_SCALE_SET(ctypes.Structure):
-    _fields_ = [
-        ('header', _DISPLAYCONFIG_DEVICE_INFO_HEADER),
-        ('scaleRel', ctypes.c_uint32)
-    ]
+    _DISPLAYCONFIG_DEVICE_INFO_SET_DPI_SCALE = -4  # set current dpi scaling value for a display
 
 
-_DISPLAYCONFIG_DEVICE_INFO_GET_TARGET_NAME = 2
+    class _DISPLAYCONFIG_SOURCE_DPI_SCALE_SET(ctypes.Structure):
+        _fields_ = [
+            ('header', _DISPLAYCONFIG_DEVICE_INFO_HEADER),
+            ('scaleRel', ctypes.c_uint32)
+        ]
 
 
-class _DISPLAY_CONFIG_TARGET_DEVICE_NAME(ctypes.Structure):
-    _fields_ = [
-        ('header', _DISPLAYCONFIG_DEVICE_INFO_HEADER),
-        ('flags', ctypes.c_uint32),
-        ('outputTechnology', ctypes.c_uint32),
-        ('edidManufactureId', ctypes.c_uint16),
-        ('edidProductCodeId', ctypes.c_uint16),
-        ('connectorInstance', ctypes.c_uint32),
-        ('monitorFriendlyDeviceName', ctypes.wintypes.WCHAR * 64),
-        ('monitorDevicePath', ctypes.wintypes.WCHAR * 128)
-    ]
+    _DISPLAYCONFIG_DEVICE_INFO_GET_TARGET_NAME = 2
 
 
-_DISPLAYCONFIG_DEVICE_INFO_GET_SOURCE_NAME = 1
+    class _DISPLAY_CONFIG_TARGET_DEVICE_NAME(ctypes.Structure):
+        _fields_ = [
+            ('header', _DISPLAYCONFIG_DEVICE_INFO_HEADER),
+            ('flags', ctypes.c_uint32),
+            ('outputTechnology', ctypes.c_uint32),
+            ('edidManufactureId', ctypes.c_uint16),
+            ('edidProductCodeId', ctypes.c_uint16),
+            ('connectorInstance', ctypes.c_uint32),
+            ('monitorFriendlyDeviceName', ctypes.wintypes.WCHAR * 64),
+            ('monitorDevicePath', ctypes.wintypes.WCHAR * 128)
+        ]
 
 
-class _DISPLAYCONFIG_SOURCE_DEVICE_NAME(ctypes.Structure):
-    _fields_ = [
-        ('header', _DISPLAYCONFIG_DEVICE_INFO_HEADER),
-        ('viewGdiDeviceName', ctypes.wintypes.WCHAR * 32)
-    ]
+    _DISPLAYCONFIG_DEVICE_INFO_GET_SOURCE_NAME = 1
+
+
+    class _DISPLAYCONFIG_SOURCE_DEVICE_NAME(ctypes.Structure):
+        _fields_ = [
+            ('header', _DISPLAYCONFIG_DEVICE_INFO_HEADER),
+            ('viewGdiDeviceName', ctypes.wintypes.WCHAR * 32)
+        ]
```

## Comparing `PyMonCtl-0.7.dist-info/LICENSE.txt` & `PyMonCtl-0.91.dist-info/LICENSE.txt`

 * *Files identical despite different names*

## Comparing `PyMonCtl-0.7.dist-info/METADATA` & `PyMonCtl-0.91.dist-info/METADATA`

 * *Files 4% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: PyMonCtl
-Version: 0.7
+Version: 0.91
 Summary: Cross-Platform toolkit to get info on and control monitors connected
 Home-page: https://github.com/Kalmat/PyMonCtl
 Author: Kalmat
 Author-email: palookjones@gmail.com
 License: BSD 3
 Keywords: screen display monitor control geometry size position frequency scale orientation screen-size mouse-position
 Classifier: Development Status :: 4 - Beta
@@ -13,30 +13,31 @@
 Classifier: Environment :: MacOS X
 Classifier: Intended Audience :: Developers
 Classifier: License :: OSI Approved :: BSD License
 Classifier: Operating System :: OS Independent
 Classifier: Programming Language :: Python
 Classifier: Programming Language :: Python :: 3
 Classifier: Programming Language :: Python :: 3 :: Only
-Classifier: Programming Language :: Python :: 3.7
-Classifier: Programming Language :: Python :: 3.8
 Classifier: Programming Language :: Python :: 3.9
 Classifier: Programming Language :: Python :: 3.10
+Classifier: Programming Language :: Python :: 3.11
 Description-Content-Type: text/markdown
 License-File: LICENSE.txt
 License-File: AUTHORS.txt
-Requires-Dist: typing-extensions (>=4.4.0)
-Requires-Dist: pyobjc (>=8.1) ; sys_platform == "darwin"
-Requires-Dist: python-xlib (>=0.21) ; sys_platform == "linux"
-Requires-Dist: pywin32 (>=302) ; sys_platform == "win32"
+Requires-Dist: typing-extensions >=4.4.0
+Requires-Dist: pyobjc >=8.1 ; sys_platform == "darwin"
+Requires-Dist: python-xlib >=0.21 ; sys_platform == "linux"
+Requires-Dist: ewmhlib >=0.1 ; sys_platform == "linux"
+Requires-Dist: pywin32 >=302 ; sys_platform == "win32"
 Provides-Extra: dev
-Requires-Dist: types-setuptools (>=65.5) ; extra == 'dev'
-Requires-Dist: mypy (>=0.990) ; extra == 'dev'
-Requires-Dist: types-pywin32 (>=305.0.0.3) ; extra == 'dev'
-Requires-Dist: types-python-xlib (>=0.32) ; extra == 'dev'
+Requires-Dist: types-setuptools >=65.5 ; extra == 'dev'
+Requires-Dist: mypy >=0.990 ; extra == 'dev'
+Requires-Dist: types-pywin32 >=305.0.0.3 ; extra == 'dev'
+Requires-Dist: types-python-xlib >=0.32 ; extra == 'dev'
+Requires-Dist: pywinctl >=0.3 ; extra == 'dev'
 
 # PyMonCtl
 [![Type Checking](https://github.com/Kalmat/PyMonCtl/actions/workflows/type-checking.yml/badge.svg)](https://github.com/Kalmat/PyMonCtl/actions/workflows/type-checking.yml)
 [![PyPI version](https://badge.fury.io/py/PyMonCtl.svg)](https://badge.fury.io/py/PyMonCtl)
 
 Cross-Platform module which provides a set of features to get info on and control monitors.
 
@@ -46,32 +47,31 @@
   - xrandr command-line tool
   - xset command-line tool
 - Windows:
   - VCP MCCS API interface
 - macOS:
   - pmset command-line tool
     
-My most sincere thanks and appreciation to the University of Utah Student Computing Labs for their awesome work on 
-the [display_manager_lib](https://github.com/univ-of-utah-marriott-library-apple/display_manager) module, for sharing it so generously, and most especially for allowing to be integrated 
-into PyMonCtl
 
 ## General Features
 
 Functions to get monitor instances, get info and arrange monitors plugged to the system.
 
 |   General functions:    |
 |:-----------------------:|
 |     getAllMonitors      |
 |   getAllMonitorsDict    |
 |    getMonitorsCount     |
 |       getPrimary        |
-|   findMonitorAtPoint    |
-| findMonitorAtPointInfo  |
+|   findMonitorsAtPoint   |
+| findMonitorsAtPointInfo |
 |   findMonitorWithName   |
 | findMonitorWithNameInfo |
+|        saveSetup        |
+|      restoreSetup       |
 |     arrangeMonitors     |
 |       getMousePos       |
 
 
 ## Monitor Class
 
 Class to access all methods and functions to get info and control a given monitor plugged to the system.
@@ -92,54 +92,69 @@
 |  setPosition   |    X    |   X   |   X   |
 |      box       |    X    |   X   |   X   |
 |      rect      |    X    |   X   |   X   |
 |   frequency    |    X    |   X   |   X   |
 |   colordepth   |    X    |   X   |   X   |
 |      dpi       |    X    |   X   |   X   |
 |     scale      |    X    |   X   |   X   |
-|    setScale    |    X    |   X   |       |
+|    setScale    |    X    |   X   |   X   |
 |  orientation   |    X    |   X   |   X   |
 | setOrientation |    X    |   X   | X (1) |
-|   brightness   |  X (2)  |   X   | X (1) |
-| setBrightness  |  X (2)  |   X   | X (1) |
+|   brightness   |  X (2)  |   X   |   X   |
+| setBrightness  |  X (2)  |   X   |   X   |
 |    contrast    |  X (2)  | X (3) | X (3) |
 |  setContrast   |  X (2)  | X (3) | X (3) |
 |      mode      |    X    |   X   |   X   |
 |    setMode     |    X    |   X   |   X   |
 |  defaultMode   |    X    |   X   |   X   |
 | setDefaultMode |    X    |   X   |   X   |
 |    allModes    |    X    |   X   |   X   |
 |   setPrimary   |    X    |   X   |   X   |
 |   isPrimary    |    X    |   X   |   X   |
-|     turnOn     |    X    |   X   |       |
-|    turnOff     |  X (4)  |   X   |       |
+|     turnOn     |  X (4)  |   X   | X (4) |
+|    turnOff     |  X (4)  |   X   | X (4) |
 |      isOn      |  X (2)  |   X   |   X   |
 |    suspend     |  X (4)  | X (4) | X (4) |
 |  isSuspended   |  X (2)  |   X   |   X   |
 |     attach     |    X    |   X   |       |
 |     detach     |    X    |   X   |       |
 |   isAttached   |    X    |   X   |   X   |
 
 
-(1) Through display_manager_lib from University of Utah - Marriott Library - Apple Infrastructure (thank you, guys!).
+(1) Working only in versions older than Catalina (thanks to University of Utah - Marriott Library - Apple Infrastructure)
 
 (2) If monitor has no VCP MCCS support, these methods won't likely work.
 
 (3) It doesn't exactly return / change contrast, but gamma values.
 
-(4) Working on Windows with VCP MCCS support, otherwise, it will suspend ALL monitors.
-    To address a specific monitor, try using turnOff() / turnOn() / detach() / attach() methods.
+(4) Different behaviour according to OS:
+- Windows: Working with VCP MCCS support only.
+- Linux: It will suspend ALL monitors. To address just one monitor, try using turnOff() / turnOn() / detach() / attach() methods.
+- macOS: It will suspend ALL monitors. Use turnOn() to wake them up again
+
 
 #### WARNING: Most of these properties may return ''None'' in case the value can not be obtained
 
 ### Important OS-dependent behaviors and limitations:
 
-  - On Windows, primary monitor is mandatory, and it is always placed at (0, 0) coordinates. Besides, the monitors can not overlap. To set a monitor as Primary, it is necessary to reposition primary monitor first, so the rest of monitors will sequentially be repositioned to LEFT.
-  - On Linux, primary monitor can be anywhere, and even there can be no primary monitor. Monitors can overlap, so take this into account when setting a new monitor position. Also bear in mind that xrandr won't accept negative values, so the whole setup will be referenced to (0, 0) coordinates.
-  - On macOS, primary monitor is mandatory, and it is always placed at (0, 0) coordinates. The monitors can overlap, so take this into account when setting a new monitor position. To set a monitor as Primary, it is necessary to reposition primary monitor first, so the rest of monitors will sequentially be repositioned to LEFT.
+  - Windows:
+      - Primary monitor is mandatory, and it is always placed at (0, 0) coordinates. 
+      - Monitors can not overlap.
+      - To set a monitor as Primary, it is necessary to reposition primary monitor first, so the rest of monitors will sequentially be repositioned to RIGHT_TOP.
+      - If you attach / detach / plug / unplug a monitor, all IDs may change. The module will try to refresh the IDs for all Monitor class instances, but take into account it may fail!
+  - Linux:
+      - Primary monitor can be anywhere, and even there can be no primary monitor. 
+      - Monitors can overlap, so take this into account when setting a new monitor position. 
+      - xrandr won't accept negative values, so the whole setup will be referenced to (0, 0) coordinates.
+      - xrandr will sort primary monitors first. Because of this and for homegeneity, when positioning a monitor as primary (only with setPosition() method), it will be placed at (0 ,0) and all the rest to RIGHT_TOP.
+  - macOS:
+      - Primary monitor is mandatory, and it is always placed at (0, 0) coordinates. 
+      - Monitors can overlap, so take this into account when setting a new monitor position. 
+      - To set a monitor as Primary, it is necessary to reposition primary monitor first, so the rest of monitors will sequentially be repositioned to RIGHT_TOP.
+      - setScale() method uses a workaround by applying the nearest monitor mode to magnify text to given value
 
 It is highly recommended to use `arrangeMonitors()` function for complex setups or just in case there are two or more monitors.   
 
 ## Keep track of Monitor(s) changes
 
 You can activate a watchdog, running in a separate Thread, which will allow you to keep monitors 
 information updated, without negatively impacting your main process, and define hooks and its callbacks to be
```

