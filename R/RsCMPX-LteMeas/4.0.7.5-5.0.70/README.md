# Comparing `tmp/RsCMPX_LteMeas-4.0.7.5.tar.gz` & `tmp/RsCMPX_LteMeas-5.0.70.tar.gz`

## filetype from file(1)

```diff
@@ -1 +1 @@
-gzip compressed data, was "dist\RsCMPX_LteMeas-4.0.7.5.tar", last modified: Sun May 16 18:25:43 2021, max compression
+gzip compressed data, was "dist\RsCMPX_LteMeas-5.0.70.tar", last modified: Thu Apr 18 15:03:39 2024, max compression
```

## Comparing `RsCMPX_LteMeas-4.0.7.5.tar` & `RsCMPX_LteMeas-5.0.70.tar`

### file list

```diff
@@ -1,1299 +1,1119 @@
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:43.002220 RsCMPX_LteMeas-4.0.7.5/
--rw-rw-rw-   0        0        0     2494 2021-05-16 18:25:43.002220 RsCMPX_LteMeas-4.0.7.5/PKG-INFO
--rw-rw-rw-   0        0        0     1651 2021-05-16 18:25:36.000000 RsCMPX_LteMeas-4.0.7.5/README.md
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:37.998522 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:38.044399 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/CustomFiles/
--rw-rw-rw-   0        0        0        0 2021-05-16 18:25:36.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/CustomFiles/__init__.py
--rw-rw-rw-   0        0        0     3304 2021-05-16 18:25:36.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/CustomFiles/events.py
--rw-rw-rw-   0        0        0     4517 2021-05-16 18:25:36.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/CustomFiles/reliability.py
--rw-rw-rw-   0        0        0    18659 2021-05-16 18:25:36.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/CustomFiles/utilities.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:38.083295 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/
--rw-rw-rw-   0        0        0     8629 2021-05-16 18:25:22.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:38.148123 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/
--rw-rw-rw-   0        0        0     2317 2021-05-16 18:25:22.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/CarrierAggregation.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:38.189015 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/CarrierAggregation_/
--rw-rw-rw-   0        0        0      910 2021-05-16 18:25:22.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/CarrierAggregation_/ChannelBw.py
--rw-rw-rw-   0        0        0     1047 2021-05-16 18:25:22.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/CarrierAggregation_/Frequency.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:38.202977 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/CarrierAggregation_/Frequency_/
--rw-rw-rw-   0        0        0     1905 2021-05-16 18:25:22.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/CarrierAggregation_/Frequency_/Aggregated.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/CarrierAggregation_/Frequency_/__init__.py
--rw-rw-rw-   0        0        0     2854 2021-05-16 18:25:22.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/CarrierAggregation_/Maping.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:38.214944 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/CarrierAggregation_/Maping_/
--rw-rw-rw-   0        0        0     2382 2021-05-16 18:25:22.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/CarrierAggregation_/Maping_/Scc.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/CarrierAggregation_/Maping_/__init__.py
--rw-rw-rw-   0        0        0     2584 2021-05-16 18:25:22.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/CarrierAggregation_/Mcarrier.py
--rw-rw-rw-   0        0        0     2393 2021-05-16 18:25:22.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/CarrierAggregation_/Mode.py
--rw-rw-rw-   0        0        0     1879 2021-05-16 18:25:22.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/CarrierAggregation_/Scc.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:38.226913 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/CarrierAggregation_/Scc_/
--rw-rw-rw-   0        0        0     1955 2021-05-16 18:25:22.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/CarrierAggregation_/Scc_/AcSpacing.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/CarrierAggregation_/Scc_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/CarrierAggregation_/__init__.py
--rw-rw-rw-   0        0        0     1924 2021-05-16 18:25:25.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/Cc.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:38.238881 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/Cc_/
--rw-rw-rw-   0        0        0     2548 2021-05-16 18:25:25.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/Cc_/ChannelBw.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/Cc_/__init__.py
--rw-rw-rw-   0        0        0     2951 2021-05-16 18:25:22.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/Emtc.py
--rw-rw-rw-   0        0        0    30569 2021-05-16 18:25:23.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:38.328640 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/
--rw-rw-rw-   0        0        0     1822 2021-05-16 18:25:25.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Bler.py
--rw-rw-rw-   0        0        0     1896 2021-05-16 18:25:23.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Cc.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:38.339613 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Cc_/
--rw-rw-rw-   0        0        0     2289 2021-05-16 18:25:23.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Cc_/PlcId.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Cc_/__init__.py
--rw-rw-rw-   0        0        0     1888 2021-05-16 18:25:25.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Limit.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:38.378508 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Limit_/
--rw-rw-rw-   0        0        0     1194 2021-05-16 18:25:25.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Limit_/Aclr.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:38.395463 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Limit_/Aclr_/
--rw-rw-rw-   0        0        0     1347 2021-05-16 18:25:25.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Limit_/Aclr_/Eutra.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:38.413415 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Limit_/Aclr_/Eutra_/
--rw-rw-rw-   0        0        0     3225 2021-05-16 18:25:25.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Limit_/Aclr_/Eutra_/CarrierAggregation.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:38.424387 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Limit_/Aclr_/Eutra_/CarrierAggregation_/
--rw-rw-rw-   0        0        0     2012 2021-05-16 18:25:25.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Limit_/Aclr_/Eutra_/CarrierAggregation_/ChannelBw1st.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:38.434359 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Limit_/Aclr_/Eutra_/CarrierAggregation_/ChannelBw1st_/
--rw-rw-rw-   0        0        0     5864 2021-05-16 18:25:25.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Limit_/Aclr_/Eutra_/CarrierAggregation_/ChannelBw1st_/ChannelBw2nd.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:38.450318 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Limit_/Aclr_/Eutra_/CarrierAggregation_/ChannelBw1st_/ChannelBw2nd_/
--rw-rw-rw-   0        0        0     6383 2021-05-16 18:25:25.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Limit_/Aclr_/Eutra_/CarrierAggregation_/ChannelBw1st_/ChannelBw2nd_/ChannelBw3rd.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Limit_/Aclr_/Eutra_/CarrierAggregation_/ChannelBw1st_/ChannelBw2nd_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Limit_/Aclr_/Eutra_/CarrierAggregation_/ChannelBw1st_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Limit_/Aclr_/Eutra_/CarrierAggregation_/__init__.py
--rw-rw-rw-   0        0        0     4129 2021-05-16 18:25:25.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Limit_/Aclr_/Eutra_/ChannelBw.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Limit_/Aclr_/Eutra_/__init__.py
--rw-rw-rw-   0        0        0     2253 2021-05-16 18:25:25.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Limit_/Aclr_/Utra.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:38.467271 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Limit_/Aclr_/Utra_/
--rw-rw-rw-   0        0        0     1416 2021-05-16 18:25:25.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Limit_/Aclr_/Utra_/CarrierAggregation.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:38.485223 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Limit_/Aclr_/Utra_/CarrierAggregation_/
--rw-rw-rw-   0        0        0     2012 2021-05-16 18:25:25.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Limit_/Aclr_/Utra_/CarrierAggregation_/ChannelBw1st.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:38.497192 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Limit_/Aclr_/Utra_/CarrierAggregation_/ChannelBw1st_/
--rw-rw-rw-   0        0        0     6610 2021-05-16 18:25:25.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Limit_/Aclr_/Utra_/CarrierAggregation_/ChannelBw1st_/ChannelBw2nd.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:38.508162 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Limit_/Aclr_/Utra_/CarrierAggregation_/ChannelBw1st_/ChannelBw2nd_/
--rw-rw-rw-   0        0        0     7129 2021-05-16 18:25:25.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Limit_/Aclr_/Utra_/CarrierAggregation_/ChannelBw1st_/ChannelBw2nd_/ChannelBw3rd.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Limit_/Aclr_/Utra_/CarrierAggregation_/ChannelBw1st_/ChannelBw2nd_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Limit_/Aclr_/Utra_/CarrierAggregation_/ChannelBw1st_/__init__.py
--rw-rw-rw-   0        0        0     3280 2021-05-16 18:25:25.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Limit_/Aclr_/Utra_/CarrierAggregation_/Ocombination.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Limit_/Aclr_/Utra_/CarrierAggregation_/__init__.py
--rw-rw-rw-   0        0        0     4869 2021-05-16 18:25:25.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Limit_/Aclr_/Utra_/ChannelBw.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Limit_/Aclr_/Utra_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Limit_/Aclr_/__init__.py
--rw-rw-rw-   0        0        0     1041 2021-05-16 18:25:25.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Limit_/Pdynamics.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:38.518135 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Limit_/Pdynamics_/
--rw-rw-rw-   0        0        0     4391 2021-05-16 18:25:25.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Limit_/Pdynamics_/ChannelBw.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Limit_/Pdynamics_/__init__.py
--rw-rw-rw-   0        0        0     3587 2021-05-16 18:25:25.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Limit_/Qam.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:38.563016 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Limit_/Qam_/
--rw-rw-rw-   0        0        0     3298 2021-05-16 18:25:25.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Limit_/Qam_/EsFlatness.py
--rw-rw-rw-   0        0        0     2763 2021-05-16 18:25:25.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Limit_/Qam_/EvMagnitude.py
--rw-rw-rw-   0        0        0     2113 2021-05-16 18:25:25.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Limit_/Qam_/FreqError.py
--rw-rw-rw-   0        0        0     3663 2021-05-16 18:25:25.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Limit_/Qam_/Ibe.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:38.572989 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Limit_/Qam_/Ibe_/
--rw-rw-rw-   0        0        0     3075 2021-05-16 18:25:25.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Limit_/Qam_/Ibe_/IqOffset.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Limit_/Qam_/Ibe_/__init__.py
--rw-rw-rw-   0        0        0     3204 2021-05-16 18:25:25.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Limit_/Qam_/IqOffset.py
--rw-rw-rw-   0        0        0     2655 2021-05-16 18:25:25.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Limit_/Qam_/Merror.py
--rw-rw-rw-   0        0        0     2863 2021-05-16 18:25:25.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Limit_/Qam_/Perror.py
--rw-rw-rw-   0        0        0     3037 2021-05-16 18:25:25.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Limit_/Qam_/Sflatness.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Limit_/Qam_/__init__.py
--rw-rw-rw-   0        0        0    12943 2021-05-16 18:25:25.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Limit_/Qpsk.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:38.583960 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Limit_/Qpsk_/
--rw-rw-rw-   0        0        0     4300 2021-05-16 18:25:25.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Limit_/Qpsk_/Ibe.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Limit_/Qpsk_/__init__.py
--rw-rw-rw-   0        0        0     1514 2021-05-16 18:25:25.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:38.603907 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/
--rw-rw-rw-   0        0        0     3939 2021-05-16 18:25:25.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/AtTolerance.py
--rw-rw-rw-   0        0        0     2425 2021-05-16 18:25:25.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/Limit.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:38.625848 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/Limit_/
--rw-rw-rw-   0        0        0     2200 2021-05-16 18:25:25.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/Limit_/Additional.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:38.641806 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/Limit_/Additional_/
--rw-rw-rw-   0        0        0     1418 2021-05-16 18:25:25.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/Limit_/Additional_/CarrierAggregation.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:38.658760 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/Limit_/Additional_/CarrierAggregation_/
--rw-rw-rw-   0        0        0     2016 2021-05-16 18:25:25.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/Limit_/Additional_/CarrierAggregation_/ChannelBw1st.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:38.667737 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/Limit_/Additional_/CarrierAggregation_/ChannelBw1st_/
--rw-rw-rw-   0        0        0     7437 2021-05-16 18:25:25.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/Limit_/Additional_/CarrierAggregation_/ChannelBw1st_/ChannelBw2nd.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/Limit_/Additional_/CarrierAggregation_/ChannelBw1st_/__init__.py
--rw-rw-rw-   0        0        0     4398 2021-05-16 18:25:25.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/Limit_/Additional_/CarrierAggregation_/Ocombination.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/Limit_/Additional_/CarrierAggregation_/__init__.py
--rw-rw-rw-   0        0        0     6521 2021-05-16 18:25:25.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/Limit_/Additional_/ChannelBw.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:38.678707 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/Limit_/Additional_/ChannelBw_/
--rw-rw-rw-   0        0        0     5026 2021-05-16 18:25:25.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/Limit_/Additional_/ChannelBw_/Sidelink.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/Limit_/Additional_/ChannelBw_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/Limit_/Additional_/__init__.py
--rw-rw-rw-   0        0        0     1416 2021-05-16 18:25:25.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/Limit_/CarrierAggregation.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:38.695661 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/Limit_/CarrierAggregation_/
--rw-rw-rw-   0        0        0     2012 2021-05-16 18:25:25.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/Limit_/CarrierAggregation_/ChannelBw1st.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:38.706633 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/Limit_/CarrierAggregation_/ChannelBw1st_/
--rw-rw-rw-   0        0        0     7111 2021-05-16 18:25:25.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/Limit_/CarrierAggregation_/ChannelBw1st_/ChannelBw2nd.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:38.716606 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/Limit_/CarrierAggregation_/ChannelBw1st_/ChannelBw2nd_/
--rw-rw-rw-   0        0        0     7631 2021-05-16 18:25:25.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/Limit_/CarrierAggregation_/ChannelBw1st_/ChannelBw2nd_/ChannelBw3rd.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/Limit_/CarrierAggregation_/ChannelBw1st_/ChannelBw2nd_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/Limit_/CarrierAggregation_/ChannelBw1st_/__init__.py
--rw-rw-rw-   0        0        0     3786 2021-05-16 18:25:25.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/Limit_/CarrierAggregation_/Ocombination.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/Limit_/CarrierAggregation_/__init__.py
--rw-rw-rw-   0        0        0     5338 2021-05-16 18:25:25.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/Limit_/ChannelBw.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/Limit_/__init__.py
--rw-rw-rw-   0        0        0     1368 2021-05-16 18:25:25.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/ObwLimit.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:38.729571 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/ObwLimit_/
--rw-rw-rw-   0        0        0     2551 2021-05-16 18:25:25.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/ObwLimit_/CarrierAggregation.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:38.740543 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/ObwLimit_/CarrierAggregation_/
--rw-rw-rw-   0        0        0     2012 2021-05-16 18:25:25.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/ObwLimit_/CarrierAggregation_/ChannelBw1st.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:38.749519 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/ObwLimit_/CarrierAggregation_/ChannelBw1st_/
--rw-rw-rw-   0        0        0     5151 2021-05-16 18:25:25.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/ObwLimit_/CarrierAggregation_/ChannelBw1st_/ChannelBw2nd.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:38.760489 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/ObwLimit_/CarrierAggregation_/ChannelBw1st_/ChannelBw2nd_/
--rw-rw-rw-   0        0        0     5673 2021-05-16 18:25:25.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/ObwLimit_/CarrierAggregation_/ChannelBw1st_/ChannelBw2nd_/ChannelBw3rd.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/ObwLimit_/CarrierAggregation_/ChannelBw1st_/ChannelBw2nd_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/ObwLimit_/CarrierAggregation_/ChannelBw1st_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/ObwLimit_/CarrierAggregation_/__init__.py
--rw-rw-rw-   0        0        0     3383 2021-05-16 18:25:25.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/ObwLimit_/ChannelBw.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/ObwLimit_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Limit_/__init__.py
--rw-rw-rw-   0        0        0     6262 2021-05-16 18:25:23.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/ListPy.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:38.775448 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/ListPy_/
--rw-rw-rw-   0        0        0     4963 2021-05-16 18:25:23.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:38.846259 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/
--rw-rw-rw-   0        0        0     3335 2021-05-16 18:25:23.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/Aclr.py
--rw-rw-rw-   0        0        0     1358 2021-05-16 18:25:23.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/CarrierAggregation.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:38.862218 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/CarrierAggregation_/
--rw-rw-rw-   0        0        0     2051 2021-05-16 18:25:23.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/CarrierAggregation_/AcSpacing.py
--rw-rw-rw-   0        0        0     2782 2021-05-16 18:25:23.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/CarrierAggregation_/Mcarrier.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:38.872193 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/CarrierAggregation_/Mcarrier_/
--rw-rw-rw-   0        0        0     2356 2021-05-16 18:25:23.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/CarrierAggregation_/Mcarrier_/Enhanced.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/CarrierAggregation_/Mcarrier_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/CarrierAggregation_/__init__.py
--rw-rw-rw-   0        0        0     4907 2021-05-16 18:25:23.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/Cc.py
--rw-rw-rw-   0        0        0      981 2021-05-16 18:25:23.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/Emtc.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:38.881167 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/Emtc_/
--rw-rw-rw-   0        0        0     2042 2021-05-16 18:25:23.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/Emtc_/Nband.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/Emtc_/__init__.py
--rw-rw-rw-   0        0        0     4039 2021-05-16 18:25:23.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/Modulation.py
--rw-rw-rw-   0        0        0     2074 2021-05-16 18:25:23.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/PlcId.py
--rw-rw-rw-   0        0        0     2012 2021-05-16 18:25:23.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/Pmonitor.py
--rw-rw-rw-   0        0        0     2627 2021-05-16 18:25:23.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/Power.py
--rw-rw-rw-   0        0        0     3653 2021-05-16 18:25:23.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/RbAllocation.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:38.892137 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/RbAllocation_/
--rw-rw-rw-   0        0        0     3368 2021-05-16 18:25:23.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/RbAllocation_/Sidelink.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/RbAllocation_/__init__.py
--rw-rw-rw-   0        0        0     4345 2021-05-16 18:25:23.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/Scc.py
--rw-rw-rw-   0        0        0     3200 2021-05-16 18:25:23.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/SeMask.py
--rw-rw-rw-   0        0        0     6004 2021-05-16 18:25:23.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/Setup.py
--rw-rw-rw-   0        0        0     1043 2021-05-16 18:25:23.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/SingleCmw.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:38.901114 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/SingleCmw_/
--rw-rw-rw-   0        0        0     2128 2021-05-16 18:25:23.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/SingleCmw_/Connector.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/SingleCmw_/__init__.py
--rw-rw-rw-   0        0        0     2912 2021-05-16 18:25:23.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/Tdd.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/__init__.py
--rw-rw-rw-   0        0        0     2149 2021-05-16 18:25:23.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/ListPy_/SingleCmw.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:38.912084 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/ListPy_/SingleCmw_/
--rw-rw-rw-   0        0        0     1584 2021-05-16 18:25:23.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/ListPy_/SingleCmw_/Connector.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/ListPy_/SingleCmw_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/ListPy_/__init__.py
--rw-rw-rw-   0        0        0     5019 2021-05-16 18:25:23.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Modulation.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:38.932031 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Modulation_/
--rw-rw-rw-   0        0        0     1947 2021-05-16 18:25:23.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Modulation_/CarrierAggregation.py
--rw-rw-rw-   0        0        0     2636 2021-05-16 18:25:23.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Modulation_/EePeriods.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:38.943002 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Modulation_/EePeriods_/
--rw-rw-rw-   0        0        0     3661 2021-05-16 18:25:23.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Modulation_/EePeriods_/Pusch.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Modulation_/EePeriods_/__init__.py
--rw-rw-rw-   0        0        0     2865 2021-05-16 18:25:23.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Modulation_/EwLength.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:38.951978 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Modulation_/EwLength_/
--rw-rw-rw-   0        0        0     4023 2021-05-16 18:25:23.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Modulation_/EwLength_/ChannelBw.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Modulation_/EwLength_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Modulation_/__init__.py
--rw-rw-rw-   0        0        0     2873 2021-05-16 18:25:23.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/NsValue.py
--rw-rw-rw-   0        0        0     1262 2021-05-16 18:25:23.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Pcc.py
--rw-rw-rw-   0        0        0     2309 2021-05-16 18:25:23.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Pdynamics.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:38.960953 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Pdynamics_/
--rw-rw-rw-   0        0        0     2838 2021-05-16 18:25:23.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Pdynamics_/AeoPower.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Pdynamics_/__init__.py
--rw-rw-rw-   0        0        0     1501 2021-05-16 18:25:23.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Power.py
--rw-rw-rw-   0        0        0     2483 2021-05-16 18:25:23.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/RbAllocation.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:38.980900 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/RbAllocation_/
--rw-rw-rw-   0        0        0     2382 2021-05-16 18:25:23.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/RbAllocation_/Mcluster.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:38.997855 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/RbAllocation_/Mcluster_/
--rw-rw-rw-   0        0        0     3277 2021-05-16 18:25:23.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/RbAllocation_/Mcluster_/Nrb.py
--rw-rw-rw-   0        0        0     3326 2021-05-16 18:25:23.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/RbAllocation_/Mcluster_/Orb.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/RbAllocation_/Mcluster_/__init__.py
--rw-rw-rw-   0        0        0     3871 2021-05-16 18:25:23.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/RbAllocation_/Nrb.py
--rw-rw-rw-   0        0        0     4259 2021-05-16 18:25:23.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/RbAllocation_/Orb.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/RbAllocation_/__init__.py
--rw-rw-rw-   0        0        0    32110 2021-05-16 18:25:25.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Result.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:39.009823 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Result_/
--rw-rw-rw-   0        0        0     4639 2021-05-16 18:25:25.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Result_/EvMagnitude.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Result_/__init__.py
--rw-rw-rw-   0        0        0     1847 2021-05-16 18:25:23.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Scc.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:39.018800 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Scc_/
--rw-rw-rw-   0        0        0     1891 2021-05-16 18:25:23.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Scc_/PlcId.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Scc_/__init__.py
--rw-rw-rw-   0        0        0     3234 2021-05-16 18:25:23.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Scount.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:39.031770 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Scount_/
--rw-rw-rw-   0        0        0     3046 2021-05-16 18:25:23.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Scount_/Spectrum.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Scount_/__init__.py
--rw-rw-rw-   0        0        0     1228 2021-05-16 18:25:23.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Spectrum.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:39.048720 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Spectrum_/
--rw-rw-rw-   0        0        0     2158 2021-05-16 18:25:23.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Spectrum_/Aclr.py
--rw-rw-rw-   0        0        0     1591 2021-05-16 18:25:23.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Spectrum_/SeMask.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Spectrum_/__init__.py
--rw-rw-rw-   0        0        0     1568 2021-05-16 18:25:23.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Srs.py
--rw-rw-rw-   0        0        0     4312 2021-05-16 18:25:23.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Tmode.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/__init__.py
--rw-rw-rw-   0        0        0     2107 2021-05-16 18:25:22.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/Network.py
--rw-rw-rw-   0        0        0     1381 2021-05-16 18:25:25.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/Pcc.py
--rw-rw-rw-   0        0        0    13145 2021-05-16 18:25:25.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/Prach.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:39.095595 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/Prach_/
--rw-rw-rw-   0        0        0     7747 2021-05-16 18:25:26.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/Prach_/Limit.py
--rw-rw-rw-   0        0        0     4566 2021-05-16 18:25:26.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/Prach_/Modulation.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:39.113547 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/Prach_/Modulation_/
--rw-rw-rw-   0        0        0     2065 2021-05-16 18:25:26.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/Prach_/Modulation_/EwLength.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:39.126513 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/Prach_/Modulation_/EwLength_/
--rw-rw-rw-   0        0        0     3337 2021-05-16 18:25:26.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/Prach_/Modulation_/EwLength_/Pformat.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/Prach_/Modulation_/EwLength_/__init__.py
--rw-rw-rw-   0        0        0     2911 2021-05-16 18:25:26.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/Prach_/Modulation_/Sindex.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/Prach_/Modulation_/__init__.py
--rw-rw-rw-   0        0        0     2682 2021-05-16 18:25:25.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/Prach_/PfOffset.py
--rw-rw-rw-   0        0        0     1345 2021-05-16 18:25:26.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/Prach_/Power.py
--rw-rw-rw-   0        0        0    16721 2021-05-16 18:25:26.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/Prach_/Result.py
--rw-rw-rw-   0        0        0     2573 2021-05-16 18:25:26.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/Prach_/Scount.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/Prach_/__init__.py
--rw-rw-rw-   0        0        0     7382 2021-05-16 18:25:22.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/RfSettings.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:39.149451 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/RfSettings_/
--rw-rw-rw-   0        0        0     1928 2021-05-16 18:25:22.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/RfSettings_/Cc.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:39.160421 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/RfSettings_/Cc_/
--rw-rw-rw-   0        0        0     2939 2021-05-16 18:25:22.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/RfSettings_/Cc_/Frequency.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/RfSettings_/Cc_/__init__.py
--rw-rw-rw-   0        0        0     1278 2021-05-16 18:25:22.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/RfSettings_/Pcc.py
--rw-rw-rw-   0        0        0     1879 2021-05-16 18:25:22.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/RfSettings_/Scc.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:39.169397 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/RfSettings_/Scc_/
--rw-rw-rw-   0        0        0     1915 2021-05-16 18:25:22.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/RfSettings_/Scc_/Frequency.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/RfSettings_/Scc_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/RfSettings_/__init__.py
--rw-rw-rw-   0        0        0     1875 2021-05-16 18:25:25.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/Scc.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:39.178374 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/Scc_/
--rw-rw-rw-   0        0        0     2014 2021-05-16 18:25:25.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/Scc_/ChannelBw.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/Scc_/__init__.py
--rw-rw-rw-   0        0        0     1350 2021-05-16 18:25:22.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/Scenario.py
--rw-rw-rw-   0        0        0     9406 2021-05-16 18:25:26.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/Srs.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:39.192336 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/Srs_/
--rw-rw-rw-   0        0        0     2253 2021-05-16 18:25:26.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/Srs_/Limit.py
--rw-rw-rw-   0        0        0     1509 2021-05-16 18:25:26.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/Srs_/Scount.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/Srs_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/__init__.py
--rw-rw-rw-   0        0        0     9850 2021-05-16 18:25:26.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:39.277111 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/
--rw-rw-rw-   0        0        0     1740 2021-05-16 18:25:29.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Aclr.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:39.300049 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Aclr_/
--rw-rw-rw-   0        0        0     5814 2021-05-16 18:25:29.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Aclr_/Average.py
--rw-rw-rw-   0        0        0     5814 2021-05-16 18:25:29.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Aclr_/Current.py
--rw-rw-rw-   0        0        0     1939 2021-05-16 18:25:29.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Aclr_/Dallocation.py
--rw-rw-rw-   0        0        0     1526 2021-05-16 18:25:29.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Aclr_/DchType.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Aclr_/__init__.py
--rw-rw-rw-   0        0        0     2014 2021-05-16 18:25:29.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Bler.py
--rw-rw-rw-   0        0        0     1795 2021-05-16 18:25:28.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/EsFlatness.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:39.324983 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/EsFlatness_/
--rw-rw-rw-   0        0        0     5011 2021-05-16 18:25:28.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/EsFlatness_/Average.py
--rw-rw-rw-   0        0        0     5635 2021-05-16 18:25:28.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/EsFlatness_/Current.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:39.333959 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/EsFlatness_/Current_/
--rw-rw-rw-   0        0        0     2190 2021-05-16 18:25:28.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/EsFlatness_/Current_/ScIndex.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/EsFlatness_/Current_/__init__.py
--rw-rw-rw-   0        0        0     5011 2021-05-16 18:25:28.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/EsFlatness_/Extreme.py
--rw-rw-rw-   0        0        0     4697 2021-05-16 18:25:28.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/EsFlatness_/StandardDev.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/EsFlatness_/__init__.py
--rw-rw-rw-   0        0        0     1748 2021-05-16 18:25:27.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/EvMagnitude.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:39.357895 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/EvMagnitude_/
--rw-rw-rw-   0        0        0     4525 2021-05-16 18:25:27.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/EvMagnitude_/Average.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:39.365873 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/EvMagnitude_/Average_/
--rw-rw-rw-   0        0        0     3120 2021-05-16 18:25:27.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/EvMagnitude_/Average_/Nref.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/EvMagnitude_/Average_/__init__.py
--rw-rw-rw-   0        0        0     4525 2021-05-16 18:25:27.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/EvMagnitude_/Current.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:39.375847 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/EvMagnitude_/Current_/
--rw-rw-rw-   0        0        0     3120 2021-05-16 18:25:27.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/EvMagnitude_/Current_/Nref.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/EvMagnitude_/Current_/__init__.py
--rw-rw-rw-   0        0        0     4525 2021-05-16 18:25:27.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/EvMagnitude_/Maximum.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:39.383825 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/EvMagnitude_/Maximum_/
--rw-rw-rw-   0        0        0     3120 2021-05-16 18:25:27.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/EvMagnitude_/Maximum_/Nref.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/EvMagnitude_/Maximum_/__init__.py
--rw-rw-rw-   0        0        0     1471 2021-05-16 18:25:27.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/EvMagnitude_/Peak.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:39.401778 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/EvMagnitude_/Peak_/
--rw-rw-rw-   0        0        0     2751 2021-05-16 18:25:27.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/EvMagnitude_/Peak_/Average.py
--rw-rw-rw-   0        0        0     2751 2021-05-16 18:25:27.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/EvMagnitude_/Peak_/Current.py
--rw-rw-rw-   0        0        0     2751 2021-05-16 18:25:27.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/EvMagnitude_/Peak_/Maximum.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/EvMagnitude_/Peak_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/EvMagnitude_/__init__.py
--rw-rw-rw-   0        0        0      967 2021-05-16 18:25:28.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Evmc.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:39.410754 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Evmc_/
--rw-rw-rw-   0        0        0     1742 2021-05-16 18:25:28.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Evmc_/Peak.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:39.432696 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Evmc_/Peak_/
--rw-rw-rw-   0        0        0     2024 2021-05-16 18:25:28.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Evmc_/Peak_/Average.py
--rw-rw-rw-   0        0        0     2024 2021-05-16 18:25:28.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Evmc_/Peak_/Current.py
--rw-rw-rw-   0        0        0     2024 2021-05-16 18:25:28.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Evmc_/Peak_/Maximum.py
--rw-rw-rw-   0        0        0     2056 2021-05-16 18:25:28.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Evmc_/Peak_/StandardDev.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Evmc_/Peak_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Evmc_/__init__.py
--rw-rw-rw-   0        0        0     1671 2021-05-16 18:25:27.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/InbandEmission.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:39.456141 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/InbandEmission_/
--rw-rw-rw-   0        0        0     1904 2021-05-16 18:25:27.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/InbandEmission_/Cc.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:39.465117 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/InbandEmission_/Cc_/
--rw-rw-rw-   0        0        0     1762 2021-05-16 18:25:27.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/InbandEmission_/Cc_/Margin.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:39.486060 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/InbandEmission_/Cc_/Margin_/
--rw-rw-rw-   0        0        0     2404 2021-05-16 18:25:28.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/InbandEmission_/Cc_/Margin_/Average.py
--rw-rw-rw-   0        0        0     3028 2021-05-16 18:25:28.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/InbandEmission_/Cc_/Margin_/Current.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:39.496034 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/InbandEmission_/Cc_/Margin_/Current_/
--rw-rw-rw-   0        0        0     2279 2021-05-16 18:25:28.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/InbandEmission_/Cc_/Margin_/Current_/RbIndex.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/InbandEmission_/Cc_/Margin_/Current_/__init__.py
--rw-rw-rw-   0        0        0     3028 2021-05-16 18:25:28.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/InbandEmission_/Cc_/Margin_/Extreme.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:39.506008 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/InbandEmission_/Cc_/Margin_/Extreme_/
--rw-rw-rw-   0        0        0     2279 2021-05-16 18:25:28.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/InbandEmission_/Cc_/Margin_/Extreme_/RbIndex.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/InbandEmission_/Cc_/Margin_/Extreme_/__init__.py
--rw-rw-rw-   0        0        0     2426 2021-05-16 18:25:28.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/InbandEmission_/Cc_/Margin_/StandardDev.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/InbandEmission_/Cc_/Margin_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/InbandEmission_/Cc_/__init__.py
--rw-rw-rw-   0        0        0      979 2021-05-16 18:25:28.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/InbandEmission_/Pcc.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:39.514982 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/InbandEmission_/Pcc_/
--rw-rw-rw-   0        0        0     1762 2021-05-16 18:25:28.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/InbandEmission_/Pcc_/Margin.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:39.537928 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/InbandEmission_/Pcc_/Margin_/
--rw-rw-rw-   0        0        0     1546 2021-05-16 18:25:28.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/InbandEmission_/Pcc_/Margin_/Average.py
--rw-rw-rw-   0        0        0     2170 2021-05-16 18:25:28.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/InbandEmission_/Pcc_/Margin_/Current.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:39.546898 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/InbandEmission_/Pcc_/Margin_/Current_/
--rw-rw-rw-   0        0        0     1574 2021-05-16 18:25:28.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/InbandEmission_/Pcc_/Margin_/Current_/RbIndex.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/InbandEmission_/Pcc_/Margin_/Current_/__init__.py
--rw-rw-rw-   0        0        0     2170 2021-05-16 18:25:28.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/InbandEmission_/Pcc_/Margin_/Extreme.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:39.556872 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/InbandEmission_/Pcc_/Margin_/Extreme_/
--rw-rw-rw-   0        0        0     1574 2021-05-16 18:25:28.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/InbandEmission_/Pcc_/Margin_/Extreme_/RbIndex.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/InbandEmission_/Pcc_/Margin_/Extreme_/__init__.py
--rw-rw-rw-   0        0        0     1568 2021-05-16 18:25:28.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/InbandEmission_/Pcc_/Margin_/StandardDev.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/InbandEmission_/Pcc_/Margin_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/InbandEmission_/Pcc_/__init__.py
--rw-rw-rw-   0        0        0      979 2021-05-16 18:25:27.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/InbandEmission_/Scc.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:39.565847 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/InbandEmission_/Scc_/
--rw-rw-rw-   0        0        0     1762 2021-05-16 18:25:27.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/InbandEmission_/Scc_/Margin.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:39.587789 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/InbandEmission_/Scc_/Margin_/
--rw-rw-rw-   0        0        0     1544 2021-05-16 18:25:27.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/InbandEmission_/Scc_/Margin_/Average.py
--rw-rw-rw-   0        0        0     2168 2021-05-16 18:25:27.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/InbandEmission_/Scc_/Margin_/Current.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:39.596766 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/InbandEmission_/Scc_/Margin_/Current_/
--rw-rw-rw-   0        0        0     1572 2021-05-16 18:25:27.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/InbandEmission_/Scc_/Margin_/Current_/RbIndex.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/InbandEmission_/Scc_/Margin_/Current_/__init__.py
--rw-rw-rw-   0        0        0     2168 2021-05-16 18:25:27.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/InbandEmission_/Scc_/Margin_/Extreme.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:39.604745 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/InbandEmission_/Scc_/Margin_/Extreme_/
--rw-rw-rw-   0        0        0     1572 2021-05-16 18:25:27.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/InbandEmission_/Scc_/Margin_/Extreme_/RbIndex.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/InbandEmission_/Scc_/Margin_/Extreme_/__init__.py
--rw-rw-rw-   0        0        0     1566 2021-05-16 18:25:27.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/InbandEmission_/Scc_/Margin_/StandardDev.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/InbandEmission_/Scc_/Margin_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/InbandEmission_/Scc_/__init__.py
--rw-rw-rw-   0        0        0     1169 2021-05-16 18:25:27.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/InbandEmission_/Ulca.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:39.616712 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/InbandEmission_/Ulca_/
--rw-rw-rw-   0        0        0      981 2021-05-16 18:25:27.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/InbandEmission_/Ulca_/Pcc.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:39.626686 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/InbandEmission_/Ulca_/Pcc_/
--rw-rw-rw-   0        0        0     1764 2021-05-16 18:25:27.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/InbandEmission_/Ulca_/Pcc_/Margin.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:39.647630 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/InbandEmission_/Ulca_/Pcc_/Margin_/
--rw-rw-rw-   0        0        0     1565 2021-05-16 18:25:27.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/InbandEmission_/Ulca_/Pcc_/Margin_/Average.py
--rw-rw-rw-   0        0        0     2189 2021-05-16 18:25:27.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/InbandEmission_/Ulca_/Pcc_/Margin_/Current.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:39.657604 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/InbandEmission_/Ulca_/Pcc_/Margin_/Current_/
--rw-rw-rw-   0        0        0     1593 2021-05-16 18:25:27.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/InbandEmission_/Ulca_/Pcc_/Margin_/Current_/RbIndex.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/InbandEmission_/Ulca_/Pcc_/Margin_/Current_/__init__.py
--rw-rw-rw-   0        0        0     2189 2021-05-16 18:25:27.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/InbandEmission_/Ulca_/Pcc_/Margin_/Extreme.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:39.666578 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/InbandEmission_/Ulca_/Pcc_/Margin_/Extreme_/
--rw-rw-rw-   0        0        0     1593 2021-05-16 18:25:27.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/InbandEmission_/Ulca_/Pcc_/Margin_/Extreme_/RbIndex.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/InbandEmission_/Ulca_/Pcc_/Margin_/Extreme_/__init__.py
--rw-rw-rw-   0        0        0     1587 2021-05-16 18:25:27.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/InbandEmission_/Ulca_/Pcc_/Margin_/StandardDev.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/InbandEmission_/Ulca_/Pcc_/Margin_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/InbandEmission_/Ulca_/Pcc_/__init__.py
--rw-rw-rw-   0        0        0     1859 2021-05-16 18:25:27.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/InbandEmission_/Ulca_/Scc.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:39.676552 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/InbandEmission_/Ulca_/Scc_/
--rw-rw-rw-   0        0        0     1764 2021-05-16 18:25:27.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/InbandEmission_/Ulca_/Scc_/Margin.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:39.701485 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/InbandEmission_/Ulca_/Scc_/Margin_/
--rw-rw-rw-   0        0        0     1899 2021-05-16 18:25:27.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/InbandEmission_/Ulca_/Scc_/Margin_/Average.py
--rw-rw-rw-   0        0        0     2523 2021-05-16 18:25:27.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/InbandEmission_/Ulca_/Scc_/Margin_/Current.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:39.709465 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/InbandEmission_/Ulca_/Scc_/Margin_/Current_/
--rw-rw-rw-   0        0        0     1928 2021-05-16 18:25:27.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/InbandEmission_/Ulca_/Scc_/Margin_/Current_/RbIndex.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/InbandEmission_/Ulca_/Scc_/Margin_/Current_/__init__.py
--rw-rw-rw-   0        0        0     2523 2021-05-16 18:25:27.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/InbandEmission_/Ulca_/Scc_/Margin_/Extreme.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:39.717443 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/InbandEmission_/Ulca_/Scc_/Margin_/Extreme_/
--rw-rw-rw-   0        0        0     1928 2021-05-16 18:25:27.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/InbandEmission_/Ulca_/Scc_/Margin_/Extreme_/RbIndex.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/InbandEmission_/Ulca_/Scc_/Margin_/Extreme_/__init__.py
--rw-rw-rw-   0        0        0     1921 2021-05-16 18:25:27.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/InbandEmission_/Ulca_/Scc_/Margin_/StandardDev.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/InbandEmission_/Ulca_/Scc_/Margin_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/InbandEmission_/Ulca_/Scc_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/InbandEmission_/Ulca_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/InbandEmission_/__init__.py
--rw-rw-rw-   0        0        0     3038 2021-05-16 18:25:29.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:39.763321 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/
--rw-rw-rw-   0        0        0     1703 2021-05-16 18:25:34.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Aclr.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:39.786259 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Aclr_/
--rw-rw-rw-   0        0        0     2309 2021-05-16 18:25:35.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Aclr_/Dallocation.py
--rw-rw-rw-   0        0        0     1668 2021-05-16 18:25:35.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Aclr_/DchType.py
--rw-rw-rw-   0        0        0     1722 2021-05-16 18:25:35.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Aclr_/Eutra.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:39.810195 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Aclr_/Eutra_/
--rw-rw-rw-   0        0        0     2354 2021-05-16 18:25:35.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Aclr_/Eutra_/Average.py
--rw-rw-rw-   0        0        0     2354 2021-05-16 18:25:35.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Aclr_/Eutra_/Current.py
--rw-rw-rw-   0        0        0     1257 2021-05-16 18:25:35.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Aclr_/Eutra_/Negativ.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:39.823161 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Aclr_/Eutra_/Negativ_/
--rw-rw-rw-   0        0        0     2552 2021-05-16 18:25:35.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Aclr_/Eutra_/Negativ_/Average.py
--rw-rw-rw-   0        0        0     2552 2021-05-16 18:25:35.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Aclr_/Eutra_/Negativ_/Current.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Aclr_/Eutra_/Negativ_/__init__.py
--rw-rw-rw-   0        0        0     1257 2021-05-16 18:25:35.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Aclr_/Eutra_/Positiv.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:39.835129 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Aclr_/Eutra_/Positiv_/
--rw-rw-rw-   0        0        0     2552 2021-05-16 18:25:35.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Aclr_/Eutra_/Positiv_/Average.py
--rw-rw-rw-   0        0        0     2552 2021-05-16 18:25:35.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Aclr_/Eutra_/Positiv_/Current.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Aclr_/Eutra_/Positiv_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Aclr_/Eutra_/__init__.py
--rw-rw-rw-   0        0        0     2145 2021-05-16 18:25:34.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Aclr_/Utra.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:39.848667 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Aclr_/Utra_/
--rw-rw-rw-   0        0        0     1257 2021-05-16 18:25:34.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Aclr_/Utra_/Negativ.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:39.863628 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Aclr_/Utra_/Negativ_/
--rw-rw-rw-   0        0        0     3261 2021-05-16 18:25:34.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Aclr_/Utra_/Negativ_/Average.py
--rw-rw-rw-   0        0        0     3261 2021-05-16 18:25:34.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Aclr_/Utra_/Negativ_/Current.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Aclr_/Utra_/Negativ_/__init__.py
--rw-rw-rw-   0        0        0     1257 2021-05-16 18:25:34.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Aclr_/Utra_/Positiv.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:39.877591 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Aclr_/Utra_/Positiv_/
--rw-rw-rw-   0        0        0     3261 2021-05-16 18:25:35.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Aclr_/Utra_/Positiv_/Average.py
--rw-rw-rw-   0        0        0     3261 2021-05-16 18:25:34.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Aclr_/Utra_/Positiv_/Current.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Aclr_/Utra_/Positiv_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Aclr_/Utra_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Aclr_/__init__.py
--rw-rw-rw-   0        0        0     1978 2021-05-16 18:25:32.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/EsFlatness.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:39.906515 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/
--rw-rw-rw-   0        0        0     2665 2021-05-16 18:25:32.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/Difference.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:39.930449 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/Difference_/
--rw-rw-rw-   0        0        0     2993 2021-05-16 18:25:32.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/Difference_/Average.py
--rw-rw-rw-   0        0        0     2993 2021-05-16 18:25:32.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/Difference_/Current.py
--rw-rw-rw-   0        0        0     2993 2021-05-16 18:25:32.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/Difference_/Extreme.py
--rw-rw-rw-   0        0        0     1786 2021-05-16 18:25:32.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/Difference_/StandardDev.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/Difference_/__init__.py
--rw-rw-rw-   0        0        0     2589 2021-05-16 18:25:32.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/Maxr.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:39.954386 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/Maxr_/
--rw-rw-rw-   0        0        0     2889 2021-05-16 18:25:32.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/Maxr_/Average.py
--rw-rw-rw-   0        0        0     2889 2021-05-16 18:25:32.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/Maxr_/Current.py
--rw-rw-rw-   0        0        0     2889 2021-05-16 18:25:33.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/Maxr_/Extreme.py
--rw-rw-rw-   0        0        0     1734 2021-05-16 18:25:33.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/Maxr_/StandardDev.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/Maxr_/__init__.py
--rw-rw-rw-   0        0        0     2589 2021-05-16 18:25:32.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/Minr.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:39.977325 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/Minr_/
--rw-rw-rw-   0        0        0     2889 2021-05-16 18:25:32.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/Minr_/Average.py
--rw-rw-rw-   0        0        0     2889 2021-05-16 18:25:32.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/Minr_/Current.py
--rw-rw-rw-   0        0        0     2889 2021-05-16 18:25:32.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/Minr_/Extreme.py
--rw-rw-rw-   0        0        0     1734 2021-05-16 18:25:32.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/Minr_/StandardDev.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/Minr_/__init__.py
--rw-rw-rw-   0        0        0     2585 2021-05-16 18:25:32.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/Ripple.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:40.000263 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/Ripple_/
--rw-rw-rw-   0        0        0     2869 2021-05-16 18:25:32.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/Ripple_/Average.py
--rw-rw-rw-   0        0        0     2869 2021-05-16 18:25:32.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/Ripple_/Current.py
--rw-rw-rw-   0        0        0     2869 2021-05-16 18:25:32.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/Ripple_/Extreme.py
--rw-rw-rw-   0        0        0     1724 2021-05-16 18:25:32.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/Ripple_/StandardDev.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/Ripple_/__init__.py
--rw-rw-rw-   0        0        0     1255 2021-05-16 18:25:33.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/ScIndex.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:40.014226 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/ScIndex_/
--rw-rw-rw-   0        0        0     1862 2021-05-16 18:25:33.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/ScIndex_/Maximum.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:40.023202 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/ScIndex_/Maximum_/
--rw-rw-rw-   0        0        0     1719 2021-05-16 18:25:33.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/ScIndex_/Maximum_/Current.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/ScIndex_/Maximum_/__init__.py
--rw-rw-rw-   0        0        0     1862 2021-05-16 18:25:33.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/ScIndex_/Minimum.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:40.031181 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/ScIndex_/Minimum_/
--rw-rw-rw-   0        0        0     1719 2021-05-16 18:25:33.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/ScIndex_/Minimum_/Current.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/ScIndex_/Minimum_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/ScIndex_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/__init__.py
--rw-rw-rw-   0        0        0     1045 2021-05-16 18:25:32.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/InbandEmission.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:40.041155 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/InbandEmission_/
--rw-rw-rw-   0        0        0     2003 2021-05-16 18:25:32.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/InbandEmission_/Margin.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:40.068082 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/InbandEmission_/Margin_/
--rw-rw-rw-   0        0        0     1478 2021-05-16 18:25:32.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/InbandEmission_/Margin_/Average.py
--rw-rw-rw-   0        0        0     1478 2021-05-16 18:25:32.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/InbandEmission_/Margin_/Current.py
--rw-rw-rw-   0        0        0     1478 2021-05-16 18:25:32.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/InbandEmission_/Margin_/Extreme.py
--rw-rw-rw-   0        0        0     1257 2021-05-16 18:25:32.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/InbandEmission_/Margin_/RbIndex.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:40.083042 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/InbandEmission_/Margin_/RbIndex_/
--rw-rw-rw-   0        0        0     1338 2021-05-16 18:25:32.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/InbandEmission_/Margin_/RbIndex_/Current.py
--rw-rw-rw-   0        0        0     1338 2021-05-16 18:25:32.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/InbandEmission_/Margin_/RbIndex_/Extreme.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/InbandEmission_/Margin_/RbIndex_/__init__.py
--rw-rw-rw-   0        0        0     1500 2021-05-16 18:25:32.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/InbandEmission_/Margin_/StandardDev.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/InbandEmission_/Margin_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/InbandEmission_/__init__.py
--rw-rw-rw-   0        0        0     3956 2021-05-16 18:25:29.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:40.146872 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/
--rw-rw-rw-   0        0        0     2327 2021-05-16 18:25:32.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Dallocation.py
--rw-rw-rw-   0        0        0     1686 2021-05-16 18:25:32.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/DchType.py
--rw-rw-rw-   0        0        0     1603 2021-05-16 18:25:32.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Dmodulation.py
--rw-rw-rw-   0        0        0     1386 2021-05-16 18:25:29.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:40.164824 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/
--rw-rw-rw-   0        0        0     1181 2021-05-16 18:25:30.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Dmrs.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:40.178787 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Dmrs_/
--rw-rw-rw-   0        0        0     1748 2021-05-16 18:25:30.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Dmrs_/High.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:40.200729 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Dmrs_/High_/
--rw-rw-rw-   0        0        0     2375 2021-05-16 18:25:30.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Dmrs_/High_/Average.py
--rw-rw-rw-   0        0        0     2375 2021-05-16 18:25:30.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Dmrs_/High_/Current.py
--rw-rw-rw-   0        0        0     2375 2021-05-16 18:25:30.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Dmrs_/High_/Extreme.py
--rw-rw-rw-   0        0        0     1468 2021-05-16 18:25:30.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Dmrs_/High_/StandardDev.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Dmrs_/High_/__init__.py
--rw-rw-rw-   0        0        0     1739 2021-05-16 18:25:30.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Dmrs_/Low.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:40.223668 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Dmrs_/Low_/
--rw-rw-rw-   0        0        0     2367 2021-05-16 18:25:30.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Dmrs_/Low_/Average.py
--rw-rw-rw-   0        0        0     2367 2021-05-16 18:25:30.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Dmrs_/Low_/Current.py
--rw-rw-rw-   0        0        0     2367 2021-05-16 18:25:30.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Dmrs_/Low_/Extreme.py
--rw-rw-rw-   0        0        0     1464 2021-05-16 18:25:30.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Dmrs_/Low_/StandardDev.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Dmrs_/Low_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Dmrs_/__init__.py
--rw-rw-rw-   0        0        0     1181 2021-05-16 18:25:30.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Peak.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:40.236633 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Peak_/
--rw-rw-rw-   0        0        0     1748 2021-05-16 18:25:30.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Peak_/High.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:40.261566 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Peak_/High_/
--rw-rw-rw-   0        0        0     2375 2021-05-16 18:25:30.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Peak_/High_/Average.py
--rw-rw-rw-   0        0        0     2375 2021-05-16 18:25:30.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Peak_/High_/Current.py
--rw-rw-rw-   0        0        0     2375 2021-05-16 18:25:30.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Peak_/High_/Extreme.py
--rw-rw-rw-   0        0        0     1468 2021-05-16 18:25:30.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Peak_/High_/StandardDev.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Peak_/High_/__init__.py
--rw-rw-rw-   0        0        0     1739 2021-05-16 18:25:30.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Peak_/Low.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:40.284505 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Peak_/Low_/
--rw-rw-rw-   0        0        0     2367 2021-05-16 18:25:30.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Peak_/Low_/Average.py
--rw-rw-rw-   0        0        0     2367 2021-05-16 18:25:30.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Peak_/Low_/Current.py
--rw-rw-rw-   0        0        0     2367 2021-05-16 18:25:30.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Peak_/Low_/Extreme.py
--rw-rw-rw-   0        0        0     1464 2021-05-16 18:25:30.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Peak_/Low_/StandardDev.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Peak_/Low_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Peak_/__init__.py
--rw-rw-rw-   0        0        0     1174 2021-05-16 18:25:30.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Rms.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:40.298975 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Rms_/
--rw-rw-rw-   0        0        0     1748 2021-05-16 18:25:30.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Rms_/High.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:40.324906 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Rms_/High_/
--rw-rw-rw-   0        0        0     2365 2021-05-16 18:25:30.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Rms_/High_/Average.py
--rw-rw-rw-   0        0        0     2365 2021-05-16 18:25:30.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Rms_/High_/Current.py
--rw-rw-rw-   0        0        0     2365 2021-05-16 18:25:30.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Rms_/High_/Extreme.py
--rw-rw-rw-   0        0        0     1463 2021-05-16 18:25:30.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Rms_/High_/StandardDev.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Rms_/High_/__init__.py
--rw-rw-rw-   0        0        0     1739 2021-05-16 18:25:30.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Rms_/Low.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:40.347844 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Rms_/Low_/
--rw-rw-rw-   0        0        0     2357 2021-05-16 18:25:30.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Rms_/Low_/Average.py
--rw-rw-rw-   0        0        0     2357 2021-05-16 18:25:30.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Rms_/Low_/Current.py
--rw-rw-rw-   0        0        0     2357 2021-05-16 18:25:30.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Rms_/Low_/Extreme.py
--rw-rw-rw-   0        0        0     1459 2021-05-16 18:25:30.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Rms_/Low_/StandardDev.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Rms_/Low_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Rms_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/__init__.py
--rw-rw-rw-   0        0        0     1789 2021-05-16 18:25:31.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/FreqError.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:40.369786 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/FreqError_/
--rw-rw-rw-   0        0        0     2247 2021-05-16 18:25:31.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/FreqError_/Average.py
--rw-rw-rw-   0        0        0     2247 2021-05-16 18:25:31.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/FreqError_/Current.py
--rw-rw-rw-   0        0        0     2247 2021-05-16 18:25:31.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/FreqError_/Extreme.py
--rw-rw-rw-   0        0        0     1400 2021-05-16 18:25:31.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/FreqError_/StandardDev.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/FreqError_/__init__.py
--rw-rw-rw-   0        0        0     1780 2021-05-16 18:25:31.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/IqOffset.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:40.392725 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/IqOffset_/
--rw-rw-rw-   0        0        0     2229 2021-05-16 18:25:31.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/IqOffset_/Average.py
--rw-rw-rw-   0        0        0     2229 2021-05-16 18:25:31.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/IqOffset_/Current.py
--rw-rw-rw-   0        0        0     2229 2021-05-16 18:25:31.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/IqOffset_/Extreme.py
--rw-rw-rw-   0        0        0     1391 2021-05-16 18:25:31.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/IqOffset_/StandardDev.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/IqOffset_/__init__.py
--rw-rw-rw-   0        0        0     1410 2021-05-16 18:25:30.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:40.412671 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/
--rw-rw-rw-   0        0        0     1181 2021-05-16 18:25:30.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Dmrs.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:40.427631 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Dmrs_/
--rw-rw-rw-   0        0        0     1748 2021-05-16 18:25:31.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Dmrs_/High.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:40.450570 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Dmrs_/High_/
--rw-rw-rw-   0        0        0     2387 2021-05-16 18:25:31.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Dmrs_/High_/Average.py
--rw-rw-rw-   0        0        0     2387 2021-05-16 18:25:31.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Dmrs_/High_/Current.py
--rw-rw-rw-   0        0        0     2387 2021-05-16 18:25:31.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Dmrs_/High_/Extreme.py
--rw-rw-rw-   0        0        0     1474 2021-05-16 18:25:31.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Dmrs_/High_/StandardDev.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Dmrs_/High_/__init__.py
--rw-rw-rw-   0        0        0     1739 2021-05-16 18:25:31.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Dmrs_/Low.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:40.473509 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Dmrs_/Low_/
--rw-rw-rw-   0        0        0     2379 2021-05-16 18:25:31.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Dmrs_/Low_/Average.py
--rw-rw-rw-   0        0        0     2379 2021-05-16 18:25:31.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Dmrs_/Low_/Current.py
--rw-rw-rw-   0        0        0     2379 2021-05-16 18:25:31.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Dmrs_/Low_/Extreme.py
--rw-rw-rw-   0        0        0     1470 2021-05-16 18:25:31.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Dmrs_/Low_/StandardDev.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Dmrs_/Low_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Dmrs_/__init__.py
--rw-rw-rw-   0        0        0     1181 2021-05-16 18:25:30.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Peak.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:40.486474 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Peak_/
--rw-rw-rw-   0        0        0     1748 2021-05-16 18:25:30.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Peak_/High.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:40.509919 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Peak_/High_/
--rw-rw-rw-   0        0        0     2387 2021-05-16 18:25:30.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Peak_/High_/Average.py
--rw-rw-rw-   0        0        0     2387 2021-05-16 18:25:30.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Peak_/High_/Current.py
--rw-rw-rw-   0        0        0     2387 2021-05-16 18:25:30.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Peak_/High_/Extreme.py
--rw-rw-rw-   0        0        0     1474 2021-05-16 18:25:30.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Peak_/High_/StandardDev.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Peak_/High_/__init__.py
--rw-rw-rw-   0        0        0     1739 2021-05-16 18:25:30.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Peak_/Low.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:40.534851 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Peak_/Low_/
--rw-rw-rw-   0        0        0     2383 2021-05-16 18:25:30.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Peak_/Low_/Average.py
--rw-rw-rw-   0        0        0     2383 2021-05-16 18:25:30.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Peak_/Low_/Current.py
--rw-rw-rw-   0        0        0     2383 2021-05-16 18:25:30.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Peak_/Low_/Extreme.py
--rw-rw-rw-   0        0        0     1472 2021-05-16 18:25:30.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Peak_/Low_/StandardDev.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Peak_/Low_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Peak_/__init__.py
--rw-rw-rw-   0        0        0     1174 2021-05-16 18:25:30.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Rms.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:40.549811 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Rms_/
--rw-rw-rw-   0        0        0     1748 2021-05-16 18:25:30.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Rms_/High.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:40.571754 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Rms_/High_/
--rw-rw-rw-   0        0        0     2381 2021-05-16 18:25:30.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Rms_/High_/Average.py
--rw-rw-rw-   0        0        0     2381 2021-05-16 18:25:30.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Rms_/High_/Current.py
--rw-rw-rw-   0        0        0     2381 2021-05-16 18:25:30.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Rms_/High_/Extreme.py
--rw-rw-rw-   0        0        0     1471 2021-05-16 18:25:30.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Rms_/High_/StandardDev.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Rms_/High_/__init__.py
--rw-rw-rw-   0        0        0     1739 2021-05-16 18:25:30.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Rms_/Low.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:40.594692 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Rms_/Low_/
--rw-rw-rw-   0        0        0     2373 2021-05-16 18:25:30.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Rms_/Low_/Average.py
--rw-rw-rw-   0        0        0     2373 2021-05-16 18:25:30.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Rms_/Low_/Current.py
--rw-rw-rw-   0        0        0     2373 2021-05-16 18:25:30.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Rms_/Low_/Extreme.py
--rw-rw-rw-   0        0        0     1467 2021-05-16 18:25:30.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Rms_/Low_/StandardDev.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Rms_/Low_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Rms_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/__init__.py
--rw-rw-rw-   0        0        0     1410 2021-05-16 18:25:31.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:40.611647 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/
--rw-rw-rw-   0        0        0     1181 2021-05-16 18:25:31.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Dmrs.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:40.624612 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Dmrs_/
--rw-rw-rw-   0        0        0     1748 2021-05-16 18:25:31.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Dmrs_/High.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:40.646553 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Dmrs_/High_/
--rw-rw-rw-   0        0        0     2381 2021-05-16 18:25:31.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Dmrs_/High_/Average.py
--rw-rw-rw-   0        0        0     2381 2021-05-16 18:25:31.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Dmrs_/High_/Current.py
--rw-rw-rw-   0        0        0     2381 2021-05-16 18:25:31.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Dmrs_/High_/Extreme.py
--rw-rw-rw-   0        0        0     1471 2021-05-16 18:25:31.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Dmrs_/High_/StandardDev.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Dmrs_/High_/__init__.py
--rw-rw-rw-   0        0        0     1739 2021-05-16 18:25:31.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Dmrs_/Low.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:40.668495 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Dmrs_/Low_/
--rw-rw-rw-   0        0        0     2373 2021-05-16 18:25:31.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Dmrs_/Low_/Average.py
--rw-rw-rw-   0        0        0     2373 2021-05-16 18:25:31.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Dmrs_/Low_/Current.py
--rw-rw-rw-   0        0        0     2373 2021-05-16 18:25:31.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Dmrs_/Low_/Extreme.py
--rw-rw-rw-   0        0        0     1467 2021-05-16 18:25:31.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Dmrs_/Low_/StandardDev.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Dmrs_/Low_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Dmrs_/__init__.py
--rw-rw-rw-   0        0        0     1181 2021-05-16 18:25:31.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Peak.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:40.682458 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Peak_/
--rw-rw-rw-   0        0        0     1748 2021-05-16 18:25:31.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Peak_/High.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:40.705396 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Peak_/High_/
--rw-rw-rw-   0        0        0     2381 2021-05-16 18:25:31.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Peak_/High_/Average.py
--rw-rw-rw-   0        0        0     2381 2021-05-16 18:25:31.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Peak_/High_/Current.py
--rw-rw-rw-   0        0        0     2381 2021-05-16 18:25:31.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Peak_/High_/Extreme.py
--rw-rw-rw-   0        0        0     1471 2021-05-16 18:25:31.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Peak_/High_/StandardDev.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Peak_/High_/__init__.py
--rw-rw-rw-   0        0        0     1739 2021-05-16 18:25:31.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Peak_/Low.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:40.730331 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Peak_/Low_/
--rw-rw-rw-   0        0        0     2373 2021-05-16 18:25:31.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Peak_/Low_/Average.py
--rw-rw-rw-   0        0        0     2373 2021-05-16 18:25:31.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Peak_/Low_/Current.py
--rw-rw-rw-   0        0        0     2373 2021-05-16 18:25:31.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Peak_/Low_/Extreme.py
--rw-rw-rw-   0        0        0     1467 2021-05-16 18:25:31.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Peak_/Low_/StandardDev.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Peak_/Low_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Peak_/__init__.py
--rw-rw-rw-   0        0        0     1174 2021-05-16 18:25:31.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Rms.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:40.744293 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Rms_/
--rw-rw-rw-   0        0        0     1748 2021-05-16 18:25:31.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Rms_/High.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:40.770224 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Rms_/High_/
--rw-rw-rw-   0        0        0     2371 2021-05-16 18:25:31.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Rms_/High_/Average.py
--rw-rw-rw-   0        0        0     2371 2021-05-16 18:25:31.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Rms_/High_/Current.py
--rw-rw-rw-   0        0        0     2371 2021-05-16 18:25:31.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Rms_/High_/Extreme.py
--rw-rw-rw-   0        0        0     1466 2021-05-16 18:25:31.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Rms_/High_/StandardDev.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Rms_/High_/__init__.py
--rw-rw-rw-   0        0        0     1739 2021-05-16 18:25:31.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Rms_/Low.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:40.795157 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Rms_/Low_/
--rw-rw-rw-   0        0        0     2363 2021-05-16 18:25:31.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Rms_/Low_/Average.py
--rw-rw-rw-   0        0        0     2363 2021-05-16 18:25:31.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Rms_/Low_/Current.py
--rw-rw-rw-   0        0        0     2363 2021-05-16 18:25:31.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Rms_/Low_/Extreme.py
--rw-rw-rw-   0        0        0     1462 2021-05-16 18:25:31.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Rms_/Low_/StandardDev.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Rms_/Low_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Rms_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/__init__.py
--rw-rw-rw-   0        0        0     2003 2021-05-16 18:25:32.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Ppower.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:40.824081 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Ppower_/
--rw-rw-rw-   0        0        0     2235 2021-05-16 18:25:32.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Ppower_/Average.py
--rw-rw-rw-   0        0        0     2235 2021-05-16 18:25:32.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Ppower_/Current.py
--rw-rw-rw-   0        0        0     2235 2021-05-16 18:25:32.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Ppower_/Maximum.py
--rw-rw-rw-   0        0        0     2235 2021-05-16 18:25:32.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Ppower_/Minimum.py
--rw-rw-rw-   0        0        0     1394 2021-05-16 18:25:32.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Ppower_/StandardDev.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Ppower_/__init__.py
--rw-rw-rw-   0        0        0     1973 2021-05-16 18:25:32.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Psd.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:40.852005 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Psd_/
--rw-rw-rw-   0        0        0     2219 2021-05-16 18:25:32.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Psd_/Average.py
--rw-rw-rw-   0        0        0     2219 2021-05-16 18:25:32.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Psd_/Current.py
--rw-rw-rw-   0        0        0     2219 2021-05-16 18:25:32.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Psd_/Maximum.py
--rw-rw-rw-   0        0        0     2219 2021-05-16 18:25:32.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Psd_/Minimum.py
--rw-rw-rw-   0        0        0     1386 2021-05-16 18:25:32.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Psd_/StandardDev.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Psd_/__init__.py
--rw-rw-rw-   0        0        0     1390 2021-05-16 18:25:32.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/SchType.py
--rw-rw-rw-   0        0        0     1762 2021-05-16 18:25:31.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Terror.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:40.876939 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Terror_/
--rw-rw-rw-   0        0        0     2227 2021-05-16 18:25:32.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Terror_/Average.py
--rw-rw-rw-   0        0        0     2227 2021-05-16 18:25:32.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Terror_/Current.py
--rw-rw-rw-   0        0        0     2227 2021-05-16 18:25:32.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Terror_/Extreme.py
--rw-rw-rw-   0        0        0     1390 2021-05-16 18:25:32.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Terror_/StandardDev.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Terror_/__init__.py
--rw-rw-rw-   0        0        0     2003 2021-05-16 18:25:32.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Tpower.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:40.905862 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Tpower_/
--rw-rw-rw-   0        0        0     2221 2021-05-16 18:25:32.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Tpower_/Average.py
--rw-rw-rw-   0        0        0     2221 2021-05-16 18:25:32.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Tpower_/Current.py
--rw-rw-rw-   0        0        0     2221 2021-05-16 18:25:32.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Tpower_/Maximum.py
--rw-rw-rw-   0        0        0     2221 2021-05-16 18:25:32.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Tpower_/Minimum.py
--rw-rw-rw-   0        0        0     1387 2021-05-16 18:25:32.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Tpower_/StandardDev.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Tpower_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/__init__.py
--rw-rw-rw-   0        0        0     1204 2021-05-16 18:25:35.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Pmonitor.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:40.921821 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Pmonitor_/
--rw-rw-rw-   0        0        0     1774 2021-05-16 18:25:35.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Pmonitor_/Peak.py
--rw-rw-rw-   0        0        0     1767 2021-05-16 18:25:35.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Pmonitor_/Rms.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Pmonitor_/__init__.py
--rw-rw-rw-   0        0        0      999 2021-05-16 18:25:35.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Power.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:40.933787 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Power_/
--rw-rw-rw-   0        0        0     2013 2021-05-16 18:25:35.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Power_/TxPower.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:40.971687 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Power_/TxPower_/
--rw-rw-rw-   0        0        0     1818 2021-05-16 18:25:35.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Power_/TxPower_/Average.py
--rw-rw-rw-   0        0        0     1818 2021-05-16 18:25:35.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Power_/TxPower_/Current.py
--rw-rw-rw-   0        0        0     1818 2021-05-16 18:25:35.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Power_/TxPower_/Maximum.py
--rw-rw-rw-   0        0        0     1818 2021-05-16 18:25:35.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Power_/TxPower_/Minimum.py
--rw-rw-rw-   0        0        0     1237 2021-05-16 18:25:35.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Power_/TxPower_/StandardDev.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Power_/TxPower_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Power_/__init__.py
--rw-rw-rw-   0        0        0     1962 2021-05-16 18:25:34.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/SeMask.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:41.005596 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/SeMask_/
--rw-rw-rw-   0        0        0     2315 2021-05-16 18:25:34.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/SeMask_/Dallocation.py
--rw-rw-rw-   0        0        0     1674 2021-05-16 18:25:34.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/SeMask_/DchType.py
--rw-rw-rw-   0        0        0      983 2021-05-16 18:25:34.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/SeMask_/Margin.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:41.015569 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/SeMask_/Margin_/
--rw-rw-rw-   0        0        0     2039 2021-05-16 18:25:34.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/SeMask_/Margin_/Area.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:41.030529 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/SeMask_/Margin_/Area_/
--rw-rw-rw-   0        0        0     1501 2021-05-16 18:25:34.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/SeMask_/Margin_/Area_/Negativ.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:41.048481 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/SeMask_/Margin_/Area_/Negativ_/
--rw-rw-rw-   0        0        0     2401 2021-05-16 18:25:34.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/SeMask_/Margin_/Area_/Negativ_/Average.py
--rw-rw-rw-   0        0        0     2407 2021-05-16 18:25:34.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/SeMask_/Margin_/Area_/Negativ_/Current.py
--rw-rw-rw-   0        0        0     2401 2021-05-16 18:25:34.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/SeMask_/Margin_/Area_/Negativ_/Minimum.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/SeMask_/Margin_/Area_/Negativ_/__init__.py
--rw-rw-rw-   0        0        0     1501 2021-05-16 18:25:34.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/SeMask_/Margin_/Area_/Positiv.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:41.069426 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/SeMask_/Margin_/Area_/Positiv_/
--rw-rw-rw-   0        0        0     2423 2021-05-16 18:25:34.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/SeMask_/Margin_/Area_/Positiv_/Average.py
--rw-rw-rw-   0        0        0     2429 2021-05-16 18:25:34.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/SeMask_/Margin_/Area_/Positiv_/Current.py
--rw-rw-rw-   0        0        0     2423 2021-05-16 18:25:34.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/SeMask_/Margin_/Area_/Positiv_/Minimum.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/SeMask_/Margin_/Area_/Positiv_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/SeMask_/Margin_/Area_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/SeMask_/Margin_/__init__.py
--rw-rw-rw-   0        0        0     1735 2021-05-16 18:25:34.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/SeMask_/Obw.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:41.094359 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/SeMask_/Obw_/
--rw-rw-rw-   0        0        0     2159 2021-05-16 18:25:34.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/SeMask_/Obw_/Average.py
--rw-rw-rw-   0        0        0     2159 2021-05-16 18:25:34.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/SeMask_/Obw_/Current.py
--rw-rw-rw-   0        0        0     2159 2021-05-16 18:25:34.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/SeMask_/Obw_/Extreme.py
--rw-rw-rw-   0        0        0     1356 2021-05-16 18:25:34.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/SeMask_/Obw_/StandardDev.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/SeMask_/Obw_/__init__.py
--rw-rw-rw-   0        0        0     2013 2021-05-16 18:25:34.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/SeMask_/TxPower.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:41.126273 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/SeMask_/TxPower_/
--rw-rw-rw-   0        0        0     2209 2021-05-16 18:25:34.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/SeMask_/TxPower_/Average.py
--rw-rw-rw-   0        0        0     2209 2021-05-16 18:25:34.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/SeMask_/TxPower_/Current.py
--rw-rw-rw-   0        0        0     2209 2021-05-16 18:25:34.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/SeMask_/TxPower_/Maximum.py
--rw-rw-rw-   0        0        0     2209 2021-05-16 18:25:34.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/SeMask_/TxPower_/Minimum.py
--rw-rw-rw-   0        0        0     1381 2021-05-16 18:25:34.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/SeMask_/TxPower_/StandardDev.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/SeMask_/TxPower_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/SeMask_/__init__.py
--rw-rw-rw-   0        0        0     3360 2021-05-16 18:25:33.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:41.164173 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/
--rw-rw-rw-   0        0        0     2015 2021-05-16 18:25:34.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/Aclr.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:41.193095 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/Aclr_/
--rw-rw-rw-   0        0        0     6730 2021-05-16 18:25:34.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/Aclr_/Average.py
--rw-rw-rw-   0        0        0     6730 2021-05-16 18:25:34.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/Aclr_/Current.py
--rw-rw-rw-   0        0        0     2460 2021-05-16 18:25:34.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/Aclr_/Dallocation.py
--rw-rw-rw-   0        0        0     2303 2021-05-16 18:25:34.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/Aclr_/DchType.py
--rw-rw-rw-   0        0        0     1932 2021-05-16 18:25:34.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/Aclr_/Dmodulation.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/Aclr_/__init__.py
--rw-rw-rw-   0        0        0     1798 2021-05-16 18:25:33.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/EsFlatness.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:41.214040 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/EsFlatness_/
--rw-rw-rw-   0        0        0     5229 2021-05-16 18:25:33.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/EsFlatness_/Average.py
--rw-rw-rw-   0        0        0     5853 2021-05-16 18:25:33.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/EsFlatness_/Current.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:41.223016 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/EsFlatness_/Current_/
--rw-rw-rw-   0        0        0     2759 2021-05-16 18:25:33.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/EsFlatness_/Current_/ScIndex.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/EsFlatness_/Current_/__init__.py
--rw-rw-rw-   0        0        0     5229 2021-05-16 18:25:33.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/EsFlatness_/Extreme.py
--rw-rw-rw-   0        0        0     5057 2021-05-16 18:25:33.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/EsFlatness_/StandardDev.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/EsFlatness_/__init__.py
--rw-rw-rw-   0        0        0     1474 2021-05-16 18:25:33.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:41.240968 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/
--rw-rw-rw-   0        0        0     1912 2021-05-16 18:25:33.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Cc.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:41.248946 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Cc_/
--rw-rw-rw-   0        0        0     1766 2021-05-16 18:25:33.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Cc_/Margin.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:41.272884 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Cc_/Margin_/
--rw-rw-rw-   0        0        0     2896 2021-05-16 18:25:33.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Cc_/Margin_/Average.py
--rw-rw-rw-   0        0        0     3520 2021-05-16 18:25:33.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Cc_/Margin_/Current.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:41.280861 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Cc_/Margin_/Current_/
--rw-rw-rw-   0        0        0     2763 2021-05-16 18:25:33.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Cc_/Margin_/Current_/RbIndex.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Cc_/Margin_/Current_/__init__.py
--rw-rw-rw-   0        0        0     3520 2021-05-16 18:25:33.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Cc_/Margin_/Extreme.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:41.289838 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Cc_/Margin_/Extreme_/
--rw-rw-rw-   0        0        0     2763 2021-05-16 18:25:33.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Cc_/Margin_/Extreme_/RbIndex.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Cc_/Margin_/Extreme_/__init__.py
--rw-rw-rw-   0        0        0     2918 2021-05-16 18:25:33.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Cc_/Margin_/StandardDev.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Cc_/Margin_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Cc_/__init__.py
--rw-rw-rw-   0        0        0     1764 2021-05-16 18:25:33.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Margin.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:41.313773 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Margin_/
--rw-rw-rw-   0        0        0     2151 2021-05-16 18:25:33.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Margin_/Average.py
--rw-rw-rw-   0        0        0     2775 2021-05-16 18:25:33.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Margin_/Current.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:41.324746 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Margin_/Current_/
--rw-rw-rw-   0        0        0     2180 2021-05-16 18:25:33.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Margin_/Current_/RbIndex.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Margin_/Current_/__init__.py
--rw-rw-rw-   0        0        0     2775 2021-05-16 18:25:33.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Margin_/Extreme.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:41.333720 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Margin_/Extreme_/
--rw-rw-rw-   0        0        0     2180 2021-05-16 18:25:33.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Margin_/Extreme_/RbIndex.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Margin_/Extreme_/__init__.py
--rw-rw-rw-   0        0        0     2173 2021-05-16 18:25:33.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Margin_/StandardDev.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Margin_/__init__.py
--rw-rw-rw-   0        0        0     1863 2021-05-16 18:25:33.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Scc.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:41.344691 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Scc_/
--rw-rw-rw-   0        0        0     1766 2021-05-16 18:25:33.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Scc_/Margin.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:41.370622 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Scc_/Margin_/
--rw-rw-rw-   0        0        0     2478 2021-05-16 18:25:33.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Scc_/Margin_/Average.py
--rw-rw-rw-   0        0        0     3102 2021-05-16 18:25:33.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Scc_/Margin_/Current.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:41.379598 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Scc_/Margin_/Current_/
--rw-rw-rw-   0        0        0     2507 2021-05-16 18:25:33.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Scc_/Margin_/Current_/RbIndex.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Scc_/Margin_/Current_/__init__.py
--rw-rw-rw-   0        0        0     3102 2021-05-16 18:25:33.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Scc_/Margin_/Extreme.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:41.387577 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Scc_/Margin_/Extreme_/
--rw-rw-rw-   0        0        0     2507 2021-05-16 18:25:33.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Scc_/Margin_/Extreme_/RbIndex.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Scc_/Margin_/Extreme_/__init__.py
--rw-rw-rw-   0        0        0     2500 2021-05-16 18:25:33.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Scc_/Margin_/StandardDev.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Scc_/Margin_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Scc_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/__init__.py
--rw-rw-rw-   0        0        0     2843 2021-05-16 18:25:33.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/Modulation.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:41.428467 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/Modulation_/
--rw-rw-rw-   0        0        0    13003 2021-05-16 18:25:33.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/Modulation_/Average.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:41.456394 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/Modulation_/Average_/
--rw-rw-rw-   0        0        0     2467 2021-05-16 18:25:33.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/Modulation_/Average_/Dmrs.py
--rw-rw-rw-   0        0        0     3322 2021-05-16 18:25:33.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/Modulation_/Average_/Emph.py
--rw-rw-rw-   0        0        0     2036 2021-05-16 18:25:33.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/Modulation_/Average_/Globale.py
--rw-rw-rw-   0        0        0     2002 2021-05-16 18:25:33.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/Modulation_/Average_/Mod.py
--rw-rw-rw-   0        0        0     1957 2021-05-16 18:25:33.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/Modulation_/Average_/Pow.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/Modulation_/Average_/__init__.py
--rw-rw-rw-   0        0        0    11523 2021-05-16 18:25:33.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/Modulation_/Current.py
--rw-rw-rw-   0        0        0     2478 2021-05-16 18:25:33.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/Modulation_/Dallocation.py
--rw-rw-rw-   0        0        0     2321 2021-05-16 18:25:33.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/Modulation_/DchType.py
--rw-rw-rw-   0        0        0     2206 2021-05-16 18:25:33.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/Modulation_/Dmodulation.py
--rw-rw-rw-   0        0        0    12495 2021-05-16 18:25:33.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/Modulation_/Extreme.py
--rw-rw-rw-   0        0        0     2038 2021-05-16 18:25:33.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/Modulation_/SchType.py
--rw-rw-rw-   0        0        0    10876 2021-05-16 18:25:33.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/Modulation_/StandardDev.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/Modulation_/__init__.py
--rw-rw-rw-   0        0        0     1433 2021-05-16 18:25:34.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/Pmonitor.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:41.473348 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/Pmonitor_/
--rw-rw-rw-   0        0        0     1219 2021-05-16 18:25:34.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/Pmonitor_/Array.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:41.487311 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/Pmonitor_/Array_/
--rw-rw-rw-   0        0        0     1666 2021-05-16 18:25:34.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/Pmonitor_/Array_/Length.py
--rw-rw-rw-   0        0        0     1833 2021-05-16 18:25:34.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/Pmonitor_/Array_/Start.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/Pmonitor_/Array_/__init__.py
--rw-rw-rw-   0        0        0     2386 2021-05-16 18:25:34.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/Pmonitor_/Peak.py
--rw-rw-rw-   0        0        0     2377 2021-05-16 18:25:34.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/Pmonitor_/Rms.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/Pmonitor_/__init__.py
--rw-rw-rw-   0        0        0     1993 2021-05-16 18:25:34.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/Power.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:41.517230 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/Power_/
--rw-rw-rw-   0        0        0     3846 2021-05-16 18:25:34.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/Power_/Average.py
--rw-rw-rw-   0        0        0     3846 2021-05-16 18:25:34.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/Power_/Current.py
--rw-rw-rw-   0        0        0     3870 2021-05-16 18:25:34.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/Power_/Maximum.py
--rw-rw-rw-   0        0        0     3870 2021-05-16 18:25:34.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/Power_/Minimum.py
--rw-rw-rw-   0        0        0     2231 2021-05-16 18:25:34.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/Power_/StandardDev.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/Power_/__init__.py
--rw-rw-rw-   0        0        0     2783 2021-05-16 18:25:33.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/SeMask.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:41.564106 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/SeMask_/
--rw-rw-rw-   0        0        0     4703 2021-05-16 18:25:33.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/SeMask_/Average.py
--rw-rw-rw-   0        0        0     4703 2021-05-16 18:25:33.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/SeMask_/Current.py
--rw-rw-rw-   0        0        0     2466 2021-05-16 18:25:34.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/SeMask_/Dallocation.py
--rw-rw-rw-   0        0        0     2309 2021-05-16 18:25:34.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/SeMask_/DchType.py
--rw-rw-rw-   0        0        0     1938 2021-05-16 18:25:34.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/SeMask_/Dmodulation.py
--rw-rw-rw-   0        0        0     5011 2021-05-16 18:25:33.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/SeMask_/Extreme.py
--rw-rw-rw-   0        0        0     4462 2021-05-16 18:25:33.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/SeMask_/Margin.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:41.587046 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/SeMask_/Margin_/
--rw-rw-rw-   0        0        0     3325 2021-05-16 18:25:33.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/SeMask_/Margin_/All.py
--rw-rw-rw-   0        0        0     1259 2021-05-16 18:25:34.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/SeMask_/Margin_/Average.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:41.602006 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/SeMask_/Margin_/Average_/
--rw-rw-rw-   0        0        0     2898 2021-05-16 18:25:34.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/SeMask_/Margin_/Average_/Negativ.py
--rw-rw-rw-   0        0        0     2898 2021-05-16 18:25:34.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/SeMask_/Margin_/Average_/Positiv.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/SeMask_/Margin_/Average_/__init__.py
--rw-rw-rw-   0        0        0     1259 2021-05-16 18:25:33.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/SeMask_/Margin_/Current.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:41.616965 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/SeMask_/Margin_/Current_/
--rw-rw-rw-   0        0        0     2904 2021-05-16 18:25:33.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/SeMask_/Margin_/Current_/Negativ.py
--rw-rw-rw-   0        0        0     2904 2021-05-16 18:25:34.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/SeMask_/Margin_/Current_/Positiv.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/SeMask_/Margin_/Current_/__init__.py
--rw-rw-rw-   0        0        0     1259 2021-05-16 18:25:34.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/SeMask_/Margin_/Minimum.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:41.629929 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/SeMask_/Margin_/Minimum_/
--rw-rw-rw-   0        0        0     2898 2021-05-16 18:25:34.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/SeMask_/Margin_/Minimum_/Negativ.py
--rw-rw-rw-   0        0        0     2898 2021-05-16 18:25:34.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/SeMask_/Margin_/Minimum_/Positiv.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/SeMask_/Margin_/Minimum_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/SeMask_/Margin_/__init__.py
--rw-rw-rw-   0        0        0     4367 2021-05-16 18:25:33.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/SeMask_/StandardDev.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/SeMask_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/__init__.py
--rw-rw-rw-   0        0        0     1657 2021-05-16 18:25:29.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Sreliability.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/__init__.py
--rw-rw-rw-   0        0        0     1486 2021-05-16 18:25:27.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Merror.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:41.647882 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Merror_/
--rw-rw-rw-   0        0        0     4598 2021-05-16 18:25:27.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Merror_/Average.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:41.658852 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Merror_/Average_/
--rw-rw-rw-   0        0        0     3090 2021-05-16 18:25:27.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Merror_/Average_/Nref.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Merror_/Average_/__init__.py
--rw-rw-rw-   0        0        0     4598 2021-05-16 18:25:27.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Merror_/Current.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:41.667828 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Merror_/Current_/
--rw-rw-rw-   0        0        0     3090 2021-05-16 18:25:27.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Merror_/Current_/Nref.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Merror_/Current_/__init__.py
--rw-rw-rw-   0        0        0     4598 2021-05-16 18:25:27.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Merror_/Maximum.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:41.676804 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Merror_/Maximum_/
--rw-rw-rw-   0        0        0     3090 2021-05-16 18:25:27.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Merror_/Maximum_/Nref.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Merror_/Maximum_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Merror_/__init__.py
--rw-rw-rw-   0        0        0     2839 2021-05-16 18:25:28.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Modulation.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:41.717695 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Modulation_/
--rw-rw-rw-   0        0        0    11707 2021-05-16 18:25:28.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Modulation_/Average.py
--rw-rw-rw-   0        0        0    11707 2021-05-16 18:25:28.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Modulation_/Current.py
--rw-rw-rw-   0        0        0     1957 2021-05-16 18:25:28.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Modulation_/Dallocation.py
--rw-rw-rw-   0        0        0     1544 2021-05-16 18:25:28.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Modulation_/DchType.py
--rw-rw-rw-   0        0        0     1379 2021-05-16 18:25:28.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Modulation_/Dmodulation.py
--rw-rw-rw-   0        0        0    12481 2021-05-16 18:25:28.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Modulation_/Extreme.py
--rw-rw-rw-   0        0        0     1256 2021-05-16 18:25:28.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Modulation_/SchType.py
--rw-rw-rw-   0        0        0    10896 2021-05-16 18:25:28.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Modulation_/StandardDev.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Modulation_/__init__.py
--rw-rw-rw-   0        0        0     2030 2021-05-16 18:25:29.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Pdynamics.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:41.747616 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Pdynamics_/
--rw-rw-rw-   0        0        0     6270 2021-05-16 18:25:29.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Pdynamics_/Average.py
--rw-rw-rw-   0        0        0     6270 2021-05-16 18:25:29.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Pdynamics_/Current.py
--rw-rw-rw-   0        0        0     6270 2021-05-16 18:25:29.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Pdynamics_/Maximum.py
--rw-rw-rw-   0        0        0     6270 2021-05-16 18:25:29.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Pdynamics_/Minimum.py
--rw-rw-rw-   0        0        0     5470 2021-05-16 18:25:29.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Pdynamics_/StandardDev.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Pdynamics_/__init__.py
--rw-rw-rw-   0        0        0     1486 2021-05-16 18:25:27.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Perror.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:41.766566 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Perror_/
--rw-rw-rw-   0        0        0     4574 2021-05-16 18:25:27.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Perror_/Average.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:41.778533 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Perror_/Average_/
--rw-rw-rw-   0        0        0     3090 2021-05-16 18:25:27.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Perror_/Average_/Nref.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Perror_/Average_/__init__.py
--rw-rw-rw-   0        0        0     4574 2021-05-16 18:25:27.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Perror_/Current.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:41.788508 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Perror_/Current_/
--rw-rw-rw-   0        0        0     3090 2021-05-16 18:25:27.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Perror_/Current_/Nref.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Perror_/Current_/__init__.py
--rw-rw-rw-   0        0        0     4574 2021-05-16 18:25:27.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Perror_/Maximum.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:41.797483 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Perror_/Maximum_/
--rw-rw-rw-   0        0        0     3090 2021-05-16 18:25:27.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Perror_/Maximum_/Nref.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Perror_/Maximum_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Perror_/__init__.py
--rw-rw-rw-   0        0        0     2864 2021-05-16 18:25:29.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Pmonitor.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:41.847349 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Pmonitor_/
--rw-rw-rw-   0        0        0     3143 2021-05-16 18:25:29.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Pmonitor_/Average.py
--rw-rw-rw-   0        0        0     2893 2021-05-16 18:25:29.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Pmonitor_/Cc.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:41.875275 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Pmonitor_/Cc_/
--rw-rw-rw-   0        0        0     2830 2021-05-16 18:25:29.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Pmonitor_/Cc_/Average.py
--rw-rw-rw-   0        0        0     2830 2021-05-16 18:25:29.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Pmonitor_/Cc_/Current.py
--rw-rw-rw-   0        0        0     2830 2021-05-16 18:25:29.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Pmonitor_/Cc_/Maximum.py
--rw-rw-rw-   0        0        0     2830 2021-05-16 18:25:29.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Pmonitor_/Cc_/Minimum.py
--rw-rw-rw-   0        0        0     2862 2021-05-16 18:25:29.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Pmonitor_/Cc_/StandardDev.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Pmonitor_/Cc_/__init__.py
--rw-rw-rw-   0        0        0     3143 2021-05-16 18:25:29.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Pmonitor_/Current.py
--rw-rw-rw-   0        0        0     3143 2021-05-16 18:25:29.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Pmonitor_/Maximum.py
--rw-rw-rw-   0        0        0     3143 2021-05-16 18:25:29.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Pmonitor_/Minimum.py
--rw-rw-rw-   0        0        0     1972 2021-05-16 18:25:29.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Pmonitor_/Pcc.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:41.904199 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Pmonitor_/Pcc_/
--rw-rw-rw-   0        0        0     1959 2021-05-16 18:25:29.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Pmonitor_/Pcc_/Average.py
--rw-rw-rw-   0        0        0     1959 2021-05-16 18:25:29.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Pmonitor_/Pcc_/Current.py
--rw-rw-rw-   0        0        0     1959 2021-05-16 18:25:29.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Pmonitor_/Pcc_/Maximum.py
--rw-rw-rw-   0        0        0     1959 2021-05-16 18:25:29.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Pmonitor_/Pcc_/Minimum.py
--rw-rw-rw-   0        0        0     1991 2021-05-16 18:25:29.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Pmonitor_/Pcc_/StandardDev.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Pmonitor_/Pcc_/__init__.py
--rw-rw-rw-   0        0        0     1972 2021-05-16 18:25:29.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Pmonitor_/Scc.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:41.933120 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Pmonitor_/Scc_/
--rw-rw-rw-   0        0        0     1959 2021-05-16 18:25:29.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Pmonitor_/Scc_/Average.py
--rw-rw-rw-   0        0        0     1959 2021-05-16 18:25:29.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Pmonitor_/Scc_/Current.py
--rw-rw-rw-   0        0        0     1959 2021-05-16 18:25:29.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Pmonitor_/Scc_/Maximum.py
--rw-rw-rw-   0        0        0     1959 2021-05-16 18:25:29.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Pmonitor_/Scc_/Minimum.py
--rw-rw-rw-   0        0        0     1991 2021-05-16 18:25:29.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Pmonitor_/Scc_/StandardDev.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Pmonitor_/Scc_/__init__.py
--rw-rw-rw-   0        0        0     3185 2021-05-16 18:25:29.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Pmonitor_/StandardDev.py
--rw-rw-rw-   0        0        0     1169 2021-05-16 18:25:29.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Pmonitor_/Ulca.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:41.946086 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Pmonitor_/Ulca_/
--rw-rw-rw-   0        0        0     1974 2021-05-16 18:25:29.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Pmonitor_/Ulca_/Pcc.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:41.976007 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Pmonitor_/Ulca_/Pcc_/
--rw-rw-rw-   0        0        0     1993 2021-05-16 18:25:29.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Pmonitor_/Ulca_/Pcc_/Average.py
--rw-rw-rw-   0        0        0     1993 2021-05-16 18:25:29.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Pmonitor_/Ulca_/Pcc_/Current.py
--rw-rw-rw-   0        0        0     1993 2021-05-16 18:25:29.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Pmonitor_/Ulca_/Pcc_/Maximum.py
--rw-rw-rw-   0        0        0     1993 2021-05-16 18:25:29.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Pmonitor_/Ulca_/Pcc_/Minimum.py
--rw-rw-rw-   0        0        0     2025 2021-05-16 18:25:29.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Pmonitor_/Ulca_/Pcc_/StandardDev.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Pmonitor_/Ulca_/Pcc_/__init__.py
--rw-rw-rw-   0        0        0     2852 2021-05-16 18:25:29.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Pmonitor_/Ulca_/Scc.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:42.003933 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Pmonitor_/Ulca_/Scc_/
--rw-rw-rw-   0        0        0     2637 2021-05-16 18:25:29.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Pmonitor_/Ulca_/Scc_/Average.py
--rw-rw-rw-   0        0        0     2637 2021-05-16 18:25:29.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Pmonitor_/Ulca_/Scc_/Current.py
--rw-rw-rw-   0        0        0     2637 2021-05-16 18:25:29.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Pmonitor_/Ulca_/Scc_/Maximum.py
--rw-rw-rw-   0        0        0     2637 2021-05-16 18:25:29.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Pmonitor_/Ulca_/Scc_/Minimum.py
--rw-rw-rw-   0        0        0     2669 2021-05-16 18:25:29.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Pmonitor_/Ulca_/Scc_/StandardDev.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Pmonitor_/Ulca_/Scc_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Pmonitor_/Ulca_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Pmonitor_/__init__.py
--rw-rw-rw-   0        0        0     2988 2021-05-16 18:25:28.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/SeMask.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:42.048812 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/SeMask_/
--rw-rw-rw-   0        0        0     4264 2021-05-16 18:25:28.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/SeMask_/Average.py
--rw-rw-rw-   0        0        0     4264 2021-05-16 18:25:28.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/SeMask_/Current.py
--rw-rw-rw-   0        0        0     1945 2021-05-16 18:25:29.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/SeMask_/Dallocation.py
--rw-rw-rw-   0        0        0     1532 2021-05-16 18:25:29.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/SeMask_/DchType.py
--rw-rw-rw-   0        0        0     4424 2021-05-16 18:25:28.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/SeMask_/Extreme.py
--rw-rw-rw-   0        0        0     3838 2021-05-16 18:25:28.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/SeMask_/Margin.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:42.072584 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/SeMask_/Margin_/
--rw-rw-rw-   0        0        0     3055 2021-05-16 18:25:28.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/SeMask_/Margin_/All.py
--rw-rw-rw-   0        0        0     1255 2021-05-16 18:25:29.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/SeMask_/Margin_/Average.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:42.085550 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/SeMask_/Margin_/Average_/
--rw-rw-rw-   0        0        0     2551 2021-05-16 18:25:29.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/SeMask_/Margin_/Average_/Negativ.py
--rw-rw-rw-   0        0        0     2551 2021-05-16 18:25:29.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/SeMask_/Margin_/Average_/Positiv.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/SeMask_/Margin_/Average_/__init__.py
--rw-rw-rw-   0        0        0     1255 2021-05-16 18:25:28.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/SeMask_/Margin_/Current.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:42.098514 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/SeMask_/Margin_/Current_/
--rw-rw-rw-   0        0        0     2557 2021-05-16 18:25:29.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/SeMask_/Margin_/Current_/Negativ.py
--rw-rw-rw-   0        0        0     2557 2021-05-16 18:25:29.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/SeMask_/Margin_/Current_/Positiv.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/SeMask_/Margin_/Current_/__init__.py
--rw-rw-rw-   0        0        0     1255 2021-05-16 18:25:29.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/SeMask_/Margin_/Minimum.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:42.111480 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/SeMask_/Margin_/Minimum_/
--rw-rw-rw-   0        0        0     2551 2021-05-16 18:25:29.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/SeMask_/Margin_/Minimum_/Negativ.py
--rw-rw-rw-   0        0        0     2551 2021-05-16 18:25:29.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/SeMask_/Margin_/Minimum_/Positiv.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/SeMask_/Margin_/Minimum_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/SeMask_/Margin_/__init__.py
--rw-rw-rw-   0        0        0     3181 2021-05-16 18:25:28.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/SeMask_/Maximum.py
--rw-rw-rw-   0        0        0     2971 2021-05-16 18:25:28.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/SeMask_/Minimum.py
--rw-rw-rw-   0        0        0     3890 2021-05-16 18:25:28.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/SeMask_/StandardDev.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/SeMask_/__init__.py
--rw-rw-rw-   0        0        0     1823 2021-05-16 18:25:26.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/State.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:42.119459 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/State_/
--rw-rw-rw-   0        0        0     2405 2021-05-16 18:25:26.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/State_/All.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/State_/__init__.py
--rw-rw-rw-   0        0        0     3159 2021-05-16 18:25:26.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Trace.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:42.167331 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Trace_/
--rw-rw-rw-   0        0        0     1232 2021-05-16 18:25:27.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Trace_/Aclr.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:42.181294 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Trace_/Aclr_/
--rw-rw-rw-   0        0        0     2979 2021-05-16 18:25:27.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Trace_/Aclr_/Average.py
--rw-rw-rw-   0        0        0     2979 2021-05-16 18:25:27.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Trace_/Aclr_/Current.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Trace_/Aclr_/__init__.py
--rw-rw-rw-   0        0        0     2595 2021-05-16 18:25:27.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Trace_/EsFlatness.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:42.191267 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Trace_/EsFlatness_/
--rw-rw-rw-   0        0        0     2003 2021-05-16 18:25:27.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Trace_/EsFlatness_/Phase.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Trace_/EsFlatness_/__init__.py
--rw-rw-rw-   0        0        0     1511 2021-05-16 18:25:27.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Trace_/EvmSymbol.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:42.210216 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Trace_/EvmSymbol_/
--rw-rw-rw-   0        0        0     1873 2021-05-16 18:25:27.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Trace_/EvmSymbol_/Average.py
--rw-rw-rw-   0        0        0     1873 2021-05-16 18:25:27.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Trace_/EvmSymbol_/Current.py
--rw-rw-rw-   0        0        0     1873 2021-05-16 18:25:27.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Trace_/EvmSymbol_/Maximum.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Trace_/EvmSymbol_/__init__.py
--rw-rw-rw-   0        0        0     1880 2021-05-16 18:25:27.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Trace_/Evmc.py
--rw-rw-rw-   0        0        0     1637 2021-05-16 18:25:26.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Trace_/Iemissions.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:42.231161 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Trace_/Iemissions_/
--rw-rw-rw-   0        0        0     3891 2021-05-16 18:25:27.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Trace_/Iemissions_/Cc.py
--rw-rw-rw-   0        0        0     1637 2021-05-16 18:25:27.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Trace_/Iemissions_/Pcc.py
--rw-rw-rw-   0        0        0     1633 2021-05-16 18:25:26.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Trace_/Iemissions_/Scc.py
--rw-rw-rw-   0        0        0     1170 2021-05-16 18:25:26.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Trace_/Iemissions_/Ulca.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:42.245124 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Trace_/Iemissions_/Ulca_/
--rw-rw-rw-   0        0        0     1671 2021-05-16 18:25:27.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Trace_/Iemissions_/Ulca_/Pcc.py
--rw-rw-rw-   0        0        0     3539 2021-05-16 18:25:26.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Trace_/Iemissions_/Ulca_/Scc.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Trace_/Iemissions_/Ulca_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Trace_/Iemissions_/__init__.py
--rw-rw-rw-   0        0        0     1162 2021-05-16 18:25:26.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Trace_/Iq.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:42.259086 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Trace_/Iq_/
--rw-rw-rw-   0        0        0     1875 2021-05-16 18:25:26.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Trace_/Iq_/High.py
--rw-rw-rw-   0        0        0     1869 2021-05-16 18:25:26.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Trace_/Iq_/Low.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Trace_/Iq_/__init__.py
--rw-rw-rw-   0        0        0     1511 2021-05-16 18:25:27.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Trace_/Pdynamics.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:42.277039 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Trace_/Pdynamics_/
--rw-rw-rw-   0        0        0     2551 2021-05-16 18:25:27.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Trace_/Pdynamics_/Average.py
--rw-rw-rw-   0        0        0     2551 2021-05-16 18:25:27.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Trace_/Pdynamics_/Current.py
--rw-rw-rw-   0        0        0     2551 2021-05-16 18:25:27.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Trace_/Pdynamics_/Maximum.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Trace_/Pdynamics_/__init__.py
--rw-rw-rw-   0        0        0     1619 2021-05-16 18:25:27.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Trace_/Pmonitor.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:42.299976 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Trace_/Pmonitor_/
--rw-rw-rw-   0        0        0     3795 2021-05-16 18:25:27.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Trace_/Pmonitor_/Cc.py
--rw-rw-rw-   0        0        0     1625 2021-05-16 18:25:27.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Trace_/Pmonitor_/Pcc.py
--rw-rw-rw-   0        0        0     1621 2021-05-16 18:25:27.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Trace_/Pmonitor_/Scc.py
--rw-rw-rw-   0        0        0     1170 2021-05-16 18:25:27.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Trace_/Pmonitor_/Ulca.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:42.313939 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Trace_/Pmonitor_/Ulca_/
--rw-rw-rw-   0        0        0     1659 2021-05-16 18:25:27.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Trace_/Pmonitor_/Ulca_/Pcc.py
--rw-rw-rw-   0        0        0     3527 2021-05-16 18:25:27.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Trace_/Pmonitor_/Ulca_/Scc.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Trace_/Pmonitor_/Ulca_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Trace_/Pmonitor_/__init__.py
--rw-rw-rw-   0        0        0     1619 2021-05-16 18:25:26.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Trace_/RbaTable.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:42.336879 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Trace_/RbaTable_/
--rw-rw-rw-   0        0        0     5552 2021-05-16 18:25:26.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Trace_/RbaTable_/Cc.py
--rw-rw-rw-   0        0        0     2313 2021-05-16 18:25:26.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Trace_/RbaTable_/Pcc.py
--rw-rw-rw-   0        0        0     2309 2021-05-16 18:25:26.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Trace_/RbaTable_/Scc.py
--rw-rw-rw-   0        0        0     1170 2021-05-16 18:25:26.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Trace_/RbaTable_/Ulca.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:42.350841 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Trace_/RbaTable_/Ulca_/
--rw-rw-rw-   0        0        0     2349 2021-05-16 18:25:26.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Trace_/RbaTable_/Ulca_/Pcc.py
--rw-rw-rw-   0        0        0     4217 2021-05-16 18:25:26.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Trace_/RbaTable_/Ulca_/Scc.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Trace_/RbaTable_/Ulca_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Trace_/RbaTable_/__init__.py
--rw-rw-rw-   0        0        0      973 2021-05-16 18:25:27.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Trace_/SeMask.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:42.358352 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Trace_/SeMask_/
--rw-rw-rw-   0        0        0     2294 2021-05-16 18:25:27.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Trace_/SeMask_/Rbw.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:42.378299 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Trace_/SeMask_/Rbw_/
--rw-rw-rw-   0        0        0     3375 2021-05-16 18:25:27.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Trace_/SeMask_/Rbw_/Average.py
--rw-rw-rw-   0        0        0     3375 2021-05-16 18:25:27.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Trace_/SeMask_/Rbw_/Current.py
--rw-rw-rw-   0        0        0     3375 2021-05-16 18:25:27.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Trace_/SeMask_/Rbw_/Maximum.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Trace_/SeMask_/Rbw_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Trace_/SeMask_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Trace_/__init__.py
--rw-rw-rw-   0        0        0     1091 2021-05-16 18:25:27.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/VfThroughput.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/__init__.py
--rw-rw-rw-   0        0        0     6731 2021-05-16 18:25:35.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Prach.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:42.402235 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Prach_/
--rw-rw-rw-   0        0        0     2839 2021-05-16 18:25:35.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Prach_/Modulation.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:42.443126 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Prach_/Modulation_/
--rw-rw-rw-   0        0        0     8473 2021-05-16 18:25:35.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Prach_/Modulation_/Average.py
--rw-rw-rw-   0        0        0     8473 2021-05-16 18:25:35.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Prach_/Modulation_/Current.py
--rw-rw-rw-   0        0        0     1815 2021-05-16 18:25:36.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Prach_/Modulation_/DpfOffset.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:42.450110 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Prach_/Modulation_/DpfOffset_/
--rw-rw-rw-   0        0        0     2750 2021-05-16 18:25:36.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Prach_/Modulation_/DpfOffset_/Preamble.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Prach_/Modulation_/DpfOffset_/__init__.py
--rw-rw-rw-   0        0        0     1778 2021-05-16 18:25:36.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Prach_/Modulation_/DsIndex.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:42.459631 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Prach_/Modulation_/DsIndex_/
--rw-rw-rw-   0        0        0     2725 2021-05-16 18:25:36.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Prach_/Modulation_/DsIndex_/Preamble.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Prach_/Modulation_/DsIndex_/__init__.py
--rw-rw-rw-   0        0        0     9062 2021-05-16 18:25:36.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Prach_/Modulation_/Extreme.py
--rw-rw-rw-   0        0        0     6313 2021-05-16 18:25:35.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Prach_/Modulation_/Preamble.py
--rw-rw-rw-   0        0        0     2069 2021-05-16 18:25:36.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Prach_/Modulation_/Scorrelation.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:42.467610 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Prach_/Modulation_/Scorrelation_/
--rw-rw-rw-   0        0        0     2984 2021-05-16 18:25:36.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Prach_/Modulation_/Scorrelation_/Preamble.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Prach_/Modulation_/Scorrelation_/__init__.py
--rw-rw-rw-   0        0        0     7973 2021-05-16 18:25:36.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Prach_/Modulation_/StandardDev.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Prach_/Modulation_/__init__.py
--rw-rw-rw-   0        0        0     2030 2021-05-16 18:25:36.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Prach_/Pdynamics.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:42.496532 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Prach_/Pdynamics_/
--rw-rw-rw-   0        0        0     5098 2021-05-16 18:25:36.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Prach_/Pdynamics_/Average.py
--rw-rw-rw-   0        0        0     5098 2021-05-16 18:25:36.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Prach_/Pdynamics_/Current.py
--rw-rw-rw-   0        0        0     5098 2021-05-16 18:25:36.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Prach_/Pdynamics_/Maximum.py
--rw-rw-rw-   0        0        0     5098 2021-05-16 18:25:36.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Prach_/Pdynamics_/Minimum.py
--rw-rw-rw-   0        0        0     4631 2021-05-16 18:25:36.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Prach_/Pdynamics_/StandardDev.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Prach_/Pdynamics_/__init__.py
--rw-rw-rw-   0        0        0     1807 2021-05-16 18:25:35.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Prach_/State.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:42.505509 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Prach_/State_/
--rw-rw-rw-   0        0        0     2389 2021-05-16 18:25:35.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Prach_/State_/All.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Prach_/State_/__init__.py
--rw-rw-rw-   0        0        0     2414 2021-05-16 18:25:35.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Prach_/Trace.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:42.540415 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Prach_/Trace_/
--rw-rw-rw-   0        0        0     1856 2021-05-16 18:25:35.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Prach_/Trace_/EvPreamble.py
--rw-rw-rw-   0        0        0     1463 2021-05-16 18:25:35.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Prach_/Trace_/Evm.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:42.556899 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Prach_/Trace_/Evm_/
--rw-rw-rw-   0        0        0     2229 2021-05-16 18:25:35.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Prach_/Trace_/Evm_/Average.py
--rw-rw-rw-   0        0        0     2229 2021-05-16 18:25:35.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Prach_/Trace_/Evm_/Current.py
--rw-rw-rw-   0        0        0     2229 2021-05-16 18:25:35.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Prach_/Trace_/Evm_/Maximum.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Prach_/Trace_/Evm_/__init__.py
--rw-rw-rw-   0        0        0     1896 2021-05-16 18:25:35.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Prach_/Trace_/Iq.py
--rw-rw-rw-   0        0        0     1487 2021-05-16 18:25:35.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Prach_/Trace_/Merror.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:42.574852 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Prach_/Trace_/Merror_/
--rw-rw-rw-   0        0        0     2239 2021-05-16 18:25:35.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Prach_/Trace_/Merror_/Average.py
--rw-rw-rw-   0        0        0     2239 2021-05-16 18:25:35.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Prach_/Trace_/Merror_/Current.py
--rw-rw-rw-   0        0        0     2239 2021-05-16 18:25:35.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Prach_/Trace_/Merror_/Maximum.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Prach_/Trace_/Merror_/__init__.py
--rw-rw-rw-   0        0        0     1511 2021-05-16 18:25:35.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Prach_/Trace_/Pdynamics.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:42.592803 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Prach_/Trace_/Pdynamics_/
--rw-rw-rw-   0        0        0     2363 2021-05-16 18:25:35.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Prach_/Trace_/Pdynamics_/Average.py
--rw-rw-rw-   0        0        0     2363 2021-05-16 18:25:35.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Prach_/Trace_/Pdynamics_/Current.py
--rw-rw-rw-   0        0        0     2363 2021-05-16 18:25:35.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Prach_/Trace_/Pdynamics_/Maximum.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Prach_/Trace_/Pdynamics_/__init__.py
--rw-rw-rw-   0        0        0     1487 2021-05-16 18:25:35.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Prach_/Trace_/Perror.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:42.613748 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Prach_/Trace_/Perror_/
--rw-rw-rw-   0        0        0     2235 2021-05-16 18:25:35.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Prach_/Trace_/Perror_/Average.py
--rw-rw-rw-   0        0        0     2235 2021-05-16 18:25:35.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Prach_/Trace_/Perror_/Current.py
--rw-rw-rw-   0        0        0     2235 2021-05-16 18:25:35.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Prach_/Trace_/Perror_/Maximum.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Prach_/Trace_/Perror_/__init__.py
--rw-rw-rw-   0        0        0     1864 2021-05-16 18:25:35.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Prach_/Trace_/PvPreamble.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Prach_/Trace_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Prach_/__init__.py
--rw-rw-rw-   0        0        0     2605 2021-05-16 18:25:26.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Route.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:42.628708 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Route_/
--rw-rw-rw-   0        0        0     1373 2021-05-16 18:25:26.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Route_/RfSettings.py
--rw-rw-rw-   0        0        0     4073 2021-05-16 18:25:26.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Route_/Scenario.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:42.642670 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Route_/Scenario_/
--rw-rw-rw-   0        0        0     2125 2021-05-16 18:25:26.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Route_/Scenario_/CombinedSignalPath.py
--rw-rw-rw-   0        0        0      868 2021-05-16 18:25:26.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Route_/Scenario_/MaProtocol.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Route_/Scenario_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Route_/__init__.py
--rw-rw-rw-   0        0        0     1339 2021-05-16 18:25:26.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Sense.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:42.657631 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Sense_/
--rw-rw-rw-   0        0        0      839 2021-05-16 18:25:26.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Sense_/CarrierAggregation.py
--rw-rw-rw-   0        0        0     1257 2021-05-16 18:25:26.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Sense_/MultiEval.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:42.673588 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Sense_/MultiEval_/
--rw-rw-rw-   0        0        0     1023 2021-05-16 18:25:26.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Sense_/MultiEval_/Limit.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:42.682564 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Sense_/MultiEval_/Limit_/
--rw-rw-rw-   0        0        0     1870 2021-05-16 18:25:26.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Sense_/MultiEval_/Limit_/Iemissions.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:42.691540 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Sense_/MultiEval_/Limit_/Iemissions_/
--rw-rw-rw-   0        0        0     1425 2021-05-16 18:25:26.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Sense_/MultiEval_/Limit_/Iemissions_/Ulca.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:42.699519 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Sense_/MultiEval_/Limit_/Iemissions_/Ulca_/
--rw-rw-rw-   0        0        0     2398 2021-05-16 18:25:26.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Sense_/MultiEval_/Limit_/Iemissions_/Ulca_/Scc.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Sense_/MultiEval_/Limit_/Iemissions_/Ulca_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Sense_/MultiEval_/Limit_/Iemissions_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Sense_/MultiEval_/Limit_/__init__.py
--rw-rw-rw-   0        0        0     1009 2021-05-16 18:25:26.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Sense_/MultiEval_/Spectrum.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:42.708495 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Sense_/MultiEval_/Spectrum_/
--rw-rw-rw-   0        0        0      975 2021-05-16 18:25:26.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Sense_/MultiEval_/Spectrum_/SeMask.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:42.718469 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Sense_/MultiEval_/Spectrum_/SeMask_/
--rw-rw-rw-   0        0        0     1631 2021-05-16 18:25:26.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Sense_/MultiEval_/Spectrum_/SeMask_/Rbw.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Sense_/MultiEval_/Spectrum_/SeMask_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Sense_/MultiEval_/Spectrum_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Sense_/MultiEval_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Sense_/__init__.py
--rw-rw-rw-   0        0        0     6415 2021-05-16 18:25:36.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Srs.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:42.737419 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Srs_/
--rw-rw-rw-   0        0        0     2030 2021-05-16 18:25:36.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Srs_/Pdynamics.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:42.765850 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Srs_/Pdynamics_/
--rw-rw-rw-   0        0        0     5788 2021-05-16 18:25:36.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Srs_/Pdynamics_/Average.py
--rw-rw-rw-   0        0        0     5788 2021-05-16 18:25:36.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Srs_/Pdynamics_/Current.py
--rw-rw-rw-   0        0        0     5788 2021-05-16 18:25:36.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Srs_/Pdynamics_/Maximum.py
--rw-rw-rw-   0        0        0     5788 2021-05-16 18:25:36.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Srs_/Pdynamics_/Minimum.py
--rw-rw-rw-   0        0        0     5258 2021-05-16 18:25:36.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Srs_/Pdynamics_/StandardDev.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Srs_/Pdynamics_/__init__.py
--rw-rw-rw-   0        0        0     1801 2021-05-16 18:25:36.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Srs_/State.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:42.774827 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Srs_/State_/
--rw-rw-rw-   0        0        0     2383 2021-05-16 18:25:36.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Srs_/State_/All.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Srs_/State_/__init__.py
--rw-rw-rw-   0        0        0     1013 2021-05-16 18:25:36.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Srs_/Trace.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:42.784800 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Srs_/Trace_/
--rw-rw-rw-   0        0        0     1511 2021-05-16 18:25:36.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Srs_/Trace_/Pdynamics.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:42.805746 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Srs_/Trace_/Pdynamics_/
--rw-rw-rw-   0        0        0     2627 2021-05-16 18:25:36.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Srs_/Trace_/Pdynamics_/Average.py
--rw-rw-rw-   0        0        0     2627 2021-05-16 18:25:36.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Srs_/Trace_/Pdynamics_/Current.py
--rw-rw-rw-   0        0        0     2627 2021-05-16 18:25:36.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Srs_/Trace_/Pdynamics_/Maximum.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Srs_/Trace_/Pdynamics_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Srs_/Trace_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Srs_/__init__.py
--rw-rw-rw-   0        0        0     1460 2021-05-16 18:25:35.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Trigger.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:42.825691 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Trigger_/
--rw-rw-rw-   0        0        0    10648 2021-05-16 18:25:35.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Trigger_/MultiEval.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:42.840652 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Trigger_/MultiEval_/
--rw-rw-rw-   0        0        0     1012 2021-05-16 18:25:35.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Trigger_/MultiEval_/Catalog.py
--rw-rw-rw-   0        0        0     2414 2021-05-16 18:25:35.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Trigger_/MultiEval_/ListPy.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Trigger_/MultiEval_/__init__.py
--rw-rw-rw-   0        0        0     6644 2021-05-16 18:25:35.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Trigger_/Prach.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:42.850624 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Trigger_/Prach_/
--rw-rw-rw-   0        0        0      992 2021-05-16 18:25:35.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Trigger_/Prach_/Catalog.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Trigger_/Prach_/__init__.py
--rw-rw-rw-   0        0        0     6572 2021-05-16 18:25:35.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Trigger_/Srs.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:42.860599 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Trigger_/Srs_/
--rw-rw-rw-   0        0        0      984 2021-05-16 18:25:35.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Trigger_/Srs_/Catalog.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Trigger_/Srs_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Trigger_/__init__.py
--rw-rw-rw-   0        0        0        0 2019-11-18 07:28:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/__init__.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:42.996235 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Internal/
--rw-rw-rw-   0        0        0      541 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Internal/ArgLinkedEventArgs.py
--rw-rw-rw-   0        0        0     4003 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Internal/ArgSingle.py
--rw-rw-rw-   0        0        0     1061 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Internal/ArgSingleList.py
--rw-rw-rw-   0        0        0     1000 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Internal/ArgSingleSuppressed.py
--rw-rw-rw-   0        0        0     9026 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Internal/ArgStringComposer.py
--rw-rw-rw-   0        0        0     5624 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Internal/ArgStruct.py
--rw-rw-rw-   0        0        0     3354 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Internal/ArgStructList.py
--rw-rw-rw-   0        0        0     2446 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Internal/ArgStructStringParser.py
--rw-rw-rw-   0        0        0     5176 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Internal/CommandsGroup.py
--rw-rw-rw-   0        0        0    20227 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Internal/Conversions.py
--rw-rw-rw-   0        0        0     3618 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Internal/ConverterFromScpiString.py
--rw-rw-rw-   0        0        0     4409 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Internal/ConverterToScpiString.py
--rw-rw-rw-   0        0        0    10299 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Internal/Core.py
--rw-rw-rw-   0        0        0    38340 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Internal/Instrument.py
--rw-rw-rw-   0        0        0     3918 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Internal/InstrumentErrors.py
--rw-rw-rw-   0        0        0     2081 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Internal/InstrumentOptions.py
--rw-rw-rw-   0        0        0     5101 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Internal/InstrumentSettings.py
--rw-rw-rw-   0        0        0     3380 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Internal/InternalLinker.py
--rw-rw-rw-   0        0        0     4331 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Internal/IoTransferEventArgs.py
--rw-rw-rw-   0        0        0     3841 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Internal/RepeatedCapability.py
--rw-rw-rw-   0        0        0     4719 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Internal/StreamReader.py
--rw-rw-rw-   0        0        0     4938 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Internal/StreamWriter.py
--rw-rw-rw-   0        0        0     1040 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Internal/StructBase.py
--rw-rw-rw-   0        0        0     2893 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Internal/Types.py
--rw-rw-rw-   0        0        0     4530 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Internal/Utilities.py
--rw-rw-rw-   0        0        0     4850 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Internal/VisaPluginSocketIo.py
--rw-rw-rw-   0        0        0    44232 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Internal/VisaSession.py
--rw-rw-rw-   0        0        0     6999 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Internal/VisaSessionSim.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Internal/__init__.py
--rw-rw-rw-   0        0        0     9273 2021-05-16 18:25:36.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/RsCMPX_LteMeas.py
--rw-rw-rw-   0        0        0      853 2021-05-16 18:25:36.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/__init__.py
--rw-rw-rw-   0        0        0    14402 2021-05-16 18:25:17.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/enums.py
--rw-rw-rw-   0        0        0    11404 2021-05-16 18:25:17.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/repcap.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:25:38.021462 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas.egg-info/
--rw-rw-rw-   0        0        0     2494 2021-05-16 18:25:37.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas.egg-info/PKG-INFO
--rw-rw-rw-   0        0        0    78643 2021-05-16 18:25:37.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas.egg-info/SOURCES.txt
--rw-rw-rw-   0        0        0        1 2021-05-16 18:25:37.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas.egg-info/dependency_links.txt
--rw-rw-rw-   0        0        0        7 2021-05-16 18:25:37.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas.egg-info/requires.txt
--rw-rw-rw-   0        0        0       15 2021-05-16 18:25:37.000000 RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas.egg-info/top_level.txt
--rw-rw-rw-   0        0        0       42 2021-05-16 18:25:43.006209 RsCMPX_LteMeas-4.0.7.5/setup.cfg
--rw-rw-rw-   0        0        0      869 2021-05-16 18:25:36.000000 RsCMPX_LteMeas-4.0.7.5/setup.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:39.139911 RsCMPX_LteMeas-5.0.70/
+-rw-rw-rw-   0        0        0     3100 2024-04-18 15:03:39.139911 RsCMPX_LteMeas-5.0.70/PKG-INFO
+-rw-rw-rw-   0        0        0     1614 2024-04-18 15:03:32.000000 RsCMPX_LteMeas-5.0.70/README.rst
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:36.171121 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:36.197626 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/CustomFiles/
+-rw-rw-rw-   0        0        0       90 2024-04-18 15:03:32.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/CustomFiles/__init__.py
+-rw-rw-rw-   0        0        0     3725 2024-04-18 15:03:32.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/CustomFiles/events.py
+-rw-rw-rw-   0        0        0     4916 2024-04-18 15:03:32.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/CustomFiles/reliability.py
+-rw-rw-rw-   0        0        0    21859 2024-04-18 15:03:32.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/CustomFiles/utilities.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:36.197626 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:36.197626 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:36.214285 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:36.221299 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/CarrierAggregation/
+-rw-rw-rw-   0        0        0      928 2024-04-18 15:03:23.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/CarrierAggregation/ChannelBw.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:36.237839 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/CarrierAggregation/Frequency/
+-rw-rw-rw-   0        0        0     1939 2024-04-18 15:03:23.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/CarrierAggregation/Frequency/Aggregated.py
+-rw-rw-rw-   0        0        0     1073 2024-04-18 15:03:23.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/CarrierAggregation/Frequency/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:36.237839 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/CarrierAggregation/Maping/
+-rw-rw-rw-   0        0        0     2444 2024-04-18 15:03:23.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/CarrierAggregation/Maping/Scc.py
+-rw-rw-rw-   0        0        0     2930 2024-04-18 15:03:23.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/CarrierAggregation/Maping/__init__.py
+-rw-rw-rw-   0        0        0     2627 2024-04-18 15:03:23.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/CarrierAggregation/Mcarrier.py
+-rw-rw-rw-   0        0        0     2428 2024-04-18 15:03:23.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/CarrierAggregation/Mode.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:36.237839 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/CarrierAggregation/Scc/
+-rw-rw-rw-   0        0        0     2126 2024-04-18 15:03:23.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/CarrierAggregation/Scc/AcSpacing.py
+-rw-rw-rw-   0        0        0     1937 2024-04-18 15:03:23.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/CarrierAggregation/Scc/__init__.py
+-rw-rw-rw-   0        0        0     2289 2024-04-18 15:03:23.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/CarrierAggregation/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:36.255492 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/Cc/
+-rw-rw-rw-   0        0        0     2589 2024-04-18 15:03:25.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/Cc/ChannelBw.py
+-rw-rw-rw-   0        0        0     1993 2024-04-18 15:03:25.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/Cc/__init__.py
+-rw-rw-rw-   0        0        0     3031 2024-04-18 15:03:23.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/Emtc.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:36.277273 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:36.277273 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Bler/
+-rw-rw-rw-   0        0        0     2227 2024-04-18 15:03:25.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Bler/Sframes.py
+-rw-rw-rw-   0        0        0     1024 2024-04-18 15:03:25.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Bler/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:36.292066 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Cc/
+-rw-rw-rw-   0        0        0     2329 2024-04-18 15:03:24.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Cc/PlcId.py
+-rw-rw-rw-   0        0        0     1965 2024-04-18 15:03:24.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Cc/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:36.294060 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Limit/
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:36.296054 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Limit/Aclr/
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:36.301041 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Limit/Aclr/Eutra/
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:36.312299 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Limit/Aclr/Eutra/CarrierAggregation/
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:36.315290 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Limit/Aclr/Eutra/CarrierAggregation/ChannelBw1st/
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:36.321275 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Limit/Aclr/Eutra/CarrierAggregation/ChannelBw1st/ChannelBw2nd/
+-rw-rw-rw-   0        0        0     6873 2024-04-18 15:03:25.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Limit/Aclr/Eutra/CarrierAggregation/ChannelBw1st/ChannelBw2nd/ChannelBw3rd.py
+-rw-rw-rw-   0        0        0     6349 2024-04-18 15:03:25.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Limit/Aclr/Eutra/CarrierAggregation/ChannelBw1st/ChannelBw2nd/__init__.py
+-rw-rw-rw-   0        0        0     2067 2024-04-18 15:03:25.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Limit/Aclr/Eutra/CarrierAggregation/ChannelBw1st/__init__.py
+-rw-rw-rw-   0        0        0     2923 2024-04-18 15:03:25.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Limit/Aclr/Eutra/CarrierAggregation/Ocombination.py
+-rw-rw-rw-   0        0        0     1424 2024-04-18 15:03:25.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Limit/Aclr/Eutra/CarrierAggregation/__init__.py
+-rw-rw-rw-   0        0        0     4586 2024-04-18 15:03:25.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Limit/Aclr/Eutra/ChannelBw.py
+-rw-rw-rw-   0        0        0     1381 2024-04-18 15:03:25.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Limit/Aclr/Eutra/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:36.323309 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Limit/Aclr/Utra/
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:36.330323 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Limit/Aclr/Utra/CarrierAggregation/
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:36.330323 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Limit/Aclr/Utra/CarrierAggregation/ChannelBw1st/
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:36.347831 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Limit/Aclr/Utra/CarrierAggregation/ChannelBw1st/ChannelBw2nd/
+-rw-rw-rw-   0        0        0     7629 2024-04-18 15:03:25.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Limit/Aclr/Utra/CarrierAggregation/ChannelBw1st/ChannelBw2nd/ChannelBw3rd.py
+-rw-rw-rw-   0        0        0     7105 2024-04-18 15:03:25.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Limit/Aclr/Utra/CarrierAggregation/ChannelBw1st/ChannelBw2nd/__init__.py
+-rw-rw-rw-   0        0        0     2067 2024-04-18 15:03:25.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Limit/Aclr/Utra/CarrierAggregation/ChannelBw1st/__init__.py
+-rw-rw-rw-   0        0        0     3700 2024-04-18 15:03:25.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Limit/Aclr/Utra/CarrierAggregation/Ocombination.py
+-rw-rw-rw-   0        0        0     1424 2024-04-18 15:03:25.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Limit/Aclr/Utra/CarrierAggregation/__init__.py
+-rw-rw-rw-   0        0        0     5336 2024-04-18 15:03:25.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Limit/Aclr/Utra/ChannelBw.py
+-rw-rw-rw-   0        0        0     2321 2024-04-18 15:03:25.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Limit/Aclr/Utra/__init__.py
+-rw-rw-rw-   0        0        0     1230 2024-04-18 15:03:25.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Limit/Aclr/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:36.354339 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Limit/Pdynamics/
+-rw-rw-rw-   0        0        0     5157 2024-04-18 15:03:25.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Limit/Pdynamics/ChannelBw.py
+-rw-rw-rw-   0        0        0     1067 2024-04-18 15:03:25.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Limit/Pdynamics/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:36.381346 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Limit/Qam/
+-rw-rw-rw-   0        0        0     3659 2024-04-18 15:03:25.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Limit/Qam/EsFlatness.py
+-rw-rw-rw-   0        0        0     3074 2024-04-18 15:03:25.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Limit/Qam/EvMagnitude.py
+-rw-rw-rw-   0        0        0     2189 2024-04-18 15:03:25.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Limit/Qam/FreqError.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:36.387851 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Limit/Qam/Ibe/
+-rw-rw-rw-   0        0        0     3550 2024-04-18 15:03:25.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Limit/Qam/Ibe/IqOffset.py
+-rw-rw-rw-   0        0        0     4371 2024-04-18 15:03:25.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Limit/Qam/Ibe/__init__.py
+-rw-rw-rw-   0        0        0     3874 2024-04-18 15:03:25.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Limit/Qam/IqOffset.py
+-rw-rw-rw-   0        0        0     2976 2024-04-18 15:03:25.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Limit/Qam/Merror.py
+-rw-rw-rw-   0        0        0     3182 2024-04-18 15:03:25.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Limit/Qam/Perror.py
+-rw-rw-rw-   0        0        0     3390 2024-04-18 15:03:25.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Limit/Qam/Sflatness.py
+-rw-rw-rw-   0        0        0     3687 2024-04-18 15:03:25.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Limit/Qam/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:36.404356 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Limit/Qpsk/
+-rw-rw-rw-   0        0        0     2381 2024-04-18 15:03:25.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Limit/Qpsk/EvMagnitude.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:36.414356 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Limit/Qpsk/Ibe/
+-rw-rw-rw-   0        0        0     2878 2024-04-18 15:03:25.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Limit/Qpsk/Ibe/IqOffset.py
+-rw-rw-rw-   0        0        0     3699 2024-04-18 15:03:25.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Limit/Qpsk/Ibe/__init__.py
+-rw-rw-rw-   0        0        0     3205 2024-04-18 15:03:25.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Limit/Qpsk/IqOffset.py
+-rw-rw-rw-   0        0        0     2285 2024-04-18 15:03:25.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Limit/Qpsk/Merror.py
+-rw-rw-rw-   0        0        0     2491 2024-04-18 15:03:25.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Limit/Qpsk/Perror.py
+-rw-rw-rw-   0        0        0     8031 2024-04-18 15:03:25.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Limit/Qpsk/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:36.414356 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Limit/SeMask/
+-rw-rw-rw-   0        0        0     4013 2024-04-18 15:03:25.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Limit/SeMask/AtTolerance.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:36.420923 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Limit/SeMask/Limit/
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:36.420923 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Limit/SeMask/Limit/Additional/
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:36.430463 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Limit/SeMask/Limit/Additional/CarrierAggregation/
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:36.437970 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Limit/SeMask/Limit/Additional/CarrierAggregation/ChannelBw1st/
+-rw-rw-rw-   0        0        0     8508 2024-04-18 15:03:25.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Limit/SeMask/Limit/Additional/CarrierAggregation/ChannelBw1st/ChannelBw2nd.py
+-rw-rw-rw-   0        0        0     2071 2024-04-18 15:03:25.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Limit/SeMask/Limit/Additional/CarrierAggregation/ChannelBw1st/__init__.py
+-rw-rw-rw-   0        0        0     5402 2024-04-18 15:03:25.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Limit/SeMask/Limit/Additional/CarrierAggregation/Ocombination.py
+-rw-rw-rw-   0        0        0     1426 2024-04-18 15:03:25.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Limit/SeMask/Limit/Additional/CarrierAggregation/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:36.447970 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Limit/SeMask/Limit/Additional/ChannelBw/
+-rw-rw-rw-   0        0        0     5440 2024-04-18 15:03:25.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Limit/SeMask/Limit/Additional/ChannelBw/Sidelink.py
+-rw-rw-rw-   0        0        0     7700 2024-04-18 15:03:25.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Limit/SeMask/Limit/Additional/ChannelBw/__init__.py
+-rw-rw-rw-   0        0        0     2238 2024-04-18 15:03:25.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Limit/SeMask/Limit/Additional/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:36.454476 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Limit/SeMask/Limit/CarrierAggregation/
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:36.454476 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Limit/SeMask/Limit/CarrierAggregation/ChannelBw1st/
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:36.469867 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Limit/SeMask/Limit/CarrierAggregation/ChannelBw1st/ChannelBw2nd/
+-rw-rw-rw-   0        0        0     8700 2024-04-18 15:03:25.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Limit/SeMask/Limit/CarrierAggregation/ChannelBw1st/ChannelBw2nd/ChannelBw3rd.py
+-rw-rw-rw-   0        0        0     8176 2024-04-18 15:03:25.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Limit/SeMask/Limit/CarrierAggregation/ChannelBw1st/ChannelBw2nd/__init__.py
+-rw-rw-rw-   0        0        0     2067 2024-04-18 15:03:25.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Limit/SeMask/Limit/CarrierAggregation/ChannelBw1st/__init__.py
+-rw-rw-rw-   0        0        0     4775 2024-04-18 15:03:25.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Limit/SeMask/Limit/CarrierAggregation/Ocombination.py
+-rw-rw-rw-   0        0        0     1424 2024-04-18 15:03:25.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Limit/SeMask/Limit/CarrierAggregation/__init__.py
+-rw-rw-rw-   0        0        0     6342 2024-04-18 15:03:25.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Limit/SeMask/Limit/ChannelBw.py
+-rw-rw-rw-   0        0        0     2477 2024-04-18 15:03:25.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Limit/SeMask/Limit/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:36.478543 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Limit/SeMask/ObwLimit/
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:36.481534 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Limit/SeMask/ObwLimit/CarrierAggregation/
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:36.485524 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Limit/SeMask/ObwLimit/CarrierAggregation/ChannelBw1st/
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:36.497320 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Limit/SeMask/ObwLimit/CarrierAggregation/ChannelBw1st/ChannelBw2nd/
+-rw-rw-rw-   0        0        0     5815 2024-04-18 15:03:25.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Limit/SeMask/ObwLimit/CarrierAggregation/ChannelBw1st/ChannelBw2nd/ChannelBw3rd.py
+-rw-rw-rw-   0        0        0     5287 2024-04-18 15:03:25.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Limit/SeMask/ObwLimit/CarrierAggregation/ChannelBw1st/ChannelBw2nd/__init__.py
+-rw-rw-rw-   0        0        0     2067 2024-04-18 15:03:25.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Limit/SeMask/ObwLimit/CarrierAggregation/ChannelBw1st/__init__.py
+-rw-rw-rw-   0        0        0     2624 2024-04-18 15:03:25.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Limit/SeMask/ObwLimit/CarrierAggregation/__init__.py
+-rw-rw-rw-   0        0        0     3495 2024-04-18 15:03:25.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Limit/SeMask/ObwLimit/ChannelBw.py
+-rw-rw-rw-   0        0        0     1396 2024-04-18 15:03:25.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Limit/SeMask/ObwLimit/__init__.py
+-rw-rw-rw-   0        0        0     1549 2024-04-18 15:03:25.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Limit/SeMask/__init__.py
+-rw-rw-rw-   0        0        0     1934 2024-04-18 15:03:24.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Limit/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:36.498361 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/ListPy/
+-rw-rw-rw-   0        0        0     2476 2024-04-18 15:03:24.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/ListPy/Lrange.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:36.546101 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/ListPy/Segment/
+-rw-rw-rw-   0        0        0     4618 2024-04-18 15:03:23.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/ListPy/Segment/Aclr.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:36.553080 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/ListPy/Segment/CarrierAggregation/
+-rw-rw-rw-   0        0        0     2222 2024-04-18 15:03:23.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/ListPy/Segment/CarrierAggregation/AcSpacing.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:36.556160 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/ListPy/Segment/CarrierAggregation/Mcarrier/
+-rw-rw-rw-   0        0        0     2397 2024-04-18 15:03:23.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/ListPy/Segment/CarrierAggregation/Mcarrier/Enhanced.py
+-rw-rw-rw-   0        0        0     2844 2024-04-18 15:03:23.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/ListPy/Segment/CarrierAggregation/Mcarrier/__init__.py
+-rw-rw-rw-   0        0        0     1366 2024-04-18 15:03:23.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/ListPy/Segment/CarrierAggregation/__init__.py
+-rw-rw-rw-   0        0        0     5502 2024-04-18 15:03:23.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/ListPy/Segment/Cc.py
+-rw-rw-rw-   0        0        0     2089 2024-04-18 15:03:24.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/ListPy/Segment/Cidx.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:36.556160 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/ListPy/Segment/Emtc/
+-rw-rw-rw-   0        0        0     2104 2024-04-18 15:03:23.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/ListPy/Segment/Emtc/Nband.py
+-rw-rw-rw-   0        0        0     1012 2024-04-18 15:03:23.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/ListPy/Segment/Emtc/__init__.py
+-rw-rw-rw-   0        0        0     4548 2024-04-18 15:03:23.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/ListPy/Segment/Modulation.py
+-rw-rw-rw-   0        0        0     2136 2024-04-18 15:03:24.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/ListPy/Segment/PlcId.py
+-rw-rw-rw-   0        0        0     2052 2024-04-18 15:03:23.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/ListPy/Segment/Pmonitor.py
+-rw-rw-rw-   0        0        0     3052 2024-04-18 15:03:23.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/ListPy/Segment/Power.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:36.566155 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/ListPy/Segment/RbAllocation/
+-rw-rw-rw-   0        0        0     4096 2024-04-18 15:03:23.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/ListPy/Segment/RbAllocation/Sidelink.py
+-rw-rw-rw-   0        0        0     4193 2024-04-18 15:03:23.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/ListPy/Segment/RbAllocation/__init__.py
+-rw-rw-rw-   0        0        0     4795 2024-04-18 15:03:23.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/ListPy/Segment/Scc.py
+-rw-rw-rw-   0        0        0     4242 2024-04-18 15:03:23.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/ListPy/Segment/SeMask.py
+-rw-rw-rw-   0        0        0     7115 2024-04-18 15:03:23.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/ListPy/Segment/Setup.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:36.572544 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/ListPy/Segment/SingleCmw/
+-rw-rw-rw-   0        0        0     2169 2024-04-18 15:03:24.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/ListPy/Segment/SingleCmw/Connector.py
+-rw-rw-rw-   0        0        0     1069 2024-04-18 15:03:24.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/ListPy/Segment/SingleCmw/__init__.py
+-rw-rw-rw-   0        0        0     3466 2024-04-18 15:03:23.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/ListPy/Segment/Tdd.py
+-rw-rw-rw-   0        0        0     5255 2024-04-18 15:03:23.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/ListPy/Segment/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:36.572544 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/ListPy/SingleCmw/
+-rw-rw-rw-   0        0        0     1611 2024-04-18 15:03:24.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/ListPy/SingleCmw/Connector.py
+-rw-rw-rw-   0        0        0     2195 2024-04-18 15:03:24.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/ListPy/SingleCmw/__init__.py
+-rw-rw-rw-   0        0        0     7749 2024-04-18 15:03:23.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/ListPy/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:36.582525 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Modulation/
+-rw-rw-rw-   0        0        0     1974 2024-04-18 15:03:24.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Modulation/CarrierAggregation.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:36.592520 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Modulation/EePeriods/
+-rw-rw-rw-   0        0        0     3704 2024-04-18 15:03:24.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Modulation/EePeriods/Pusch.py
+-rw-rw-rw-   0        0        0     2680 2024-04-18 15:03:24.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Modulation/EePeriods/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:36.602515 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Modulation/EwLength/
+-rw-rw-rw-   0        0        0     4453 2024-04-18 15:03:24.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Modulation/EwLength/ChannelBw.py
+-rw-rw-rw-   0        0        0     3333 2024-04-18 15:03:24.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Modulation/EwLength/__init__.py
+-rw-rw-rw-   0        0        0     5106 2024-04-18 15:03:24.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Modulation/__init__.py
+-rw-rw-rw-   0        0        0     2825 2024-04-18 15:03:24.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/MsubFrames.py
+-rw-rw-rw-   0        0        0     2916 2024-04-18 15:03:24.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/NsValue.py
+-rw-rw-rw-   0        0        0     1288 2024-04-18 15:03:24.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Pcc.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:36.612511 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Pdynamics/
+-rw-rw-rw-   0        0        0     2880 2024-04-18 15:03:24.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Pdynamics/AeoPower.py
+-rw-rw-rw-   0        0        0     2341 2024-04-18 15:03:24.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Pdynamics/__init__.py
+-rw-rw-rw-   0        0        0     1403 2024-04-18 15:03:24.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Power.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:36.621024 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/RbAllocation/
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:36.631016 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/RbAllocation/Mcluster/
+-rw-rw-rw-   0        0        0     3347 2024-04-18 15:03:24.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/RbAllocation/Mcluster/Nrb.py
+-rw-rw-rw-   0        0        0     3398 2024-04-18 15:03:24.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/RbAllocation/Mcluster/Orb.py
+-rw-rw-rw-   0        0        0     2428 2024-04-18 15:03:24.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/RbAllocation/Mcluster/__init__.py
+-rw-rw-rw-   0        0        0     3929 2024-04-18 15:03:24.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/RbAllocation/Nrb.py
+-rw-rw-rw-   0        0        0     4317 2024-04-18 15:03:24.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/RbAllocation/Orb.py
+-rw-rw-rw-   0        0        0     2518 2024-04-18 15:03:24.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/RbAllocation/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:36.637731 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Result/
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:36.637731 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Result/EvMagnitude/
+-rw-rw-rw-   0        0        0     2818 2024-04-18 15:03:24.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Result/EvMagnitude/EvmSymbol.py
+-rw-rw-rw-   0        0        0     3409 2024-04-18 15:03:24.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Result/EvMagnitude/__init__.py
+-rw-rw-rw-   0        0        0    33069 2024-04-18 15:03:24.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Result/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:36.647729 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Scc/
+-rw-rw-rw-   0        0        0     1931 2024-04-18 15:03:24.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Scc/PlcId.py
+-rw-rw-rw-   0        0        0     1905 2024-04-18 15:03:24.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Scc/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:36.654472 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Scount/
+-rw-rw-rw-   0        0        0     3088 2024-04-18 15:03:24.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Scount/Spectrum.py
+-rw-rw-rw-   0        0        0     3297 2024-04-18 15:03:24.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Scount/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:36.654472 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Spectrum/
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:36.664471 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Spectrum/Aclr/
+-rw-rw-rw-   0        0        0     2575 2024-04-18 15:03:24.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Spectrum/Aclr/Enable.py
+-rw-rw-rw-   0        0        0     1018 2024-04-18 15:03:24.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Spectrum/Aclr/__init__.py
+-rw-rw-rw-   0        0        0     1618 2024-04-18 15:03:24.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Spectrum/SeMask.py
+-rw-rw-rw-   0        0        0     1256 2024-04-18 15:03:24.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Spectrum/__init__.py
+-rw-rw-rw-   0        0        0     1632 2024-04-18 15:03:24.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Srs.py
+-rw-rw-rw-   0        0        0     4449 2024-04-18 15:03:24.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Tmode.py
+-rw-rw-rw-   0        0        0    29315 2024-04-18 15:03:23.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/__init__.py
+-rw-rw-rw-   0        0        0     3448 2024-04-18 15:03:23.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/Network.py
+-rw-rw-rw-   0        0        0     1408 2024-04-18 15:03:25.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/Pcc.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:36.689854 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/Prach/
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:36.714170 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/Prach/Limit/
+-rw-rw-rw-   0        0        0     2296 2024-04-18 15:03:26.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/Prach/Limit/EvMagnitude.py
+-rw-rw-rw-   0        0        0     2198 2024-04-18 15:03:26.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/Prach/Limit/Merror.py
+-rw-rw-rw-   0        0        0     2978 2024-04-18 15:03:26.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/Prach/Limit/Pdynamics.py
+-rw-rw-rw-   0        0        0     2404 2024-04-18 15:03:26.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/Prach/Limit/Perror.py
+-rw-rw-rw-   0        0        0     2832 2024-04-18 15:03:26.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/Prach/Limit/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:36.721153 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/Prach/Modulation/
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:36.723009 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/Prach/Modulation/EwLength/
+-rw-rw-rw-   0        0        0     3421 2024-04-18 15:03:26.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/Prach/Modulation/EwLength/Pformat.py
+-rw-rw-rw-   0        0        0     2110 2024-04-18 15:03:26.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/Prach/Modulation/EwLength/__init__.py
+-rw-rw-rw-   0        0        0     2985 2024-04-18 15:03:26.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/Prach/Modulation/Sindex.py
+-rw-rw-rw-   0        0        0     4886 2024-04-18 15:03:26.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/Prach/Modulation/__init__.py
+-rw-rw-rw-   0        0        0     2756 2024-04-18 15:03:26.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/Prach/PfOffset.py
+-rw-rw-rw-   0        0        0     1483 2024-04-18 15:03:26.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/Prach/Power.py
+-rw-rw-rw-   0        0        0    17695 2024-04-18 15:03:26.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/Prach/Result.py
+-rw-rw-rw-   0        0        0     2615 2024-04-18 15:03:26.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/Prach/Scount.py
+-rw-rw-rw-   0        0        0    14618 2024-04-18 15:03:25.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/Prach/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:36.731033 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/RfSettings/
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:36.742342 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/RfSettings/Cc/
+-rw-rw-rw-   0        0        0     2979 2024-04-18 15:03:23.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/RfSettings/Cc/Frequency.py
+-rw-rw-rw-   0        0        0     1997 2024-04-18 15:03:23.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/RfSettings/Cc/__init__.py
+-rw-rw-rw-   0        0        0     1304 2024-04-18 15:03:23.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/RfSettings/Pcc.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:36.748326 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/RfSettings/Scc/
+-rw-rw-rw-   0        0        0     1955 2024-04-18 15:03:23.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/RfSettings/Scc/Frequency.py
+-rw-rw-rw-   0        0        0     1937 2024-04-18 15:03:23.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/RfSettings/Scc/__init__.py
+-rw-rw-rw-   0        0        0     7257 2024-04-18 15:03:23.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/RfSettings/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:36.757573 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/Scc/
+-rw-rw-rw-   0        0        0     2055 2024-04-18 15:03:25.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/Scc/ChannelBw.py
+-rw-rw-rw-   0        0        0     1933 2024-04-18 15:03:25.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/Scc/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:36.762560 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/Srs/
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:36.767546 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/Srs/Limit/
+-rw-rw-rw-   0        0        0     2966 2024-04-18 15:03:26.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/Srs/Limit/Pdynamics.py
+-rw-rw-rw-   0        0        0     1045 2024-04-18 15:03:26.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/Srs/Limit/__init__.py
+-rw-rw-rw-   0        0        0     1535 2024-04-18 15:03:26.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/Srs/Scount.py
+-rw-rw-rw-   0        0        0     9576 2024-04-18 15:03:26.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/Srs/__init__.py
+-rw-rw-rw-   0        0        0     8356 2024-04-18 15:03:23.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/__init__.py
+-rw-rw-rw-   0        0        0     1046 2024-04-18 15:03:23.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:36.772594 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:36.782589 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:36.792583 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Aclr/
+-rw-rw-rw-   0        0        0     5850 2024-04-18 15:03:27.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Aclr/Average.py
+-rw-rw-rw-   0        0        0     5850 2024-04-18 15:03:27.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Aclr/Current.py
+-rw-rw-rw-   0        0        0     1958 2024-04-18 15:03:27.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Aclr/Dallocation.py
+-rw-rw-rw-   0        0        0     1547 2024-04-18 15:03:27.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Aclr/DchType.py
+-rw-rw-rw-   0        0        0     1786 2024-04-18 15:03:27.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Aclr/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:36.812572 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Amarker/
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:36.821097 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Amarker/EvMagnitude/
+-rw-rw-rw-   0        0        0     2238 2024-04-18 15:03:26.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Amarker/EvMagnitude/Peak.py
+-rw-rw-rw-   0        0        0     2869 2024-04-18 15:03:26.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Amarker/EvMagnitude/__init__.py
+-rw-rw-rw-   0        0        0     2205 2024-04-18 15:03:26.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Amarker/Merror.py
+-rw-rw-rw-   0        0        0     2041 2024-04-18 15:03:26.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Amarker/Pdynamics.py
+-rw-rw-rw-   0        0        0     2205 2024-04-18 15:03:26.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Amarker/Perror.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:36.821097 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Amarker/Pmonitor/
+-rw-rw-rw-   0        0        0     3376 2024-04-18 15:03:26.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Amarker/Pmonitor/Cc.py
+-rw-rw-rw-   0        0        0     1004 2024-04-18 15:03:26.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Amarker/Pmonitor/__init__.py
+-rw-rw-rw-   0        0        0     2927 2024-04-18 15:03:26.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Amarker/__init__.py
+-rw-rw-rw-   0        0        0     2041 2024-04-18 15:03:28.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Bler.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:36.837754 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Dmarker/
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:36.847754 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Dmarker/EvMagnitude/
+-rw-rw-rw-   0        0        0     2334 2024-04-18 15:03:26.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Dmarker/EvMagnitude/Peak.py
+-rw-rw-rw-   0        0        0     2965 2024-04-18 15:03:26.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Dmarker/EvMagnitude/__init__.py
+-rw-rw-rw-   0        0        0     2301 2024-04-18 15:03:26.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Dmarker/Merror.py
+-rw-rw-rw-   0        0        0     2137 2024-04-18 15:03:26.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Dmarker/Pdynamics.py
+-rw-rw-rw-   0        0        0     2301 2024-04-18 15:03:26.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Dmarker/Perror.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:36.854260 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Dmarker/Pmonitor/
+-rw-rw-rw-   0        0        0     3469 2024-04-18 15:03:26.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Dmarker/Pmonitor/Cc.py
+-rw-rw-rw-   0        0        0     1004 2024-04-18 15:03:26.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Dmarker/Pmonitor/__init__.py
+-rw-rw-rw-   0        0        0     2953 2024-04-18 15:03:26.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Dmarker/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:36.864260 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/EsFlatness/
+-rw-rw-rw-   0        0        0     5142 2024-04-18 15:03:27.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/EsFlatness/Average.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:36.864260 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/EsFlatness/Current/
+-rw-rw-rw-   0        0        0     2213 2024-04-18 15:03:27.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/EsFlatness/Current/ScIndex.py
+-rw-rw-rw-   0        0        0     5787 2024-04-18 15:03:27.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/EsFlatness/Current/__init__.py
+-rw-rw-rw-   0        0        0     5142 2024-04-18 15:03:27.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/EsFlatness/Extreme.py
+-rw-rw-rw-   0        0        0     4816 2024-04-18 15:03:27.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/EsFlatness/StandardDev.py
+-rw-rw-rw-   0        0        0     1817 2024-04-18 15:03:27.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/EsFlatness/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:36.864260 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/EvMagnitude/
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:36.889620 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/EvMagnitude/Average/
+-rw-rw-rw-   0        0        0     3147 2024-04-18 15:03:26.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/EvMagnitude/Average/Nref.py
+-rw-rw-rw-   0        0        0     4577 2024-04-18 15:03:26.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/EvMagnitude/Average/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:36.895674 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/EvMagnitude/Current/
+-rw-rw-rw-   0        0        0     3147 2024-04-18 15:03:26.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/EvMagnitude/Current/Nref.py
+-rw-rw-rw-   0        0        0     4577 2024-04-18 15:03:26.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/EvMagnitude/Current/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:36.904680 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/EvMagnitude/Maximum/
+-rw-rw-rw-   0        0        0     3147 2024-04-18 15:03:26.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/EvMagnitude/Maximum/Nref.py
+-rw-rw-rw-   0        0        0     4577 2024-04-18 15:03:26.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/EvMagnitude/Maximum/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:36.915188 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/EvMagnitude/Peak/
+-rw-rw-rw-   0        0        0     2771 2024-04-18 15:03:26.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/EvMagnitude/Peak/Average.py
+-rw-rw-rw-   0        0        0     2771 2024-04-18 15:03:26.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/EvMagnitude/Peak/Current.py
+-rw-rw-rw-   0        0        0     2771 2024-04-18 15:03:27.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/EvMagnitude/Peak/Maximum.py
+-rw-rw-rw-   0        0        0     1512 2024-04-18 15:03:26.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/EvMagnitude/Peak/__init__.py
+-rw-rw-rw-   0        0        0     1766 2024-04-18 15:03:26.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/EvMagnitude/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:36.921223 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Evmc/
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:36.930971 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Evmc/Peak/
+-rw-rw-rw-   0        0        0     2052 2024-04-18 15:03:27.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Evmc/Peak/Average.py
+-rw-rw-rw-   0        0        0     2052 2024-04-18 15:03:27.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Evmc/Peak/Current.py
+-rw-rw-rw-   0        0        0     2052 2024-04-18 15:03:27.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Evmc/Peak/Maximum.py
+-rw-rw-rw-   0        0        0     2084 2024-04-18 15:03:27.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Evmc/Peak/StandardDev.py
+-rw-rw-rw-   0        0        0     1788 2024-04-18 15:03:27.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Evmc/Peak/__init__.py
+-rw-rw-rw-   0        0        0      998 2024-04-18 15:03:27.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Evmc/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:36.942424 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/InbandEmission/
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:36.944417 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/InbandEmission/Cc/
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:36.952396 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/InbandEmission/Cc/Margin/
+-rw-rw-rw-   0        0        0     2434 2024-04-18 15:03:27.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/InbandEmission/Cc/Margin/Average.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:36.960631 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/InbandEmission/Cc/Margin/Current/
+-rw-rw-rw-   0        0        0     2317 2024-04-18 15:03:27.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/InbandEmission/Cc/Margin/Current/RbIndex.py
+-rw-rw-rw-   0        0        0     3080 2024-04-18 15:03:27.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/InbandEmission/Cc/Margin/Current/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:36.966615 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/InbandEmission/Cc/Margin/Extreme/
+-rw-rw-rw-   0        0        0     2317 2024-04-18 15:03:27.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/InbandEmission/Cc/Margin/Extreme/RbIndex.py
+-rw-rw-rw-   0        0        0     3080 2024-04-18 15:03:27.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/InbandEmission/Cc/Margin/Extreme/__init__.py
+-rw-rw-rw-   0        0        0     2456 2024-04-18 15:03:27.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/InbandEmission/Cc/Margin/StandardDev.py
+-rw-rw-rw-   0        0        0     1800 2024-04-18 15:03:27.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/InbandEmission/Cc/Margin/__init__.py
+-rw-rw-rw-   0        0        0     1973 2024-04-18 15:03:27.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/InbandEmission/Cc/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:36.971601 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/InbandEmission/Pcc/
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:36.972675 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/InbandEmission/Pcc/Margin/
+-rw-rw-rw-   0        0        0     1565 2024-04-18 15:03:27.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/InbandEmission/Pcc/Margin/Average.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:36.982671 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/InbandEmission/Pcc/Margin/Current/
+-rw-rw-rw-   0        0        0     1593 2024-04-18 15:03:27.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/InbandEmission/Pcc/Margin/Current/RbIndex.py
+-rw-rw-rw-   0        0        0     2210 2024-04-18 15:03:27.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/InbandEmission/Pcc/Margin/Current/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:36.992665 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/InbandEmission/Pcc/Margin/Extreme/
+-rw-rw-rw-   0        0        0     1593 2024-04-18 15:03:27.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/InbandEmission/Pcc/Margin/Extreme/RbIndex.py
+-rw-rw-rw-   0        0        0     2210 2024-04-18 15:03:27.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/InbandEmission/Pcc/Margin/Extreme/__init__.py
+-rw-rw-rw-   0        0        0     1587 2024-04-18 15:03:27.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/InbandEmission/Pcc/Margin/StandardDev.py
+-rw-rw-rw-   0        0        0     1800 2024-04-18 15:03:27.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/InbandEmission/Pcc/Margin/__init__.py
+-rw-rw-rw-   0        0        0     1011 2024-04-18 15:03:27.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/InbandEmission/Pcc/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:36.992665 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/InbandEmission/Scc/
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:37.004492 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/InbandEmission/Scc/Margin/
+-rw-rw-rw-   0        0        0     1563 2024-04-18 15:03:27.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/InbandEmission/Scc/Margin/Average.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:37.014493 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/InbandEmission/Scc/Margin/Current/
+-rw-rw-rw-   0        0        0     1591 2024-04-18 15:03:27.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/InbandEmission/Scc/Margin/Current/RbIndex.py
+-rw-rw-rw-   0        0        0     2208 2024-04-18 15:03:27.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/InbandEmission/Scc/Margin/Current/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:37.021005 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/InbandEmission/Scc/Margin/Extreme/
+-rw-rw-rw-   0        0        0     1591 2024-04-18 15:03:27.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/InbandEmission/Scc/Margin/Extreme/RbIndex.py
+-rw-rw-rw-   0        0        0     2208 2024-04-18 15:03:27.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/InbandEmission/Scc/Margin/Extreme/__init__.py
+-rw-rw-rw-   0        0        0     1585 2024-04-18 15:03:27.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/InbandEmission/Scc/Margin/StandardDev.py
+-rw-rw-rw-   0        0        0     1800 2024-04-18 15:03:27.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/InbandEmission/Scc/Margin/__init__.py
+-rw-rw-rw-   0        0        0     1011 2024-04-18 15:03:27.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/InbandEmission/Scc/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:37.021005 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/InbandEmission/Ulca/
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:37.021005 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/InbandEmission/Ulca/Pcc/
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:37.040994 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/InbandEmission/Ulca/Pcc/Margin/
+-rw-rw-rw-   0        0        0     1584 2024-04-18 15:03:27.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/InbandEmission/Ulca/Pcc/Margin/Average.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:37.040994 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/InbandEmission/Ulca/Pcc/Margin/Current/
+-rw-rw-rw-   0        0        0     1612 2024-04-18 15:03:27.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/InbandEmission/Ulca/Pcc/Margin/Current/RbIndex.py
+-rw-rw-rw-   0        0        0     2229 2024-04-18 15:03:27.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/InbandEmission/Ulca/Pcc/Margin/Current/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:37.050988 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/InbandEmission/Ulca/Pcc/Margin/Extreme/
+-rw-rw-rw-   0        0        0     1612 2024-04-18 15:03:27.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/InbandEmission/Ulca/Pcc/Margin/Extreme/RbIndex.py
+-rw-rw-rw-   0        0        0     2229 2024-04-18 15:03:27.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/InbandEmission/Ulca/Pcc/Margin/Extreme/__init__.py
+-rw-rw-rw-   0        0        0     1606 2024-04-18 15:03:27.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/InbandEmission/Ulca/Pcc/Margin/StandardDev.py
+-rw-rw-rw-   0        0        0     1802 2024-04-18 15:03:27.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/InbandEmission/Ulca/Pcc/Margin/__init__.py
+-rw-rw-rw-   0        0        0     1013 2024-04-18 15:03:27.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/InbandEmission/Ulca/Pcc/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:37.050988 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/InbandEmission/Ulca/Scc/
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:37.060983 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/InbandEmission/Ulca/Scc/Margin/
+-rw-rw-rw-   0        0        0     1924 2024-04-18 15:03:27.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/InbandEmission/Ulca/Scc/Margin/Average.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:37.070977 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/InbandEmission/Ulca/Scc/Margin/Current/
+-rw-rw-rw-   0        0        0     1953 2024-04-18 15:03:27.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/InbandEmission/Ulca/Scc/Margin/Current/RbIndex.py
+-rw-rw-rw-   0        0        0     2570 2024-04-18 15:03:27.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/InbandEmission/Ulca/Scc/Margin/Current/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:37.080972 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/InbandEmission/Ulca/Scc/Margin/Extreme/
+-rw-rw-rw-   0        0        0     1953 2024-04-18 15:03:27.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/InbandEmission/Ulca/Scc/Margin/Extreme/RbIndex.py
+-rw-rw-rw-   0        0        0     2570 2024-04-18 15:03:27.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/InbandEmission/Ulca/Scc/Margin/Extreme/__init__.py
+-rw-rw-rw-   0        0        0     1946 2024-04-18 15:03:27.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/InbandEmission/Ulca/Scc/Margin/StandardDev.py
+-rw-rw-rw-   0        0        0     1802 2024-04-18 15:03:27.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/InbandEmission/Ulca/Scc/Margin/__init__.py
+-rw-rw-rw-   0        0        0     1917 2024-04-18 15:03:27.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/InbandEmission/Ulca/Scc/__init__.py
+-rw-rw-rw-   0        0        0     1205 2024-04-18 15:03:27.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/InbandEmission/Ulca/__init__.py
+-rw-rw-rw-   0        0        0     1677 2024-04-18 15:03:27.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/InbandEmission/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:37.087979 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:37.109036 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Aclr/
+-rw-rw-rw-   0        0        0     2307 2024-04-18 15:03:31.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Aclr/Dallocation.py
+-rw-rw-rw-   0        0        0     1665 2024-04-18 15:03:31.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Aclr/DchType.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:37.122004 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Aclr/Eutra/
+-rw-rw-rw-   0        0        0     2383 2024-04-18 15:03:31.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Aclr/Eutra/Average.py
+-rw-rw-rw-   0        0        0     2383 2024-04-18 15:03:31.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Aclr/Eutra/Current.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:37.138264 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Aclr/Eutra/Negativ/
+-rw-rw-rw-   0        0        0     2581 2024-04-18 15:03:31.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Aclr/Eutra/Negativ/Average.py
+-rw-rw-rw-   0        0        0     2581 2024-04-18 15:03:31.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Aclr/Eutra/Negativ/Current.py
+-rw-rw-rw-   0        0        0     1287 2024-04-18 15:03:31.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Aclr/Eutra/Negativ/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:37.149234 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Aclr/Eutra/Positiv/
+-rw-rw-rw-   0        0        0     2581 2024-04-18 15:03:31.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Aclr/Eutra/Positiv/Average.py
+-rw-rw-rw-   0        0        0     2581 2024-04-18 15:03:31.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Aclr/Eutra/Positiv/Current.py
+-rw-rw-rw-   0        0        0     1287 2024-04-18 15:03:31.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Aclr/Eutra/Positiv/__init__.py
+-rw-rw-rw-   0        0        0     1764 2024-04-18 15:03:31.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Aclr/Eutra/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:37.151229 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Aclr/Utra/
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:37.164535 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Aclr/Utra/Negativ/
+-rw-rw-rw-   0        0        0     3301 2024-04-18 15:03:31.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Aclr/Utra/Negativ/Average.py
+-rw-rw-rw-   0        0        0     3301 2024-04-18 15:03:31.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Aclr/Utra/Negativ/Current.py
+-rw-rw-rw-   0        0        0     1287 2024-04-18 15:03:31.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Aclr/Utra/Negativ/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:37.173560 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Aclr/Utra/Positiv/
+-rw-rw-rw-   0        0        0     3301 2024-04-18 15:03:31.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Aclr/Utra/Positiv/Average.py
+-rw-rw-rw-   0        0        0     3301 2024-04-18 15:03:31.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Aclr/Utra/Positiv/Current.py
+-rw-rw-rw-   0        0        0     1287 2024-04-18 15:03:31.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Aclr/Utra/Positiv/__init__.py
+-rw-rw-rw-   0        0        0     2213 2024-04-18 15:03:31.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Aclr/Utra/__init__.py
+-rw-rw-rw-   0        0        0     1749 2024-04-18 15:03:31.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Aclr/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:37.173560 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/EsFlatness/
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:37.183555 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/EsFlatness/Difference/
+-rw-rw-rw-   0        0        0     3131 2024-04-18 15:03:29.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/EsFlatness/Difference/Average.py
+-rw-rw-rw-   0        0        0     3131 2024-04-18 15:03:29.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/EsFlatness/Difference/Current.py
+-rw-rw-rw-   0        0        0     3131 2024-04-18 15:03:29.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/EsFlatness/Difference/Extreme.py
+-rw-rw-rw-   0        0        0     1811 2024-04-18 15:03:29.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/EsFlatness/Difference/StandardDev.py
+-rw-rw-rw-   0        0        0     2711 2024-04-18 15:03:29.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/EsFlatness/Difference/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:37.204421 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/EsFlatness/Maxr/
+-rw-rw-rw-   0        0        0     3029 2024-04-18 15:03:29.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/EsFlatness/Maxr/Average.py
+-rw-rw-rw-   0        0        0     3029 2024-04-18 15:03:29.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/EsFlatness/Maxr/Current.py
+-rw-rw-rw-   0        0        0     3029 2024-04-18 15:03:29.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/EsFlatness/Maxr/Extreme.py
+-rw-rw-rw-   0        0        0     1760 2024-04-18 15:03:29.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/EsFlatness/Maxr/StandardDev.py
+-rw-rw-rw-   0        0        0     2655 2024-04-18 15:03:29.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/EsFlatness/Maxr/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:37.220930 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/EsFlatness/Minr/
+-rw-rw-rw-   0        0        0     3029 2024-04-18 15:03:29.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/EsFlatness/Minr/Average.py
+-rw-rw-rw-   0        0        0     3029 2024-04-18 15:03:29.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/EsFlatness/Minr/Current.py
+-rw-rw-rw-   0        0        0     3029 2024-04-18 15:03:29.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/EsFlatness/Minr/Extreme.py
+-rw-rw-rw-   0        0        0     1760 2024-04-18 15:03:29.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/EsFlatness/Minr/StandardDev.py
+-rw-rw-rw-   0        0        0     2655 2024-04-18 15:03:29.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/EsFlatness/Minr/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:37.230924 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/EsFlatness/Ripple/
+-rw-rw-rw-   0        0        0     3007 2024-04-18 15:03:29.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/EsFlatness/Ripple/Average.py
+-rw-rw-rw-   0        0        0     3007 2024-04-18 15:03:29.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/EsFlatness/Ripple/Current.py
+-rw-rw-rw-   0        0        0     3007 2024-04-18 15:03:29.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/EsFlatness/Ripple/Extreme.py
+-rw-rw-rw-   0        0        0     1749 2024-04-18 15:03:29.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/EsFlatness/Ripple/StandardDev.py
+-rw-rw-rw-   0        0        0     2639 2024-04-18 15:03:29.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/EsFlatness/Ripple/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:37.237647 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/EsFlatness/ScIndex/
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:37.247648 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/EsFlatness/ScIndex/Maximum/
+-rw-rw-rw-   0        0        0     1744 2024-04-18 15:03:29.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/EsFlatness/ScIndex/Maximum/Current.py
+-rw-rw-rw-   0        0        0     1910 2024-04-18 15:03:29.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/EsFlatness/ScIndex/Maximum/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:37.254345 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/EsFlatness/ScIndex/Minimum/
+-rw-rw-rw-   0        0        0     1744 2024-04-18 15:03:29.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/EsFlatness/ScIndex/Minimum/Current.py
+-rw-rw-rw-   0        0        0     1910 2024-04-18 15:03:29.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/EsFlatness/ScIndex/Minimum/__init__.py
+-rw-rw-rw-   0        0        0     1285 2024-04-18 15:03:29.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/EsFlatness/ScIndex/__init__.py
+-rw-rw-rw-   0        0        0     1999 2024-04-18 15:03:29.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/EsFlatness/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:37.254345 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/InbandEmission/
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:37.271351 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/InbandEmission/Margin/
+-rw-rw-rw-   0        0        0     1498 2024-04-18 15:03:29.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/InbandEmission/Margin/Average.py
+-rw-rw-rw-   0        0        0     1498 2024-04-18 15:03:29.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/InbandEmission/Margin/Current.py
+-rw-rw-rw-   0        0        0     1498 2024-04-18 15:03:29.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/InbandEmission/Margin/Extreme.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:37.281351 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/InbandEmission/Margin/RbIndex/
+-rw-rw-rw-   0        0        0     1358 2024-04-18 15:03:29.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/InbandEmission/Margin/RbIndex/Current.py
+-rw-rw-rw-   0        0        0     1358 2024-04-18 15:03:29.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/InbandEmission/Margin/RbIndex/Extreme.py
+-rw-rw-rw-   0        0        0     1287 2024-04-18 15:03:29.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/InbandEmission/Margin/RbIndex/__init__.py
+-rw-rw-rw-   0        0        0     1520 2024-04-18 15:03:29.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/InbandEmission/Margin/StandardDev.py
+-rw-rw-rw-   0        0        0     2044 2024-04-18 15:03:29.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/InbandEmission/Margin/__init__.py
+-rw-rw-rw-   0        0        0     1066 2024-04-18 15:03:29.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/InbandEmission/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:37.304365 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/
+-rw-rw-rw-   0        0        0     2325 2024-04-18 15:03:29.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Dallocation.py
+-rw-rw-rw-   0        0        0     1683 2024-04-18 15:03:29.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/DchType.py
+-rw-rw-rw-   0        0        0     1628 2024-04-18 15:03:29.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Dmodulation.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:37.304365 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Evm/
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:37.304365 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Evm/Dmrs/
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:37.332924 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Evm/Dmrs/High/
+-rw-rw-rw-   0        0        0     2504 2024-04-18 15:03:28.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Evm/Dmrs/High/Average.py
+-rw-rw-rw-   0        0        0     2504 2024-04-18 15:03:28.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Evm/Dmrs/High/Current.py
+-rw-rw-rw-   0        0        0     2504 2024-04-18 15:03:28.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Evm/Dmrs/High/Extreme.py
+-rw-rw-rw-   0        0        0     1487 2024-04-18 15:03:28.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Evm/Dmrs/High/StandardDev.py
+-rw-rw-rw-   0        0        0     1794 2024-04-18 15:03:28.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Evm/Dmrs/High/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:37.350426 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Evm/Dmrs/Low/
+-rw-rw-rw-   0        0        0     2496 2024-04-18 15:03:28.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Evm/Dmrs/Low/Average.py
+-rw-rw-rw-   0        0        0     2496 2024-04-18 15:03:28.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Evm/Dmrs/Low/Current.py
+-rw-rw-rw-   0        0        0     2496 2024-04-18 15:03:28.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Evm/Dmrs/Low/Extreme.py
+-rw-rw-rw-   0        0        0     1483 2024-04-18 15:03:28.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Evm/Dmrs/Low/StandardDev.py
+-rw-rw-rw-   0        0        0     1789 2024-04-18 15:03:28.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Evm/Dmrs/Low/__init__.py
+-rw-rw-rw-   0        0        0     1217 2024-04-18 15:03:28.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Evm/Dmrs/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:37.350426 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Evm/Peak/
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:37.370416 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Evm/Peak/High/
+-rw-rw-rw-   0        0        0     2504 2024-04-18 15:03:28.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Evm/Peak/High/Average.py
+-rw-rw-rw-   0        0        0     2504 2024-04-18 15:03:28.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Evm/Peak/High/Current.py
+-rw-rw-rw-   0        0        0     2504 2024-04-18 15:03:28.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Evm/Peak/High/Extreme.py
+-rw-rw-rw-   0        0        0     1487 2024-04-18 15:03:28.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Evm/Peak/High/StandardDev.py
+-rw-rw-rw-   0        0        0     1794 2024-04-18 15:03:28.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Evm/Peak/High/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:37.391617 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Evm/Peak/Low/
+-rw-rw-rw-   0        0        0     2496 2024-04-18 15:03:28.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Evm/Peak/Low/Average.py
+-rw-rw-rw-   0        0        0     2496 2024-04-18 15:03:28.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Evm/Peak/Low/Current.py
+-rw-rw-rw-   0        0        0     2496 2024-04-18 15:03:28.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Evm/Peak/Low/Extreme.py
+-rw-rw-rw-   0        0        0     1483 2024-04-18 15:03:28.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Evm/Peak/Low/StandardDev.py
+-rw-rw-rw-   0        0        0     1789 2024-04-18 15:03:28.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Evm/Peak/Low/__init__.py
+-rw-rw-rw-   0        0        0     1217 2024-04-18 15:03:28.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Evm/Peak/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:37.394611 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Evm/Rms/
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:37.405974 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Evm/Rms/High/
+-rw-rw-rw-   0        0        0     2494 2024-04-18 15:03:28.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Evm/Rms/High/Average.py
+-rw-rw-rw-   0        0        0     2494 2024-04-18 15:03:28.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Evm/Rms/High/Current.py
+-rw-rw-rw-   0        0        0     2494 2024-04-18 15:03:28.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Evm/Rms/High/Extreme.py
+-rw-rw-rw-   0        0        0     1482 2024-04-18 15:03:28.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Evm/Rms/High/StandardDev.py
+-rw-rw-rw-   0        0        0     1794 2024-04-18 15:03:28.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Evm/Rms/High/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:37.425964 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Evm/Rms/Low/
+-rw-rw-rw-   0        0        0     2486 2024-04-18 15:03:28.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Evm/Rms/Low/Average.py
+-rw-rw-rw-   0        0        0     2486 2024-04-18 15:03:28.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Evm/Rms/Low/Current.py
+-rw-rw-rw-   0        0        0     2486 2024-04-18 15:03:28.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Evm/Rms/Low/Extreme.py
+-rw-rw-rw-   0        0        0     1478 2024-04-18 15:03:28.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Evm/Rms/Low/StandardDev.py
+-rw-rw-rw-   0        0        0     1789 2024-04-18 15:03:28.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Evm/Rms/Low/__init__.py
+-rw-rw-rw-   0        0        0     1212 2024-04-18 15:03:28.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Evm/Rms/__init__.py
+-rw-rw-rw-   0        0        0     1430 2024-04-18 15:03:28.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Evm/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:37.437748 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/FreqError/
+-rw-rw-rw-   0        0        0     2374 2024-04-18 15:03:29.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/FreqError/Average.py
+-rw-rw-rw-   0        0        0     2374 2024-04-18 15:03:29.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/FreqError/Current.py
+-rw-rw-rw-   0        0        0     2374 2024-04-18 15:03:29.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/FreqError/Extreme.py
+-rw-rw-rw-   0        0        0     1419 2024-04-18 15:03:29.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/FreqError/StandardDev.py
+-rw-rw-rw-   0        0        0     1815 2024-04-18 15:03:29.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/FreqError/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:37.454259 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/IqOffset/
+-rw-rw-rw-   0        0        0     2356 2024-04-18 15:03:29.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/IqOffset/Average.py
+-rw-rw-rw-   0        0        0     2356 2024-04-18 15:03:29.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/IqOffset/Current.py
+-rw-rw-rw-   0        0        0     2356 2024-04-18 15:03:29.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/IqOffset/Extreme.py
+-rw-rw-rw-   0        0        0     1410 2024-04-18 15:03:29.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/IqOffset/StandardDev.py
+-rw-rw-rw-   0        0        0     1810 2024-04-18 15:03:29.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/IqOffset/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:37.454259 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Merror/
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:37.454259 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Merror/Dmrs/
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:37.481265 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Merror/Dmrs/High/
+-rw-rw-rw-   0        0        0     2516 2024-04-18 15:03:28.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Merror/Dmrs/High/Average.py
+-rw-rw-rw-   0        0        0     2516 2024-04-18 15:03:28.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Merror/Dmrs/High/Current.py
+-rw-rw-rw-   0        0        0     2516 2024-04-18 15:03:28.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Merror/Dmrs/High/Extreme.py
+-rw-rw-rw-   0        0        0     1493 2024-04-18 15:03:28.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Merror/Dmrs/High/StandardDev.py
+-rw-rw-rw-   0        0        0     1794 2024-04-18 15:03:28.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Merror/Dmrs/High/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:37.487998 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Merror/Dmrs/Low/
+-rw-rw-rw-   0        0        0     2508 2024-04-18 15:03:28.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Merror/Dmrs/Low/Average.py
+-rw-rw-rw-   0        0        0     2508 2024-04-18 15:03:28.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Merror/Dmrs/Low/Current.py
+-rw-rw-rw-   0        0        0     2508 2024-04-18 15:03:28.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Merror/Dmrs/Low/Extreme.py
+-rw-rw-rw-   0        0        0     1489 2024-04-18 15:03:28.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Merror/Dmrs/Low/StandardDev.py
+-rw-rw-rw-   0        0        0     1789 2024-04-18 15:03:28.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Merror/Dmrs/Low/__init__.py
+-rw-rw-rw-   0        0        0     1217 2024-04-18 15:03:28.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Merror/Dmrs/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:37.497998 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Merror/Peak/
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:37.514502 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Merror/Peak/High/
+-rw-rw-rw-   0        0        0     2516 2024-04-18 15:03:28.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Merror/Peak/High/Average.py
+-rw-rw-rw-   0        0        0     2516 2024-04-18 15:03:28.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Merror/Peak/High/Current.py
+-rw-rw-rw-   0        0        0     2516 2024-04-18 15:03:28.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Merror/Peak/High/Extreme.py
+-rw-rw-rw-   0        0        0     1493 2024-04-18 15:03:28.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Merror/Peak/High/StandardDev.py
+-rw-rw-rw-   0        0        0     1794 2024-04-18 15:03:28.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Merror/Peak/High/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:37.537161 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Merror/Peak/Low/
+-rw-rw-rw-   0        0        0     2512 2024-04-18 15:03:28.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Merror/Peak/Low/Average.py
+-rw-rw-rw-   0        0        0     2512 2024-04-18 15:03:28.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Merror/Peak/Low/Current.py
+-rw-rw-rw-   0        0        0     2512 2024-04-18 15:03:28.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Merror/Peak/Low/Extreme.py
+-rw-rw-rw-   0        0        0     1491 2024-04-18 15:03:28.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Merror/Peak/Low/StandardDev.py
+-rw-rw-rw-   0        0        0     1789 2024-04-18 15:03:28.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Merror/Peak/Low/__init__.py
+-rw-rw-rw-   0        0        0     1217 2024-04-18 15:03:28.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Merror/Peak/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:37.542944 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Merror/Rms/
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:37.557197 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Merror/Rms/High/
+-rw-rw-rw-   0        0        0     2510 2024-04-18 15:03:28.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Merror/Rms/High/Average.py
+-rw-rw-rw-   0        0        0     2510 2024-04-18 15:03:28.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Merror/Rms/High/Current.py
+-rw-rw-rw-   0        0        0     2510 2024-04-18 15:03:28.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Merror/Rms/High/Extreme.py
+-rw-rw-rw-   0        0        0     1490 2024-04-18 15:03:28.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Merror/Rms/High/StandardDev.py
+-rw-rw-rw-   0        0        0     1794 2024-04-18 15:03:28.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Merror/Rms/High/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:37.581817 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Merror/Rms/Low/
+-rw-rw-rw-   0        0        0     2502 2024-04-18 15:03:28.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Merror/Rms/Low/Average.py
+-rw-rw-rw-   0        0        0     2502 2024-04-18 15:03:28.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Merror/Rms/Low/Current.py
+-rw-rw-rw-   0        0        0     2502 2024-04-18 15:03:28.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Merror/Rms/Low/Extreme.py
+-rw-rw-rw-   0        0        0     1486 2024-04-18 15:03:28.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Merror/Rms/Low/StandardDev.py
+-rw-rw-rw-   0        0        0     1789 2024-04-18 15:03:28.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Merror/Rms/Low/__init__.py
+-rw-rw-rw-   0        0        0     1212 2024-04-18 15:03:28.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Merror/Rms/__init__.py
+-rw-rw-rw-   0        0        0     1445 2024-04-18 15:03:28.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Merror/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:37.590007 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Perror/
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:37.594988 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Perror/Dmrs/
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:37.611215 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Perror/Dmrs/High/
+-rw-rw-rw-   0        0        0     2510 2024-04-18 15:03:29.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Perror/Dmrs/High/Average.py
+-rw-rw-rw-   0        0        0     2510 2024-04-18 15:03:29.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Perror/Dmrs/High/Current.py
+-rw-rw-rw-   0        0        0     2510 2024-04-18 15:03:29.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Perror/Dmrs/High/Extreme.py
+-rw-rw-rw-   0        0        0     1490 2024-04-18 15:03:29.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Perror/Dmrs/High/StandardDev.py
+-rw-rw-rw-   0        0        0     1794 2024-04-18 15:03:29.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Perror/Dmrs/High/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:37.623275 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Perror/Dmrs/Low/
+-rw-rw-rw-   0        0        0     2502 2024-04-18 15:03:29.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Perror/Dmrs/Low/Average.py
+-rw-rw-rw-   0        0        0     2502 2024-04-18 15:03:29.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Perror/Dmrs/Low/Current.py
+-rw-rw-rw-   0        0        0     2502 2024-04-18 15:03:29.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Perror/Dmrs/Low/Extreme.py
+-rw-rw-rw-   0        0        0     1486 2024-04-18 15:03:29.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Perror/Dmrs/Low/StandardDev.py
+-rw-rw-rw-   0        0        0     1789 2024-04-18 15:03:29.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Perror/Dmrs/Low/__init__.py
+-rw-rw-rw-   0        0        0     1217 2024-04-18 15:03:29.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Perror/Dmrs/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:37.631788 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Perror/Peak/
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:37.647791 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Perror/Peak/High/
+-rw-rw-rw-   0        0        0     2510 2024-04-18 15:03:29.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Perror/Peak/High/Average.py
+-rw-rw-rw-   0        0        0     2510 2024-04-18 15:03:29.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Perror/Peak/High/Current.py
+-rw-rw-rw-   0        0        0     2510 2024-04-18 15:03:29.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Perror/Peak/High/Extreme.py
+-rw-rw-rw-   0        0        0     1490 2024-04-18 15:03:29.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Perror/Peak/High/StandardDev.py
+-rw-rw-rw-   0        0        0     1794 2024-04-18 15:03:29.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Perror/Peak/High/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:37.664296 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Perror/Peak/Low/
+-rw-rw-rw-   0        0        0     2502 2024-04-18 15:03:29.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Perror/Peak/Low/Average.py
+-rw-rw-rw-   0        0        0     2502 2024-04-18 15:03:29.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Perror/Peak/Low/Current.py
+-rw-rw-rw-   0        0        0     2502 2024-04-18 15:03:29.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Perror/Peak/Low/Extreme.py
+-rw-rw-rw-   0        0        0     1486 2024-04-18 15:03:29.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Perror/Peak/Low/StandardDev.py
+-rw-rw-rw-   0        0        0     1789 2024-04-18 15:03:29.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Perror/Peak/Low/__init__.py
+-rw-rw-rw-   0        0        0     1217 2024-04-18 15:03:29.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Perror/Peak/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:37.671097 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Perror/Rms/
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:37.687606 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Perror/Rms/High/
+-rw-rw-rw-   0        0        0     2500 2024-04-18 15:03:29.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Perror/Rms/High/Average.py
+-rw-rw-rw-   0        0        0     2500 2024-04-18 15:03:29.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Perror/Rms/High/Current.py
+-rw-rw-rw-   0        0        0     2500 2024-04-18 15:03:29.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Perror/Rms/High/Extreme.py
+-rw-rw-rw-   0        0        0     1485 2024-04-18 15:03:29.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Perror/Rms/High/StandardDev.py
+-rw-rw-rw-   0        0        0     1794 2024-04-18 15:03:29.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Perror/Rms/High/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:37.704336 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Perror/Rms/Low/
+-rw-rw-rw-   0        0        0     2492 2024-04-18 15:03:28.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Perror/Rms/Low/Average.py
+-rw-rw-rw-   0        0        0     2492 2024-04-18 15:03:28.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Perror/Rms/Low/Current.py
+-rw-rw-rw-   0        0        0     2492 2024-04-18 15:03:28.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Perror/Rms/Low/Extreme.py
+-rw-rw-rw-   0        0        0     1481 2024-04-18 15:03:29.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Perror/Rms/Low/StandardDev.py
+-rw-rw-rw-   0        0        0     1789 2024-04-18 15:03:28.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Perror/Rms/Low/__init__.py
+-rw-rw-rw-   0        0        0     1212 2024-04-18 15:03:28.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Perror/Rms/__init__.py
+-rw-rw-rw-   0        0        0     1445 2024-04-18 15:03:28.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Perror/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:37.721351 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Ppower/
+-rw-rw-rw-   0        0        0     2362 2024-04-18 15:03:29.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Ppower/Average.py
+-rw-rw-rw-   0        0        0     2362 2024-04-18 15:03:29.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Ppower/Current.py
+-rw-rw-rw-   0        0        0     2362 2024-04-18 15:03:29.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Ppower/Maximum.py
+-rw-rw-rw-   0        0        0     2362 2024-04-18 15:03:29.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Ppower/Minimum.py
+-rw-rw-rw-   0        0        0     1413 2024-04-18 15:03:29.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Ppower/StandardDev.py
+-rw-rw-rw-   0        0        0     2044 2024-04-18 15:03:29.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Ppower/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:37.749461 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Psd/
+-rw-rw-rw-   0        0        0     2296 2024-04-18 15:03:29.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Psd/Average.py
+-rw-rw-rw-   0        0        0     2296 2024-04-18 15:03:29.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Psd/Current.py
+-rw-rw-rw-   0        0        0     2296 2024-04-18 15:03:29.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Psd/Maximum.py
+-rw-rw-rw-   0        0        0     2296 2024-04-18 15:03:29.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Psd/Minimum.py
+-rw-rw-rw-   0        0        0     1380 2024-04-18 15:03:29.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Psd/StandardDev.py
+-rw-rw-rw-   0        0        0     2029 2024-04-18 15:03:29.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Psd/__init__.py
+-rw-rw-rw-   0        0        0     1411 2024-04-18 15:03:29.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/SchType.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:37.770523 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Terror/
+-rw-rw-rw-   0        0        0     2354 2024-04-18 15:03:29.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Terror/Average.py
+-rw-rw-rw-   0        0        0     2354 2024-04-18 15:03:29.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Terror/Current.py
+-rw-rw-rw-   0        0        0     2354 2024-04-18 15:03:29.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Terror/Extreme.py
+-rw-rw-rw-   0        0        0     1409 2024-04-18 15:03:29.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Terror/StandardDev.py
+-rw-rw-rw-   0        0        0     1800 2024-04-18 15:03:29.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Terror/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:37.798998 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Tpower/
+-rw-rw-rw-   0        0        0     2348 2024-04-18 15:03:29.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Tpower/Average.py
+-rw-rw-rw-   0        0        0     2348 2024-04-18 15:03:29.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Tpower/Current.py
+-rw-rw-rw-   0        0        0     2348 2024-04-18 15:03:29.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Tpower/Maximum.py
+-rw-rw-rw-   0        0        0     2348 2024-04-18 15:03:29.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Tpower/Minimum.py
+-rw-rw-rw-   0        0        0     1406 2024-04-18 15:03:29.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Tpower/StandardDev.py
+-rw-rw-rw-   0        0        0     2044 2024-04-18 15:03:29.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Tpower/__init__.py
+-rw-rw-rw-   0        0        0     3969 2024-04-18 15:03:28.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:37.808992 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Pmonitor/
+-rw-rw-rw-   0        0        0     1809 2024-04-18 15:03:31.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Pmonitor/Peak.py
+-rw-rw-rw-   0        0        0     1802 2024-04-18 15:03:31.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Pmonitor/Rms.py
+-rw-rw-rw-   0        0        0     1232 2024-04-18 15:03:31.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Pmonitor/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:37.811177 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Power/
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:37.831337 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Power/TxPower/
+-rw-rw-rw-   0        0        0     1945 2024-04-18 15:03:31.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Power/TxPower/Average.py
+-rw-rw-rw-   0        0        0     1945 2024-04-18 15:03:31.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Power/TxPower/Current.py
+-rw-rw-rw-   0        0        0     1945 2024-04-18 15:03:31.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Power/TxPower/Maximum.py
+-rw-rw-rw-   0        0        0     1945 2024-04-18 15:03:31.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Power/TxPower/Minimum.py
+-rw-rw-rw-   0        0        0     1256 2024-04-18 15:03:31.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Power/TxPower/StandardDev.py
+-rw-rw-rw-   0        0        0     2049 2024-04-18 15:03:31.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Power/TxPower/__init__.py
+-rw-rw-rw-   0        0        0     1029 2024-04-18 15:03:31.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Power/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:37.841411 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/SeMask/
+-rw-rw-rw-   0        0        0     2313 2024-04-18 15:03:31.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/SeMask/Dallocation.py
+-rw-rw-rw-   0        0        0     1671 2024-04-18 15:03:31.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/SeMask/DchType.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:37.841411 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/SeMask/Margin/
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:37.854386 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/SeMask/Margin/Area/
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:37.864386 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/SeMask/Margin/Area/Negativ/
+-rw-rw-rw-   0        0        0     2427 2024-04-18 15:03:31.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/SeMask/Margin/Area/Negativ/Average.py
+-rw-rw-rw-   0        0        0     2433 2024-04-18 15:03:31.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/SeMask/Margin/Area/Negativ/Current.py
+-rw-rw-rw-   0        0        0     2427 2024-04-18 15:03:31.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/SeMask/Margin/Area/Negativ/Minimum.py
+-rw-rw-rw-   0        0        0     1533 2024-04-18 15:03:31.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/SeMask/Margin/Area/Negativ/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:37.881394 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/SeMask/Margin/Area/Positiv/
+-rw-rw-rw-   0        0        0     2446 2024-04-18 15:03:31.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/SeMask/Margin/Area/Positiv/Average.py
+-rw-rw-rw-   0        0        0     2452 2024-04-18 15:03:31.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/SeMask/Margin/Area/Positiv/Current.py
+-rw-rw-rw-   0        0        0     2446 2024-04-18 15:03:31.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/SeMask/Margin/Area/Positiv/Minimum.py
+-rw-rw-rw-   0        0        0     1533 2024-04-18 15:03:31.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/SeMask/Margin/Area/Positiv/__init__.py
+-rw-rw-rw-   0        0        0     2087 2024-04-18 15:03:31.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/SeMask/Margin/Area/__init__.py
+-rw-rw-rw-   0        0        0     1012 2024-04-18 15:03:31.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/SeMask/Margin/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:37.904412 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/SeMask/Obw/
+-rw-rw-rw-   0        0        0     2286 2024-04-18 15:03:31.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/SeMask/Obw/Average.py
+-rw-rw-rw-   0        0        0     2286 2024-04-18 15:03:31.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/SeMask/Obw/Current.py
+-rw-rw-rw-   0        0        0     2286 2024-04-18 15:03:31.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/SeMask/Obw/Extreme.py
+-rw-rw-rw-   0        0        0     1375 2024-04-18 15:03:31.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/SeMask/Obw/StandardDev.py
+-rw-rw-rw-   0        0        0     1785 2024-04-18 15:03:31.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/SeMask/Obw/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:37.930918 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/SeMask/TxPower/
+-rw-rw-rw-   0        0        0     2336 2024-04-18 15:03:31.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/SeMask/TxPower/Average.py
+-rw-rw-rw-   0        0        0     2336 2024-04-18 15:03:31.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/SeMask/TxPower/Current.py
+-rw-rw-rw-   0        0        0     2336 2024-04-18 15:03:31.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/SeMask/TxPower/Maximum.py
+-rw-rw-rw-   0        0        0     2336 2024-04-18 15:03:31.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/SeMask/TxPower/Minimum.py
+-rw-rw-rw-   0        0        0     1400 2024-04-18 15:03:31.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/SeMask/TxPower/StandardDev.py
+-rw-rw-rw-   0        0        0     2049 2024-04-18 15:03:31.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/SeMask/TxPower/__init__.py
+-rw-rw-rw-   0        0        0     2003 2024-04-18 15:03:31.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/SeMask/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:37.937932 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:37.969939 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/Aclr/
+-rw-rw-rw-   0        0        0     6769 2024-04-18 15:03:30.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/Aclr/Average.py
+-rw-rw-rw-   0        0        0     6769 2024-04-18 15:03:30.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/Aclr/Current.py
+-rw-rw-rw-   0        0        0     2461 2024-04-18 15:03:30.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/Aclr/Dallocation.py
+-rw-rw-rw-   0        0        0     2303 2024-04-18 15:03:30.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/Aclr/DchType.py
+-rw-rw-rw-   0        0        0     1958 2024-04-18 15:03:30.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/Aclr/Dmodulation.py
+-rw-rw-rw-   0        0        0     2066 2024-04-18 15:03:30.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/Aclr/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:37.984012 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/EsFlatness/
+-rw-rw-rw-   0        0        0     5355 2024-04-18 15:03:30.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/EsFlatness/Average.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:37.988575 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/EsFlatness/Current/
+-rw-rw-rw-   0        0        0     2784 2024-04-18 15:03:30.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/EsFlatness/Current/ScIndex.py
+-rw-rw-rw-   0        0        0     6001 2024-04-18 15:03:30.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/EsFlatness/Current/__init__.py
+-rw-rw-rw-   0        0        0     5355 2024-04-18 15:03:30.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/EsFlatness/Extreme.py
+-rw-rw-rw-   0        0        0     5175 2024-04-18 15:03:30.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/EsFlatness/StandardDev.py
+-rw-rw-rw-   0        0        0     1820 2024-04-18 15:03:30.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/EsFlatness/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:37.988575 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/InbandEmission/
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:37.998571 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/InbandEmission/Cc/
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:38.009753 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/InbandEmission/Cc/Margin/
+-rw-rw-rw-   0        0        0     2927 2024-04-18 15:03:30.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/InbandEmission/Cc/Margin/Average.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:38.015737 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/InbandEmission/Cc/Margin/Current/
+-rw-rw-rw-   0        0        0     2794 2024-04-18 15:03:30.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/InbandEmission/Cc/Margin/Current/RbIndex.py
+-rw-rw-rw-   0        0        0     3573 2024-04-18 15:03:30.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/InbandEmission/Cc/Margin/Current/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:38.020723 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/InbandEmission/Cc/Margin/Extreme/
+-rw-rw-rw-   0        0        0     2794 2024-04-18 15:03:30.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/InbandEmission/Cc/Margin/Extreme/RbIndex.py
+-rw-rw-rw-   0        0        0     3573 2024-04-18 15:03:30.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/InbandEmission/Cc/Margin/Extreme/__init__.py
+-rw-rw-rw-   0        0        0     2949 2024-04-18 15:03:30.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/InbandEmission/Cc/Margin/StandardDev.py
+-rw-rw-rw-   0        0        0     1804 2024-04-18 15:03:30.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/InbandEmission/Cc/Margin/__init__.py
+-rw-rw-rw-   0        0        0     1981 2024-04-18 15:03:30.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/InbandEmission/Cc/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:38.022764 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/InbandEmission/Margin/
+-rw-rw-rw-   0        0        0     2176 2024-04-18 15:03:30.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/InbandEmission/Margin/Average.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:38.032759 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/InbandEmission/Margin/Current/
+-rw-rw-rw-   0        0        0     2205 2024-04-18 15:03:30.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/InbandEmission/Margin/Current/RbIndex.py
+-rw-rw-rw-   0        0        0     2822 2024-04-18 15:03:30.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/InbandEmission/Margin/Current/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:38.042754 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/InbandEmission/Margin/Extreme/
+-rw-rw-rw-   0        0        0     2205 2024-04-18 15:03:30.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/InbandEmission/Margin/Extreme/RbIndex.py
+-rw-rw-rw-   0        0        0     2822 2024-04-18 15:03:30.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/InbandEmission/Margin/Extreme/__init__.py
+-rw-rw-rw-   0        0        0     2198 2024-04-18 15:03:30.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/InbandEmission/Margin/StandardDev.py
+-rw-rw-rw-   0        0        0     1802 2024-04-18 15:03:30.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/InbandEmission/Margin/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:38.042754 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/InbandEmission/Scc/
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:38.052748 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/InbandEmission/Scc/Margin/
+-rw-rw-rw-   0        0        0     2508 2024-04-18 15:03:30.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/InbandEmission/Scc/Margin/Average.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:38.062744 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/InbandEmission/Scc/Margin/Current/
+-rw-rw-rw-   0        0        0     2537 2024-04-18 15:03:30.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/InbandEmission/Scc/Margin/Current/RbIndex.py
+-rw-rw-rw-   0        0        0     3154 2024-04-18 15:03:30.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/InbandEmission/Scc/Margin/Current/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:38.062744 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/InbandEmission/Scc/Margin/Extreme/
+-rw-rw-rw-   0        0        0     2537 2024-04-18 15:03:30.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/InbandEmission/Scc/Margin/Extreme/RbIndex.py
+-rw-rw-rw-   0        0        0     3154 2024-04-18 15:03:30.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/InbandEmission/Scc/Margin/Extreme/__init__.py
+-rw-rw-rw-   0        0        0     2530 2024-04-18 15:03:30.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/InbandEmission/Scc/Margin/StandardDev.py
+-rw-rw-rw-   0        0        0     1804 2024-04-18 15:03:30.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/InbandEmission/Scc/Margin/__init__.py
+-rw-rw-rw-   0        0        0     1921 2024-04-18 15:03:30.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/InbandEmission/Scc/__init__.py
+-rw-rw-rw-   0        0        0     1485 2024-04-18 15:03:30.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/InbandEmission/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:38.097754 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/Modulation/
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:38.121268 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/Modulation/Average/
+-rw-rw-rw-   0        0        0     2492 2024-04-18 15:03:29.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/Modulation/Average/Dmrs.py
+-rw-rw-rw-   0        0        0     3347 2024-04-18 15:03:29.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/Modulation/Average/Emph.py
+-rw-rw-rw-   0        0        0     2061 2024-04-18 15:03:29.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/Modulation/Average/Globale.py
+-rw-rw-rw-   0        0        0     2027 2024-04-18 15:03:29.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/Modulation/Average/Mod.py
+-rw-rw-rw-   0        0        0     1982 2024-04-18 15:03:29.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/Modulation/Average/Pow.py
+-rw-rw-rw-   0        0        0    13533 2024-04-18 15:03:29.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/Modulation/Average/__init__.py
+-rw-rw-rw-   0        0        0    12023 2024-04-18 15:03:30.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/Modulation/Current.py
+-rw-rw-rw-   0        0        0     2479 2024-04-18 15:03:30.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/Modulation/Dallocation.py
+-rw-rw-rw-   0        0        0     2321 2024-04-18 15:03:30.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/Modulation/DchType.py
+-rw-rw-rw-   0        0        0     2236 2024-04-18 15:03:30.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/Modulation/Dmodulation.py
+-rw-rw-rw-   0        0        0    13069 2024-04-18 15:03:30.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/Modulation/Extreme.py
+-rw-rw-rw-   0        0        0     2064 2024-04-18 15:03:30.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/Modulation/SchType.py
+-rw-rw-rw-   0        0        0    11385 2024-04-18 15:03:30.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/Modulation/StandardDev.py
+-rw-rw-rw-   0        0        0     2861 2024-04-18 15:03:29.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/Modulation/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:38.121268 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/Pmonitor/
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:38.137783 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/Pmonitor/Array/
+-rw-rw-rw-   0        0        0     1700 2024-04-18 15:03:31.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/Pmonitor/Array/Length.py
+-rw-rw-rw-   0        0        0     1868 2024-04-18 15:03:31.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/Pmonitor/Array/Start.py
+-rw-rw-rw-   0        0        0     1253 2024-04-18 15:03:31.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/Pmonitor/Array/__init__.py
+-rw-rw-rw-   0        0        0     2412 2024-04-18 15:03:31.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/Pmonitor/Peak.py
+-rw-rw-rw-   0        0        0     2403 2024-04-18 15:03:31.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/Pmonitor/Rms.py
+-rw-rw-rw-   0        0        0     1462 2024-04-18 15:03:31.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/Pmonitor/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:38.157134 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/Power/
+-rw-rw-rw-   0        0        0     3904 2024-04-18 15:03:30.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/Power/Average.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:38.187120 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/Power/Cc/
+-rw-rw-rw-   0        0        0     4685 2024-04-18 15:03:31.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/Power/Cc/Average.py
+-rw-rw-rw-   0        0        0     4685 2024-04-18 15:03:31.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/Power/Cc/Current.py
+-rw-rw-rw-   0        0        0     4709 2024-04-18 15:03:31.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/Power/Cc/Maximum.py
+-rw-rw-rw-   0        0        0     4709 2024-04-18 15:03:31.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/Power/Cc/Minimum.py
+-rw-rw-rw-   0        0        0     2659 2024-04-18 15:03:31.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/Power/Cc/StandardDev.py
+-rw-rw-rw-   0        0        0     3010 2024-04-18 15:03:30.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/Power/Cc/__init__.py
+-rw-rw-rw-   0        0        0     3904 2024-04-18 15:03:30.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/Power/Current.py
+-rw-rw-rw-   0        0        0     3928 2024-04-18 15:03:30.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/Power/Maximum.py
+-rw-rw-rw-   0        0        0     3928 2024-04-18 15:03:30.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/Power/Minimum.py
+-rw-rw-rw-   0        0        0     2256 2024-04-18 15:03:30.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/Power/StandardDev.py
+-rw-rw-rw-   0        0        0     2244 2024-04-18 15:03:30.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/Power/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:38.225225 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/SeMask/
+-rw-rw-rw-   0        0        0     4781 2024-04-18 15:03:30.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/SeMask/Average.py
+-rw-rw-rw-   0        0        0     4781 2024-04-18 15:03:30.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/SeMask/Current.py
+-rw-rw-rw-   0        0        0     2467 2024-04-18 15:03:30.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/SeMask/Dallocation.py
+-rw-rw-rw-   0        0        0     2309 2024-04-18 15:03:30.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/SeMask/DchType.py
+-rw-rw-rw-   0        0        0     1964 2024-04-18 15:03:30.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/SeMask/Dmodulation.py
+-rw-rw-rw-   0        0        0     5109 2024-04-18 15:03:30.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/SeMask/Extreme.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:38.231206 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/SeMask/Margin/
+-rw-rw-rw-   0        0        0     3340 2024-04-18 15:03:30.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/SeMask/Margin/All.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:38.240228 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/SeMask/Margin/Average/
+-rw-rw-rw-   0        0        0     2924 2024-04-18 15:03:30.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/SeMask/Margin/Average/Negativ.py
+-rw-rw-rw-   0        0        0     2924 2024-04-18 15:03:30.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/SeMask/Margin/Average/Positiv.py
+-rw-rw-rw-   0        0        0     1289 2024-04-18 15:03:30.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/SeMask/Margin/Average/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:38.242737 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/SeMask/Margin/Current/
+-rw-rw-rw-   0        0        0     2930 2024-04-18 15:03:30.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/SeMask/Margin/Current/Negativ.py
+-rw-rw-rw-   0        0        0     2930 2024-04-18 15:03:30.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/SeMask/Margin/Current/Positiv.py
+-rw-rw-rw-   0        0        0     1289 2024-04-18 15:03:30.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/SeMask/Margin/Current/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:38.254586 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/SeMask/Margin/Minimum/
+-rw-rw-rw-   0        0        0     2924 2024-04-18 15:03:30.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/SeMask/Margin/Minimum/Negativ.py
+-rw-rw-rw-   0        0        0     2924 2024-04-18 15:03:30.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/SeMask/Margin/Minimum/Positiv.py
+-rw-rw-rw-   0        0        0     1289 2024-04-18 15:03:30.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/SeMask/Margin/Minimum/__init__.py
+-rw-rw-rw-   0        0        0     4521 2024-04-18 15:03:30.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/SeMask/Margin/__init__.py
+-rw-rw-rw-   0        0        0     4445 2024-04-18 15:03:30.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/SeMask/StandardDev.py
+-rw-rw-rw-   0        0        0     2833 2024-04-18 15:03:30.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/SeMask/__init__.py
+-rw-rw-rw-   0        0        0     3418 2024-04-18 15:03:29.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/__init__.py
+-rw-rw-rw-   0        0        0     1676 2024-04-18 15:03:28.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Sreliability.py
+-rw-rw-rw-   0        0        0     3091 2024-04-18 15:03:28.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:38.264586 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Merror/
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:38.264586 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Merror/Average/
+-rw-rw-rw-   0        0        0     3117 2024-04-18 15:03:27.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Merror/Average/Nref.py
+-rw-rw-rw-   0        0        0     4650 2024-04-18 15:03:27.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Merror/Average/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:38.271092 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Merror/Current/
+-rw-rw-rw-   0        0        0     3117 2024-04-18 15:03:27.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Merror/Current/Nref.py
+-rw-rw-rw-   0        0        0     4650 2024-04-18 15:03:27.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Merror/Current/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:38.271092 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Merror/Maximum/
+-rw-rw-rw-   0        0        0     3117 2024-04-18 15:03:27.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Merror/Maximum/Nref.py
+-rw-rw-rw-   0        0        0     4650 2024-04-18 15:03:27.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Merror/Maximum/__init__.py
+-rw-rw-rw-   0        0        0     1521 2024-04-18 15:03:27.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Merror/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:38.304321 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Modulation/
+-rw-rw-rw-   0        0        0    12238 2024-04-18 15:03:27.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Modulation/Average.py
+-rw-rw-rw-   0        0        0    12238 2024-04-18 15:03:27.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Modulation/Current.py
+-rw-rw-rw-   0        0        0     1976 2024-04-18 15:03:27.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Modulation/Dallocation.py
+-rw-rw-rw-   0        0        0     1565 2024-04-18 15:03:27.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Modulation/DchType.py
+-rw-rw-rw-   0        0        0     1404 2024-04-18 15:03:27.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Modulation/Dmodulation.py
+-rw-rw-rw-   0        0        0    13072 2024-04-18 15:03:27.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Modulation/Extreme.py
+-rw-rw-rw-   0        0        0     1277 2024-04-18 15:03:27.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Modulation/SchType.py
+-rw-rw-rw-   0        0        0    11439 2024-04-18 15:03:27.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Modulation/StandardDev.py
+-rw-rw-rw-   0        0        0     2857 2024-04-18 15:03:27.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Modulation/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:38.321330 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Pdynamics/
+-rw-rw-rw-   0        0        0     6417 2024-04-18 15:03:27.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Pdynamics/Average.py
+-rw-rw-rw-   0        0        0     6417 2024-04-18 15:03:27.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Pdynamics/Current.py
+-rw-rw-rw-   0        0        0     6417 2024-04-18 15:03:28.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Pdynamics/Maximum.py
+-rw-rw-rw-   0        0        0     6417 2024-04-18 15:03:28.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Pdynamics/Minimum.py
+-rw-rw-rw-   0        0        0     5605 2024-04-18 15:03:28.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Pdynamics/StandardDev.py
+-rw-rw-rw-   0        0        0     2056 2024-04-18 15:03:27.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Pdynamics/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:38.331330 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Perror/
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:38.337841 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Perror/Average/
+-rw-rw-rw-   0        0        0     3117 2024-04-18 15:03:27.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Perror/Average/Nref.py
+-rw-rw-rw-   0        0        0     4626 2024-04-18 15:03:27.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Perror/Average/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:38.342873 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Perror/Current/
+-rw-rw-rw-   0        0        0     3117 2024-04-18 15:03:27.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Perror/Current/Nref.py
+-rw-rw-rw-   0        0        0     4626 2024-04-18 15:03:27.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Perror/Current/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:38.358332 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Perror/Maximum/
+-rw-rw-rw-   0        0        0     3117 2024-04-18 15:03:27.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Perror/Maximum/Nref.py
+-rw-rw-rw-   0        0        0     4626 2024-04-18 15:03:27.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Perror/Maximum/__init__.py
+-rw-rw-rw-   0        0        0     1521 2024-04-18 15:03:27.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Perror/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:38.380284 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Pmonitor/
+-rw-rw-rw-   0        0        0     3202 2024-04-18 15:03:28.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Pmonitor/Average.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:38.407328 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Pmonitor/Cc/
+-rw-rw-rw-   0        0        0     2872 2024-04-18 15:03:28.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Pmonitor/Cc/Average.py
+-rw-rw-rw-   0        0        0     2872 2024-04-18 15:03:28.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Pmonitor/Cc/Current.py
+-rw-rw-rw-   0        0        0     2872 2024-04-18 15:03:28.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Pmonitor/Cc/Maximum.py
+-rw-rw-rw-   0        0        0     2872 2024-04-18 15:03:28.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Pmonitor/Cc/Minimum.py
+-rw-rw-rw-   0        0        0     2904 2024-04-18 15:03:28.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Pmonitor/Cc/StandardDev.py
+-rw-rw-rw-   0        0        0     2990 2024-04-18 15:03:28.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Pmonitor/Cc/__init__.py
+-rw-rw-rw-   0        0        0     3202 2024-04-18 15:03:28.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Pmonitor/Current.py
+-rw-rw-rw-   0        0        0     3202 2024-04-18 15:03:28.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Pmonitor/Maximum.py
+-rw-rw-rw-   0        0        0     3202 2024-04-18 15:03:28.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Pmonitor/Minimum.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:38.423389 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Pmonitor/Pcc/
+-rw-rw-rw-   0        0        0     1986 2024-04-18 15:03:28.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Pmonitor/Pcc/Average.py
+-rw-rw-rw-   0        0        0     1986 2024-04-18 15:03:28.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Pmonitor/Pcc/Current.py
+-rw-rw-rw-   0        0        0     1986 2024-04-18 15:03:28.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Pmonitor/Pcc/Maximum.py
+-rw-rw-rw-   0        0        0     1986 2024-04-18 15:03:28.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Pmonitor/Pcc/Minimum.py
+-rw-rw-rw-   0        0        0     2018 2024-04-18 15:03:28.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Pmonitor/Pcc/StandardDev.py
+-rw-rw-rw-   0        0        0     2028 2024-04-18 15:03:28.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Pmonitor/Pcc/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:38.454382 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Pmonitor/Scc/
+-rw-rw-rw-   0        0        0     1986 2024-04-18 15:03:28.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Pmonitor/Scc/Average.py
+-rw-rw-rw-   0        0        0     1986 2024-04-18 15:03:28.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Pmonitor/Scc/Current.py
+-rw-rw-rw-   0        0        0     1986 2024-04-18 15:03:28.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Pmonitor/Scc/Maximum.py
+-rw-rw-rw-   0        0        0     1986 2024-04-18 15:03:28.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Pmonitor/Scc/Minimum.py
+-rw-rw-rw-   0        0        0     2018 2024-04-18 15:03:28.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Pmonitor/Scc/StandardDev.py
+-rw-rw-rw-   0        0        0     2028 2024-04-18 15:03:28.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Pmonitor/Scc/__init__.py
+-rw-rw-rw-   0        0        0     3244 2024-04-18 15:03:28.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Pmonitor/StandardDev.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:38.464381 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Pmonitor/Ulca/
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:38.471390 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Pmonitor/Ulca/Pcc/
+-rw-rw-rw-   0        0        0     2020 2024-04-18 15:03:28.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Pmonitor/Ulca/Pcc/Average.py
+-rw-rw-rw-   0        0        0     2020 2024-04-18 15:03:28.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Pmonitor/Ulca/Pcc/Current.py
+-rw-rw-rw-   0        0        0     2020 2024-04-18 15:03:28.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Pmonitor/Ulca/Pcc/Maximum.py
+-rw-rw-rw-   0        0        0     2020 2024-04-18 15:03:28.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Pmonitor/Ulca/Pcc/Minimum.py
+-rw-rw-rw-   0        0        0     2052 2024-04-18 15:03:28.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Pmonitor/Ulca/Pcc/StandardDev.py
+-rw-rw-rw-   0        0        0     2030 2024-04-18 15:03:28.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Pmonitor/Ulca/Pcc/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:38.504418 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Pmonitor/Ulca/Scc/
+-rw-rw-rw-   0        0        0     2675 2024-04-18 15:03:28.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Pmonitor/Ulca/Scc/Average.py
+-rw-rw-rw-   0        0        0     2675 2024-04-18 15:03:28.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Pmonitor/Ulca/Scc/Current.py
+-rw-rw-rw-   0        0        0     2675 2024-04-18 15:03:28.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Pmonitor/Ulca/Scc/Maximum.py
+-rw-rw-rw-   0        0        0     2675 2024-04-18 15:03:28.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Pmonitor/Ulca/Scc/Minimum.py
+-rw-rw-rw-   0        0        0     2707 2024-04-18 15:03:28.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Pmonitor/Ulca/Scc/StandardDev.py
+-rw-rw-rw-   0        0        0     2934 2024-04-18 15:03:28.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Pmonitor/Ulca/Scc/__init__.py
+-rw-rw-rw-   0        0        0     1205 2024-04-18 15:03:28.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Pmonitor/Ulca/__init__.py
+-rw-rw-rw-   0        0        0     2899 2024-04-18 15:03:28.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Pmonitor/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:38.514418 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ReferenceMarker/
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:38.520923 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ReferenceMarker/EvMagnitude/
+-rw-rw-rw-   0        0        0     1900 2024-04-18 15:03:26.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ReferenceMarker/EvMagnitude/Peak.py
+-rw-rw-rw-   0        0        0     2531 2024-04-18 15:03:26.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ReferenceMarker/EvMagnitude/__init__.py
+-rw-rw-rw-   0        0        0     1868 2024-04-18 15:03:26.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ReferenceMarker/Merror.py
+-rw-rw-rw-   0        0        0     1706 2024-04-18 15:03:26.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ReferenceMarker/Pdynamics.py
+-rw-rw-rw-   0        0        0     1868 2024-04-18 15:03:26.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ReferenceMarker/Perror.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:38.530922 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ReferenceMarker/Pmonitor/
+-rw-rw-rw-   0        0        0     3066 2024-04-18 15:03:26.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ReferenceMarker/Pmonitor/Cc.py
+-rw-rw-rw-   0        0        0     1004 2024-04-18 15:03:26.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ReferenceMarker/Pmonitor/__init__.py
+-rw-rw-rw-   0        0        0     2093 2024-04-18 15:03:26.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ReferenceMarker/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:38.553606 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/SeMask/
+-rw-rw-rw-   0        0        0     4347 2024-04-18 15:03:27.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/SeMask/Average.py
+-rw-rw-rw-   0        0        0     4347 2024-04-18 15:03:27.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/SeMask/Current.py
+-rw-rw-rw-   0        0        0     1964 2024-04-18 15:03:27.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/SeMask/Dallocation.py
+-rw-rw-rw-   0        0        0     1553 2024-04-18 15:03:27.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/SeMask/DchType.py
+-rw-rw-rw-   0        0        0     4527 2024-04-18 15:03:27.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/SeMask/Extreme.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:38.563602 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/SeMask/Margin/
+-rw-rw-rw-   0        0        0     3079 2024-04-18 15:03:27.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/SeMask/Margin/All.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:38.571185 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/SeMask/Margin/Average/
+-rw-rw-rw-   0        0        0     2576 2024-04-18 15:03:27.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/SeMask/Margin/Average/Negativ.py
+-rw-rw-rw-   0        0        0     2576 2024-04-18 15:03:27.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/SeMask/Margin/Average/Positiv.py
+-rw-rw-rw-   0        0        0     1285 2024-04-18 15:03:27.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/SeMask/Margin/Average/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:38.591537 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/SeMask/Margin/Current/
+-rw-rw-rw-   0        0        0     2582 2024-04-18 15:03:27.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/SeMask/Margin/Current/Negativ.py
+-rw-rw-rw-   0        0        0     2582 2024-04-18 15:03:27.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/SeMask/Margin/Current/Positiv.py
+-rw-rw-rw-   0        0        0     1285 2024-04-18 15:03:27.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/SeMask/Margin/Current/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:38.601533 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/SeMask/Margin/Minimum/
+-rw-rw-rw-   0        0        0     2576 2024-04-18 15:03:27.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/SeMask/Margin/Minimum/Negativ.py
+-rw-rw-rw-   0        0        0     2576 2024-04-18 15:03:27.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/SeMask/Margin/Minimum/Positiv.py
+-rw-rw-rw-   0        0        0     1285 2024-04-18 15:03:27.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/SeMask/Margin/Minimum/__init__.py
+-rw-rw-rw-   0        0        0     3890 2024-04-18 15:03:27.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/SeMask/Margin/__init__.py
+-rw-rw-rw-   0        0        0     3256 2024-04-18 15:03:27.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/SeMask/Maximum.py
+-rw-rw-rw-   0        0        0     3026 2024-04-18 15:03:27.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/SeMask/Minimum.py
+-rw-rw-rw-   0        0        0     3969 2024-04-18 15:03:27.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/SeMask/StandardDev.py
+-rw-rw-rw-   0        0        0     3041 2024-04-18 15:03:27.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/SeMask/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:38.601533 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/State/
+-rw-rw-rw-   0        0        0     2096 2024-04-18 15:03:26.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/State/All.py
+-rw-rw-rw-   0        0        0     2743 2024-04-18 15:03:26.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/State/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:38.611527 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Trace/
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:38.611527 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Trace/Aclr/
+-rw-rw-rw-   0        0        0     3006 2024-04-18 15:03:26.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Trace/Aclr/Average.py
+-rw-rw-rw-   0        0        0     3006 2024-04-18 15:03:26.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Trace/Aclr/Current.py
+-rw-rw-rw-   0        0        0     1268 2024-04-18 15:03:26.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Trace/Aclr/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:38.629856 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Trace/EsFlatness/
+-rw-rw-rw-   0        0        0     2030 2024-04-18 15:03:26.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Trace/EsFlatness/Phase.py
+-rw-rw-rw-   0        0        0     2640 2024-04-18 15:03:26.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Trace/EsFlatness/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:38.644406 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Trace/EvmSymbol/
+-rw-rw-rw-   0        0        0     1900 2024-04-18 15:03:26.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Trace/EvmSymbol/Average.py
+-rw-rw-rw-   0        0        0     1900 2024-04-18 15:03:26.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Trace/EvmSymbol/Current.py
+-rw-rw-rw-   0        0        0     1900 2024-04-18 15:03:26.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Trace/EvmSymbol/Maximum.py
+-rw-rw-rw-   0        0        0     1537 2024-04-18 15:03:26.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Trace/EvmSymbol/__init__.py
+-rw-rw-rw-   0        0        0     1907 2024-04-18 15:03:26.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Trace/Evmc.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:38.658003 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Trace/Iemissions/
+-rw-rw-rw-   0        0        0     3979 2024-04-18 15:03:26.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Trace/Iemissions/Cc.py
+-rw-rw-rw-   0        0        0     1664 2024-04-18 15:03:26.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Trace/Iemissions/Pcc.py
+-rw-rw-rw-   0        0        0     1660 2024-04-18 15:03:26.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Trace/Iemissions/Scc.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:38.667975 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Trace/Iemissions/Ulca/
+-rw-rw-rw-   0        0        0     1698 2024-04-18 15:03:26.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Trace/Iemissions/Ulca/Pcc.py
+-rw-rw-rw-   0        0        0     3615 2024-04-18 15:03:26.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Trace/Iemissions/Ulca/Scc.py
+-rw-rw-rw-   0        0        0     1206 2024-04-18 15:03:26.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Trace/Iemissions/Ulca/__init__.py
+-rw-rw-rw-   0        0        0     1659 2024-04-18 15:03:26.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Trace/Iemissions/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:38.674026 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Trace/Iq/
+-rw-rw-rw-   0        0        0     1895 2024-04-18 15:03:26.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Trace/Iq/High.py
+-rw-rw-rw-   0        0        0     1889 2024-04-18 15:03:26.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Trace/Iq/Low.py
+-rw-rw-rw-   0        0        0     1202 2024-04-18 15:03:26.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Trace/Iq/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:38.687582 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Trace/Pdynamics/
+-rw-rw-rw-   0        0        0     2578 2024-04-18 15:03:26.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Trace/Pdynamics/Average.py
+-rw-rw-rw-   0        0        0     2578 2024-04-18 15:03:26.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Trace/Pdynamics/Current.py
+-rw-rw-rw-   0        0        0     2578 2024-04-18 15:03:26.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Trace/Pdynamics/Maximum.py
+-rw-rw-rw-   0        0        0     1537 2024-04-18 15:03:26.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Trace/Pdynamics/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:38.704589 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Trace/Pmonitor/
+-rw-rw-rw-   0        0        0     3881 2024-04-18 15:03:26.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Trace/Pmonitor/Cc.py
+-rw-rw-rw-   0        0        0     1652 2024-04-18 15:03:26.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Trace/Pmonitor/Pcc.py
+-rw-rw-rw-   0        0        0     1648 2024-04-18 15:03:26.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Trace/Pmonitor/Scc.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:38.714588 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Trace/Pmonitor/Ulca/
+-rw-rw-rw-   0        0        0     1686 2024-04-18 15:03:26.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Trace/Pmonitor/Ulca/Pcc.py
+-rw-rw-rw-   0        0        0     3603 2024-04-18 15:03:26.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Trace/Pmonitor/Ulca/Scc.py
+-rw-rw-rw-   0        0        0     1206 2024-04-18 15:03:26.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Trace/Pmonitor/Ulca/__init__.py
+-rw-rw-rw-   0        0        0     1649 2024-04-18 15:03:26.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Trace/Pmonitor/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:38.721097 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Trace/RbaTable/
+-rw-rw-rw-   0        0        0     5647 2024-04-18 15:03:26.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Trace/RbaTable/Cc.py
+-rw-rw-rw-   0        0        0     2342 2024-04-18 15:03:26.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Trace/RbaTable/Pcc.py
+-rw-rw-rw-   0        0        0     2338 2024-04-18 15:03:26.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Trace/RbaTable/Scc.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:38.737612 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Trace/RbaTable/Ulca/
+-rw-rw-rw-   0        0        0     2378 2024-04-18 15:03:26.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Trace/RbaTable/Ulca/Pcc.py
+-rw-rw-rw-   0        0        0     4295 2024-04-18 15:03:26.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Trace/RbaTable/Ulca/Scc.py
+-rw-rw-rw-   0        0        0     1206 2024-04-18 15:03:26.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Trace/RbaTable/Ulca/__init__.py
+-rw-rw-rw-   0        0        0     1649 2024-04-18 15:03:26.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Trace/RbaTable/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:38.744655 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Trace/SeMask/
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:38.754586 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Trace/SeMask/Rbw/
+-rw-rw-rw-   0        0        0     3423 2024-04-18 15:03:26.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Trace/SeMask/Rbw/Average.py
+-rw-rw-rw-   0        0        0     3423 2024-04-18 15:03:26.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Trace/SeMask/Rbw/Current.py
+-rw-rw-rw-   0        0        0     3423 2024-04-18 15:03:26.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Trace/SeMask/Rbw/Maximum.py
+-rw-rw-rw-   0        0        0     2354 2024-04-18 15:03:26.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Trace/SeMask/Rbw/__init__.py
+-rw-rw-rw-   0        0        0     1002 2024-04-18 15:03:26.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Trace/SeMask/__init__.py
+-rw-rw-rw-   0        0        0     3225 2024-04-18 15:03:26.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Trace/__init__.py
+-rw-rw-rw-   0        0        0     1111 2024-04-18 15:03:26.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/VfThroughput.py
+-rw-rw-rw-   0        0        0     9180 2024-04-18 15:03:26.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:38.754586 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/Prach/
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:38.771098 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/Prach/EvmSymbol/
+-rw-rw-rw-   0        0        0     4074 2024-04-18 15:03:31.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/Prach/EvmSymbol/Average.py
+-rw-rw-rw-   0        0        0     4074 2024-04-18 15:03:31.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/Prach/EvmSymbol/Current.py
+-rw-rw-rw-   0        0        0     4074 2024-04-18 15:03:31.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/Prach/EvmSymbol/Maximum.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:38.787606 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/Prach/EvmSymbol/Peak/
+-rw-rw-rw-   0        0        0     2913 2024-04-18 15:03:31.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/Prach/EvmSymbol/Peak/Average.py
+-rw-rw-rw-   0        0        0     2913 2024-04-18 15:03:31.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/Prach/EvmSymbol/Peak/Current.py
+-rw-rw-rw-   0        0        0     2913 2024-04-18 15:03:31.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/Prach/EvmSymbol/Peak/Maximum.py
+-rw-rw-rw-   0        0        0     1512 2024-04-18 15:03:31.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/Prach/EvmSymbol/Peak/__init__.py
+-rw-rw-rw-   0        0        0     1756 2024-04-18 15:03:31.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/Prach/EvmSymbol/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:38.821033 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/Prach/Modulation/
+-rw-rw-rw-   0        0        0     8828 2024-04-18 15:03:31.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/Prach/Modulation/Average.py
+-rw-rw-rw-   0        0        0     8828 2024-04-18 15:03:31.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/Prach/Modulation/Current.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:38.822730 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/Prach/Modulation/DpfOffset/
+-rw-rw-rw-   0        0        0     2808 2024-04-18 15:03:31.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/Prach/Modulation/DpfOffset/Preamble.py
+-rw-rw-rw-   0        0        0     1855 2024-04-18 15:03:31.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/Prach/Modulation/DpfOffset/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:38.832725 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/Prach/Modulation/DsIndex/
+-rw-rw-rw-   0        0        0     2783 2024-04-18 15:03:31.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/Prach/Modulation/DsIndex/Preamble.py
+-rw-rw-rw-   0        0        0     1820 2024-04-18 15:03:31.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/Prach/Modulation/DsIndex/__init__.py
+-rw-rw-rw-   0        0        0     9367 2024-04-18 15:03:31.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/Prach/Modulation/Extreme.py
+-rw-rw-rw-   0        0        0     1160 2024-04-18 15:03:31.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/Prach/Modulation/Nsymbol.py
+-rw-rw-rw-   0        0        0     6380 2024-04-18 15:03:31.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/Prach/Modulation/Preamble.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:38.842986 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/Prach/Modulation/Scorrelation/
+-rw-rw-rw-   0        0        0     3033 2024-04-18 15:03:31.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/Prach/Modulation/Scorrelation/Preamble.py
+-rw-rw-rw-   0        0        0     2097 2024-04-18 15:03:31.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/Prach/Modulation/Scorrelation/__init__.py
+-rw-rw-rw-   0        0        0     8328 2024-04-18 15:03:31.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/Prach/Modulation/StandardDev.py
+-rw-rw-rw-   0        0        0     3101 2024-04-18 15:03:31.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/Prach/Modulation/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:38.857945 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/Prach/Pdynamics/
+-rw-rw-rw-   0        0        0     5229 2024-04-18 15:03:32.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/Prach/Pdynamics/Average.py
+-rw-rw-rw-   0        0        0     5229 2024-04-18 15:03:31.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/Prach/Pdynamics/Current.py
+-rw-rw-rw-   0        0        0     5229 2024-04-18 15:03:32.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/Prach/Pdynamics/Maximum.py
+-rw-rw-rw-   0        0        0     5229 2024-04-18 15:03:32.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/Prach/Pdynamics/Minimum.py
+-rw-rw-rw-   0        0        0     4754 2024-04-18 15:03:32.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/Prach/Pdynamics/StandardDev.py
+-rw-rw-rw-   0        0        0     2056 2024-04-18 15:03:31.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/Prach/Pdynamics/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:38.864100 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/Prach/State/
+-rw-rw-rw-   0        0        0     2080 2024-04-18 15:03:31.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/Prach/State/All.py
+-rw-rw-rw-   0        0        0     2727 2024-04-18 15:03:31.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/Prach/State/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:38.873147 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/Prach/Trace/
+-rw-rw-rw-   0        0        0     1883 2024-04-18 15:03:31.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/Prach/Trace/EvPreamble.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:38.883142 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/Prach/Trace/Evm/
+-rw-rw-rw-   0        0        0     2256 2024-04-18 15:03:31.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/Prach/Trace/Evm/Average.py
+-rw-rw-rw-   0        0        0     2256 2024-04-18 15:03:31.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/Prach/Trace/Evm/Current.py
+-rw-rw-rw-   0        0        0     2256 2024-04-18 15:03:31.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/Prach/Trace/Evm/Maximum.py
+-rw-rw-rw-   0        0        0     1507 2024-04-18 15:03:31.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/Prach/Trace/Evm/__init__.py
+-rw-rw-rw-   0        0        0     1916 2024-04-18 15:03:31.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/Prach/Trace/Iq.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:38.893136 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/Prach/Trace/Merror/
+-rw-rw-rw-   0        0        0     2266 2024-04-18 15:03:31.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/Prach/Trace/Merror/Average.py
+-rw-rw-rw-   0        0        0     2266 2024-04-18 15:03:31.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/Prach/Trace/Merror/Current.py
+-rw-rw-rw-   0        0        0     2266 2024-04-18 15:03:31.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/Prach/Trace/Merror/Maximum.py
+-rw-rw-rw-   0        0        0     1522 2024-04-18 15:03:31.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/Prach/Trace/Merror/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:38.914399 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/Prach/Trace/Pdynamics/
+-rw-rw-rw-   0        0        0     2390 2024-04-18 15:03:31.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/Prach/Trace/Pdynamics/Average.py
+-rw-rw-rw-   0        0        0     2390 2024-04-18 15:03:31.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/Prach/Trace/Pdynamics/Current.py
+-rw-rw-rw-   0        0        0     2390 2024-04-18 15:03:31.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/Prach/Trace/Pdynamics/Maximum.py
+-rw-rw-rw-   0        0        0     1537 2024-04-18 15:03:31.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/Prach/Trace/Pdynamics/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:38.931405 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/Prach/Trace/Perror/
+-rw-rw-rw-   0        0        0     2262 2024-04-18 15:03:31.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/Prach/Trace/Perror/Average.py
+-rw-rw-rw-   0        0        0     2262 2024-04-18 15:03:31.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/Prach/Trace/Perror/Current.py
+-rw-rw-rw-   0        0        0     2262 2024-04-18 15:03:31.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/Prach/Trace/Perror/Maximum.py
+-rw-rw-rw-   0        0        0     1522 2024-04-18 15:03:31.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/Prach/Trace/Perror/__init__.py
+-rw-rw-rw-   0        0        0     1891 2024-04-18 15:03:31.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/Prach/Trace/PvPreamble.py
+-rw-rw-rw-   0        0        0     2468 2024-04-18 15:03:31.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/Prach/Trace/__init__.py
+-rw-rw-rw-   0        0        0     5573 2024-04-18 15:03:31.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/Prach/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:38.931405 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/Srs/
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:38.954367 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/Srs/Pdynamics/
+-rw-rw-rw-   0        0        0     5999 2024-04-18 15:03:32.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/Srs/Pdynamics/Average.py
+-rw-rw-rw-   0        0        0     5999 2024-04-18 15:03:32.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/Srs/Pdynamics/Current.py
+-rw-rw-rw-   0        0        0     5999 2024-04-18 15:03:32.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/Srs/Pdynamics/Maximum.py
+-rw-rw-rw-   0        0        0     5999 2024-04-18 15:03:32.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/Srs/Pdynamics/Minimum.py
+-rw-rw-rw-   0        0        0     5441 2024-04-18 15:03:32.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/Srs/Pdynamics/StandardDev.py
+-rw-rw-rw-   0        0        0     2056 2024-04-18 15:03:32.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/Srs/Pdynamics/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:38.954367 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/Srs/State/
+-rw-rw-rw-   0        0        0     2074 2024-04-18 15:03:32.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/Srs/State/All.py
+-rw-rw-rw-   0        0        0     2721 2024-04-18 15:03:32.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/Srs/State/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:38.964365 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/Srs/Trace/
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:38.971106 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/Srs/Trace/Pdynamics/
+-rw-rw-rw-   0        0        0     2658 2024-04-18 15:03:32.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/Srs/Trace/Pdynamics/Average.py
+-rw-rw-rw-   0        0        0     2658 2024-04-18 15:03:32.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/Srs/Trace/Pdynamics/Current.py
+-rw-rw-rw-   0        0        0     2658 2024-04-18 15:03:32.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/Srs/Trace/Pdynamics/Maximum.py
+-rw-rw-rw-   0        0        0     1537 2024-04-18 15:03:32.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/Srs/Trace/Pdynamics/__init__.py
+-rw-rw-rw-   0        0        0     1043 2024-04-18 15:03:32.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/Srs/Trace/__init__.py
+-rw-rw-rw-   0        0        0     5011 2024-04-18 15:03:32.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/Srs/__init__.py
+-rw-rw-rw-   0        0        0     1492 2024-04-18 15:03:26.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:38.971106 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Sense/
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:38.981105 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Sense/LteMeas/
+-rw-rw-rw-   0        0        0      857 2024-04-18 15:03:26.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Sense/LteMeas/CarrierAggregation.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:38.987610 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Sense/LteMeas/MultiEval/
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:38.987610 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Sense/LteMeas/MultiEval/Limit/
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:38.987610 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Sense/LteMeas/MultiEval/Limit/Iemissions/
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:38.997610 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Sense/LteMeas/MultiEval/Limit/Iemissions/Ulca/
+-rw-rw-rw-   0        0        0     2459 2024-04-18 15:03:26.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Sense/LteMeas/MultiEval/Limit/Iemissions/Ulca/Scc.py
+-rw-rw-rw-   0        0        0     1464 2024-04-18 15:03:26.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Sense/LteMeas/MultiEval/Limit/Iemissions/Ulca/__init__.py
+-rw-rw-rw-   0        0        0     1911 2024-04-18 15:03:26.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Sense/LteMeas/MultiEval/Limit/Iemissions/__init__.py
+-rw-rw-rw-   0        0        0     1053 2024-04-18 15:03:26.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Sense/LteMeas/MultiEval/Limit/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:38.997610 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Sense/LteMeas/MultiEval/Spectrum/
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:39.004619 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Sense/LteMeas/MultiEval/Spectrum/SeMask/
+-rw-rw-rw-   0        0        0     1705 2024-04-18 15:03:26.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Sense/LteMeas/MultiEval/Spectrum/SeMask/Rbw.py
+-rw-rw-rw-   0        0        0     1004 2024-04-18 15:03:26.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Sense/LteMeas/MultiEval/Spectrum/SeMask/__init__.py
+-rw-rw-rw-   0        0        0     1036 2024-04-18 15:03:26.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Sense/LteMeas/MultiEval/Spectrum/__init__.py
+-rw-rw-rw-   0        0        0     1283 2024-04-18 15:03:26.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Sense/LteMeas/MultiEval/__init__.py
+-rw-rw-rw-   0        0        0     1383 2024-04-18 15:03:26.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Sense/LteMeas/__init__.py
+-rw-rw-rw-   0        0        0     1023 2024-04-18 15:03:26.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Sense/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:39.004619 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Trigger/
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:39.027788 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Trigger/LteMeas/
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:39.035766 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Trigger/LteMeas/MultiEval/
+-rw-rw-rw-   0        0        0     3872 2024-04-18 15:03:32.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Trigger/LteMeas/MultiEval/ListPy.py
+-rw-rw-rw-   0        0        0     9054 2024-04-18 15:03:32.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Trigger/LteMeas/MultiEval/__init__.py
+-rw-rw-rw-   0        0        0     4896 2024-04-18 15:03:32.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Trigger/LteMeas/Prach.py
+-rw-rw-rw-   0        0        0     4842 2024-04-18 15:03:32.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Trigger/LteMeas/Srs.py
+-rw-rw-rw-   0        0        0     1492 2024-04-18 15:03:32.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Trigger/LteMeas/__init__.py
+-rw-rw-rw-   0        0        0     1034 2024-04-18 15:03:32.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Trigger/__init__.py
+-rw-rw-rw-   0        0        0        0 2019-11-18 07:28:01.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:39.137857 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Internal/
+-rw-rw-rw-   0        0        0      586 2024-02-28 16:27:53.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Internal/ArgLinkedEventArgs.py
+-rw-rw-rw-   0        0        0     4165 2024-02-28 16:27:53.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Internal/ArgSingle.py
+-rw-rw-rw-   0        0        0     1116 2024-02-28 16:27:53.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Internal/ArgSingleList.py
+-rw-rw-rw-   0        0        0     1145 2024-02-28 16:27:53.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Internal/ArgSingleSuppressed.py
+-rw-rw-rw-   0        0        0     9097 2024-02-28 16:27:53.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Internal/ArgStringComposer.py
+-rw-rw-rw-   0        0        0     5751 2024-02-28 16:27:53.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Internal/ArgStruct.py
+-rw-rw-rw-   0        0        0     3439 2024-02-28 16:27:53.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Internal/ArgStructList.py
+-rw-rw-rw-   0        0        0     2546 2024-02-28 16:27:53.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Internal/ArgStructStringParser.py
+-rw-rw-rw-   0        0        0     5238 2024-02-28 16:27:53.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Internal/CommandsGroup.py
+-rw-rw-rw-   0        0        0    25419 2024-04-03 11:15:31.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Internal/Conversions.py
+-rw-rw-rw-   0        0        0     3775 2024-02-28 16:27:53.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Internal/ConverterFromScpiString.py
+-rw-rw-rw-   0        0        0     4768 2024-02-28 16:27:53.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Internal/ConverterToScpiString.py
+-rw-rw-rw-   0        0        0    14213 2024-04-03 11:15:31.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Internal/Core.py
+-rw-rw-rw-   0        0        0     1386 2024-02-28 16:27:53.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Internal/GlobalData.py
+-rw-rw-rw-   0        0        0    60862 2024-04-03 11:15:31.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Internal/Instrument.py
+-rw-rw-rw-   0        0        0     4785 2024-02-28 16:27:53.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Internal/InstrumentErrors.py
+-rw-rw-rw-   0        0        0     2225 2024-02-28 16:27:53.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Internal/InstrumentOptions.py
+-rw-rw-rw-   0        0        0    16156 2024-04-03 11:15:31.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Internal/InstrumentSettings.py
+-rw-rw-rw-   0        0        0     3518 2024-02-28 16:27:53.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Internal/InternalLinker.py
+-rw-rw-rw-   0        0        0     4390 2024-02-28 16:27:53.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Internal/IoTransferEventArgs.py
+-rw-rw-rw-   0        0        0      387 2024-02-28 16:27:53.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Internal/Properties.py
+-rw-rw-rw-   0        0        0     4289 2024-02-28 16:27:53.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Internal/RepeatedCapability.py
+-rw-rw-rw-   0        0        0     4745 2024-02-28 16:27:53.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Internal/ScpiEnums.py
+-rw-rw-rw-   0        0        0    35525 2024-02-28 16:27:53.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Internal/ScpiLogger.py
+-rw-rw-rw-   0        0        0     5098 2024-02-28 16:27:53.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Internal/StreamReader.py
+-rw-rw-rw-   0        0        0     5856 2024-02-28 16:27:53.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Internal/StreamWriter.py
+-rw-rw-rw-   0        0        0     1114 2024-02-28 16:27:53.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Internal/StructBase.py
+-rw-rw-rw-   0        0        0     3608 2024-02-28 16:27:53.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Internal/Types.py
+-rw-rw-rw-   0        0        0     5498 2024-02-28 16:27:53.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Internal/Utilities.py
+-rw-rw-rw-   0        0        0     5716 2024-02-28 16:27:53.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Internal/VisaPluginSocketIo.py
+-rw-rw-rw-   0        0        0    51976 2024-04-03 11:15:31.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Internal/VisaSession.py
+-rw-rw-rw-   0        0        0     7512 2024-02-28 16:27:53.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Internal/VisaSessionSim.py
+-rw-rw-rw-   0        0        0       29 2024-02-28 16:27:53.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Internal/__init__.py
+-rw-rw-rw-   0        0        0    12809 2024-04-18 15:03:32.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/RsCMPX_LteMeas.py
+-rw-rw-rw-   0        0        0      932 2024-04-18 15:03:32.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/__init__.py
+-rw-rw-rw-   0        0        0    12628 2024-04-18 15:03:23.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/enums.py
+-rw-rw-rw-   0        0        0    38009 2024-04-18 15:02:14.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/repcap.py
+drwxrwxrwx   0        0        0        0 2024-04-18 15:03:36.187626 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas.egg-info/
+-rw-rw-rw-   0        0        0     3100 2024-04-18 15:03:35.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas.egg-info/PKG-INFO
+-rw-rw-rw-   0        0        0    67686 2024-04-18 15:03:35.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas.egg-info/SOURCES.txt
+-rw-rw-rw-   0        0        0        1 2024-04-18 15:03:35.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas.egg-info/dependency_links.txt
+-rw-rw-rw-   0        0        0       15 2024-04-18 15:03:35.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas.egg-info/requires.txt
+-rw-rw-rw-   0        0        0       15 2024-04-18 15:03:35.000000 RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas.egg-info/top_level.txt
+-rw-rw-rw-   0        0        0       42 2024-04-18 15:03:39.139911 RsCMPX_LteMeas-5.0.70/setup.cfg
+-rw-rw-rw-   0        0        0     1483 2024-04-18 15:03:32.000000 RsCMPX_LteMeas-5.0.70/setup.py
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/CustomFiles/events.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/CustomFiles/events.py`

 * *Files 11% similar despite different names*

```diff
@@ -1,79 +1,89 @@
-from typing import Callable
-
-from ..Internal import Core
-
-
-class Events:
-	"""Common Events class.
-	Event-related methods common for all types of drivers."""
-	def __init__(self, core: Core):
-		self._core = core
-
-	@property
-	def io_events_include_data(self) -> bool:
-		"""Returns the current state of the io_events_include_data See the setter for more details."""
-		return self._core.io.io_events_include_data
-
-	@io_events_include_data.setter
-	def io_events_include_data(self, value: bool) -> None:
-		"""If True, the on_write and on_read events include also the sent/received data.
-		Default value is False, to avoid handling potentially big data."""
-		self._core.io.io_events_include_data = value
-
-	@property
-	def before_write_handler(self) -> Callable:
-		"""Returns the handler of before_write events. \n
-		:return: current before_write_handler"""
-		return self._core.io.before_write_handler
-
-	@before_write_handler.setter
-	def before_write_handler(self, handler: Callable) -> None:
-		"""Sets handler for before_write events.
-		The before_write event is invoked before each write operation (only once, not for every chunk)
-		Event prototype: handler(io: Instrument, cmd: str)
-		:param handler: new handler"""
-		self._core.io.before_write_handler = handler
-
-	@property
-	def on_write_handler(self) -> Callable:
-		"""Returns the handler of on_write events. \n
-		:return: current on_write_handler"""
-		return self._core.io.on_write_handler
-
-	@on_write_handler.setter
-	def on_write_handler(self, handler: Callable) -> None:
-		"""Sets handler for on_write events.
-		The on_write event is invoked every time the driver performs a write operation to the instrument (for each write chunk)
-		Event arguments type: IoTransferEventArgs
-		By default, the event_args do not contain the actual data sent. If you wish to receive them, set the driver.Events.io_events_include_data to True \n
-		:param handler: new handler for all write operations"""
-		self._core.io.on_write_handler = handler
-
-	@property
-	def on_read_handler(self) -> Callable:
-		"""Returns the handler of on_read events. \n
-		:return: current on_read_handler"""
-		return self._core.io.on_read_handler
-
-	@on_read_handler.setter
-	def on_read_handler(self, handler: Callable) -> None:
-		"""Sets handler for on_read events.
-		The on_read event is invoked every time the driver performs a read operation to the instrument.
-		Event arguments type: IoTransferEventArgs
-		By default, the event_args do not contain the actual data sent. If you wish to receive them, set the driver.Events.io_events_include_data to True \n
-		:param handler: new handler for all read operations"""
-		self._core.io.on_read_handler = handler
-
-	@property
-	def before_query_handler(self) -> Callable:
-		"""Returns the handler of before_query events. \n
-		:return: current before_query_handler"""
-		return self._core.io.before_query_handler
-
-	@before_query_handler.setter
-	def before_query_handler(self, handler: Callable) -> None:
-		"""Sets handler for before_query events.
-		The before_query event is invoked before each query operation (only once, not for every chunk)
-		Event prototype: handler(io: Instrument, query: str)
-		:param handler: new handler"""
-		self._core.io.before_query_handler = handler
+"""Event-related methods and properties. Here you can set all the event handlers."""
+
+from typing import Callable
+
+from ..Internal import Core
+
+
+class Events:
+	"""Common Events class.
+	Event-related methods and properties. Here you can set all the event handlers."""
+	def __init__(self, core: Core):
+		self._core = core
+
+	@property
+	def io_events_include_data(self) -> bool:
+		"""Returns the current state of the io_events_include_data See the setter for more details."""
+		return self._core.io.io_events_include_data
+
+	@io_events_include_data.setter
+	def io_events_include_data(self, value: bool) -> None:
+		"""If True, the on_write and on_read events include also the transferred data.
+		Default value is False, to avoid handling potentially big data."""
+		self._core.io.io_events_include_data = value
+
+	@property
+	def before_write_handler(self) -> Callable:
+		"""Returns the handler of before_write events. \n
+		:return: current ``before_write_handler``"""
+		return self._core.io.before_write_handler
+
+	@before_write_handler.setter
+	def before_write_handler(self, handler: Callable) -> None:
+		"""Sets handler for before_write events.
+		The before_write event is invoked before each write operation (only once, not for every chunk)
+		Event prototype: handler(io: Instrument, cmd: str)
+		:param handler: new handler"""
+		self._core.io.before_write_handler = handler
+
+	@property
+	def on_write_handler(self) -> Callable:
+		"""Returns the handler of on_write events. \n
+		:return: current ``on_write_handler``"""
+		return self._core.io.on_write_handler
+
+	@on_write_handler.setter
+	def on_write_handler(self, handler: Callable) -> None:
+		"""Sets handler for on_write events.
+		The on_write event is invoked every time the driver performs a write operation to the instrument (for each write chunk)
+		Event arguments type: IoTransferEventArgs
+		By default, the event_args do not contain the actual data sent. If you wish to receive them, set the driver.Events.io_events_include_data to True \n
+		:param handler: new handler for all write operations"""
+		self._core.io.on_write_handler = handler
+
+	@property
+	def on_read_handler(self) -> Callable:
+		"""Returns the handler of on_read events. \n
+		:return: current ``on_read_handler``"""
+		return self._core.io.on_read_handler
+
+	@on_read_handler.setter
+	def on_read_handler(self, handler: Callable) -> None:
+		"""Sets handler for on_read events.
+		The on_read event is invoked every time the driver performs a read operation to the instrument.
+		Event arguments type: IoTransferEventArgs
+		By default, the event_args do not contain the actual data sent. If you wish to receive them, set the driver.Events.io_events_include_data to True \n
+		:param handler: new handler for all read operations"""
+		self._core.io.on_read_handler = handler
+
+	@property
+	def before_query_handler(self) -> Callable:
+		"""Returns the handler of before_query events. \n
+		:return: current ``before_query_handler``"""
+		return self._core.io.before_query_handler
+
+	@before_query_handler.setter
+	def before_query_handler(self, handler: Callable) -> None:
+		"""Sets handler for before_query events.
+		The before_query event is invoked before each query operation (only once, not for every chunk)
+		Event prototype: handler(io: Instrument, query: str)
+		:param handler: new handler"""
+		self._core.io.before_query_handler = handler
+
+	def sync_from(self, source: 'Events') -> None:
+		"""Synchronises these Events with the source."""
+		self.before_query_handler = source.before_query_handler
+		self.before_write_handler = source.before_write_handler
+		self.io_events_include_data = source.io_events_include_data
+		self.on_read_handler = source.on_read_handler
+		self.on_write_handler = source.on_write_handler
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/CustomFiles/reliability.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/CustomFiles/reliability.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,7 +1,10 @@
+"""Class for R&S Mobile Radio Test instruments that use reliability indicators."""
+
+
 import time
 from typing import Callable
 
 from ..Internal import ArgLinkedEventArgs
 from ..Internal import Core
 
 codes_table = {
@@ -60,25 +63,25 @@
 		self.context = context
 
 
 class Reliability:
 	"""Reliability class that handles all the necessary tasks related to reliability indicator."""
 
 	def __init__(self, core: Core):
-		self._core = core
-		self._last_value = 0
-		self._last_context = ''
+		self._core: Core = core
+		self._last_value: int = 0
+		self._last_context: str = ''
 		self._last_timestamp = None
 		self._exception_on_error = False
 		# noinspection PyTypeChecker
 		self._on_update_handler: Callable = None
 		self._core.set_link_handler('Reliability', self._permanent_on_update_handler)
 
 	@property
-	def last_value(self):
+	def last_value(self) -> int:
 		"""Returns the last updated Reliability code."""
 		return self._last_value
 
 	@property
 	def last_context(self) -> str:
 		"""Returns the last updated Context of the reliability code - usually the SCPI query on which the instrument responded with the Reliability code."""
 		return self._last_context
@@ -94,36 +97,39 @@
 		if self._last_value in codes_table:
 			return codes_table[self._last_value]
 		else:
 			return f'Undefined reliability code {self._last_value}.'
 
 	@property
 	def exception_on_error(self) -> bool:
-		"""see the exception_on_error.setter."""
+		"""If True, (default is False) the object throws an exception if the updated reliability is not 0 (non-OK)."""
 		return self._exception_on_error
 
 	@exception_on_error.setter
 	def exception_on_error(self, value) -> None:
 		"""If True, (default is False) the object throws an exception if the updated reliability is not 0 (non-OK)."""
 		self._exception_on_error = value
 
 	def on_update_handler(self, handler: Callable) -> None:
 		"""Register the handler for on_update event.
 		This handler is invoked with each update of the reliability indicator.
 		Handler API: handler(event_args: ReliabilityEventArgs)"""
 		self._on_update_handler = handler
 
-	def _permanent_on_update_handler(self, event_args: ArgLinkedEventArgs):
+	def _permanent_on_update_handler(self, event_args: ArgLinkedEventArgs) -> None:
 		"""Permanent on_update handler. Takes care of updating all the 'last_xxx' values and calling a user-defined updated_handler."""
 		self._last_value = int(str(event_args.value))
 		self._last_context = event_args.context
 		self._last_timestamp = event_args.timestamp
-
 		if self._on_update_handler:
 			# Call the additional handler if registered
 			rel_events_args = ReliabilityEventArgs(self._last_timestamp, self._last_value, self.last_message, self._last_context)
 			self._on_update_handler(rel_events_args)
-
 		if self._exception_on_error and self._last_value != 0:
 			raise Exception(
 				f'Reliability indicator error. Time: {time.strftime("%H:%M:%S", time.localtime(self._last_timestamp))}, '
 				f'Context: {self._last_context}, Value {self._last_value}: {self.last_message}')
+
+	def sync_from(self, source: 'Reliability') -> None:
+		"""Synchronises this Reliability with the source."""
+		self.exception_on_error = source.exception_on_error
+		self.on_update_handler(source._on_update_handler)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/__init__.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,210 +1,200 @@
-from ..Internal.Core import Core
-from ..Internal.CommandsGroup import CommandsGroup
-from ..Internal import Conversions
-from .. import enums
+from ....Internal.Core import Core
+from ....Internal.CommandsGroup import CommandsGroup
+from ....Internal import Conversions
+from .... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Configure:
-	"""Configure commands group definition. 215 total commands, 11 Sub-groups, 5 group commands"""
+class LteMeasCls:
+	"""LteMeas commands group definition. 219 total commands, 10 Subgroups, 5 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("configure", core, parent)
+		self._cmd_group = CommandsGroup("lteMeas", core, parent)
 
 	@property
 	def network(self):
-		"""network commands group. 0 Sub-classes, 2 commands."""
+		"""network commands group. 0 Sub-classes, 3 commands."""
 		if not hasattr(self, '_network'):
-			from .Configure_.Network import Network
-			self._network = Network(self._core, self._base)
+			from .Network import NetworkCls
+			self._network = NetworkCls(self._core, self._cmd_group)
 		return self._network
 
 	@property
-	def scenario(self):
-		"""scenario commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_scenario'):
-			from .Configure_.Scenario import Scenario
-			self._scenario = Scenario(self._core, self._base)
-		return self._scenario
-
-	@property
 	def rfSettings(self):
 		"""rfSettings commands group. 3 Sub-classes, 5 commands."""
 		if not hasattr(self, '_rfSettings'):
-			from .Configure_.RfSettings import RfSettings
-			self._rfSettings = RfSettings(self._core, self._base)
+			from .RfSettings import RfSettingsCls
+			self._rfSettings = RfSettingsCls(self._core, self._cmd_group)
 		return self._rfSettings
 
 	@property
 	def carrierAggregation(self):
 		"""carrierAggregation commands group. 6 Sub-classes, 0 commands."""
 		if not hasattr(self, '_carrierAggregation'):
-			from .Configure_.CarrierAggregation import CarrierAggregation
-			self._carrierAggregation = CarrierAggregation(self._core, self._base)
+			from .CarrierAggregation import CarrierAggregationCls
+			self._carrierAggregation = CarrierAggregationCls(self._core, self._cmd_group)
 		return self._carrierAggregation
 
 	@property
 	def emtc(self):
 		"""emtc commands group. 0 Sub-classes, 3 commands."""
 		if not hasattr(self, '_emtc'):
-			from .Configure_.Emtc import Emtc
-			self._emtc = Emtc(self._core, self._base)
+			from .Emtc import EmtcCls
+			self._emtc = EmtcCls(self._core, self._cmd_group)
 		return self._emtc
 
 	@property
 	def multiEval(self):
-		"""multiEval commands group. 16 Sub-classes, 20 commands."""
+		"""multiEval commands group. 17 Sub-classes, 19 commands."""
 		if not hasattr(self, '_multiEval'):
-			from .Configure_.MultiEval import MultiEval
-			self._multiEval = MultiEval(self._core, self._base)
+			from .MultiEval import MultiEvalCls
+			self._multiEval = MultiEvalCls(self._core, self._cmd_group)
 		return self._multiEval
 
 	@property
 	def pcc(self):
 		"""pcc commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_pcc'):
-			from .Configure_.Pcc import Pcc
-			self._pcc = Pcc(self._core, self._base)
+			from .Pcc import PccCls
+			self._pcc = PccCls(self._core, self._cmd_group)
 		return self._pcc
 
 	@property
 	def scc(self):
 		"""scc commands group. 1 Sub-classes, 0 commands."""
 		if not hasattr(self, '_scc'):
-			from .Configure_.Scc import Scc
-			self._scc = Scc(self._core, self._base)
+			from .Scc import SccCls
+			self._scc = SccCls(self._core, self._cmd_group)
 		return self._scc
 
 	@property
 	def cc(self):
 		"""cc commands group. 1 Sub-classes, 0 commands."""
 		if not hasattr(self, '_cc'):
-			from .Configure_.Cc import Cc
-			self._cc = Cc(self._core, self._base)
+			from .Cc import CcCls
+			self._cc = CcCls(self._core, self._cmd_group)
 		return self._cc
 
 	@property
 	def prach(self):
-		"""prach commands group. 6 Sub-classes, 9 commands."""
+		"""prach commands group. 6 Sub-classes, 10 commands."""
 		if not hasattr(self, '_prach'):
-			from .Configure_.Prach import Prach
-			self._prach = Prach(self._core, self._base)
+			from .Prach import PrachCls
+			self._prach = PrachCls(self._core, self._cmd_group)
 		return self._prach
 
 	@property
 	def srs(self):
 		"""srs commands group. 2 Sub-classes, 6 commands."""
 		if not hasattr(self, '_srs'):
-			from .Configure_.Srs import Srs
-			self._srs = Srs(self._core, self._base)
+			from .Srs import SrsCls
+			self._srs = SrsCls(self._core, self._cmd_group)
 		return self._srs
 
 	# noinspection PyTypeChecker
 	def get_band(self) -> enums.Band:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:BAND \n
-		Snippet: value: enums.Band = driver.configure.get_band() \n
+		Snippet: value: enums.Band = driver.configure.lteMeas.get_band() \n
 		Selects the operating band (OB) .
 			INTRO_CMD_HELP: The allowed input range has dependencies: \n
 			- FDD UL: OB1 | ... | OB28 | OB30 | OB31 | OB65 | OB66 | OB68 | OB70 | ... | OB74 | OB85 | OB87 | OB88
 			- TDD UL: OB33 | ... | OB45 | OB48 | OB50 | ... | OB53 | OB250
-			- Sidelink: OB47
 		For Signal Path = Network, use [CONFigure:]SIGNaling:LTE:CELL:RFSettings:FBINdicator. \n
 			:return: band: No help available
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:BAND?')
 		return Conversions.str_to_scalar_enum(response, enums.Band)
 
 	def set_band(self, band: enums.Band) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:BAND \n
-		Snippet: driver.configure.set_band(band = enums.Band.OB1) \n
+		Snippet: driver.configure.lteMeas.set_band(band = enums.Band.OB1) \n
 		Selects the operating band (OB) .
 			INTRO_CMD_HELP: The allowed input range has dependencies: \n
 			- FDD UL: OB1 | ... | OB28 | OB30 | OB31 | OB65 | OB66 | OB68 | OB70 | ... | OB74 | OB85 | OB87 | OB88
 			- TDD UL: OB33 | ... | OB45 | OB48 | OB50 | ... | OB53 | OB250
-			- Sidelink: OB47
 		For Signal Path = Network, use [CONFigure:]SIGNaling:LTE:CELL:RFSettings:FBINdicator. \n
 			:param band: No help available
 		"""
 		param = Conversions.enum_scalar_to_str(band, enums.Band)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:BAND {param}')
 
 	# noinspection PyTypeChecker
 	def get_spath(self) -> enums.Path:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:SPATh \n
-		Snippet: value: enums.Path = driver.configure.get_spath() \n
+		Snippet: value: enums.Path = driver.configure.lteMeas.get_spath() \n
 		Selects between a standalone measurement and a measurement with coupling to signaling settings (cell settings of the
 		network configuration) . \n
 			:return: path: No help available
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:SPATh?')
 		return Conversions.str_to_scalar_enum(response, enums.Path)
 
 	def set_spath(self, path: enums.Path) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:SPATh \n
-		Snippet: driver.configure.set_spath(path = enums.Path.NETWork) \n
+		Snippet: driver.configure.lteMeas.set_spath(path = enums.Path.NETWork) \n
 		Selects between a standalone measurement and a measurement with coupling to signaling settings (cell settings of the
 		network configuration) . \n
 			:param path: No help available
 		"""
 		param = Conversions.enum_scalar_to_str(path, enums.Path)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:SPATh {param}')
 
 	# noinspection PyTypeChecker
 	def get_stype(self) -> enums.SignalType:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:STYPe \n
-		Snippet: value: enums.SignalType = driver.configure.get_stype() \n
+		Snippet: value: enums.SignalType = driver.configure.lteMeas.get_stype() \n
 		Selects the type of the measured signal. \n
-			:return: signal_type: UL: LTE uplink signal with PUSCH or PUCCH SL: V2X sidelink signal with PSSCH and PSCCH
+			:return: signal_type: UL: LTE uplink signal SL: V2X sidelink signal
 		"""
 		response = self._core.io.query_str_with_opc('CONFigure:LTE:MEASurement<Instance>:STYPe?')
 		return Conversions.str_to_scalar_enum(response, enums.SignalType)
 
 	def set_stype(self, signal_type: enums.SignalType) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:STYPe \n
-		Snippet: driver.configure.set_stype(signal_type = enums.SignalType.SL) \n
+		Snippet: driver.configure.lteMeas.set_stype(signal_type = enums.SignalType.SL) \n
 		Selects the type of the measured signal. \n
-			:param signal_type: UL: LTE uplink signal with PUSCH or PUCCH SL: V2X sidelink signal with PSSCH and PSCCH
+			:param signal_type: UL: LTE uplink signal SL: V2X sidelink signal
 		"""
 		param = Conversions.enum_scalar_to_str(signal_type, enums.SignalType)
 		self._core.io.write_with_opc(f'CONFigure:LTE:MEASurement<Instance>:STYPe {param}')
 
 	# noinspection PyTypeChecker
 	def get_dmode(self) -> enums.Mode:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:DMODe \n
-		Snippet: value: enums.Mode = driver.configure.get_dmode() \n
+		Snippet: value: enums.Mode = driver.configure.lteMeas.get_dmode() \n
 		Selects the duplex mode of the LTE signal: FDD or TDD.
 		For Signal Path = Network, use [CONFigure:]SIGNaling:LTE:CELL:RFSettings:DMODe. \n
 			:return: mode: No help available
 		"""
 		response = self._core.io.query_str_with_opc('CONFigure:LTE:MEASurement<Instance>:DMODe?')
 		return Conversions.str_to_scalar_enum(response, enums.Mode)
 
 	def set_dmode(self, mode: enums.Mode) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:DMODe \n
-		Snippet: driver.configure.set_dmode(mode = enums.Mode.FDD) \n
+		Snippet: driver.configure.lteMeas.set_dmode(mode = enums.Mode.FDD) \n
 		Selects the duplex mode of the LTE signal: FDD or TDD.
 		For Signal Path = Network, use [CONFigure:]SIGNaling:LTE:CELL:RFSettings:DMODe. \n
 			:param mode: No help available
 		"""
 		param = Conversions.enum_scalar_to_str(mode, enums.Mode)
 		self._core.io.write_with_opc(f'CONFigure:LTE:MEASurement<Instance>:DMODe {param}')
 
 	# noinspection PyTypeChecker
 	def get_fstructure(self) -> enums.FrameStructure:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:FSTRucture \n
-		Snippet: value: enums.FrameStructure = driver.configure.get_fstructure() \n
+		Snippet: value: enums.FrameStructure = driver.configure.lteMeas.get_fstructure() \n
 		Queries the frame structure type of the LTE signal. The value depends on the duplex mode (method RsCMPX_LteMeas.Configure.
-		dmode) . \n
+		LteMeas.dmode) . \n
 			:return: frame_structure: T1: Type 1, FDD signal T2: Type 2, TDD signal
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:FSTRucture?')
 		return Conversions.str_to_scalar_enum(response, enums.FrameStructure)
 
-	def clone(self) -> 'Configure':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'LteMeasCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Configure(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = LteMeasCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/CarrierAggregation.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/CarrierAggregation/__init__.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,67 +1,67 @@
-from ...Internal.Core import Core
-from ...Internal.CommandsGroup import CommandsGroup
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class CarrierAggregation:
-	"""CarrierAggregation commands group definition. 12 total commands, 6 Sub-groups, 0 group commands"""
+class CarrierAggregationCls:
+	"""CarrierAggregation commands group definition. 12 total commands, 6 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("carrierAggregation", core, parent)
+		self._cmd_group = CommandsGroup("carrierAggregation", core, parent)
 
 	@property
 	def mode(self):
 		"""mode commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_mode'):
-			from .CarrierAggregation_.Mode import Mode
-			self._mode = Mode(self._core, self._base)
+			from .Mode import ModeCls
+			self._mode = ModeCls(self._core, self._cmd_group)
 		return self._mode
 
 	@property
 	def mcarrier(self):
 		"""mcarrier commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_mcarrier'):
-			from .CarrierAggregation_.Mcarrier import Mcarrier
-			self._mcarrier = Mcarrier(self._core, self._base)
+			from .Mcarrier import McarrierCls
+			self._mcarrier = McarrierCls(self._core, self._cmd_group)
 		return self._mcarrier
 
 	@property
 	def frequency(self):
 		"""frequency commands group. 1 Sub-classes, 0 commands."""
 		if not hasattr(self, '_frequency'):
-			from .CarrierAggregation_.Frequency import Frequency
-			self._frequency = Frequency(self._core, self._base)
+			from .Frequency import FrequencyCls
+			self._frequency = FrequencyCls(self._core, self._cmd_group)
 		return self._frequency
 
 	@property
 	def channelBw(self):
 		"""channelBw commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_channelBw'):
-			from .CarrierAggregation_.ChannelBw import ChannelBw
-			self._channelBw = ChannelBw(self._core, self._base)
+			from .ChannelBw import ChannelBwCls
+			self._channelBw = ChannelBwCls(self._core, self._cmd_group)
 		return self._channelBw
 
 	@property
 	def scc(self):
 		"""scc commands group. 1 Sub-classes, 0 commands."""
 		if not hasattr(self, '_scc'):
-			from .CarrierAggregation_.Scc import Scc
-			self._scc = Scc(self._core, self._base)
+			from .Scc import SccCls
+			self._scc = SccCls(self._core, self._cmd_group)
 		return self._scc
 
 	@property
 	def maping(self):
 		"""maping commands group. 1 Sub-classes, 2 commands."""
 		if not hasattr(self, '_maping'):
-			from .CarrierAggregation_.Maping import Maping
-			self._maping = Maping(self._core, self._base)
+			from .Maping import MapingCls
+			self._maping = MapingCls(self._core, self._cmd_group)
 		return self._maping
 
-	def clone(self) -> 'CarrierAggregation':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'CarrierAggregationCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = CarrierAggregation(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = CarrierAggregationCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/CarrierAggregation_/ChannelBw.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/CarrierAggregation/ChannelBw.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,21 +1,21 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
-from ....Internal import Conversions
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
+from .....Internal import Conversions
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class ChannelBw:
-	"""ChannelBw commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class ChannelBwCls:
+	"""ChannelBw commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("channelBw", core, parent)
+		self._cmd_group = CommandsGroup("channelBw", core, parent)
 
 	def get_aggregated(self) -> float:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:CAGGregation:CBANdwidth:AGGRegated \n
-		Snippet: value: float = driver.configure.carrierAggregation.channelBw.get_aggregated() \n
+		Snippet: value: float = driver.configure.lteMeas.carrierAggregation.channelBw.get_aggregated() \n
 		Queries the width of the aggregated channel bandwidth. \n
 			:return: ch_bandwidth: No help available
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:CAGGregation:CBANdwidth:AGGRegated?')
 		return Conversions.str_to_float(response)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/CarrierAggregation_/Frequency.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/CarrierAggregation/Frequency/__init__.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,27 +1,27 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Frequency:
-	"""Frequency commands group definition. 3 total commands, 1 Sub-groups, 0 group commands"""
+class FrequencyCls:
+	"""Frequency commands group definition. 3 total commands, 1 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("frequency", core, parent)
+		self._cmd_group = CommandsGroup("frequency", core, parent)
 
 	@property
 	def aggregated(self):
 		"""aggregated commands group. 0 Sub-classes, 3 commands."""
 		if not hasattr(self, '_aggregated'):
-			from .Frequency_.Aggregated import Aggregated
-			self._aggregated = Aggregated(self._core, self._base)
+			from .Aggregated import AggregatedCls
+			self._aggregated = AggregatedCls(self._core, self._cmd_group)
 		return self._aggregated
 
-	def clone(self) -> 'Frequency':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'FrequencyCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Frequency(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = FrequencyCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/CarrierAggregation_/Frequency_/Aggregated.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/CarrierAggregation/Frequency/Aggregated.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,39 +1,39 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
-from .....Internal import Conversions
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal import Conversions
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Aggregated:
-	"""Aggregated commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class AggregatedCls:
+	"""Aggregated commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("aggregated", core, parent)
+		self._cmd_group = CommandsGroup("aggregated", core, parent)
 
 	def get_low(self) -> float:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:CAGGregation:FREQuency:AGGRegated:LOW \n
-		Snippet: value: float = driver.configure.carrierAggregation.frequency.aggregated.get_low() \n
+		Snippet: value: float = driver.configure.lteMeas.carrierAggregation.frequency.aggregated.get_low() \n
 		Queries the lower edge of the aggregated bandwidth. \n
 			:return: frequency_low: No help available
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:CAGGregation:FREQuency:AGGRegated:LOW?')
 		return Conversions.str_to_float(response)
 
 	def get_center(self) -> float:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:CAGGregation:FREQuency:AGGRegated:CENTer \n
-		Snippet: value: float = driver.configure.carrierAggregation.frequency.aggregated.get_center() \n
+		Snippet: value: float = driver.configure.lteMeas.carrierAggregation.frequency.aggregated.get_center() \n
 		Queries the center frequency of the aggregated bandwidth. \n
 			:return: frequency_center: No help available
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:CAGGregation:FREQuency:AGGRegated:CENTer?')
 		return Conversions.str_to_float(response)
 
 	def get_high(self) -> float:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:CAGGregation:FREQuency:AGGRegated:HIGH \n
-		Snippet: value: float = driver.configure.carrierAggregation.frequency.aggregated.get_high() \n
+		Snippet: value: float = driver.configure.lteMeas.carrierAggregation.frequency.aggregated.get_high() \n
 		Queries the upper edge of the aggregated bandwidth. \n
 			:return: frequency_high: No help available
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:CAGGregation:FREQuency:AGGRegated:HIGH?')
 		return Conversions.str_to_float(response)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/CarrierAggregation_/Maping.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/CarrierAggregation/Maping/__init__.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,42 +1,42 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
-from ....Internal.Utilities import trim_str_response
-from ....Internal.StructBase import StructBase
-from ....Internal.ArgStruct import ArgStruct
-from .... import enums
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal.Utilities import trim_str_response
+from ......Internal.StructBase import StructBase
+from ......Internal.ArgStruct import ArgStruct
+from ...... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Maping:
-	"""Maping commands group definition. 3 total commands, 1 Sub-groups, 2 group commands"""
+class MapingCls:
+	"""Maping commands group definition. 3 total commands, 1 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("maping", core, parent)
+		self._cmd_group = CommandsGroup("maping", core, parent)
 
 	@property
 	def scc(self):
 		"""scc commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_scc'):
-			from .Maping_.Scc import Scc
-			self._scc = Scc(self._core, self._base)
+			from .Scc import SccCls
+			self._scc = SccCls(self._core, self._cmd_group)
 		return self._scc
 
 	def get_pcc(self) -> str:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:CAGGregation:MAPing:PCC \n
-		Snippet: value: str = driver.configure.carrierAggregation.maping.get_pcc() \n
+		Snippet: value: str = driver.configure.lteMeas.carrierAggregation.maping.get_pcc() \n
 		No command help available \n
 			:return: cc: No help available
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:CAGGregation:MAPing:PCC?')
 		return trim_str_response(response)
 
 	# noinspection PyTypeChecker
-	class ValueStruct(StructBase):
+	class ValueStruct(StructBase):  # From ReadStructDefinition CmdPropertyTemplate.xml
 		"""Structure for reading output parameters. Fields: \n
 			- Cc_1: enums.CarrAggrMaping: No parameter help available
 			- Cc_2: enums.CarrAggrMaping: No parameter help available
 			- Cc_3: enums.CarrAggrMaping: No parameter help available
 			- Cc_4: enums.CarrAggrMaping: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_enum('Cc_1', enums.CarrAggrMaping),
@@ -47,23 +47,22 @@
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Cc_1: enums.CarrAggrMaping = None
 			self.Cc_2: enums.CarrAggrMaping = None
 			self.Cc_3: enums.CarrAggrMaping = None
 			self.Cc_4: enums.CarrAggrMaping = None
 
-	# noinspection PyTypeChecker
 	def get_value(self) -> ValueStruct:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:CAGGregation:MAPing \n
-		Snippet: value: ValueStruct = driver.configure.carrierAggregation.maping.get_value() \n
+		Snippet: value: ValueStruct = driver.configure.lteMeas.carrierAggregation.maping.get_value() \n
 		No command help available \n
 			:return: structure: for return value, see the help for ValueStruct structure arguments.
 		"""
 		return self._core.io.query_struct('CONFigure:LTE:MEASurement<Instance>:CAGGregation:MAPing?', self.__class__.ValueStruct())
 
-	def clone(self) -> 'Maping':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'MapingCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Maping(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = MapingCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/CarrierAggregation_/Maping_/Scc.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Scc/__init__.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,45 +1,42 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
-from .....Internal.Utilities import trim_str_response
-from .....Internal.RepeatedCapability import RepeatedCapability
-from ..... import repcap
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal.RepeatedCapability import RepeatedCapability
+from ...... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Scc:
-	"""Scc commands group definition. 1 total commands, 0 Sub-groups, 1 group commands
+class SccCls:
+	"""Scc commands group definition. 1 total commands, 1 Subgroups, 0 group commands
 	Repeated Capability: SecondaryCC, default value after init: SecondaryCC.CC1"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("scc", core, parent)
-		self._base.rep_cap = RepeatedCapability(self._base.group_name, 'repcap_secondaryCC_get', 'repcap_secondaryCC_set', repcap.SecondaryCC.CC1)
+		self._cmd_group = CommandsGroup("scc", core, parent)
+		self._cmd_group.rep_cap = RepeatedCapability(self._cmd_group.group_name, 'repcap_secondaryCC_get', 'repcap_secondaryCC_set', repcap.SecondaryCC.CC1)
 
-	def repcap_secondaryCC_set(self, enum_value: repcap.SecondaryCC) -> None:
+	def repcap_secondaryCC_set(self, secondaryCC: repcap.SecondaryCC) -> None:
 		"""Repeated Capability default value numeric suffix.
 		This value is used, if you do not explicitely set it in the child set/get methods, or if you leave it to SecondaryCC.Default
 		Default value after init: SecondaryCC.CC1"""
-		self._base.set_repcap_enum_value(enum_value)
+		self._cmd_group.set_repcap_enum_value(secondaryCC)
 
 	def repcap_secondaryCC_get(self) -> repcap.SecondaryCC:
 		"""Returns the current default repeated capability for the child set/get methods"""
 		# noinspection PyTypeChecker
-		return self._base.get_repcap_enum_value()
+		return self._cmd_group.get_repcap_enum_value()
 
-	def get(self, secondaryCC=repcap.SecondaryCC.Default) -> str:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:CAGGregation:MAPing:SCC<Carrier> \n
-		Snippet: value: str = driver.configure.carrierAggregation.maping.scc.get(secondaryCC = repcap.SecondaryCC.Default) \n
-		No command help available \n
-			:param secondaryCC: optional repeated capability selector. Default value: CC1 (settable in the interface 'Scc')
-			:return: cc: No help available"""
-		secondaryCC_cmd_val = self._base.get_repcap_cmd_value(secondaryCC, repcap.SecondaryCC)
-		response = self._core.io.query_str(f'CONFigure:LTE:MEASurement<Instance>:CAGGregation:MAPing:SCC{secondaryCC_cmd_val}?')
-		return trim_str_response(response)
+	@property
+	def plcId(self):
+		"""plcId commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_plcId'):
+			from .PlcId import PlcIdCls
+			self._plcId = PlcIdCls(self._core, self._cmd_group)
+		return self._plcId
 
-	def clone(self) -> 'Scc':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'SccCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Scc(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = SccCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/CarrierAggregation_/Mcarrier.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/CarrierAggregation/Mcarrier.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,51 +1,51 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
-from ....Internal import Conversions
-from .... import enums
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
+from .....Internal import Conversions
+from ..... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Mcarrier:
-	"""Mcarrier commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class McarrierCls:
+	"""Mcarrier commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("mcarrier", core, parent)
+		self._cmd_group = CommandsGroup("mcarrier", core, parent)
 
 	# noinspection PyTypeChecker
 	def get_enhanced(self) -> enums.MeasCarrierEnhanced:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:CAGGregation:MCARrier:ENHanced \n
-		Snippet: value: enums.MeasCarrierEnhanced = driver.configure.carrierAggregation.mcarrier.get_enhanced() \n
-		Selects a component carrier for single-carrier measurements. \n
+		Snippet: value: enums.MeasCarrierEnhanced = driver.configure.lteMeas.carrierAggregation.mcarrier.get_enhanced() \n
+		Selects a component carrier for single carrier measurements. \n
 			:return: meas_carrier: No help available
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:CAGGregation:MCARrier:ENHanced?')
 		return Conversions.str_to_scalar_enum(response, enums.MeasCarrierEnhanced)
 
 	def set_enhanced(self, meas_carrier: enums.MeasCarrierEnhanced) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:CAGGregation:MCARrier:ENHanced \n
-		Snippet: driver.configure.carrierAggregation.mcarrier.set_enhanced(meas_carrier = enums.MeasCarrierEnhanced.CC1) \n
-		Selects a component carrier for single-carrier measurements. \n
+		Snippet: driver.configure.lteMeas.carrierAggregation.mcarrier.set_enhanced(meas_carrier = enums.MeasCarrierEnhanced.CC1) \n
+		Selects a component carrier for single carrier measurements. \n
 			:param meas_carrier: No help available
 		"""
 		param = Conversions.enum_scalar_to_str(meas_carrier, enums.MeasCarrierEnhanced)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:CAGGregation:MCARrier:ENHanced {param}')
 
 	# noinspection PyTypeChecker
 	def get_value(self) -> enums.MeasCarrierB:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:CAGGregation:MCARrier \n
-		Snippet: value: enums.MeasCarrierB = driver.configure.carrierAggregation.mcarrier.get_value() \n
+		Snippet: value: enums.MeasCarrierB = driver.configure.lteMeas.carrierAggregation.mcarrier.get_value() \n
 		No command help available \n
 			:return: meas_carrier: No help available
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:CAGGregation:MCARrier?')
 		return Conversions.str_to_scalar_enum(response, enums.MeasCarrierB)
 
 	def set_value(self, meas_carrier: enums.MeasCarrierB) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:CAGGregation:MCARrier \n
-		Snippet: driver.configure.carrierAggregation.mcarrier.set_value(meas_carrier = enums.MeasCarrierB.PCC) \n
+		Snippet: driver.configure.lteMeas.carrierAggregation.mcarrier.set_value(meas_carrier = enums.MeasCarrierB.PCC) \n
 		No command help available \n
 			:param meas_carrier: No help available
 		"""
 		param = Conversions.enum_scalar_to_str(meas_carrier, enums.MeasCarrierB)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:CAGGregation:MCARrier {param}')
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/CarrierAggregation_/Mode.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/CarrierAggregation/Mode.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,44 +1,44 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
-from ....Internal import Conversions
-from .... import enums
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
+from .....Internal import Conversions
+from ..... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Mode:
-	"""Mode commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class ModeCls:
+	"""Mode commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("mode", core, parent)
+		self._cmd_group = CommandsGroup("mode", core, parent)
 
 	# noinspection PyTypeChecker
 	def get_combined_signal_path(self) -> enums.CarrAggrMode:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:CAGGregation:MODE:CSPath \n
-		Snippet: value: enums.CarrAggrMode = driver.configure.carrierAggregation.mode.get_combined_signal_path() \n
+		Snippet: value: enums.CarrAggrMode = driver.configure.lteMeas.carrierAggregation.mode.get_combined_signal_path() \n
 		No command help available \n
 			:return: ca_mode: No help available
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:CAGGregation:MODE:CSPath?')
 		return Conversions.str_to_scalar_enum(response, enums.CarrAggrMode)
 
 	# noinspection PyTypeChecker
 	def get_value(self) -> enums.CarrAggrMode:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:CAGGregation:MODE \n
-		Snippet: value: enums.CarrAggrMode = driver.configure.carrierAggregation.mode.get_value() \n
-		Selects how many component carriers with intra-band contiguous aggregation are measured. For Signal Path = Network, the
+		Snippet: value: enums.CarrAggrMode = driver.configure.lteMeas.carrierAggregation.mode.get_value() \n
+		Selects how many component carriers with intraband contiguous aggregation are measured. For Signal Path = Network, the
 		setting is not configurable. \n
-			:return: ca_mode: OFF: only one carrier is measured INTRaband: two carriers (BW class B & C) ICD: three carriers (BW class D) ICE: four carriers (BW class E)
+			:return: ca_mode: OFF: Only one carrier is measured. INTRaband: two carriers (BW class B & C) ICD: three carriers (BW class D) ICE: four carriers (BW class E)
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:CAGGregation:MODE?')
 		return Conversions.str_to_scalar_enum(response, enums.CarrAggrMode)
 
 	def set_value(self, ca_mode: enums.CarrAggrMode) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:CAGGregation:MODE \n
-		Snippet: driver.configure.carrierAggregation.mode.set_value(ca_mode = enums.CarrAggrMode.ICD) \n
-		Selects how many component carriers with intra-band contiguous aggregation are measured. For Signal Path = Network, the
+		Snippet: driver.configure.lteMeas.carrierAggregation.mode.set_value(ca_mode = enums.CarrAggrMode.ICD) \n
+		Selects how many component carriers with intraband contiguous aggregation are measured. For Signal Path = Network, the
 		setting is not configurable. \n
-			:param ca_mode: OFF: only one carrier is measured INTRaband: two carriers (BW class B & C) ICD: three carriers (BW class D) ICE: four carriers (BW class E)
+			:param ca_mode: OFF: Only one carrier is measured. INTRaband: two carriers (BW class B & C) ICD: three carriers (BW class D) ICE: four carriers (BW class E)
 		"""
 		param = Conversions.enum_scalar_to_str(ca_mode, enums.CarrAggrMode)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:CAGGregation:MODE {param}')
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/CarrierAggregation_/Scc.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Pmonitor/Ulca/Scc/__init__.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,42 +1,74 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
-from ....Internal.RepeatedCapability import RepeatedCapability
-from .... import repcap
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal.RepeatedCapability import RepeatedCapability
+from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Scc:
-	"""Scc commands group definition. 1 total commands, 1 Sub-groups, 0 group commands
+class SccCls:
+	"""Scc commands group definition. 10 total commands, 5 Subgroups, 0 group commands
 	Repeated Capability: SecondaryCC, default value after init: SecondaryCC.CC1"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("scc", core, parent)
-		self._base.rep_cap = RepeatedCapability(self._base.group_name, 'repcap_secondaryCC_get', 'repcap_secondaryCC_set', repcap.SecondaryCC.CC1)
+		self._cmd_group = CommandsGroup("scc", core, parent)
+		self._cmd_group.rep_cap = RepeatedCapability(self._cmd_group.group_name, 'repcap_secondaryCC_get', 'repcap_secondaryCC_set', repcap.SecondaryCC.CC1)
 
-	def repcap_secondaryCC_set(self, enum_value: repcap.SecondaryCC) -> None:
+	def repcap_secondaryCC_set(self, secondaryCC: repcap.SecondaryCC) -> None:
 		"""Repeated Capability default value numeric suffix.
 		This value is used, if you do not explicitely set it in the child set/get methods, or if you leave it to SecondaryCC.Default
 		Default value after init: SecondaryCC.CC1"""
-		self._base.set_repcap_enum_value(enum_value)
+		self._cmd_group.set_repcap_enum_value(secondaryCC)
 
 	def repcap_secondaryCC_get(self) -> repcap.SecondaryCC:
 		"""Returns the current default repeated capability for the child set/get methods"""
 		# noinspection PyTypeChecker
-		return self._base.get_repcap_enum_value()
+		return self._cmd_group.get_repcap_enum_value()
 
 	@property
-	def acSpacing(self):
-		"""acSpacing commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_acSpacing'):
-			from .Scc_.AcSpacing import AcSpacing
-			self._acSpacing = AcSpacing(self._core, self._base)
-		return self._acSpacing
+	def current(self):
+		"""current commands group. 0 Sub-classes, 2 commands."""
+		if not hasattr(self, '_current'):
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
+		return self._current
 
-	def clone(self) -> 'Scc':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	@property
+	def average(self):
+		"""average commands group. 0 Sub-classes, 2 commands."""
+		if not hasattr(self, '_average'):
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
+		return self._average
+
+	@property
+	def maximum(self):
+		"""maximum commands group. 0 Sub-classes, 2 commands."""
+		if not hasattr(self, '_maximum'):
+			from .Maximum import MaximumCls
+			self._maximum = MaximumCls(self._core, self._cmd_group)
+		return self._maximum
+
+	@property
+	def minimum(self):
+		"""minimum commands group. 0 Sub-classes, 2 commands."""
+		if not hasattr(self, '_minimum'):
+			from .Minimum import MinimumCls
+			self._minimum = MinimumCls(self._core, self._cmd_group)
+		return self._minimum
+
+	@property
+	def standardDev(self):
+		"""standardDev commands group. 0 Sub-classes, 2 commands."""
+		if not hasattr(self, '_standardDev'):
+			from .StandardDev import StandardDevCls
+			self._standardDev = StandardDevCls(self._core, self._cmd_group)
+		return self._standardDev
+
+	def clone(self) -> 'SccCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Scc(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = SccCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/CarrierAggregation_/Scc_/AcSpacing.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/CarrierAggregation/Scc/AcSpacing.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,29 +1,31 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
-from ..... import repcap
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ...... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class AcSpacing:
-	"""AcSpacing commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class AcSpacingCls:
+	"""AcSpacing commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("acSpacing", core, parent)
+		self._cmd_group = CommandsGroup("acSpacing", core, parent)
 
 	def set(self, secondaryCC=repcap.SecondaryCC.Default) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:CAGGregation[:SCC<Nr>]:ACSPacing \n
-		Snippet: driver.configure.carrierAggregation.scc.acSpacing.set(secondaryCC = repcap.SecondaryCC.Default) \n
+		Snippet: driver.configure.lteMeas.carrierAggregation.scc.acSpacing.set(secondaryCC = repcap.SecondaryCC.Default) \n
 		Adjusts the component carrier frequencies, so that the carriers are aggregated contiguously. \n
-			:param secondaryCC: optional repeated capability selector. Default value: CC1 (settable in the interface 'Scc')"""
-		secondaryCC_cmd_val = self._base.get_repcap_cmd_value(secondaryCC, repcap.SecondaryCC)
+			:param secondaryCC: optional repeated capability selector. Default value: CC1 (settable in the interface 'Scc')
+		"""
+		secondaryCC_cmd_val = self._cmd_group.get_repcap_cmd_value(secondaryCC, repcap.SecondaryCC)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:CAGGregation:SCC{secondaryCC_cmd_val}:ACSPacing')
 
-	def set_with_opc(self, secondaryCC=repcap.SecondaryCC.Default) -> None:
-		secondaryCC_cmd_val = self._base.get_repcap_cmd_value(secondaryCC, repcap.SecondaryCC)
+	def set_with_opc(self, secondaryCC=repcap.SecondaryCC.Default, opc_timeout_ms: int = -1) -> None:
+		secondaryCC_cmd_val = self._cmd_group.get_repcap_cmd_value(secondaryCC, repcap.SecondaryCC)
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:CAGGregation[:SCC<Nr>]:ACSPacing \n
-		Snippet: driver.configure.carrierAggregation.scc.acSpacing.set_with_opc(secondaryCC = repcap.SecondaryCC.Default) \n
+		Snippet: driver.configure.lteMeas.carrierAggregation.scc.acSpacing.set_with_opc(secondaryCC = repcap.SecondaryCC.Default) \n
 		Adjusts the component carrier frequencies, so that the carriers are aggregated contiguously. \n
 		Same as set, but waits for the operation to complete before continuing further. Use the RsCMPX_LteMeas.utilities.opc_timeout_set() to set the timeout value. \n
-			:param secondaryCC: optional repeated capability selector. Default value: CC1 (settable in the interface 'Scc')"""
-		self._core.io.write_with_opc(f'CONFigure:LTE:MEASurement<Instance>:CAGGregation:SCC{secondaryCC_cmd_val}:ACSPacing')
+			:param secondaryCC: optional repeated capability selector. Default value: CC1 (settable in the interface 'Scc')
+			:param opc_timeout_ms: Maximum time to wait in milliseconds, valid only for this call."""
+		self._core.io.write_with_opc(f'CONFigure:LTE:MEASurement<Instance>:CAGGregation:SCC{secondaryCC_cmd_val}:ACSPacing', opc_timeout_ms)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/Cc.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/Cc/__init__.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,42 +1,42 @@
-from ...Internal.Core import Core
-from ...Internal.CommandsGroup import CommandsGroup
-from ...Internal.RepeatedCapability import RepeatedCapability
-from ... import repcap
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
+from .....Internal.RepeatedCapability import RepeatedCapability
+from ..... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Cc:
-	"""Cc commands group definition. 1 total commands, 1 Sub-groups, 0 group commands
+class CcCls:
+	"""Cc commands group definition. 1 total commands, 1 Subgroups, 0 group commands
 	Repeated Capability: CarrierComponent, default value after init: CarrierComponent.Nr1"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("cc", core, parent)
-		self._base.rep_cap = RepeatedCapability(self._base.group_name, 'repcap_carrierComponent_get', 'repcap_carrierComponent_set', repcap.CarrierComponent.Nr1)
+		self._cmd_group = CommandsGroup("cc", core, parent)
+		self._cmd_group.rep_cap = RepeatedCapability(self._cmd_group.group_name, 'repcap_carrierComponent_get', 'repcap_carrierComponent_set', repcap.CarrierComponent.Nr1)
 
-	def repcap_carrierComponent_set(self, enum_value: repcap.CarrierComponent) -> None:
+	def repcap_carrierComponent_set(self, carrierComponent: repcap.CarrierComponent) -> None:
 		"""Repeated Capability default value numeric suffix.
 		This value is used, if you do not explicitely set it in the child set/get methods, or if you leave it to CarrierComponent.Default
 		Default value after init: CarrierComponent.Nr1"""
-		self._base.set_repcap_enum_value(enum_value)
+		self._cmd_group.set_repcap_enum_value(carrierComponent)
 
 	def repcap_carrierComponent_get(self) -> repcap.CarrierComponent:
 		"""Returns the current default repeated capability for the child set/get methods"""
 		# noinspection PyTypeChecker
-		return self._base.get_repcap_enum_value()
+		return self._cmd_group.get_repcap_enum_value()
 
 	@property
 	def channelBw(self):
 		"""channelBw commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_channelBw'):
-			from .Cc_.ChannelBw import ChannelBw
-			self._channelBw = ChannelBw(self._core, self._base)
+			from .ChannelBw import ChannelBwCls
+			self._channelBw = ChannelBwCls(self._core, self._cmd_group)
 		return self._channelBw
 
-	def clone(self) -> 'Cc':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'CcCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Cc(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = CcCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/Cc_/ChannelBw.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/Cc/ChannelBw.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,37 +1,38 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
-from ....Internal import Conversions
-from .... import enums
-from .... import repcap
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
+from .....Internal import Conversions
+from ..... import enums
+from ..... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class ChannelBw:
-	"""ChannelBw commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class ChannelBwCls:
+	"""ChannelBw commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("channelBw", core, parent)
+		self._cmd_group = CommandsGroup("channelBw", core, parent)
 
 	def set(self, channel_bw: enums.ChannelBandwidth, carrierComponent=repcap.CarrierComponent.Default) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:CC<Nr>:CBANdwidth \n
-		Snippet: driver.configure.cc.channelBw.set(channel_bw = enums.ChannelBandwidth.B014, carrierComponent = repcap.CarrierComponent.Default) \n
+		Snippet: driver.configure.lteMeas.cc.channelBw.set(channel_bw = enums.ChannelBandwidth.B014, carrierComponent = repcap.CarrierComponent.Default) \n
 		Selects the channel bandwidth of component carrier CC<no>. Without carrier aggregation, you can omit <no>. For Signal
 		Path = Network, use [CONFigure:]SIGNaling:LTE:CELL:RFSettings:UL:BWIDth. \n
 			:param channel_bw: B014: 1.4 MHz B030: 3 MHz B050: 5 MHz B100: 10 MHz B150: 15 MHz B200: 20 MHz
-			:param carrierComponent: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Cc')"""
+			:param carrierComponent: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Cc')
+		"""
 		param = Conversions.enum_scalar_to_str(channel_bw, enums.ChannelBandwidth)
-		carrierComponent_cmd_val = self._base.get_repcap_cmd_value(carrierComponent, repcap.CarrierComponent)
+		carrierComponent_cmd_val = self._cmd_group.get_repcap_cmd_value(carrierComponent, repcap.CarrierComponent)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:CC{carrierComponent_cmd_val}:CBANdwidth {param}')
 
 	# noinspection PyTypeChecker
 	def get(self, carrierComponent=repcap.CarrierComponent.Default) -> enums.ChannelBandwidth:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:CC<Nr>:CBANdwidth \n
-		Snippet: value: enums.ChannelBandwidth = driver.configure.cc.channelBw.get(carrierComponent = repcap.CarrierComponent.Default) \n
+		Snippet: value: enums.ChannelBandwidth = driver.configure.lteMeas.cc.channelBw.get(carrierComponent = repcap.CarrierComponent.Default) \n
 		Selects the channel bandwidth of component carrier CC<no>. Without carrier aggregation, you can omit <no>. For Signal
 		Path = Network, use [CONFigure:]SIGNaling:LTE:CELL:RFSettings:UL:BWIDth. \n
 			:param carrierComponent: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Cc')
 			:return: channel_bw: B014: 1.4 MHz B030: 3 MHz B050: 5 MHz B100: 10 MHz B150: 15 MHz B200: 20 MHz"""
-		carrierComponent_cmd_val = self._base.get_repcap_cmd_value(carrierComponent, repcap.CarrierComponent)
+		carrierComponent_cmd_val = self._cmd_group.get_repcap_cmd_value(carrierComponent, repcap.CarrierComponent)
 		response = self._core.io.query_str(f'CONFigure:LTE:MEASurement<Instance>:CC{carrierComponent_cmd_val}:CBANdwidth?')
 		return Conversions.str_to_scalar_enum(response, enums.ChannelBandwidth)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/Emtc.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/Emtc.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,66 +1,66 @@
-from ...Internal.Core import Core
-from ...Internal.CommandsGroup import CommandsGroup
-from ...Internal import Conversions
+from ....Internal.Core import Core
+from ....Internal.CommandsGroup import CommandsGroup
+from ....Internal import Conversions
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Emtc:
-	"""Emtc commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class EmtcCls:
+	"""Emtc commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("emtc", core, parent)
+		self._cmd_group = CommandsGroup("emtc", core, parent)
 
 	def get_enable(self) -> bool:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:EMTC:ENABle \n
-		Snippet: value: bool = driver.configure.emtc.get_enable() \n
+		Snippet: value: bool = driver.configure.lteMeas.emtc.get_enable() \n
 		Enables or disables eMTC. For Signal Path = Network, the setting is not configurable. \n
 			:return: enable: No help available
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:EMTC:ENABle?')
 		return Conversions.str_to_bool(response)
 
 	def set_enable(self, enable: bool) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:EMTC:ENABle \n
-		Snippet: driver.configure.emtc.set_enable(enable = False) \n
+		Snippet: driver.configure.lteMeas.emtc.set_enable(enable = False) \n
 		Enables or disables eMTC. For Signal Path = Network, the setting is not configurable. \n
 			:param enable: No help available
 		"""
 		param = Conversions.bool_to_str(enable)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:EMTC:ENABle {param}')
 
 	def get_mb(self) -> bool:
 		"""SCPI: CONFigure:LTE:MEASurement<instance>:EMTC:MB<number> \n
-		Snippet: value: bool = driver.configure.emtc.get_mb() \n
+		Snippet: value: bool = driver.configure.lteMeas.emtc.get_mb() \n
 		Selects the maximum eMTC bandwidth. \n
 			:return: enable: OFF: Max bandwidth 1.4 MHz ON: Max bandwidth 5 MHz
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:EMTC:MB5?')
 		return Conversions.str_to_bool(response)
 
 	def set_mb(self, enable: bool) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<instance>:EMTC:MB<number> \n
-		Snippet: driver.configure.emtc.set_mb(enable = False) \n
+		Snippet: driver.configure.lteMeas.emtc.set_mb(enable = False) \n
 		Selects the maximum eMTC bandwidth. \n
 			:param enable: OFF: Max bandwidth 1.4 MHz ON: Max bandwidth 5 MHz
 		"""
 		param = Conversions.bool_to_str(enable)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:EMTC:MB5 {param}')
 
 	def get_nband(self) -> int:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:EMTC:NBANd \n
-		Snippet: value: int = driver.configure.emtc.get_nband() \n
+		Snippet: value: int = driver.configure.lteMeas.emtc.get_nband() \n
 		Selects the narrowband used for eMTC. \n
-			:return: number: The maximum depends on the channel BW, see 'RB allocation and narrowbands for eMTC'.
+			:return: number: The maximum depends on the channel BW, see 'RB allocation, narrowbands and widebands for eMTC'.
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:EMTC:NBANd?')
 		return Conversions.str_to_int(response)
 
 	def set_nband(self, number: int) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:EMTC:NBANd \n
-		Snippet: driver.configure.emtc.set_nband(number = 1) \n
+		Snippet: driver.configure.lteMeas.emtc.set_nband(number = 1) \n
 		Selects the narrowband used for eMTC. \n
-			:param number: The maximum depends on the channel BW, see 'RB allocation and narrowbands for eMTC'.
+			:param number: The maximum depends on the channel BW, see 'RB allocation, narrowbands and widebands for eMTC'.
 		"""
 		param = Conversions.decimal_value_to_str(number)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:EMTC:NBANd {param}')
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/__init__.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,574 +1,545 @@
-from ...Internal.Core import Core
-from ...Internal.CommandsGroup import CommandsGroup
-from ...Internal import Conversions
-from ...Internal.StructBase import StructBase
-from ...Internal.ArgStruct import ArgStruct
-from ... import enums
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
+from .....Internal import Conversions
+from ..... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class MultiEval:
-	"""MultiEval commands group definition. 138 total commands, 16 Sub-groups, 20 group commands"""
+class MultiEvalCls:
+	"""MultiEval commands group definition. 141 total commands, 17 Subgroups, 19 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("multiEval", core, parent)
+		self._cmd_group = CommandsGroup("multiEval", core, parent)
 
 	@property
 	def listPy(self):
-		"""listPy commands group. 2 Sub-classes, 4 commands."""
+		"""listPy commands group. 3 Sub-classes, 5 commands."""
 		if not hasattr(self, '_listPy'):
-			from .MultiEval_.ListPy import ListPy
-			self._listPy = ListPy(self._core, self._base)
+			from .ListPy import ListPyCls
+			self._listPy = ListPyCls(self._core, self._cmd_group)
 		return self._listPy
 
 	@property
 	def tmode(self):
 		"""tmode commands group. 0 Sub-classes, 3 commands."""
 		if not hasattr(self, '_tmode'):
-			from .MultiEval_.Tmode import Tmode
-			self._tmode = Tmode(self._core, self._base)
+			from .Tmode import TmodeCls
+			self._tmode = TmodeCls(self._core, self._cmd_group)
 		return self._tmode
 
 	@property
 	def pcc(self):
 		"""pcc commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_pcc'):
-			from .MultiEval_.Pcc import Pcc
-			self._pcc = Pcc(self._core, self._base)
+			from .Pcc import PccCls
+			self._pcc = PccCls(self._core, self._cmd_group)
 		return self._pcc
 
 	@property
 	def scc(self):
 		"""scc commands group. 1 Sub-classes, 0 commands."""
 		if not hasattr(self, '_scc'):
-			from .MultiEval_.Scc import Scc
-			self._scc = Scc(self._core, self._base)
+			from .Scc import SccCls
+			self._scc = SccCls(self._core, self._cmd_group)
 		return self._scc
 
 	@property
 	def cc(self):
 		"""cc commands group. 1 Sub-classes, 0 commands."""
 		if not hasattr(self, '_cc'):
-			from .MultiEval_.Cc import Cc
-			self._cc = Cc(self._core, self._base)
+			from .Cc import CcCls
+			self._cc = CcCls(self._core, self._cmd_group)
 		return self._cc
 
 	@property
 	def nsValue(self):
 		"""nsValue commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_nsValue'):
-			from .MultiEval_.NsValue import NsValue
-			self._nsValue = NsValue(self._core, self._base)
+			from .NsValue import NsValueCls
+			self._nsValue = NsValueCls(self._core, self._cmd_group)
 		return self._nsValue
 
 	@property
 	def srs(self):
 		"""srs commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_srs'):
-			from .MultiEval_.Srs import Srs
-			self._srs = Srs(self._core, self._base)
+			from .Srs import SrsCls
+			self._srs = SrsCls(self._core, self._cmd_group)
 		return self._srs
 
 	@property
 	def modulation(self):
 		"""modulation commands group. 3 Sub-classes, 3 commands."""
 		if not hasattr(self, '_modulation'):
-			from .MultiEval_.Modulation import Modulation
-			self._modulation = Modulation(self._core, self._base)
+			from .Modulation import ModulationCls
+			self._modulation = ModulationCls(self._core, self._cmd_group)
 		return self._modulation
 
 	@property
 	def spectrum(self):
 		"""spectrum commands group. 2 Sub-classes, 0 commands."""
 		if not hasattr(self, '_spectrum'):
-			from .MultiEval_.Spectrum import Spectrum
-			self._spectrum = Spectrum(self._core, self._base)
+			from .Spectrum import SpectrumCls
+			self._spectrum = SpectrumCls(self._core, self._cmd_group)
 		return self._spectrum
 
 	@property
 	def rbAllocation(self):
 		"""rbAllocation commands group. 3 Sub-classes, 1 commands."""
 		if not hasattr(self, '_rbAllocation'):
-			from .MultiEval_.RbAllocation import RbAllocation
-			self._rbAllocation = RbAllocation(self._core, self._base)
+			from .RbAllocation import RbAllocationCls
+			self._rbAllocation = RbAllocationCls(self._core, self._cmd_group)
 		return self._rbAllocation
 
 	@property
 	def power(self):
 		"""power commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_power'):
-			from .MultiEval_.Power import Power
-			self._power = Power(self._core, self._base)
+			from .Power import PowerCls
+			self._power = PowerCls(self._core, self._cmd_group)
 		return self._power
 
 	@property
 	def pdynamics(self):
 		"""pdynamics commands group. 1 Sub-classes, 1 commands."""
 		if not hasattr(self, '_pdynamics'):
-			from .MultiEval_.Pdynamics import Pdynamics
-			self._pdynamics = Pdynamics(self._core, self._base)
+			from .Pdynamics import PdynamicsCls
+			self._pdynamics = PdynamicsCls(self._core, self._cmd_group)
 		return self._pdynamics
 
 	@property
+	def msubFrames(self):
+		"""msubFrames commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_msubFrames'):
+			from .MsubFrames import MsubFramesCls
+			self._msubFrames = MsubFramesCls(self._core, self._cmd_group)
+		return self._msubFrames
+
+	@property
 	def scount(self):
 		"""scount commands group. 1 Sub-classes, 2 commands."""
 		if not hasattr(self, '_scount'):
-			from .MultiEval_.Scount import Scount
-			self._scount = Scount(self._core, self._base)
+			from .Scount import ScountCls
+			self._scount = ScountCls(self._core, self._cmd_group)
 		return self._scount
 
 	@property
 	def result(self):
 		"""result commands group. 1 Sub-classes, 14 commands."""
 		if not hasattr(self, '_result'):
-			from .MultiEval_.Result import Result
-			self._result = Result(self._core, self._base)
+			from .Result import ResultCls
+			self._result = ResultCls(self._core, self._cmd_group)
 		return self._result
 
 	@property
 	def limit(self):
 		"""limit commands group. 5 Sub-classes, 0 commands."""
 		if not hasattr(self, '_limit'):
-			from .MultiEval_.Limit import Limit
-			self._limit = Limit(self._core, self._base)
+			from .Limit import LimitCls
+			self._limit = LimitCls(self._core, self._cmd_group)
 		return self._limit
 
 	@property
 	def bler(self):
-		"""bler commands group. 0 Sub-classes, 1 commands."""
+		"""bler commands group. 1 Sub-classes, 0 commands."""
 		if not hasattr(self, '_bler'):
-			from .MultiEval_.Bler import Bler
-			self._bler = Bler(self._core, self._base)
+			from .Bler import BlerCls
+			self._bler = BlerCls(self._core, self._cmd_group)
 		return self._bler
 
 	def get_timeout(self) -> float:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:TOUT \n
-		Snippet: value: float = driver.configure.multiEval.get_timeout() \n
+		Snippet: value: float = driver.configure.lteMeas.multiEval.get_timeout() \n
 		Defines a timeout for the measurement. The timer is started when the measurement is initiated via a READ or INIT command.
-		It is not started if the measurement is initiated manually (ON | OFF key or RESTART | STOP key) . When the measurement
-		has completed the first measurement cycle (first single shot) , the statistical depth is reached and the timer is reset.
-		If the first measurement cycle has not been completed when the timer expires, the measurement is stopped. The measurement
-		state changes to RDY. The reliability indicator is set to 1, indicating that a measurement timeout occurred.
-		Still running READ, FETCh or CALCulate commands are completed, returning the available results. At least for some results,
-		there are no values at all or the statistical depth has not been reached. A timeout of 0 s corresponds to an infinite
-		measurement timeout. \n
+		It is not started if the measurement is initiated manually. When the measurement has completed the first measurement
+		cycle (first single shot) , the statistical depth is reached and the timer is reset. If the first measurement cycle has
+		not been completed when the timer expires, the measurement is stopped. The measurement state changes to RDY.
+		The reliability indicator is set to 1, indicating that a measurement timeout occurred. Still running READ, FETCh or
+		CALCulate commands are completed, returning the available results. At least for some results, there are no values at all
+		or the statistical depth has not been reached. A timeout of 0 s corresponds to an infinite measurement timeout. \n
 			:return: timeout: No help available
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:MEValuation:TOUT?')
 		return Conversions.str_to_float(response)
 
 	def set_timeout(self, timeout: float) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:TOUT \n
-		Snippet: driver.configure.multiEval.set_timeout(timeout = 1.0) \n
+		Snippet: driver.configure.lteMeas.multiEval.set_timeout(timeout = 1.0) \n
 		Defines a timeout for the measurement. The timer is started when the measurement is initiated via a READ or INIT command.
-		It is not started if the measurement is initiated manually (ON | OFF key or RESTART | STOP key) . When the measurement
-		has completed the first measurement cycle (first single shot) , the statistical depth is reached and the timer is reset.
-		If the first measurement cycle has not been completed when the timer expires, the measurement is stopped. The measurement
-		state changes to RDY. The reliability indicator is set to 1, indicating that a measurement timeout occurred.
-		Still running READ, FETCh or CALCulate commands are completed, returning the available results. At least for some results,
-		there are no values at all or the statistical depth has not been reached. A timeout of 0 s corresponds to an infinite
-		measurement timeout. \n
+		It is not started if the measurement is initiated manually. When the measurement has completed the first measurement
+		cycle (first single shot) , the statistical depth is reached and the timer is reset. If the first measurement cycle has
+		not been completed when the timer expires, the measurement is stopped. The measurement state changes to RDY.
+		The reliability indicator is set to 1, indicating that a measurement timeout occurred. Still running READ, FETCh or
+		CALCulate commands are completed, returning the available results. At least for some results, there are no values at all
+		or the statistical depth has not been reached. A timeout of 0 s corresponds to an infinite measurement timeout. \n
 			:param timeout: No help available
 		"""
 		param = Conversions.decimal_value_to_str(timeout)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:TOUT {param}')
 
 	# noinspection PyTypeChecker
 	def get_mmode(self) -> enums.MeasurementMode:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:MMODe \n
-		Snippet: value: enums.MeasurementMode = driver.configure.multiEval.get_mmode() \n
+		Snippet: value: enums.MeasurementMode = driver.configure.lteMeas.multiEval.get_mmode() \n
 		Selects the measurement mode. \n
 			:return: measurement_mode: NORMal: normal mode TMODe: TPC mode MELMode: multi-evaluation list mode
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:MEValuation:MMODe?')
 		return Conversions.str_to_scalar_enum(response, enums.MeasurementMode)
 
 	def set_mmode(self, measurement_mode: enums.MeasurementMode) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:MMODe \n
-		Snippet: driver.configure.multiEval.set_mmode(measurement_mode = enums.MeasurementMode.MELMode) \n
+		Snippet: driver.configure.lteMeas.multiEval.set_mmode(measurement_mode = enums.MeasurementMode.MELMode) \n
 		Selects the measurement mode. \n
 			:param measurement_mode: NORMal: normal mode TMODe: TPC mode MELMode: multi-evaluation list mode
 		"""
 		param = Conversions.enum_scalar_to_str(measurement_mode, enums.MeasurementMode)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:MMODe {param}')
 
 	# noinspection PyTypeChecker
 	def get_repetition(self) -> enums.Repeat:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:REPetition \n
-		Snippet: value: enums.Repeat = driver.configure.multiEval.get_repetition() \n
+		Snippet: value: enums.Repeat = driver.configure.lteMeas.multiEval.get_repetition() \n
 		Specifies the repetition mode of the measurement. The repetition mode specifies whether the measurement is stopped after
 		a single shot or repeated continuously. Use CONFigure:..:MEAS<i>:...:SCOunt to determine the number of measurement
 		intervals per single shot. \n
 			:return: repetition: SINGleshot: Single-shot measurement CONTinuous: Continuous measurement
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:MEValuation:REPetition?')
 		return Conversions.str_to_scalar_enum(response, enums.Repeat)
 
 	def set_repetition(self, repetition: enums.Repeat) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:REPetition \n
-		Snippet: driver.configure.multiEval.set_repetition(repetition = enums.Repeat.CONTinuous) \n
+		Snippet: driver.configure.lteMeas.multiEval.set_repetition(repetition = enums.Repeat.CONTinuous) \n
 		Specifies the repetition mode of the measurement. The repetition mode specifies whether the measurement is stopped after
 		a single shot or repeated continuously. Use CONFigure:..:MEAS<i>:...:SCOunt to determine the number of measurement
 		intervals per single shot. \n
 			:param repetition: SINGleshot: Single-shot measurement CONTinuous: Continuous measurement
 		"""
 		param = Conversions.enum_scalar_to_str(repetition, enums.Repeat)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:REPetition {param}')
 
 	# noinspection PyTypeChecker
 	def get_scondition(self) -> enums.StopCondition:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:SCONdition \n
-		Snippet: value: enums.StopCondition = driver.configure.multiEval.get_scondition() \n
+		Snippet: value: enums.StopCondition = driver.configure.lteMeas.multiEval.get_scondition() \n
 		Qualifies whether the measurement is stopped after a failed limit check or continued. SLFail means that the measurement
 		is stopped and reaches the RDY state when one of the results exceeds the limits. \n
-			:return: stop_condition: NONE: Continue measurement irrespective of the limit check SLFail: Stop measurement on limit failure
+			:return: stop_condition: NONE: Continue measurement irrespective of the limit check. SLFail: Stop measurement on limit failure.
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:MEValuation:SCONdition?')
 		return Conversions.str_to_scalar_enum(response, enums.StopCondition)
 
 	def set_scondition(self, stop_condition: enums.StopCondition) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:SCONdition \n
-		Snippet: driver.configure.multiEval.set_scondition(stop_condition = enums.StopCondition.NONE) \n
+		Snippet: driver.configure.lteMeas.multiEval.set_scondition(stop_condition = enums.StopCondition.NONE) \n
 		Qualifies whether the measurement is stopped after a failed limit check or continued. SLFail means that the measurement
 		is stopped and reaches the RDY state when one of the results exceeds the limits. \n
-			:param stop_condition: NONE: Continue measurement irrespective of the limit check SLFail: Stop measurement on limit failure
+			:param stop_condition: NONE: Continue measurement irrespective of the limit check. SLFail: Stop measurement on limit failure.
 		"""
 		param = Conversions.enum_scalar_to_str(stop_condition, enums.StopCondition)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:SCONdition {param}')
 
 	def get_ul_dl(self) -> int:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:ULDL \n
-		Snippet: value: int = driver.configure.multiEval.get_ul_dl() \n
+		Snippet: value: int = driver.configure.lteMeas.multiEval.get_ul_dl() \n
 		Selects an UL-DL configuration, defining the combination of uplink, downlink and special subframes within a radio frame.
-		This parameter is only relevant for frame structure Type 2 (method RsCMPX_LteMeas.Configure.fstructure) .
+		This parameter is only relevant for frame structure Type 2 (method RsCMPX_LteMeas.Configure.LteMeas.fstructure) .
 		The UL-DL configurations are defined in 3GPP TS 36.211, chapter 4, 'Frame Structure'. \n
 			:return: uplink_downlink: No help available
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:MEValuation:ULDL?')
 		return Conversions.str_to_int(response)
 
 	def set_ul_dl(self, uplink_downlink: int) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:ULDL \n
-		Snippet: driver.configure.multiEval.set_ul_dl(uplink_downlink = 1) \n
+		Snippet: driver.configure.lteMeas.multiEval.set_ul_dl(uplink_downlink = 1) \n
 		Selects an UL-DL configuration, defining the combination of uplink, downlink and special subframes within a radio frame.
-		This parameter is only relevant for frame structure Type 2 (method RsCMPX_LteMeas.Configure.fstructure) .
+		This parameter is only relevant for frame structure Type 2 (method RsCMPX_LteMeas.Configure.LteMeas.fstructure) .
 		The UL-DL configurations are defined in 3GPP TS 36.211, chapter 4, 'Frame Structure'. \n
 			:param uplink_downlink: No help available
 		"""
 		param = Conversions.decimal_value_to_str(uplink_downlink)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:ULDL {param}')
 
 	def get_ssubframe(self) -> int:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:SSUBframe \n
-		Snippet: value: int = driver.configure.multiEval.get_ssubframe() \n
+		Snippet: value: int = driver.configure.lteMeas.multiEval.get_ssubframe() \n
 		Selects a special subframe configuration, defining the inner structure of special subframes. This parameter is only
-		relevant for frame structure Type 2 (method RsCMPX_LteMeas.Configure.fstructure) . The special subframe configurations
-		are defined in 3GPP TS 36.211, chapter 4, 'Frame Structure'. \n
+		relevant for frame structure Type 2 (method RsCMPX_LteMeas.Configure.LteMeas.fstructure) . The special subframe
+		configurations are defined in 3GPP TS 36.211, chapter 4, 'Frame Structure'. \n
 			:return: special_subframe: No help available
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:MEValuation:SSUBframe?')
 		return Conversions.str_to_int(response)
 
 	def set_ssubframe(self, special_subframe: int) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:SSUBframe \n
-		Snippet: driver.configure.multiEval.set_ssubframe(special_subframe = 1) \n
+		Snippet: driver.configure.lteMeas.multiEval.set_ssubframe(special_subframe = 1) \n
 		Selects a special subframe configuration, defining the inner structure of special subframes. This parameter is only
-		relevant for frame structure Type 2 (method RsCMPX_LteMeas.Configure.fstructure) . The special subframe configurations
-		are defined in 3GPP TS 36.211, chapter 4, 'Frame Structure'. \n
+		relevant for frame structure Type 2 (method RsCMPX_LteMeas.Configure.LteMeas.fstructure) . The special subframe
+		configurations are defined in 3GPP TS 36.211, chapter 4, 'Frame Structure'. \n
 			:param special_subframe: No help available
 		"""
 		param = Conversions.decimal_value_to_str(special_subframe)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:SSUBframe {param}')
 
 	def get_mo_exception(self) -> bool:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:MOEXception \n
-		Snippet: value: bool = driver.configure.multiEval.get_mo_exception() \n
+		Snippet: value: bool = driver.configure.lteMeas.multiEval.get_mo_exception() \n
 		Specifies whether measurement results identified as faulty or inaccurate are rejected. \n
-			:return: meas_on_exception: OFF: Faulty results are rejected ON: Results are never rejected
+			:return: meas_on_exception: OFF: Faulty results are rejected. ON: Results are never rejected.
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:MEValuation:MOEXception?')
 		return Conversions.str_to_bool(response)
 
 	def set_mo_exception(self, meas_on_exception: bool) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:MOEXception \n
-		Snippet: driver.configure.multiEval.set_mo_exception(meas_on_exception = False) \n
+		Snippet: driver.configure.lteMeas.multiEval.set_mo_exception(meas_on_exception = False) \n
 		Specifies whether measurement results identified as faulty or inaccurate are rejected. \n
-			:param meas_on_exception: OFF: Faulty results are rejected ON: Results are never rejected
+			:param meas_on_exception: OFF: Faulty results are rejected. ON: Results are never rejected.
 		"""
 		param = Conversions.bool_to_str(meas_on_exception)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:MOEXception {param}')
 
 	# noinspection PyTypeChecker
 	def get_cprefix(self) -> enums.CyclicPrefix:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:CPRefix \n
-		Snippet: value: enums.CyclicPrefix = driver.configure.multiEval.get_cprefix() \n
+		Snippet: value: enums.CyclicPrefix = driver.configure.lteMeas.multiEval.get_cprefix() \n
 		Selects the type of cyclic prefix of the LTE signal. For Signal Path = Network, the setting is not configurable. \n
 			:return: cyclic_prefix: No help available
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:MEValuation:CPRefix?')
 		return Conversions.str_to_scalar_enum(response, enums.CyclicPrefix)
 
 	def set_cprefix(self, cyclic_prefix: enums.CyclicPrefix) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:CPRefix \n
-		Snippet: driver.configure.multiEval.set_cprefix(cyclic_prefix = enums.CyclicPrefix.EXTended) \n
+		Snippet: driver.configure.lteMeas.multiEval.set_cprefix(cyclic_prefix = enums.CyclicPrefix.EXTended) \n
 		Selects the type of cyclic prefix of the LTE signal. For Signal Path = Network, the setting is not configurable. \n
 			:param cyclic_prefix: No help available
 		"""
 		param = Conversions.enum_scalar_to_str(cyclic_prefix, enums.CyclicPrefix)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:CPRefix {param}')
 
 	# noinspection PyTypeChecker
 	def get_ctype(self) -> enums.ChannelTypeDetection:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:CTYPe \n
-		Snippet: value: enums.ChannelTypeDetection = driver.configure.multiEval.get_ctype() \n
+		Snippet: value: enums.ChannelTypeDetection = driver.configure.lteMeas.multiEval.get_ctype() \n
 		Configures the channel type detection for uplink measurements. \n
 			:return: channel_type: Automatic detection of channel type or manual selection
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:MEValuation:CTYPe?')
 		return Conversions.str_to_scalar_enum(response, enums.ChannelTypeDetection)
 
 	def set_ctype(self, channel_type: enums.ChannelTypeDetection) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:CTYPe \n
-		Snippet: driver.configure.multiEval.set_ctype(channel_type = enums.ChannelTypeDetection.AUTO) \n
+		Snippet: driver.configure.lteMeas.multiEval.set_ctype(channel_type = enums.ChannelTypeDetection.AUTO) \n
 		Configures the channel type detection for uplink measurements. \n
 			:param channel_type: Automatic detection of channel type or manual selection
 		"""
 		param = Conversions.enum_scalar_to_str(channel_type, enums.ChannelTypeDetection)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:CTYPe {param}')
 
 	# noinspection PyTypeChecker
 	def get_sch_type(self) -> enums.SidelinkChannelType:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:SCTYpe \n
-		Snippet: value: enums.SidelinkChannelType = driver.configure.multiEval.get_sch_type() \n
+		Snippet: value: enums.SidelinkChannelType = driver.configure.lteMeas.multiEval.get_sch_type() \n
 		Configures the channel type for modulation results of sidelink measurements. \n
 			:return: channel_type: No help available
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:MEValuation:SCTYpe?')
 		return Conversions.str_to_scalar_enum(response, enums.SidelinkChannelType)
 
 	def set_sch_type(self, channel_type: enums.SidelinkChannelType) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:SCTYpe \n
-		Snippet: driver.configure.multiEval.set_sch_type(channel_type = enums.SidelinkChannelType.PSCCh) \n
+		Snippet: driver.configure.lteMeas.multiEval.set_sch_type(channel_type = enums.SidelinkChannelType.PSBCh) \n
 		Configures the channel type for modulation results of sidelink measurements. \n
 			:param channel_type: No help available
 		"""
 		param = Conversions.enum_scalar_to_str(channel_type, enums.SidelinkChannelType)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:SCTYpe {param}')
 
 	def get_peak_search(self) -> bool:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:PSEarch \n
-		Snippet: value: bool = driver.configure.multiEval.get_peak_search() \n
+		Snippet: value: bool = driver.configure.lteMeas.multiEval.get_peak_search() \n
 		No command help available \n
 			:return: pucch_search: No help available
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:MEValuation:PSEarch?')
 		return Conversions.str_to_bool(response)
 
 	def set_peak_search(self, pucch_search: bool) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:PSEarch \n
-		Snippet: driver.configure.multiEval.set_peak_search(pucch_search = False) \n
+		Snippet: driver.configure.lteMeas.multiEval.set_peak_search(pucch_search = False) \n
 		No command help available \n
 			:param pucch_search: No help available
 		"""
 		param = Conversions.bool_to_str(pucch_search)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:PSEarch {param}')
 
 	# noinspection PyTypeChecker
 	def get_pformat(self) -> enums.PucchFormat:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:PFORmat \n
-		Snippet: value: enums.PucchFormat = driver.configure.multiEval.get_pformat() \n
+		Snippet: value: enums.PucchFormat = driver.configure.lteMeas.multiEval.get_pformat() \n
 		Specifies the PUCCH format (only relevant for signals containing a PUCCH) . The formats are defined in 3GPP TS 36.211. \n
 			:return: pucch_format: No help available
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:MEValuation:PFORmat?')
 		return Conversions.str_to_scalar_enum(response, enums.PucchFormat)
 
 	def set_pformat(self, pucch_format: enums.PucchFormat) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:PFORmat \n
-		Snippet: driver.configure.multiEval.set_pformat(pucch_format = enums.PucchFormat.F1) \n
+		Snippet: driver.configure.lteMeas.multiEval.set_pformat(pucch_format = enums.PucchFormat.F1) \n
 		Specifies the PUCCH format (only relevant for signals containing a PUCCH) . The formats are defined in 3GPP TS 36.211. \n
 			:param pucch_format: No help available
 		"""
 		param = Conversions.enum_scalar_to_str(pucch_format, enums.PucchFormat)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:PFORmat {param}')
 
 	def get_nvfilter(self) -> int or bool:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:NVFilter \n
-		Snippet: value: int or bool = driver.configure.multiEval.get_nvfilter() \n
+		Snippet: value: int or bool = driver.configure.lteMeas.multiEval.get_nvfilter() \n
 		Specifies, enables or disables the number of resource blocks (NRB) view filter. If the filter is active, only slots with
 		a matching number of allocated resource blocks are measured. Within the indicated input range, only specific numbers are
-		allowed as defined in 3GPP TS 36.211. For details, see 'Resources in Time and Frequency Domain'. \n
-			:return: nrb_view_filter: Number of allocated resource blocks
+		allowed as defined in 3GPP TS 36.211. For details, see 'Resources in time and frequency domain'. \n
+			:return: nrb_view_filter: (integer or boolean) Number of allocated resource blocks
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:MEValuation:NVFilter?')
 		return Conversions.str_to_int_or_bool(response)
 
 	def set_nvfilter(self, nrb_view_filter: int or bool) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:NVFilter \n
-		Snippet: driver.configure.multiEval.set_nvfilter(nrb_view_filter = 1) \n
+		Snippet: driver.configure.lteMeas.multiEval.set_nvfilter(nrb_view_filter = 1) \n
 		Specifies, enables or disables the number of resource blocks (NRB) view filter. If the filter is active, only slots with
 		a matching number of allocated resource blocks are measured. Within the indicated input range, only specific numbers are
-		allowed as defined in 3GPP TS 36.211. For details, see 'Resources in Time and Frequency Domain'. \n
-			:param nrb_view_filter: Number of allocated resource blocks
+		allowed as defined in 3GPP TS 36.211. For details, see 'Resources in time and frequency domain'. \n
+			:param nrb_view_filter: (integer or boolean) Number of allocated resource blocks
 		"""
 		param = Conversions.decimal_or_bool_value_to_str(nrb_view_filter)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:NVFilter {param}')
 
 	def get_orv_filter(self) -> int or bool:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:ORVFilter \n
-		Snippet: value: int or bool = driver.configure.multiEval.get_orv_filter() \n
+		Snippet: value: int or bool = driver.configure.lteMeas.multiEval.get_orv_filter() \n
 		Specifies, enables or disables the RB offset view filter. If the filter is active, only slots with a matching number of
 		RB offset are measured. The indicated input range applies to a 20-MHz channel bandwidth. The maximum value depends on the
 		bandwidth (maximum number of RBs minus one) . \n
-			:return: offset_rb: Offset of the first allocated RB
+			:return: offset_rb: (integer or boolean) Offset of the first allocated RB
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:MEValuation:ORVFilter?')
 		return Conversions.str_to_int_or_bool(response)
 
 	def set_orv_filter(self, offset_rb: int or bool) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:ORVFilter \n
-		Snippet: driver.configure.multiEval.set_orv_filter(offset_rb = 1) \n
+		Snippet: driver.configure.lteMeas.multiEval.set_orv_filter(offset_rb = 1) \n
 		Specifies, enables or disables the RB offset view filter. If the filter is active, only slots with a matching number of
 		RB offset are measured. The indicated input range applies to a 20-MHz channel bandwidth. The maximum value depends on the
 		bandwidth (maximum number of RBs minus one) . \n
-			:param offset_rb: Offset of the first allocated RB
+			:param offset_rb: (integer or boolean) Offset of the first allocated RB
 		"""
 		param = Conversions.decimal_or_bool_value_to_str(offset_rb)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:ORVFilter {param}')
 
 	# noinspection PyTypeChecker
 	def get_ctv_filter(self) -> enums.ChannelTypeVewFilter:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:CTVFilter \n
-		Snippet: value: enums.ChannelTypeVewFilter = driver.configure.multiEval.get_ctv_filter() \n
+		Snippet: value: enums.ChannelTypeVewFilter = driver.configure.lteMeas.multiEval.get_ctv_filter() \n
 		Specifies, enables or disables the channel type view filter. If the filter is active, only slots with detected channel
 		type PUSCH or PUCCH are measured. \n
-			:return: channel_type: PUSCh: measure only physical uplink shared channel PUCCh: measure only physical uplink control channel ON: enable the filter OFF: disable the filter
+			:return: channel_type: PUSCh: measure only PUSCH PUCCh: measure only PUCCH ON: enable the filter OFF: disable the filter
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:MEValuation:CTVFilter?')
 		return Conversions.str_to_scalar_enum(response, enums.ChannelTypeVewFilter)
 
 	def set_ctv_filter(self, channel_type: enums.ChannelTypeVewFilter) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:CTVFilter \n
-		Snippet: driver.configure.multiEval.set_ctv_filter(channel_type = enums.ChannelTypeVewFilter.OFF) \n
+		Snippet: driver.configure.lteMeas.multiEval.set_ctv_filter(channel_type = enums.ChannelTypeVewFilter.OFF) \n
 		Specifies, enables or disables the channel type view filter. If the filter is active, only slots with detected channel
 		type PUSCH or PUCCH are measured. \n
-			:param channel_type: PUSCh: measure only physical uplink shared channel PUCCh: measure only physical uplink control channel ON: enable the filter OFF: disable the filter
+			:param channel_type: PUSCh: measure only PUSCH PUCCh: measure only PUCCH ON: enable the filter OFF: disable the filter
 		"""
 		param = Conversions.enum_scalar_to_str(channel_type, enums.ChannelTypeVewFilter)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:CTVFilter {param}')
 
 	def get_dss_pusch(self) -> int:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:DSSPusch \n
-		Snippet: value: int = driver.configure.multiEval.get_dss_pusch() \n
+		Snippet: value: int = driver.configure.lteMeas.multiEval.get_dss_pusch() \n
 		Specifies the delta sequence shift value (ss) used to calculate the sequence shift pattern for PUSCH. \n
 			:return: delta_seq_sh_pusch: No help available
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:MEValuation:DSSPusch?')
 		return Conversions.str_to_int(response)
 
 	def set_dss_pusch(self, delta_seq_sh_pusch: int) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:DSSPusch \n
-		Snippet: driver.configure.multiEval.set_dss_pusch(delta_seq_sh_pusch = 1) \n
+		Snippet: driver.configure.lteMeas.multiEval.set_dss_pusch(delta_seq_sh_pusch = 1) \n
 		Specifies the delta sequence shift value (ss) used to calculate the sequence shift pattern for PUSCH. \n
 			:param delta_seq_sh_pusch: No help available
 		"""
 		param = Conversions.decimal_value_to_str(delta_seq_sh_pusch)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:DSSPusch {param}')
 
 	def get_ghopping(self) -> bool:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:GHOPping \n
-		Snippet: value: bool = driver.configure.multiEval.get_ghopping() \n
+		Snippet: value: bool = driver.configure.lteMeas.multiEval.get_ghopping() \n
 		Specifies whether group hopping is used or not. For Signal Path = Network, the setting is not configurable. \n
 			:return: value: No help available
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:MEValuation:GHOPping?')
 		return Conversions.str_to_bool(response)
 
 	def set_ghopping(self, value: bool) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:GHOPping \n
-		Snippet: driver.configure.multiEval.set_ghopping(value = False) \n
+		Snippet: driver.configure.lteMeas.multiEval.set_ghopping(value = False) \n
 		Specifies whether group hopping is used or not. For Signal Path = Network, the setting is not configurable. \n
 			:param value: No help available
 		"""
 		param = Conversions.bool_to_str(value)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:GHOPping {param}')
 
 	# noinspection PyTypeChecker
-	class MsubFramesStruct(StructBase):
-		"""Structure for reading output parameters. Fields: \n
-			- Sub_Frame_Offset: int: Start of the measured subframe range relative to the trigger event
-			- Sub_Frame_Count: int: Length of the measured subframe range
-			- Meas_Subframe: int: Subframe containing the measured slots for modulation and spectrum results"""
-		__meta_args_list = [
-			ArgStruct.scalar_int('Sub_Frame_Offset'),
-			ArgStruct.scalar_int('Sub_Frame_Count'),
-			ArgStruct.scalar_int('Meas_Subframe')]
-
-		def __init__(self):
-			StructBase.__init__(self, self)
-			self.Sub_Frame_Offset: int = None
-			self.Sub_Frame_Count: int = None
-			self.Meas_Subframe: int = None
-
-	def get_msub_frames(self) -> MsubFramesStruct:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:MSUBframes \n
-		Snippet: value: MsubFramesStruct = driver.configure.multiEval.get_msub_frames() \n
-		Configures the scope of the measurement, i.e. which subframes are measured. \n
-			:return: structure: for return value, see the help for MsubFramesStruct structure arguments.
-		"""
-		return self._core.io.query_struct('CONFigure:LTE:MEASurement<Instance>:MEValuation:MSUBframes?', self.__class__.MsubFramesStruct())
-
-	def set_msub_frames(self, value: MsubFramesStruct) -> None:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:MSUBframes \n
-		Snippet: driver.configure.multiEval.set_msub_frames(value = MsubFramesStruct()) \n
-		Configures the scope of the measurement, i.e. which subframes are measured. \n
-			:param value: see the help for MsubFramesStruct structure arguments.
-		"""
-		self._core.io.write_struct('CONFigure:LTE:MEASurement<Instance>:MEValuation:MSUBframes', value)
-
-	# noinspection PyTypeChecker
 	def get_mslot(self) -> enums.MeasureSlot:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:MSLot \n
-		Snippet: value: enums.MeasureSlot = driver.configure.multiEval.get_mslot() \n
+		Snippet: value: enums.MeasureSlot = driver.configure.lteMeas.multiEval.get_mslot() \n
 		Selects which slots of the Measure Subframe are measured. \n
 			:return: measure_slot: MS0: slot number 0 only MS1: slot number 1 only ALL: both slots
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:MEValuation:MSLot?')
 		return Conversions.str_to_scalar_enum(response, enums.MeasureSlot)
 
 	def set_mslot(self, measure_slot: enums.MeasureSlot) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:MSLot \n
-		Snippet: driver.configure.multiEval.set_mslot(measure_slot = enums.MeasureSlot.ALL) \n
+		Snippet: driver.configure.lteMeas.multiEval.set_mslot(measure_slot = enums.MeasureSlot.ALL) \n
 		Selects which slots of the Measure Subframe are measured. \n
 			:param measure_slot: MS0: slot number 0 only MS1: slot number 1 only ALL: both slots
 		"""
 		param = Conversions.enum_scalar_to_str(measure_slot, enums.MeasureSlot)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:MSLot {param}')
 
 	# noinspection PyTypeChecker
 	def get_view(self) -> enums.ViewMev:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:VIEW \n
-		Snippet: value: enums.ViewMev = driver.configure.multiEval.get_view() \n
+		Snippet: value: enums.ViewMev = driver.configure.lteMeas.multiEval.get_view() \n
 		No command help available \n
 			:return: view: No help available
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:MEValuation:VIEW?')
 		return Conversions.str_to_scalar_enum(response, enums.ViewMev)
 
 	def set_view(self, view: enums.ViewMev) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:VIEW \n
-		Snippet: driver.configure.multiEval.set_view(view = enums.ViewMev.ACLR) \n
+		Snippet: driver.configure.lteMeas.multiEval.set_view(view = enums.ViewMev.ACLR) \n
 		No command help available \n
 			:param view: No help available
 		"""
 		param = Conversions.enum_scalar_to_str(view, enums.ViewMev)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:VIEW {param}')
 
-	def clone(self) -> 'MultiEval':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'MultiEvalCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = MultiEval(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = MultiEvalCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Bler.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Pmonitor/Pcc/StandardDev.py`

 * *Files 21% similar despite different names*

```diff
@@ -1,43 +1,44 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
-from ....Internal.StructBase import StructBase
-from ....Internal.ArgStruct import ArgStruct
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal.StructBase import StructBase
+from ......Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Bler:
-	"""Bler commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class StandardDevCls:
+	"""StandardDev commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("bler", core, parent)
+		self._cmd_group = CommandsGroup("standardDev", core, parent)
 
 	# noinspection PyTypeChecker
-	class SframesStruct(StructBase):
-		"""Structure for reading output parameters. Fields: \n
-			- Sub_Frames: int: No parameter help available
-			- Sched_Subfr_Per_Fr: int: No parameter help available"""
+	class ResultData(StructBase):
+		"""Response structure. Fields: \n
+			- Reliability: int: No parameter help available
+			- Out_Of_Tolerance: int: No parameter help available
+			- Tx_Power: float: No parameter help available"""
 		__meta_args_list = [
-			ArgStruct.scalar_int('Sub_Frames'),
-			ArgStruct.scalar_int('Sched_Subfr_Per_Fr')]
+			ArgStruct.scalar_int('Reliability', 'Reliability'),
+			ArgStruct.scalar_int('Out_Of_Tolerance'),
+			ArgStruct.scalar_float('Tx_Power')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
-			self.Sub_Frames: int = None
-			self.Sched_Subfr_Per_Fr: int = None
-
-	def get_sframes(self) -> SframesStruct:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:BLER:SFRames \n
-		Snippet: value: SframesStruct = driver.configure.multiEval.bler.get_sframes() \n
+			self.Reliability: int = None
+			self.Out_Of_Tolerance: int = None
+			self.Tx_Power: float = None
+
+	def read(self) -> ResultData:
+		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:PMONitor:PCC:SDEViation \n
+		Snippet: value: ResultData = driver.lteMeas.multiEval.pmonitor.pcc.standardDev.read() \n
 		No command help available \n
-			:return: structure: for return value, see the help for SframesStruct structure arguments.
-		"""
-		return self._core.io.query_struct('CONFigure:LTE:MEASurement<Instance>:MEValuation:BLER:SFRames?', self.__class__.SframesStruct())
-
-	def set_sframes(self, value: SframesStruct) -> None:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:BLER:SFRames \n
-		Snippet: driver.configure.multiEval.bler.set_sframes(value = SframesStruct()) \n
+			:return: structure: for return value, see the help for ResultData structure arguments."""
+		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:PMONitor:PCC:SDEViation?', self.__class__.ResultData())
+
+	def fetch(self) -> ResultData:
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:PMONitor:PCC:SDEViation \n
+		Snippet: value: ResultData = driver.lteMeas.multiEval.pmonitor.pcc.standardDev.fetch() \n
 		No command help available \n
-			:param value: see the help for SframesStruct structure arguments.
-		"""
-		self._core.io.write_struct('CONFigure:LTE:MEASurement<Instance>:MEValuation:BLER:SFRames', value)
+			:return: structure: for return value, see the help for ResultData structure arguments."""
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:PMONitor:PCC:SDEViation?', self.__class__.ResultData())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Cc.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Cc/__init__.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,42 +1,42 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
-from ....Internal.RepeatedCapability import RepeatedCapability
-from .... import repcap
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal.RepeatedCapability import RepeatedCapability
+from ...... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Cc:
-	"""Cc commands group definition. 1 total commands, 1 Sub-groups, 0 group commands
+class CcCls:
+	"""Cc commands group definition. 1 total commands, 1 Subgroups, 0 group commands
 	Repeated Capability: CarrierComponent, default value after init: CarrierComponent.Nr1"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("cc", core, parent)
-		self._base.rep_cap = RepeatedCapability(self._base.group_name, 'repcap_carrierComponent_get', 'repcap_carrierComponent_set', repcap.CarrierComponent.Nr1)
+		self._cmd_group = CommandsGroup("cc", core, parent)
+		self._cmd_group.rep_cap = RepeatedCapability(self._cmd_group.group_name, 'repcap_carrierComponent_get', 'repcap_carrierComponent_set', repcap.CarrierComponent.Nr1)
 
-	def repcap_carrierComponent_set(self, enum_value: repcap.CarrierComponent) -> None:
+	def repcap_carrierComponent_set(self, carrierComponent: repcap.CarrierComponent) -> None:
 		"""Repeated Capability default value numeric suffix.
 		This value is used, if you do not explicitely set it in the child set/get methods, or if you leave it to CarrierComponent.Default
 		Default value after init: CarrierComponent.Nr1"""
-		self._base.set_repcap_enum_value(enum_value)
+		self._cmd_group.set_repcap_enum_value(carrierComponent)
 
 	def repcap_carrierComponent_get(self) -> repcap.CarrierComponent:
 		"""Returns the current default repeated capability for the child set/get methods"""
 		# noinspection PyTypeChecker
-		return self._base.get_repcap_enum_value()
+		return self._cmd_group.get_repcap_enum_value()
 
 	@property
 	def plcId(self):
 		"""plcId commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_plcId'):
-			from .Cc_.PlcId import PlcId
-			self._plcId = PlcId(self._core, self._base)
+			from .PlcId import PlcIdCls
+			self._plcId = PlcIdCls(self._core, self._cmd_group)
 		return self._plcId
 
-	def clone(self) -> 'Cc':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'CcCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Cc(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = CcCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Cc_/PlcId.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Cc/PlcId.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,35 +1,36 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
-from .....Internal import Conversions
-from ..... import repcap
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal import Conversions
+from ...... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class PlcId:
-	"""PlcId commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class PlcIdCls:
+	"""PlcId commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("plcId", core, parent)
+		self._cmd_group = CommandsGroup("plcId", core, parent)
 
 	def set(self, phs_layer_cell_id: int, carrierComponent=repcap.CarrierComponent.Default) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:CC<Nr>:PLCid \n
-		Snippet: driver.configure.multiEval.cc.plcId.set(phs_layer_cell_id = 1, carrierComponent = repcap.CarrierComponent.Default) \n
+		Snippet: driver.configure.lteMeas.multiEval.cc.plcId.set(phs_layer_cell_id = 1, carrierComponent = repcap.CarrierComponent.Default) \n
 		Specifies the physical layer cell ID of component carrier CC<no>. Without carrier aggregation, you can omit <no>.
 		For Signal Path = Network, use [CONFigure:]SIGNaling:LTE:CELL:PCID. \n
 			:param phs_layer_cell_id: No help available
-			:param carrierComponent: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Cc')"""
+			:param carrierComponent: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Cc')
+		"""
 		param = Conversions.decimal_value_to_str(phs_layer_cell_id)
-		carrierComponent_cmd_val = self._base.get_repcap_cmd_value(carrierComponent, repcap.CarrierComponent)
+		carrierComponent_cmd_val = self._cmd_group.get_repcap_cmd_value(carrierComponent, repcap.CarrierComponent)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:CC{carrierComponent_cmd_val}:PLCid {param}')
 
 	def get(self, carrierComponent=repcap.CarrierComponent.Default) -> int:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:CC<Nr>:PLCid \n
-		Snippet: value: int = driver.configure.multiEval.cc.plcId.get(carrierComponent = repcap.CarrierComponent.Default) \n
+		Snippet: value: int = driver.configure.lteMeas.multiEval.cc.plcId.get(carrierComponent = repcap.CarrierComponent.Default) \n
 		Specifies the physical layer cell ID of component carrier CC<no>. Without carrier aggregation, you can omit <no>.
 		For Signal Path = Network, use [CONFigure:]SIGNaling:LTE:CELL:PCID. \n
 			:param carrierComponent: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Cc')
 			:return: phs_layer_cell_id: No help available"""
-		carrierComponent_cmd_val = self._base.get_repcap_cmd_value(carrierComponent, repcap.CarrierComponent)
+		carrierComponent_cmd_val = self._cmd_group.get_repcap_cmd_value(carrierComponent, repcap.CarrierComponent)
 		response = self._core.io.query_str(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:CC{carrierComponent_cmd_val}:PLCid?')
 		return Conversions.str_to_int(response)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Limit.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Limit/__init__.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,59 +1,59 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Limit:
-	"""Limit commands group definition. 40 total commands, 5 Sub-groups, 0 group commands"""
+class LimitCls:
+	"""Limit commands group definition. 40 total commands, 5 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("limit", core, parent)
+		self._cmd_group = CommandsGroup("limit", core, parent)
 
 	@property
 	def qpsk(self):
-		"""qpsk commands group. 1 Sub-classes, 7 commands."""
+		"""qpsk commands group. 5 Sub-classes, 3 commands."""
 		if not hasattr(self, '_qpsk'):
-			from .Limit_.Qpsk import Qpsk
-			self._qpsk = Qpsk(self._core, self._base)
+			from .Qpsk import QpskCls
+			self._qpsk = QpskCls(self._core, self._cmd_group)
 		return self._qpsk
 
 	@property
 	def qam(self):
 		"""qam commands group. 8 Sub-classes, 0 commands."""
 		if not hasattr(self, '_qam'):
-			from .Limit_.Qam import Qam
-			self._qam = Qam(self._core, self._base)
+			from .Qam import QamCls
+			self._qam = QamCls(self._core, self._cmd_group)
 		return self._qam
 
 	@property
 	def seMask(self):
 		"""seMask commands group. 3 Sub-classes, 0 commands."""
 		if not hasattr(self, '_seMask'):
-			from .Limit_.SeMask import SeMask
-			self._seMask = SeMask(self._core, self._base)
+			from .SeMask import SeMaskCls
+			self._seMask = SeMaskCls(self._core, self._cmd_group)
 		return self._seMask
 
 	@property
 	def aclr(self):
 		"""aclr commands group. 2 Sub-classes, 0 commands."""
 		if not hasattr(self, '_aclr'):
-			from .Limit_.Aclr import Aclr
-			self._aclr = Aclr(self._core, self._base)
+			from .Aclr import AclrCls
+			self._aclr = AclrCls(self._core, self._cmd_group)
 		return self._aclr
 
 	@property
 	def pdynamics(self):
 		"""pdynamics commands group. 1 Sub-classes, 0 commands."""
 		if not hasattr(self, '_pdynamics'):
-			from .Limit_.Pdynamics import Pdynamics
-			self._pdynamics = Pdynamics(self._core, self._base)
+			from .Pdynamics import PdynamicsCls
+			self._pdynamics = PdynamicsCls(self._core, self._cmd_group)
 		return self._pdynamics
 
-	def clone(self) -> 'Limit':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'LimitCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Limit(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = LimitCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Limit_/Aclr.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Limit/Aclr/__init__.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,35 +1,35 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Aclr:
-	"""Aclr commands group definition. 8 total commands, 2 Sub-groups, 0 group commands"""
+class AclrCls:
+	"""Aclr commands group definition. 8 total commands, 2 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("aclr", core, parent)
+		self._cmd_group = CommandsGroup("aclr", core, parent)
 
 	@property
 	def utra(self):
 		"""utra commands group. 2 Sub-classes, 0 commands."""
 		if not hasattr(self, '_utra'):
-			from .Aclr_.Utra import Utra
-			self._utra = Utra(self._core, self._base)
+			from .Utra import UtraCls
+			self._utra = UtraCls(self._core, self._cmd_group)
 		return self._utra
 
 	@property
 	def eutra(self):
 		"""eutra commands group. 2 Sub-classes, 0 commands."""
 		if not hasattr(self, '_eutra'):
-			from .Aclr_.Eutra import Eutra
-			self._eutra = Eutra(self._core, self._base)
+			from .Eutra import EutraCls
+			self._eutra = EutraCls(self._core, self._cmd_group)
 		return self._eutra
 
-	def clone(self) -> 'Aclr':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'AclrCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Aclr(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = AclrCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Limit_/Aclr_/Eutra.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Limit/SeMask/ObwLimit/__init__.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,35 +1,35 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
+from ........Internal.Core import Core
+from ........Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Eutra:
-	"""Eutra commands group definition. 4 total commands, 2 Sub-groups, 0 group commands"""
+class ObwLimitCls:
+	"""ObwLimit commands group definition. 4 total commands, 2 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("eutra", core, parent)
+		self._cmd_group = CommandsGroup("obwLimit", core, parent)
 
 	@property
 	def channelBw(self):
 		"""channelBw commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_channelBw'):
-			from .Eutra_.ChannelBw import ChannelBw
-			self._channelBw = ChannelBw(self._core, self._base)
+			from .ChannelBw import ChannelBwCls
+			self._channelBw = ChannelBwCls(self._core, self._cmd_group)
 		return self._channelBw
 
 	@property
 	def carrierAggregation(self):
 		"""carrierAggregation commands group. 1 Sub-classes, 1 commands."""
 		if not hasattr(self, '_carrierAggregation'):
-			from .Eutra_.CarrierAggregation import CarrierAggregation
-			self._carrierAggregation = CarrierAggregation(self._core, self._base)
+			from .CarrierAggregation import CarrierAggregationCls
+			self._carrierAggregation = CarrierAggregationCls(self._core, self._cmd_group)
 		return self._carrierAggregation
 
-	def clone(self) -> 'Eutra':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'ObwLimitCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Eutra(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = ObwLimitCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Limit_/Aclr_/Eutra_/CarrierAggregation.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Limit/SeMask/ObwLimit/CarrierAggregation/__init__.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,61 +1,48 @@
-from .......Internal.Core import Core
-from .......Internal.CommandsGroup import CommandsGroup
-from .......Internal.StructBase import StructBase
-from .......Internal.ArgStruct import ArgStruct
+from .........Internal.Core import Core
+from .........Internal.CommandsGroup import CommandsGroup
+from .........Internal import Conversions
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class CarrierAggregation:
-	"""CarrierAggregation commands group definition. 3 total commands, 1 Sub-groups, 1 group commands"""
+class CarrierAggregationCls:
+	"""CarrierAggregation commands group definition. 3 total commands, 1 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("carrierAggregation", core, parent)
+		self._cmd_group = CommandsGroup("carrierAggregation", core, parent)
 
 	@property
 	def channelBw1st(self):
 		"""channelBw1st commands group. 1 Sub-classes, 0 commands."""
 		if not hasattr(self, '_channelBw1st'):
-			from .CarrierAggregation_.ChannelBw1st import ChannelBw1st
-			self._channelBw1st = ChannelBw1st(self._core, self._base)
+			from .ChannelBw1st import ChannelBw1stCls
+			self._channelBw1st = ChannelBw1stCls(self._core, self._cmd_group)
 		return self._channelBw1st
 
-	# noinspection PyTypeChecker
-	class OcombinationStruct(StructBase):
-		"""Structure for reading output parameters. Fields: \n
-			- Relative_Level: float or bool: No parameter help available
-			- Absolute_Level: float or bool: No parameter help available"""
-		__meta_args_list = [
-			ArgStruct.scalar_float_ext('Relative_Level'),
-			ArgStruct.scalar_float_ext('Absolute_Level')]
-
-		def __init__(self):
-			StructBase.__init__(self, self)
-			self.Relative_Level: float or bool = None
-			self.Absolute_Level: float or bool = None
-
-	def get_ocombination(self) -> OcombinationStruct:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:ACLR:EUTRa:CAGGregation:OCOMbination \n
-		Snippet: value: OcombinationStruct = driver.configure.multiEval.limit.aclr.eutra.carrierAggregation.get_ocombination() \n
-		Defines relative and absolute limits for the ACLR measured in an adjacent E-UTRA channel. The settings apply to all
-		'other' channel bandwidth combinations, not covered by other commands in this chapter. \n
-			:return: structure: for return value, see the help for OcombinationStruct structure arguments.
+	def get_ocombination(self) -> float or bool:
+		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:SEMask:OBWLimit:CAGGregation:OCOMbination \n
+		Snippet: value: float or bool = driver.configure.lteMeas.multiEval.limit.seMask.obwLimit.carrierAggregation.get_ocombination() \n
+		Defines an upper limit for the occupied bandwidth. The setting applies to all 'other' channel bandwidth combinations, not
+		covered by other commands in this chapter. \n
+			:return: obw_limit: (float or boolean) No help available
 		"""
-		return self._core.io.query_struct('CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:ACLR:EUTRa:CAGGregation:OCOMbination?', self.__class__.OcombinationStruct())
+		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:SEMask:OBWLimit:CAGGregation:OCOMbination?')
+		return Conversions.str_to_float_or_bool(response)
 
-	def set_ocombination(self, value: OcombinationStruct) -> None:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:ACLR:EUTRa:CAGGregation:OCOMbination \n
-		Snippet: driver.configure.multiEval.limit.aclr.eutra.carrierAggregation.set_ocombination(value = OcombinationStruct()) \n
-		Defines relative and absolute limits for the ACLR measured in an adjacent E-UTRA channel. The settings apply to all
-		'other' channel bandwidth combinations, not covered by other commands in this chapter. \n
-			:param value: see the help for OcombinationStruct structure arguments.
+	def set_ocombination(self, obw_limit: float or bool) -> None:
+		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:SEMask:OBWLimit:CAGGregation:OCOMbination \n
+		Snippet: driver.configure.lteMeas.multiEval.limit.seMask.obwLimit.carrierAggregation.set_ocombination(obw_limit = 1.0) \n
+		Defines an upper limit for the occupied bandwidth. The setting applies to all 'other' channel bandwidth combinations, not
+		covered by other commands in this chapter. \n
+			:param obw_limit: (float or boolean) No help available
 		"""
-		self._core.io.write_struct('CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:ACLR:EUTRa:CAGGregation:OCOMbination', value)
+		param = Conversions.decimal_or_bool_value_to_str(obw_limit)
+		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:SEMask:OBWLimit:CAGGregation:OCOMbination {param}')
 
-	def clone(self) -> 'CarrierAggregation':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'CarrierAggregationCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = CarrierAggregation(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = CarrierAggregationCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Limit_/Aclr_/Eutra_/CarrierAggregation_/ChannelBw1st.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Limit/SeMask/Limit/Additional/CarrierAggregation/ChannelBw1st/__init__.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,42 +1,42 @@
-from ........Internal.Core import Core
-from ........Internal.CommandsGroup import CommandsGroup
-from ........Internal.RepeatedCapability import RepeatedCapability
-from ........ import repcap
+from ...........Internal.Core import Core
+from ...........Internal.CommandsGroup import CommandsGroup
+from ...........Internal.RepeatedCapability import RepeatedCapability
+from ........... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class ChannelBw1st:
-	"""ChannelBw1st commands group definition. 2 total commands, 1 Sub-groups, 0 group commands
+class ChannelBw1stCls:
+	"""ChannelBw1st commands group definition. 1 total commands, 1 Subgroups, 0 group commands
 	Repeated Capability: FirstChannelBw, default value after init: FirstChannelBw.Bw100"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("channelBw1st", core, parent)
-		self._base.rep_cap = RepeatedCapability(self._base.group_name, 'repcap_firstChannelBw_get', 'repcap_firstChannelBw_set', repcap.FirstChannelBw.Bw100)
+		self._cmd_group = CommandsGroup("channelBw1st", core, parent)
+		self._cmd_group.rep_cap = RepeatedCapability(self._cmd_group.group_name, 'repcap_firstChannelBw_get', 'repcap_firstChannelBw_set', repcap.FirstChannelBw.Bw100)
 
-	def repcap_firstChannelBw_set(self, enum_value: repcap.FirstChannelBw) -> None:
+	def repcap_firstChannelBw_set(self, firstChannelBw: repcap.FirstChannelBw) -> None:
 		"""Repeated Capability default value numeric suffix.
 		This value is used, if you do not explicitely set it in the child set/get methods, or if you leave it to FirstChannelBw.Default
 		Default value after init: FirstChannelBw.Bw100"""
-		self._base.set_repcap_enum_value(enum_value)
+		self._cmd_group.set_repcap_enum_value(firstChannelBw)
 
 	def repcap_firstChannelBw_get(self) -> repcap.FirstChannelBw:
 		"""Returns the current default repeated capability for the child set/get methods"""
 		# noinspection PyTypeChecker
-		return self._base.get_repcap_enum_value()
+		return self._cmd_group.get_repcap_enum_value()
 
 	@property
 	def channelBw2nd(self):
-		"""channelBw2nd commands group. 1 Sub-classes, 1 commands."""
+		"""channelBw2nd commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_channelBw2nd'):
-			from .ChannelBw1st_.ChannelBw2nd import ChannelBw2nd
-			self._channelBw2nd = ChannelBw2nd(self._core, self._base)
+			from .ChannelBw2nd import ChannelBw2ndCls
+			self._channelBw2nd = ChannelBw2ndCls(self._core, self._cmd_group)
 		return self._channelBw2nd
 
-	def clone(self) -> 'ChannelBw1st':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'ChannelBw1stCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = ChannelBw1st(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = ChannelBw1stCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Limit_/Aclr_/Eutra_/CarrierAggregation_/ChannelBw1st_/ChannelBw2nd.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Limit/Aclr/Eutra/CarrierAggregation/ChannelBw1st/ChannelBw2nd/__init__.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,84 +1,90 @@
-from .........Internal.Core import Core
-from .........Internal.CommandsGroup import CommandsGroup
-from .........Internal.StructBase import StructBase
-from .........Internal.ArgStruct import ArgStruct
-from .........Internal.RepeatedCapability import RepeatedCapability
-from ......... import repcap
+from ...........Internal.Core import Core
+from ...........Internal.CommandsGroup import CommandsGroup
+from ...........Internal.Types import DataType
+from ...........Internal.StructBase import StructBase
+from ...........Internal.ArgStruct import ArgStruct
+from ...........Internal.ArgSingleList import ArgSingleList
+from ...........Internal.ArgSingle import ArgSingle
+from ...........Internal.RepeatedCapability import RepeatedCapability
+from ........... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class ChannelBw2nd:
-	"""ChannelBw2nd commands group definition. 2 total commands, 1 Sub-groups, 1 group commands
+class ChannelBw2ndCls:
+	"""ChannelBw2nd commands group definition. 2 total commands, 1 Subgroups, 1 group commands
 	Repeated Capability: SecondChannelBw, default value after init: SecondChannelBw.Bw50"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("channelBw2nd", core, parent)
-		self._base.rep_cap = RepeatedCapability(self._base.group_name, 'repcap_secondChannelBw_get', 'repcap_secondChannelBw_set', repcap.SecondChannelBw.Bw50)
+		self._cmd_group = CommandsGroup("channelBw2nd", core, parent)
+		self._cmd_group.rep_cap = RepeatedCapability(self._cmd_group.group_name, 'repcap_secondChannelBw_get', 'repcap_secondChannelBw_set', repcap.SecondChannelBw.Bw50)
 
-	def repcap_secondChannelBw_set(self, enum_value: repcap.SecondChannelBw) -> None:
+	def repcap_secondChannelBw_set(self, secondChannelBw: repcap.SecondChannelBw) -> None:
 		"""Repeated Capability default value numeric suffix.
 		This value is used, if you do not explicitely set it in the child set/get methods, or if you leave it to SecondChannelBw.Default
 		Default value after init: SecondChannelBw.Bw50"""
-		self._base.set_repcap_enum_value(enum_value)
+		self._cmd_group.set_repcap_enum_value(secondChannelBw)
 
 	def repcap_secondChannelBw_get(self) -> repcap.SecondChannelBw:
 		"""Returns the current default repeated capability for the child set/get methods"""
 		# noinspection PyTypeChecker
-		return self._base.get_repcap_enum_value()
+		return self._cmd_group.get_repcap_enum_value()
 
 	@property
 	def channelBw3rd(self):
 		"""channelBw3rd commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_channelBw3rd'):
-			from .ChannelBw2nd_.ChannelBw3rd import ChannelBw3rd
-			self._channelBw3rd = ChannelBw3rd(self._core, self._base)
+			from .ChannelBw3rd import ChannelBw3rdCls
+			self._channelBw3rd = ChannelBw3rdCls(self._core, self._cmd_group)
 		return self._channelBw3rd
 
+	def set(self, relative_level: float or bool, absolute_level: float or bool, firstChannelBw=repcap.FirstChannelBw.Default, secondChannelBw=repcap.SecondChannelBw.Default) -> None:
+		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:ACLR:EUTRa:CAGGregation:CBANdwidth<Band1>:CBANdwidth<Band2> \n
+		Snippet: driver.configure.lteMeas.multiEval.limit.aclr.eutra.carrierAggregation.channelBw1st.channelBw2nd.set(relative_level = 1.0, absolute_level = 1.0, firstChannelBw = repcap.FirstChannelBw.Default, secondChannelBw = repcap.SecondChannelBw.Default) \n
+		Defines relative and absolute limits for the ACLR measured in an adjacent E-UTRA channel. The settings are defined
+		separately for each channel bandwidth combination, for two aggregated carriers. The following bandwidth combinations are
+		supported: Example: For the first line in the figure, use ...:CBANdwidth100:CBANdwidth50. \n
+			:param relative_level: (float or boolean) No help available
+			:param absolute_level: (float or boolean) No help available
+			:param firstChannelBw: optional repeated capability selector. Default value: Bw100 (settable in the interface 'ChannelBw1st')
+			:param secondChannelBw: optional repeated capability selector. Default value: Bw50 (settable in the interface 'ChannelBw2nd')
+		"""
+		param = ArgSingleList().compose_cmd_string(ArgSingle('relative_level', relative_level, DataType.FloatExt), ArgSingle('absolute_level', absolute_level, DataType.FloatExt))
+		firstChannelBw_cmd_val = self._cmd_group.get_repcap_cmd_value(firstChannelBw, repcap.FirstChannelBw)
+		secondChannelBw_cmd_val = self._cmd_group.get_repcap_cmd_value(secondChannelBw, repcap.SecondChannelBw)
+		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:ACLR:EUTRa:CAGGregation:CBANdwidth{firstChannelBw_cmd_val}:CBANdwidth{secondChannelBw_cmd_val} {param}'.rstrip())
+
 	# noinspection PyTypeChecker
 	class ChannelBw2ndStruct(StructBase):
-		"""Structure for setting input parameters. Fields: \n
+		"""Response structure. Fields: \n
 			- Relative_Level: float or bool: No parameter help available
 			- Absolute_Level: float or bool: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_float_ext('Relative_Level'),
 			ArgStruct.scalar_float_ext('Absolute_Level')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Relative_Level: float or bool = None
 			self.Absolute_Level: float or bool = None
 
-	def set(self, structure: ChannelBw2ndStruct, firstChannelBw=repcap.FirstChannelBw.Default, secondChannelBw=repcap.SecondChannelBw.Default) -> None:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:ACLR:EUTRa:CAGGregation:CBANdwidth<Band1>:CBANdwidth<Band2> \n
-		Snippet: driver.configure.multiEval.limit.aclr.eutra.carrierAggregation.channelBw1st.channelBw2nd.set(value = [PROPERTY_STRUCT_NAME](), firstChannelBw = repcap.FirstChannelBw.Default, secondChannelBw = repcap.SecondChannelBw.Default) \n
-		Defines relative and absolute limits for the ACLR measured in an adjacent E-UTRA channel. The settings are defined
-		separately for each channel bandwidth combination, for two aggregated carriers. The following bandwidth combinations are
-		supported: Example: For the first line in the figure, use ...:CBANdwidth100:CBANdwidth50. \n
-			:param structure: for set value, see the help for ChannelBw2ndStruct structure arguments.
-			:param firstChannelBw: optional repeated capability selector. Default value: Bw100 (settable in the interface 'ChannelBw1st')
-			:param secondChannelBw: optional repeated capability selector. Default value: Bw50 (settable in the interface 'ChannelBw2nd')"""
-		firstChannelBw_cmd_val = self._base.get_repcap_cmd_value(firstChannelBw, repcap.FirstChannelBw)
-		secondChannelBw_cmd_val = self._base.get_repcap_cmd_value(secondChannelBw, repcap.SecondChannelBw)
-		self._core.io.write_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:ACLR:EUTRa:CAGGregation:CBANdwidth{firstChannelBw_cmd_val}:CBANdwidth{secondChannelBw_cmd_val}', structure)
-
 	def get(self, firstChannelBw=repcap.FirstChannelBw.Default, secondChannelBw=repcap.SecondChannelBw.Default) -> ChannelBw2ndStruct:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:ACLR:EUTRa:CAGGregation:CBANdwidth<Band1>:CBANdwidth<Band2> \n
-		Snippet: value: ChannelBw2ndStruct = driver.configure.multiEval.limit.aclr.eutra.carrierAggregation.channelBw1st.channelBw2nd.get(firstChannelBw = repcap.FirstChannelBw.Default, secondChannelBw = repcap.SecondChannelBw.Default) \n
+		Snippet: value: ChannelBw2ndStruct = driver.configure.lteMeas.multiEval.limit.aclr.eutra.carrierAggregation.channelBw1st.channelBw2nd.get(firstChannelBw = repcap.FirstChannelBw.Default, secondChannelBw = repcap.SecondChannelBw.Default) \n
 		Defines relative and absolute limits for the ACLR measured in an adjacent E-UTRA channel. The settings are defined
 		separately for each channel bandwidth combination, for two aggregated carriers. The following bandwidth combinations are
 		supported: Example: For the first line in the figure, use ...:CBANdwidth100:CBANdwidth50. \n
 			:param firstChannelBw: optional repeated capability selector. Default value: Bw100 (settable in the interface 'ChannelBw1st')
 			:param secondChannelBw: optional repeated capability selector. Default value: Bw50 (settable in the interface 'ChannelBw2nd')
 			:return: structure: for return value, see the help for ChannelBw2ndStruct structure arguments."""
-		firstChannelBw_cmd_val = self._base.get_repcap_cmd_value(firstChannelBw, repcap.FirstChannelBw)
-		secondChannelBw_cmd_val = self._base.get_repcap_cmd_value(secondChannelBw, repcap.SecondChannelBw)
+		firstChannelBw_cmd_val = self._cmd_group.get_repcap_cmd_value(firstChannelBw, repcap.FirstChannelBw)
+		secondChannelBw_cmd_val = self._cmd_group.get_repcap_cmd_value(secondChannelBw, repcap.SecondChannelBw)
 		return self._core.io.query_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:ACLR:EUTRa:CAGGregation:CBANdwidth{firstChannelBw_cmd_val}:CBANdwidth{secondChannelBw_cmd_val}?', self.__class__.ChannelBw2ndStruct())
 
-	def clone(self) -> 'ChannelBw2nd':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'ChannelBw2ndCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = ChannelBw2nd(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = ChannelBw2ndCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Limit_/Aclr_/Eutra_/CarrierAggregation_/ChannelBw1st_/ChannelBw2nd_/ChannelBw3rd.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Limit/Aclr/Utra/CarrierAggregation/ChannelBw1st/ChannelBw2nd/__init__.py`

 * *Files 11% similar despite different names*

```diff
@@ -1,80 +1,96 @@
-from ..........Internal.Core import Core
-from ..........Internal.CommandsGroup import CommandsGroup
-from ..........Internal.StructBase import StructBase
-from ..........Internal.ArgStruct import ArgStruct
-from ..........Internal.RepeatedCapability import RepeatedCapability
-from .......... import repcap
+from ...........Internal.Core import Core
+from ...........Internal.CommandsGroup import CommandsGroup
+from ...........Internal.Types import DataType
+from ...........Internal.StructBase import StructBase
+from ...........Internal.ArgStruct import ArgStruct
+from ...........Internal.ArgSingleList import ArgSingleList
+from ...........Internal.ArgSingle import ArgSingle
+from ...........Internal.RepeatedCapability import RepeatedCapability
+from ........... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class ChannelBw3rd:
-	"""ChannelBw3rd commands group definition. 1 total commands, 0 Sub-groups, 1 group commands
-	Repeated Capability: ThirdChannelBw, default value after init: ThirdChannelBw.Bw100"""
+class ChannelBw2ndCls:
+	"""ChannelBw2nd commands group definition. 2 total commands, 1 Subgroups, 1 group commands
+	Repeated Capability: SecondChannelBw, default value after init: SecondChannelBw.Bw50"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("channelBw3rd", core, parent)
-		self._base.rep_cap = RepeatedCapability(self._base.group_name, 'repcap_thirdChannelBw_get', 'repcap_thirdChannelBw_set', repcap.ThirdChannelBw.Bw100)
+		self._cmd_group = CommandsGroup("channelBw2nd", core, parent)
+		self._cmd_group.rep_cap = RepeatedCapability(self._cmd_group.group_name, 'repcap_secondChannelBw_get', 'repcap_secondChannelBw_set', repcap.SecondChannelBw.Bw50)
 
-	def repcap_thirdChannelBw_set(self, enum_value: repcap.ThirdChannelBw) -> None:
+	def repcap_secondChannelBw_set(self, secondChannelBw: repcap.SecondChannelBw) -> None:
 		"""Repeated Capability default value numeric suffix.
-		This value is used, if you do not explicitely set it in the child set/get methods, or if you leave it to ThirdChannelBw.Default
-		Default value after init: ThirdChannelBw.Bw100"""
-		self._base.set_repcap_enum_value(enum_value)
+		This value is used, if you do not explicitely set it in the child set/get methods, or if you leave it to SecondChannelBw.Default
+		Default value after init: SecondChannelBw.Bw50"""
+		self._cmd_group.set_repcap_enum_value(secondChannelBw)
 
-	def repcap_thirdChannelBw_get(self) -> repcap.ThirdChannelBw:
+	def repcap_secondChannelBw_get(self) -> repcap.SecondChannelBw:
 		"""Returns the current default repeated capability for the child set/get methods"""
 		# noinspection PyTypeChecker
-		return self._base.get_repcap_enum_value()
+		return self._cmd_group.get_repcap_enum_value()
+
+	@property
+	def channelBw3rd(self):
+		"""channelBw3rd commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_channelBw3rd'):
+			from .ChannelBw3rd import ChannelBw3rdCls
+			self._channelBw3rd = ChannelBw3rdCls(self._core, self._cmd_group)
+		return self._channelBw3rd
+
+	def set(self, relative_level: float or bool, absolute_level: float or bool, utraAdjChannel=repcap.UtraAdjChannel.Default, firstChannelBw=repcap.FirstChannelBw.Default, secondChannelBw=repcap.SecondChannelBw.Default) -> None:
+		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:ACLR:UTRA<nr>:CAGGregation:CBANdwidth<Band1>:CBANdwidth<Band2> \n
+		Snippet: driver.configure.lteMeas.multiEval.limit.aclr.utra.carrierAggregation.channelBw1st.channelBw2nd.set(relative_level = 1.0, absolute_level = 1.0, utraAdjChannel = repcap.UtraAdjChannel.Default, firstChannelBw = repcap.FirstChannelBw.Default, secondChannelBw = repcap.SecondChannelBw.Default) \n
+		Defines relative and absolute limits for the ACLR measured in the first or second adjacent UTRA channel, depending on
+		<no>. The settings are defined separately for each channel bandwidth combination, for two aggregated carriers.
+		The following bandwidth combinations are supported: Example: For the first line in the figure, use ...
+		:CBANdwidth100:CBANdwidth50. \n
+			:param relative_level: (float or boolean) No help available
+			:param absolute_level: (float or boolean) No help available
+			:param utraAdjChannel: optional repeated capability selector. Default value: Ch1 (settable in the interface 'Utra')
+			:param firstChannelBw: optional repeated capability selector. Default value: Bw100 (settable in the interface 'ChannelBw1st')
+			:param secondChannelBw: optional repeated capability selector. Default value: Bw50 (settable in the interface 'ChannelBw2nd')
+		"""
+		param = ArgSingleList().compose_cmd_string(ArgSingle('relative_level', relative_level, DataType.FloatExt), ArgSingle('absolute_level', absolute_level, DataType.FloatExt))
+		utraAdjChannel_cmd_val = self._cmd_group.get_repcap_cmd_value(utraAdjChannel, repcap.UtraAdjChannel)
+		firstChannelBw_cmd_val = self._cmd_group.get_repcap_cmd_value(firstChannelBw, repcap.FirstChannelBw)
+		secondChannelBw_cmd_val = self._cmd_group.get_repcap_cmd_value(secondChannelBw, repcap.SecondChannelBw)
+		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:ACLR:UTRA{utraAdjChannel_cmd_val}:CAGGregation:CBANdwidth{firstChannelBw_cmd_val}:CBANdwidth{secondChannelBw_cmd_val} {param}'.rstrip())
 
 	# noinspection PyTypeChecker
-	class ChannelBw3rdStruct(StructBase):
-		"""Structure for setting input parameters. Fields: \n
+	class ChannelBw2ndStruct(StructBase):
+		"""Response structure. Fields: \n
 			- Relative_Level: float or bool: No parameter help available
 			- Absolute_Level: float or bool: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_float_ext('Relative_Level'),
 			ArgStruct.scalar_float_ext('Absolute_Level')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Relative_Level: float or bool = None
 			self.Absolute_Level: float or bool = None
 
-	def set(self, structure: ChannelBw3rdStruct, firstChannelBw=repcap.FirstChannelBw.Default, secondChannelBw=repcap.SecondChannelBw.Default, thirdChannelBw=repcap.ThirdChannelBw.Default) -> None:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:ACLR:EUTRa:CAGGregation:CBANdwidth<Band1>:CBANdwidth<Band2>:CBANdwidth<Band3> \n
-		Snippet: driver.configure.multiEval.limit.aclr.eutra.carrierAggregation.channelBw1st.channelBw2nd.channelBw3rd.set(value = [PROPERTY_STRUCT_NAME](), firstChannelBw = repcap.FirstChannelBw.Default, secondChannelBw = repcap.SecondChannelBw.Default, thirdChannelBw = repcap.ThirdChannelBw.Default) \n
-		Defines relative and absolute limits for the ACLR measured in an adjacent E-UTRA channel. The settings are defined
-		separately for each channel bandwidth combination, for three aggregated carriers. The following bandwidth combinations
-		are supported: Example: For the first line in the figure, use ...:CBANdwidth200:CBANdwidth150:CBANdwidth100. \n
-			:param structure: for set value, see the help for ChannelBw3rdStruct structure arguments.
-			:param firstChannelBw: optional repeated capability selector. Default value: Bw100 (settable in the interface 'ChannelBw1st')
-			:param secondChannelBw: optional repeated capability selector. Default value: Bw50 (settable in the interface 'ChannelBw2nd')
-			:param thirdChannelBw: optional repeated capability selector. Default value: Bw100 (settable in the interface 'ChannelBw3rd')"""
-		firstChannelBw_cmd_val = self._base.get_repcap_cmd_value(firstChannelBw, repcap.FirstChannelBw)
-		secondChannelBw_cmd_val = self._base.get_repcap_cmd_value(secondChannelBw, repcap.SecondChannelBw)
-		thirdChannelBw_cmd_val = self._base.get_repcap_cmd_value(thirdChannelBw, repcap.ThirdChannelBw)
-		self._core.io.write_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:ACLR:EUTRa:CAGGregation:CBANdwidth{firstChannelBw_cmd_val}:CBANdwidth{secondChannelBw_cmd_val}:CBANdwidth{thirdChannelBw_cmd_val}', structure)
-
-	def get(self, firstChannelBw=repcap.FirstChannelBw.Default, secondChannelBw=repcap.SecondChannelBw.Default, thirdChannelBw=repcap.ThirdChannelBw.Default) -> ChannelBw3rdStruct:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:ACLR:EUTRa:CAGGregation:CBANdwidth<Band1>:CBANdwidth<Band2>:CBANdwidth<Band3> \n
-		Snippet: value: ChannelBw3rdStruct = driver.configure.multiEval.limit.aclr.eutra.carrierAggregation.channelBw1st.channelBw2nd.channelBw3rd.get(firstChannelBw = repcap.FirstChannelBw.Default, secondChannelBw = repcap.SecondChannelBw.Default, thirdChannelBw = repcap.ThirdChannelBw.Default) \n
-		Defines relative and absolute limits for the ACLR measured in an adjacent E-UTRA channel. The settings are defined
-		separately for each channel bandwidth combination, for three aggregated carriers. The following bandwidth combinations
-		are supported: Example: For the first line in the figure, use ...:CBANdwidth200:CBANdwidth150:CBANdwidth100. \n
+	def get(self, utraAdjChannel=repcap.UtraAdjChannel.Default, firstChannelBw=repcap.FirstChannelBw.Default, secondChannelBw=repcap.SecondChannelBw.Default) -> ChannelBw2ndStruct:
+		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:ACLR:UTRA<nr>:CAGGregation:CBANdwidth<Band1>:CBANdwidth<Band2> \n
+		Snippet: value: ChannelBw2ndStruct = driver.configure.lteMeas.multiEval.limit.aclr.utra.carrierAggregation.channelBw1st.channelBw2nd.get(utraAdjChannel = repcap.UtraAdjChannel.Default, firstChannelBw = repcap.FirstChannelBw.Default, secondChannelBw = repcap.SecondChannelBw.Default) \n
+		Defines relative and absolute limits for the ACLR measured in the first or second adjacent UTRA channel, depending on
+		<no>. The settings are defined separately for each channel bandwidth combination, for two aggregated carriers.
+		The following bandwidth combinations are supported: Example: For the first line in the figure, use ...
+		:CBANdwidth100:CBANdwidth50. \n
+			:param utraAdjChannel: optional repeated capability selector. Default value: Ch1 (settable in the interface 'Utra')
 			:param firstChannelBw: optional repeated capability selector. Default value: Bw100 (settable in the interface 'ChannelBw1st')
 			:param secondChannelBw: optional repeated capability selector. Default value: Bw50 (settable in the interface 'ChannelBw2nd')
-			:param thirdChannelBw: optional repeated capability selector. Default value: Bw100 (settable in the interface 'ChannelBw3rd')
-			:return: structure: for return value, see the help for ChannelBw3rdStruct structure arguments."""
-		firstChannelBw_cmd_val = self._base.get_repcap_cmd_value(firstChannelBw, repcap.FirstChannelBw)
-		secondChannelBw_cmd_val = self._base.get_repcap_cmd_value(secondChannelBw, repcap.SecondChannelBw)
-		thirdChannelBw_cmd_val = self._base.get_repcap_cmd_value(thirdChannelBw, repcap.ThirdChannelBw)
-		return self._core.io.query_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:ACLR:EUTRa:CAGGregation:CBANdwidth{firstChannelBw_cmd_val}:CBANdwidth{secondChannelBw_cmd_val}:CBANdwidth{thirdChannelBw_cmd_val}?', self.__class__.ChannelBw3rdStruct())
+			:return: structure: for return value, see the help for ChannelBw2ndStruct structure arguments."""
+		utraAdjChannel_cmd_val = self._cmd_group.get_repcap_cmd_value(utraAdjChannel, repcap.UtraAdjChannel)
+		firstChannelBw_cmd_val = self._cmd_group.get_repcap_cmd_value(firstChannelBw, repcap.FirstChannelBw)
+		secondChannelBw_cmd_val = self._cmd_group.get_repcap_cmd_value(secondChannelBw, repcap.SecondChannelBw)
+		return self._core.io.query_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:ACLR:UTRA{utraAdjChannel_cmd_val}:CAGGregation:CBANdwidth{firstChannelBw_cmd_val}:CBANdwidth{secondChannelBw_cmd_val}?', self.__class__.ChannelBw2ndStruct())
 
-	def clone(self) -> 'ChannelBw3rd':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'ChannelBw2ndCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = ChannelBw3rd(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = ChannelBw2ndCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Limit_/Aclr_/Eutra_/ChannelBw.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Limit/Aclr/Eutra/ChannelBw.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,70 +1,76 @@
-from .......Internal.Core import Core
-from .......Internal.CommandsGroup import CommandsGroup
-from .......Internal.StructBase import StructBase
-from .......Internal.ArgStruct import ArgStruct
-from .......Internal.RepeatedCapability import RepeatedCapability
-from ....... import repcap
+from ........Internal.Core import Core
+from ........Internal.CommandsGroup import CommandsGroup
+from ........Internal.Types import DataType
+from ........Internal.StructBase import StructBase
+from ........Internal.ArgStruct import ArgStruct
+from ........Internal.ArgSingleList import ArgSingleList
+from ........Internal.ArgSingle import ArgSingle
+from ........Internal.RepeatedCapability import RepeatedCapability
+from ........ import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class ChannelBw:
-	"""ChannelBw commands group definition. 1 total commands, 0 Sub-groups, 1 group commands
+class ChannelBwCls:
+	"""ChannelBw commands group definition. 1 total commands, 0 Subgroups, 1 group commands
 	Repeated Capability: ChannelBw, default value after init: ChannelBw.Bw14"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("channelBw", core, parent)
-		self._base.rep_cap = RepeatedCapability(self._base.group_name, 'repcap_channelBw_get', 'repcap_channelBw_set', repcap.ChannelBw.Bw14)
+		self._cmd_group = CommandsGroup("channelBw", core, parent)
+		self._cmd_group.rep_cap = RepeatedCapability(self._cmd_group.group_name, 'repcap_channelBw_get', 'repcap_channelBw_set', repcap.ChannelBw.Bw14)
 
-	def repcap_channelBw_set(self, enum_value: repcap.ChannelBw) -> None:
+	def repcap_channelBw_set(self, channelBw: repcap.ChannelBw) -> None:
 		"""Repeated Capability default value numeric suffix.
 		This value is used, if you do not explicitely set it in the child set/get methods, or if you leave it to ChannelBw.Default
 		Default value after init: ChannelBw.Bw14"""
-		self._base.set_repcap_enum_value(enum_value)
+		self._cmd_group.set_repcap_enum_value(channelBw)
 
 	def repcap_channelBw_get(self) -> repcap.ChannelBw:
 		"""Returns the current default repeated capability for the child set/get methods"""
 		# noinspection PyTypeChecker
-		return self._base.get_repcap_enum_value()
+		return self._cmd_group.get_repcap_enum_value()
+
+	def set(self, relative_level: float or bool, absolute_level: float or bool, channelBw=repcap.ChannelBw.Default) -> None:
+		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:ACLR:EUTRa:CBANdwidth<Band> \n
+		Snippet: driver.configure.lteMeas.multiEval.limit.aclr.eutra.channelBw.set(relative_level = 1.0, absolute_level = 1.0, channelBw = repcap.ChannelBw.Default) \n
+		Defines relative and absolute limits for the ACLR measured in an adjacent E-UTRA channel. The settings are defined
+		separately for each channel bandwidth. \n
+			:param relative_level: (float or boolean) No help available
+			:param absolute_level: (float or boolean) No help available
+			:param channelBw: optional repeated capability selector. Default value: Bw14 (settable in the interface 'ChannelBw')
+		"""
+		param = ArgSingleList().compose_cmd_string(ArgSingle('relative_level', relative_level, DataType.FloatExt), ArgSingle('absolute_level', absolute_level, DataType.FloatExt))
+		channelBw_cmd_val = self._cmd_group.get_repcap_cmd_value(channelBw, repcap.ChannelBw)
+		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:ACLR:EUTRa:CBANdwidth{channelBw_cmd_val} {param}'.rstrip())
 
 	# noinspection PyTypeChecker
 	class ChannelBwStruct(StructBase):
-		"""Structure for setting input parameters. Fields: \n
+		"""Response structure. Fields: \n
 			- Relative_Level: float or bool: No parameter help available
 			- Absolute_Level: float or bool: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_float_ext('Relative_Level'),
 			ArgStruct.scalar_float_ext('Absolute_Level')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Relative_Level: float or bool = None
 			self.Absolute_Level: float or bool = None
 
-	def set(self, structure: ChannelBwStruct, channelBw=repcap.ChannelBw.Default) -> None:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:ACLR:EUTRa:CBANdwidth<Band> \n
-		Snippet: driver.configure.multiEval.limit.aclr.eutra.channelBw.set(value = [PROPERTY_STRUCT_NAME](), channelBw = repcap.ChannelBw.Default) \n
-		Defines relative and absolute limits for the ACLR measured in an adjacent E-UTRA channel. The settings are defined
-		separately for each channel bandwidth. \n
-			:param structure: for set value, see the help for ChannelBwStruct structure arguments.
-			:param channelBw: optional repeated capability selector. Default value: Bw14 (settable in the interface 'ChannelBw')"""
-		channelBw_cmd_val = self._base.get_repcap_cmd_value(channelBw, repcap.ChannelBw)
-		self._core.io.write_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:ACLR:EUTRa:CBANdwidth{channelBw_cmd_val}', structure)
-
 	def get(self, channelBw=repcap.ChannelBw.Default) -> ChannelBwStruct:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:ACLR:EUTRa:CBANdwidth<Band> \n
-		Snippet: value: ChannelBwStruct = driver.configure.multiEval.limit.aclr.eutra.channelBw.get(channelBw = repcap.ChannelBw.Default) \n
+		Snippet: value: ChannelBwStruct = driver.configure.lteMeas.multiEval.limit.aclr.eutra.channelBw.get(channelBw = repcap.ChannelBw.Default) \n
 		Defines relative and absolute limits for the ACLR measured in an adjacent E-UTRA channel. The settings are defined
 		separately for each channel bandwidth. \n
 			:param channelBw: optional repeated capability selector. Default value: Bw14 (settable in the interface 'ChannelBw')
 			:return: structure: for return value, see the help for ChannelBwStruct structure arguments."""
-		channelBw_cmd_val = self._base.get_repcap_cmd_value(channelBw, repcap.ChannelBw)
+		channelBw_cmd_val = self._cmd_group.get_repcap_cmd_value(channelBw, repcap.ChannelBw)
 		return self._core.io.query_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:ACLR:EUTRa:CBANdwidth{channelBw_cmd_val}?', self.__class__.ChannelBwStruct())
 
-	def clone(self) -> 'ChannelBw':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'ChannelBwCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = ChannelBw(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = ChannelBwCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Limit_/Aclr_/Utra.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Aclr/Utra/__init__.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,50 +1,50 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.RepeatedCapability import RepeatedCapability
-from ...... import repcap
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal.RepeatedCapability import RepeatedCapability
+from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Utra:
-	"""Utra commands group definition. 4 total commands, 2 Sub-groups, 0 group commands
+class UtraCls:
+	"""Utra commands group definition. 8 total commands, 2 Subgroups, 0 group commands
 	Repeated Capability: UtraAdjChannel, default value after init: UtraAdjChannel.Ch1"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("utra", core, parent)
-		self._base.rep_cap = RepeatedCapability(self._base.group_name, 'repcap_utraAdjChannel_get', 'repcap_utraAdjChannel_set', repcap.UtraAdjChannel.Ch1)
+		self._cmd_group = CommandsGroup("utra", core, parent)
+		self._cmd_group.rep_cap = RepeatedCapability(self._cmd_group.group_name, 'repcap_utraAdjChannel_get', 'repcap_utraAdjChannel_set', repcap.UtraAdjChannel.Ch1)
 
-	def repcap_utraAdjChannel_set(self, enum_value: repcap.UtraAdjChannel) -> None:
+	def repcap_utraAdjChannel_set(self, utraAdjChannel: repcap.UtraAdjChannel) -> None:
 		"""Repeated Capability default value numeric suffix.
 		This value is used, if you do not explicitely set it in the child set/get methods, or if you leave it to UtraAdjChannel.Default
 		Default value after init: UtraAdjChannel.Ch1"""
-		self._base.set_repcap_enum_value(enum_value)
+		self._cmd_group.set_repcap_enum_value(utraAdjChannel)
 
 	def repcap_utraAdjChannel_get(self) -> repcap.UtraAdjChannel:
 		"""Returns the current default repeated capability for the child set/get methods"""
 		# noinspection PyTypeChecker
-		return self._base.get_repcap_enum_value()
+		return self._cmd_group.get_repcap_enum_value()
 
 	@property
-	def channelBw(self):
-		"""channelBw commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_channelBw'):
-			from .Utra_.ChannelBw import ChannelBw
-			self._channelBw = ChannelBw(self._core, self._base)
-		return self._channelBw
+	def negativ(self):
+		"""negativ commands group. 2 Sub-classes, 0 commands."""
+		if not hasattr(self, '_negativ'):
+			from .Negativ import NegativCls
+			self._negativ = NegativCls(self._core, self._cmd_group)
+		return self._negativ
 
 	@property
-	def carrierAggregation(self):
-		"""carrierAggregation commands group. 2 Sub-classes, 0 commands."""
-		if not hasattr(self, '_carrierAggregation'):
-			from .Utra_.CarrierAggregation import CarrierAggregation
-			self._carrierAggregation = CarrierAggregation(self._core, self._base)
-		return self._carrierAggregation
+	def positiv(self):
+		"""positiv commands group. 2 Sub-classes, 0 commands."""
+		if not hasattr(self, '_positiv'):
+			from .Positiv import PositivCls
+			self._positiv = PositivCls(self._core, self._cmd_group)
+		return self._positiv
 
-	def clone(self) -> 'Utra':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'UtraCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Utra(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = UtraCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Limit_/Aclr_/Utra_/CarrierAggregation.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Limit/Aclr/Eutra/CarrierAggregation/__init__.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,35 +1,35 @@
-from .......Internal.Core import Core
-from .......Internal.CommandsGroup import CommandsGroup
+from .........Internal.Core import Core
+from .........Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class CarrierAggregation:
-	"""CarrierAggregation commands group definition. 3 total commands, 2 Sub-groups, 0 group commands"""
+class CarrierAggregationCls:
+	"""CarrierAggregation commands group definition. 3 total commands, 2 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("carrierAggregation", core, parent)
+		self._cmd_group = CommandsGroup("carrierAggregation", core, parent)
 
 	@property
 	def channelBw1st(self):
 		"""channelBw1st commands group. 1 Sub-classes, 0 commands."""
 		if not hasattr(self, '_channelBw1st'):
-			from .CarrierAggregation_.ChannelBw1st import ChannelBw1st
-			self._channelBw1st = ChannelBw1st(self._core, self._base)
+			from .ChannelBw1st import ChannelBw1stCls
+			self._channelBw1st = ChannelBw1stCls(self._core, self._cmd_group)
 		return self._channelBw1st
 
 	@property
 	def ocombination(self):
 		"""ocombination commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_ocombination'):
-			from .CarrierAggregation_.Ocombination import Ocombination
-			self._ocombination = Ocombination(self._core, self._base)
+			from .Ocombination import OcombinationCls
+			self._ocombination = OcombinationCls(self._core, self._cmd_group)
 		return self._ocombination
 
-	def clone(self) -> 'CarrierAggregation':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'CarrierAggregationCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = CarrierAggregation(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = CarrierAggregationCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Limit_/Aclr_/Utra_/CarrierAggregation_/ChannelBw1st.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Limit/Aclr/Eutra/CarrierAggregation/ChannelBw1st/__init__.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,42 +1,42 @@
-from ........Internal.Core import Core
-from ........Internal.CommandsGroup import CommandsGroup
-from ........Internal.RepeatedCapability import RepeatedCapability
-from ........ import repcap
+from ..........Internal.Core import Core
+from ..........Internal.CommandsGroup import CommandsGroup
+from ..........Internal.RepeatedCapability import RepeatedCapability
+from .......... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class ChannelBw1st:
-	"""ChannelBw1st commands group definition. 2 total commands, 1 Sub-groups, 0 group commands
+class ChannelBw1stCls:
+	"""ChannelBw1st commands group definition. 2 total commands, 1 Subgroups, 0 group commands
 	Repeated Capability: FirstChannelBw, default value after init: FirstChannelBw.Bw100"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("channelBw1st", core, parent)
-		self._base.rep_cap = RepeatedCapability(self._base.group_name, 'repcap_firstChannelBw_get', 'repcap_firstChannelBw_set', repcap.FirstChannelBw.Bw100)
+		self._cmd_group = CommandsGroup("channelBw1st", core, parent)
+		self._cmd_group.rep_cap = RepeatedCapability(self._cmd_group.group_name, 'repcap_firstChannelBw_get', 'repcap_firstChannelBw_set', repcap.FirstChannelBw.Bw100)
 
-	def repcap_firstChannelBw_set(self, enum_value: repcap.FirstChannelBw) -> None:
+	def repcap_firstChannelBw_set(self, firstChannelBw: repcap.FirstChannelBw) -> None:
 		"""Repeated Capability default value numeric suffix.
 		This value is used, if you do not explicitely set it in the child set/get methods, or if you leave it to FirstChannelBw.Default
 		Default value after init: FirstChannelBw.Bw100"""
-		self._base.set_repcap_enum_value(enum_value)
+		self._cmd_group.set_repcap_enum_value(firstChannelBw)
 
 	def repcap_firstChannelBw_get(self) -> repcap.FirstChannelBw:
 		"""Returns the current default repeated capability for the child set/get methods"""
 		# noinspection PyTypeChecker
-		return self._base.get_repcap_enum_value()
+		return self._cmd_group.get_repcap_enum_value()
 
 	@property
 	def channelBw2nd(self):
 		"""channelBw2nd commands group. 1 Sub-classes, 1 commands."""
 		if not hasattr(self, '_channelBw2nd'):
-			from .ChannelBw1st_.ChannelBw2nd import ChannelBw2nd
-			self._channelBw2nd = ChannelBw2nd(self._core, self._base)
+			from .ChannelBw2nd import ChannelBw2ndCls
+			self._channelBw2nd = ChannelBw2ndCls(self._core, self._cmd_group)
 		return self._channelBw2nd
 
-	def clone(self) -> 'ChannelBw1st':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'ChannelBw1stCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = ChannelBw1st(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = ChannelBw1stCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Limit_/Aclr_/Utra_/CarrierAggregation_/ChannelBw1st_/ChannelBw2nd.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Limit/Aclr/Eutra/CarrierAggregation/ChannelBw1st/ChannelBw2nd/ChannelBw3rd.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,90 +1,86 @@
-from .........Internal.Core import Core
-from .........Internal.CommandsGroup import CommandsGroup
-from .........Internal.StructBase import StructBase
-from .........Internal.ArgStruct import ArgStruct
-from .........Internal.RepeatedCapability import RepeatedCapability
-from ......... import repcap
+from ...........Internal.Core import Core
+from ...........Internal.CommandsGroup import CommandsGroup
+from ...........Internal.Types import DataType
+from ...........Internal.StructBase import StructBase
+from ...........Internal.ArgStruct import ArgStruct
+from ...........Internal.ArgSingleList import ArgSingleList
+from ...........Internal.ArgSingle import ArgSingle
+from ...........Internal.RepeatedCapability import RepeatedCapability
+from ........... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class ChannelBw2nd:
-	"""ChannelBw2nd commands group definition. 2 total commands, 1 Sub-groups, 1 group commands
-	Repeated Capability: SecondChannelBw, default value after init: SecondChannelBw.Bw50"""
+class ChannelBw3rdCls:
+	"""ChannelBw3rd commands group definition. 1 total commands, 0 Subgroups, 1 group commands
+	Repeated Capability: ThirdChannelBw, default value after init: ThirdChannelBw.Bw100"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("channelBw2nd", core, parent)
-		self._base.rep_cap = RepeatedCapability(self._base.group_name, 'repcap_secondChannelBw_get', 'repcap_secondChannelBw_set', repcap.SecondChannelBw.Bw50)
+		self._cmd_group = CommandsGroup("channelBw3rd", core, parent)
+		self._cmd_group.rep_cap = RepeatedCapability(self._cmd_group.group_name, 'repcap_thirdChannelBw_get', 'repcap_thirdChannelBw_set', repcap.ThirdChannelBw.Bw100)
 
-	def repcap_secondChannelBw_set(self, enum_value: repcap.SecondChannelBw) -> None:
+	def repcap_thirdChannelBw_set(self, thirdChannelBw: repcap.ThirdChannelBw) -> None:
 		"""Repeated Capability default value numeric suffix.
-		This value is used, if you do not explicitely set it in the child set/get methods, or if you leave it to SecondChannelBw.Default
-		Default value after init: SecondChannelBw.Bw50"""
-		self._base.set_repcap_enum_value(enum_value)
+		This value is used, if you do not explicitely set it in the child set/get methods, or if you leave it to ThirdChannelBw.Default
+		Default value after init: ThirdChannelBw.Bw100"""
+		self._cmd_group.set_repcap_enum_value(thirdChannelBw)
 
-	def repcap_secondChannelBw_get(self) -> repcap.SecondChannelBw:
+	def repcap_thirdChannelBw_get(self) -> repcap.ThirdChannelBw:
 		"""Returns the current default repeated capability for the child set/get methods"""
 		# noinspection PyTypeChecker
-		return self._base.get_repcap_enum_value()
+		return self._cmd_group.get_repcap_enum_value()
 
-	@property
-	def channelBw3rd(self):
-		"""channelBw3rd commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_channelBw3rd'):
-			from .ChannelBw2nd_.ChannelBw3rd import ChannelBw3rd
-			self._channelBw3rd = ChannelBw3rd(self._core, self._base)
-		return self._channelBw3rd
+	def set(self, relative_level: float or bool, absolute_level: float or bool, firstChannelBw=repcap.FirstChannelBw.Default, secondChannelBw=repcap.SecondChannelBw.Default, thirdChannelBw=repcap.ThirdChannelBw.Default) -> None:
+		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:ACLR:EUTRa:CAGGregation:CBANdwidth<Band1>:CBANdwidth<Band2>:CBANdwidth<Band3> \n
+		Snippet: driver.configure.lteMeas.multiEval.limit.aclr.eutra.carrierAggregation.channelBw1st.channelBw2nd.channelBw3rd.set(relative_level = 1.0, absolute_level = 1.0, firstChannelBw = repcap.FirstChannelBw.Default, secondChannelBw = repcap.SecondChannelBw.Default, thirdChannelBw = repcap.ThirdChannelBw.Default) \n
+		Defines relative and absolute limits for the ACLR measured in an adjacent E-UTRA channel. The settings are defined
+		separately for each channel bandwidth combination, for three aggregated carriers. The following bandwidth combinations
+		are supported: Example: For the first line in the figure, use ...:CBANdwidth200:CBANdwidth150:CBANdwidth100. \n
+			:param relative_level: (float or boolean) No help available
+			:param absolute_level: (float or boolean) No help available
+			:param firstChannelBw: optional repeated capability selector. Default value: Bw100 (settable in the interface 'ChannelBw1st')
+			:param secondChannelBw: optional repeated capability selector. Default value: Bw50 (settable in the interface 'ChannelBw2nd')
+			:param thirdChannelBw: optional repeated capability selector. Default value: Bw100 (settable in the interface 'ChannelBw3rd')
+		"""
+		param = ArgSingleList().compose_cmd_string(ArgSingle('relative_level', relative_level, DataType.FloatExt), ArgSingle('absolute_level', absolute_level, DataType.FloatExt))
+		firstChannelBw_cmd_val = self._cmd_group.get_repcap_cmd_value(firstChannelBw, repcap.FirstChannelBw)
+		secondChannelBw_cmd_val = self._cmd_group.get_repcap_cmd_value(secondChannelBw, repcap.SecondChannelBw)
+		thirdChannelBw_cmd_val = self._cmd_group.get_repcap_cmd_value(thirdChannelBw, repcap.ThirdChannelBw)
+		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:ACLR:EUTRa:CAGGregation:CBANdwidth{firstChannelBw_cmd_val}:CBANdwidth{secondChannelBw_cmd_val}:CBANdwidth{thirdChannelBw_cmd_val} {param}'.rstrip())
 
 	# noinspection PyTypeChecker
-	class ChannelBw2ndStruct(StructBase):
-		"""Structure for setting input parameters. Fields: \n
+	class ChannelBw3rdStruct(StructBase):
+		"""Response structure. Fields: \n
 			- Relative_Level: float or bool: No parameter help available
 			- Absolute_Level: float or bool: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_float_ext('Relative_Level'),
 			ArgStruct.scalar_float_ext('Absolute_Level')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Relative_Level: float or bool = None
 			self.Absolute_Level: float or bool = None
 
-	def set(self, structure: ChannelBw2ndStruct, utraAdjChannel=repcap.UtraAdjChannel.Default, firstChannelBw=repcap.FirstChannelBw.Default, secondChannelBw=repcap.SecondChannelBw.Default) -> None:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:ACLR:UTRA<nr>:CAGGregation:CBANdwidth<Band1>:CBANdwidth<Band2> \n
-		Snippet: driver.configure.multiEval.limit.aclr.utra.carrierAggregation.channelBw1st.channelBw2nd.set(value = [PROPERTY_STRUCT_NAME](), utraAdjChannel = repcap.UtraAdjChannel.Default, firstChannelBw = repcap.FirstChannelBw.Default, secondChannelBw = repcap.SecondChannelBw.Default) \n
-		Defines relative and absolute limits for the ACLR measured in the first or second adjacent UTRA channel, depending on
-		<no>. The settings are defined separately for each channel bandwidth combination, for two aggregated carriers.
-		The following bandwidth combinations are supported: Example: For the first line in the figure, use ...
-		:CBANdwidth100:CBANdwidth50. \n
-			:param structure: for set value, see the help for ChannelBw2ndStruct structure arguments.
-			:param utraAdjChannel: optional repeated capability selector. Default value: Ch1 (settable in the interface 'Utra')
-			:param firstChannelBw: optional repeated capability selector. Default value: Bw100 (settable in the interface 'ChannelBw1st')
-			:param secondChannelBw: optional repeated capability selector. Default value: Bw50 (settable in the interface 'ChannelBw2nd')"""
-		utraAdjChannel_cmd_val = self._base.get_repcap_cmd_value(utraAdjChannel, repcap.UtraAdjChannel)
-		firstChannelBw_cmd_val = self._base.get_repcap_cmd_value(firstChannelBw, repcap.FirstChannelBw)
-		secondChannelBw_cmd_val = self._base.get_repcap_cmd_value(secondChannelBw, repcap.SecondChannelBw)
-		self._core.io.write_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:ACLR:UTRA{utraAdjChannel_cmd_val}:CAGGregation:CBANdwidth{firstChannelBw_cmd_val}:CBANdwidth{secondChannelBw_cmd_val}', structure)
-
-	def get(self, utraAdjChannel=repcap.UtraAdjChannel.Default, firstChannelBw=repcap.FirstChannelBw.Default, secondChannelBw=repcap.SecondChannelBw.Default) -> ChannelBw2ndStruct:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:ACLR:UTRA<nr>:CAGGregation:CBANdwidth<Band1>:CBANdwidth<Band2> \n
-		Snippet: value: ChannelBw2ndStruct = driver.configure.multiEval.limit.aclr.utra.carrierAggregation.channelBw1st.channelBw2nd.get(utraAdjChannel = repcap.UtraAdjChannel.Default, firstChannelBw = repcap.FirstChannelBw.Default, secondChannelBw = repcap.SecondChannelBw.Default) \n
-		Defines relative and absolute limits for the ACLR measured in the first or second adjacent UTRA channel, depending on
-		<no>. The settings are defined separately for each channel bandwidth combination, for two aggregated carriers.
-		The following bandwidth combinations are supported: Example: For the first line in the figure, use ...
-		:CBANdwidth100:CBANdwidth50. \n
-			:param utraAdjChannel: optional repeated capability selector. Default value: Ch1 (settable in the interface 'Utra')
+	def get(self, firstChannelBw=repcap.FirstChannelBw.Default, secondChannelBw=repcap.SecondChannelBw.Default, thirdChannelBw=repcap.ThirdChannelBw.Default) -> ChannelBw3rdStruct:
+		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:ACLR:EUTRa:CAGGregation:CBANdwidth<Band1>:CBANdwidth<Band2>:CBANdwidth<Band3> \n
+		Snippet: value: ChannelBw3rdStruct = driver.configure.lteMeas.multiEval.limit.aclr.eutra.carrierAggregation.channelBw1st.channelBw2nd.channelBw3rd.get(firstChannelBw = repcap.FirstChannelBw.Default, secondChannelBw = repcap.SecondChannelBw.Default, thirdChannelBw = repcap.ThirdChannelBw.Default) \n
+		Defines relative and absolute limits for the ACLR measured in an adjacent E-UTRA channel. The settings are defined
+		separately for each channel bandwidth combination, for three aggregated carriers. The following bandwidth combinations
+		are supported: Example: For the first line in the figure, use ...:CBANdwidth200:CBANdwidth150:CBANdwidth100. \n
 			:param firstChannelBw: optional repeated capability selector. Default value: Bw100 (settable in the interface 'ChannelBw1st')
 			:param secondChannelBw: optional repeated capability selector. Default value: Bw50 (settable in the interface 'ChannelBw2nd')
-			:return: structure: for return value, see the help for ChannelBw2ndStruct structure arguments."""
-		utraAdjChannel_cmd_val = self._base.get_repcap_cmd_value(utraAdjChannel, repcap.UtraAdjChannel)
-		firstChannelBw_cmd_val = self._base.get_repcap_cmd_value(firstChannelBw, repcap.FirstChannelBw)
-		secondChannelBw_cmd_val = self._base.get_repcap_cmd_value(secondChannelBw, repcap.SecondChannelBw)
-		return self._core.io.query_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:ACLR:UTRA{utraAdjChannel_cmd_val}:CAGGregation:CBANdwidth{firstChannelBw_cmd_val}:CBANdwidth{secondChannelBw_cmd_val}?', self.__class__.ChannelBw2ndStruct())
+			:param thirdChannelBw: optional repeated capability selector. Default value: Bw100 (settable in the interface 'ChannelBw3rd')
+			:return: structure: for return value, see the help for ChannelBw3rdStruct structure arguments."""
+		firstChannelBw_cmd_val = self._cmd_group.get_repcap_cmd_value(firstChannelBw, repcap.FirstChannelBw)
+		secondChannelBw_cmd_val = self._cmd_group.get_repcap_cmd_value(secondChannelBw, repcap.SecondChannelBw)
+		thirdChannelBw_cmd_val = self._cmd_group.get_repcap_cmd_value(thirdChannelBw, repcap.ThirdChannelBw)
+		return self._core.io.query_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:ACLR:EUTRa:CAGGregation:CBANdwidth{firstChannelBw_cmd_val}:CBANdwidth{secondChannelBw_cmd_val}:CBANdwidth{thirdChannelBw_cmd_val}?', self.__class__.ChannelBw3rdStruct())
 
-	def clone(self) -> 'ChannelBw2nd':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'ChannelBw3rdCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = ChannelBw2nd(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = ChannelBw3rdCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Limit_/Aclr_/Utra_/CarrierAggregation_/ChannelBw1st_/ChannelBw2nd_/ChannelBw3rd.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Limit/Aclr/Utra/CarrierAggregation/ChannelBw1st/ChannelBw2nd/ChannelBw3rd.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,86 +1,92 @@
-from ..........Internal.Core import Core
-from ..........Internal.CommandsGroup import CommandsGroup
-from ..........Internal.StructBase import StructBase
-from ..........Internal.ArgStruct import ArgStruct
-from ..........Internal.RepeatedCapability import RepeatedCapability
-from .......... import repcap
+from ...........Internal.Core import Core
+from ...........Internal.CommandsGroup import CommandsGroup
+from ...........Internal.Types import DataType
+from ...........Internal.StructBase import StructBase
+from ...........Internal.ArgStruct import ArgStruct
+from ...........Internal.ArgSingleList import ArgSingleList
+from ...........Internal.ArgSingle import ArgSingle
+from ...........Internal.RepeatedCapability import RepeatedCapability
+from ........... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class ChannelBw3rd:
-	"""ChannelBw3rd commands group definition. 1 total commands, 0 Sub-groups, 1 group commands
+class ChannelBw3rdCls:
+	"""ChannelBw3rd commands group definition. 1 total commands, 0 Subgroups, 1 group commands
 	Repeated Capability: ThirdChannelBw, default value after init: ThirdChannelBw.Bw100"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("channelBw3rd", core, parent)
-		self._base.rep_cap = RepeatedCapability(self._base.group_name, 'repcap_thirdChannelBw_get', 'repcap_thirdChannelBw_set', repcap.ThirdChannelBw.Bw100)
+		self._cmd_group = CommandsGroup("channelBw3rd", core, parent)
+		self._cmd_group.rep_cap = RepeatedCapability(self._cmd_group.group_name, 'repcap_thirdChannelBw_get', 'repcap_thirdChannelBw_set', repcap.ThirdChannelBw.Bw100)
 
-	def repcap_thirdChannelBw_set(self, enum_value: repcap.ThirdChannelBw) -> None:
+	def repcap_thirdChannelBw_set(self, thirdChannelBw: repcap.ThirdChannelBw) -> None:
 		"""Repeated Capability default value numeric suffix.
 		This value is used, if you do not explicitely set it in the child set/get methods, or if you leave it to ThirdChannelBw.Default
 		Default value after init: ThirdChannelBw.Bw100"""
-		self._base.set_repcap_enum_value(enum_value)
+		self._cmd_group.set_repcap_enum_value(thirdChannelBw)
 
 	def repcap_thirdChannelBw_get(self) -> repcap.ThirdChannelBw:
 		"""Returns the current default repeated capability for the child set/get methods"""
 		# noinspection PyTypeChecker
-		return self._base.get_repcap_enum_value()
+		return self._cmd_group.get_repcap_enum_value()
+
+	def set(self, relative_level: float or bool, absolute_level: float or bool, utraAdjChannel=repcap.UtraAdjChannel.Default, firstChannelBw=repcap.FirstChannelBw.Default, secondChannelBw=repcap.SecondChannelBw.Default, thirdChannelBw=repcap.ThirdChannelBw.Default) -> None:
+		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:ACLR:UTRA<nr>:CAGGregation:CBANdwidth<Band1>:CBANdwidth<Band2>:CBANdwidth<Band3> \n
+		Snippet: driver.configure.lteMeas.multiEval.limit.aclr.utra.carrierAggregation.channelBw1st.channelBw2nd.channelBw3rd.set(relative_level = 1.0, absolute_level = 1.0, utraAdjChannel = repcap.UtraAdjChannel.Default, firstChannelBw = repcap.FirstChannelBw.Default, secondChannelBw = repcap.SecondChannelBw.Default, thirdChannelBw = repcap.ThirdChannelBw.Default) \n
+		Defines relative and absolute limits for the ACLR measured in the first or second adjacent UTRA channel, depending on
+		<no>. The settings are defined separately for each channel bandwidth combination, for three aggregated carriers.
+		The following bandwidth combinations are supported: Example: For the first line in the figure, use ...
+		:CBANdwidth200:CBANdwidth150:CBANdwidth100. \n
+			:param relative_level: (float or boolean) No help available
+			:param absolute_level: (float or boolean) No help available
+			:param utraAdjChannel: optional repeated capability selector. Default value: Ch1 (settable in the interface 'Utra')
+			:param firstChannelBw: optional repeated capability selector. Default value: Bw100 (settable in the interface 'ChannelBw1st')
+			:param secondChannelBw: optional repeated capability selector. Default value: Bw50 (settable in the interface 'ChannelBw2nd')
+			:param thirdChannelBw: optional repeated capability selector. Default value: Bw100 (settable in the interface 'ChannelBw3rd')
+		"""
+		param = ArgSingleList().compose_cmd_string(ArgSingle('relative_level', relative_level, DataType.FloatExt), ArgSingle('absolute_level', absolute_level, DataType.FloatExt))
+		utraAdjChannel_cmd_val = self._cmd_group.get_repcap_cmd_value(utraAdjChannel, repcap.UtraAdjChannel)
+		firstChannelBw_cmd_val = self._cmd_group.get_repcap_cmd_value(firstChannelBw, repcap.FirstChannelBw)
+		secondChannelBw_cmd_val = self._cmd_group.get_repcap_cmd_value(secondChannelBw, repcap.SecondChannelBw)
+		thirdChannelBw_cmd_val = self._cmd_group.get_repcap_cmd_value(thirdChannelBw, repcap.ThirdChannelBw)
+		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:ACLR:UTRA{utraAdjChannel_cmd_val}:CAGGregation:CBANdwidth{firstChannelBw_cmd_val}:CBANdwidth{secondChannelBw_cmd_val}:CBANdwidth{thirdChannelBw_cmd_val} {param}'.rstrip())
 
 	# noinspection PyTypeChecker
 	class ChannelBw3rdStruct(StructBase):
-		"""Structure for setting input parameters. Fields: \n
+		"""Response structure. Fields: \n
 			- Relative_Level: float or bool: No parameter help available
 			- Absolute_Level: float or bool: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_float_ext('Relative_Level'),
 			ArgStruct.scalar_float_ext('Absolute_Level')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Relative_Level: float or bool = None
 			self.Absolute_Level: float or bool = None
 
-	def set(self, structure: ChannelBw3rdStruct, utraAdjChannel=repcap.UtraAdjChannel.Default, firstChannelBw=repcap.FirstChannelBw.Default, secondChannelBw=repcap.SecondChannelBw.Default, thirdChannelBw=repcap.ThirdChannelBw.Default) -> None:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:ACLR:UTRA<nr>:CAGGregation:CBANdwidth<Band1>:CBANdwidth<Band2>:CBANdwidth<Band3> \n
-		Snippet: driver.configure.multiEval.limit.aclr.utra.carrierAggregation.channelBw1st.channelBw2nd.channelBw3rd.set(value = [PROPERTY_STRUCT_NAME](), utraAdjChannel = repcap.UtraAdjChannel.Default, firstChannelBw = repcap.FirstChannelBw.Default, secondChannelBw = repcap.SecondChannelBw.Default, thirdChannelBw = repcap.ThirdChannelBw.Default) \n
-		Defines relative and absolute limits for the ACLR measured in the first or second adjacent UTRA channel, depending on
-		<no>. The settings are defined separately for each channel bandwidth combination, for three aggregated carriers.
-		The following bandwidth combinations are supported: Example: For the first line in the figure, use ...
-		:CBANdwidth200:CBANdwidth150:CBANdwidth100. \n
-			:param structure: for set value, see the help for ChannelBw3rdStruct structure arguments.
-			:param utraAdjChannel: optional repeated capability selector. Default value: Ch1 (settable in the interface 'Utra')
-			:param firstChannelBw: optional repeated capability selector. Default value: Bw100 (settable in the interface 'ChannelBw1st')
-			:param secondChannelBw: optional repeated capability selector. Default value: Bw50 (settable in the interface 'ChannelBw2nd')
-			:param thirdChannelBw: optional repeated capability selector. Default value: Bw100 (settable in the interface 'ChannelBw3rd')"""
-		utraAdjChannel_cmd_val = self._base.get_repcap_cmd_value(utraAdjChannel, repcap.UtraAdjChannel)
-		firstChannelBw_cmd_val = self._base.get_repcap_cmd_value(firstChannelBw, repcap.FirstChannelBw)
-		secondChannelBw_cmd_val = self._base.get_repcap_cmd_value(secondChannelBw, repcap.SecondChannelBw)
-		thirdChannelBw_cmd_val = self._base.get_repcap_cmd_value(thirdChannelBw, repcap.ThirdChannelBw)
-		self._core.io.write_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:ACLR:UTRA{utraAdjChannel_cmd_val}:CAGGregation:CBANdwidth{firstChannelBw_cmd_val}:CBANdwidth{secondChannelBw_cmd_val}:CBANdwidth{thirdChannelBw_cmd_val}', structure)
-
 	def get(self, utraAdjChannel=repcap.UtraAdjChannel.Default, firstChannelBw=repcap.FirstChannelBw.Default, secondChannelBw=repcap.SecondChannelBw.Default, thirdChannelBw=repcap.ThirdChannelBw.Default) -> ChannelBw3rdStruct:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:ACLR:UTRA<nr>:CAGGregation:CBANdwidth<Band1>:CBANdwidth<Band2>:CBANdwidth<Band3> \n
-		Snippet: value: ChannelBw3rdStruct = driver.configure.multiEval.limit.aclr.utra.carrierAggregation.channelBw1st.channelBw2nd.channelBw3rd.get(utraAdjChannel = repcap.UtraAdjChannel.Default, firstChannelBw = repcap.FirstChannelBw.Default, secondChannelBw = repcap.SecondChannelBw.Default, thirdChannelBw = repcap.ThirdChannelBw.Default) \n
+		Snippet: value: ChannelBw3rdStruct = driver.configure.lteMeas.multiEval.limit.aclr.utra.carrierAggregation.channelBw1st.channelBw2nd.channelBw3rd.get(utraAdjChannel = repcap.UtraAdjChannel.Default, firstChannelBw = repcap.FirstChannelBw.Default, secondChannelBw = repcap.SecondChannelBw.Default, thirdChannelBw = repcap.ThirdChannelBw.Default) \n
 		Defines relative and absolute limits for the ACLR measured in the first or second adjacent UTRA channel, depending on
 		<no>. The settings are defined separately for each channel bandwidth combination, for three aggregated carriers.
 		The following bandwidth combinations are supported: Example: For the first line in the figure, use ...
 		:CBANdwidth200:CBANdwidth150:CBANdwidth100. \n
 			:param utraAdjChannel: optional repeated capability selector. Default value: Ch1 (settable in the interface 'Utra')
 			:param firstChannelBw: optional repeated capability selector. Default value: Bw100 (settable in the interface 'ChannelBw1st')
 			:param secondChannelBw: optional repeated capability selector. Default value: Bw50 (settable in the interface 'ChannelBw2nd')
 			:param thirdChannelBw: optional repeated capability selector. Default value: Bw100 (settable in the interface 'ChannelBw3rd')
 			:return: structure: for return value, see the help for ChannelBw3rdStruct structure arguments."""
-		utraAdjChannel_cmd_val = self._base.get_repcap_cmd_value(utraAdjChannel, repcap.UtraAdjChannel)
-		firstChannelBw_cmd_val = self._base.get_repcap_cmd_value(firstChannelBw, repcap.FirstChannelBw)
-		secondChannelBw_cmd_val = self._base.get_repcap_cmd_value(secondChannelBw, repcap.SecondChannelBw)
-		thirdChannelBw_cmd_val = self._base.get_repcap_cmd_value(thirdChannelBw, repcap.ThirdChannelBw)
+		utraAdjChannel_cmd_val = self._cmd_group.get_repcap_cmd_value(utraAdjChannel, repcap.UtraAdjChannel)
+		firstChannelBw_cmd_val = self._cmd_group.get_repcap_cmd_value(firstChannelBw, repcap.FirstChannelBw)
+		secondChannelBw_cmd_val = self._cmd_group.get_repcap_cmd_value(secondChannelBw, repcap.SecondChannelBw)
+		thirdChannelBw_cmd_val = self._cmd_group.get_repcap_cmd_value(thirdChannelBw, repcap.ThirdChannelBw)
 		return self._core.io.query_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:ACLR:UTRA{utraAdjChannel_cmd_val}:CAGGregation:CBANdwidth{firstChannelBw_cmd_val}:CBANdwidth{secondChannelBw_cmd_val}:CBANdwidth{thirdChannelBw_cmd_val}?', self.__class__.ChannelBw3rdStruct())
 
-	def clone(self) -> 'ChannelBw3rd':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'ChannelBw3rdCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = ChannelBw3rd(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = ChannelBw3rdCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Limit_/Aclr_/Utra_/CarrierAggregation_/Ocombination.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Limit/Aclr/Utra/CarrierAggregation/Ocombination.py`

 * *Files 25% similar despite different names*

```diff
@@ -1,48 +1,54 @@
-from ........Internal.Core import Core
-from ........Internal.CommandsGroup import CommandsGroup
-from ........Internal.StructBase import StructBase
-from ........Internal.ArgStruct import ArgStruct
-from ........ import repcap
+from .........Internal.Core import Core
+from .........Internal.CommandsGroup import CommandsGroup
+from .........Internal.Types import DataType
+from .........Internal.StructBase import StructBase
+from .........Internal.ArgStruct import ArgStruct
+from .........Internal.ArgSingleList import ArgSingleList
+from .........Internal.ArgSingle import ArgSingle
+from ......... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Ocombination:
-	"""Ocombination commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class OcombinationCls:
+	"""Ocombination commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("ocombination", core, parent)
+		self._cmd_group = CommandsGroup("ocombination", core, parent)
+
+	def set(self, relative_level: float or bool, absolute_level: float or bool, utraAdjChannel=repcap.UtraAdjChannel.Default) -> None:
+		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:ACLR:UTRA<nr>:CAGGregation:OCOMbination \n
+		Snippet: driver.configure.lteMeas.multiEval.limit.aclr.utra.carrierAggregation.ocombination.set(relative_level = 1.0, absolute_level = 1.0, utraAdjChannel = repcap.UtraAdjChannel.Default) \n
+		Defines relative and absolute limits for the ACLR measured in the first or second adjacent UTRA channel, depending on
+		<no>. The settings apply to all 'other' channel bandwidth combinations, not covered by other commands in this chapter. \n
+			:param relative_level: (float or boolean) No help available
+			:param absolute_level: (float or boolean) No help available
+			:param utraAdjChannel: optional repeated capability selector. Default value: Ch1 (settable in the interface 'Utra')
+		"""
+		param = ArgSingleList().compose_cmd_string(ArgSingle('relative_level', relative_level, DataType.FloatExt), ArgSingle('absolute_level', absolute_level, DataType.FloatExt))
+		utraAdjChannel_cmd_val = self._cmd_group.get_repcap_cmd_value(utraAdjChannel, repcap.UtraAdjChannel)
+		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:ACLR:UTRA{utraAdjChannel_cmd_val}:CAGGregation:OCOMbination {param}'.rstrip())
 
 	# noinspection PyTypeChecker
 	class OcombinationStruct(StructBase):
-		"""Structure for setting input parameters. Fields: \n
+		"""Response structure. Fields: \n
 			- Relative_Level: float or bool: No parameter help available
 			- Absolute_Level: float or bool: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_float_ext('Relative_Level'),
 			ArgStruct.scalar_float_ext('Absolute_Level')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Relative_Level: float or bool = None
 			self.Absolute_Level: float or bool = None
 
-	def set(self, structure: OcombinationStruct, utraAdjChannel=repcap.UtraAdjChannel.Default) -> None:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:ACLR:UTRA<nr>:CAGGregation:OCOMbination \n
-		Snippet: driver.configure.multiEval.limit.aclr.utra.carrierAggregation.ocombination.set(value = [PROPERTY_STRUCT_NAME](), utraAdjChannel = repcap.UtraAdjChannel.Default) \n
-		Defines relative and absolute limits for the ACLR measured in the first or second adjacent UTRA channel, depending on
-		<no>. The settings apply to all 'other' channel bandwidth combinations, not covered by other commands in this chapter. \n
-			:param structure: for set value, see the help for OcombinationStruct structure arguments.
-			:param utraAdjChannel: optional repeated capability selector. Default value: Ch1 (settable in the interface 'Utra')"""
-		utraAdjChannel_cmd_val = self._base.get_repcap_cmd_value(utraAdjChannel, repcap.UtraAdjChannel)
-		self._core.io.write_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:ACLR:UTRA{utraAdjChannel_cmd_val}:CAGGregation:OCOMbination', structure)
-
 	def get(self, utraAdjChannel=repcap.UtraAdjChannel.Default) -> OcombinationStruct:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:ACLR:UTRA<nr>:CAGGregation:OCOMbination \n
-		Snippet: value: OcombinationStruct = driver.configure.multiEval.limit.aclr.utra.carrierAggregation.ocombination.get(utraAdjChannel = repcap.UtraAdjChannel.Default) \n
+		Snippet: value: OcombinationStruct = driver.configure.lteMeas.multiEval.limit.aclr.utra.carrierAggregation.ocombination.get(utraAdjChannel = repcap.UtraAdjChannel.Default) \n
 		Defines relative and absolute limits for the ACLR measured in the first or second adjacent UTRA channel, depending on
 		<no>. The settings apply to all 'other' channel bandwidth combinations, not covered by other commands in this chapter. \n
 			:param utraAdjChannel: optional repeated capability selector. Default value: Ch1 (settable in the interface 'Utra')
 			:return: structure: for return value, see the help for OcombinationStruct structure arguments."""
-		utraAdjChannel_cmd_val = self._base.get_repcap_cmd_value(utraAdjChannel, repcap.UtraAdjChannel)
+		utraAdjChannel_cmd_val = self._cmd_group.get_repcap_cmd_value(utraAdjChannel, repcap.UtraAdjChannel)
 		return self._core.io.query_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:ACLR:UTRA{utraAdjChannel_cmd_val}:CAGGregation:OCOMbination?', self.__class__.OcombinationStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Limit_/Aclr_/Utra_/ChannelBw.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Limit/Aclr/Utra/ChannelBw.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,74 +1,80 @@
-from .......Internal.Core import Core
-from .......Internal.CommandsGroup import CommandsGroup
-from .......Internal.StructBase import StructBase
-from .......Internal.ArgStruct import ArgStruct
-from .......Internal.RepeatedCapability import RepeatedCapability
-from ....... import repcap
+from ........Internal.Core import Core
+from ........Internal.CommandsGroup import CommandsGroup
+from ........Internal.Types import DataType
+from ........Internal.StructBase import StructBase
+from ........Internal.ArgStruct import ArgStruct
+from ........Internal.ArgSingleList import ArgSingleList
+from ........Internal.ArgSingle import ArgSingle
+from ........Internal.RepeatedCapability import RepeatedCapability
+from ........ import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class ChannelBw:
-	"""ChannelBw commands group definition. 1 total commands, 0 Sub-groups, 1 group commands
+class ChannelBwCls:
+	"""ChannelBw commands group definition. 1 total commands, 0 Subgroups, 1 group commands
 	Repeated Capability: ChannelBw, default value after init: ChannelBw.Bw14"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("channelBw", core, parent)
-		self._base.rep_cap = RepeatedCapability(self._base.group_name, 'repcap_channelBw_get', 'repcap_channelBw_set', repcap.ChannelBw.Bw14)
+		self._cmd_group = CommandsGroup("channelBw", core, parent)
+		self._cmd_group.rep_cap = RepeatedCapability(self._cmd_group.group_name, 'repcap_channelBw_get', 'repcap_channelBw_set', repcap.ChannelBw.Bw14)
 
-	def repcap_channelBw_set(self, enum_value: repcap.ChannelBw) -> None:
+	def repcap_channelBw_set(self, channelBw: repcap.ChannelBw) -> None:
 		"""Repeated Capability default value numeric suffix.
 		This value is used, if you do not explicitely set it in the child set/get methods, or if you leave it to ChannelBw.Default
 		Default value after init: ChannelBw.Bw14"""
-		self._base.set_repcap_enum_value(enum_value)
+		self._cmd_group.set_repcap_enum_value(channelBw)
 
 	def repcap_channelBw_get(self) -> repcap.ChannelBw:
 		"""Returns the current default repeated capability for the child set/get methods"""
 		# noinspection PyTypeChecker
-		return self._base.get_repcap_enum_value()
+		return self._cmd_group.get_repcap_enum_value()
+
+	def set(self, relative_level: float or bool, absolute_level: float or bool, utraAdjChannel=repcap.UtraAdjChannel.Default, channelBw=repcap.ChannelBw.Default) -> None:
+		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:ACLR:UTRA<nr>:CBANdwidth<Band> \n
+		Snippet: driver.configure.lteMeas.multiEval.limit.aclr.utra.channelBw.set(relative_level = 1.0, absolute_level = 1.0, utraAdjChannel = repcap.UtraAdjChannel.Default, channelBw = repcap.ChannelBw.Default) \n
+		Defines relative and absolute limits for the ACLR measured in the first or second adjacent UTRA channel, depending on
+		<no>. The settings are defined separately for each channel bandwidth. \n
+			:param relative_level: (float or boolean) No help available
+			:param absolute_level: (float or boolean) No help available
+			:param utraAdjChannel: optional repeated capability selector. Default value: Ch1 (settable in the interface 'Utra')
+			:param channelBw: optional repeated capability selector. Default value: Bw14 (settable in the interface 'ChannelBw')
+		"""
+		param = ArgSingleList().compose_cmd_string(ArgSingle('relative_level', relative_level, DataType.FloatExt), ArgSingle('absolute_level', absolute_level, DataType.FloatExt))
+		utraAdjChannel_cmd_val = self._cmd_group.get_repcap_cmd_value(utraAdjChannel, repcap.UtraAdjChannel)
+		channelBw_cmd_val = self._cmd_group.get_repcap_cmd_value(channelBw, repcap.ChannelBw)
+		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:ACLR:UTRA{utraAdjChannel_cmd_val}:CBANdwidth{channelBw_cmd_val} {param}'.rstrip())
 
 	# noinspection PyTypeChecker
 	class ChannelBwStruct(StructBase):
-		"""Structure for setting input parameters. Fields: \n
+		"""Response structure. Fields: \n
 			- Relative_Level: float or bool: No parameter help available
 			- Absolute_Level: float or bool: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_float_ext('Relative_Level'),
 			ArgStruct.scalar_float_ext('Absolute_Level')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Relative_Level: float or bool = None
 			self.Absolute_Level: float or bool = None
 
-	def set(self, structure: ChannelBwStruct, utraAdjChannel=repcap.UtraAdjChannel.Default, channelBw=repcap.ChannelBw.Default) -> None:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:ACLR:UTRA<nr>:CBANdwidth<Band> \n
-		Snippet: driver.configure.multiEval.limit.aclr.utra.channelBw.set(value = [PROPERTY_STRUCT_NAME](), utraAdjChannel = repcap.UtraAdjChannel.Default, channelBw = repcap.ChannelBw.Default) \n
-		Defines relative and absolute limits for the ACLR measured in the first or second adjacent UTRA channel, depending on
-		<no>. The settings are defined separately for each channel bandwidth. \n
-			:param structure: for set value, see the help for ChannelBwStruct structure arguments.
-			:param utraAdjChannel: optional repeated capability selector. Default value: Ch1 (settable in the interface 'Utra')
-			:param channelBw: optional repeated capability selector. Default value: Bw14 (settable in the interface 'ChannelBw')"""
-		utraAdjChannel_cmd_val = self._base.get_repcap_cmd_value(utraAdjChannel, repcap.UtraAdjChannel)
-		channelBw_cmd_val = self._base.get_repcap_cmd_value(channelBw, repcap.ChannelBw)
-		self._core.io.write_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:ACLR:UTRA{utraAdjChannel_cmd_val}:CBANdwidth{channelBw_cmd_val}', structure)
-
 	def get(self, utraAdjChannel=repcap.UtraAdjChannel.Default, channelBw=repcap.ChannelBw.Default) -> ChannelBwStruct:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:ACLR:UTRA<nr>:CBANdwidth<Band> \n
-		Snippet: value: ChannelBwStruct = driver.configure.multiEval.limit.aclr.utra.channelBw.get(utraAdjChannel = repcap.UtraAdjChannel.Default, channelBw = repcap.ChannelBw.Default) \n
+		Snippet: value: ChannelBwStruct = driver.configure.lteMeas.multiEval.limit.aclr.utra.channelBw.get(utraAdjChannel = repcap.UtraAdjChannel.Default, channelBw = repcap.ChannelBw.Default) \n
 		Defines relative and absolute limits for the ACLR measured in the first or second adjacent UTRA channel, depending on
 		<no>. The settings are defined separately for each channel bandwidth. \n
 			:param utraAdjChannel: optional repeated capability selector. Default value: Ch1 (settable in the interface 'Utra')
 			:param channelBw: optional repeated capability selector. Default value: Bw14 (settable in the interface 'ChannelBw')
 			:return: structure: for return value, see the help for ChannelBwStruct structure arguments."""
-		utraAdjChannel_cmd_val = self._base.get_repcap_cmd_value(utraAdjChannel, repcap.UtraAdjChannel)
-		channelBw_cmd_val = self._base.get_repcap_cmd_value(channelBw, repcap.ChannelBw)
+		utraAdjChannel_cmd_val = self._cmd_group.get_repcap_cmd_value(utraAdjChannel, repcap.UtraAdjChannel)
+		channelBw_cmd_val = self._cmd_group.get_repcap_cmd_value(channelBw, repcap.ChannelBw)
 		return self._core.io.query_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:ACLR:UTRA{utraAdjChannel_cmd_val}:CBANdwidth{channelBw_cmd_val}?', self.__class__.ChannelBwStruct())
 
-	def clone(self) -> 'ChannelBw':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'ChannelBwCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = ChannelBw(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = ChannelBwCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Limit_/Pdynamics.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/SeMask/Margin/Current/__init__.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,27 +1,35 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
+from .........Internal.Core import Core
+from .........Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Pdynamics:
-	"""Pdynamics commands group definition. 1 total commands, 1 Sub-groups, 0 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 2 total commands, 2 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("pdynamics", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	@property
-	def channelBw(self):
-		"""channelBw commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_channelBw'):
-			from .Pdynamics_.ChannelBw import ChannelBw
-			self._channelBw = ChannelBw(self._core, self._base)
-		return self._channelBw
+	def negativ(self):
+		"""negativ commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_negativ'):
+			from .Negativ import NegativCls
+			self._negativ = NegativCls(self._core, self._cmd_group)
+		return self._negativ
 
-	def clone(self) -> 'Pdynamics':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	@property
+	def positiv(self):
+		"""positiv commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_positiv'):
+			from .Positiv import PositivCls
+			self._positiv = PositivCls(self._core, self._cmd_group)
+		return self._positiv
+
+	def clone(self) -> 'CurrentCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Pdynamics(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = CurrentCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Limit_/Pdynamics_/ChannelBw.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Modulation/EwLength/ChannelBw.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,76 +1,74 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.StructBase import StructBase
-from ......Internal.ArgStruct import ArgStruct
-from ......Internal.RepeatedCapability import RepeatedCapability
-from ...... import repcap
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal.Types import DataType
+from .......Internal.StructBase import StructBase
+from .......Internal.ArgStruct import ArgStruct
+from .......Internal.ArgSingleList import ArgSingleList
+from .......Internal.ArgSingle import ArgSingle
+from .......Internal.RepeatedCapability import RepeatedCapability
+from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class ChannelBw:
-	"""ChannelBw commands group definition. 1 total commands, 0 Sub-groups, 1 group commands
+class ChannelBwCls:
+	"""ChannelBw commands group definition. 1 total commands, 0 Subgroups, 1 group commands
 	Repeated Capability: ChannelBw, default value after init: ChannelBw.Bw14"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("channelBw", core, parent)
-		self._base.rep_cap = RepeatedCapability(self._base.group_name, 'repcap_channelBw_get', 'repcap_channelBw_set', repcap.ChannelBw.Bw14)
+		self._cmd_group = CommandsGroup("channelBw", core, parent)
+		self._cmd_group.rep_cap = RepeatedCapability(self._cmd_group.group_name, 'repcap_channelBw_get', 'repcap_channelBw_set', repcap.ChannelBw.Bw14)
 
-	def repcap_channelBw_set(self, enum_value: repcap.ChannelBw) -> None:
+	def repcap_channelBw_set(self, channelBw: repcap.ChannelBw) -> None:
 		"""Repeated Capability default value numeric suffix.
 		This value is used, if you do not explicitely set it in the child set/get methods, or if you leave it to ChannelBw.Default
 		Default value after init: ChannelBw.Bw14"""
-		self._base.set_repcap_enum_value(enum_value)
+		self._cmd_group.set_repcap_enum_value(channelBw)
 
 	def repcap_channelBw_get(self) -> repcap.ChannelBw:
 		"""Returns the current default repeated capability for the child set/get methods"""
 		# noinspection PyTypeChecker
-		return self._base.get_repcap_enum_value()
+		return self._cmd_group.get_repcap_enum_value()
+
+	def set(self, cyc_prefix_normal: int, cyc_prefix_extend: int, channelBw=repcap.ChannelBw.Default) -> None:
+		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:MODulation:EWLength:CBANdwidth<Band> \n
+		Snippet: driver.configure.lteMeas.multiEval.modulation.ewLength.channelBw.set(cyc_prefix_normal = 1, cyc_prefix_extend = 1, channelBw = repcap.ChannelBw.Default) \n
+		Specifies the EVM window length in samples for a selected channel bandwidth, depending on the cyclic prefix (CP) type. \n
+			:param cyc_prefix_normal: Samples for normal CP
+			:param cyc_prefix_extend: Samples for extended CP
+			:param channelBw: optional repeated capability selector. Default value: Bw14 (settable in the interface 'ChannelBw')
+		"""
+		param = ArgSingleList().compose_cmd_string(ArgSingle('cyc_prefix_normal', cyc_prefix_normal, DataType.Integer), ArgSingle('cyc_prefix_extend', cyc_prefix_extend, DataType.Integer))
+		channelBw_cmd_val = self._cmd_group.get_repcap_cmd_value(channelBw, repcap.ChannelBw)
+		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:MODulation:EWLength:CBANdwidth{channelBw_cmd_val} {param}'.rstrip())
 
 	# noinspection PyTypeChecker
 	class ChannelBwStruct(StructBase):
-		"""Structure for setting input parameters. Fields: \n
-			- Enable: bool: OFF: disables the limit check ON: enables the limit check
-			- On_Power_Upper: float: Upper limit for the 'ON power'
-			- On_Power_Lower: float: Lower limit for the 'ON power'
-			- Off_Power_Upper: float: Upper limit for the 'OFF power' and the 'SRS OFF' power"""
+		"""Response structure. Fields: \n
+			- Cyc_Prefix_Normal: int: Samples for normal CP
+			- Cyc_Prefix_Extend: int: Samples for extended CP"""
 		__meta_args_list = [
-			ArgStruct.scalar_bool('Enable'),
-			ArgStruct.scalar_float('On_Power_Upper'),
-			ArgStruct.scalar_float('On_Power_Lower'),
-			ArgStruct.scalar_float('Off_Power_Upper')]
+			ArgStruct.scalar_int('Cyc_Prefix_Normal'),
+			ArgStruct.scalar_int('Cyc_Prefix_Extend')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
-			self.Enable: bool = None
-			self.On_Power_Upper: float = None
-			self.On_Power_Lower: float = None
-			self.Off_Power_Upper: float = None
-
-	def set(self, structure: ChannelBwStruct, channelBw=repcap.ChannelBw.Default) -> None:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:PDYNamics:CBANdwidth<Band> \n
-		Snippet: driver.configure.multiEval.limit.pdynamics.channelBw.set(value = [PROPERTY_STRUCT_NAME](), channelBw = repcap.ChannelBw.Default) \n
-		Defines limits for the ON power and OFF power determined with the power dynamics measurement. Separate limits can be
-		defined for each channel bandwidth. \n
-			:param structure: for set value, see the help for ChannelBwStruct structure arguments.
-			:param channelBw: optional repeated capability selector. Default value: Bw14 (settable in the interface 'ChannelBw')"""
-		channelBw_cmd_val = self._base.get_repcap_cmd_value(channelBw, repcap.ChannelBw)
-		self._core.io.write_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:PDYNamics:CBANdwidth{channelBw_cmd_val}', structure)
+			self.Cyc_Prefix_Normal: int = None
+			self.Cyc_Prefix_Extend: int = None
 
 	def get(self, channelBw=repcap.ChannelBw.Default) -> ChannelBwStruct:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:PDYNamics:CBANdwidth<Band> \n
-		Snippet: value: ChannelBwStruct = driver.configure.multiEval.limit.pdynamics.channelBw.get(channelBw = repcap.ChannelBw.Default) \n
-		Defines limits for the ON power and OFF power determined with the power dynamics measurement. Separate limits can be
-		defined for each channel bandwidth. \n
+		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:MODulation:EWLength:CBANdwidth<Band> \n
+		Snippet: value: ChannelBwStruct = driver.configure.lteMeas.multiEval.modulation.ewLength.channelBw.get(channelBw = repcap.ChannelBw.Default) \n
+		Specifies the EVM window length in samples for a selected channel bandwidth, depending on the cyclic prefix (CP) type. \n
 			:param channelBw: optional repeated capability selector. Default value: Bw14 (settable in the interface 'ChannelBw')
 			:return: structure: for return value, see the help for ChannelBwStruct structure arguments."""
-		channelBw_cmd_val = self._base.get_repcap_cmd_value(channelBw, repcap.ChannelBw)
-		return self._core.io.query_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:PDYNamics:CBANdwidth{channelBw_cmd_val}?', self.__class__.ChannelBwStruct())
+		channelBw_cmd_val = self._cmd_group.get_repcap_cmd_value(channelBw, repcap.ChannelBw)
+		return self._core.io.query_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:MODulation:EWLength:CBANdwidth{channelBw_cmd_val}?', self.__class__.ChannelBwStruct())
 
-	def clone(self) -> 'ChannelBw':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'ChannelBwCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = ChannelBw(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = ChannelBwCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Limit_/Qam.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Limit/Qam/__init__.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,98 +1,98 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
-from .....Internal.RepeatedCapability import RepeatedCapability
-from ..... import repcap
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal.RepeatedCapability import RepeatedCapability
+from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Qam:
-	"""Qam commands group definition. 9 total commands, 8 Sub-groups, 0 group commands
+class QamCls:
+	"""Qam commands group definition. 9 total commands, 8 Subgroups, 0 group commands
 	Repeated Capability: QAMmodOrder, default value after init: QAMmodOrder.Qam16"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("qam", core, parent)
-		self._base.rep_cap = RepeatedCapability(self._base.group_name, 'repcap_qAMmodOrder_get', 'repcap_qAMmodOrder_set', repcap.QAMmodOrder.Qam16)
+		self._cmd_group = CommandsGroup("qam", core, parent)
+		self._cmd_group.rep_cap = RepeatedCapability(self._cmd_group.group_name, 'repcap_qAMmodOrder_get', 'repcap_qAMmodOrder_set', repcap.QAMmodOrder.Qam16)
 
-	def repcap_qAMmodOrder_set(self, enum_value: repcap.QAMmodOrder) -> None:
+	def repcap_qAMmodOrder_set(self, qAMmodOrder: repcap.QAMmodOrder) -> None:
 		"""Repeated Capability default value numeric suffix.
 		This value is used, if you do not explicitely set it in the child set/get methods, or if you leave it to QAMmodOrder.Default
 		Default value after init: QAMmodOrder.Qam16"""
-		self._base.set_repcap_enum_value(enum_value)
+		self._cmd_group.set_repcap_enum_value(qAMmodOrder)
 
 	def repcap_qAMmodOrder_get(self) -> repcap.QAMmodOrder:
 		"""Returns the current default repeated capability for the child set/get methods"""
 		# noinspection PyTypeChecker
-		return self._base.get_repcap_enum_value()
+		return self._cmd_group.get_repcap_enum_value()
 
 	@property
 	def evMagnitude(self):
 		"""evMagnitude commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_evMagnitude'):
-			from .Qam_.EvMagnitude import EvMagnitude
-			self._evMagnitude = EvMagnitude(self._core, self._base)
+			from .EvMagnitude import EvMagnitudeCls
+			self._evMagnitude = EvMagnitudeCls(self._core, self._cmd_group)
 		return self._evMagnitude
 
 	@property
 	def merror(self):
 		"""merror commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_merror'):
-			from .Qam_.Merror import Merror
-			self._merror = Merror(self._core, self._base)
+			from .Merror import MerrorCls
+			self._merror = MerrorCls(self._core, self._cmd_group)
 		return self._merror
 
 	@property
 	def perror(self):
 		"""perror commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_perror'):
-			from .Qam_.Perror import Perror
-			self._perror = Perror(self._core, self._base)
+			from .Perror import PerrorCls
+			self._perror = PerrorCls(self._core, self._cmd_group)
 		return self._perror
 
 	@property
 	def freqError(self):
 		"""freqError commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_freqError'):
-			from .Qam_.FreqError import FreqError
-			self._freqError = FreqError(self._core, self._base)
+			from .FreqError import FreqErrorCls
+			self._freqError = FreqErrorCls(self._core, self._cmd_group)
 		return self._freqError
 
 	@property
 	def iqOffset(self):
 		"""iqOffset commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_iqOffset'):
-			from .Qam_.IqOffset import IqOffset
-			self._iqOffset = IqOffset(self._core, self._base)
+			from .IqOffset import IqOffsetCls
+			self._iqOffset = IqOffsetCls(self._core, self._cmd_group)
 		return self._iqOffset
 
 	@property
 	def ibe(self):
 		"""ibe commands group. 1 Sub-classes, 1 commands."""
 		if not hasattr(self, '_ibe'):
-			from .Qam_.Ibe import Ibe
-			self._ibe = Ibe(self._core, self._base)
+			from .Ibe import IbeCls
+			self._ibe = IbeCls(self._core, self._cmd_group)
 		return self._ibe
 
 	@property
 	def sflatness(self):
 		"""sflatness commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_sflatness'):
-			from .Qam_.Sflatness import Sflatness
-			self._sflatness = Sflatness(self._core, self._base)
+			from .Sflatness import SflatnessCls
+			self._sflatness = SflatnessCls(self._core, self._cmd_group)
 		return self._sflatness
 
 	@property
 	def esFlatness(self):
 		"""esFlatness commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_esFlatness'):
-			from .Qam_.EsFlatness import EsFlatness
-			self._esFlatness = EsFlatness(self._core, self._base)
+			from .EsFlatness import EsFlatnessCls
+			self._esFlatness = EsFlatnessCls(self._core, self._cmd_group)
 		return self._esFlatness
 
-	def clone(self) -> 'Qam':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'QamCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Qam(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = QamCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Limit_/Qam_/EsFlatness.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Limit/Qam/EsFlatness.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,21 +1,21 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.StructBase import StructBase
-from ......Internal.ArgStruct import ArgStruct
-from ...... import repcap
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal.StructBase import StructBase
+from .......Internal.ArgStruct import ArgStruct
+from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class EsFlatness:
-	"""EsFlatness commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class EsFlatnessCls:
+	"""EsFlatness commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("esFlatness", core, parent)
+		self._cmd_group = CommandsGroup("esFlatness", core, parent)
 
 	# noinspection PyTypeChecker
 	class EsFlatnessStruct(StructBase):
 		"""Structure for setting input parameters. Fields: \n
 			- Enable: bool: OFF: disables the limit check ON: enables the limit check
 			- Range_1: float: Upper limit for max(range 1) - min(range 1)
 			- Range_2: float: Upper limit for max(range 2) - min(range 2)
@@ -37,22 +37,31 @@
 			self.Range_2: float = None
 			self.Max_1_Min_2: float = None
 			self.Max_2_Min_1: float = None
 			self.Edge_Frequency: float = None
 
 	def set(self, structure: EsFlatnessStruct, qAMmodOrder=repcap.QAMmodOrder.Default) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QAM<ModOrder>:ESFLatness \n
-		Snippet: driver.configure.multiEval.limit.qam.esFlatness.set(value = [PROPERTY_STRUCT_NAME](), qAMmodOrder = repcap.QAMmodOrder.Default) \n
+		Snippet with structure: \n
+		structure = driver.configure.lteMeas.multiEval.limit.qam.esFlatness.EsFlatnessStruct() \n
+		structure.Enable: bool = False \n
+		structure.Range_1: float = 1.0 \n
+		structure.Range_2: float = 1.0 \n
+		structure.Max_1_Min_2: float = 1.0 \n
+		structure.Max_2_Min_1: float = 1.0 \n
+		structure.Edge_Frequency: float = 1.0 \n
+		driver.configure.lteMeas.multiEval.limit.qam.esFlatness.set(structure, qAMmodOrder = repcap.QAMmodOrder.Default) \n
 		Defines limits for the equalizer spectrum flatness, for QAM modulations. \n
 			:param structure: for set value, see the help for EsFlatnessStruct structure arguments.
-			:param qAMmodOrder: optional repeated capability selector. Default value: Qam16 (settable in the interface 'Qam')"""
-		qAMmodOrder_cmd_val = self._base.get_repcap_cmd_value(qAMmodOrder, repcap.QAMmodOrder)
+			:param qAMmodOrder: optional repeated capability selector. Default value: Qam16 (settable in the interface 'Qam')
+		"""
+		qAMmodOrder_cmd_val = self._cmd_group.get_repcap_cmd_value(qAMmodOrder, repcap.QAMmodOrder)
 		self._core.io.write_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QAM{qAMmodOrder_cmd_val}:ESFLatness', structure)
 
 	def get(self, qAMmodOrder=repcap.QAMmodOrder.Default) -> EsFlatnessStruct:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QAM<ModOrder>:ESFLatness \n
-		Snippet: value: EsFlatnessStruct = driver.configure.multiEval.limit.qam.esFlatness.get(qAMmodOrder = repcap.QAMmodOrder.Default) \n
+		Snippet: value: EsFlatnessStruct = driver.configure.lteMeas.multiEval.limit.qam.esFlatness.get(qAMmodOrder = repcap.QAMmodOrder.Default) \n
 		Defines limits for the equalizer spectrum flatness, for QAM modulations. \n
 			:param qAMmodOrder: optional repeated capability selector. Default value: Qam16 (settable in the interface 'Qam')
 			:return: structure: for return value, see the help for EsFlatnessStruct structure arguments."""
-		qAMmodOrder_cmd_val = self._base.get_repcap_cmd_value(qAMmodOrder, repcap.QAMmodOrder)
+		qAMmodOrder_cmd_val = self._cmd_group.get_repcap_cmd_value(qAMmodOrder, repcap.QAMmodOrder)
 		return self._core.io.query_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QAM{qAMmodOrder_cmd_val}:ESFLatness?', self.__class__.EsFlatnessStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Limit_/Qam_/EvMagnitude.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Limit/Qam/EvMagnitude.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,46 +1,52 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.StructBase import StructBase
-from ......Internal.ArgStruct import ArgStruct
-from ...... import repcap
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal.Types import DataType
+from .......Internal.StructBase import StructBase
+from .......Internal.ArgStruct import ArgStruct
+from .......Internal.ArgSingleList import ArgSingleList
+from .......Internal.ArgSingle import ArgSingle
+from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class EvMagnitude:
-	"""EvMagnitude commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class EvMagnitudeCls:
+	"""EvMagnitude commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("evMagnitude", core, parent)
+		self._cmd_group = CommandsGroup("evMagnitude", core, parent)
+
+	def set(self, rms: float or bool, peak: float or bool, qAMmodOrder=repcap.QAMmodOrder.Default) -> None:
+		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QAM<ModOrder>:EVMagnitude \n
+		Snippet: driver.configure.lteMeas.multiEval.limit.qam.evMagnitude.set(rms = 1.0, peak = 1.0, qAMmodOrder = repcap.QAMmodOrder.Default) \n
+		Defines upper limits for the RMS and peak values of the error vector magnitude (EVM) , for QAM modulations. \n
+			:param rms: (float or boolean) No help available
+			:param peak: (float or boolean) No help available
+			:param qAMmodOrder: optional repeated capability selector. Default value: Qam16 (settable in the interface 'Qam')
+		"""
+		param = ArgSingleList().compose_cmd_string(ArgSingle('rms', rms, DataType.FloatExt), ArgSingle('peak', peak, DataType.FloatExt))
+		qAMmodOrder_cmd_val = self._cmd_group.get_repcap_cmd_value(qAMmodOrder, repcap.QAMmodOrder)
+		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QAM{qAMmodOrder_cmd_val}:EVMagnitude {param}'.rstrip())
 
 	# noinspection PyTypeChecker
 	class EvMagnitudeStruct(StructBase):
-		"""Structure for setting input parameters. Fields: \n
+		"""Response structure. Fields: \n
 			- Rms: float or bool: No parameter help available
 			- Peak: float or bool: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_float_ext('Rms'),
 			ArgStruct.scalar_float_ext('Peak')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Rms: float or bool = None
 			self.Peak: float or bool = None
 
-	def set(self, structure: EvMagnitudeStruct, qAMmodOrder=repcap.QAMmodOrder.Default) -> None:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QAM<ModOrder>:EVMagnitude \n
-		Snippet: driver.configure.multiEval.limit.qam.evMagnitude.set(value = [PROPERTY_STRUCT_NAME](), qAMmodOrder = repcap.QAMmodOrder.Default) \n
-		Defines upper limits for the RMS and peak values of the error vector magnitude (EVM) , for QAM modulations. \n
-			:param structure: for set value, see the help for EvMagnitudeStruct structure arguments.
-			:param qAMmodOrder: optional repeated capability selector. Default value: Qam16 (settable in the interface 'Qam')"""
-		qAMmodOrder_cmd_val = self._base.get_repcap_cmd_value(qAMmodOrder, repcap.QAMmodOrder)
-		self._core.io.write_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QAM{qAMmodOrder_cmd_val}:EVMagnitude', structure)
-
 	def get(self, qAMmodOrder=repcap.QAMmodOrder.Default) -> EvMagnitudeStruct:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QAM<ModOrder>:EVMagnitude \n
-		Snippet: value: EvMagnitudeStruct = driver.configure.multiEval.limit.qam.evMagnitude.get(qAMmodOrder = repcap.QAMmodOrder.Default) \n
+		Snippet: value: EvMagnitudeStruct = driver.configure.lteMeas.multiEval.limit.qam.evMagnitude.get(qAMmodOrder = repcap.QAMmodOrder.Default) \n
 		Defines upper limits for the RMS and peak values of the error vector magnitude (EVM) , for QAM modulations. \n
 			:param qAMmodOrder: optional repeated capability selector. Default value: Qam16 (settable in the interface 'Qam')
 			:return: structure: for return value, see the help for EvMagnitudeStruct structure arguments."""
-		qAMmodOrder_cmd_val = self._base.get_repcap_cmd_value(qAMmodOrder, repcap.QAMmodOrder)
+		qAMmodOrder_cmd_val = self._cmd_group.get_repcap_cmd_value(qAMmodOrder, repcap.QAMmodOrder)
 		return self._core.io.query_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QAM{qAMmodOrder_cmd_val}:EVMagnitude?', self.__class__.EvMagnitudeStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Limit_/Qam_/FreqError.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Limit/Qam/FreqError.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,33 +1,34 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal import Conversions
-from ...... import repcap
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal import Conversions
+from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class FreqError:
-	"""FreqError commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class FreqErrorCls:
+	"""FreqError commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("freqError", core, parent)
+		self._cmd_group = CommandsGroup("freqError", core, parent)
 
 	def set(self, frequency_error: float or bool, qAMmodOrder=repcap.QAMmodOrder.Default) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QAM<ModOrder>:FERRor \n
-		Snippet: driver.configure.multiEval.limit.qam.freqError.set(frequency_error = 1.0, qAMmodOrder = repcap.QAMmodOrder.Default) \n
-		Defines an upper limit for the carrier frequency error, for QAM modulations. \n
-			:param frequency_error: No help available
-			:param qAMmodOrder: optional repeated capability selector. Default value: Qam16 (settable in the interface 'Qam')"""
+		Snippet: driver.configure.lteMeas.multiEval.limit.qam.freqError.set(frequency_error = 1.0, qAMmodOrder = repcap.QAMmodOrder.Default) \n
+		Defines an upper limit for the carrier frequency error for QAM modulations. \n
+			:param frequency_error: (float or boolean) No help available
+			:param qAMmodOrder: optional repeated capability selector. Default value: Qam16 (settable in the interface 'Qam')
+		"""
 		param = Conversions.decimal_or_bool_value_to_str(frequency_error)
-		qAMmodOrder_cmd_val = self._base.get_repcap_cmd_value(qAMmodOrder, repcap.QAMmodOrder)
+		qAMmodOrder_cmd_val = self._cmd_group.get_repcap_cmd_value(qAMmodOrder, repcap.QAMmodOrder)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QAM{qAMmodOrder_cmd_val}:FERRor {param}')
 
 	def get(self, qAMmodOrder=repcap.QAMmodOrder.Default) -> float or bool:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QAM<ModOrder>:FERRor \n
-		Snippet: value: float or bool = driver.configure.multiEval.limit.qam.freqError.get(qAMmodOrder = repcap.QAMmodOrder.Default) \n
-		Defines an upper limit for the carrier frequency error, for QAM modulations. \n
+		Snippet: value: float or bool = driver.configure.lteMeas.multiEval.limit.qam.freqError.get(qAMmodOrder = repcap.QAMmodOrder.Default) \n
+		Defines an upper limit for the carrier frequency error for QAM modulations. \n
 			:param qAMmodOrder: optional repeated capability selector. Default value: Qam16 (settable in the interface 'Qam')
-			:return: frequency_error: No help available"""
-		qAMmodOrder_cmd_val = self._base.get_repcap_cmd_value(qAMmodOrder, repcap.QAMmodOrder)
+			:return: frequency_error: (float or boolean) No help available"""
+		qAMmodOrder_cmd_val = self._cmd_group.get_repcap_cmd_value(qAMmodOrder, repcap.QAMmodOrder)
 		response = self._core.io.query_str(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QAM{qAMmodOrder_cmd_val}:FERRor?')
 		return Conversions.str_to_float_or_bool(response)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Limit_/Qam_/Ibe.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Limit/Qam/Sflatness.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,73 +1,67 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.StructBase import StructBase
-from ......Internal.ArgStruct import ArgStruct
-from ...... import repcap
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal.StructBase import StructBase
+from .......Internal.ArgStruct import ArgStruct
+from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Ibe:
-	"""Ibe commands group definition. 2 total commands, 1 Sub-groups, 1 group commands"""
+class SflatnessCls:
+	"""Sflatness commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("ibe", core, parent)
-
-	@property
-	def iqOffset(self):
-		"""iqOffset commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_iqOffset'):
-			from .Ibe_.IqOffset import IqOffset
-			self._iqOffset = IqOffset(self._core, self._base)
-		return self._iqOffset
+		self._cmd_group = CommandsGroup("sflatness", core, parent)
 
 	# noinspection PyTypeChecker
-	class IbeStruct(StructBase):
+	class SflatnessStruct(StructBase):
 		"""Structure for setting input parameters. Fields: \n
-			- Enable: bool: OFF: disables the limit check ON: enables the limit check
-			- Minimum: float: No parameter help available
-			- Evm: float: No parameter help available
-			- Rb_Power: float: No parameter help available
-			- Iq_Image: float: No parameter help available"""
+			- Enable: bool: No parameter help available
+			- Lower: float: No parameter help available
+			- Upper: float: No parameter help available
+			- Edge_Lower: float: No parameter help available
+			- Edge_Upper: float: No parameter help available
+			- Edge_Frequency: float: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_bool('Enable'),
-			ArgStruct.scalar_float('Minimum'),
-			ArgStruct.scalar_float('Evm'),
-			ArgStruct.scalar_float('Rb_Power'),
-			ArgStruct.scalar_float('Iq_Image')]
+			ArgStruct.scalar_float('Lower'),
+			ArgStruct.scalar_float('Upper'),
+			ArgStruct.scalar_float('Edge_Lower'),
+			ArgStruct.scalar_float('Edge_Upper'),
+			ArgStruct.scalar_float('Edge_Frequency')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Enable: bool = None
-			self.Minimum: float = None
-			self.Evm: float = None
-			self.Rb_Power: float = None
-			self.Iq_Image: float = None
-
-	def set(self, structure: IbeStruct, qAMmodOrder=repcap.QAMmodOrder.Default) -> None:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QAM<ModOrder>:IBE \n
-		Snippet: driver.configure.multiEval.limit.qam.ibe.set(value = [PROPERTY_STRUCT_NAME](), qAMmodOrder = repcap.QAMmodOrder.Default) \n
-		Defines parameters used for calculation of an upper limit for the inband emission, for QAM modulations, see 'Inband
-		Emissions Limits'. \n
-			:param structure: for set value, see the help for IbeStruct structure arguments.
-			:param qAMmodOrder: optional repeated capability selector. Default value: Qam16 (settable in the interface 'Qam')"""
-		qAMmodOrder_cmd_val = self._base.get_repcap_cmd_value(qAMmodOrder, repcap.QAMmodOrder)
-		self._core.io.write_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QAM{qAMmodOrder_cmd_val}:IBE', structure)
-
-	def get(self, qAMmodOrder=repcap.QAMmodOrder.Default) -> IbeStruct:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QAM<ModOrder>:IBE \n
-		Snippet: value: IbeStruct = driver.configure.multiEval.limit.qam.ibe.get(qAMmodOrder = repcap.QAMmodOrder.Default) \n
-		Defines parameters used for calculation of an upper limit for the inband emission, for QAM modulations, see 'Inband
-		Emissions Limits'. \n
+			self.Lower: float = None
+			self.Upper: float = None
+			self.Edge_Lower: float = None
+			self.Edge_Upper: float = None
+			self.Edge_Frequency: float = None
+
+	def set(self, structure: SflatnessStruct, qAMmodOrder=repcap.QAMmodOrder.Default) -> None:
+		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QAM<ModOrder>:SFLatness \n
+		Snippet with structure: \n
+		structure = driver.configure.lteMeas.multiEval.limit.qam.sflatness.SflatnessStruct() \n
+		structure.Enable: bool = False \n
+		structure.Lower: float = 1.0 \n
+		structure.Upper: float = 1.0 \n
+		structure.Edge_Lower: float = 1.0 \n
+		structure.Edge_Upper: float = 1.0 \n
+		structure.Edge_Frequency: float = 1.0 \n
+		driver.configure.lteMeas.multiEval.limit.qam.sflatness.set(structure, qAMmodOrder = repcap.QAMmodOrder.Default) \n
+		No command help available \n
+			:param structure: for set value, see the help for SflatnessStruct structure arguments.
+			:param qAMmodOrder: optional repeated capability selector. Default value: Qam16 (settable in the interface 'Qam')
+		"""
+		qAMmodOrder_cmd_val = self._cmd_group.get_repcap_cmd_value(qAMmodOrder, repcap.QAMmodOrder)
+		self._core.io.write_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QAM{qAMmodOrder_cmd_val}:SFLatness', structure)
+
+	def get(self, qAMmodOrder=repcap.QAMmodOrder.Default) -> SflatnessStruct:
+		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QAM<ModOrder>:SFLatness \n
+		Snippet: value: SflatnessStruct = driver.configure.lteMeas.multiEval.limit.qam.sflatness.get(qAMmodOrder = repcap.QAMmodOrder.Default) \n
+		No command help available \n
 			:param qAMmodOrder: optional repeated capability selector. Default value: Qam16 (settable in the interface 'Qam')
-			:return: structure: for return value, see the help for IbeStruct structure arguments."""
-		qAMmodOrder_cmd_val = self._base.get_repcap_cmd_value(qAMmodOrder, repcap.QAMmodOrder)
-		return self._core.io.query_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QAM{qAMmodOrder_cmd_val}:IBE?', self.__class__.IbeStruct())
-
-	def clone(self) -> 'Ibe':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
-		Also copies all the existing default Repeated Capabilities setting,
-		which you can change independently without affecting the original group"""
-		new_group = Ibe(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
-		return new_group
+			:return: structure: for return value, see the help for SflatnessStruct structure arguments."""
+		qAMmodOrder_cmd_val = self._cmd_group.get_repcap_cmd_value(qAMmodOrder, repcap.QAMmodOrder)
+		return self._core.io.query_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QAM{qAMmodOrder_cmd_val}:SFLatness?', self.__class__.SflatnessStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Limit_/Qam_/Ibe_/IqOffset.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Limit/Qam/Merror.py`

 * *Files 25% similar despite different names*

```diff
@@ -1,51 +1,52 @@
 from .......Internal.Core import Core
 from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal.Types import DataType
 from .......Internal.StructBase import StructBase
 from .......Internal.ArgStruct import ArgStruct
+from .......Internal.ArgSingleList import ArgSingleList
+from .......Internal.ArgSingle import ArgSingle
 from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class IqOffset:
-	"""IqOffset commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class MerrorCls:
+	"""Merror commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("iqOffset", core, parent)
+		self._cmd_group = CommandsGroup("merror", core, parent)
+
+	def set(self, rms: float or bool, peak: float or bool, qAMmodOrder=repcap.QAMmodOrder.Default) -> None:
+		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QAM<ModOrder>:MERRor \n
+		Snippet: driver.configure.lteMeas.multiEval.limit.qam.merror.set(rms = 1.0, peak = 1.0, qAMmodOrder = repcap.QAMmodOrder.Default) \n
+		Defines upper limits for the RMS and peak values of the magnitude error, for QAM modulations. \n
+			:param rms: (float or boolean) No help available
+			:param peak: (float or boolean) No help available
+			:param qAMmodOrder: optional repeated capability selector. Default value: Qam16 (settable in the interface 'Qam')
+		"""
+		param = ArgSingleList().compose_cmd_string(ArgSingle('rms', rms, DataType.FloatExt), ArgSingle('peak', peak, DataType.FloatExt))
+		qAMmodOrder_cmd_val = self._cmd_group.get_repcap_cmd_value(qAMmodOrder, repcap.QAMmodOrder)
+		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QAM{qAMmodOrder_cmd_val}:MERRor {param}'.rstrip())
 
 	# noinspection PyTypeChecker
-	class IqOffsetStruct(StructBase):
-		"""Structure for setting input parameters. Fields: \n
-			- Offset_1: float: Offset for high TX power range
-			- Offset_2: float: Offset for intermediate TX power range
-			- Offset_3: float: Offset for low TX power range"""
+	class MerrorStruct(StructBase):
+		"""Response structure. Fields: \n
+			- Rms: float or bool: No parameter help available
+			- Peak: float or bool: No parameter help available"""
 		__meta_args_list = [
-			ArgStruct.scalar_float('Offset_1'),
-			ArgStruct.scalar_float('Offset_2'),
-			ArgStruct.scalar_float('Offset_3')]
+			ArgStruct.scalar_float_ext('Rms'),
+			ArgStruct.scalar_float_ext('Peak')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
-			self.Offset_1: float = None
-			self.Offset_2: float = None
-			self.Offset_3: float = None
-
-	def set(self, structure: IqOffsetStruct, qAMmodOrder=repcap.QAMmodOrder.Default) -> None:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QAM<ModOrder>:IBE:IQOFfset \n
-		Snippet: driver.configure.multiEval.limit.qam.ibe.iqOffset.set(value = [PROPERTY_STRUCT_NAME](), qAMmodOrder = repcap.QAMmodOrder.Default) \n
-		Defines I/Q origin offset values used for calculation of an upper limit for the inband emission, for QAM modulations.
-		Three different values can be set for three TX power ranges, see 'Inband Emissions Limits'. \n
-			:param structure: for set value, see the help for IqOffsetStruct structure arguments.
-			:param qAMmodOrder: optional repeated capability selector. Default value: Qam16 (settable in the interface 'Qam')"""
-		qAMmodOrder_cmd_val = self._base.get_repcap_cmd_value(qAMmodOrder, repcap.QAMmodOrder)
-		self._core.io.write_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QAM{qAMmodOrder_cmd_val}:IBE:IQOFfset', structure)
-
-	def get(self, qAMmodOrder=repcap.QAMmodOrder.Default) -> IqOffsetStruct:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QAM<ModOrder>:IBE:IQOFfset \n
-		Snippet: value: IqOffsetStruct = driver.configure.multiEval.limit.qam.ibe.iqOffset.get(qAMmodOrder = repcap.QAMmodOrder.Default) \n
-		Defines I/Q origin offset values used for calculation of an upper limit for the inband emission, for QAM modulations.
-		Three different values can be set for three TX power ranges, see 'Inband Emissions Limits'. \n
+			self.Rms: float or bool = None
+			self.Peak: float or bool = None
+
+	def get(self, qAMmodOrder=repcap.QAMmodOrder.Default) -> MerrorStruct:
+		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QAM<ModOrder>:MERRor \n
+		Snippet: value: MerrorStruct = driver.configure.lteMeas.multiEval.limit.qam.merror.get(qAMmodOrder = repcap.QAMmodOrder.Default) \n
+		Defines upper limits for the RMS and peak values of the magnitude error, for QAM modulations. \n
 			:param qAMmodOrder: optional repeated capability selector. Default value: Qam16 (settable in the interface 'Qam')
-			:return: structure: for return value, see the help for IqOffsetStruct structure arguments."""
-		qAMmodOrder_cmd_val = self._base.get_repcap_cmd_value(qAMmodOrder, repcap.QAMmodOrder)
-		return self._core.io.query_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QAM{qAMmodOrder_cmd_val}:IBE:IQOFfset?', self.__class__.IqOffsetStruct())
+			:return: structure: for return value, see the help for MerrorStruct structure arguments."""
+		qAMmodOrder_cmd_val = self._cmd_group.get_repcap_cmd_value(qAMmodOrder, repcap.QAMmodOrder)
+		return self._core.io.query_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QAM{qAMmodOrder_cmd_val}:MERRor?', self.__class__.MerrorStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Limit_/Qam_/IqOffset.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Limit/Qam/Ibe/IqOffset.py`

 * *Files 23% similar despite different names*

```diff
@@ -1,54 +1,58 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.StructBase import StructBase
-from ......Internal.ArgStruct import ArgStruct
-from ...... import repcap
+from ........Internal.Core import Core
+from ........Internal.CommandsGroup import CommandsGroup
+from ........Internal.Types import DataType
+from ........Internal.StructBase import StructBase
+from ........Internal.ArgStruct import ArgStruct
+from ........Internal.ArgSingleList import ArgSingleList
+from ........Internal.ArgSingle import ArgSingle
+from ........ import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class IqOffset:
-	"""IqOffset commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class IqOffsetCls:
+	"""IqOffset commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("iqOffset", core, parent)
+		self._cmd_group = CommandsGroup("iqOffset", core, parent)
+
+	def set(self, offset_1: float, offset_2: float, offset_3: float, qAMmodOrder=repcap.QAMmodOrder.Default) -> None:
+		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QAM<ModOrder>:IBE:IQOFfset \n
+		Snippet: driver.configure.lteMeas.multiEval.limit.qam.ibe.iqOffset.set(offset_1 = 1.0, offset_2 = 1.0, offset_3 = 1.0, qAMmodOrder = repcap.QAMmodOrder.Default) \n
+		Defines I/Q origin offset values used for calculation of an upper limit for the in-band emission, for QAM modulations.
+		Three different values can be set for three TX power ranges, see 'In-band emissions limits'. \n
+			:param offset_1: Offset for high TX power range
+			:param offset_2: Offset for intermediate TX power range
+			:param offset_3: Offset for low TX power range
+			:param qAMmodOrder: optional repeated capability selector. Default value: Qam16 (settable in the interface 'Qam')
+		"""
+		param = ArgSingleList().compose_cmd_string(ArgSingle('offset_1', offset_1, DataType.Float), ArgSingle('offset_2', offset_2, DataType.Float), ArgSingle('offset_3', offset_3, DataType.Float))
+		qAMmodOrder_cmd_val = self._cmd_group.get_repcap_cmd_value(qAMmodOrder, repcap.QAMmodOrder)
+		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QAM{qAMmodOrder_cmd_val}:IBE:IQOFfset {param}'.rstrip())
 
 	# noinspection PyTypeChecker
 	class IqOffsetStruct(StructBase):
-		"""Structure for setting input parameters. Fields: \n
-			- Enable: bool: OFF: disables the limit check ON: enables the limit check
-			- Offset_1: float: I/Q origin offset limit for high TX power range
-			- Offset_2: float: I/Q origin offset limit for intermediate TX power range
-			- Offset_3: float: I/Q origin offset limit for low TX power range"""
+		"""Response structure. Fields: \n
+			- Offset_1: float: Offset for high TX power range
+			- Offset_2: float: Offset for intermediate TX power range
+			- Offset_3: float: Offset for low TX power range"""
 		__meta_args_list = [
-			ArgStruct.scalar_bool('Enable'),
 			ArgStruct.scalar_float('Offset_1'),
 			ArgStruct.scalar_float('Offset_2'),
 			ArgStruct.scalar_float('Offset_3')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
-			self.Enable: bool = None
 			self.Offset_1: float = None
 			self.Offset_2: float = None
 			self.Offset_3: float = None
 
-	def set(self, structure: IqOffsetStruct, qAMmodOrder=repcap.QAMmodOrder.Default) -> None:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QAM<ModOrder>:IQOFfset \n
-		Snippet: driver.configure.multiEval.limit.qam.iqOffset.set(value = [PROPERTY_STRUCT_NAME](), qAMmodOrder = repcap.QAMmodOrder.Default) \n
-		Defines upper limits for the I/Q origin offset, for QAM modulations. Three different I/Q origin offset limits can be set
-		for three TX power ranges. For details, see 'I/Q Origin Offset Limits'. \n
-			:param structure: for set value, see the help for IqOffsetStruct structure arguments.
-			:param qAMmodOrder: optional repeated capability selector. Default value: Qam16 (settable in the interface 'Qam')"""
-		qAMmodOrder_cmd_val = self._base.get_repcap_cmd_value(qAMmodOrder, repcap.QAMmodOrder)
-		self._core.io.write_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QAM{qAMmodOrder_cmd_val}:IQOFfset', structure)
-
 	def get(self, qAMmodOrder=repcap.QAMmodOrder.Default) -> IqOffsetStruct:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QAM<ModOrder>:IQOFfset \n
-		Snippet: value: IqOffsetStruct = driver.configure.multiEval.limit.qam.iqOffset.get(qAMmodOrder = repcap.QAMmodOrder.Default) \n
-		Defines upper limits for the I/Q origin offset, for QAM modulations. Three different I/Q origin offset limits can be set
-		for three TX power ranges. For details, see 'I/Q Origin Offset Limits'. \n
+		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QAM<ModOrder>:IBE:IQOFfset \n
+		Snippet: value: IqOffsetStruct = driver.configure.lteMeas.multiEval.limit.qam.ibe.iqOffset.get(qAMmodOrder = repcap.QAMmodOrder.Default) \n
+		Defines I/Q origin offset values used for calculation of an upper limit for the in-band emission, for QAM modulations.
+		Three different values can be set for three TX power ranges, see 'In-band emissions limits'. \n
 			:param qAMmodOrder: optional repeated capability selector. Default value: Qam16 (settable in the interface 'Qam')
 			:return: structure: for return value, see the help for IqOffsetStruct structure arguments."""
-		qAMmodOrder_cmd_val = self._base.get_repcap_cmd_value(qAMmodOrder, repcap.QAMmodOrder)
-		return self._core.io.query_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QAM{qAMmodOrder_cmd_val}:IQOFfset?', self.__class__.IqOffsetStruct())
+		qAMmodOrder_cmd_val = self._cmd_group.get_repcap_cmd_value(qAMmodOrder, repcap.QAMmodOrder)
+		return self._core.io.query_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QAM{qAMmodOrder_cmd_val}:IBE:IQOFfset?', self.__class__.IqOffsetStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Limit_/Qam_/Merror.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Limit/Qpsk/Perror.py`

 * *Files 23% similar despite different names*

```diff
@@ -1,46 +1,49 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.StructBase import StructBase
-from ......Internal.ArgStruct import ArgStruct
-from ...... import repcap
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal.Types import DataType
+from .......Internal.StructBase import StructBase
+from .......Internal.ArgStruct import ArgStruct
+from .......Internal.ArgSingleList import ArgSingleList
+from .......Internal.ArgSingle import ArgSingle
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Merror:
-	"""Merror commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class PerrorCls:
+	"""Perror commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("merror", core, parent)
+		self._cmd_group = CommandsGroup("perror", core, parent)
+
+	def set(self, rms: float or bool, peak: float or bool) -> None:
+		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QPSK:PERRor \n
+		Snippet: driver.configure.lteMeas.multiEval.limit.qpsk.perror.set(rms = 1.0, peak = 1.0) \n
+		Defines symmetric limits for the RMS and peak values of the phase error for QPSK. The limit check fails if the absolute
+		value of the measured phase error exceeds the specified limit. \n
+			:param rms: (float or boolean) No help available
+			:param peak: (float or boolean) No help available
+		"""
+		param = ArgSingleList().compose_cmd_string(ArgSingle('rms', rms, DataType.FloatExt), ArgSingle('peak', peak, DataType.FloatExt))
+		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QPSK:PERRor {param}'.rstrip())
 
 	# noinspection PyTypeChecker
-	class MerrorStruct(StructBase):
-		"""Structure for setting input parameters. Fields: \n
+	class PerrorStruct(StructBase):
+		"""Response structure. Fields: \n
 			- Rms: float or bool: No parameter help available
 			- Peak: float or bool: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_float_ext('Rms'),
 			ArgStruct.scalar_float_ext('Peak')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Rms: float or bool = None
 			self.Peak: float or bool = None
 
-	def set(self, structure: MerrorStruct, qAMmodOrder=repcap.QAMmodOrder.Default) -> None:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QAM<ModOrder>:MERRor \n
-		Snippet: driver.configure.multiEval.limit.qam.merror.set(value = [PROPERTY_STRUCT_NAME](), qAMmodOrder = repcap.QAMmodOrder.Default) \n
-		Defines upper limits for the RMS and peak values of the magnitude error, for QAM modulations. \n
-			:param structure: for set value, see the help for MerrorStruct structure arguments.
-			:param qAMmodOrder: optional repeated capability selector. Default value: Qam16 (settable in the interface 'Qam')"""
-		qAMmodOrder_cmd_val = self._base.get_repcap_cmd_value(qAMmodOrder, repcap.QAMmodOrder)
-		self._core.io.write_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QAM{qAMmodOrder_cmd_val}:MERRor', structure)
-
-	def get(self, qAMmodOrder=repcap.QAMmodOrder.Default) -> MerrorStruct:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QAM<ModOrder>:MERRor \n
-		Snippet: value: MerrorStruct = driver.configure.multiEval.limit.qam.merror.get(qAMmodOrder = repcap.QAMmodOrder.Default) \n
-		Defines upper limits for the RMS and peak values of the magnitude error, for QAM modulations. \n
-			:param qAMmodOrder: optional repeated capability selector. Default value: Qam16 (settable in the interface 'Qam')
-			:return: structure: for return value, see the help for MerrorStruct structure arguments."""
-		qAMmodOrder_cmd_val = self._base.get_repcap_cmd_value(qAMmodOrder, repcap.QAMmodOrder)
-		return self._core.io.query_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QAM{qAMmodOrder_cmd_val}:MERRor?', self.__class__.MerrorStruct())
+	def get(self) -> PerrorStruct:
+		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QPSK:PERRor \n
+		Snippet: value: PerrorStruct = driver.configure.lteMeas.multiEval.limit.qpsk.perror.get() \n
+		Defines symmetric limits for the RMS and peak values of the phase error for QPSK. The limit check fails if the absolute
+		value of the measured phase error exceeds the specified limit. \n
+			:return: structure: for return value, see the help for PerrorStruct structure arguments."""
+		return self._core.io.query_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QPSK:PERRor?', self.__class__.PerrorStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Limit_/Qam_/Perror.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Limit/Qam/Perror.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,48 +1,54 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.StructBase import StructBase
-from ......Internal.ArgStruct import ArgStruct
-from ...... import repcap
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal.Types import DataType
+from .......Internal.StructBase import StructBase
+from .......Internal.ArgStruct import ArgStruct
+from .......Internal.ArgSingleList import ArgSingleList
+from .......Internal.ArgSingle import ArgSingle
+from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Perror:
-	"""Perror commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class PerrorCls:
+	"""Perror commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("perror", core, parent)
+		self._cmd_group = CommandsGroup("perror", core, parent)
+
+	def set(self, rms: float or bool, peak: float or bool, qAMmodOrder=repcap.QAMmodOrder.Default) -> None:
+		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QAM<ModOrder>:PERRor \n
+		Snippet: driver.configure.lteMeas.multiEval.limit.qam.perror.set(rms = 1.0, peak = 1.0, qAMmodOrder = repcap.QAMmodOrder.Default) \n
+		Defines symmetric limits for the RMS and peak values of the phase error, for QAM modulations. The limit check fails if
+		the absolute value of the measured phase error exceeds the specified limit. \n
+			:param rms: (float or boolean) No help available
+			:param peak: (float or boolean) No help available
+			:param qAMmodOrder: optional repeated capability selector. Default value: Qam16 (settable in the interface 'Qam')
+		"""
+		param = ArgSingleList().compose_cmd_string(ArgSingle('rms', rms, DataType.FloatExt), ArgSingle('peak', peak, DataType.FloatExt))
+		qAMmodOrder_cmd_val = self._cmd_group.get_repcap_cmd_value(qAMmodOrder, repcap.QAMmodOrder)
+		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QAM{qAMmodOrder_cmd_val}:PERRor {param}'.rstrip())
 
 	# noinspection PyTypeChecker
 	class PerrorStruct(StructBase):
-		"""Structure for setting input parameters. Fields: \n
+		"""Response structure. Fields: \n
 			- Rms: float or bool: No parameter help available
 			- Peak: float or bool: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_float_ext('Rms'),
 			ArgStruct.scalar_float_ext('Peak')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Rms: float or bool = None
 			self.Peak: float or bool = None
 
-	def set(self, structure: PerrorStruct, qAMmodOrder=repcap.QAMmodOrder.Default) -> None:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QAM<ModOrder>:PERRor \n
-		Snippet: driver.configure.multiEval.limit.qam.perror.set(value = [PROPERTY_STRUCT_NAME](), qAMmodOrder = repcap.QAMmodOrder.Default) \n
-		Defines symmetric limits for the RMS and peak values of the phase error, for QAM modulations. The limit check fails if
-		the absolute value of the measured phase error exceeds the specified values. \n
-			:param structure: for set value, see the help for PerrorStruct structure arguments.
-			:param qAMmodOrder: optional repeated capability selector. Default value: Qam16 (settable in the interface 'Qam')"""
-		qAMmodOrder_cmd_val = self._base.get_repcap_cmd_value(qAMmodOrder, repcap.QAMmodOrder)
-		self._core.io.write_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QAM{qAMmodOrder_cmd_val}:PERRor', structure)
-
 	def get(self, qAMmodOrder=repcap.QAMmodOrder.Default) -> PerrorStruct:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QAM<ModOrder>:PERRor \n
-		Snippet: value: PerrorStruct = driver.configure.multiEval.limit.qam.perror.get(qAMmodOrder = repcap.QAMmodOrder.Default) \n
+		Snippet: value: PerrorStruct = driver.configure.lteMeas.multiEval.limit.qam.perror.get(qAMmodOrder = repcap.QAMmodOrder.Default) \n
 		Defines symmetric limits for the RMS and peak values of the phase error, for QAM modulations. The limit check fails if
-		the absolute value of the measured phase error exceeds the specified values. \n
+		the absolute value of the measured phase error exceeds the specified limit. \n
 			:param qAMmodOrder: optional repeated capability selector. Default value: Qam16 (settable in the interface 'Qam')
 			:return: structure: for return value, see the help for PerrorStruct structure arguments."""
-		qAMmodOrder_cmd_val = self._base.get_repcap_cmd_value(qAMmodOrder, repcap.QAMmodOrder)
+		qAMmodOrder_cmd_val = self._cmd_group.get_repcap_cmd_value(qAMmodOrder, repcap.QAMmodOrder)
 		return self._core.io.query_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QAM{qAMmodOrder_cmd_val}:PERRor?', self.__class__.PerrorStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Limit_/Qam_/Sflatness.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/InbandEmission/Scc/Margin/StandardDev.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,58 +1,48 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.StructBase import StructBase
-from ......Internal.ArgStruct import ArgStruct
-from ...... import repcap
+from .........Internal.Core import Core
+from .........Internal.CommandsGroup import CommandsGroup
+from .........Internal.StructBase import StructBase
+from .........Internal.ArgStruct import ArgStruct
+from ......... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Sflatness:
-	"""Sflatness commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class StandardDevCls:
+	"""StandardDev commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("sflatness", core, parent)
+		self._cmd_group = CommandsGroup("standardDev", core, parent)
 
 	# noinspection PyTypeChecker
-	class SflatnessStruct(StructBase):
-		"""Structure for setting input parameters. Fields: \n
-			- Enable: bool: No parameter help available
-			- Lower: float: No parameter help available
-			- Upper: float: No parameter help available
-			- Edge_Lower: float: No parameter help available
-			- Edge_Upper: float: No parameter help available
-			- Edge_Frequency: float: No parameter help available"""
+	class FetchStruct(StructBase):
+		"""Response structure. Fields: \n
+			- Reliability: int: No parameter help available
+			- Seg_Reliability: int: No parameter help available
+			- Statist_Expired: int: No parameter help available
+			- Out_Of_Tolerance: int: No parameter help available
+			- Margin: float: No parameter help available"""
 		__meta_args_list = [
-			ArgStruct.scalar_bool('Enable'),
-			ArgStruct.scalar_float('Lower'),
-			ArgStruct.scalar_float('Upper'),
-			ArgStruct.scalar_float('Edge_Lower'),
-			ArgStruct.scalar_float('Edge_Upper'),
-			ArgStruct.scalar_float('Edge_Frequency')]
+			ArgStruct.scalar_int('Reliability', 'Reliability'),
+			ArgStruct.scalar_int('Seg_Reliability'),
+			ArgStruct.scalar_int('Statist_Expired'),
+			ArgStruct.scalar_int('Out_Of_Tolerance'),
+			ArgStruct.scalar_float('Margin')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
-			self.Enable: bool = None
-			self.Lower: float = None
-			self.Upper: float = None
-			self.Edge_Lower: float = None
-			self.Edge_Upper: float = None
-			self.Edge_Frequency: float = None
-
-	def set(self, structure: SflatnessStruct, qAMmodOrder=repcap.QAMmodOrder.Default) -> None:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QAM<ModOrder>:SFLatness \n
-		Snippet: driver.configure.multiEval.limit.qam.sflatness.set(value = [PROPERTY_STRUCT_NAME](), qAMmodOrder = repcap.QAMmodOrder.Default) \n
+			self.Reliability: int = None
+			self.Seg_Reliability: int = None
+			self.Statist_Expired: int = None
+			self.Out_Of_Tolerance: int = None
+			self.Margin: float = None
+
+	def fetch(self, segment=repcap.Segment.Default, secondaryCC=repcap.SecondaryCC.Default) -> FetchStruct:
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:IEMission:SCC<c>:MARGin:SDEViation \n
+		Snippet: value: FetchStruct = driver.lteMeas.multiEval.listPy.segment.inbandEmission.scc.margin.standardDev.fetch(segment = repcap.Segment.Default, secondaryCC = repcap.SecondaryCC.Default) \n
 		No command help available \n
-			:param structure: for set value, see the help for SflatnessStruct structure arguments.
-			:param qAMmodOrder: optional repeated capability selector. Default value: Qam16 (settable in the interface 'Qam')"""
-		qAMmodOrder_cmd_val = self._base.get_repcap_cmd_value(qAMmodOrder, repcap.QAMmodOrder)
-		self._core.io.write_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QAM{qAMmodOrder_cmd_val}:SFLatness', structure)
-
-	def get(self, qAMmodOrder=repcap.QAMmodOrder.Default) -> SflatnessStruct:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QAM<ModOrder>:SFLatness \n
-		Snippet: value: SflatnessStruct = driver.configure.multiEval.limit.qam.sflatness.get(qAMmodOrder = repcap.QAMmodOrder.Default) \n
-		No command help available \n
-			:param qAMmodOrder: optional repeated capability selector. Default value: Qam16 (settable in the interface 'Qam')
-			:return: structure: for return value, see the help for SflatnessStruct structure arguments."""
-		qAMmodOrder_cmd_val = self._base.get_repcap_cmd_value(qAMmodOrder, repcap.QAMmodOrder)
-		return self._core.io.query_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QAM{qAMmodOrder_cmd_val}:SFLatness?', self.__class__.SflatnessStruct())
+			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
+			:param secondaryCC: optional repeated capability selector. Default value: CC1 (settable in the interface 'Scc')
+			:return: structure: for return value, see the help for FetchStruct structure arguments."""
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
+		secondaryCC_cmd_val = self._cmd_group.get_repcap_cmd_value(secondaryCC, repcap.SecondaryCC)
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:IEMission:SCC{secondaryCC_cmd_val}:MARGin:SDEViation?', self.__class__.FetchStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Limit_/Qpsk.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/RsCMPX_LteMeas.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,262 +1,242 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
-from .....Internal import Conversions
-from .....Internal.StructBase import StructBase
-from .....Internal.ArgStruct import ArgStruct
+from typing import ClassVar, List
 
+from .Internal.Core import Core
+from .Internal.InstrumentErrors import RsInstrException
+from .Internal.CommandsGroup import CommandsGroup
+from .Internal.VisaSession import VisaSession
+from datetime import datetime, timedelta
+from . import repcap
+from .Internal.RepeatedCapability import RepeatedCapability
 
-# noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Qpsk:
-	"""Qpsk commands group definition. 9 total commands, 1 Sub-groups, 7 group commands"""
 
-	def __init__(self, core: Core, parent):
-		self._core = core
-		self._base = CommandsGroup("qpsk", core, parent)
+# noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
+class RsCMPX_LteMeas:
+	"""1037 total commands, 4 Subgroups, 0 group commands"""
+	_driver_options = "SupportedInstrModels = CMX/CMP/CMW/PVT, SupportedIdnPatterns = CMX/CMP/CMW/PVT, SimulationIdnString = 'Rohde&Schwarz,CMP180,100001,5.0.70.0014'"
+	_global_logging_relative_timestamp: ClassVar[datetime] = None
+	_global_logging_target_stream: ClassVar = None
+
+	def __init__(self, resource_name: str, id_query: bool = True, reset: bool = False, options: str = None, direct_session: object = None):
+		"""Initializes new RsCMPX_LteMeas session. \n
+		Parameter options tokens examples:
+			- ``Simulate=True`` - starts the session in simulation mode. Default: ``False``
+			- ``SelectVisa=socket`` - uses no VISA implementation for socket connections - you do not need any VISA-C installation
+			- ``SelectVisa=rs`` - forces usage of RohdeSchwarz Visa
+			- ``SelectVisa=ivi`` - forces usage of National Instruments Visa
+			- ``QueryInstrumentStatus = False`` - same as ``driver.utilities.instrument_status_checking = False``. Default: ``True``
+			- ``WriteDelay = 20, ReadDelay = 5`` - Introduces delay of 20ms before each write and 5ms before each read. Default: ``0ms`` for both
+			- ``OpcWaitMode = OpcQuery`` - mode for all the opc-synchronised write/reads. Other modes: StbPolling, StbPollingSlow, StbPollingSuperSlow. Default: ``StbPolling``
+			- ``AddTermCharToWriteBinBLock = True`` - Adds one additional LF to the end of the binary data (some instruments require that). Default: ``False``
+			- ``AssureWriteWithTermChar = True`` - Makes sure each command/query is terminated with termination character. Default: Interface dependent
+			- ``TerminationCharacter = "\\r"`` - Sets the termination character for reading. Default: ``\\n`` (LineFeed or LF)
+			- ``DataChunkSize = 10E3`` - Maximum size of one write/read segment. If transferred data is bigger, it is split to more segments. Default: ``1E6`` bytes
+			- ``OpcTimeout = 10000`` - same as driver.utilities.opc_timeout = 10000. Default: ``30000ms``
+			- ``VisaTimeout = 5000`` - same as driver.utilities.visa_timeout = 5000. Default: ``10000ms``
+			- ``ViClearExeMode = Disabled`` - viClear() execution mode. Default: ``execute_on_all``
+			- ``OpcQueryAfterWrite = True`` - same as driver.utilities.opc_query_after_write = True. Default: ``False``
+			- ``StbInErrorCheck = False`` - if true, the driver checks errors with *STB? If false, it uses SYST:ERR?. Default: ``True``
+			- ``ScpiQuotes = double'. - for SCPI commands, you can define how strings are quoted. With single or double quotes. Possible values: single | double | {char}. Default: ``single``
+			- ``LoggingMode = On`` - Sets the logging status right from the start. Default: ``Off``
+			- ``LoggingName = 'MyDevice'`` - Sets the name to represent the session in the log entries. Default: ``'resource_name'``
+			- ``LogToGlobalTarget = True`` - Sets the logging target to the class-property previously set with RsCMPX_LteMeas.set_global_logging_target() Default: ``False``
+			- ``LoggingToConsole = True`` - Immediately starts logging to the console. Default: False
+			- ``LoggingToUdp = True`` - Immediately starts logging to the UDP port. Default: False
+			- ``LoggingUdpPort = 49200`` - UDP port to log to. Default: 49200
+		:param resource_name: VISA resource name, e.g. 'TCPIP::192.168.2.1::INSTR'
+		:param id_query: if True, the instrument's model name is verified against the models supported by the driver and eventually throws an exception.
+		:param reset: Resets the instrument (sends *RST command) and clears its status sybsystem.
+		:param options: string tokens alternating the driver settings.
+		:param direct_session: Another driver object or pyVisa object to reuse the session instead of opening a new session."""
+		self._core = Core(resource_name, id_query, reset, RsCMPX_LteMeas._driver_options, options, direct_session)
+		self._core.driver_version = '5.0.70.0014'
+		self._options = options
+		self._add_all_global_repcaps()
+		self._custom_properties_init()
+		self.utilities.default_instrument_setup()
+		# noinspection PyTypeChecker
+		self._cmd_group = CommandsGroup("ROOT", self._core, None)
+
+	@classmethod
+	def from_existing_session(cls, session: object, options: str = None) -> 'RsCMPX_LteMeas':
+		"""Creates a new RsCMPX_LteMeas object with the entered 'session' reused. \n
+		:param session: can be another driver or a direct pyvisa session.
+		:param options: string tokens alternating the driver settings."""
+		# noinspection PyTypeChecker
+		resource_name = None
+		if hasattr(session, 'resource_name'):
+			resource_name = getattr(session, 'resource_name')
+		return cls(resource_name, False, False, options, session)
+		
+	@classmethod
+	def set_global_logging_target(cls, target) -> None:
+		"""Sets global common target stream that each instance can use. To use it, call the following: io.utilities.logger.set_logging_target_global().
+		If an instance uses global logging target, it automatically uses the global relative timestamp (if set).
+		You can set the target to None to invalidate it."""
+		cls._global_logging_target_stream = target
+
+	@classmethod
+	def get_global_logging_target(cls):
+		"""Returns global common target stream."""
+		return cls._global_logging_target_stream
+
+	@classmethod
+	def set_global_logging_relative_timestamp(cls, timestamp: datetime) -> None:
+		"""Sets global common relative timestamp for log entries. To use it, call the following: io.utilities.logger.set_relative_timestamp_global()"""
+		cls._global_logging_relative_timestamp = timestamp
+
+	@classmethod
+	def set_global_logging_relative_timestamp_now(cls) -> None:
+		"""Sets global common relative timestamp for log entries to this moment.
+		To use it, call the following: io.utilities.logger.set_relative_timestamp_global()."""
+		cls._global_logging_relative_timestamp = datetime.now()
+
+	@classmethod
+	def clear_global_logging_relative_timestamp(cls) -> None:
+		"""Clears the global relative timestamp. After this, all the instances using the global relative timestamp continue logging with the absolute timestamps."""
+		# noinspection PyTypeChecker
+		cls._global_logging_relative_timestamp = None
+
+	@classmethod
+	def get_global_logging_relative_timestamp(cls) -> datetime or None:
+		"""Returns global common relative timestamp for log entries."""
+		return cls._global_logging_relative_timestamp
+
+	def __str__(self) -> str:
+		if self._core.io:
+			return f"RsCMPX_LteMeas session '{self._core.io.resource_name}'"
+		else:
+			return f"RsCMPX_LteMeas with session closed"
+
+	def get_total_execution_time(self) -> timedelta:
+		"""Returns total time spent by the library on communicating with the instrument.
+		This time is always shorter than get_total_time(), since it does not include gaps between the communication.
+		You can reset this counter with reset_time_statistics()."""
+		return self._core.io.total_execution_time
+
+	def get_total_time(self) -> timedelta:
+		"""Returns total time spent by the library on communicating with the instrument.
+		This time is always shorter than get_total_time(), since it does not include gaps between the communication.
+		You can reset this counter with reset_time_statistics()."""
+		return datetime.now() - self._core.io.total_time_startpoint
+
+	def reset_time_statistics(self) -> None:
+		"""Resets all execution and total time counters. Affects the results of get_total_time() and get_total_execution_time()"""
+		self._core.io.reset_time_statistics()
+
+	@staticmethod
+	def assert_minimum_version(min_version: str) -> None:
+		"""Asserts that the driver version fulfills the minimum required version you have entered.
+		This way you make sure your installed driver is of the entered version or newer."""
+		min_version_list = min_version.split('.')
+		curr_version_list = '5.0.70.0014'.split('.')
+		count_min = len(min_version_list)
+		count_curr = len(curr_version_list)
+		count = count_min if count_min < count_curr else count_curr
+		for i in range(count):
+			minimum = int(min_version_list[i])
+			curr = int(curr_version_list[i])
+			if curr > minimum:
+				break
+			if curr < minimum:
+				raise RsInstrException(f"Assertion for minimum RsCMPX_LteMeas version failed. Current version: '5.0.70.0014', minimum required version: '{min_version}'")
+
+	@staticmethod
+	def list_resources(expression: str = '?*::INSTR', visa_select: str = None) -> List[str]:
+		"""Finds all the resources defined by the expression
+			- '?*' - matches all the available instruments
+			- 'USB::?*' - matches all the USB instruments
+			- 'TCPIP::192?*' - matches all the LAN instruments with the IP address starting with 192
+		:param expression: see the examples in the function
+		:param visa_select: optional parameter selecting a specific VISA. Examples: '@ivi', '@rs'
+		"""
+		rm = VisaSession.get_resource_manager(visa_select)
+		resources = rm.list_resources(expression)
+		rm.close()
+		# noinspection PyTypeChecker
+		return resources
+
+	def close(self) -> None:
+		"""Closes the active RsCMPX_LteMeas session."""
+		self._core.io.close()
+
+	def get_session_handle(self) -> object:
+		"""Returns the underlying session handle."""
+		return self._core.get_session_handle()
+
+	def _add_all_global_repcaps(self) -> None:
+		"""Adds all the repcaps defined as global to the instrument's global repcaps dictionary."""
+		self._core.io.add_global_repcap('<Instance>', RepeatedCapability("ROOT", 'repcap_instance_get', 'repcap_instance_set', repcap.Instance.Inst1))
+
+	def repcap_instance_get(self) -> repcap.Instance:
+		"""Returns Global Repeated capability Instance"""
+		return self._core.io.get_global_repcap_value('<Instance>')
+
+	def repcap_instance_set(self, value: repcap.Instance) -> None:
+		"""Sets Global Repeated capability Instance
+		Default value after init: Instance.Inst1"""
+		self._core.io.set_global_repcap_value('<Instance>', value)
+
+	def _custom_properties_init(self) -> None:
+		"""Adds all the interfaces that are custom for the driver."""
+		from .CustomFiles.utilities import Utilities
+		self.utilities = Utilities(self._core)
+		from .CustomFiles.events import Events
+		self.events = Events(self._core)
+		from .CustomFiles.reliability import Reliability
+		self.reliability = Reliability(self._core)
+		
+	def _sync_to_custom_properties(self, cloned: 'RsCMPX_LteMeas') -> None:
+		"""Synchronises the state of all the custom properties to the entered object."""
+		cloned.utilities.sync_from(self.utilities)
+		cloned.events.sync_from(self.events)
+		cloned.reliability.sync_from(self.reliability)
 
 	@property
-	def ibe(self):
-		"""ibe commands group. 0 Sub-classes, 2 commands."""
-		if not hasattr(self, '_ibe'):
-			from .Qpsk_.Ibe import Ibe
-			self._ibe = Ibe(self._core, self._base)
-		return self._ibe
-
-	# noinspection PyTypeChecker
-	class EvMagnitudeStruct(StructBase):
-		"""Structure for reading output parameters. Fields: \n
-			- Rms: float or bool: No parameter help available
-			- Peak: float or bool: No parameter help available"""
-		__meta_args_list = [
-			ArgStruct.scalar_float_ext('Rms'),
-			ArgStruct.scalar_float_ext('Peak')]
-
-		def __init__(self):
-			StructBase.__init__(self, self)
-			self.Rms: float or bool = None
-			self.Peak: float or bool = None
-
-	def get_ev_magnitude(self) -> EvMagnitudeStruct:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QPSK:EVMagnitude \n
-		Snippet: value: EvMagnitudeStruct = driver.configure.multiEval.limit.qpsk.get_ev_magnitude() \n
-		Defines upper limits for the RMS and peak values of the error vector magnitude (EVM) for QPSK. \n
-			:return: structure: for return value, see the help for EvMagnitudeStruct structure arguments.
-		"""
-		return self._core.io.query_struct('CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QPSK:EVMagnitude?', self.__class__.EvMagnitudeStruct())
-
-	def set_ev_magnitude(self, value: EvMagnitudeStruct) -> None:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QPSK:EVMagnitude \n
-		Snippet: driver.configure.multiEval.limit.qpsk.set_ev_magnitude(value = EvMagnitudeStruct()) \n
-		Defines upper limits for the RMS and peak values of the error vector magnitude (EVM) for QPSK. \n
-			:param value: see the help for EvMagnitudeStruct structure arguments.
-		"""
-		self._core.io.write_struct('CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QPSK:EVMagnitude', value)
-
-	# noinspection PyTypeChecker
-	class MerrorStruct(StructBase):
-		"""Structure for reading output parameters. Fields: \n
-			- Rms: float or bool: No parameter help available
-			- Peak: float or bool: No parameter help available"""
-		__meta_args_list = [
-			ArgStruct.scalar_float_ext('Rms'),
-			ArgStruct.scalar_float_ext('Peak')]
-
-		def __init__(self):
-			StructBase.__init__(self, self)
-			self.Rms: float or bool = None
-			self.Peak: float or bool = None
-
-	def get_merror(self) -> MerrorStruct:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QPSK:MERRor \n
-		Snippet: value: MerrorStruct = driver.configure.multiEval.limit.qpsk.get_merror() \n
-		Defines upper limits for the RMS and peak values of the magnitude error for QPSK. \n
-			:return: structure: for return value, see the help for MerrorStruct structure arguments.
-		"""
-		return self._core.io.query_struct('CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QPSK:MERRor?', self.__class__.MerrorStruct())
-
-	def set_merror(self, value: MerrorStruct) -> None:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QPSK:MERRor \n
-		Snippet: driver.configure.multiEval.limit.qpsk.set_merror(value = MerrorStruct()) \n
-		Defines upper limits for the RMS and peak values of the magnitude error for QPSK. \n
-			:param value: see the help for MerrorStruct structure arguments.
-		"""
-		self._core.io.write_struct('CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QPSK:MERRor', value)
-
-	# noinspection PyTypeChecker
-	class PerrorStruct(StructBase):
-		"""Structure for reading output parameters. Fields: \n
-			- Rms: float or bool: No parameter help available
-			- Peak: float or bool: No parameter help available"""
-		__meta_args_list = [
-			ArgStruct.scalar_float_ext('Rms'),
-			ArgStruct.scalar_float_ext('Peak')]
-
-		def __init__(self):
-			StructBase.__init__(self, self)
-			self.Rms: float or bool = None
-			self.Peak: float or bool = None
-
-	def get_perror(self) -> PerrorStruct:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QPSK:PERRor \n
-		Snippet: value: PerrorStruct = driver.configure.multiEval.limit.qpsk.get_perror() \n
-		Defines symmetric limits for the RMS and peak values of the phase error for QPSK. The limit check fails if the absolute
-		value of the measured phase error exceeds the specified values. \n
-			:return: structure: for return value, see the help for PerrorStruct structure arguments.
-		"""
-		return self._core.io.query_struct('CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QPSK:PERRor?', self.__class__.PerrorStruct())
-
-	def set_perror(self, value: PerrorStruct) -> None:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QPSK:PERRor \n
-		Snippet: driver.configure.multiEval.limit.qpsk.set_perror(value = PerrorStruct()) \n
-		Defines symmetric limits for the RMS and peak values of the phase error for QPSK. The limit check fails if the absolute
-		value of the measured phase error exceeds the specified values. \n
-			:param value: see the help for PerrorStruct structure arguments.
-		"""
-		self._core.io.write_struct('CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QPSK:PERRor', value)
-
-	def get_freq_error(self) -> float or bool:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QPSK:FERRor \n
-		Snippet: value: float or bool = driver.configure.multiEval.limit.qpsk.get_freq_error() \n
-		Defines an upper limit for the carrier frequency error (QPSK modulation) . \n
-			:return: frequency_error: No help available
-		"""
-		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QPSK:FERRor?')
-		return Conversions.str_to_float_or_bool(response)
+	def configure(self):
+		"""configure commands group. 1 Sub-classes, 0 commands."""
+		if not hasattr(self, '_configure'):
+			from .Implementations.Configure import ConfigureCls
+			self._configure = ConfigureCls(self._core, self._cmd_group)
+		return self._configure
 
-	def set_freq_error(self, frequency_error: float or bool) -> None:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QPSK:FERRor \n
-		Snippet: driver.configure.multiEval.limit.qpsk.set_freq_error(frequency_error = 1.0) \n
-		Defines an upper limit for the carrier frequency error (QPSK modulation) . \n
-			:param frequency_error: No help available
-		"""
-		param = Conversions.decimal_or_bool_value_to_str(frequency_error)
-		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QPSK:FERRor {param}')
-
-	# noinspection PyTypeChecker
-	class IqOffsetStruct(StructBase):
-		"""Structure for reading output parameters. Fields: \n
-			- Enable: bool: OFF: disables the limit check ON: enables the limit check
-			- Offset_1: float: I/Q origin offset limit for high TX power range
-			- Offset_2: float: I/Q origin offset limit for intermediate TX power range
-			- Offset_3: float: I/Q origin offset limit for low TX power range"""
-		__meta_args_list = [
-			ArgStruct.scalar_bool('Enable'),
-			ArgStruct.scalar_float('Offset_1'),
-			ArgStruct.scalar_float('Offset_2'),
-			ArgStruct.scalar_float('Offset_3')]
-
-		def __init__(self):
-			StructBase.__init__(self, self)
-			self.Enable: bool = None
-			self.Offset_1: float = None
-			self.Offset_2: float = None
-			self.Offset_3: float = None
-
-	def get_iq_offset(self) -> IqOffsetStruct:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QPSK:IQOFfset \n
-		Snippet: value: IqOffsetStruct = driver.configure.multiEval.limit.qpsk.get_iq_offset() \n
-		Defines upper limits for the I/Q origin offset (QPSK modulation) . Three different I/Q origin offset limits can be set
-		for three TX power ranges. For details, see 'I/Q Origin Offset Limits'. \n
-			:return: structure: for return value, see the help for IqOffsetStruct structure arguments.
-		"""
-		return self._core.io.query_struct('CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QPSK:IQOFfset?', self.__class__.IqOffsetStruct())
-
-	def set_iq_offset(self, value: IqOffsetStruct) -> None:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QPSK:IQOFfset \n
-		Snippet: driver.configure.multiEval.limit.qpsk.set_iq_offset(value = IqOffsetStruct()) \n
-		Defines upper limits for the I/Q origin offset (QPSK modulation) . Three different I/Q origin offset limits can be set
-		for three TX power ranges. For details, see 'I/Q Origin Offset Limits'. \n
-			:param value: see the help for IqOffsetStruct structure arguments.
-		"""
-		self._core.io.write_struct('CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QPSK:IQOFfset', value)
-
-	# noinspection PyTypeChecker
-	class SflatnessStruct(StructBase):
-		"""Structure for reading output parameters. Fields: \n
-			- Enable: bool: No parameter help available
-			- Lower: float: No parameter help available
-			- Upper: float: No parameter help available
-			- Edge_Lower: float: No parameter help available
-			- Edge_Upper: float: No parameter help available
-			- Edge_Frequency: float: No parameter help available"""
-		__meta_args_list = [
-			ArgStruct.scalar_bool('Enable'),
-			ArgStruct.scalar_float('Lower'),
-			ArgStruct.scalar_float('Upper'),
-			ArgStruct.scalar_float('Edge_Lower'),
-			ArgStruct.scalar_float('Edge_Upper'),
-			ArgStruct.scalar_float('Edge_Frequency')]
-
-		def __init__(self):
-			StructBase.__init__(self, self)
-			self.Enable: bool = None
-			self.Lower: float = None
-			self.Upper: float = None
-			self.Edge_Lower: float = None
-			self.Edge_Upper: float = None
-			self.Edge_Frequency: float = None
-
-	def get_sflatness(self) -> SflatnessStruct:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QPSK:SFLatness \n
-		Snippet: value: SflatnessStruct = driver.configure.multiEval.limit.qpsk.get_sflatness() \n
-		No command help available \n
-			:return: structure: for return value, see the help for SflatnessStruct structure arguments.
-		"""
-		return self._core.io.query_struct('CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QPSK:SFLatness?', self.__class__.SflatnessStruct())
-
-	def set_sflatness(self, value: SflatnessStruct) -> None:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QPSK:SFLatness \n
-		Snippet: driver.configure.multiEval.limit.qpsk.set_sflatness(value = SflatnessStruct()) \n
-		No command help available \n
-			:param value: see the help for SflatnessStruct structure arguments.
-		"""
-		self._core.io.write_struct('CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QPSK:SFLatness', value)
-
-	# noinspection PyTypeChecker
-	class EsFlatnessStruct(StructBase):
-		"""Structure for reading output parameters. Fields: \n
-			- Enable: bool: OFF: disables the limit check ON: enables the limit check
-			- Range_1: float: Upper limit for max(range 1) - min(range 1)
-			- Range_2: float: Upper limit for max(range 2) - min(range 2)
-			- Max_1_Min_2: float: Upper limit for max(range 1) - min(range 2)
-			- Max_2_Min_1: float: Upper limit for max(range 2) - min(range 1)
-			- Edge_Frequency: float: Frequency band edge distance of border between range 1 and range 2"""
-		__meta_args_list = [
-			ArgStruct.scalar_bool('Enable'),
-			ArgStruct.scalar_float('Range_1'),
-			ArgStruct.scalar_float('Range_2'),
-			ArgStruct.scalar_float('Max_1_Min_2'),
-			ArgStruct.scalar_float('Max_2_Min_1'),
-			ArgStruct.scalar_float('Edge_Frequency')]
-
-		def __init__(self):
-			StructBase.__init__(self, self)
-			self.Enable: bool = None
-			self.Range_1: float = None
-			self.Range_2: float = None
-			self.Max_1_Min_2: float = None
-			self.Max_2_Min_1: float = None
-			self.Edge_Frequency: float = None
-
-	def get_es_flatness(self) -> EsFlatnessStruct:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QPSK:ESFLatness \n
-		Snippet: value: EsFlatnessStruct = driver.configure.multiEval.limit.qpsk.get_es_flatness() \n
-		Defines limits for the equalizer spectrum flatness (QPSK modulation) . \n
-			:return: structure: for return value, see the help for EsFlatnessStruct structure arguments.
-		"""
-		return self._core.io.query_struct('CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QPSK:ESFLatness?', self.__class__.EsFlatnessStruct())
+	@property
+	def sense(self):
+		"""sense commands group. 1 Sub-classes, 0 commands."""
+		if not hasattr(self, '_sense'):
+			from .Implementations.Sense import SenseCls
+			self._sense = SenseCls(self._core, self._cmd_group)
+		return self._sense
 
-	def set_es_flatness(self, value: EsFlatnessStruct) -> None:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QPSK:ESFLatness \n
-		Snippet: driver.configure.multiEval.limit.qpsk.set_es_flatness(value = EsFlatnessStruct()) \n
-		Defines limits for the equalizer spectrum flatness (QPSK modulation) . \n
-			:param value: see the help for EsFlatnessStruct structure arguments.
-		"""
-		self._core.io.write_struct('CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QPSK:ESFLatness', value)
+	@property
+	def lteMeas(self):
+		"""lteMeas commands group. 3 Sub-classes, 0 commands."""
+		if not hasattr(self, '_lteMeas'):
+			from .Implementations.LteMeas import LteMeasCls
+			self._lteMeas = LteMeasCls(self._core, self._cmd_group)
+		return self._lteMeas
 
-	def clone(self) -> 'Qpsk':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
-		Also copies all the existing default Repeated Capabilities setting,
-		which you can change independently without affecting the original group"""
-		new_group = Qpsk(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
-		return new_group
+	@property
+	def trigger(self):
+		"""trigger commands group. 1 Sub-classes, 0 commands."""
+		if not hasattr(self, '_trigger'):
+			from .Implementations.Trigger import TriggerCls
+			self._trigger = TriggerCls(self._core, self._cmd_group)
+		return self._trigger
+
+	def clone(self) -> 'RsCMPX_LteMeas':
+		"""Creates a deep copy of the RsCMPX_LteMeas object. Also copies:
+			- All the existing Global repeated capability values
+			- All the default group repeated capabilities setting \n
+		Does not check the *IDN? response, and does not perform Reset.
+		After cloning, you can set all the repeated capabilities settings independentely from the original group.
+		Calling close() on the new object does not close the original VISA session"""
+		cloned = RsCMPX_LteMeas.from_existing_session(self.get_session_handle(), self._options)
+		self._cmd_group.synchronize_repcaps(cloned)
+		cloned.repcap_instance_set(self.repcap_instance_get())
+		self._sync_to_custom_properties(cloned)
+		return cloned
+
+	def restore_all_repcaps_to_default(self) -> None:
+		"""Sets all the Group and Global repcaps to their initial values"""
+		self._cmd_group.restore_repcaps()
+		self.repcap_instance_set(repcap.Instance.Inst1)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Limit_/Qpsk_/Ibe.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Limit/Qam/IqOffset.py`

 * *Files 21% similar despite different names*

```diff
@@ -1,89 +1,62 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.StructBase import StructBase
-from ......Internal.ArgStruct import ArgStruct
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal.Types import DataType
+from .......Internal.StructBase import StructBase
+from .......Internal.ArgStruct import ArgStruct
+from .......Internal.ArgSingleList import ArgSingleList
+from .......Internal.ArgSingle import ArgSingle
+from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Ibe:
-	"""Ibe commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class IqOffsetCls:
+	"""IqOffset commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("ibe", core, parent)
+		self._cmd_group = CommandsGroup("iqOffset", core, parent)
+
+	def set(self, enable: bool, offset_1: float, offset_2: float, offset_3: float, qAMmodOrder=repcap.QAMmodOrder.Default) -> None:
+		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QAM<ModOrder>:IQOFfset \n
+		Snippet: driver.configure.lteMeas.multiEval.limit.qam.iqOffset.set(enable = False, offset_1 = 1.0, offset_2 = 1.0, offset_3 = 1.0, qAMmodOrder = repcap.QAMmodOrder.Default) \n
+		Defines upper limits for the I/Q origin offset for QAM modulations. Three different I/Q origin offset limits can be set
+		for three TX power ranges. For details, see 'I/Q origin offset limits'. \n
+			:param enable: OFF: disables the limit check ON: enables the limit check
+			:param offset_1: I/Q origin offset limit for high TX power range
+			:param offset_2: I/Q origin offset limit for intermediate TX power range
+			:param offset_3: I/Q origin offset limit for low TX power range
+			:param qAMmodOrder: optional repeated capability selector. Default value: Qam16 (settable in the interface 'Qam')
+		"""
+		param = ArgSingleList().compose_cmd_string(ArgSingle('enable', enable, DataType.Boolean), ArgSingle('offset_1', offset_1, DataType.Float), ArgSingle('offset_2', offset_2, DataType.Float), ArgSingle('offset_3', offset_3, DataType.Float))
+		qAMmodOrder_cmd_val = self._cmd_group.get_repcap_cmd_value(qAMmodOrder, repcap.QAMmodOrder)
+		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QAM{qAMmodOrder_cmd_val}:IQOFfset {param}'.rstrip())
 
 	# noinspection PyTypeChecker
 	class IqOffsetStruct(StructBase):
-		"""Structure for reading output parameters. Fields: \n
-			- Offset_1: float: Offset for high TX power range
-			- Offset_2: float: Offset for intermediate TX power range
-			- Offset_3: float: Offset for low TX power range"""
+		"""Response structure. Fields: \n
+			- Enable: bool: OFF: disables the limit check ON: enables the limit check
+			- Offset_1: float: I/Q origin offset limit for high TX power range
+			- Offset_2: float: I/Q origin offset limit for intermediate TX power range
+			- Offset_3: float: I/Q origin offset limit for low TX power range"""
 		__meta_args_list = [
+			ArgStruct.scalar_bool('Enable'),
 			ArgStruct.scalar_float('Offset_1'),
 			ArgStruct.scalar_float('Offset_2'),
 			ArgStruct.scalar_float('Offset_3')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
+			self.Enable: bool = None
 			self.Offset_1: float = None
 			self.Offset_2: float = None
 			self.Offset_3: float = None
 
-	def get_iq_offset(self) -> IqOffsetStruct:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QPSK:IBE:IQOFfset \n
-		Snippet: value: IqOffsetStruct = driver.configure.multiEval.limit.qpsk.ibe.get_iq_offset() \n
-		Defines I/Q origin offset values used for calculation of an upper limit for the inband emission (QPSK modulation) . Three
-		different values can be set for three TX power ranges, see 'Inband Emissions Limits'. \n
-			:return: structure: for return value, see the help for IqOffsetStruct structure arguments.
-		"""
-		return self._core.io.query_struct('CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QPSK:IBE:IQOFfset?', self.__class__.IqOffsetStruct())
-
-	def set_iq_offset(self, value: IqOffsetStruct) -> None:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QPSK:IBE:IQOFfset \n
-		Snippet: driver.configure.multiEval.limit.qpsk.ibe.set_iq_offset(value = IqOffsetStruct()) \n
-		Defines I/Q origin offset values used for calculation of an upper limit for the inband emission (QPSK modulation) . Three
-		different values can be set for three TX power ranges, see 'Inband Emissions Limits'. \n
-			:param value: see the help for IqOffsetStruct structure arguments.
-		"""
-		self._core.io.write_struct('CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QPSK:IBE:IQOFfset', value)
-
-	# noinspection PyTypeChecker
-	class ValueStruct(StructBase):
-		"""Structure for reading output parameters. Fields: \n
-			- Enable: bool: OFF: disables the limit check ON: enables the limit check
-			- Minimum: float: No parameter help available
-			- Evm: float: No parameter help available
-			- Rb_Power: float: No parameter help available
-			- Iq_Image: float: No parameter help available"""
-		__meta_args_list = [
-			ArgStruct.scalar_bool('Enable'),
-			ArgStruct.scalar_float('Minimum'),
-			ArgStruct.scalar_float('Evm'),
-			ArgStruct.scalar_float('Rb_Power'),
-			ArgStruct.scalar_float('Iq_Image')]
-
-		def __init__(self):
-			StructBase.__init__(self, self)
-			self.Enable: bool = None
-			self.Minimum: float = None
-			self.Evm: float = None
-			self.Rb_Power: float = None
-			self.Iq_Image: float = None
-
-	def get_value(self) -> ValueStruct:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QPSK:IBE \n
-		Snippet: value: ValueStruct = driver.configure.multiEval.limit.qpsk.ibe.get_value() \n
-		Defines parameters used for calculation of an upper limit for the inband emission (QPSK modulation) , see 'Inband
-		Emissions Limits'. \n
-			:return: structure: for return value, see the help for ValueStruct structure arguments.
-		"""
-		return self._core.io.query_struct('CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QPSK:IBE?', self.__class__.ValueStruct())
-
-	def set_value(self, value: ValueStruct) -> None:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QPSK:IBE \n
-		Snippet: driver.configure.multiEval.limit.qpsk.ibe.set_value(value = ValueStruct()) \n
-		Defines parameters used for calculation of an upper limit for the inband emission (QPSK modulation) , see 'Inband
-		Emissions Limits'. \n
-			:param value: see the help for ValueStruct structure arguments.
-		"""
-		self._core.io.write_struct('CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QPSK:IBE', value)
+	def get(self, qAMmodOrder=repcap.QAMmodOrder.Default) -> IqOffsetStruct:
+		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QAM<ModOrder>:IQOFfset \n
+		Snippet: value: IqOffsetStruct = driver.configure.lteMeas.multiEval.limit.qam.iqOffset.get(qAMmodOrder = repcap.QAMmodOrder.Default) \n
+		Defines upper limits for the I/Q origin offset for QAM modulations. Three different I/Q origin offset limits can be set
+		for three TX power ranges. For details, see 'I/Q origin offset limits'. \n
+			:param qAMmodOrder: optional repeated capability selector. Default value: Qam16 (settable in the interface 'Qam')
+			:return: structure: for return value, see the help for IqOffsetStruct structure arguments."""
+		qAMmodOrder_cmd_val = self._cmd_group.get_repcap_cmd_value(qAMmodOrder, repcap.QAMmodOrder)
+		return self._core.io.query_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QAM{qAMmodOrder_cmd_val}:IQOFfset?', self.__class__.IqOffsetStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Limit/SeMask/__init__.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,43 +1,43 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class SeMask:
-	"""SeMask commands group definition. 13 total commands, 3 Sub-groups, 0 group commands"""
+class SeMaskCls:
+	"""SeMask commands group definition. 13 total commands, 3 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("seMask", core, parent)
+		self._cmd_group = CommandsGroup("seMask", core, parent)
 
 	@property
 	def obwLimit(self):
 		"""obwLimit commands group. 2 Sub-classes, 0 commands."""
 		if not hasattr(self, '_obwLimit'):
-			from .SeMask_.ObwLimit import ObwLimit
-			self._obwLimit = ObwLimit(self._core, self._base)
+			from .ObwLimit import ObwLimitCls
+			self._obwLimit = ObwLimitCls(self._core, self._cmd_group)
 		return self._obwLimit
 
 	@property
 	def limit(self):
 		"""limit commands group. 3 Sub-classes, 0 commands."""
 		if not hasattr(self, '_limit'):
-			from .SeMask_.Limit import Limit
-			self._limit = Limit(self._core, self._base)
+			from .Limit import LimitCls
+			self._limit = LimitCls(self._core, self._cmd_group)
 		return self._limit
 
 	@property
 	def atTolerance(self):
 		"""atTolerance commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_atTolerance'):
-			from .SeMask_.AtTolerance import AtTolerance
-			self._atTolerance = AtTolerance(self._core, self._base)
+			from .AtTolerance import AtToleranceCls
+			self._atTolerance = AtToleranceCls(self._core, self._cmd_group)
 		return self._atTolerance
 
-	def clone(self) -> 'SeMask':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'SeMaskCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = SeMask(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = SeMaskCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/AtTolerance.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Limit/SeMask/AtTolerance.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,61 +1,62 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal import Conversions
-from ......Internal.RepeatedCapability import RepeatedCapability
-from ...... import repcap
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal import Conversions
+from .......Internal.RepeatedCapability import RepeatedCapability
+from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class AtTolerance:
-	"""AtTolerance commands group definition. 1 total commands, 0 Sub-groups, 1 group commands
+class AtToleranceCls:
+	"""AtTolerance commands group definition. 1 total commands, 0 Subgroups, 1 group commands
 	Repeated Capability: EutraBand, default value after init: EutraBand.Nr30"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("atTolerance", core, parent)
-		self._base.rep_cap = RepeatedCapability(self._base.group_name, 'repcap_eutraBand_get', 'repcap_eutraBand_set', repcap.EutraBand.Nr30)
+		self._cmd_group = CommandsGroup("atTolerance", core, parent)
+		self._cmd_group.rep_cap = RepeatedCapability(self._cmd_group.group_name, 'repcap_eutraBand_get', 'repcap_eutraBand_set', repcap.EutraBand.Nr30)
 
-	def repcap_eutraBand_set(self, enum_value: repcap.EutraBand) -> None:
+	def repcap_eutraBand_set(self, eutraBand: repcap.EutraBand) -> None:
 		"""Repeated Capability default value numeric suffix.
 		This value is used, if you do not explicitely set it in the child set/get methods, or if you leave it to EutraBand.Default
 		Default value after init: EutraBand.Nr30"""
-		self._base.set_repcap_enum_value(enum_value)
+		self._cmd_group.set_repcap_enum_value(eutraBand)
 
 	def repcap_eutraBand_get(self) -> repcap.EutraBand:
 		"""Returns the current default repeated capability for the child set/get methods"""
 		# noinspection PyTypeChecker
-		return self._base.get_repcap_enum_value()
+		return self._cmd_group.get_repcap_enum_value()
 
 	def set(self, add_test_tol: float, eutraBand=repcap.EutraBand.Default) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:SEMask:ATTolerance<EUTRAband> \n
-		Snippet: driver.configure.multiEval.limit.seMask.atTolerance.set(add_test_tol = 1.0, eutraBand = repcap.EutraBand.Default) \n
+		Snippet: driver.configure.lteMeas.multiEval.limit.seMask.atTolerance.set(add_test_tol = 1.0, eutraBand = repcap.EutraBand.Default) \n
 		Defines additional test tolerances for the emission masks. The tolerance is added to the power values of all general and
 		additional spectrum emission masks. A positive tolerance value relaxes the limits. For operating bands below 3 GHz, there
 		is no additional test tolerance. You can define different additional test tolerances for bands above 3 GHz and for bands
 		above 5 GHz. \n
 			:param add_test_tol: Additional test tolerance
-			:param eutraBand: optional repeated capability selector. Default value: Nr30 (settable in the interface 'AtTolerance')"""
+			:param eutraBand: optional repeated capability selector. Default value: Nr30 (settable in the interface 'AtTolerance')
+		"""
 		param = Conversions.decimal_value_to_str(add_test_tol)
-		eutraBand_cmd_val = self._base.get_repcap_cmd_value(eutraBand, repcap.EutraBand)
+		eutraBand_cmd_val = self._cmd_group.get_repcap_cmd_value(eutraBand, repcap.EutraBand)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:SEMask:ATTolerance{eutraBand_cmd_val} {param}')
 
 	def get(self, eutraBand=repcap.EutraBand.Default) -> float:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:SEMask:ATTolerance<EUTRAband> \n
-		Snippet: value: float = driver.configure.multiEval.limit.seMask.atTolerance.get(eutraBand = repcap.EutraBand.Default) \n
+		Snippet: value: float = driver.configure.lteMeas.multiEval.limit.seMask.atTolerance.get(eutraBand = repcap.EutraBand.Default) \n
 		Defines additional test tolerances for the emission masks. The tolerance is added to the power values of all general and
 		additional spectrum emission masks. A positive tolerance value relaxes the limits. For operating bands below 3 GHz, there
 		is no additional test tolerance. You can define different additional test tolerances for bands above 3 GHz and for bands
 		above 5 GHz. \n
 			:param eutraBand: optional repeated capability selector. Default value: Nr30 (settable in the interface 'AtTolerance')
 			:return: add_test_tol: Additional test tolerance"""
-		eutraBand_cmd_val = self._base.get_repcap_cmd_value(eutraBand, repcap.EutraBand)
+		eutraBand_cmd_val = self._cmd_group.get_repcap_cmd_value(eutraBand, repcap.EutraBand)
 		response = self._core.io.query_str(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:SEMask:ATTolerance{eutraBand_cmd_val}?')
 		return Conversions.str_to_float(response)
 
-	def clone(self) -> 'AtTolerance':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'AtToleranceCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = AtTolerance(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = AtToleranceCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/Limit.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Limit/SeMask/Limit/Additional/__init__.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,58 +1,50 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.RepeatedCapability import RepeatedCapability
-from ...... import repcap
+from .........Internal.Core import Core
+from .........Internal.CommandsGroup import CommandsGroup
+from .........Internal.RepeatedCapability import RepeatedCapability
+from ......... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Limit:
-	"""Limit commands group definition. 8 total commands, 3 Sub-groups, 0 group commands
-	Repeated Capability: Limit, default value after init: Limit.Nr1"""
+class AdditionalCls:
+	"""Additional commands group definition. 4 total commands, 2 Subgroups, 0 group commands
+	Repeated Capability: Table, default value after init: Table.Nr1"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("limit", core, parent)
-		self._base.rep_cap = RepeatedCapability(self._base.group_name, 'repcap_limit_get', 'repcap_limit_set', repcap.Limit.Nr1)
+		self._cmd_group = CommandsGroup("additional", core, parent)
+		self._cmd_group.rep_cap = RepeatedCapability(self._cmd_group.group_name, 'repcap_table_get', 'repcap_table_set', repcap.Table.Nr1)
 
-	def repcap_limit_set(self, enum_value: repcap.Limit) -> None:
+	def repcap_table_set(self, table: repcap.Table) -> None:
 		"""Repeated Capability default value numeric suffix.
-		This value is used, if you do not explicitely set it in the child set/get methods, or if you leave it to Limit.Default
-		Default value after init: Limit.Nr1"""
-		self._base.set_repcap_enum_value(enum_value)
+		This value is used, if you do not explicitely set it in the child set/get methods, or if you leave it to Table.Default
+		Default value after init: Table.Nr1"""
+		self._cmd_group.set_repcap_enum_value(table)
 
-	def repcap_limit_get(self) -> repcap.Limit:
+	def repcap_table_get(self) -> repcap.Table:
 		"""Returns the current default repeated capability for the child set/get methods"""
 		# noinspection PyTypeChecker
-		return self._base.get_repcap_enum_value()
+		return self._cmd_group.get_repcap_enum_value()
 
 	@property
 	def channelBw(self):
-		"""channelBw commands group. 0 Sub-classes, 1 commands."""
+		"""channelBw commands group. 1 Sub-classes, 1 commands."""
 		if not hasattr(self, '_channelBw'):
-			from .Limit_.ChannelBw import ChannelBw
-			self._channelBw = ChannelBw(self._core, self._base)
+			from .ChannelBw import ChannelBwCls
+			self._channelBw = ChannelBwCls(self._core, self._cmd_group)
 		return self._channelBw
 
 	@property
-	def additional(self):
-		"""additional commands group. 2 Sub-classes, 0 commands."""
-		if not hasattr(self, '_additional'):
-			from .Limit_.Additional import Additional
-			self._additional = Additional(self._core, self._base)
-		return self._additional
-
-	@property
 	def carrierAggregation(self):
 		"""carrierAggregation commands group. 2 Sub-classes, 0 commands."""
 		if not hasattr(self, '_carrierAggregation'):
-			from .Limit_.CarrierAggregation import CarrierAggregation
-			self._carrierAggregation = CarrierAggregation(self._core, self._base)
+			from .CarrierAggregation import CarrierAggregationCls
+			self._carrierAggregation = CarrierAggregationCls(self._core, self._cmd_group)
 		return self._carrierAggregation
 
-	def clone(self) -> 'Limit':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'AdditionalCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Limit(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = AdditionalCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/Limit_/Additional.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Limit/SeMask/Limit/__init__.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,50 +1,58 @@
-from .......Internal.Core import Core
-from .......Internal.CommandsGroup import CommandsGroup
-from .......Internal.RepeatedCapability import RepeatedCapability
-from ....... import repcap
+from ........Internal.Core import Core
+from ........Internal.CommandsGroup import CommandsGroup
+from ........Internal.RepeatedCapability import RepeatedCapability
+from ........ import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Additional:
-	"""Additional commands group definition. 4 total commands, 2 Sub-groups, 0 group commands
-	Repeated Capability: Table, default value after init: Table.Nr1"""
+class LimitCls:
+	"""Limit commands group definition. 8 total commands, 3 Subgroups, 0 group commands
+	Repeated Capability: Limit, default value after init: Limit.Nr1"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("additional", core, parent)
-		self._base.rep_cap = RepeatedCapability(self._base.group_name, 'repcap_table_get', 'repcap_table_set', repcap.Table.Nr1)
+		self._cmd_group = CommandsGroup("limit", core, parent)
+		self._cmd_group.rep_cap = RepeatedCapability(self._cmd_group.group_name, 'repcap_limit_get', 'repcap_limit_set', repcap.Limit.Nr1)
 
-	def repcap_table_set(self, enum_value: repcap.Table) -> None:
+	def repcap_limit_set(self, limit: repcap.Limit) -> None:
 		"""Repeated Capability default value numeric suffix.
-		This value is used, if you do not explicitely set it in the child set/get methods, or if you leave it to Table.Default
-		Default value after init: Table.Nr1"""
-		self._base.set_repcap_enum_value(enum_value)
+		This value is used, if you do not explicitely set it in the child set/get methods, or if you leave it to Limit.Default
+		Default value after init: Limit.Nr1"""
+		self._cmd_group.set_repcap_enum_value(limit)
 
-	def repcap_table_get(self) -> repcap.Table:
+	def repcap_limit_get(self) -> repcap.Limit:
 		"""Returns the current default repeated capability for the child set/get methods"""
 		# noinspection PyTypeChecker
-		return self._base.get_repcap_enum_value()
+		return self._cmd_group.get_repcap_enum_value()
 
 	@property
 	def channelBw(self):
-		"""channelBw commands group. 1 Sub-classes, 1 commands."""
+		"""channelBw commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_channelBw'):
-			from .Additional_.ChannelBw import ChannelBw
-			self._channelBw = ChannelBw(self._core, self._base)
+			from .ChannelBw import ChannelBwCls
+			self._channelBw = ChannelBwCls(self._core, self._cmd_group)
 		return self._channelBw
 
 	@property
+	def additional(self):
+		"""additional commands group. 2 Sub-classes, 0 commands."""
+		if not hasattr(self, '_additional'):
+			from .Additional import AdditionalCls
+			self._additional = AdditionalCls(self._core, self._cmd_group)
+		return self._additional
+
+	@property
 	def carrierAggregation(self):
 		"""carrierAggregation commands group. 2 Sub-classes, 0 commands."""
 		if not hasattr(self, '_carrierAggregation'):
-			from .Additional_.CarrierAggregation import CarrierAggregation
-			self._carrierAggregation = CarrierAggregation(self._core, self._base)
+			from .CarrierAggregation import CarrierAggregationCls
+			self._carrierAggregation = CarrierAggregationCls(self._core, self._cmd_group)
 		return self._carrierAggregation
 
-	def clone(self) -> 'Additional':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'LimitCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Additional(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = LimitCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/Limit_/Additional_/CarrierAggregation.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Limit/Aclr/Utra/CarrierAggregation/__init__.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,35 +1,35 @@
-from ........Internal.Core import Core
-from ........Internal.CommandsGroup import CommandsGroup
+from .........Internal.Core import Core
+from .........Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class CarrierAggregation:
-	"""CarrierAggregation commands group definition. 2 total commands, 2 Sub-groups, 0 group commands"""
+class CarrierAggregationCls:
+	"""CarrierAggregation commands group definition. 3 total commands, 2 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("carrierAggregation", core, parent)
+		self._cmd_group = CommandsGroup("carrierAggregation", core, parent)
 
 	@property
 	def channelBw1st(self):
 		"""channelBw1st commands group. 1 Sub-classes, 0 commands."""
 		if not hasattr(self, '_channelBw1st'):
-			from .CarrierAggregation_.ChannelBw1st import ChannelBw1st
-			self._channelBw1st = ChannelBw1st(self._core, self._base)
+			from .ChannelBw1st import ChannelBw1stCls
+			self._channelBw1st = ChannelBw1stCls(self._core, self._cmd_group)
 		return self._channelBw1st
 
 	@property
 	def ocombination(self):
 		"""ocombination commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_ocombination'):
-			from .CarrierAggregation_.Ocombination import Ocombination
-			self._ocombination = Ocombination(self._core, self._base)
+			from .Ocombination import OcombinationCls
+			self._ocombination = OcombinationCls(self._core, self._cmd_group)
 		return self._ocombination
 
-	def clone(self) -> 'CarrierAggregation':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'CarrierAggregationCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = CarrierAggregation(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = CarrierAggregationCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/Limit_/Additional_/CarrierAggregation_/ChannelBw1st.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Limit/Aclr/Utra/CarrierAggregation/ChannelBw1st/__init__.py`

 * *Files 11% similar despite different names*

```diff
@@ -1,42 +1,42 @@
-from .........Internal.Core import Core
-from .........Internal.CommandsGroup import CommandsGroup
-from .........Internal.RepeatedCapability import RepeatedCapability
-from ......... import repcap
+from ..........Internal.Core import Core
+from ..........Internal.CommandsGroup import CommandsGroup
+from ..........Internal.RepeatedCapability import RepeatedCapability
+from .......... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class ChannelBw1st:
-	"""ChannelBw1st commands group definition. 1 total commands, 1 Sub-groups, 0 group commands
+class ChannelBw1stCls:
+	"""ChannelBw1st commands group definition. 2 total commands, 1 Subgroups, 0 group commands
 	Repeated Capability: FirstChannelBw, default value after init: FirstChannelBw.Bw100"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("channelBw1st", core, parent)
-		self._base.rep_cap = RepeatedCapability(self._base.group_name, 'repcap_firstChannelBw_get', 'repcap_firstChannelBw_set', repcap.FirstChannelBw.Bw100)
+		self._cmd_group = CommandsGroup("channelBw1st", core, parent)
+		self._cmd_group.rep_cap = RepeatedCapability(self._cmd_group.group_name, 'repcap_firstChannelBw_get', 'repcap_firstChannelBw_set', repcap.FirstChannelBw.Bw100)
 
-	def repcap_firstChannelBw_set(self, enum_value: repcap.FirstChannelBw) -> None:
+	def repcap_firstChannelBw_set(self, firstChannelBw: repcap.FirstChannelBw) -> None:
 		"""Repeated Capability default value numeric suffix.
 		This value is used, if you do not explicitely set it in the child set/get methods, or if you leave it to FirstChannelBw.Default
 		Default value after init: FirstChannelBw.Bw100"""
-		self._base.set_repcap_enum_value(enum_value)
+		self._cmd_group.set_repcap_enum_value(firstChannelBw)
 
 	def repcap_firstChannelBw_get(self) -> repcap.FirstChannelBw:
 		"""Returns the current default repeated capability for the child set/get methods"""
 		# noinspection PyTypeChecker
-		return self._base.get_repcap_enum_value()
+		return self._cmd_group.get_repcap_enum_value()
 
 	@property
 	def channelBw2nd(self):
-		"""channelBw2nd commands group. 0 Sub-classes, 1 commands."""
+		"""channelBw2nd commands group. 1 Sub-classes, 1 commands."""
 		if not hasattr(self, '_channelBw2nd'):
-			from .ChannelBw1st_.ChannelBw2nd import ChannelBw2nd
-			self._channelBw2nd = ChannelBw2nd(self._core, self._base)
+			from .ChannelBw2nd import ChannelBw2ndCls
+			self._channelBw2nd = ChannelBw2ndCls(self._core, self._cmd_group)
 		return self._channelBw2nd
 
-	def clone(self) -> 'ChannelBw1st':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'ChannelBw1stCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = ChannelBw1st(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = ChannelBw1stCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/Limit_/Additional_/CarrierAggregation_/ChannelBw1st_/ChannelBw2nd.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Limit/SeMask/Limit/CarrierAggregation/ChannelBw1st/ChannelBw2nd/__init__.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,45 +1,78 @@
-from ..........Internal.Core import Core
-from ..........Internal.CommandsGroup import CommandsGroup
-from ..........Internal.StructBase import StructBase
-from ..........Internal.ArgStruct import ArgStruct
-from ..........Internal.RepeatedCapability import RepeatedCapability
-from .......... import enums
-from .......... import repcap
+from ...........Internal.Core import Core
+from ...........Internal.CommandsGroup import CommandsGroup
+from ...........Internal.Types import DataType
+from ...........Internal.StructBase import StructBase
+from ...........Internal.ArgStruct import ArgStruct
+from ...........Internal.ArgSingleList import ArgSingleList
+from ...........Internal.ArgSingle import ArgSingle
+from ...........Internal.RepeatedCapability import RepeatedCapability
+from ........... import enums
+from ........... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class ChannelBw2nd:
-	"""ChannelBw2nd commands group definition. 1 total commands, 0 Sub-groups, 1 group commands
+class ChannelBw2ndCls:
+	"""ChannelBw2nd commands group definition. 2 total commands, 1 Subgroups, 1 group commands
 	Repeated Capability: SecondChannelBw, default value after init: SecondChannelBw.Bw50"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("channelBw2nd", core, parent)
-		self._base.rep_cap = RepeatedCapability(self._base.group_name, 'repcap_secondChannelBw_get', 'repcap_secondChannelBw_set', repcap.SecondChannelBw.Bw50)
+		self._cmd_group = CommandsGroup("channelBw2nd", core, parent)
+		self._cmd_group.rep_cap = RepeatedCapability(self._cmd_group.group_name, 'repcap_secondChannelBw_get', 'repcap_secondChannelBw_set', repcap.SecondChannelBw.Bw50)
 
-	def repcap_secondChannelBw_set(self, enum_value: repcap.SecondChannelBw) -> None:
+	def repcap_secondChannelBw_set(self, secondChannelBw: repcap.SecondChannelBw) -> None:
 		"""Repeated Capability default value numeric suffix.
 		This value is used, if you do not explicitely set it in the child set/get methods, or if you leave it to SecondChannelBw.Default
 		Default value after init: SecondChannelBw.Bw50"""
-		self._base.set_repcap_enum_value(enum_value)
+		self._cmd_group.set_repcap_enum_value(secondChannelBw)
 
 	def repcap_secondChannelBw_get(self) -> repcap.SecondChannelBw:
 		"""Returns the current default repeated capability for the child set/get methods"""
 		# noinspection PyTypeChecker
-		return self._base.get_repcap_enum_value()
+		return self._cmd_group.get_repcap_enum_value()
+
+	@property
+	def channelBw3rd(self):
+		"""channelBw3rd commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_channelBw3rd'):
+			from .ChannelBw3rd import ChannelBw3rdCls
+			self._channelBw3rd = ChannelBw3rdCls(self._core, self._cmd_group)
+		return self._channelBw3rd
+
+	def set(self, enable: bool, frequency_start: float, frequency_end: float, level: float, rbw: enums.Rbw, limit=repcap.Limit.Default, firstChannelBw=repcap.FirstChannelBw.Default, secondChannelBw=repcap.SecondChannelBw.Default) -> None:
+		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:SEMask:LIMit<nr>:CAGGregation:CBANdwidth<Band1>:CBANdwidth<Band2> \n
+		Snippet: driver.configure.lteMeas.multiEval.limit.seMask.limit.carrierAggregation.channelBw1st.channelBw2nd.set(enable = False, frequency_start = 1.0, frequency_end = 1.0, level = 1.0, rbw = enums.Rbw.K030, limit = repcap.Limit.Default, firstChannelBw = repcap.FirstChannelBw.Default, secondChannelBw = repcap.SecondChannelBw.Default) \n
+		Defines general requirements for the emission mask area <no>. The activation state, the area borders, an upper limit and
+		the resolution bandwidth must be specified. The settings are defined separately for each channel bandwidth combination,
+		for two aggregated carriers. The following bandwidth combinations are supported: Example: For the first line in the
+		figure, use ...:CBANdwidth100:CBANdwidth50. \n
+			:param enable: OFF: Disables the check of these requirements. ON: Enables the check of these requirements.
+			:param frequency_start: Start frequency of the area, relative to the edges of the aggregated channel bandwidth.
+			:param frequency_end: Stop frequency of the area, relative to the edges of the aggregated channel bandwidth.
+			:param level: Upper limit for the area
+			:param rbw: Resolution bandwidth to be used for the area. K030: 30 kHz K100: 100 kHz M1: 1 MHz
+			:param limit: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Limit')
+			:param firstChannelBw: optional repeated capability selector. Default value: Bw100 (settable in the interface 'ChannelBw1st')
+			:param secondChannelBw: optional repeated capability selector. Default value: Bw50 (settable in the interface 'ChannelBw2nd')
+		"""
+		param = ArgSingleList().compose_cmd_string(ArgSingle('enable', enable, DataType.Boolean), ArgSingle('frequency_start', frequency_start, DataType.Float), ArgSingle('frequency_end', frequency_end, DataType.Float), ArgSingle('level', level, DataType.Float), ArgSingle('rbw', rbw, DataType.Enum, enums.Rbw))
+		limit_cmd_val = self._cmd_group.get_repcap_cmd_value(limit, repcap.Limit)
+		firstChannelBw_cmd_val = self._cmd_group.get_repcap_cmd_value(firstChannelBw, repcap.FirstChannelBw)
+		secondChannelBw_cmd_val = self._cmd_group.get_repcap_cmd_value(secondChannelBw, repcap.SecondChannelBw)
+		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:SEMask:LIMit{limit_cmd_val}:CAGGregation:CBANdwidth{firstChannelBw_cmd_val}:CBANdwidth{secondChannelBw_cmd_val} {param}'.rstrip())
 
 	# noinspection PyTypeChecker
 	class ChannelBw2ndStruct(StructBase):
-		"""Structure for setting input parameters. Fields: \n
-			- Enable: bool: OFF: disables the check of these requirements ON: enables the check of these requirements
-			- Frequency_Start: float: Start frequency of the area, relative to the edges of the aggregated channel bandwidth
-			- Frequency_End: float: Stop frequency of the area, relative to the edges of the aggregated channel bandwidth
+		"""Response structure. Fields: \n
+			- Enable: bool: OFF: Disables the check of these requirements. ON: Enables the check of these requirements.
+			- Frequency_Start: float: Start frequency of the area, relative to the edges of the aggregated channel bandwidth.
+			- Frequency_End: float: Stop frequency of the area, relative to the edges of the aggregated channel bandwidth.
 			- Level: float: Upper limit for the area
-			- Rbw: enums.Rbw: Resolution bandwidth to be used for the area K030: 30 kHz K100: 100 kHz M1: 1 MHz"""
+			- Rbw: enums.Rbw: Resolution bandwidth to be used for the area. K030: 30 kHz K100: 100 kHz M1: 1 MHz"""
 		__meta_args_list = [
 			ArgStruct.scalar_bool('Enable'),
 			ArgStruct.scalar_float('Frequency_Start'),
 			ArgStruct.scalar_float('Frequency_End'),
 			ArgStruct.scalar_float('Level'),
 			ArgStruct.scalar_enum('Rbw', enums.Rbw)]
 
@@ -47,50 +80,30 @@
 			StructBase.__init__(self, self)
 			self.Enable: bool = None
 			self.Frequency_Start: float = None
 			self.Frequency_End: float = None
 			self.Level: float = None
 			self.Rbw: enums.Rbw = None
 
-	def set(self, structure: ChannelBw2ndStruct, limit=repcap.Limit.Default, table=repcap.Table.Default, firstChannelBw=repcap.FirstChannelBw.Default, secondChannelBw=repcap.SecondChannelBw.Default) -> None:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:SEMask:LIMit<nr>:ADDitional<Table>:CAGGregation:CBANdwidth<Band1>:CBANdwidth<Band2> \n
-		Snippet: driver.configure.multiEval.limit.seMask.limit.additional.carrierAggregation.channelBw1st.channelBw2nd.set(value = [PROPERTY_STRUCT_NAME](), limit = repcap.Limit.Default, table = repcap.Table.Default, firstChannelBw = repcap.FirstChannelBw.Default, secondChannelBw = repcap.SecondChannelBw.Default) \n
-		Defines additional requirements for the emission mask area <no>. The activation state, the area borders, an upper limit
-		and the resolution bandwidth must be specified. The settings are defined separately for each channel bandwidth
-		combination, for two aggregated carriers. The following bandwidth combinations are supported: Example: For the first line
-		in the figure, use ...:CBANdwidth100:CBANdwidth50. \n
-			:param structure: for set value, see the help for ChannelBw2ndStruct structure arguments.
-			:param limit: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Limit')
-			:param table: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Additional')
-			:param firstChannelBw: optional repeated capability selector. Default value: Bw100 (settable in the interface 'ChannelBw1st')
-			:param secondChannelBw: optional repeated capability selector. Default value: Bw50 (settable in the interface 'ChannelBw2nd')"""
-		limit_cmd_val = self._base.get_repcap_cmd_value(limit, repcap.Limit)
-		table_cmd_val = self._base.get_repcap_cmd_value(table, repcap.Table)
-		firstChannelBw_cmd_val = self._base.get_repcap_cmd_value(firstChannelBw, repcap.FirstChannelBw)
-		secondChannelBw_cmd_val = self._base.get_repcap_cmd_value(secondChannelBw, repcap.SecondChannelBw)
-		self._core.io.write_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:SEMask:LIMit{limit_cmd_val}:ADDitional{table_cmd_val}:CAGGregation:CBANdwidth{firstChannelBw_cmd_val}:CBANdwidth{secondChannelBw_cmd_val}', structure)
-
-	def get(self, limit=repcap.Limit.Default, table=repcap.Table.Default, firstChannelBw=repcap.FirstChannelBw.Default, secondChannelBw=repcap.SecondChannelBw.Default) -> ChannelBw2ndStruct:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:SEMask:LIMit<nr>:ADDitional<Table>:CAGGregation:CBANdwidth<Band1>:CBANdwidth<Band2> \n
-		Snippet: value: ChannelBw2ndStruct = driver.configure.multiEval.limit.seMask.limit.additional.carrierAggregation.channelBw1st.channelBw2nd.get(limit = repcap.Limit.Default, table = repcap.Table.Default, firstChannelBw = repcap.FirstChannelBw.Default, secondChannelBw = repcap.SecondChannelBw.Default) \n
-		Defines additional requirements for the emission mask area <no>. The activation state, the area borders, an upper limit
-		and the resolution bandwidth must be specified. The settings are defined separately for each channel bandwidth
-		combination, for two aggregated carriers. The following bandwidth combinations are supported: Example: For the first line
-		in the figure, use ...:CBANdwidth100:CBANdwidth50. \n
+	def get(self, limit=repcap.Limit.Default, firstChannelBw=repcap.FirstChannelBw.Default, secondChannelBw=repcap.SecondChannelBw.Default) -> ChannelBw2ndStruct:
+		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:SEMask:LIMit<nr>:CAGGregation:CBANdwidth<Band1>:CBANdwidth<Band2> \n
+		Snippet: value: ChannelBw2ndStruct = driver.configure.lteMeas.multiEval.limit.seMask.limit.carrierAggregation.channelBw1st.channelBw2nd.get(limit = repcap.Limit.Default, firstChannelBw = repcap.FirstChannelBw.Default, secondChannelBw = repcap.SecondChannelBw.Default) \n
+		Defines general requirements for the emission mask area <no>. The activation state, the area borders, an upper limit and
+		the resolution bandwidth must be specified. The settings are defined separately for each channel bandwidth combination,
+		for two aggregated carriers. The following bandwidth combinations are supported: Example: For the first line in the
+		figure, use ...:CBANdwidth100:CBANdwidth50. \n
 			:param limit: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Limit')
-			:param table: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Additional')
 			:param firstChannelBw: optional repeated capability selector. Default value: Bw100 (settable in the interface 'ChannelBw1st')
 			:param secondChannelBw: optional repeated capability selector. Default value: Bw50 (settable in the interface 'ChannelBw2nd')
 			:return: structure: for return value, see the help for ChannelBw2ndStruct structure arguments."""
-		limit_cmd_val = self._base.get_repcap_cmd_value(limit, repcap.Limit)
-		table_cmd_val = self._base.get_repcap_cmd_value(table, repcap.Table)
-		firstChannelBw_cmd_val = self._base.get_repcap_cmd_value(firstChannelBw, repcap.FirstChannelBw)
-		secondChannelBw_cmd_val = self._base.get_repcap_cmd_value(secondChannelBw, repcap.SecondChannelBw)
-		return self._core.io.query_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:SEMask:LIMit{limit_cmd_val}:ADDitional{table_cmd_val}:CAGGregation:CBANdwidth{firstChannelBw_cmd_val}:CBANdwidth{secondChannelBw_cmd_val}?', self.__class__.ChannelBw2ndStruct())
+		limit_cmd_val = self._cmd_group.get_repcap_cmd_value(limit, repcap.Limit)
+		firstChannelBw_cmd_val = self._cmd_group.get_repcap_cmd_value(firstChannelBw, repcap.FirstChannelBw)
+		secondChannelBw_cmd_val = self._cmd_group.get_repcap_cmd_value(secondChannelBw, repcap.SecondChannelBw)
+		return self._core.io.query_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:SEMask:LIMit{limit_cmd_val}:CAGGregation:CBANdwidth{firstChannelBw_cmd_val}:CBANdwidth{secondChannelBw_cmd_val}?', self.__class__.ChannelBw2ndStruct())
 
-	def clone(self) -> 'ChannelBw2nd':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'ChannelBw2ndCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = ChannelBw2nd(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = ChannelBw2ndCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/Limit_/Additional_/CarrierAggregation_/Ocombination.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Limit/SeMask/Limit/CarrierAggregation/Ocombination.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,31 +1,51 @@
 from .........Internal.Core import Core
 from .........Internal.CommandsGroup import CommandsGroup
+from .........Internal.Types import DataType
 from .........Internal.StructBase import StructBase
 from .........Internal.ArgStruct import ArgStruct
+from .........Internal.ArgSingleList import ArgSingleList
+from .........Internal.ArgSingle import ArgSingle
 from ......... import enums
 from ......... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Ocombination:
-	"""Ocombination commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class OcombinationCls:
+	"""Ocombination commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("ocombination", core, parent)
+		self._cmd_group = CommandsGroup("ocombination", core, parent)
+
+	def set(self, enable: bool, frequency_start: float, frequency_end: float, level: float, rbw: enums.Rbw, limit=repcap.Limit.Default) -> None:
+		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:SEMask:LIMit<nr>:CAGGregation:OCOMbination \n
+		Snippet: driver.configure.lteMeas.multiEval.limit.seMask.limit.carrierAggregation.ocombination.set(enable = False, frequency_start = 1.0, frequency_end = 1.0, level = 1.0, rbw = enums.Rbw.K030, limit = repcap.Limit.Default) \n
+		Defines general requirements for the emission mask area <no>. The activation state, the area borders, an upper limit and
+		the resolution bandwidth must be specified. The settings apply to all 'other' channel bandwidth combinations, not covered
+		by other commands in this chapter. \n
+			:param enable: OFF: Disables the check of these requirements. ON: Enables the check of these requirements.
+			:param frequency_start: Start frequency of the area, relative to the edges of the aggregated channel bandwidth.
+			:param frequency_end: Stop frequency of the area, relative to the edges of the aggregated channel bandwidth.
+			:param level: Upper limit for the area
+			:param rbw: Resolution bandwidth to be used for the area. K030: 30 kHz K100: 100 kHz M1: 1 MHz
+			:param limit: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Limit')
+		"""
+		param = ArgSingleList().compose_cmd_string(ArgSingle('enable', enable, DataType.Boolean), ArgSingle('frequency_start', frequency_start, DataType.Float), ArgSingle('frequency_end', frequency_end, DataType.Float), ArgSingle('level', level, DataType.Float), ArgSingle('rbw', rbw, DataType.Enum, enums.Rbw))
+		limit_cmd_val = self._cmd_group.get_repcap_cmd_value(limit, repcap.Limit)
+		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:SEMask:LIMit{limit_cmd_val}:CAGGregation:OCOMbination {param}'.rstrip())
 
 	# noinspection PyTypeChecker
 	class OcombinationStruct(StructBase):
-		"""Structure for setting input parameters. Fields: \n
-			- Enable: bool: OFF: disables the check of these requirements ON: enables the check of these requirements
-			- Frequency_Start: float: Start frequency of the area, relative to the edges of the aggregated channel bandwidth
-			- Frequency_End: float: Stop frequency of the area, relative to the edges of the aggregated channel bandwidth
+		"""Response structure. Fields: \n
+			- Enable: bool: OFF: Disables the check of these requirements. ON: Enables the check of these requirements.
+			- Frequency_Start: float: Start frequency of the area, relative to the edges of the aggregated channel bandwidth.
+			- Frequency_End: float: Stop frequency of the area, relative to the edges of the aggregated channel bandwidth.
 			- Level: float: Upper limit for the area
-			- Rbw: enums.Rbw: Resolution bandwidth to be used for the area K030: 30 kHz K100: 100 kHz M1: 1 MHz"""
+			- Rbw: enums.Rbw: Resolution bandwidth to be used for the area. K030: 30 kHz K100: 100 kHz M1: 1 MHz"""
 		__meta_args_list = [
 			ArgStruct.scalar_bool('Enable'),
 			ArgStruct.scalar_float('Frequency_Start'),
 			ArgStruct.scalar_float('Frequency_End'),
 			ArgStruct.scalar_float('Level'),
 			ArgStruct.scalar_enum('Rbw', enums.Rbw)]
 
@@ -33,32 +53,17 @@
 			StructBase.__init__(self, self)
 			self.Enable: bool = None
 			self.Frequency_Start: float = None
 			self.Frequency_End: float = None
 			self.Level: float = None
 			self.Rbw: enums.Rbw = None
 
-	def set(self, structure: OcombinationStruct, limit=repcap.Limit.Default, table=repcap.Table.Default) -> None:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:SEMask:LIMit<nr>:ADDitional<Table>:CAGGregation:OCOMbination \n
-		Snippet: driver.configure.multiEval.limit.seMask.limit.additional.carrierAggregation.ocombination.set(value = [PROPERTY_STRUCT_NAME](), limit = repcap.Limit.Default, table = repcap.Table.Default) \n
-		Defines additional requirements for the emission mask area <no>. The activation state, the area borders, an upper limit
-		and the resolution bandwidth must be specified. The settings apply to all 'other' channel bandwidth combinations, not
-		covered by other commands in this chapter. \n
-			:param structure: for set value, see the help for OcombinationStruct structure arguments.
-			:param limit: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Limit')
-			:param table: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Additional')"""
-		limit_cmd_val = self._base.get_repcap_cmd_value(limit, repcap.Limit)
-		table_cmd_val = self._base.get_repcap_cmd_value(table, repcap.Table)
-		self._core.io.write_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:SEMask:LIMit{limit_cmd_val}:ADDitional{table_cmd_val}:CAGGregation:OCOMbination', structure)
-
-	def get(self, limit=repcap.Limit.Default, table=repcap.Table.Default) -> OcombinationStruct:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:SEMask:LIMit<nr>:ADDitional<Table>:CAGGregation:OCOMbination \n
-		Snippet: value: OcombinationStruct = driver.configure.multiEval.limit.seMask.limit.additional.carrierAggregation.ocombination.get(limit = repcap.Limit.Default, table = repcap.Table.Default) \n
-		Defines additional requirements for the emission mask area <no>. The activation state, the area borders, an upper limit
-		and the resolution bandwidth must be specified. The settings apply to all 'other' channel bandwidth combinations, not
-		covered by other commands in this chapter. \n
+	def get(self, limit=repcap.Limit.Default) -> OcombinationStruct:
+		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:SEMask:LIMit<nr>:CAGGregation:OCOMbination \n
+		Snippet: value: OcombinationStruct = driver.configure.lteMeas.multiEval.limit.seMask.limit.carrierAggregation.ocombination.get(limit = repcap.Limit.Default) \n
+		Defines general requirements for the emission mask area <no>. The activation state, the area borders, an upper limit and
+		the resolution bandwidth must be specified. The settings apply to all 'other' channel bandwidth combinations, not covered
+		by other commands in this chapter. \n
 			:param limit: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Limit')
-			:param table: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Additional')
 			:return: structure: for return value, see the help for OcombinationStruct structure arguments."""
-		limit_cmd_val = self._base.get_repcap_cmd_value(limit, repcap.Limit)
-		table_cmd_val = self._base.get_repcap_cmd_value(table, repcap.Table)
-		return self._core.io.query_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:SEMask:LIMit{limit_cmd_val}:ADDitional{table_cmd_val}:CAGGregation:OCOMbination?', self.__class__.OcombinationStruct())
+		limit_cmd_val = self._cmd_group.get_repcap_cmd_value(limit, repcap.Limit)
+		return self._core.io.query_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:SEMask:LIMit{limit_cmd_val}:CAGGregation:OCOMbination?', self.__class__.OcombinationStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/Limit_/Additional_/ChannelBw.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Limit/SeMask/Limit/Additional/ChannelBw/__init__.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,53 +1,77 @@
-from ........Internal.Core import Core
-from ........Internal.CommandsGroup import CommandsGroup
-from ........Internal.StructBase import StructBase
-from ........Internal.ArgStruct import ArgStruct
-from ........Internal.RepeatedCapability import RepeatedCapability
-from ........ import enums
-from ........ import repcap
+from ..........Internal.Core import Core
+from ..........Internal.CommandsGroup import CommandsGroup
+from ..........Internal.Types import DataType
+from ..........Internal.StructBase import StructBase
+from ..........Internal.ArgStruct import ArgStruct
+from ..........Internal.ArgSingleList import ArgSingleList
+from ..........Internal.ArgSingle import ArgSingle
+from ..........Internal.RepeatedCapability import RepeatedCapability
+from .......... import enums
+from .......... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class ChannelBw:
-	"""ChannelBw commands group definition. 2 total commands, 1 Sub-groups, 1 group commands
+class ChannelBwCls:
+	"""ChannelBw commands group definition. 2 total commands, 1 Subgroups, 1 group commands
 	Repeated Capability: ChannelBw, default value after init: ChannelBw.Bw14"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("channelBw", core, parent)
-		self._base.rep_cap = RepeatedCapability(self._base.group_name, 'repcap_channelBw_get', 'repcap_channelBw_set', repcap.ChannelBw.Bw14)
+		self._cmd_group = CommandsGroup("channelBw", core, parent)
+		self._cmd_group.rep_cap = RepeatedCapability(self._cmd_group.group_name, 'repcap_channelBw_get', 'repcap_channelBw_set', repcap.ChannelBw.Bw14)
 
-	def repcap_channelBw_set(self, enum_value: repcap.ChannelBw) -> None:
+	def repcap_channelBw_set(self, channelBw: repcap.ChannelBw) -> None:
 		"""Repeated Capability default value numeric suffix.
 		This value is used, if you do not explicitely set it in the child set/get methods, or if you leave it to ChannelBw.Default
 		Default value after init: ChannelBw.Bw14"""
-		self._base.set_repcap_enum_value(enum_value)
+		self._cmd_group.set_repcap_enum_value(channelBw)
 
 	def repcap_channelBw_get(self) -> repcap.ChannelBw:
 		"""Returns the current default repeated capability for the child set/get methods"""
 		# noinspection PyTypeChecker
-		return self._base.get_repcap_enum_value()
+		return self._cmd_group.get_repcap_enum_value()
 
 	@property
 	def sidelink(self):
 		"""sidelink commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_sidelink'):
-			from .ChannelBw_.Sidelink import Sidelink
-			self._sidelink = Sidelink(self._core, self._base)
+			from .Sidelink import SidelinkCls
+			self._sidelink = SidelinkCls(self._core, self._cmd_group)
 		return self._sidelink
 
+	def set(self, enable: bool, frequency_start: float, frequency_end: float, level: float, rbw: enums.RbwExtended, limit=repcap.Limit.Default, table=repcap.Table.Default, channelBw=repcap.ChannelBw.Default) -> None:
+		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:SEMask:LIMit<nr>:ADDitional<Table>:CBANdwidth<Band> \n
+		Snippet: driver.configure.lteMeas.multiEval.limit.seMask.limit.additional.channelBw.set(enable = False, frequency_start = 1.0, frequency_end = 1.0, level = 1.0, rbw = enums.RbwExtended.K030, limit = repcap.Limit.Default, table = repcap.Table.Default, channelBw = repcap.ChannelBw.Default) \n
+		Defines additional requirements for the emission mask area <no>, for uplink measurements. The activation state, the area
+		borders, an upper limit and the resolution bandwidth must be specified. The emission mask applies to the channel
+		bandwidth <Band>. Several tables of additional requirements are available. \n
+			:param enable: OFF: Disables the check of these requirements. ON: Enables the check of these requirements.
+			:param frequency_start: Lower border of the area, relative to the edges of the channel bandwidth.
+			:param frequency_end: Upper border of the area, relative to the edges of the channel bandwidth.
+			:param level: Upper limit for the area
+			:param rbw: Resolution bandwidth to be used for the area. Only a subset of the values is allowed, depending on Table and Band, see table below. K030: 30 kHz K050: 50 kHz K100: 100 kHz K150: 150 kHz K200: 200 kHz M1: 1 MHz
+			:param limit: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Limit')
+			:param table: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Additional')
+			:param channelBw: optional repeated capability selector. Default value: Bw14 (settable in the interface 'ChannelBw')
+		"""
+		param = ArgSingleList().compose_cmd_string(ArgSingle('enable', enable, DataType.Boolean), ArgSingle('frequency_start', frequency_start, DataType.Float), ArgSingle('frequency_end', frequency_end, DataType.Float), ArgSingle('level', level, DataType.Float), ArgSingle('rbw', rbw, DataType.Enum, enums.RbwExtended))
+		limit_cmd_val = self._cmd_group.get_repcap_cmd_value(limit, repcap.Limit)
+		table_cmd_val = self._cmd_group.get_repcap_cmd_value(table, repcap.Table)
+		channelBw_cmd_val = self._cmd_group.get_repcap_cmd_value(channelBw, repcap.ChannelBw)
+		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:SEMask:LIMit{limit_cmd_val}:ADDitional{table_cmd_val}:CBANdwidth{channelBw_cmd_val} {param}'.rstrip())
+
 	# noinspection PyTypeChecker
 	class ChannelBwStruct(StructBase):
-		"""Structure for setting input parameters. Fields: \n
-			- Enable: bool: OFF: disables the check of these requirements ON: enables the check of these requirements
-			- Frequency_Start: float: Start frequency of the area, relative to the edges of the channel bandwidth
-			- Frequency_End: float: Stop frequency of the area, relative to the edges of the channel bandwidth
+		"""Response structure. Fields: \n
+			- Enable: bool: OFF: Disables the check of these requirements. ON: Enables the check of these requirements.
+			- Frequency_Start: float: Lower border of the area, relative to the edges of the channel bandwidth.
+			- Frequency_End: float: Upper border of the area, relative to the edges of the channel bandwidth.
 			- Level: float: Upper limit for the area
-			- Rbw: enums.RbwExtended: Resolution bandwidth to be used for the area Only a subset of the values is allowed, depending on Table and Band, see table below K030: 30 kHz K050: 50 kHz K100: 100 kHz K150: 150 kHz K200: 200 kHz M1: 1 MHz"""
+			- Rbw: enums.RbwExtended: Resolution bandwidth to be used for the area. Only a subset of the values is allowed, depending on Table and Band, see table below. K030: 30 kHz K050: 50 kHz K100: 100 kHz K150: 150 kHz K200: 200 kHz M1: 1 MHz"""
 		__meta_args_list = [
 			ArgStruct.scalar_bool('Enable'),
 			ArgStruct.scalar_float('Frequency_Start'),
 			ArgStruct.scalar_float('Frequency_End'),
 			ArgStruct.scalar_float('Level'),
 			ArgStruct.scalar_enum('Rbw', enums.RbwExtended)]
 
@@ -55,44 +79,29 @@
 			StructBase.__init__(self, self)
 			self.Enable: bool = None
 			self.Frequency_Start: float = None
 			self.Frequency_End: float = None
 			self.Level: float = None
 			self.Rbw: enums.RbwExtended = None
 
-	def set(self, structure: ChannelBwStruct, limit=repcap.Limit.Default, table=repcap.Table.Default, channelBw=repcap.ChannelBw.Default) -> None:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:SEMask:LIMit<nr>:ADDitional<Table>:CBANdwidth<Band> \n
-		Snippet: driver.configure.multiEval.limit.seMask.limit.additional.channelBw.set(value = [PROPERTY_STRUCT_NAME](), limit = repcap.Limit.Default, table = repcap.Table.Default, channelBw = repcap.ChannelBw.Default) \n
-		Defines additional requirements for the emission mask area <no>, for uplink measurements. The activation state, the area
-		borders, an upper limit and the resolution bandwidth must be specified. The emission mask applies to the channel
-		bandwidth <Band>. Several tables of additional requirements are available. \n
-			:param structure: for set value, see the help for ChannelBwStruct structure arguments.
-			:param limit: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Limit')
-			:param table: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Additional')
-			:param channelBw: optional repeated capability selector. Default value: Bw14 (settable in the interface 'ChannelBw')"""
-		limit_cmd_val = self._base.get_repcap_cmd_value(limit, repcap.Limit)
-		table_cmd_val = self._base.get_repcap_cmd_value(table, repcap.Table)
-		channelBw_cmd_val = self._base.get_repcap_cmd_value(channelBw, repcap.ChannelBw)
-		self._core.io.write_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:SEMask:LIMit{limit_cmd_val}:ADDitional{table_cmd_val}:CBANdwidth{channelBw_cmd_val}', structure)
-
 	def get(self, limit=repcap.Limit.Default, table=repcap.Table.Default, channelBw=repcap.ChannelBw.Default) -> ChannelBwStruct:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:SEMask:LIMit<nr>:ADDitional<Table>:CBANdwidth<Band> \n
-		Snippet: value: ChannelBwStruct = driver.configure.multiEval.limit.seMask.limit.additional.channelBw.get(limit = repcap.Limit.Default, table = repcap.Table.Default, channelBw = repcap.ChannelBw.Default) \n
+		Snippet: value: ChannelBwStruct = driver.configure.lteMeas.multiEval.limit.seMask.limit.additional.channelBw.get(limit = repcap.Limit.Default, table = repcap.Table.Default, channelBw = repcap.ChannelBw.Default) \n
 		Defines additional requirements for the emission mask area <no>, for uplink measurements. The activation state, the area
 		borders, an upper limit and the resolution bandwidth must be specified. The emission mask applies to the channel
 		bandwidth <Band>. Several tables of additional requirements are available. \n
 			:param limit: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Limit')
 			:param table: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Additional')
 			:param channelBw: optional repeated capability selector. Default value: Bw14 (settable in the interface 'ChannelBw')
 			:return: structure: for return value, see the help for ChannelBwStruct structure arguments."""
-		limit_cmd_val = self._base.get_repcap_cmd_value(limit, repcap.Limit)
-		table_cmd_val = self._base.get_repcap_cmd_value(table, repcap.Table)
-		channelBw_cmd_val = self._base.get_repcap_cmd_value(channelBw, repcap.ChannelBw)
+		limit_cmd_val = self._cmd_group.get_repcap_cmd_value(limit, repcap.Limit)
+		table_cmd_val = self._cmd_group.get_repcap_cmd_value(table, repcap.Table)
+		channelBw_cmd_val = self._cmd_group.get_repcap_cmd_value(channelBw, repcap.ChannelBw)
 		return self._core.io.query_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:SEMask:LIMit{limit_cmd_val}:ADDitional{table_cmd_val}:CBANdwidth{channelBw_cmd_val}?', self.__class__.ChannelBwStruct())
 
-	def clone(self) -> 'ChannelBw':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'ChannelBwCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = ChannelBw(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = ChannelBwCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/Limit_/Additional_/ChannelBw_/Sidelink.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Limit/SeMask/Limit/Additional/ChannelBw/Sidelink.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,32 +1,32 @@
-from .........Internal.Core import Core
-from .........Internal.CommandsGroup import CommandsGroup
-from .........Internal.StructBase import StructBase
-from .........Internal.ArgStruct import ArgStruct
-from ......... import enums
-from ......... import repcap
+from ..........Internal.Core import Core
+from ..........Internal.CommandsGroup import CommandsGroup
+from ..........Internal.StructBase import StructBase
+from ..........Internal.ArgStruct import ArgStruct
+from .......... import enums
+from .......... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Sidelink:
-	"""Sidelink commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class SidelinkCls:
+	"""Sidelink commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("sidelink", core, parent)
+		self._cmd_group = CommandsGroup("sidelink", core, parent)
 
 	# noinspection PyTypeChecker
 	class SidelinkStruct(StructBase):
 		"""Structure for setting input parameters. Fields: \n
-			- Enable: bool: OFF: disables the check of these requirements ON: enables the check of these requirements
-			- Frequency_Start: float: Start frequency of the area, relative to the edges of the channel bandwidth
-			- Frequency_End: float: Stop frequency of the area, relative to the edges of the channel bandwidth
+			- Enable: bool: OFF: Disables the check of these requirements. ON: Enables the check of these requirements.
+			- Frequency_Start: float: Lower border of the area, relative to the edges of the channel bandwidth.
+			- Frequency_End: float: Upper border of the area, relative to the edges of the channel bandwidth.
 			- Level: float: Upper limit at FrequencyStart
 			- Slope: float: Slope for the upper limit within the area
-			- Rbw: enums.Rbw: Resolution bandwidth to be used for the area K030: 30 kHz K100: 100 kHz M1: 1 MHz"""
+			- Rbw: enums.Rbw: Resolution bandwidth to be used for the area. K030: 30 kHz K100: 100 kHz M1: 1 MHz"""
 		__meta_args_list = [
 			ArgStruct.scalar_bool('Enable'),
 			ArgStruct.scalar_float('Frequency_Start'),
 			ArgStruct.scalar_float('Frequency_End'),
 			ArgStruct.scalar_float('Level'),
 			ArgStruct.scalar_float('Slope'),
 			ArgStruct.scalar_enum('Rbw', enums.Rbw)]
@@ -38,34 +38,43 @@
 			self.Frequency_End: float = None
 			self.Level: float = None
 			self.Slope: float = None
 			self.Rbw: enums.Rbw = None
 
 	def set(self, structure: SidelinkStruct, limit=repcap.Limit.Default, table=repcap.Table.Default, channelBw=repcap.ChannelBw.Default) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:SEMask:LIMit<nr>:ADDitional<Table>:CBANdwidth<Band>:SIDelink \n
-		Snippet: driver.configure.multiEval.limit.seMask.limit.additional.channelBw.sidelink.set(value = [PROPERTY_STRUCT_NAME](), limit = repcap.Limit.Default, table = repcap.Table.Default, channelBw = repcap.ChannelBw.Default) \n
+		Snippet with structure: \n
+		structure = driver.configure.lteMeas.multiEval.limit.seMask.limit.additional.channelBw.sidelink.SidelinkStruct() \n
+		structure.Enable: bool = False \n
+		structure.Frequency_Start: float = 1.0 \n
+		structure.Frequency_End: float = 1.0 \n
+		structure.Level: float = 1.0 \n
+		structure.Slope: float = 1.0 \n
+		structure.Rbw: enums.Rbw = enums.Rbw.K030 \n
+		driver.configure.lteMeas.multiEval.limit.seMask.limit.additional.channelBw.sidelink.set(structure, limit = repcap.Limit.Default, table = repcap.Table.Default, channelBw = repcap.ChannelBw.Default) \n
 		Defines additional requirements for the emission mask area <no>, for sidelink measurements. The activation state, the
 		area borders, the start value and slope of the upper limit and the resolution bandwidth must be specified. The emission
 		mask applies to the channel bandwidth <Band>. \n
 			:param structure: for set value, see the help for SidelinkStruct structure arguments.
 			:param limit: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Limit')
 			:param table: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Additional')
-			:param channelBw: optional repeated capability selector. Default value: Bw14 (settable in the interface 'ChannelBw')"""
-		limit_cmd_val = self._base.get_repcap_cmd_value(limit, repcap.Limit)
-		table_cmd_val = self._base.get_repcap_cmd_value(table, repcap.Table)
-		channelBw_cmd_val = self._base.get_repcap_cmd_value(channelBw, repcap.ChannelBw)
+			:param channelBw: optional repeated capability selector. Default value: Bw14 (settable in the interface 'ChannelBw')
+		"""
+		limit_cmd_val = self._cmd_group.get_repcap_cmd_value(limit, repcap.Limit)
+		table_cmd_val = self._cmd_group.get_repcap_cmd_value(table, repcap.Table)
+		channelBw_cmd_val = self._cmd_group.get_repcap_cmd_value(channelBw, repcap.ChannelBw)
 		self._core.io.write_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:SEMask:LIMit{limit_cmd_val}:ADDitional{table_cmd_val}:CBANdwidth{channelBw_cmd_val}:SIDelink', structure)
 
 	def get(self, limit=repcap.Limit.Default, table=repcap.Table.Default, channelBw=repcap.ChannelBw.Default) -> SidelinkStruct:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:SEMask:LIMit<nr>:ADDitional<Table>:CBANdwidth<Band>:SIDelink \n
-		Snippet: value: SidelinkStruct = driver.configure.multiEval.limit.seMask.limit.additional.channelBw.sidelink.get(limit = repcap.Limit.Default, table = repcap.Table.Default, channelBw = repcap.ChannelBw.Default) \n
+		Snippet: value: SidelinkStruct = driver.configure.lteMeas.multiEval.limit.seMask.limit.additional.channelBw.sidelink.get(limit = repcap.Limit.Default, table = repcap.Table.Default, channelBw = repcap.ChannelBw.Default) \n
 		Defines additional requirements for the emission mask area <no>, for sidelink measurements. The activation state, the
 		area borders, the start value and slope of the upper limit and the resolution bandwidth must be specified. The emission
 		mask applies to the channel bandwidth <Band>. \n
 			:param limit: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Limit')
 			:param table: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Additional')
 			:param channelBw: optional repeated capability selector. Default value: Bw14 (settable in the interface 'ChannelBw')
 			:return: structure: for return value, see the help for SidelinkStruct structure arguments."""
-		limit_cmd_val = self._base.get_repcap_cmd_value(limit, repcap.Limit)
-		table_cmd_val = self._base.get_repcap_cmd_value(table, repcap.Table)
-		channelBw_cmd_val = self._base.get_repcap_cmd_value(channelBw, repcap.ChannelBw)
+		limit_cmd_val = self._cmd_group.get_repcap_cmd_value(limit, repcap.Limit)
+		table_cmd_val = self._cmd_group.get_repcap_cmd_value(table, repcap.Table)
+		channelBw_cmd_val = self._cmd_group.get_repcap_cmd_value(channelBw, repcap.ChannelBw)
 		return self._core.io.query_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:SEMask:LIMit{limit_cmd_val}:ADDitional{table_cmd_val}:CBANdwidth{channelBw_cmd_val}:SIDelink?', self.__class__.SidelinkStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/Limit_/CarrierAggregation.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Limit/SeMask/Limit/CarrierAggregation/__init__.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,35 +1,35 @@
-from .......Internal.Core import Core
-from .......Internal.CommandsGroup import CommandsGroup
+from .........Internal.Core import Core
+from .........Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class CarrierAggregation:
-	"""CarrierAggregation commands group definition. 3 total commands, 2 Sub-groups, 0 group commands"""
+class CarrierAggregationCls:
+	"""CarrierAggregation commands group definition. 3 total commands, 2 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("carrierAggregation", core, parent)
+		self._cmd_group = CommandsGroup("carrierAggregation", core, parent)
 
 	@property
 	def channelBw1st(self):
 		"""channelBw1st commands group. 1 Sub-classes, 0 commands."""
 		if not hasattr(self, '_channelBw1st'):
-			from .CarrierAggregation_.ChannelBw1st import ChannelBw1st
-			self._channelBw1st = ChannelBw1st(self._core, self._base)
+			from .ChannelBw1st import ChannelBw1stCls
+			self._channelBw1st = ChannelBw1stCls(self._core, self._cmd_group)
 		return self._channelBw1st
 
 	@property
 	def ocombination(self):
 		"""ocombination commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_ocombination'):
-			from .CarrierAggregation_.Ocombination import Ocombination
-			self._ocombination = Ocombination(self._core, self._base)
+			from .Ocombination import OcombinationCls
+			self._ocombination = OcombinationCls(self._core, self._cmd_group)
 		return self._ocombination
 
-	def clone(self) -> 'CarrierAggregation':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'CarrierAggregationCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = CarrierAggregation(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = CarrierAggregationCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/Limit_/CarrierAggregation_/ChannelBw1st.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Limit/SeMask/Limit/CarrierAggregation/ChannelBw1st/__init__.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,42 +1,42 @@
-from ........Internal.Core import Core
-from ........Internal.CommandsGroup import CommandsGroup
-from ........Internal.RepeatedCapability import RepeatedCapability
-from ........ import repcap
+from ..........Internal.Core import Core
+from ..........Internal.CommandsGroup import CommandsGroup
+from ..........Internal.RepeatedCapability import RepeatedCapability
+from .......... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class ChannelBw1st:
-	"""ChannelBw1st commands group definition. 2 total commands, 1 Sub-groups, 0 group commands
+class ChannelBw1stCls:
+	"""ChannelBw1st commands group definition. 2 total commands, 1 Subgroups, 0 group commands
 	Repeated Capability: FirstChannelBw, default value after init: FirstChannelBw.Bw100"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("channelBw1st", core, parent)
-		self._base.rep_cap = RepeatedCapability(self._base.group_name, 'repcap_firstChannelBw_get', 'repcap_firstChannelBw_set', repcap.FirstChannelBw.Bw100)
+		self._cmd_group = CommandsGroup("channelBw1st", core, parent)
+		self._cmd_group.rep_cap = RepeatedCapability(self._cmd_group.group_name, 'repcap_firstChannelBw_get', 'repcap_firstChannelBw_set', repcap.FirstChannelBw.Bw100)
 
-	def repcap_firstChannelBw_set(self, enum_value: repcap.FirstChannelBw) -> None:
+	def repcap_firstChannelBw_set(self, firstChannelBw: repcap.FirstChannelBw) -> None:
 		"""Repeated Capability default value numeric suffix.
 		This value is used, if you do not explicitely set it in the child set/get methods, or if you leave it to FirstChannelBw.Default
 		Default value after init: FirstChannelBw.Bw100"""
-		self._base.set_repcap_enum_value(enum_value)
+		self._cmd_group.set_repcap_enum_value(firstChannelBw)
 
 	def repcap_firstChannelBw_get(self) -> repcap.FirstChannelBw:
 		"""Returns the current default repeated capability for the child set/get methods"""
 		# noinspection PyTypeChecker
-		return self._base.get_repcap_enum_value()
+		return self._cmd_group.get_repcap_enum_value()
 
 	@property
 	def channelBw2nd(self):
 		"""channelBw2nd commands group. 1 Sub-classes, 1 commands."""
 		if not hasattr(self, '_channelBw2nd'):
-			from .ChannelBw1st_.ChannelBw2nd import ChannelBw2nd
-			self._channelBw2nd = ChannelBw2nd(self._core, self._base)
+			from .ChannelBw2nd import ChannelBw2ndCls
+			self._channelBw2nd = ChannelBw2ndCls(self._core, self._cmd_group)
 		return self._channelBw2nd
 
-	def clone(self) -> 'ChannelBw1st':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'ChannelBw1stCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = ChannelBw1st(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = ChannelBw1stCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/Limit_/CarrierAggregation_/ChannelBw1st_/ChannelBw2nd.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Limit/SeMask/Limit/Additional/CarrierAggregation/ChannelBw1st/ChannelBw2nd.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,53 +1,72 @@
-from .........Internal.Core import Core
-from .........Internal.CommandsGroup import CommandsGroup
-from .........Internal.StructBase import StructBase
-from .........Internal.ArgStruct import ArgStruct
-from .........Internal.RepeatedCapability import RepeatedCapability
-from ......... import enums
-from ......... import repcap
+from ...........Internal.Core import Core
+from ...........Internal.CommandsGroup import CommandsGroup
+from ...........Internal.Types import DataType
+from ...........Internal.StructBase import StructBase
+from ...........Internal.ArgStruct import ArgStruct
+from ...........Internal.ArgSingleList import ArgSingleList
+from ...........Internal.ArgSingle import ArgSingle
+from ...........Internal.RepeatedCapability import RepeatedCapability
+from ........... import enums
+from ........... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class ChannelBw2nd:
-	"""ChannelBw2nd commands group definition. 2 total commands, 1 Sub-groups, 1 group commands
+class ChannelBw2ndCls:
+	"""ChannelBw2nd commands group definition. 1 total commands, 0 Subgroups, 1 group commands
 	Repeated Capability: SecondChannelBw, default value after init: SecondChannelBw.Bw50"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("channelBw2nd", core, parent)
-		self._base.rep_cap = RepeatedCapability(self._base.group_name, 'repcap_secondChannelBw_get', 'repcap_secondChannelBw_set', repcap.SecondChannelBw.Bw50)
+		self._cmd_group = CommandsGroup("channelBw2nd", core, parent)
+		self._cmd_group.rep_cap = RepeatedCapability(self._cmd_group.group_name, 'repcap_secondChannelBw_get', 'repcap_secondChannelBw_set', repcap.SecondChannelBw.Bw50)
 
-	def repcap_secondChannelBw_set(self, enum_value: repcap.SecondChannelBw) -> None:
+	def repcap_secondChannelBw_set(self, secondChannelBw: repcap.SecondChannelBw) -> None:
 		"""Repeated Capability default value numeric suffix.
 		This value is used, if you do not explicitely set it in the child set/get methods, or if you leave it to SecondChannelBw.Default
 		Default value after init: SecondChannelBw.Bw50"""
-		self._base.set_repcap_enum_value(enum_value)
+		self._cmd_group.set_repcap_enum_value(secondChannelBw)
 
 	def repcap_secondChannelBw_get(self) -> repcap.SecondChannelBw:
 		"""Returns the current default repeated capability for the child set/get methods"""
 		# noinspection PyTypeChecker
-		return self._base.get_repcap_enum_value()
+		return self._cmd_group.get_repcap_enum_value()
 
-	@property
-	def channelBw3rd(self):
-		"""channelBw3rd commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_channelBw3rd'):
-			from .ChannelBw2nd_.ChannelBw3rd import ChannelBw3rd
-			self._channelBw3rd = ChannelBw3rd(self._core, self._base)
-		return self._channelBw3rd
+	def set(self, enable: bool, frequency_start: float, frequency_end: float, level: float, rbw: enums.Rbw, limit=repcap.Limit.Default, table=repcap.Table.Default, firstChannelBw=repcap.FirstChannelBw.Default, secondChannelBw=repcap.SecondChannelBw.Default) -> None:
+		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:SEMask:LIMit<nr>:ADDitional<Table>:CAGGregation:CBANdwidth<Band1>:CBANdwidth<Band2> \n
+		Snippet: driver.configure.lteMeas.multiEval.limit.seMask.limit.additional.carrierAggregation.channelBw1st.channelBw2nd.set(enable = False, frequency_start = 1.0, frequency_end = 1.0, level = 1.0, rbw = enums.Rbw.K030, limit = repcap.Limit.Default, table = repcap.Table.Default, firstChannelBw = repcap.FirstChannelBw.Default, secondChannelBw = repcap.SecondChannelBw.Default) \n
+		Defines additional requirements for the emission mask area <no>. The activation state, the area borders, an upper limit
+		and the resolution bandwidth must be specified. The settings are defined separately for each channel bandwidth
+		combination, for two aggregated carriers. The following bandwidth combinations are supported: Example: For the first line
+		in the figure, use ...:CBANdwidth100:CBANdwidth50. \n
+			:param enable: OFF: Disables the check of these requirements. ON: Enables the check of these requirements.
+			:param frequency_start: Start frequency of the area, relative to the edges of the aggregated channel bandwidth.
+			:param frequency_end: Stop frequency of the area, relative to the edges of the aggregated channel bandwidth.
+			:param level: Upper limit for the area
+			:param rbw: Resolution bandwidth to be used for the area. K030: 30 kHz K100: 100 kHz M1: 1 MHz
+			:param limit: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Limit')
+			:param table: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Additional')
+			:param firstChannelBw: optional repeated capability selector. Default value: Bw100 (settable in the interface 'ChannelBw1st')
+			:param secondChannelBw: optional repeated capability selector. Default value: Bw50 (settable in the interface 'ChannelBw2nd')
+		"""
+		param = ArgSingleList().compose_cmd_string(ArgSingle('enable', enable, DataType.Boolean), ArgSingle('frequency_start', frequency_start, DataType.Float), ArgSingle('frequency_end', frequency_end, DataType.Float), ArgSingle('level', level, DataType.Float), ArgSingle('rbw', rbw, DataType.Enum, enums.Rbw))
+		limit_cmd_val = self._cmd_group.get_repcap_cmd_value(limit, repcap.Limit)
+		table_cmd_val = self._cmd_group.get_repcap_cmd_value(table, repcap.Table)
+		firstChannelBw_cmd_val = self._cmd_group.get_repcap_cmd_value(firstChannelBw, repcap.FirstChannelBw)
+		secondChannelBw_cmd_val = self._cmd_group.get_repcap_cmd_value(secondChannelBw, repcap.SecondChannelBw)
+		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:SEMask:LIMit{limit_cmd_val}:ADDitional{table_cmd_val}:CAGGregation:CBANdwidth{firstChannelBw_cmd_val}:CBANdwidth{secondChannelBw_cmd_val} {param}'.rstrip())
 
 	# noinspection PyTypeChecker
 	class ChannelBw2ndStruct(StructBase):
-		"""Structure for setting input parameters. Fields: \n
-			- Enable: bool: OFF: disables the check of these requirements ON: enables the check of these requirements
-			- Frequency_Start: float: Start frequency of the area, relative to the edges of the aggregated channel bandwidth
-			- Frequency_End: float: Stop frequency of the area, relative to the edges of the aggregated channel bandwidth
+		"""Response structure. Fields: \n
+			- Enable: bool: OFF: Disables the check of these requirements. ON: Enables the check of these requirements.
+			- Frequency_Start: float: Start frequency of the area, relative to the edges of the aggregated channel bandwidth.
+			- Frequency_End: float: Stop frequency of the area, relative to the edges of the aggregated channel bandwidth.
 			- Level: float: Upper limit for the area
-			- Rbw: enums.Rbw: Resolution bandwidth to be used for the area K030: 30 kHz K100: 100 kHz M1: 1 MHz"""
+			- Rbw: enums.Rbw: Resolution bandwidth to be used for the area. K030: 30 kHz K100: 100 kHz M1: 1 MHz"""
 		__meta_args_list = [
 			ArgStruct.scalar_bool('Enable'),
 			ArgStruct.scalar_float('Frequency_Start'),
 			ArgStruct.scalar_float('Frequency_End'),
 			ArgStruct.scalar_float('Level'),
 			ArgStruct.scalar_enum('Rbw', enums.Rbw)]
 
@@ -55,46 +74,32 @@
 			StructBase.__init__(self, self)
 			self.Enable: bool = None
 			self.Frequency_Start: float = None
 			self.Frequency_End: float = None
 			self.Level: float = None
 			self.Rbw: enums.Rbw = None
 
-	def set(self, structure: ChannelBw2ndStruct, limit=repcap.Limit.Default, firstChannelBw=repcap.FirstChannelBw.Default, secondChannelBw=repcap.SecondChannelBw.Default) -> None:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:SEMask:LIMit<nr>:CAGGregation:CBANdwidth<Band1>:CBANdwidth<Band2> \n
-		Snippet: driver.configure.multiEval.limit.seMask.limit.carrierAggregation.channelBw1st.channelBw2nd.set(value = [PROPERTY_STRUCT_NAME](), limit = repcap.Limit.Default, firstChannelBw = repcap.FirstChannelBw.Default, secondChannelBw = repcap.SecondChannelBw.Default) \n
-		Defines general requirements for the emission mask area <no>. The activation state, the area borders, an upper limit and
-		the resolution bandwidth must be specified. The settings are defined separately for each channel bandwidth combination,
-		for two aggregated carriers. The following bandwidth combinations are supported: Example: For the first line in the
-		figure, use ...:CBANdwidth100:CBANdwidth50. \n
-			:param structure: for set value, see the help for ChannelBw2ndStruct structure arguments.
-			:param limit: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Limit')
-			:param firstChannelBw: optional repeated capability selector. Default value: Bw100 (settable in the interface 'ChannelBw1st')
-			:param secondChannelBw: optional repeated capability selector. Default value: Bw50 (settable in the interface 'ChannelBw2nd')"""
-		limit_cmd_val = self._base.get_repcap_cmd_value(limit, repcap.Limit)
-		firstChannelBw_cmd_val = self._base.get_repcap_cmd_value(firstChannelBw, repcap.FirstChannelBw)
-		secondChannelBw_cmd_val = self._base.get_repcap_cmd_value(secondChannelBw, repcap.SecondChannelBw)
-		self._core.io.write_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:SEMask:LIMit{limit_cmd_val}:CAGGregation:CBANdwidth{firstChannelBw_cmd_val}:CBANdwidth{secondChannelBw_cmd_val}', structure)
-
-	def get(self, limit=repcap.Limit.Default, firstChannelBw=repcap.FirstChannelBw.Default, secondChannelBw=repcap.SecondChannelBw.Default) -> ChannelBw2ndStruct:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:SEMask:LIMit<nr>:CAGGregation:CBANdwidth<Band1>:CBANdwidth<Band2> \n
-		Snippet: value: ChannelBw2ndStruct = driver.configure.multiEval.limit.seMask.limit.carrierAggregation.channelBw1st.channelBw2nd.get(limit = repcap.Limit.Default, firstChannelBw = repcap.FirstChannelBw.Default, secondChannelBw = repcap.SecondChannelBw.Default) \n
-		Defines general requirements for the emission mask area <no>. The activation state, the area borders, an upper limit and
-		the resolution bandwidth must be specified. The settings are defined separately for each channel bandwidth combination,
-		for two aggregated carriers. The following bandwidth combinations are supported: Example: For the first line in the
-		figure, use ...:CBANdwidth100:CBANdwidth50. \n
+	def get(self, limit=repcap.Limit.Default, table=repcap.Table.Default, firstChannelBw=repcap.FirstChannelBw.Default, secondChannelBw=repcap.SecondChannelBw.Default) -> ChannelBw2ndStruct:
+		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:SEMask:LIMit<nr>:ADDitional<Table>:CAGGregation:CBANdwidth<Band1>:CBANdwidth<Band2> \n
+		Snippet: value: ChannelBw2ndStruct = driver.configure.lteMeas.multiEval.limit.seMask.limit.additional.carrierAggregation.channelBw1st.channelBw2nd.get(limit = repcap.Limit.Default, table = repcap.Table.Default, firstChannelBw = repcap.FirstChannelBw.Default, secondChannelBw = repcap.SecondChannelBw.Default) \n
+		Defines additional requirements for the emission mask area <no>. The activation state, the area borders, an upper limit
+		and the resolution bandwidth must be specified. The settings are defined separately for each channel bandwidth
+		combination, for two aggregated carriers. The following bandwidth combinations are supported: Example: For the first line
+		in the figure, use ...:CBANdwidth100:CBANdwidth50. \n
 			:param limit: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Limit')
+			:param table: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Additional')
 			:param firstChannelBw: optional repeated capability selector. Default value: Bw100 (settable in the interface 'ChannelBw1st')
 			:param secondChannelBw: optional repeated capability selector. Default value: Bw50 (settable in the interface 'ChannelBw2nd')
 			:return: structure: for return value, see the help for ChannelBw2ndStruct structure arguments."""
-		limit_cmd_val = self._base.get_repcap_cmd_value(limit, repcap.Limit)
-		firstChannelBw_cmd_val = self._base.get_repcap_cmd_value(firstChannelBw, repcap.FirstChannelBw)
-		secondChannelBw_cmd_val = self._base.get_repcap_cmd_value(secondChannelBw, repcap.SecondChannelBw)
-		return self._core.io.query_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:SEMask:LIMit{limit_cmd_val}:CAGGregation:CBANdwidth{firstChannelBw_cmd_val}:CBANdwidth{secondChannelBw_cmd_val}?', self.__class__.ChannelBw2ndStruct())
+		limit_cmd_val = self._cmd_group.get_repcap_cmd_value(limit, repcap.Limit)
+		table_cmd_val = self._cmd_group.get_repcap_cmd_value(table, repcap.Table)
+		firstChannelBw_cmd_val = self._cmd_group.get_repcap_cmd_value(firstChannelBw, repcap.FirstChannelBw)
+		secondChannelBw_cmd_val = self._cmd_group.get_repcap_cmd_value(secondChannelBw, repcap.SecondChannelBw)
+		return self._core.io.query_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:SEMask:LIMit{limit_cmd_val}:ADDitional{table_cmd_val}:CAGGregation:CBANdwidth{firstChannelBw_cmd_val}:CBANdwidth{secondChannelBw_cmd_val}?', self.__class__.ChannelBw2ndStruct())
 
-	def clone(self) -> 'ChannelBw2nd':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'ChannelBw2ndCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = ChannelBw2nd(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = ChannelBw2ndCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/Limit_/CarrierAggregation_/ChannelBw1st_/ChannelBw2nd_/ChannelBw3rd.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Limit/SeMask/Limit/CarrierAggregation/ChannelBw1st/ChannelBw2nd/ChannelBw3rd.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,45 +1,72 @@
-from ..........Internal.Core import Core
-from ..........Internal.CommandsGroup import CommandsGroup
-from ..........Internal.StructBase import StructBase
-from ..........Internal.ArgStruct import ArgStruct
-from ..........Internal.RepeatedCapability import RepeatedCapability
-from .......... import enums
-from .......... import repcap
+from ...........Internal.Core import Core
+from ...........Internal.CommandsGroup import CommandsGroup
+from ...........Internal.Types import DataType
+from ...........Internal.StructBase import StructBase
+from ...........Internal.ArgStruct import ArgStruct
+from ...........Internal.ArgSingleList import ArgSingleList
+from ...........Internal.ArgSingle import ArgSingle
+from ...........Internal.RepeatedCapability import RepeatedCapability
+from ........... import enums
+from ........... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class ChannelBw3rd:
-	"""ChannelBw3rd commands group definition. 1 total commands, 0 Sub-groups, 1 group commands
+class ChannelBw3rdCls:
+	"""ChannelBw3rd commands group definition. 1 total commands, 0 Subgroups, 1 group commands
 	Repeated Capability: ThirdChannelBw, default value after init: ThirdChannelBw.Bw100"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("channelBw3rd", core, parent)
-		self._base.rep_cap = RepeatedCapability(self._base.group_name, 'repcap_thirdChannelBw_get', 'repcap_thirdChannelBw_set', repcap.ThirdChannelBw.Bw100)
+		self._cmd_group = CommandsGroup("channelBw3rd", core, parent)
+		self._cmd_group.rep_cap = RepeatedCapability(self._cmd_group.group_name, 'repcap_thirdChannelBw_get', 'repcap_thirdChannelBw_set', repcap.ThirdChannelBw.Bw100)
 
-	def repcap_thirdChannelBw_set(self, enum_value: repcap.ThirdChannelBw) -> None:
+	def repcap_thirdChannelBw_set(self, thirdChannelBw: repcap.ThirdChannelBw) -> None:
 		"""Repeated Capability default value numeric suffix.
 		This value is used, if you do not explicitely set it in the child set/get methods, or if you leave it to ThirdChannelBw.Default
 		Default value after init: ThirdChannelBw.Bw100"""
-		self._base.set_repcap_enum_value(enum_value)
+		self._cmd_group.set_repcap_enum_value(thirdChannelBw)
 
 	def repcap_thirdChannelBw_get(self) -> repcap.ThirdChannelBw:
 		"""Returns the current default repeated capability for the child set/get methods"""
 		# noinspection PyTypeChecker
-		return self._base.get_repcap_enum_value()
+		return self._cmd_group.get_repcap_enum_value()
+
+	def set(self, enable: bool, frequency_start: float, frequency_end: float, level: float, rbw: enums.Rbw, limit=repcap.Limit.Default, firstChannelBw=repcap.FirstChannelBw.Default, secondChannelBw=repcap.SecondChannelBw.Default, thirdChannelBw=repcap.ThirdChannelBw.Default) -> None:
+		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:SEMask:LIMit<nr>:CAGGregation:CBANdwidth<Band1>:CBANdwidth<Band2>:CBANdwidth<Band3> \n
+		Snippet: driver.configure.lteMeas.multiEval.limit.seMask.limit.carrierAggregation.channelBw1st.channelBw2nd.channelBw3rd.set(enable = False, frequency_start = 1.0, frequency_end = 1.0, level = 1.0, rbw = enums.Rbw.K030, limit = repcap.Limit.Default, firstChannelBw = repcap.FirstChannelBw.Default, secondChannelBw = repcap.SecondChannelBw.Default, thirdChannelBw = repcap.ThirdChannelBw.Default) \n
+		Defines general requirements for the emission mask area <no>. The activation state, the area borders, an upper limit and
+		the resolution bandwidth must be specified. The settings are defined separately for each channel bandwidth combination,
+		for three aggregated carriers. The following bandwidth combinations are supported: Example: For the first line in the
+		figure, use ...:CBANdwidth200:CBANdwidth150:CBANdwidth100. \n
+			:param enable: OFF: Disables the check of these requirements. ON: Enables the check of these requirements.
+			:param frequency_start: Start frequency of the area, relative to the edges of the aggregated channel bandwidth.
+			:param frequency_end: Stop frequency of the area, relative to the edges of the aggregated channel bandwidth.
+			:param level: Upper limit for the area
+			:param rbw: Resolution bandwidth to be used for the area. K030: 30 kHz K100: 100 kHz M1: 1 MHz
+			:param limit: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Limit')
+			:param firstChannelBw: optional repeated capability selector. Default value: Bw100 (settable in the interface 'ChannelBw1st')
+			:param secondChannelBw: optional repeated capability selector. Default value: Bw50 (settable in the interface 'ChannelBw2nd')
+			:param thirdChannelBw: optional repeated capability selector. Default value: Bw100 (settable in the interface 'ChannelBw3rd')
+		"""
+		param = ArgSingleList().compose_cmd_string(ArgSingle('enable', enable, DataType.Boolean), ArgSingle('frequency_start', frequency_start, DataType.Float), ArgSingle('frequency_end', frequency_end, DataType.Float), ArgSingle('level', level, DataType.Float), ArgSingle('rbw', rbw, DataType.Enum, enums.Rbw))
+		limit_cmd_val = self._cmd_group.get_repcap_cmd_value(limit, repcap.Limit)
+		firstChannelBw_cmd_val = self._cmd_group.get_repcap_cmd_value(firstChannelBw, repcap.FirstChannelBw)
+		secondChannelBw_cmd_val = self._cmd_group.get_repcap_cmd_value(secondChannelBw, repcap.SecondChannelBw)
+		thirdChannelBw_cmd_val = self._cmd_group.get_repcap_cmd_value(thirdChannelBw, repcap.ThirdChannelBw)
+		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:SEMask:LIMit{limit_cmd_val}:CAGGregation:CBANdwidth{firstChannelBw_cmd_val}:CBANdwidth{secondChannelBw_cmd_val}:CBANdwidth{thirdChannelBw_cmd_val} {param}'.rstrip())
 
 	# noinspection PyTypeChecker
 	class ChannelBw3rdStruct(StructBase):
-		"""Structure for setting input parameters. Fields: \n
-			- Enable: bool: OFF: disables the check of these requirements ON: enables the check of these requirements
-			- Frequency_Start: float: Start frequency of the area, relative to the edges of the aggregated channel bandwidth
-			- Frequency_End: float: Stop frequency of the area, relative to the edges of the aggregated channel bandwidth
+		"""Response structure. Fields: \n
+			- Enable: bool: OFF: Disables the check of these requirements. ON: Enables the check of these requirements.
+			- Frequency_Start: float: Start frequency of the area, relative to the edges of the aggregated channel bandwidth.
+			- Frequency_End: float: Stop frequency of the area, relative to the edges of the aggregated channel bandwidth.
 			- Level: float: Upper limit for the area
-			- Rbw: enums.Rbw: Resolution bandwidth to be used for the area K030: 30 kHz K100: 100 kHz M1: 1 MHz"""
+			- Rbw: enums.Rbw: Resolution bandwidth to be used for the area. K030: 30 kHz K100: 100 kHz M1: 1 MHz"""
 		__meta_args_list = [
 			ArgStruct.scalar_bool('Enable'),
 			ArgStruct.scalar_float('Frequency_Start'),
 			ArgStruct.scalar_float('Frequency_End'),
 			ArgStruct.scalar_float('Level'),
 			ArgStruct.scalar_enum('Rbw', enums.Rbw)]
 
@@ -47,50 +74,32 @@
 			StructBase.__init__(self, self)
 			self.Enable: bool = None
 			self.Frequency_Start: float = None
 			self.Frequency_End: float = None
 			self.Level: float = None
 			self.Rbw: enums.Rbw = None
 
-	def set(self, structure: ChannelBw3rdStruct, limit=repcap.Limit.Default, firstChannelBw=repcap.FirstChannelBw.Default, secondChannelBw=repcap.SecondChannelBw.Default, thirdChannelBw=repcap.ThirdChannelBw.Default) -> None:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:SEMask:LIMit<nr>:CAGGregation:CBANdwidth<Band1>:CBANdwidth<Band2>:CBANdwidth<Band3> \n
-		Snippet: driver.configure.multiEval.limit.seMask.limit.carrierAggregation.channelBw1st.channelBw2nd.channelBw3rd.set(value = [PROPERTY_STRUCT_NAME](), limit = repcap.Limit.Default, firstChannelBw = repcap.FirstChannelBw.Default, secondChannelBw = repcap.SecondChannelBw.Default, thirdChannelBw = repcap.ThirdChannelBw.Default) \n
-		Defines general requirements for the emission mask area <no>. The activation state, the area borders, an upper limit and
-		the resolution bandwidth must be specified. The settings are defined separately for each channel bandwidth combination,
-		for three aggregated carriers. The following bandwidth combinations are supported: Example: For the first line in the
-		figure, use ...:CBANdwidth200:CBANdwidth150:CBANdwidth100. \n
-			:param structure: for set value, see the help for ChannelBw3rdStruct structure arguments.
-			:param limit: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Limit')
-			:param firstChannelBw: optional repeated capability selector. Default value: Bw100 (settable in the interface 'ChannelBw1st')
-			:param secondChannelBw: optional repeated capability selector. Default value: Bw50 (settable in the interface 'ChannelBw2nd')
-			:param thirdChannelBw: optional repeated capability selector. Default value: Bw100 (settable in the interface 'ChannelBw3rd')"""
-		limit_cmd_val = self._base.get_repcap_cmd_value(limit, repcap.Limit)
-		firstChannelBw_cmd_val = self._base.get_repcap_cmd_value(firstChannelBw, repcap.FirstChannelBw)
-		secondChannelBw_cmd_val = self._base.get_repcap_cmd_value(secondChannelBw, repcap.SecondChannelBw)
-		thirdChannelBw_cmd_val = self._base.get_repcap_cmd_value(thirdChannelBw, repcap.ThirdChannelBw)
-		self._core.io.write_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:SEMask:LIMit{limit_cmd_val}:CAGGregation:CBANdwidth{firstChannelBw_cmd_val}:CBANdwidth{secondChannelBw_cmd_val}:CBANdwidth{thirdChannelBw_cmd_val}', structure)
-
 	def get(self, limit=repcap.Limit.Default, firstChannelBw=repcap.FirstChannelBw.Default, secondChannelBw=repcap.SecondChannelBw.Default, thirdChannelBw=repcap.ThirdChannelBw.Default) -> ChannelBw3rdStruct:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:SEMask:LIMit<nr>:CAGGregation:CBANdwidth<Band1>:CBANdwidth<Band2>:CBANdwidth<Band3> \n
-		Snippet: value: ChannelBw3rdStruct = driver.configure.multiEval.limit.seMask.limit.carrierAggregation.channelBw1st.channelBw2nd.channelBw3rd.get(limit = repcap.Limit.Default, firstChannelBw = repcap.FirstChannelBw.Default, secondChannelBw = repcap.SecondChannelBw.Default, thirdChannelBw = repcap.ThirdChannelBw.Default) \n
+		Snippet: value: ChannelBw3rdStruct = driver.configure.lteMeas.multiEval.limit.seMask.limit.carrierAggregation.channelBw1st.channelBw2nd.channelBw3rd.get(limit = repcap.Limit.Default, firstChannelBw = repcap.FirstChannelBw.Default, secondChannelBw = repcap.SecondChannelBw.Default, thirdChannelBw = repcap.ThirdChannelBw.Default) \n
 		Defines general requirements for the emission mask area <no>. The activation state, the area borders, an upper limit and
 		the resolution bandwidth must be specified. The settings are defined separately for each channel bandwidth combination,
 		for three aggregated carriers. The following bandwidth combinations are supported: Example: For the first line in the
 		figure, use ...:CBANdwidth200:CBANdwidth150:CBANdwidth100. \n
 			:param limit: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Limit')
 			:param firstChannelBw: optional repeated capability selector. Default value: Bw100 (settable in the interface 'ChannelBw1st')
 			:param secondChannelBw: optional repeated capability selector. Default value: Bw50 (settable in the interface 'ChannelBw2nd')
 			:param thirdChannelBw: optional repeated capability selector. Default value: Bw100 (settable in the interface 'ChannelBw3rd')
 			:return: structure: for return value, see the help for ChannelBw3rdStruct structure arguments."""
-		limit_cmd_val = self._base.get_repcap_cmd_value(limit, repcap.Limit)
-		firstChannelBw_cmd_val = self._base.get_repcap_cmd_value(firstChannelBw, repcap.FirstChannelBw)
-		secondChannelBw_cmd_val = self._base.get_repcap_cmd_value(secondChannelBw, repcap.SecondChannelBw)
-		thirdChannelBw_cmd_val = self._base.get_repcap_cmd_value(thirdChannelBw, repcap.ThirdChannelBw)
+		limit_cmd_val = self._cmd_group.get_repcap_cmd_value(limit, repcap.Limit)
+		firstChannelBw_cmd_val = self._cmd_group.get_repcap_cmd_value(firstChannelBw, repcap.FirstChannelBw)
+		secondChannelBw_cmd_val = self._cmd_group.get_repcap_cmd_value(secondChannelBw, repcap.SecondChannelBw)
+		thirdChannelBw_cmd_val = self._cmd_group.get_repcap_cmd_value(thirdChannelBw, repcap.ThirdChannelBw)
 		return self._core.io.query_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:SEMask:LIMit{limit_cmd_val}:CAGGregation:CBANdwidth{firstChannelBw_cmd_val}:CBANdwidth{secondChannelBw_cmd_val}:CBANdwidth{thirdChannelBw_cmd_val}?', self.__class__.ChannelBw3rdStruct())
 
-	def clone(self) -> 'ChannelBw3rd':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'ChannelBw3rdCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = ChannelBw3rd(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = ChannelBw3rdCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/Limit_/ChannelBw.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Limit/SeMask/Limit/ChannelBw.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,45 +1,66 @@
-from .......Internal.Core import Core
-from .......Internal.CommandsGroup import CommandsGroup
-from .......Internal.StructBase import StructBase
-from .......Internal.ArgStruct import ArgStruct
-from .......Internal.RepeatedCapability import RepeatedCapability
-from ....... import enums
-from ....... import repcap
+from ........Internal.Core import Core
+from ........Internal.CommandsGroup import CommandsGroup
+from ........Internal.Types import DataType
+from ........Internal.StructBase import StructBase
+from ........Internal.ArgStruct import ArgStruct
+from ........Internal.ArgSingleList import ArgSingleList
+from ........Internal.ArgSingle import ArgSingle
+from ........Internal.RepeatedCapability import RepeatedCapability
+from ........ import enums
+from ........ import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class ChannelBw:
-	"""ChannelBw commands group definition. 1 total commands, 0 Sub-groups, 1 group commands
+class ChannelBwCls:
+	"""ChannelBw commands group definition. 1 total commands, 0 Subgroups, 1 group commands
 	Repeated Capability: ChannelBw, default value after init: ChannelBw.Bw14"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("channelBw", core, parent)
-		self._base.rep_cap = RepeatedCapability(self._base.group_name, 'repcap_channelBw_get', 'repcap_channelBw_set', repcap.ChannelBw.Bw14)
+		self._cmd_group = CommandsGroup("channelBw", core, parent)
+		self._cmd_group.rep_cap = RepeatedCapability(self._cmd_group.group_name, 'repcap_channelBw_get', 'repcap_channelBw_set', repcap.ChannelBw.Bw14)
 
-	def repcap_channelBw_set(self, enum_value: repcap.ChannelBw) -> None:
+	def repcap_channelBw_set(self, channelBw: repcap.ChannelBw) -> None:
 		"""Repeated Capability default value numeric suffix.
 		This value is used, if you do not explicitely set it in the child set/get methods, or if you leave it to ChannelBw.Default
 		Default value after init: ChannelBw.Bw14"""
-		self._base.set_repcap_enum_value(enum_value)
+		self._cmd_group.set_repcap_enum_value(channelBw)
 
 	def repcap_channelBw_get(self) -> repcap.ChannelBw:
 		"""Returns the current default repeated capability for the child set/get methods"""
 		# noinspection PyTypeChecker
-		return self._base.get_repcap_enum_value()
+		return self._cmd_group.get_repcap_enum_value()
+
+	def set(self, enable: bool, frequency_start: float, frequency_end: float, level: float, rbw: enums.Rbw, limit=repcap.Limit.Default, channelBw=repcap.ChannelBw.Default) -> None:
+		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:SEMask:LIMit<nr>:CBANdwidth<Band> \n
+		Snippet: driver.configure.lteMeas.multiEval.limit.seMask.limit.channelBw.set(enable = False, frequency_start = 1.0, frequency_end = 1.0, level = 1.0, rbw = enums.Rbw.K030, limit = repcap.Limit.Default, channelBw = repcap.ChannelBw.Default) \n
+		Defines general requirements for the emission mask area <no>. The activation state, the area borders, an upper limit and
+		the resolution bandwidth must be specified. The emission mask applies to the channel bandwidth <Band>. \n
+			:param enable: OFF: Disables the check of these requirements. ON: Enables the check of these requirements.
+			:param frequency_start: Lower border of the area, relative to the edges of the channel bandwidth.
+			:param frequency_end: Upper border of the area, relative to the edges of the channel bandwidth.
+			:param level: Upper limit for the area
+			:param rbw: Resolution bandwidth to be used for the area. K030: 30 kHz K100: 100 kHz M1: 1 MHz
+			:param limit: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Limit')
+			:param channelBw: optional repeated capability selector. Default value: Bw14 (settable in the interface 'ChannelBw')
+		"""
+		param = ArgSingleList().compose_cmd_string(ArgSingle('enable', enable, DataType.Boolean), ArgSingle('frequency_start', frequency_start, DataType.Float), ArgSingle('frequency_end', frequency_end, DataType.Float), ArgSingle('level', level, DataType.Float), ArgSingle('rbw', rbw, DataType.Enum, enums.Rbw))
+		limit_cmd_val = self._cmd_group.get_repcap_cmd_value(limit, repcap.Limit)
+		channelBw_cmd_val = self._cmd_group.get_repcap_cmd_value(channelBw, repcap.ChannelBw)
+		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:SEMask:LIMit{limit_cmd_val}:CBANdwidth{channelBw_cmd_val} {param}'.rstrip())
 
 	# noinspection PyTypeChecker
 	class ChannelBwStruct(StructBase):
-		"""Structure for setting input parameters. Fields: \n
-			- Enable: bool: OFF: disables the check of these requirements ON: enables the check of these requirements
-			- Frequency_Start: float: Start frequency of the area, relative to the edges of the channel bandwidth
-			- Frequency_End: float: Stop frequency of the area, relative to the edges of the channel bandwidth
+		"""Response structure. Fields: \n
+			- Enable: bool: OFF: Disables the check of these requirements. ON: Enables the check of these requirements.
+			- Frequency_Start: float: Lower border of the area, relative to the edges of the channel bandwidth.
+			- Frequency_End: float: Upper border of the area, relative to the edges of the channel bandwidth.
 			- Level: float: Upper limit for the area
-			- Rbw: enums.Rbw: Resolution bandwidth to be used for the area K030: 30 kHz K100: 100 kHz M1: 1 MHz"""
+			- Rbw: enums.Rbw: Resolution bandwidth to be used for the area. K030: 30 kHz K100: 100 kHz M1: 1 MHz"""
 		__meta_args_list = [
 			ArgStruct.scalar_bool('Enable'),
 			ArgStruct.scalar_float('Frequency_Start'),
 			ArgStruct.scalar_float('Frequency_End'),
 			ArgStruct.scalar_float('Level'),
 			ArgStruct.scalar_enum('Rbw', enums.Rbw)]
 
@@ -47,38 +68,26 @@
 			StructBase.__init__(self, self)
 			self.Enable: bool = None
 			self.Frequency_Start: float = None
 			self.Frequency_End: float = None
 			self.Level: float = None
 			self.Rbw: enums.Rbw = None
 
-	def set(self, structure: ChannelBwStruct, limit=repcap.Limit.Default, channelBw=repcap.ChannelBw.Default) -> None:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:SEMask:LIMit<nr>:CBANdwidth<Band> \n
-		Snippet: driver.configure.multiEval.limit.seMask.limit.channelBw.set(value = [PROPERTY_STRUCT_NAME](), limit = repcap.Limit.Default, channelBw = repcap.ChannelBw.Default) \n
-		Defines general requirements for the emission mask area <no>. The activation state, the area borders, an upper limit and
-		the resolution bandwidth must be specified. The emission mask applies to the channel bandwidth <Band>. \n
-			:param structure: for set value, see the help for ChannelBwStruct structure arguments.
-			:param limit: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Limit')
-			:param channelBw: optional repeated capability selector. Default value: Bw14 (settable in the interface 'ChannelBw')"""
-		limit_cmd_val = self._base.get_repcap_cmd_value(limit, repcap.Limit)
-		channelBw_cmd_val = self._base.get_repcap_cmd_value(channelBw, repcap.ChannelBw)
-		self._core.io.write_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:SEMask:LIMit{limit_cmd_val}:CBANdwidth{channelBw_cmd_val}', structure)
-
 	def get(self, limit=repcap.Limit.Default, channelBw=repcap.ChannelBw.Default) -> ChannelBwStruct:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:SEMask:LIMit<nr>:CBANdwidth<Band> \n
-		Snippet: value: ChannelBwStruct = driver.configure.multiEval.limit.seMask.limit.channelBw.get(limit = repcap.Limit.Default, channelBw = repcap.ChannelBw.Default) \n
+		Snippet: value: ChannelBwStruct = driver.configure.lteMeas.multiEval.limit.seMask.limit.channelBw.get(limit = repcap.Limit.Default, channelBw = repcap.ChannelBw.Default) \n
 		Defines general requirements for the emission mask area <no>. The activation state, the area borders, an upper limit and
 		the resolution bandwidth must be specified. The emission mask applies to the channel bandwidth <Band>. \n
 			:param limit: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Limit')
 			:param channelBw: optional repeated capability selector. Default value: Bw14 (settable in the interface 'ChannelBw')
 			:return: structure: for return value, see the help for ChannelBwStruct structure arguments."""
-		limit_cmd_val = self._base.get_repcap_cmd_value(limit, repcap.Limit)
-		channelBw_cmd_val = self._base.get_repcap_cmd_value(channelBw, repcap.ChannelBw)
+		limit_cmd_val = self._cmd_group.get_repcap_cmd_value(limit, repcap.Limit)
+		channelBw_cmd_val = self._cmd_group.get_repcap_cmd_value(channelBw, repcap.ChannelBw)
 		return self._core.io.query_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:SEMask:LIMit{limit_cmd_val}:CBANdwidth{channelBw_cmd_val}?', self.__class__.ChannelBwStruct())
 
-	def clone(self) -> 'ChannelBw':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'ChannelBwCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = ChannelBw(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = ChannelBwCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/ObwLimit.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Pmonitor/Ulca/__init__.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,35 +1,35 @@
 from ......Internal.Core import Core
 from ......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class ObwLimit:
-	"""ObwLimit commands group definition. 4 total commands, 2 Sub-groups, 0 group commands"""
+class UlcaCls:
+	"""Ulca commands group definition. 20 total commands, 2 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("obwLimit", core, parent)
+		self._cmd_group = CommandsGroup("ulca", core, parent)
 
 	@property
-	def channelBw(self):
-		"""channelBw commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_channelBw'):
-			from .ObwLimit_.ChannelBw import ChannelBw
-			self._channelBw = ChannelBw(self._core, self._base)
-		return self._channelBw
+	def scc(self):
+		"""scc commands group. 5 Sub-classes, 0 commands."""
+		if not hasattr(self, '_scc'):
+			from .Scc import SccCls
+			self._scc = SccCls(self._core, self._cmd_group)
+		return self._scc
 
 	@property
-	def carrierAggregation(self):
-		"""carrierAggregation commands group. 1 Sub-classes, 1 commands."""
-		if not hasattr(self, '_carrierAggregation'):
-			from .ObwLimit_.CarrierAggregation import CarrierAggregation
-			self._carrierAggregation = CarrierAggregation(self._core, self._base)
-		return self._carrierAggregation
+	def pcc(self):
+		"""pcc commands group. 5 Sub-classes, 0 commands."""
+		if not hasattr(self, '_pcc'):
+			from .Pcc import PccCls
+			self._pcc = PccCls(self._core, self._cmd_group)
+		return self._pcc
 
-	def clone(self) -> 'ObwLimit':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'UlcaCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = ObwLimit(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = UlcaCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/ObwLimit_/CarrierAggregation_/ChannelBw1st.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Limit/SeMask/ObwLimit/CarrierAggregation/ChannelBw1st/__init__.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,42 +1,42 @@
-from ........Internal.Core import Core
-from ........Internal.CommandsGroup import CommandsGroup
-from ........Internal.RepeatedCapability import RepeatedCapability
-from ........ import repcap
+from ..........Internal.Core import Core
+from ..........Internal.CommandsGroup import CommandsGroup
+from ..........Internal.RepeatedCapability import RepeatedCapability
+from .......... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class ChannelBw1st:
-	"""ChannelBw1st commands group definition. 2 total commands, 1 Sub-groups, 0 group commands
+class ChannelBw1stCls:
+	"""ChannelBw1st commands group definition. 2 total commands, 1 Subgroups, 0 group commands
 	Repeated Capability: FirstChannelBw, default value after init: FirstChannelBw.Bw100"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("channelBw1st", core, parent)
-		self._base.rep_cap = RepeatedCapability(self._base.group_name, 'repcap_firstChannelBw_get', 'repcap_firstChannelBw_set', repcap.FirstChannelBw.Bw100)
+		self._cmd_group = CommandsGroup("channelBw1st", core, parent)
+		self._cmd_group.rep_cap = RepeatedCapability(self._cmd_group.group_name, 'repcap_firstChannelBw_get', 'repcap_firstChannelBw_set', repcap.FirstChannelBw.Bw100)
 
-	def repcap_firstChannelBw_set(self, enum_value: repcap.FirstChannelBw) -> None:
+	def repcap_firstChannelBw_set(self, firstChannelBw: repcap.FirstChannelBw) -> None:
 		"""Repeated Capability default value numeric suffix.
 		This value is used, if you do not explicitely set it in the child set/get methods, or if you leave it to FirstChannelBw.Default
 		Default value after init: FirstChannelBw.Bw100"""
-		self._base.set_repcap_enum_value(enum_value)
+		self._cmd_group.set_repcap_enum_value(firstChannelBw)
 
 	def repcap_firstChannelBw_get(self) -> repcap.FirstChannelBw:
 		"""Returns the current default repeated capability for the child set/get methods"""
 		# noinspection PyTypeChecker
-		return self._base.get_repcap_enum_value()
+		return self._cmd_group.get_repcap_enum_value()
 
 	@property
 	def channelBw2nd(self):
 		"""channelBw2nd commands group. 1 Sub-classes, 1 commands."""
 		if not hasattr(self, '_channelBw2nd'):
-			from .ChannelBw1st_.ChannelBw2nd import ChannelBw2nd
-			self._channelBw2nd = ChannelBw2nd(self._core, self._base)
+			from .ChannelBw2nd import ChannelBw2ndCls
+			self._channelBw2nd = ChannelBw2ndCls(self._core, self._cmd_group)
 		return self._channelBw2nd
 
-	def clone(self) -> 'ChannelBw1st':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'ChannelBw1stCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = ChannelBw1st(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = ChannelBw1stCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/ObwLimit_/CarrierAggregation_/ChannelBw1st_/ChannelBw2nd.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Limit/SeMask/ObwLimit/CarrierAggregation/ChannelBw1st/ChannelBw2nd/__init__.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,71 +1,72 @@
-from .........Internal.Core import Core
-from .........Internal.CommandsGroup import CommandsGroup
-from .........Internal import Conversions
-from .........Internal.RepeatedCapability import RepeatedCapability
-from ......... import repcap
+from ...........Internal.Core import Core
+from ...........Internal.CommandsGroup import CommandsGroup
+from ...........Internal import Conversions
+from ...........Internal.RepeatedCapability import RepeatedCapability
+from ........... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class ChannelBw2nd:
-	"""ChannelBw2nd commands group definition. 2 total commands, 1 Sub-groups, 1 group commands
+class ChannelBw2ndCls:
+	"""ChannelBw2nd commands group definition. 2 total commands, 1 Subgroups, 1 group commands
 	Repeated Capability: SecondChannelBw, default value after init: SecondChannelBw.Bw50"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("channelBw2nd", core, parent)
-		self._base.rep_cap = RepeatedCapability(self._base.group_name, 'repcap_secondChannelBw_get', 'repcap_secondChannelBw_set', repcap.SecondChannelBw.Bw50)
+		self._cmd_group = CommandsGroup("channelBw2nd", core, parent)
+		self._cmd_group.rep_cap = RepeatedCapability(self._cmd_group.group_name, 'repcap_secondChannelBw_get', 'repcap_secondChannelBw_set', repcap.SecondChannelBw.Bw50)
 
-	def repcap_secondChannelBw_set(self, enum_value: repcap.SecondChannelBw) -> None:
+	def repcap_secondChannelBw_set(self, secondChannelBw: repcap.SecondChannelBw) -> None:
 		"""Repeated Capability default value numeric suffix.
 		This value is used, if you do not explicitely set it in the child set/get methods, or if you leave it to SecondChannelBw.Default
 		Default value after init: SecondChannelBw.Bw50"""
-		self._base.set_repcap_enum_value(enum_value)
+		self._cmd_group.set_repcap_enum_value(secondChannelBw)
 
 	def repcap_secondChannelBw_get(self) -> repcap.SecondChannelBw:
 		"""Returns the current default repeated capability for the child set/get methods"""
 		# noinspection PyTypeChecker
-		return self._base.get_repcap_enum_value()
+		return self._cmd_group.get_repcap_enum_value()
 
 	@property
 	def channelBw3rd(self):
 		"""channelBw3rd commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_channelBw3rd'):
-			from .ChannelBw2nd_.ChannelBw3rd import ChannelBw3rd
-			self._channelBw3rd = ChannelBw3rd(self._core, self._base)
+			from .ChannelBw3rd import ChannelBw3rdCls
+			self._channelBw3rd = ChannelBw3rdCls(self._core, self._cmd_group)
 		return self._channelBw3rd
 
 	def set(self, obw_limit: float or bool, firstChannelBw=repcap.FirstChannelBw.Default, secondChannelBw=repcap.SecondChannelBw.Default) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:SEMask:OBWLimit:CAGGregation:CBANdwidth<Band1>:CBANdwidth<Band2> \n
-		Snippet: driver.configure.multiEval.limit.seMask.obwLimit.carrierAggregation.channelBw1st.channelBw2nd.set(obw_limit = 1.0, firstChannelBw = repcap.FirstChannelBw.Default, secondChannelBw = repcap.SecondChannelBw.Default) \n
+		Snippet: driver.configure.lteMeas.multiEval.limit.seMask.obwLimit.carrierAggregation.channelBw1st.channelBw2nd.set(obw_limit = 1.0, firstChannelBw = repcap.FirstChannelBw.Default, secondChannelBw = repcap.SecondChannelBw.Default) \n
 		Defines an upper limit for the occupied bandwidth. The setting is defined separately for each channel bandwidth
 		combination, for two aggregated carriers. The following bandwidth combinations are supported: Example: For the first line
 		in the figure, use ...:CBANdwidth100:CBANdwidth50. \n
-			:param obw_limit: No help available
+			:param obw_limit: (float or boolean) No help available
 			:param firstChannelBw: optional repeated capability selector. Default value: Bw100 (settable in the interface 'ChannelBw1st')
-			:param secondChannelBw: optional repeated capability selector. Default value: Bw50 (settable in the interface 'ChannelBw2nd')"""
+			:param secondChannelBw: optional repeated capability selector. Default value: Bw50 (settable in the interface 'ChannelBw2nd')
+		"""
 		param = Conversions.decimal_or_bool_value_to_str(obw_limit)
-		firstChannelBw_cmd_val = self._base.get_repcap_cmd_value(firstChannelBw, repcap.FirstChannelBw)
-		secondChannelBw_cmd_val = self._base.get_repcap_cmd_value(secondChannelBw, repcap.SecondChannelBw)
+		firstChannelBw_cmd_val = self._cmd_group.get_repcap_cmd_value(firstChannelBw, repcap.FirstChannelBw)
+		secondChannelBw_cmd_val = self._cmd_group.get_repcap_cmd_value(secondChannelBw, repcap.SecondChannelBw)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:SEMask:OBWLimit:CAGGregation:CBANdwidth{firstChannelBw_cmd_val}:CBANdwidth{secondChannelBw_cmd_val} {param}')
 
 	def get(self, firstChannelBw=repcap.FirstChannelBw.Default, secondChannelBw=repcap.SecondChannelBw.Default) -> float or bool:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:SEMask:OBWLimit:CAGGregation:CBANdwidth<Band1>:CBANdwidth<Band2> \n
-		Snippet: value: float or bool = driver.configure.multiEval.limit.seMask.obwLimit.carrierAggregation.channelBw1st.channelBw2nd.get(firstChannelBw = repcap.FirstChannelBw.Default, secondChannelBw = repcap.SecondChannelBw.Default) \n
+		Snippet: value: float or bool = driver.configure.lteMeas.multiEval.limit.seMask.obwLimit.carrierAggregation.channelBw1st.channelBw2nd.get(firstChannelBw = repcap.FirstChannelBw.Default, secondChannelBw = repcap.SecondChannelBw.Default) \n
 		Defines an upper limit for the occupied bandwidth. The setting is defined separately for each channel bandwidth
 		combination, for two aggregated carriers. The following bandwidth combinations are supported: Example: For the first line
 		in the figure, use ...:CBANdwidth100:CBANdwidth50. \n
 			:param firstChannelBw: optional repeated capability selector. Default value: Bw100 (settable in the interface 'ChannelBw1st')
 			:param secondChannelBw: optional repeated capability selector. Default value: Bw50 (settable in the interface 'ChannelBw2nd')
-			:return: obw_limit: No help available"""
-		firstChannelBw_cmd_val = self._base.get_repcap_cmd_value(firstChannelBw, repcap.FirstChannelBw)
-		secondChannelBw_cmd_val = self._base.get_repcap_cmd_value(secondChannelBw, repcap.SecondChannelBw)
+			:return: obw_limit: (float or boolean) No help available"""
+		firstChannelBw_cmd_val = self._cmd_group.get_repcap_cmd_value(firstChannelBw, repcap.FirstChannelBw)
+		secondChannelBw_cmd_val = self._cmd_group.get_repcap_cmd_value(secondChannelBw, repcap.SecondChannelBw)
 		response = self._core.io.query_str(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:SEMask:OBWLimit:CAGGregation:CBANdwidth{firstChannelBw_cmd_val}:CBANdwidth{secondChannelBw_cmd_val}?')
 		return Conversions.str_to_float_or_bool(response)
 
-	def clone(self) -> 'ChannelBw2nd':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'ChannelBw2ndCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = ChannelBw2nd(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = ChannelBw2ndCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/ObwLimit_/CarrierAggregation_/ChannelBw1st_/ChannelBw2nd_/ChannelBw3rd.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Limit/SeMask/ObwLimit/CarrierAggregation/ChannelBw1st/ChannelBw2nd/ChannelBw3rd.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,67 +1,68 @@
-from ..........Internal.Core import Core
-from ..........Internal.CommandsGroup import CommandsGroup
-from ..........Internal import Conversions
-from ..........Internal.RepeatedCapability import RepeatedCapability
-from .......... import repcap
+from ...........Internal.Core import Core
+from ...........Internal.CommandsGroup import CommandsGroup
+from ...........Internal import Conversions
+from ...........Internal.RepeatedCapability import RepeatedCapability
+from ........... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class ChannelBw3rd:
-	"""ChannelBw3rd commands group definition. 1 total commands, 0 Sub-groups, 1 group commands
+class ChannelBw3rdCls:
+	"""ChannelBw3rd commands group definition. 1 total commands, 0 Subgroups, 1 group commands
 	Repeated Capability: ThirdChannelBw, default value after init: ThirdChannelBw.Bw100"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("channelBw3rd", core, parent)
-		self._base.rep_cap = RepeatedCapability(self._base.group_name, 'repcap_thirdChannelBw_get', 'repcap_thirdChannelBw_set', repcap.ThirdChannelBw.Bw100)
+		self._cmd_group = CommandsGroup("channelBw3rd", core, parent)
+		self._cmd_group.rep_cap = RepeatedCapability(self._cmd_group.group_name, 'repcap_thirdChannelBw_get', 'repcap_thirdChannelBw_set', repcap.ThirdChannelBw.Bw100)
 
-	def repcap_thirdChannelBw_set(self, enum_value: repcap.ThirdChannelBw) -> None:
+	def repcap_thirdChannelBw_set(self, thirdChannelBw: repcap.ThirdChannelBw) -> None:
 		"""Repeated Capability default value numeric suffix.
 		This value is used, if you do not explicitely set it in the child set/get methods, or if you leave it to ThirdChannelBw.Default
 		Default value after init: ThirdChannelBw.Bw100"""
-		self._base.set_repcap_enum_value(enum_value)
+		self._cmd_group.set_repcap_enum_value(thirdChannelBw)
 
 	def repcap_thirdChannelBw_get(self) -> repcap.ThirdChannelBw:
 		"""Returns the current default repeated capability for the child set/get methods"""
 		# noinspection PyTypeChecker
-		return self._base.get_repcap_enum_value()
+		return self._cmd_group.get_repcap_enum_value()
 
 	def set(self, obw_limit: float or bool, firstChannelBw=repcap.FirstChannelBw.Default, secondChannelBw=repcap.SecondChannelBw.Default, thirdChannelBw=repcap.ThirdChannelBw.Default) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:SEMask:OBWLimit:CAGGregation:CBANdwidth<Band1>:CBANdwidth<Band2>:CBANdwidth<Band3> \n
-		Snippet: driver.configure.multiEval.limit.seMask.obwLimit.carrierAggregation.channelBw1st.channelBw2nd.channelBw3rd.set(obw_limit = 1.0, firstChannelBw = repcap.FirstChannelBw.Default, secondChannelBw = repcap.SecondChannelBw.Default, thirdChannelBw = repcap.ThirdChannelBw.Default) \n
+		Snippet: driver.configure.lteMeas.multiEval.limit.seMask.obwLimit.carrierAggregation.channelBw1st.channelBw2nd.channelBw3rd.set(obw_limit = 1.0, firstChannelBw = repcap.FirstChannelBw.Default, secondChannelBw = repcap.SecondChannelBw.Default, thirdChannelBw = repcap.ThirdChannelBw.Default) \n
 		Defines an upper limit for the occupied bandwidth. The settings are defined separately for each channel bandwidth
 		combination, for three aggregated carriers. The following bandwidth combinations are supported: Example: For the first
 		line in the figure, use ...:CBANdwidth200:CBANdwidth150:CBANdwidth100. \n
-			:param obw_limit: No help available
+			:param obw_limit: (float or boolean) No help available
 			:param firstChannelBw: optional repeated capability selector. Default value: Bw100 (settable in the interface 'ChannelBw1st')
 			:param secondChannelBw: optional repeated capability selector. Default value: Bw50 (settable in the interface 'ChannelBw2nd')
-			:param thirdChannelBw: optional repeated capability selector. Default value: Bw100 (settable in the interface 'ChannelBw3rd')"""
+			:param thirdChannelBw: optional repeated capability selector. Default value: Bw100 (settable in the interface 'ChannelBw3rd')
+		"""
 		param = Conversions.decimal_or_bool_value_to_str(obw_limit)
-		firstChannelBw_cmd_val = self._base.get_repcap_cmd_value(firstChannelBw, repcap.FirstChannelBw)
-		secondChannelBw_cmd_val = self._base.get_repcap_cmd_value(secondChannelBw, repcap.SecondChannelBw)
-		thirdChannelBw_cmd_val = self._base.get_repcap_cmd_value(thirdChannelBw, repcap.ThirdChannelBw)
+		firstChannelBw_cmd_val = self._cmd_group.get_repcap_cmd_value(firstChannelBw, repcap.FirstChannelBw)
+		secondChannelBw_cmd_val = self._cmd_group.get_repcap_cmd_value(secondChannelBw, repcap.SecondChannelBw)
+		thirdChannelBw_cmd_val = self._cmd_group.get_repcap_cmd_value(thirdChannelBw, repcap.ThirdChannelBw)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:SEMask:OBWLimit:CAGGregation:CBANdwidth{firstChannelBw_cmd_val}:CBANdwidth{secondChannelBw_cmd_val}:CBANdwidth{thirdChannelBw_cmd_val} {param}')
 
 	def get(self, firstChannelBw=repcap.FirstChannelBw.Default, secondChannelBw=repcap.SecondChannelBw.Default, thirdChannelBw=repcap.ThirdChannelBw.Default) -> float or bool:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:SEMask:OBWLimit:CAGGregation:CBANdwidth<Band1>:CBANdwidth<Band2>:CBANdwidth<Band3> \n
-		Snippet: value: float or bool = driver.configure.multiEval.limit.seMask.obwLimit.carrierAggregation.channelBw1st.channelBw2nd.channelBw3rd.get(firstChannelBw = repcap.FirstChannelBw.Default, secondChannelBw = repcap.SecondChannelBw.Default, thirdChannelBw = repcap.ThirdChannelBw.Default) \n
+		Snippet: value: float or bool = driver.configure.lteMeas.multiEval.limit.seMask.obwLimit.carrierAggregation.channelBw1st.channelBw2nd.channelBw3rd.get(firstChannelBw = repcap.FirstChannelBw.Default, secondChannelBw = repcap.SecondChannelBw.Default, thirdChannelBw = repcap.ThirdChannelBw.Default) \n
 		Defines an upper limit for the occupied bandwidth. The settings are defined separately for each channel bandwidth
 		combination, for three aggregated carriers. The following bandwidth combinations are supported: Example: For the first
 		line in the figure, use ...:CBANdwidth200:CBANdwidth150:CBANdwidth100. \n
 			:param firstChannelBw: optional repeated capability selector. Default value: Bw100 (settable in the interface 'ChannelBw1st')
 			:param secondChannelBw: optional repeated capability selector. Default value: Bw50 (settable in the interface 'ChannelBw2nd')
 			:param thirdChannelBw: optional repeated capability selector. Default value: Bw100 (settable in the interface 'ChannelBw3rd')
-			:return: obw_limit: No help available"""
-		firstChannelBw_cmd_val = self._base.get_repcap_cmd_value(firstChannelBw, repcap.FirstChannelBw)
-		secondChannelBw_cmd_val = self._base.get_repcap_cmd_value(secondChannelBw, repcap.SecondChannelBw)
-		thirdChannelBw_cmd_val = self._base.get_repcap_cmd_value(thirdChannelBw, repcap.ThirdChannelBw)
+			:return: obw_limit: (float or boolean) No help available"""
+		firstChannelBw_cmd_val = self._cmd_group.get_repcap_cmd_value(firstChannelBw, repcap.FirstChannelBw)
+		secondChannelBw_cmd_val = self._cmd_group.get_repcap_cmd_value(secondChannelBw, repcap.SecondChannelBw)
+		thirdChannelBw_cmd_val = self._cmd_group.get_repcap_cmd_value(thirdChannelBw, repcap.ThirdChannelBw)
 		response = self._core.io.query_str(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:SEMask:OBWLimit:CAGGregation:CBANdwidth{firstChannelBw_cmd_val}:CBANdwidth{secondChannelBw_cmd_val}:CBANdwidth{thirdChannelBw_cmd_val}?')
 		return Conversions.str_to_float_or_bool(response)
 
-	def clone(self) -> 'ChannelBw3rd':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'ChannelBw3rdCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = ChannelBw3rd(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = ChannelBw3rdCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Limit_/SeMask_/ObwLimit_/ChannelBw.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Limit/SeMask/ObwLimit/ChannelBw.py`

 * *Files 23% similar despite different names*

```diff
@@ -1,55 +1,56 @@
-from .......Internal.Core import Core
-from .......Internal.CommandsGroup import CommandsGroup
-from .......Internal import Conversions
-from .......Internal.RepeatedCapability import RepeatedCapability
-from ....... import repcap
+from ........Internal.Core import Core
+from ........Internal.CommandsGroup import CommandsGroup
+from ........Internal import Conversions
+from ........Internal.RepeatedCapability import RepeatedCapability
+from ........ import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class ChannelBw:
-	"""ChannelBw commands group definition. 1 total commands, 0 Sub-groups, 1 group commands
+class ChannelBwCls:
+	"""ChannelBw commands group definition. 1 total commands, 0 Subgroups, 1 group commands
 	Repeated Capability: ChannelBw, default value after init: ChannelBw.Bw14"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("channelBw", core, parent)
-		self._base.rep_cap = RepeatedCapability(self._base.group_name, 'repcap_channelBw_get', 'repcap_channelBw_set', repcap.ChannelBw.Bw14)
+		self._cmd_group = CommandsGroup("channelBw", core, parent)
+		self._cmd_group.rep_cap = RepeatedCapability(self._cmd_group.group_name, 'repcap_channelBw_get', 'repcap_channelBw_set', repcap.ChannelBw.Bw14)
 
-	def repcap_channelBw_set(self, enum_value: repcap.ChannelBw) -> None:
+	def repcap_channelBw_set(self, channelBw: repcap.ChannelBw) -> None:
 		"""Repeated Capability default value numeric suffix.
 		This value is used, if you do not explicitely set it in the child set/get methods, or if you leave it to ChannelBw.Default
 		Default value after init: ChannelBw.Bw14"""
-		self._base.set_repcap_enum_value(enum_value)
+		self._cmd_group.set_repcap_enum_value(channelBw)
 
 	def repcap_channelBw_get(self) -> repcap.ChannelBw:
 		"""Returns the current default repeated capability for the child set/get methods"""
 		# noinspection PyTypeChecker
-		return self._base.get_repcap_enum_value()
+		return self._cmd_group.get_repcap_enum_value()
 
 	def set(self, obw_limit: float or bool, channelBw=repcap.ChannelBw.Default) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:SEMask:OBWLimit:CBANdwidth<Band> \n
-		Snippet: driver.configure.multiEval.limit.seMask.obwLimit.channelBw.set(obw_limit = 1.0, channelBw = repcap.ChannelBw.Default) \n
+		Snippet: driver.configure.lteMeas.multiEval.limit.seMask.obwLimit.channelBw.set(obw_limit = 1.0, channelBw = repcap.ChannelBw.Default) \n
 		Defines an upper limit for the occupied bandwidth, depending on the channel bandwidth. \n
-			:param obw_limit: No help available
-			:param channelBw: optional repeated capability selector. Default value: Bw14 (settable in the interface 'ChannelBw')"""
+			:param obw_limit: (float or boolean) No help available
+			:param channelBw: optional repeated capability selector. Default value: Bw14 (settable in the interface 'ChannelBw')
+		"""
 		param = Conversions.decimal_or_bool_value_to_str(obw_limit)
-		channelBw_cmd_val = self._base.get_repcap_cmd_value(channelBw, repcap.ChannelBw)
+		channelBw_cmd_val = self._cmd_group.get_repcap_cmd_value(channelBw, repcap.ChannelBw)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:SEMask:OBWLimit:CBANdwidth{channelBw_cmd_val} {param}')
 
 	def get(self, channelBw=repcap.ChannelBw.Default) -> float or bool:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:SEMask:OBWLimit:CBANdwidth<Band> \n
-		Snippet: value: float or bool = driver.configure.multiEval.limit.seMask.obwLimit.channelBw.get(channelBw = repcap.ChannelBw.Default) \n
+		Snippet: value: float or bool = driver.configure.lteMeas.multiEval.limit.seMask.obwLimit.channelBw.get(channelBw = repcap.ChannelBw.Default) \n
 		Defines an upper limit for the occupied bandwidth, depending on the channel bandwidth. \n
 			:param channelBw: optional repeated capability selector. Default value: Bw14 (settable in the interface 'ChannelBw')
-			:return: obw_limit: No help available"""
-		channelBw_cmd_val = self._base.get_repcap_cmd_value(channelBw, repcap.ChannelBw)
+			:return: obw_limit: (float or boolean) No help available"""
+		channelBw_cmd_val = self._cmd_group.get_repcap_cmd_value(channelBw, repcap.ChannelBw)
 		response = self._core.io.query_str(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:SEMask:OBWLimit:CBANdwidth{channelBw_cmd_val}?')
 		return Conversions.str_to_float_or_bool(response)
 
-	def clone(self) -> 'ChannelBw':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'ChannelBwCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = ChannelBw(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = ChannelBwCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/ListPy/Segment/__init__.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,146 +1,154 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
-from .....Internal.RepeatedCapability import RepeatedCapability
-from ..... import repcap
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal.RepeatedCapability import RepeatedCapability
+from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Segment:
-	"""Segment commands group definition. 17 total commands, 14 Sub-groups, 0 group commands
+class SegmentCls:
+	"""Segment commands group definition. 18 total commands, 15 Subgroups, 0 group commands
 	Repeated Capability: Segment, default value after init: Segment.Nr1"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("segment", core, parent)
-		self._base.rep_cap = RepeatedCapability(self._base.group_name, 'repcap_segment_get', 'repcap_segment_set', repcap.Segment.Nr1)
+		self._cmd_group = CommandsGroup("segment", core, parent)
+		self._cmd_group.rep_cap = RepeatedCapability(self._cmd_group.group_name, 'repcap_segment_get', 'repcap_segment_set', repcap.Segment.Nr1)
 
-	def repcap_segment_set(self, enum_value: repcap.Segment) -> None:
+	def repcap_segment_set(self, segment: repcap.Segment) -> None:
 		"""Repeated Capability default value numeric suffix.
 		This value is used, if you do not explicitely set it in the child set/get methods, or if you leave it to Segment.Default
 		Default value after init: Segment.Nr1"""
-		self._base.set_repcap_enum_value(enum_value)
+		self._cmd_group.set_repcap_enum_value(segment)
 
 	def repcap_segment_get(self) -> repcap.Segment:
 		"""Returns the current default repeated capability for the child set/get methods"""
 		# noinspection PyTypeChecker
-		return self._base.get_repcap_enum_value()
+		return self._cmd_group.get_repcap_enum_value()
 
 	@property
 	def scc(self):
 		"""scc commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_scc'):
-			from .Segment_.Scc import Scc
-			self._scc = Scc(self._core, self._base)
+			from .Scc import SccCls
+			self._scc = SccCls(self._core, self._cmd_group)
 		return self._scc
 
 	@property
 	def cc(self):
 		"""cc commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_cc'):
-			from .Segment_.Cc import Cc
-			self._cc = Cc(self._core, self._base)
+			from .Cc import CcCls
+			self._cc = CcCls(self._core, self._cmd_group)
 		return self._cc
 
 	@property
 	def carrierAggregation(self):
 		"""carrierAggregation commands group. 2 Sub-classes, 0 commands."""
 		if not hasattr(self, '_carrierAggregation'):
-			from .Segment_.CarrierAggregation import CarrierAggregation
-			self._carrierAggregation = CarrierAggregation(self._core, self._base)
+			from .CarrierAggregation import CarrierAggregationCls
+			self._carrierAggregation = CarrierAggregationCls(self._core, self._cmd_group)
 		return self._carrierAggregation
 
 	@property
 	def setup(self):
 		"""setup commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_setup'):
-			from .Segment_.Setup import Setup
-			self._setup = Setup(self._core, self._base)
+			from .Setup import SetupCls
+			self._setup = SetupCls(self._core, self._cmd_group)
 		return self._setup
 
 	@property
 	def tdd(self):
 		"""tdd commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_tdd'):
-			from .Segment_.Tdd import Tdd
-			self._tdd = Tdd(self._core, self._base)
+			from .Tdd import TddCls
+			self._tdd = TddCls(self._core, self._cmd_group)
 		return self._tdd
 
 	@property
 	def rbAllocation(self):
 		"""rbAllocation commands group. 1 Sub-classes, 1 commands."""
 		if not hasattr(self, '_rbAllocation'):
-			from .Segment_.RbAllocation import RbAllocation
-			self._rbAllocation = RbAllocation(self._core, self._base)
+			from .RbAllocation import RbAllocationCls
+			self._rbAllocation = RbAllocationCls(self._core, self._cmd_group)
 		return self._rbAllocation
 
 	@property
 	def modulation(self):
 		"""modulation commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_modulation'):
-			from .Segment_.Modulation import Modulation
-			self._modulation = Modulation(self._core, self._base)
+			from .Modulation import ModulationCls
+			self._modulation = ModulationCls(self._core, self._cmd_group)
 		return self._modulation
 
 	@property
 	def seMask(self):
 		"""seMask commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_seMask'):
-			from .Segment_.SeMask import SeMask
-			self._seMask = SeMask(self._core, self._base)
+			from .SeMask import SeMaskCls
+			self._seMask = SeMaskCls(self._core, self._cmd_group)
 		return self._seMask
 
 	@property
 	def aclr(self):
 		"""aclr commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_aclr'):
-			from .Segment_.Aclr import Aclr
-			self._aclr = Aclr(self._core, self._base)
+			from .Aclr import AclrCls
+			self._aclr = AclrCls(self._core, self._cmd_group)
 		return self._aclr
 
 	@property
 	def pmonitor(self):
 		"""pmonitor commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_pmonitor'):
-			from .Segment_.Pmonitor import Pmonitor
-			self._pmonitor = Pmonitor(self._core, self._base)
+			from .Pmonitor import PmonitorCls
+			self._pmonitor = PmonitorCls(self._core, self._cmd_group)
 		return self._pmonitor
 
 	@property
 	def power(self):
 		"""power commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_power'):
-			from .Segment_.Power import Power
-			self._power = Power(self._core, self._base)
+			from .Power import PowerCls
+			self._power = PowerCls(self._core, self._cmd_group)
 		return self._power
 
 	@property
 	def emtc(self):
 		"""emtc commands group. 1 Sub-classes, 0 commands."""
 		if not hasattr(self, '_emtc'):
-			from .Segment_.Emtc import Emtc
-			self._emtc = Emtc(self._core, self._base)
+			from .Emtc import EmtcCls
+			self._emtc = EmtcCls(self._core, self._cmd_group)
 		return self._emtc
 
 	@property
 	def plcId(self):
 		"""plcId commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_plcId'):
-			from .Segment_.PlcId import PlcId
-			self._plcId = PlcId(self._core, self._base)
+			from .PlcId import PlcIdCls
+			self._plcId = PlcIdCls(self._core, self._cmd_group)
 		return self._plcId
 
 	@property
 	def singleCmw(self):
 		"""singleCmw commands group. 1 Sub-classes, 0 commands."""
 		if not hasattr(self, '_singleCmw'):
-			from .Segment_.SingleCmw import SingleCmw
-			self._singleCmw = SingleCmw(self._core, self._base)
+			from .SingleCmw import SingleCmwCls
+			self._singleCmw = SingleCmwCls(self._core, self._cmd_group)
 		return self._singleCmw
 
-	def clone(self) -> 'Segment':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	@property
+	def cidx(self):
+		"""cidx commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_cidx'):
+			from .Cidx import CidxCls
+			self._cidx = CidxCls(self._core, self._cmd_group)
+		return self._cidx
+
+	def clone(self) -> 'SegmentCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Segment(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = SegmentCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/Aclr.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/ListPy/Segment/Power.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,55 +1,52 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.StructBase import StructBase
-from ......Internal.ArgStruct import ArgStruct
-from ...... import repcap
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal.Types import DataType
+from .......Internal.StructBase import StructBase
+from .......Internal.ArgStruct import ArgStruct
+from .......Internal.ArgSingleList import ArgSingleList
+from .......Internal.ArgSingle import ArgSingle
+from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Aclr:
-	"""Aclr commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class PowerCls:
+	"""Power commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("aclr", core, parent)
+		self._cmd_group = CommandsGroup("power", core, parent)
+
+	def set(self, power_statistics: int, power_enable: bool, segment=repcap.Segment.Default) -> None:
+		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:POWer \n
+		Snippet: driver.configure.lteMeas.multiEval.listPy.segment.power.set(power_statistics = 1, power_enable = False, segment = repcap.Segment.Default) \n
+		Defines settings for the measurement of the total TX power of all carriers for segment <no>. \n
+			:param power_statistics: Statistical length in subframes
+			:param power_enable: Enables or disables the measurement of the total TX power.
+			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
+		"""
+		param = ArgSingleList().compose_cmd_string(ArgSingle('power_statistics', power_statistics, DataType.Integer), ArgSingle('power_enable', power_enable, DataType.Boolean))
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
+		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:POWer {param}'.rstrip())
 
 	# noinspection PyTypeChecker
-	class AclrStruct(StructBase):
-		"""Structure for setting input parameters. Fields: \n
-			- Aclr_Statistics: int: Statistical length in slots
-			- Aclr_Enable: bool: Enable or disable the measurement of ACLR results ON: ACLR results are measured according to the other enable flags in this command. ACLR results for which there is no explicit enable flag are also measured (e.g. power in assigned E-UTRA channel) . OFF: No ACLR results at all are measured. The other enable flags in this command are ignored.
-			- Utra_1_Enable: bool: Enable or disable evaluation of first adjacent UTRA channels
-			- Utra_2_Enable: bool: Enable or disable evaluation of second adjacent UTRA channels
-			- Eutra_Enable: bool: Enable or disable evaluation of first adjacent E-UTRA channels"""
+	class PowerStruct(StructBase):
+		"""Response structure. Fields: \n
+			- Power_Statistics: int: Statistical length in subframes
+			- Power_Enable: bool: Enables or disables the measurement of the total TX power."""
 		__meta_args_list = [
-			ArgStruct.scalar_int('Aclr_Statistics'),
-			ArgStruct.scalar_bool('Aclr_Enable'),
-			ArgStruct.scalar_bool('Utra_1_Enable'),
-			ArgStruct.scalar_bool('Utra_2_Enable'),
-			ArgStruct.scalar_bool('Eutra_Enable')]
+			ArgStruct.scalar_int('Power_Statistics'),
+			ArgStruct.scalar_bool('Power_Enable')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
-			self.Aclr_Statistics: int = None
-			self.Aclr_Enable: bool = None
-			self.Utra_1_Enable: bool = None
-			self.Utra_2_Enable: bool = None
-			self.Eutra_Enable: bool = None
-
-	def set(self, structure: AclrStruct, segment=repcap.Segment.Default) -> None:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:ACLR \n
-		Snippet: driver.configure.multiEval.listPy.segment.aclr.set(value = [PROPERTY_STRUCT_NAME](), segment = repcap.Segment.Default) \n
-		Defines settings for ACLR measurements in list mode for segment <no>. \n
-			:param structure: for set value, see the help for AclrStruct structure arguments.
-			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')"""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
-		self._core.io.write_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:ACLR', structure)
-
-	def get(self, segment=repcap.Segment.Default) -> AclrStruct:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:ACLR \n
-		Snippet: value: AclrStruct = driver.configure.multiEval.listPy.segment.aclr.get(segment = repcap.Segment.Default) \n
-		Defines settings for ACLR measurements in list mode for segment <no>. \n
+			self.Power_Statistics: int = None
+			self.Power_Enable: bool = None
+
+	def get(self, segment=repcap.Segment.Default) -> PowerStruct:
+		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:POWer \n
+		Snippet: value: PowerStruct = driver.configure.lteMeas.multiEval.listPy.segment.power.get(segment = repcap.Segment.Default) \n
+		Defines settings for the measurement of the total TX power of all carriers for segment <no>. \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
-			:return: structure: for return value, see the help for AclrStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
-		return self._core.io.query_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:ACLR?', self.__class__.AclrStruct())
+			:return: structure: for return value, see the help for PowerStruct structure arguments."""
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
+		return self._core.io.query_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:POWer?', self.__class__.PowerStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/CarrierAggregation.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/ListPy/Segment/CarrierAggregation/__init__.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,35 +1,35 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
+from ........Internal.Core import Core
+from ........Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class CarrierAggregation:
-	"""CarrierAggregation commands group definition. 3 total commands, 2 Sub-groups, 0 group commands"""
+class CarrierAggregationCls:
+	"""CarrierAggregation commands group definition. 3 total commands, 2 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("carrierAggregation", core, parent)
+		self._cmd_group = CommandsGroup("carrierAggregation", core, parent)
 
 	@property
 	def acSpacing(self):
 		"""acSpacing commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_acSpacing'):
-			from .CarrierAggregation_.AcSpacing import AcSpacing
-			self._acSpacing = AcSpacing(self._core, self._base)
+			from .AcSpacing import AcSpacingCls
+			self._acSpacing = AcSpacingCls(self._core, self._cmd_group)
 		return self._acSpacing
 
 	@property
 	def mcarrier(self):
 		"""mcarrier commands group. 1 Sub-classes, 1 commands."""
 		if not hasattr(self, '_mcarrier'):
-			from .CarrierAggregation_.Mcarrier import Mcarrier
-			self._mcarrier = Mcarrier(self._core, self._base)
+			from .Mcarrier import McarrierCls
+			self._mcarrier = McarrierCls(self._core, self._cmd_group)
 		return self._mcarrier
 
-	def clone(self) -> 'CarrierAggregation':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'CarrierAggregationCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = CarrierAggregation(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = CarrierAggregationCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/CarrierAggregation_/AcSpacing.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/ListPy/Segment/CarrierAggregation/AcSpacing.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,29 +1,31 @@
-from .......Internal.Core import Core
-from .......Internal.CommandsGroup import CommandsGroup
-from ....... import repcap
+from ........Internal.Core import Core
+from ........Internal.CommandsGroup import CommandsGroup
+from ........ import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class AcSpacing:
-	"""AcSpacing commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class AcSpacingCls:
+	"""AcSpacing commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("acSpacing", core, parent)
+		self._cmd_group = CommandsGroup("acSpacing", core, parent)
 
 	def set(self, segment=repcap.Segment.Default) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:CAGGregation:ACSPacing \n
-		Snippet: driver.configure.multiEval.listPy.segment.carrierAggregation.acSpacing.set(segment = repcap.Segment.Default) \n
+		Snippet: driver.configure.lteMeas.multiEval.listPy.segment.carrierAggregation.acSpacing.set(segment = repcap.Segment.Default) \n
 		Adjusts the component carrier frequencies in segment <no>, so that the carriers are aggregated contiguously. \n
-			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')"""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
+		"""
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:CAGGregation:ACSPacing')
 
-	def set_with_opc(self, segment=repcap.Segment.Default) -> None:
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+	def set_with_opc(self, segment=repcap.Segment.Default, opc_timeout_ms: int = -1) -> None:
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:CAGGregation:ACSPacing \n
-		Snippet: driver.configure.multiEval.listPy.segment.carrierAggregation.acSpacing.set_with_opc(segment = repcap.Segment.Default) \n
+		Snippet: driver.configure.lteMeas.multiEval.listPy.segment.carrierAggregation.acSpacing.set_with_opc(segment = repcap.Segment.Default) \n
 		Adjusts the component carrier frequencies in segment <no>, so that the carriers are aggregated contiguously. \n
 		Same as set, but waits for the operation to complete before continuing further. Use the RsCMPX_LteMeas.utilities.opc_timeout_set() to set the timeout value. \n
-			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')"""
-		self._core.io.write_with_opc(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:CAGGregation:ACSPacing')
+			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
+			:param opc_timeout_ms: Maximum time to wait in milliseconds, valid only for this call."""
+		self._core.io.write_with_opc(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:CAGGregation:ACSPacing', opc_timeout_ms)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/CarrierAggregation_/Mcarrier.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/ListPy/Segment/CarrierAggregation/Mcarrier/Enhanced.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,51 +1,36 @@
-from .......Internal.Core import Core
-from .......Internal.CommandsGroup import CommandsGroup
-from .......Internal import Conversions
-from ....... import enums
-from ....... import repcap
+from .........Internal.Core import Core
+from .........Internal.CommandsGroup import CommandsGroup
+from .........Internal import Conversions
+from ......... import enums
+from ......... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Mcarrier:
-	"""Mcarrier commands group definition. 2 total commands, 1 Sub-groups, 1 group commands"""
+class EnhancedCls:
+	"""Enhanced commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("mcarrier", core, parent)
+		self._cmd_group = CommandsGroup("enhanced", core, parent)
 
-	@property
-	def enhanced(self):
-		"""enhanced commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_enhanced'):
-			from .Mcarrier_.Enhanced import Enhanced
-			self._enhanced = Enhanced(self._core, self._base)
-		return self._enhanced
-
-	def set(self, meas_carrier: enums.MeasCarrier, segment=repcap.Segment.Default) -> None:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:CAGGregation:MCARrier \n
-		Snippet: driver.configure.multiEval.listPy.segment.carrierAggregation.mcarrier.set(meas_carrier = enums.MeasCarrier.PCC, segment = repcap.Segment.Default) \n
-		No command help available \n
+	def set(self, meas_carrier: enums.MeasCarrierEnhanced, segment=repcap.Segment.Default) -> None:
+		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:CAGGregation:MCARrier:ENHanced \n
+		Snippet: driver.configure.lteMeas.multiEval.listPy.segment.carrierAggregation.mcarrier.enhanced.set(meas_carrier = enums.MeasCarrierEnhanced.CC1, segment = repcap.Segment.Default) \n
+		Selects a component carrier for single carrier measurements in segment <no>. \n
 			:param meas_carrier: No help available
-			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')"""
-		param = Conversions.enum_scalar_to_str(meas_carrier, enums.MeasCarrier)
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
-		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:CAGGregation:MCARrier {param}')
+			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
+		"""
+		param = Conversions.enum_scalar_to_str(meas_carrier, enums.MeasCarrierEnhanced)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
+		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:CAGGregation:MCARrier:ENHanced {param}')
 
 	# noinspection PyTypeChecker
-	def get(self, segment=repcap.Segment.Default) -> enums.MeasCarrier:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:CAGGregation:MCARrier \n
-		Snippet: value: enums.MeasCarrier = driver.configure.multiEval.listPy.segment.carrierAggregation.mcarrier.get(segment = repcap.Segment.Default) \n
-		No command help available \n
+	def get(self, segment=repcap.Segment.Default) -> enums.MeasCarrierEnhanced:
+		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:CAGGregation:MCARrier:ENHanced \n
+		Snippet: value: enums.MeasCarrierEnhanced = driver.configure.lteMeas.multiEval.listPy.segment.carrierAggregation.mcarrier.enhanced.get(segment = repcap.Segment.Default) \n
+		Selects a component carrier for single carrier measurements in segment <no>. \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
 			:return: meas_carrier: No help available"""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
-		response = self._core.io.query_str(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:CAGGregation:MCARrier?')
-		return Conversions.str_to_scalar_enum(response, enums.MeasCarrier)
-
-	def clone(self) -> 'Mcarrier':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
-		Also copies all the existing default Repeated Capabilities setting,
-		which you can change independently without affecting the original group"""
-		new_group = Mcarrier(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
-		return new_group
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
+		response = self._core.io.query_str(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:CAGGregation:MCARrier:ENHanced?')
+		return Conversions.str_to_scalar_enum(response, enums.MeasCarrierEnhanced)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/CarrierAggregation_/Mcarrier_/Enhanced.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/ListPy/Segment/SingleCmw/Connector.py`

 * *Files 22% similar despite different names*

```diff
@@ -2,34 +2,35 @@
 from ........Internal.CommandsGroup import CommandsGroup
 from ........Internal import Conversions
 from ........ import enums
 from ........ import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Enhanced:
-	"""Enhanced commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class ConnectorCls:
+	"""Connector commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("enhanced", core, parent)
+		self._cmd_group = CommandsGroup("connector", core, parent)
 
-	def set(self, meas_carrier: enums.MeasCarrierEnhanced, segment=repcap.Segment.Default) -> None:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:CAGGregation:MCARrier:ENHanced \n
-		Snippet: driver.configure.multiEval.listPy.segment.carrierAggregation.mcarrier.enhanced.set(meas_carrier = enums.MeasCarrierEnhanced.CC1, segment = repcap.Segment.Default) \n
-		Selects a component carrier for single-carrier measurements in segment <no>. \n
-			:param meas_carrier: No help available
-			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')"""
-		param = Conversions.enum_scalar_to_str(meas_carrier, enums.MeasCarrierEnhanced)
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
-		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:CAGGregation:MCARrier:ENHanced {param}')
+	def set(self, cmws_connector: enums.CmwsConnector, segment=repcap.Segment.Default) -> None:
+		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:CMWS:CONNector \n
+		Snippet: driver.configure.lteMeas.multiEval.listPy.segment.singleCmw.connector.set(cmws_connector = enums.CmwsConnector.R11, segment = repcap.Segment.Default) \n
+		No command help available \n
+			:param cmws_connector: No help available
+			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
+		"""
+		param = Conversions.enum_scalar_to_str(cmws_connector, enums.CmwsConnector)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
+		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:CMWS:CONNector {param}')
 
 	# noinspection PyTypeChecker
-	def get(self, segment=repcap.Segment.Default) -> enums.MeasCarrierEnhanced:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:CAGGregation:MCARrier:ENHanced \n
-		Snippet: value: enums.MeasCarrierEnhanced = driver.configure.multiEval.listPy.segment.carrierAggregation.mcarrier.enhanced.get(segment = repcap.Segment.Default) \n
-		Selects a component carrier for single-carrier measurements in segment <no>. \n
+	def get(self, segment=repcap.Segment.Default) -> enums.CmwsConnector:
+		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:CMWS:CONNector \n
+		Snippet: value: enums.CmwsConnector = driver.configure.lteMeas.multiEval.listPy.segment.singleCmw.connector.get(segment = repcap.Segment.Default) \n
+		No command help available \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
-			:return: meas_carrier: No help available"""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
-		response = self._core.io.query_str(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:CAGGregation:MCARrier:ENHanced?')
-		return Conversions.str_to_scalar_enum(response, enums.MeasCarrierEnhanced)
+			:return: cmws_connector: No help available"""
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
+		response = self._core.io.query_str(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:CMWS:CONNector?')
+		return Conversions.str_to_scalar_enum(response, enums.CmwsConnector)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/Cc.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/ListPy/Segment/Scc.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,75 +1,79 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.StructBase import StructBase
-from ......Internal.ArgStruct import ArgStruct
-from ......Internal.RepeatedCapability import RepeatedCapability
-from ...... import enums
-from ...... import repcap
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal.Types import DataType
+from .......Internal.StructBase import StructBase
+from .......Internal.ArgStruct import ArgStruct
+from .......Internal.ArgSingleList import ArgSingleList
+from .......Internal.ArgSingle import ArgSingle
+from .......Internal.RepeatedCapability import RepeatedCapability
+from ....... import enums
+from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Cc:
-	"""Cc commands group definition. 1 total commands, 0 Sub-groups, 1 group commands
-	Repeated Capability: CarrierComponent, default value after init: CarrierComponent.Nr1"""
+class SccCls:
+	"""Scc commands group definition. 1 total commands, 0 Subgroups, 1 group commands
+	Repeated Capability: SecondaryCC, default value after init: SecondaryCC.CC1"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("cc", core, parent)
-		self._base.rep_cap = RepeatedCapability(self._base.group_name, 'repcap_carrierComponent_get', 'repcap_carrierComponent_set', repcap.CarrierComponent.Nr1)
+		self._cmd_group = CommandsGroup("scc", core, parent)
+		self._cmd_group.rep_cap = RepeatedCapability(self._cmd_group.group_name, 'repcap_secondaryCC_get', 'repcap_secondaryCC_set', repcap.SecondaryCC.CC1)
 
-	def repcap_carrierComponent_set(self, enum_value: repcap.CarrierComponent) -> None:
+	def repcap_secondaryCC_set(self, secondaryCC: repcap.SecondaryCC) -> None:
 		"""Repeated Capability default value numeric suffix.
-		This value is used, if you do not explicitely set it in the child set/get methods, or if you leave it to CarrierComponent.Default
-		Default value after init: CarrierComponent.Nr1"""
-		self._base.set_repcap_enum_value(enum_value)
+		This value is used, if you do not explicitely set it in the child set/get methods, or if you leave it to SecondaryCC.Default
+		Default value after init: SecondaryCC.CC1"""
+		self._cmd_group.set_repcap_enum_value(secondaryCC)
 
-	def repcap_carrierComponent_get(self) -> repcap.CarrierComponent:
+	def repcap_secondaryCC_get(self) -> repcap.SecondaryCC:
 		"""Returns the current default repeated capability for the child set/get methods"""
 		# noinspection PyTypeChecker
-		return self._base.get_repcap_enum_value()
+		return self._cmd_group.get_repcap_enum_value()
+
+	def set(self, frequency: float, ch_bandwidth: enums.ChannelBandwidth, segment=repcap.Segment.Default, secondaryCC=repcap.SecondaryCC.Default) -> None:
+		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:SCC<c> \n
+		Snippet: driver.configure.lteMeas.multiEval.listPy.segment.scc.set(frequency = 1.0, ch_bandwidth = enums.ChannelBandwidth.B014, segment = repcap.Segment.Default, secondaryCC = repcap.SecondaryCC.Default) \n
+		No command help available \n
+			:param frequency: No help available
+			:param ch_bandwidth: No help available
+			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
+			:param secondaryCC: optional repeated capability selector. Default value: CC1 (settable in the interface 'Scc')
+		"""
+		param = ArgSingleList().compose_cmd_string(ArgSingle('frequency', frequency, DataType.Float), ArgSingle('ch_bandwidth', ch_bandwidth, DataType.Enum, enums.ChannelBandwidth))
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
+		secondaryCC_cmd_val = self._cmd_group.get_repcap_cmd_value(secondaryCC, repcap.SecondaryCC)
+		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:SCC{secondaryCC_cmd_val} {param}'.rstrip())
 
 	# noinspection PyTypeChecker
-	class CcStruct(StructBase):
-		"""Structure for setting input parameters. Fields: \n
-			- Frequency: float: Center frequency of the component carrier, used in the segment For the supported range, see 'Frequency Ranges'.
-			- Ch_Bandwidth: enums.ChannelBandwidth: Channel bandwidth of the component carrier, used in the segment B014: 1.4 MHz B030: 3 MHz B050: 5 MHz B100: 10 MHz B150: 15 MHz B200: 20 MHz"""
+	class SccStruct(StructBase):
+		"""Response structure. Fields: \n
+			- Frequency: float: No parameter help available
+			- Ch_Bandwidth: enums.ChannelBandwidth: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_float('Frequency'),
 			ArgStruct.scalar_enum('Ch_Bandwidth', enums.ChannelBandwidth)]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Frequency: float = None
 			self.Ch_Bandwidth: enums.ChannelBandwidth = None
 
-	def set(self, structure: CcStruct, segment=repcap.Segment.Default, carrierComponent=repcap.CarrierComponent.Default) -> None:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:CC<c> \n
-		Snippet: driver.configure.multiEval.listPy.segment.cc.set(value = [PROPERTY_STRUCT_NAME](), segment = repcap.Segment.Default, carrierComponent = repcap.CarrierComponent.Default) \n
-		Defines carrier-specific analyzer settings for component carrier CC<c>, in segment <no>. This command is only relevant
-		for carrier aggregation. \n
-			:param structure: for set value, see the help for CcStruct structure arguments.
-			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
-			:param carrierComponent: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Cc')"""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
-		carrierComponent_cmd_val = self._base.get_repcap_cmd_value(carrierComponent, repcap.CarrierComponent)
-		self._core.io.write_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:CC{carrierComponent_cmd_val}', structure)
-
-	def get(self, segment=repcap.Segment.Default, carrierComponent=repcap.CarrierComponent.Default) -> CcStruct:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:CC<c> \n
-		Snippet: value: CcStruct = driver.configure.multiEval.listPy.segment.cc.get(segment = repcap.Segment.Default, carrierComponent = repcap.CarrierComponent.Default) \n
-		Defines carrier-specific analyzer settings for component carrier CC<c>, in segment <no>. This command is only relevant
-		for carrier aggregation. \n
+	def get(self, segment=repcap.Segment.Default, secondaryCC=repcap.SecondaryCC.Default) -> SccStruct:
+		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:SCC<c> \n
+		Snippet: value: SccStruct = driver.configure.lteMeas.multiEval.listPy.segment.scc.get(segment = repcap.Segment.Default, secondaryCC = repcap.SecondaryCC.Default) \n
+		No command help available \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
-			:param carrierComponent: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Cc')
-			:return: structure: for return value, see the help for CcStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
-		carrierComponent_cmd_val = self._base.get_repcap_cmd_value(carrierComponent, repcap.CarrierComponent)
-		return self._core.io.query_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:CC{carrierComponent_cmd_val}?', self.__class__.CcStruct())
+			:param secondaryCC: optional repeated capability selector. Default value: CC1 (settable in the interface 'Scc')
+			:return: structure: for return value, see the help for SccStruct structure arguments."""
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
+		secondaryCC_cmd_val = self._cmd_group.get_repcap_cmd_value(secondaryCC, repcap.SecondaryCC)
+		return self._core.io.query_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:SCC{secondaryCC_cmd_val}?', self.__class__.SccStruct())
 
-	def clone(self) -> 'Cc':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'SccCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Cc(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = SccCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/Emtc.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/InbandEmission/Scc/__init__.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,27 +1,27 @@
 from ......Internal.Core import Core
 from ......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Emtc:
-	"""Emtc commands group definition. 1 total commands, 1 Sub-groups, 0 group commands"""
+class SccCls:
+	"""Scc commands group definition. 6 total commands, 1 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("emtc", core, parent)
+		self._cmd_group = CommandsGroup("scc", core, parent)
 
 	@property
-	def nband(self):
-		"""nband commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_nband'):
-			from .Emtc_.Nband import Nband
-			self._nband = Nband(self._core, self._base)
-		return self._nband
+	def margin(self):
+		"""margin commands group. 4 Sub-classes, 0 commands."""
+		if not hasattr(self, '_margin'):
+			from .Margin import MarginCls
+			self._margin = MarginCls(self._core, self._cmd_group)
+		return self._margin
 
-	def clone(self) -> 'Emtc':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'SccCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Emtc(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = SccCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/Emtc_/Nband.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/ListPy/Segment/Emtc/Nband.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,33 +1,34 @@
-from .......Internal.Core import Core
-from .......Internal.CommandsGroup import CommandsGroup
-from .......Internal import Conversions
-from ....... import repcap
+from ........Internal.Core import Core
+from ........Internal.CommandsGroup import CommandsGroup
+from ........Internal import Conversions
+from ........ import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Nband:
-	"""Nband commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class NbandCls:
+	"""Nband commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("nband", core, parent)
+		self._cmd_group = CommandsGroup("nband", core, parent)
 
 	def set(self, number: int, segment=repcap.Segment.Default) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:EMTC:NBANd \n
-		Snippet: driver.configure.multiEval.listPy.segment.emtc.nband.set(number = 1, segment = repcap.Segment.Default) \n
+		Snippet: driver.configure.lteMeas.multiEval.listPy.segment.emtc.nband.set(number = 1, segment = repcap.Segment.Default) \n
 		Selects the eMTC narrowband for segment <no>. \n
-			:param number: The maximum depends on the channel BW, see 'RB allocation and narrowbands for eMTC'.
-			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')"""
+			:param number: The maximum depends on the channel BW, see 'RB allocation, narrowbands and widebands for eMTC'.
+			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
+		"""
 		param = Conversions.decimal_value_to_str(number)
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:EMTC:NBANd {param}')
 
 	def get(self, segment=repcap.Segment.Default) -> int:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:EMTC:NBANd \n
-		Snippet: value: int = driver.configure.multiEval.listPy.segment.emtc.nband.get(segment = repcap.Segment.Default) \n
+		Snippet: value: int = driver.configure.lteMeas.multiEval.listPy.segment.emtc.nband.get(segment = repcap.Segment.Default) \n
 		Selects the eMTC narrowband for segment <no>. \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
-			:return: number: The maximum depends on the channel BW, see 'RB allocation and narrowbands for eMTC'."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+			:return: number: The maximum depends on the channel BW, see 'RB allocation, narrowbands and widebands for eMTC'."""
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		response = self._core.io.query_str(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:EMTC:NBANd?')
 		return Conversions.str_to_int(response)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/Modulation.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/ListPy/Segment/Modulation.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,34 +1,34 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.StructBase import StructBase
-from ......Internal.ArgStruct import ArgStruct
-from ...... import enums
-from ...... import repcap
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal.StructBase import StructBase
+from .......Internal.ArgStruct import ArgStruct
+from ....... import enums
+from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Modulation:
-	"""Modulation commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class ModulationCls:
+	"""Modulation commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("modulation", core, parent)
+		self._cmd_group = CommandsGroup("modulation", core, parent)
 
 	# noinspection PyTypeChecker
 	class ModulationStruct(StructBase):
 		"""Structure for setting input parameters. Fields: \n
-			- Mod_Statistics: int: Statistical length in slots
-			- Modenable: bool: Enable or disable the measurement of modulation results ON: Modulation results are measured according to the other enable flags in this command. Modulation results for which there is no explicit enable flag are also measured (e.g. I/Q offset, frequency error and timing error) . OFF: No modulation results at all are measured. The other enable flags in this command are ignored.
-			- Evm_Enable: bool: Enable or disable measurement of EVM
-			- Mag_Error_Enable: bool: Enable or disable measurement of magnitude error
-			- Phase_Err_Enable: bool: Enable or disable measurement of phase error
-			- Ib_Eenable: bool: Enable or disable measurement of inband emissions
-			- Eq_Sp_Flat_Enable: bool: Enable or disable measurement of equalizer spectrum flatness results
-			- Mod_Scheme: enums.ModScheme: Modulation scheme used by the LTE uplink signal AUTO: automatic detection QPSK: QPSK Q16: 16-QAM Q64: 64-QAM Q256: 256-QAM"""
+			- Mod_Statistics: int: Statistical length in slots.
+			- Modenable: bool: Enable or disable the measurement of modulation results. ON: Modulation results are measured according to the other enable flags in this command. Modulation results for which there is no explicit enable flag are also measured (e.g. I/Q offset, frequency error and timing error) . OFF: No modulation results at all are measured. The other enable flags in this command are ignored.
+			- Evm_Enable: bool: Enable or disable measurement of EVM.
+			- Mag_Error_Enable: bool: Enable or disable measurement of magnitude error.
+			- Phase_Err_Enable: bool: Enable or disable measurement of phase error.
+			- Ib_Eenable: bool: Enable or disable measurement of in-band emissions.
+			- Eq_Sp_Flat_Enable: bool: Enable or disable measurement of equalizer spectrum flatness results.
+			- Mod_Scheme: enums.ModScheme: The modulation scheme used by the LTE uplink signal. AUTO: automatic detection QPSK: QPSK Q16: 16QAM Q64: 64QAM Q256: 256QAM"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Mod_Statistics'),
 			ArgStruct.scalar_bool('Modenable'),
 			ArgStruct.scalar_bool('Evm_Enable'),
 			ArgStruct.scalar_bool('Mag_Error_Enable'),
 			ArgStruct.scalar_bool('Phase_Err_Enable'),
 			ArgStruct.scalar_bool('Ib_Eenable'),
@@ -44,22 +44,33 @@
 			self.Phase_Err_Enable: bool = None
 			self.Ib_Eenable: bool = None
 			self.Eq_Sp_Flat_Enable: bool = None
 			self.Mod_Scheme: enums.ModScheme = None
 
 	def set(self, structure: ModulationStruct, segment=repcap.Segment.Default) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:MODulation \n
-		Snippet: driver.configure.multiEval.listPy.segment.modulation.set(value = [PROPERTY_STRUCT_NAME](), segment = repcap.Segment.Default) \n
+		Snippet with structure: \n
+		structure = driver.configure.lteMeas.multiEval.listPy.segment.modulation.ModulationStruct() \n
+		structure.Mod_Statistics: int = 1 \n
+		structure.Modenable: bool = False \n
+		structure.Evm_Enable: bool = False \n
+		structure.Mag_Error_Enable: bool = False \n
+		structure.Phase_Err_Enable: bool = False \n
+		structure.Ib_Eenable: bool = False \n
+		structure.Eq_Sp_Flat_Enable: bool = False \n
+		structure.Mod_Scheme: enums.ModScheme = enums.ModScheme.AUTO \n
+		driver.configure.lteMeas.multiEval.listPy.segment.modulation.set(structure, segment = repcap.Segment.Default) \n
 		Defines settings for modulation measurements in list mode for segment <no>. \n
 			:param structure: for set value, see the help for ModulationStruct structure arguments.
-			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')"""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
+		"""
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		self._core.io.write_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:MODulation', structure)
 
 	def get(self, segment=repcap.Segment.Default) -> ModulationStruct:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:MODulation \n
-		Snippet: value: ModulationStruct = driver.configure.multiEval.listPy.segment.modulation.get(segment = repcap.Segment.Default) \n
+		Snippet: value: ModulationStruct = driver.configure.lteMeas.multiEval.listPy.segment.modulation.get(segment = repcap.Segment.Default) \n
 		Defines settings for modulation measurements in list mode for segment <no>. \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
 			:return: structure: for return value, see the help for ModulationStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		return self._core.io.query_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:MODulation?', self.__class__.ModulationStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/PlcId.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/ListPy/Segment/PlcId.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,33 +1,36 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal import Conversions
-from ...... import repcap
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal import Conversions
+from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class PlcId:
-	"""PlcId commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class PlcIdCls:
+	"""PlcId commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("plcId", core, parent)
+		self._cmd_group = CommandsGroup("plcId", core, parent)
 
 	def set(self, phys_layer_cell_id: int, segment=repcap.Segment.Default) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:PLCid \n
-		Snippet: driver.configure.multiEval.listPy.segment.plcId.set(phys_layer_cell_id = 1, segment = repcap.Segment.Default) \n
-		Specifies the physical cell ID for segment <no>. See also method RsCMPX_LteMeas.Configure.MultiEval.ListPy.plcMode. \n
+		Snippet: driver.configure.lteMeas.multiEval.listPy.segment.plcId.set(phys_layer_cell_id = 1, segment = repcap.Segment.Default) \n
+		Specifies the physical cell ID for segment <no>. See also method RsCMPX_LteMeas.Configure.LteMeas.MultiEval.ListPy.
+		plcMode. \n
 			:param phys_layer_cell_id: No help available
-			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')"""
+			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
+		"""
 		param = Conversions.decimal_value_to_str(phys_layer_cell_id)
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:PLCid {param}')
 
 	def get(self, segment=repcap.Segment.Default) -> int:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:PLCid \n
-		Snippet: value: int = driver.configure.multiEval.listPy.segment.plcId.get(segment = repcap.Segment.Default) \n
-		Specifies the physical cell ID for segment <no>. See also method RsCMPX_LteMeas.Configure.MultiEval.ListPy.plcMode. \n
+		Snippet: value: int = driver.configure.lteMeas.multiEval.listPy.segment.plcId.get(segment = repcap.Segment.Default) \n
+		Specifies the physical cell ID for segment <no>. See also method RsCMPX_LteMeas.Configure.LteMeas.MultiEval.ListPy.
+		plcMode. \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
 			:return: phys_layer_cell_id: No help available"""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		response = self._core.io.query_str(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:PLCid?')
 		return Conversions.str_to_int(response)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/Pmonitor.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/ListPy/Segment/Pmonitor.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,33 +1,34 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal import Conversions
-from ...... import repcap
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal import Conversions
+from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Pmonitor:
-	"""Pmonitor commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class PmonitorCls:
+	"""Pmonitor commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("pmonitor", core, parent)
+		self._cmd_group = CommandsGroup("pmonitor", core, parent)
 
 	def set(self, enable: bool, segment=repcap.Segment.Default) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:PMONitor \n
-		Snippet: driver.configure.multiEval.listPy.segment.pmonitor.set(enable = False, segment = repcap.Segment.Default) \n
+		Snippet: driver.configure.lteMeas.multiEval.listPy.segment.pmonitor.set(enable = False, segment = repcap.Segment.Default) \n
 		Enables or disables the measurement of power monitor results (power of one carrier) for segment <no>. \n
 			:param enable: No help available
-			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')"""
+			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
+		"""
 		param = Conversions.bool_to_str(enable)
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:PMONitor {param}')
 
 	def get(self, segment=repcap.Segment.Default) -> bool:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:PMONitor \n
-		Snippet: value: bool = driver.configure.multiEval.listPy.segment.pmonitor.get(segment = repcap.Segment.Default) \n
+		Snippet: value: bool = driver.configure.lteMeas.multiEval.listPy.segment.pmonitor.get(segment = repcap.Segment.Default) \n
 		Enables or disables the measurement of power monitor results (power of one carrier) for segment <no>. \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
 			:return: enable: No help available"""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		response = self._core.io.query_str(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:PMONitor?')
 		return Conversions.str_to_bool(response)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/Power.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/Modulation/Average/Pow.py`

 * *Files 25% similar despite different names*

```diff
@@ -1,46 +1,43 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.StructBase import StructBase
-from ......Internal.ArgStruct import ArgStruct
-from ...... import repcap
+from ........Internal.Core import Core
+from ........Internal.CommandsGroup import CommandsGroup
+from ........Internal.StructBase import StructBase
+from ........Internal.ArgStruct import ArgStruct
+from ........ import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Power:
-	"""Power commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class PowCls:
+	"""Pow commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("power", core, parent)
+		self._cmd_group = CommandsGroup("pow", core, parent)
 
 	# noinspection PyTypeChecker
-	class PowerStruct(StructBase):
-		"""Structure for setting input parameters. Fields: \n
-			- Power_Statistics: int: Statistical length in subframes
-			- Power_Enable: bool: Enables or disables the measurement of the total TX power"""
+	class FetchStruct(StructBase):
+		"""Response structure. Fields: \n
+			- Reliability: int: No parameter help available
+			- Tx_Power: float: No parameter help available
+			- Peak_Power: float: No parameter help available
+			- Psd: float: No parameter help available"""
 		__meta_args_list = [
-			ArgStruct.scalar_int('Power_Statistics'),
-			ArgStruct.scalar_bool('Power_Enable')]
+			ArgStruct.scalar_int('Reliability', 'Reliability'),
+			ArgStruct.scalar_float('Tx_Power'),
+			ArgStruct.scalar_float('Peak_Power'),
+			ArgStruct.scalar_float('Psd')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
-			self.Power_Statistics: int = None
-			self.Power_Enable: bool = None
-
-	def set(self, structure: PowerStruct, segment=repcap.Segment.Default) -> None:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:POWer \n
-		Snippet: driver.configure.multiEval.listPy.segment.power.set(value = [PROPERTY_STRUCT_NAME](), segment = repcap.Segment.Default) \n
-		Defines settings for the measurement of the total TX power of all carriers for segment <no>. \n
-			:param structure: for set value, see the help for PowerStruct structure arguments.
-			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')"""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
-		self._core.io.write_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:POWer', structure)
-
-	def get(self, segment=repcap.Segment.Default) -> PowerStruct:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:POWer \n
-		Snippet: value: PowerStruct = driver.configure.multiEval.listPy.segment.power.get(segment = repcap.Segment.Default) \n
-		Defines settings for the measurement of the total TX power of all carriers for segment <no>. \n
+			self.Reliability: int = None
+			self.Tx_Power: float = None
+			self.Peak_Power: float = None
+			self.Psd: float = None
+
+	def fetch(self, segment=repcap.Segment.Default) -> FetchStruct:
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:MODulation:AVERage:POW \n
+		Snippet: value: FetchStruct = driver.lteMeas.multiEval.listPy.segment.modulation.average.pow.fetch(segment = repcap.Segment.Default) \n
+		No command help available \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
-			:return: structure: for return value, see the help for PowerStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
-		return self._core.io.query_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:POWer?', self.__class__.PowerStruct())
+			:return: structure: for return value, see the help for FetchStruct structure arguments."""
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:MODulation:AVERage:POW?', self.__class__.FetchStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/RbAllocation.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/ListPy/Segment/RbAllocation/__init__.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,67 +1,74 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.StructBase import StructBase
-from ......Internal.ArgStruct import ArgStruct
-from ...... import repcap
+from ........Internal.Core import Core
+from ........Internal.CommandsGroup import CommandsGroup
+from ........Internal.Types import DataType
+from ........Internal.StructBase import StructBase
+from ........Internal.ArgStruct import ArgStruct
+from ........Internal.ArgSingleList import ArgSingleList
+from ........Internal.ArgSingle import ArgSingle
+from ........ import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class RbAllocation:
-	"""RbAllocation commands group definition. 2 total commands, 1 Sub-groups, 1 group commands"""
+class RbAllocationCls:
+	"""RbAllocation commands group definition. 2 total commands, 1 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("rbAllocation", core, parent)
+		self._cmd_group = CommandsGroup("rbAllocation", core, parent)
 
 	@property
 	def sidelink(self):
 		"""sidelink commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_sidelink'):
-			from .RbAllocation_.Sidelink import Sidelink
-			self._sidelink = Sidelink(self._core, self._base)
+			from .Sidelink import SidelinkCls
+			self._sidelink = SidelinkCls(self._core, self._cmd_group)
 		return self._sidelink
 
+	def set(self, auto: bool, no_rb: int, offset: int, segment=repcap.Segment.Default) -> None:
+		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:RBALlocation \n
+		Snippet: driver.configure.lteMeas.multiEval.listPy.segment.rbAllocation.set(auto = False, no_rb = 1, offset = 1, segment = repcap.Segment.Default) \n
+		Defines the uplink resource block allocation manually for segment <no>. By default, the RB allocation is detected
+		automatically. \n
+			:param auto: OFF: manual definition via NoRB and Offset ON: automatic detection of RB allocation
+			:param no_rb: Number of allocated resource blocks in each measured slot
+			:param offset: Offset of first allocated resource block from edge of allocated UL transmission bandwidth
+			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
+		"""
+		param = ArgSingleList().compose_cmd_string(ArgSingle('auto', auto, DataType.Boolean), ArgSingle('no_rb', no_rb, DataType.Integer), ArgSingle('offset', offset, DataType.Integer))
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
+		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:RBALlocation {param}'.rstrip())
+
 	# noinspection PyTypeChecker
 	class RbAllocationStruct(StructBase):
-		"""Structure for setting input parameters. Fields: \n
+		"""Response structure. Fields: \n
 			- Auto: bool: OFF: manual definition via NoRB and Offset ON: automatic detection of RB allocation
 			- No_Rb: int: Number of allocated resource blocks in each measured slot
 			- Offset: int: Offset of first allocated resource block from edge of allocated UL transmission bandwidth"""
 		__meta_args_list = [
 			ArgStruct.scalar_bool('Auto'),
 			ArgStruct.scalar_int('No_Rb'),
 			ArgStruct.scalar_int('Offset')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Auto: bool = None
 			self.No_Rb: int = None
 			self.Offset: int = None
 
-	def set(self, structure: RbAllocationStruct, segment=repcap.Segment.Default) -> None:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:RBALlocation \n
-		Snippet: driver.configure.multiEval.listPy.segment.rbAllocation.set(value = [PROPERTY_STRUCT_NAME](), segment = repcap.Segment.Default) \n
-		Allows you to define the uplink resource block allocation manually for segment <no>. By default, the RB allocation is
-		detected automatically. \n
-			:param structure: for set value, see the help for RbAllocationStruct structure arguments.
-			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')"""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
-		self._core.io.write_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:RBALlocation', structure)
-
 	def get(self, segment=repcap.Segment.Default) -> RbAllocationStruct:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:RBALlocation \n
-		Snippet: value: RbAllocationStruct = driver.configure.multiEval.listPy.segment.rbAllocation.get(segment = repcap.Segment.Default) \n
-		Allows you to define the uplink resource block allocation manually for segment <no>. By default, the RB allocation is
-		detected automatically. \n
+		Snippet: value: RbAllocationStruct = driver.configure.lteMeas.multiEval.listPy.segment.rbAllocation.get(segment = repcap.Segment.Default) \n
+		Defines the uplink resource block allocation manually for segment <no>. By default, the RB allocation is detected
+		automatically. \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
 			:return: structure: for return value, see the help for RbAllocationStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		return self._core.io.query_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:RBALlocation?', self.__class__.RbAllocationStruct())
 
-	def clone(self) -> 'RbAllocation':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'RbAllocationCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = RbAllocation(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = RbAllocationCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/RbAllocation_/Sidelink.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/InbandEmission/Cc/Margin/Extreme/RbIndex.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,54 +1,49 @@
-from .......Internal.Core import Core
-from .......Internal.CommandsGroup import CommandsGroup
-from .......Internal.StructBase import StructBase
-from .......Internal.ArgStruct import ArgStruct
-from ....... import repcap
+from ..........Internal.Core import Core
+from ..........Internal.CommandsGroup import CommandsGroup
+from ..........Internal.StructBase import StructBase
+from ..........Internal.ArgStruct import ArgStruct
+from .......... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Sidelink:
-	"""Sidelink commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class RbIndexCls:
+	"""RbIndex commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("sidelink", core, parent)
+		self._cmd_group = CommandsGroup("rbIndex", core, parent)
 
 	# noinspection PyTypeChecker
-	class SidelinkStruct(StructBase):
-		"""Structure for setting input parameters. Fields: \n
-			- Auto: bool: OFF: manual definition via the other settings ON: automatic detection of RB allocation
-			- No_Rb_Pssch: int: Number of allocated RBs for the PSSCH in each measured slot
-			- Offset_Pssch: int: Offset of the first allocated PSSCH resource block
-			- Offset_Pscch: int: Offset of the first allocated PSCCH resource block"""
+	class FetchStruct(StructBase):
+		"""Response structure. Fields: \n
+			- Reliability: int: 'Reliability indicator'
+			- Seg_Reliability: int: Reliability indicator for the segment
+			- Statist_Expired: int: Reached statistical length in slots
+			- Out_Of_Tolerance: int: Percentage of measured subframes with failed limit check
+			- Rb_Index: int: Resource block index of margin"""
 		__meta_args_list = [
-			ArgStruct.scalar_bool('Auto'),
-			ArgStruct.scalar_int('No_Rb_Pssch'),
-			ArgStruct.scalar_int('Offset_Pssch'),
-			ArgStruct.scalar_int('Offset_Pscch')]
+			ArgStruct.scalar_int('Reliability', 'Reliability'),
+			ArgStruct.scalar_int('Seg_Reliability'),
+			ArgStruct.scalar_int('Statist_Expired'),
+			ArgStruct.scalar_int('Out_Of_Tolerance'),
+			ArgStruct.scalar_int('Rb_Index')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
-			self.Auto: bool = None
-			self.No_Rb_Pssch: int = None
-			self.Offset_Pssch: int = None
-			self.Offset_Pscch: int = None
-
-	def set(self, structure: SidelinkStruct, segment=repcap.Segment.Default) -> None:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:RBALlocation:SIDelink \n
-		Snippet: driver.configure.multiEval.listPy.segment.rbAllocation.sidelink.set(value = [PROPERTY_STRUCT_NAME](), segment = repcap.Segment.Default) \n
-		Allows you to define the sidelink resource block allocation manually for segment <no>. By default, the RB allocation is
-		detected automatically. Most allowed input ranges depend on other settings, see 'Sidelink Resource Block Allocation'. \n
-			:param structure: for set value, see the help for SidelinkStruct structure arguments.
-			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')"""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
-		self._core.io.write_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:RBALlocation:SIDelink', structure)
-
-	def get(self, segment=repcap.Segment.Default) -> SidelinkStruct:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:RBALlocation:SIDelink \n
-		Snippet: value: SidelinkStruct = driver.configure.multiEval.listPy.segment.rbAllocation.sidelink.get(segment = repcap.Segment.Default) \n
-		Allows you to define the sidelink resource block allocation manually for segment <no>. By default, the RB allocation is
-		detected automatically. Most allowed input ranges depend on other settings, see 'Sidelink Resource Block Allocation'. \n
+			self.Reliability: int = None
+			self.Seg_Reliability: int = None
+			self.Statist_Expired: int = None
+			self.Out_Of_Tolerance: int = None
+			self.Rb_Index: int = None
+
+	def fetch(self, segment=repcap.Segment.Default, carrierComponent=repcap.CarrierComponent.Default) -> FetchStruct:
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:IEMission:CC<c>:MARGin:EXTReme:RBINdex \n
+		Snippet: value: FetchStruct = driver.lteMeas.multiEval.listPy.segment.inbandEmission.cc.margin.extreme.rbIndex.fetch(segment = repcap.Segment.Default, carrierComponent = repcap.CarrierComponent.Default) \n
+		Return resource block indices of the component carrier CC<c> in-band emission measurement for segment <no> in list mode.
+		At these RB indices, the CURRent and EXTReme margins have been detected. \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
-			:return: structure: for return value, see the help for SidelinkStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
-		return self._core.io.query_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:RBALlocation:SIDelink?', self.__class__.SidelinkStruct())
+			:param carrierComponent: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Cc')
+			:return: structure: for return value, see the help for FetchStruct structure arguments."""
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
+		carrierComponent_cmd_val = self._cmd_group.get_repcap_cmd_value(carrierComponent, repcap.CarrierComponent)
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:IEMission:CC{carrierComponent_cmd_val}:MARGin:EXTReme:RBINdex?', self.__class__.FetchStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/Scc.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Trace/Iemissions/Ulca/Scc.py`

 * *Files 23% similar despite different names*

```diff
@@ -1,73 +1,62 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.StructBase import StructBase
-from ......Internal.ArgStruct import ArgStruct
-from ......Internal.RepeatedCapability import RepeatedCapability
-from ...... import enums
-from ...... import repcap
+from typing import List
+
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .......Internal.Types import DataType
+from .......Internal.RepeatedCapability import RepeatedCapability
+from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Scc:
-	"""Scc commands group definition. 1 total commands, 0 Sub-groups, 1 group commands
+class SccCls:
+	"""Scc commands group definition. 2 total commands, 0 Subgroups, 2 group commands
 	Repeated Capability: SecondaryCC, default value after init: SecondaryCC.CC1"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("scc", core, parent)
-		self._base.rep_cap = RepeatedCapability(self._base.group_name, 'repcap_secondaryCC_get', 'repcap_secondaryCC_set', repcap.SecondaryCC.CC1)
+		self._cmd_group = CommandsGroup("scc", core, parent)
+		self._cmd_group.rep_cap = RepeatedCapability(self._cmd_group.group_name, 'repcap_secondaryCC_get', 'repcap_secondaryCC_set', repcap.SecondaryCC.CC1)
 
-	def repcap_secondaryCC_set(self, enum_value: repcap.SecondaryCC) -> None:
+	def repcap_secondaryCC_set(self, secondaryCC: repcap.SecondaryCC) -> None:
 		"""Repeated Capability default value numeric suffix.
 		This value is used, if you do not explicitely set it in the child set/get methods, or if you leave it to SecondaryCC.Default
 		Default value after init: SecondaryCC.CC1"""
-		self._base.set_repcap_enum_value(enum_value)
+		self._cmd_group.set_repcap_enum_value(secondaryCC)
 
 	def repcap_secondaryCC_get(self) -> repcap.SecondaryCC:
 		"""Returns the current default repeated capability for the child set/get methods"""
 		# noinspection PyTypeChecker
-		return self._base.get_repcap_enum_value()
+		return self._cmd_group.get_repcap_enum_value()
 
-	# noinspection PyTypeChecker
-	class SccStruct(StructBase):
-		"""Structure for setting input parameters. Fields: \n
-			- Frequency: float: No parameter help available
-			- Ch_Bandwidth: enums.ChannelBandwidth: No parameter help available"""
-		__meta_args_list = [
-			ArgStruct.scalar_float('Frequency'),
-			ArgStruct.scalar_enum('Ch_Bandwidth', enums.ChannelBandwidth)]
-
-		def __init__(self):
-			StructBase.__init__(self, self)
-			self.Frequency: float = None
-			self.Ch_Bandwidth: enums.ChannelBandwidth = None
-
-	def set(self, structure: SccStruct, segment=repcap.Segment.Default, secondaryCC=repcap.SecondaryCC.Default) -> None:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:SCC<c> \n
-		Snippet: driver.configure.multiEval.listPy.segment.scc.set(value = [PROPERTY_STRUCT_NAME](), segment = repcap.Segment.Default, secondaryCC = repcap.SecondaryCC.Default) \n
+	def read(self, secondaryCC=repcap.SecondaryCC.Default) -> List[float]:
+		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:TRACe:IEMissions:ULCA:SCC<Nr> \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.trace.iemissions.ulca.scc.read(secondaryCC = repcap.SecondaryCC.Default) \n
 		No command help available \n
-			:param structure: for set value, see the help for SccStruct structure arguments.
-			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
-			:param secondaryCC: optional repeated capability selector. Default value: CC1 (settable in the interface 'Scc')"""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
-		secondaryCC_cmd_val = self._base.get_repcap_cmd_value(secondaryCC, repcap.SecondaryCC)
-		self._core.io.write_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:SCC{secondaryCC_cmd_val}', structure)
-
-	def get(self, segment=repcap.Segment.Default, secondaryCC=repcap.SecondaryCC.Default) -> SccStruct:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:SCC<c> \n
-		Snippet: value: SccStruct = driver.configure.multiEval.listPy.segment.scc.get(segment = repcap.Segment.Default, secondaryCC = repcap.SecondaryCC.Default) \n
+		Suppressed linked return values: reliability \n
+			:param secondaryCC: optional repeated capability selector. Default value: CC1 (settable in the interface 'Scc')
+			:return: power: No help available"""
+		secondaryCC_cmd_val = self._cmd_group.get_repcap_cmd_value(secondaryCC, repcap.SecondaryCC)
+		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:LTE:MEASurement<Instance>:MEValuation:TRACe:IEMissions:ULCA:SCC{secondaryCC_cmd_val}?', suppressed)
+		return response
+
+	def fetch(self, secondaryCC=repcap.SecondaryCC.Default) -> List[float]:
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:TRACe:IEMissions:ULCA:SCC<Nr> \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.trace.iemissions.ulca.scc.fetch(secondaryCC = repcap.SecondaryCC.Default) \n
 		No command help available \n
-			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
+		Suppressed linked return values: reliability \n
 			:param secondaryCC: optional repeated capability selector. Default value: CC1 (settable in the interface 'Scc')
-			:return: structure: for return value, see the help for SccStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
-		secondaryCC_cmd_val = self._base.get_repcap_cmd_value(secondaryCC, repcap.SecondaryCC)
-		return self._core.io.query_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:SCC{secondaryCC_cmd_val}?', self.__class__.SccStruct())
+			:return: power: No help available"""
+		secondaryCC_cmd_val = self._cmd_group.get_repcap_cmd_value(secondaryCC, repcap.SecondaryCC)
+		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:TRACe:IEMissions:ULCA:SCC{secondaryCC_cmd_val}?', suppressed)
+		return response
 
-	def clone(self) -> 'Scc':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'SccCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Scc(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = SccCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/SeMask.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Pmonitor/Ulca/Scc/Average.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,52 +1,49 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.StructBase import StructBase
-from ......Internal.ArgStruct import ArgStruct
-from ...... import repcap
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal.StructBase import StructBase
+from .......Internal.ArgStruct import ArgStruct
+from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class SeMask:
-	"""SeMask commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class AverageCls:
+	"""Average commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("seMask", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	# noinspection PyTypeChecker
-	class SeMaskStruct(StructBase):
-		"""Structure for setting input parameters. Fields: \n
-			- Sem_Statistics: int: Statistical length in slots
-			- Se_Enable: bool: Enable or disable the measurement of spectrum emission results ON: Spectrum emission results are measured according to the other enable flags in this command. Results for which there is no explicit enable flag are also measured. OFF: No spectrum emission results at all are measured. The other enable flags in this command are ignored.
-			- Obw_Enable: bool: Enable or disable measurement of occupied bandwidth
-			- Sem_Enable: bool: Enable or disable measurement of spectrum emission trace and margin results"""
+	class ResultData(StructBase):
+		"""Response structure. Fields: \n
+			- Reliability: int: No parameter help available
+			- Out_Of_Tolerance: int: No parameter help available
+			- Tx_Power: float: No parameter help available"""
 		__meta_args_list = [
-			ArgStruct.scalar_int('Sem_Statistics'),
-			ArgStruct.scalar_bool('Se_Enable'),
-			ArgStruct.scalar_bool('Obw_Enable'),
-			ArgStruct.scalar_bool('Sem_Enable')]
+			ArgStruct.scalar_int('Reliability', 'Reliability'),
+			ArgStruct.scalar_int('Out_Of_Tolerance'),
+			ArgStruct.scalar_float('Tx_Power')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
-			self.Sem_Statistics: int = None
-			self.Se_Enable: bool = None
-			self.Obw_Enable: bool = None
-			self.Sem_Enable: bool = None
-
-	def set(self, structure: SeMaskStruct, segment=repcap.Segment.Default) -> None:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:SEMask \n
-		Snippet: driver.configure.multiEval.listPy.segment.seMask.set(value = [PROPERTY_STRUCT_NAME](), segment = repcap.Segment.Default) \n
-		Defines settings for spectrum emission measurements in list mode for segment <no>. \n
-			:param structure: for set value, see the help for SeMaskStruct structure arguments.
-			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')"""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
-		self._core.io.write_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:SEMask', structure)
-
-	def get(self, segment=repcap.Segment.Default) -> SeMaskStruct:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:SEMask \n
-		Snippet: value: SeMaskStruct = driver.configure.multiEval.listPy.segment.seMask.get(segment = repcap.Segment.Default) \n
-		Defines settings for spectrum emission measurements in list mode for segment <no>. \n
-			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
-			:return: structure: for return value, see the help for SeMaskStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
-		return self._core.io.query_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:SEMask?', self.__class__.SeMaskStruct())
+			self.Reliability: int = None
+			self.Out_Of_Tolerance: int = None
+			self.Tx_Power: float = None
+
+	def read(self, secondaryCC=repcap.SecondaryCC.Default) -> ResultData:
+		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:PMONitor:ULCA:SCC<Nr>:AVERage \n
+		Snippet: value: ResultData = driver.lteMeas.multiEval.pmonitor.ulca.scc.average.read(secondaryCC = repcap.SecondaryCC.Default) \n
+		No command help available \n
+			:param secondaryCC: optional repeated capability selector. Default value: CC1 (settable in the interface 'Scc')
+			:return: structure: for return value, see the help for ResultData structure arguments."""
+		secondaryCC_cmd_val = self._cmd_group.get_repcap_cmd_value(secondaryCC, repcap.SecondaryCC)
+		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:PMONitor:ULCA:SCC{secondaryCC_cmd_val}:AVERage?', self.__class__.ResultData())
+
+	def fetch(self, secondaryCC=repcap.SecondaryCC.Default) -> ResultData:
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:PMONitor:ULCA:SCC<Nr>:AVERage \n
+		Snippet: value: ResultData = driver.lteMeas.multiEval.pmonitor.ulca.scc.average.fetch(secondaryCC = repcap.SecondaryCC.Default) \n
+		No command help available \n
+			:param secondaryCC: optional repeated capability selector. Default value: CC1 (settable in the interface 'Scc')
+			:return: structure: for return value, see the help for ResultData structure arguments."""
+		secondaryCC_cmd_val = self._cmd_group.get_repcap_cmd_value(secondaryCC, repcap.SecondaryCC)
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:PMONitor:ULCA:SCC{secondaryCC_cmd_val}:AVERage?', self.__class__.ResultData())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/Setup.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/ListPy/Segment/Setup.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,49 +1,54 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.StructBase import StructBase
-from ......Internal.ArgStruct import ArgStruct
-from ...... import enums
-from ...... import repcap
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal.StructBase import StructBase
+from .......Internal.ArgStruct import ArgStruct
+from ....... import enums
+from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Setup:
-	"""Setup commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class SetupCls:
+	"""Setup commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("setup", core, parent)
+		self._cmd_group = CommandsGroup("setup", core, parent)
 
 	# noinspection PyTypeChecker
 	class SetupStruct(StructBase):
 		"""Structure for setting input parameters. Contains optional setting parameters. Fields: \n
 			- Segment_Length: int: Number of subframes in the segment
-			- Level: float: Expected nominal power in the segment. The range can be calculated as follows: Range (Expected Nominal Power) = Range (Input Power) + External Attenuation - User Margin The input power range is stated in the data sheet.
+			- Level: float: Expected nominal power in the segment. The range can be calculated as follows: Range (Expected Nominal Power) = Range (Input Power) + External Attenuation - User Margin The input power range is stated in the specifications document.
 			- Duplex_Mode: enums.Mode: Duplex mode used in the segment
 			- Band: enums.Band: TDD UL: OB33 | ... | OB45 | OB48 | OB50 | ... | OB53 | OB250 Sidelink: OB47 Operating band used in the segment
-			- Frequency: float: Center frequency of CC1 used in the segment For the supported range, see 'Frequency Ranges'.
-			- Ch_Bandwidth: enums.ChannelBandwidth: Channel bandwidth of CC1 used in the segment B014: 1.4 MHz B030: 3 MHz B050: 5 MHz B100: 10 MHz B150: 15 MHz B200: 20 MHz
+			- Frequency: float: Center frequency of CC1 used in the segment For the supported range, see 'Frequency ranges'.
+			- Ch_Bandwidth: enums.ChannelBandwidth: Channel bandwidth of CC1 used in the segment. B014: 1.4 MHz B030: 3 MHz B050: 5 MHz B100: 10 MHz B150: 15 MHz B200: 20 MHz
 			- Cyclic_Prefix: enums.CyclicPrefix: Type of cyclic prefix used in the segment
-			- Channel_Type: enums.SegmentChannelTypeExtended: Channel type to be measured in the segment (AUTO for automatic detection) Uplink: AUTO, PUSCh, PUCCh Sidelink: PSSCh, PSCCh
-			- Retrigger_Flag: enums.RetriggerFlag: Specifies whether the measurement waits for a trigger event before measuring the segment, or not. For the first segment, the value OFF is always interpreted as ON. For subsequent segments, the retrigger flag is ignored for trigger mode ONCE and evaluated for trigger mode SEGMent, see [CMDLINK: TRIGger:LTE:MEASi:MEValuation:LIST:MODE CMDLINK]. OFF: measure the segment without retrigger ON: wait for a trigger event from the trigger source configured via [CMDLINK: TRIGger:LTE:MEASi:MEValuation:SOURce CMDLINK] IFPower: wait for a trigger event from the trigger source IF Power
+			- Channel_Type: enums.SegmentChannelTypeExtended: Channel type to be measured in the segment (AUTO for automatic detection) . Uplink: AUTO, PUSCh, PUCCh Sidelink: PSSCh, PSCCh, PSBCh
+			- Retrigger_Flag: enums.RetriggerFlag: Specifies whether the measurement waits for a trigger event before measuring the segment, or not. The retrigger flag is ignored for trigger mode ONCE and evaluated for trigger mode SEGMent, see [CMDLINKRESOLVED Trigger.LteMeas.MultiEval.ListPy#Mode CMDLINKRESOLVED].
+				- OFF: Measure the segment without retrigger. For the first segment, the value OFF is interpreted as ON.
+				- ON: Wait for a trigger event from the trigger source configured via TRIGger:LTE:MEASi:MEValuation:SOURce.
+				- IFPower: Wait for a trigger event from the trigger source IF Power.The trigger evaluation bandwidth is 160 MHz.
+				- IFPNarrowband: Wait for a trigger event from the trigger source IF Power.The trigger evaluation bandwidth is configured via TRIGger:LTE:MEASi:MEValuation:LIST:NBANdwidth.
 			- Evaluat_Offset: int: Number of subframes at the beginning of the segment that are not evaluated
-			- Network_Sig_Value: enums.NetworkSigValueNoCarrAggr: Optional setting parameter. Network signaled value to be used for the segment"""
+			- Network_Sig_Value: enums.NetworkSigValueNoCarrAggr: Optional setting parameter. Network signaled value to be used
+			for the segment"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Segment_Length'),
 			ArgStruct.scalar_float('Level'),
 			ArgStruct.scalar_enum('Duplex_Mode', enums.Mode),
 			ArgStruct.scalar_enum('Band', enums.Band),
 			ArgStruct.scalar_float('Frequency'),
 			ArgStruct.scalar_enum('Ch_Bandwidth', enums.ChannelBandwidth),
 			ArgStruct.scalar_enum('Cyclic_Prefix', enums.CyclicPrefix),
 			ArgStruct.scalar_enum('Channel_Type', enums.SegmentChannelTypeExtended),
 			ArgStruct.scalar_enum('Retrigger_Flag', enums.RetriggerFlag),
 			ArgStruct.scalar_int('Evaluat_Offset'),
-			ArgStruct.scalar_enum('Network_Sig_Value', enums.NetworkSigValueNoCarrAggr)]
+			ArgStruct.scalar_enum_optional('Network_Sig_Value', enums.NetworkSigValueNoCarrAggr)]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Segment_Length: int = None
 			self.Level: float = None
 			self.Duplex_Mode: enums.Mode = None
 			self.Band: enums.Band = None
@@ -53,28 +58,42 @@
 			self.Channel_Type: enums.SegmentChannelTypeExtended = None
 			self.Retrigger_Flag: enums.RetriggerFlag = None
 			self.Evaluat_Offset: int = None
 			self.Network_Sig_Value: enums.NetworkSigValueNoCarrAggr = None
 
 	def set(self, structure: SetupStruct, segment=repcap.Segment.Default) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:SETup \n
-		Snippet: driver.configure.multiEval.listPy.segment.setup.set(value = [PROPERTY_STRUCT_NAME](), segment = repcap.Segment.Default) \n
+		Snippet with structure: \n
+		structure = driver.configure.lteMeas.multiEval.listPy.segment.setup.SetupStruct() \n
+		structure.Segment_Length: int = 1 \n
+		structure.Level: float = 1.0 \n
+		structure.Duplex_Mode: enums.Mode = enums.Mode.FDD \n
+		structure.Band: enums.Band = enums.Band.OB1 \n
+		structure.Frequency: float = 1.0 \n
+		structure.Ch_Bandwidth: enums.ChannelBandwidth = enums.ChannelBandwidth.B014 \n
+		structure.Cyclic_Prefix: enums.CyclicPrefix = enums.CyclicPrefix.EXTended \n
+		structure.Channel_Type: enums.SegmentChannelTypeExtended = enums.SegmentChannelTypeExtended.AUTO \n
+		structure.Retrigger_Flag: enums.RetriggerFlag = enums.RetriggerFlag.IFPNarrow \n
+		structure.Evaluat_Offset: int = 1 \n
+		structure.Network_Sig_Value: enums.NetworkSigValueNoCarrAggr = enums.NetworkSigValueNoCarrAggr.NS01 \n
+		driver.configure.lteMeas.multiEval.listPy.segment.setup.set(structure, segment = repcap.Segment.Default) \n
 		Defines the length and analyzer settings of segment <no>. This command must be sent for all segments to be measured
-		(method RsCMPX_LteMeas.Configure.MultiEval.ListPy.lrange) . For uplink signals with TDD mode, see also method
-		RsCMPX_LteMeas.Configure.MultiEval.ListPy.Segment.Tdd.set. For carrier-specific settings for carrier aggregation, see
-		CONFigure:LTE:MEAS<i>:MEValuation:LIST:SEGMent<no>:CC<c>. \n
+		(method RsCMPX_LteMeas.Configure.LteMeas.MultiEval.ListPy.Lrange.set) . For uplink signals with TDD mode, see also method
+		RsCMPX_LteMeas.Configure.LteMeas.MultiEval.ListPy.Segment.Tdd.set. For carrier-specific settings for carrier aggregation,
+		see CONFigure:LTE:MEAS<i>:MEValuation:LIST:SEGMent<no>:CC<c>. \n
 			:param structure: for set value, see the help for SetupStruct structure arguments.
-			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')"""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
+		"""
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		self._core.io.write_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:SETup', structure)
 
 	def get(self, segment=repcap.Segment.Default) -> SetupStruct:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:SETup \n
-		Snippet: value: SetupStruct = driver.configure.multiEval.listPy.segment.setup.get(segment = repcap.Segment.Default) \n
+		Snippet: value: SetupStruct = driver.configure.lteMeas.multiEval.listPy.segment.setup.get(segment = repcap.Segment.Default) \n
 		Defines the length and analyzer settings of segment <no>. This command must be sent for all segments to be measured
-		(method RsCMPX_LteMeas.Configure.MultiEval.ListPy.lrange) . For uplink signals with TDD mode, see also method
-		RsCMPX_LteMeas.Configure.MultiEval.ListPy.Segment.Tdd.set. For carrier-specific settings for carrier aggregation, see
-		CONFigure:LTE:MEAS<i>:MEValuation:LIST:SEGMent<no>:CC<c>. \n
+		(method RsCMPX_LteMeas.Configure.LteMeas.MultiEval.ListPy.Lrange.set) . For uplink signals with TDD mode, see also method
+		RsCMPX_LteMeas.Configure.LteMeas.MultiEval.ListPy.Segment.Tdd.set. For carrier-specific settings for carrier aggregation,
+		see CONFigure:LTE:MEAS<i>:MEValuation:LIST:SEGMent<no>:CC<c>. \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
 			:return: structure: for return value, see the help for SetupStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		return self._core.io.query_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:SETup?', self.__class__.SetupStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/SingleCmw.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/ListPy/Segment/SingleCmw/__init__.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,27 +1,27 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
+from ........Internal.Core import Core
+from ........Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class SingleCmw:
-	"""SingleCmw commands group definition. 1 total commands, 1 Sub-groups, 0 group commands"""
+class SingleCmwCls:
+	"""SingleCmw commands group definition. 1 total commands, 1 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("singleCmw", core, parent)
+		self._cmd_group = CommandsGroup("singleCmw", core, parent)
 
 	@property
 	def connector(self):
 		"""connector commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_connector'):
-			from .SingleCmw_.Connector import Connector
-			self._connector = Connector(self._core, self._base)
+			from .Connector import ConnectorCls
+			self._connector = ConnectorCls(self._core, self._cmd_group)
 		return self._connector
 
-	def clone(self) -> 'SingleCmw':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'SingleCmwCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = SingleCmw(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = SingleCmwCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/SingleCmw_/Connector.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/InbandEmission/Scc/Margin/Extreme/RbIndex.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,35 +1,48 @@
-from .......Internal.Core import Core
-from .......Internal.CommandsGroup import CommandsGroup
-from .......Internal import Conversions
-from ....... import enums
-from ....... import repcap
+from ..........Internal.Core import Core
+from ..........Internal.CommandsGroup import CommandsGroup
+from ..........Internal.StructBase import StructBase
+from ..........Internal.ArgStruct import ArgStruct
+from .......... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Connector:
-	"""Connector commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class RbIndexCls:
+	"""RbIndex commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("connector", core, parent)
-
-	def set(self, cmws_connector: enums.CmwsConnector, segment=repcap.Segment.Default) -> None:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:CMWS:CONNector \n
-		Snippet: driver.configure.multiEval.listPy.segment.singleCmw.connector.set(cmws_connector = enums.CmwsConnector.R11, segment = repcap.Segment.Default) \n
-		No command help available \n
-			:param cmws_connector: No help available
-			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')"""
-		param = Conversions.enum_scalar_to_str(cmws_connector, enums.CmwsConnector)
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
-		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:CMWS:CONNector {param}')
+		self._cmd_group = CommandsGroup("rbIndex", core, parent)
 
 	# noinspection PyTypeChecker
-	def get(self, segment=repcap.Segment.Default) -> enums.CmwsConnector:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:CMWS:CONNector \n
-		Snippet: value: enums.CmwsConnector = driver.configure.multiEval.listPy.segment.singleCmw.connector.get(segment = repcap.Segment.Default) \n
+	class FetchStruct(StructBase):
+		"""Response structure. Fields: \n
+			- Reliability: int: No parameter help available
+			- Seg_Reliability: int: No parameter help available
+			- Statist_Expired: int: No parameter help available
+			- Out_Of_Tolerance: int: No parameter help available
+			- Rb_Index: int: No parameter help available"""
+		__meta_args_list = [
+			ArgStruct.scalar_int('Reliability', 'Reliability'),
+			ArgStruct.scalar_int('Seg_Reliability'),
+			ArgStruct.scalar_int('Statist_Expired'),
+			ArgStruct.scalar_int('Out_Of_Tolerance'),
+			ArgStruct.scalar_int('Rb_Index')]
+
+		def __init__(self):
+			StructBase.__init__(self, self)
+			self.Reliability: int = None
+			self.Seg_Reliability: int = None
+			self.Statist_Expired: int = None
+			self.Out_Of_Tolerance: int = None
+			self.Rb_Index: int = None
+
+	def fetch(self, segment=repcap.Segment.Default, secondaryCC=repcap.SecondaryCC.Default) -> FetchStruct:
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:IEMission:SCC<c>:MARGin:EXTReme:RBINdex \n
+		Snippet: value: FetchStruct = driver.lteMeas.multiEval.listPy.segment.inbandEmission.scc.margin.extreme.rbIndex.fetch(segment = repcap.Segment.Default, secondaryCC = repcap.SecondaryCC.Default) \n
 		No command help available \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
-			:return: cmws_connector: No help available"""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
-		response = self._core.io.query_str(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:CMWS:CONNector?')
-		return Conversions.str_to_scalar_enum(response, enums.CmwsConnector)
+			:param secondaryCC: optional repeated capability selector. Default value: CC1 (settable in the interface 'Scc')
+			:return: structure: for return value, see the help for FetchStruct structure arguments."""
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
+		secondaryCC_cmd_val = self._cmd_group.get_repcap_cmd_value(secondaryCC, repcap.SecondaryCC)
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:IEMission:SCC{secondaryCC_cmd_val}:MARGin:EXTReme:RBINdex?', self.__class__.FetchStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/ListPy_/Segment_/Tdd.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/ListPy/Segment/Tdd.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,48 +1,54 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.StructBase import StructBase
-from ......Internal.ArgStruct import ArgStruct
-from ...... import repcap
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal.Types import DataType
+from .......Internal.StructBase import StructBase
+from .......Internal.ArgStruct import ArgStruct
+from .......Internal.ArgSingleList import ArgSingleList
+from .......Internal.ArgSingle import ArgSingle
+from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Tdd:
-	"""Tdd commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class TddCls:
+	"""Tdd commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("tdd", core, parent)
+		self._cmd_group = CommandsGroup("tdd", core, parent)
+
+	def set(self, uplink_downlink: int, special_subframe: int, segment=repcap.Segment.Default) -> None:
+		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:TDD \n
+		Snippet: driver.configure.lteMeas.multiEval.listPy.segment.tdd.set(uplink_downlink = 1, special_subframe = 1, segment = repcap.Segment.Default) \n
+		Defines segment settings only relevant for uplink measurements with the duplex mode TDD.
+		For general segment configuration, see method RsCMPX_LteMeas.Configure.LteMeas.MultiEval.ListPy.Segment.Setup.set. \n
+			:param uplink_downlink: UL-DL configuration, defining the combination of uplink, downlink and special subframes within a radio frame
+			:param special_subframe: Special subframe configuration, defining the inner structure of special subframes
+			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
+		"""
+		param = ArgSingleList().compose_cmd_string(ArgSingle('uplink_downlink', uplink_downlink, DataType.Integer), ArgSingle('special_subframe', special_subframe, DataType.Integer))
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
+		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:TDD {param}'.rstrip())
 
 	# noinspection PyTypeChecker
 	class TddStruct(StructBase):
-		"""Structure for setting input parameters. Fields: \n
+		"""Response structure. Fields: \n
 			- Uplink_Downlink: int: UL-DL configuration, defining the combination of uplink, downlink and special subframes within a radio frame
 			- Special_Subframe: int: Special subframe configuration, defining the inner structure of special subframes"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Uplink_Downlink'),
 			ArgStruct.scalar_int('Special_Subframe')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Uplink_Downlink: int = None
 			self.Special_Subframe: int = None
 
-	def set(self, structure: TddStruct, segment=repcap.Segment.Default) -> None:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:TDD \n
-		Snippet: driver.configure.multiEval.listPy.segment.tdd.set(value = [PROPERTY_STRUCT_NAME](), segment = repcap.Segment.Default) \n
-		Defines segment settings only relevant for uplink measurements with the duplex mode TDD.
-		For general segment configuration, see method RsCMPX_LteMeas.Configure.MultiEval.ListPy.Segment.Setup.set. \n
-			:param structure: for set value, see the help for TddStruct structure arguments.
-			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')"""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
-		self._core.io.write_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:TDD', structure)
-
 	def get(self, segment=repcap.Segment.Default) -> TddStruct:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:TDD \n
-		Snippet: value: TddStruct = driver.configure.multiEval.listPy.segment.tdd.get(segment = repcap.Segment.Default) \n
+		Snippet: value: TddStruct = driver.configure.lteMeas.multiEval.listPy.segment.tdd.get(segment = repcap.Segment.Default) \n
 		Defines segment settings only relevant for uplink measurements with the duplex mode TDD.
-		For general segment configuration, see method RsCMPX_LteMeas.Configure.MultiEval.ListPy.Segment.Setup.set. \n
+		For general segment configuration, see method RsCMPX_LteMeas.Configure.LteMeas.MultiEval.ListPy.Segment.Setup.set. \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
 			:return: structure: for return value, see the help for TddStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		return self._core.io.query_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:TDD?', self.__class__.TddStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/ListPy_/SingleCmw.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/ListPy/SingleCmw/__init__.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,48 +1,48 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
-from .....Internal import Conversions
-from ..... import enums
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal import Conversions
+from ....... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class SingleCmw:
-	"""SingleCmw commands group definition. 2 total commands, 1 Sub-groups, 1 group commands"""
+class SingleCmwCls:
+	"""SingleCmw commands group definition. 2 total commands, 1 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("singleCmw", core, parent)
+		self._cmd_group = CommandsGroup("singleCmw", core, parent)
 
 	@property
 	def connector(self):
 		"""connector commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_connector'):
-			from .SingleCmw_.Connector import Connector
-			self._connector = Connector(self._core, self._base)
+			from .Connector import ConnectorCls
+			self._connector = ConnectorCls(self._core, self._cmd_group)
 		return self._connector
 
 	# noinspection PyTypeChecker
 	def get_cmode(self) -> enums.ParameterSetMode:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:CMWS:CMODe \n
-		Snippet: value: enums.ParameterSetMode = driver.configure.multiEval.listPy.singleCmw.get_cmode() \n
+		Snippet: value: enums.ParameterSetMode = driver.configure.lteMeas.multiEval.listPy.singleCmw.get_cmode() \n
 		No command help available \n
 			:return: connector_mode: No help available
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:CMWS:CMODe?')
 		return Conversions.str_to_scalar_enum(response, enums.ParameterSetMode)
 
 	def set_cmode(self, connector_mode: enums.ParameterSetMode) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:CMWS:CMODe \n
-		Snippet: driver.configure.multiEval.listPy.singleCmw.set_cmode(connector_mode = enums.ParameterSetMode.GLOBal) \n
+		Snippet: driver.configure.lteMeas.multiEval.listPy.singleCmw.set_cmode(connector_mode = enums.ParameterSetMode.GLOBal) \n
 		No command help available \n
 			:param connector_mode: No help available
 		"""
 		param = Conversions.enum_scalar_to_str(connector_mode, enums.ParameterSetMode)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:CMWS:CMODe {param}')
 
-	def clone(self) -> 'SingleCmw':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'SingleCmwCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = SingleCmw(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = SingleCmwCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/ListPy_/SingleCmw_/Connector.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/ListPy/SingleCmw/Connector.py`

 * *Files 11% similar despite different names*

```diff
@@ -1,34 +1,34 @@
 from typing import List
 
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal import Conversions
-from ...... import enums
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal import Conversions
+from ....... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Connector:
-	"""Connector commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class ConnectorCls:
+	"""Connector commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("connector", core, parent)
+		self._cmd_group = CommandsGroup("connector", core, parent)
 
 	# noinspection PyTypeChecker
 	def get_all(self) -> List[enums.CmwsConnector]:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:CMWS:CONNector:ALL \n
-		Snippet: value: List[enums.CmwsConnector] = driver.configure.multiEval.listPy.singleCmw.connector.get_all() \n
+		Snippet: value: List[enums.CmwsConnector] = driver.configure.lteMeas.multiEval.listPy.singleCmw.connector.get_all() \n
 		No command help available \n
 			:return: cmws_connector: No help available
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:CMWS:CONNector:ALL?')
 		return Conversions.str_to_list_enum(response, enums.CmwsConnector)
 
 	def set_all(self, cmws_connector: List[enums.CmwsConnector]) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:CMWS:CONNector:ALL \n
-		Snippet: driver.configure.multiEval.listPy.singleCmw.connector.set_all(cmws_connector = [CmwsConnector.R11, CmwsConnector.RB8]) \n
+		Snippet: driver.configure.lteMeas.multiEval.listPy.singleCmw.connector.set_all(cmws_connector = [CmwsConnector.R11, CmwsConnector.RB8]) \n
 		No command help available \n
 			:param cmws_connector: No help available
 		"""
 		param = Conversions.enum_list_to_str(cmws_connector, enums.CmwsConnector)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIST:CMWS:CONNector:ALL {param}')
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Modulation.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Modulation/__init__.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,101 +1,101 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
-from ....Internal import Conversions
-from .... import enums
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal import Conversions
+from ...... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Modulation:
-	"""Modulation commands group definition. 9 total commands, 3 Sub-groups, 3 group commands"""
+class ModulationCls:
+	"""Modulation commands group definition. 9 total commands, 3 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("modulation", core, parent)
+		self._cmd_group = CommandsGroup("modulation", core, parent)
 
 	@property
 	def ewLength(self):
 		"""ewLength commands group. 1 Sub-classes, 1 commands."""
 		if not hasattr(self, '_ewLength'):
-			from .Modulation_.EwLength import EwLength
-			self._ewLength = EwLength(self._core, self._base)
+			from .EwLength import EwLengthCls
+			self._ewLength = EwLengthCls(self._core, self._cmd_group)
 		return self._ewLength
 
 	@property
 	def eePeriods(self):
 		"""eePeriods commands group. 1 Sub-classes, 1 commands."""
 		if not hasattr(self, '_eePeriods'):
-			from .Modulation_.EePeriods import EePeriods
-			self._eePeriods = EePeriods(self._core, self._base)
+			from .EePeriods import EePeriodsCls
+			self._eePeriods = EePeriodsCls(self._core, self._cmd_group)
 		return self._eePeriods
 
 	@property
 	def carrierAggregation(self):
 		"""carrierAggregation commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_carrierAggregation'):
-			from .Modulation_.CarrierAggregation import CarrierAggregation
-			self._carrierAggregation = CarrierAggregation(self._core, self._base)
+			from .CarrierAggregation import CarrierAggregationCls
+			self._carrierAggregation = CarrierAggregationCls(self._core, self._cmd_group)
 		return self._carrierAggregation
 
 	def get_equalizer(self) -> bool:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:MODulation:EQUalizer \n
-		Snippet: value: bool = driver.configure.multiEval.modulation.get_equalizer() \n
+		Snippet: value: bool = driver.configure.lteMeas.multiEval.modulation.get_equalizer() \n
 		Enables or disables the post-FFT equalization step for the measurement of modulation results. \n
 			:return: enable: No help available
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:MEValuation:MODulation:EQUalizer?')
 		return Conversions.str_to_bool(response)
 
 	def set_equalizer(self, enable: bool) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:MODulation:EQUalizer \n
-		Snippet: driver.configure.multiEval.modulation.set_equalizer(enable = False) \n
+		Snippet: driver.configure.lteMeas.multiEval.modulation.set_equalizer(enable = False) \n
 		Enables or disables the post-FFT equalization step for the measurement of modulation results. \n
 			:param enable: No help available
 		"""
 		param = Conversions.bool_to_str(enable)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:MODulation:EQUalizer {param}')
 
 	# noinspection PyTypeChecker
 	def get_mscheme(self) -> enums.ModScheme:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:MODulation:MSCHeme \n
-		Snippet: value: enums.ModScheme = driver.configure.multiEval.modulation.get_mscheme() \n
+		Snippet: value: enums.ModScheme = driver.configure.lteMeas.multiEval.modulation.get_mscheme() \n
 		Selects the modulation scheme used by the measured signal. \n
-			:return: mod_scheme: Auto-detection, QPSK, 16-QAM, 64-QAM, 256-QAM
+			:return: mod_scheme: Auto-detection, QPSK, 16QAM, 64QAM, 256QAM
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:MEValuation:MODulation:MSCHeme?')
 		return Conversions.str_to_scalar_enum(response, enums.ModScheme)
 
 	def set_mscheme(self, mod_scheme: enums.ModScheme) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:MODulation:MSCHeme \n
-		Snippet: driver.configure.multiEval.modulation.set_mscheme(mod_scheme = enums.ModScheme.AUTO) \n
+		Snippet: driver.configure.lteMeas.multiEval.modulation.set_mscheme(mod_scheme = enums.ModScheme.AUTO) \n
 		Selects the modulation scheme used by the measured signal. \n
-			:param mod_scheme: Auto-detection, QPSK, 16-QAM, 64-QAM, 256-QAM
+			:param mod_scheme: Auto-detection, QPSK, 16QAM, 64QAM, 256QAM
 		"""
 		param = Conversions.enum_scalar_to_str(mod_scheme, enums.ModScheme)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:MODulation:MSCHeme {param}')
 
 	# noinspection PyTypeChecker
 	def get_llocation(self) -> enums.LocalOscLocation:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:MODulation:LLOCation \n
-		Snippet: value: enums.LocalOscLocation = driver.configure.multiEval.modulation.get_llocation() \n
+		Snippet: value: enums.LocalOscLocation = driver.configure.lteMeas.multiEval.modulation.get_llocation() \n
 		Specifies the UE transmitter architecture (local oscillator location) used for eMTC. \n
-			:return: value: CN: Center of narrowband CCB: Center of channel bandwidth
+			:return: value: CN: Center of narrowband/wideband CCB: Center of channel bandwidth
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:MEValuation:MODulation:LLOCation?')
 		return Conversions.str_to_scalar_enum(response, enums.LocalOscLocation)
 
 	def set_llocation(self, value: enums.LocalOscLocation) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:MODulation:LLOCation \n
-		Snippet: driver.configure.multiEval.modulation.set_llocation(value = enums.LocalOscLocation.CCB) \n
+		Snippet: driver.configure.lteMeas.multiEval.modulation.set_llocation(value = enums.LocalOscLocation.CCB) \n
 		Specifies the UE transmitter architecture (local oscillator location) used for eMTC. \n
-			:param value: CN: Center of narrowband CCB: Center of channel bandwidth
+			:param value: CN: Center of narrowband/wideband CCB: Center of channel bandwidth
 		"""
 		param = Conversions.enum_scalar_to_str(value, enums.LocalOscLocation)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:MODulation:LLOCation {param}')
 
-	def clone(self) -> 'Modulation':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'ModulationCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Modulation(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = ModulationCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Modulation_/CarrierAggregation.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Modulation/CarrierAggregation.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,32 +1,32 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
-from .....Internal import Conversions
-from ..... import enums
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal import Conversions
+from ...... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class CarrierAggregation:
-	"""CarrierAggregation commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class CarrierAggregationCls:
+	"""CarrierAggregation commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("carrierAggregation", core, parent)
+		self._cmd_group = CommandsGroup("carrierAggregation", core, parent)
 
 	# noinspection PyTypeChecker
 	def get_llocation(self) -> enums.CarrAggrLocalOscLocation:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:MODulation:CAGGregation:LLOCation \n
-		Snippet: value: enums.CarrAggrLocalOscLocation = driver.configure.multiEval.modulation.carrierAggregation.get_llocation() \n
+		Snippet: value: enums.CarrAggrLocalOscLocation = driver.configure.lteMeas.multiEval.modulation.carrierAggregation.get_llocation() \n
 		Specifies the UE transmitter architecture (local oscillator location) used for contiguous carrier aggregation. \n
 			:return: value: CACB: Center of aggregated channel bandwidth CECC: Center of each component carrier
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:MEValuation:MODulation:CAGGregation:LLOCation?')
 		return Conversions.str_to_scalar_enum(response, enums.CarrAggrLocalOscLocation)
 
 	def set_llocation(self, value: enums.CarrAggrLocalOscLocation) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:MODulation:CAGGregation:LLOCation \n
-		Snippet: driver.configure.multiEval.modulation.carrierAggregation.set_llocation(value = enums.CarrAggrLocalOscLocation.AUTO) \n
+		Snippet: driver.configure.lteMeas.multiEval.modulation.carrierAggregation.set_llocation(value = enums.CarrAggrLocalOscLocation.AUTO) \n
 		Specifies the UE transmitter architecture (local oscillator location) used for contiguous carrier aggregation. \n
 			:param value: CACB: Center of aggregated channel bandwidth CECC: Center of each component carrier
 		"""
 		param = Conversions.enum_scalar_to_str(value, enums.CarrAggrLocalOscLocation)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:MODulation:CAGGregation:LLOCation {param}')
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Modulation_/EePeriods.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Modulation/EePeriods/__init__.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,52 +1,52 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
-from .....Internal import Conversions
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal import Conversions
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class EePeriods:
-	"""EePeriods commands group definition. 3 total commands, 1 Sub-groups, 1 group commands"""
+class EePeriodsCls:
+	"""EePeriods commands group definition. 3 total commands, 1 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("eePeriods", core, parent)
+		self._cmd_group = CommandsGroup("eePeriods", core, parent)
 
 	@property
 	def pusch(self):
 		"""pusch commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_pusch'):
-			from .EePeriods_.Pusch import Pusch
-			self._pusch = Pusch(self._core, self._base)
+			from .Pusch import PuschCls
+			self._pusch = PuschCls(self._core, self._cmd_group)
 		return self._pusch
 
 	def get_pucch(self) -> bool:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:MODulation:EEPeriods:PUCCh \n
-		Snippet: value: bool = driver.configure.multiEval.modulation.eePeriods.get_pucch() \n
+		Snippet: value: bool = driver.configure.lteMeas.multiEval.modulation.eePeriods.get_pucch() \n
 		Enables or disables EVM exclusion periods for slots with detected channel type 'PUCCH'. If enabled, the first and the
 		last SC-FDMA symbol of each slot is excluded from the calculation of EVM, magnitude error and phase error single value
 		results. If the last symbol of a slot is already excluded because SRS signals are allowed, the second but last symbol is
 		also excluded. \n
 			:return: pucch: No help available
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:MEValuation:MODulation:EEPeriods:PUCCh?')
 		return Conversions.str_to_bool(response)
 
 	def set_pucch(self, pucch: bool) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:MODulation:EEPeriods:PUCCh \n
-		Snippet: driver.configure.multiEval.modulation.eePeriods.set_pucch(pucch = False) \n
+		Snippet: driver.configure.lteMeas.multiEval.modulation.eePeriods.set_pucch(pucch = False) \n
 		Enables or disables EVM exclusion periods for slots with detected channel type 'PUCCH'. If enabled, the first and the
 		last SC-FDMA symbol of each slot is excluded from the calculation of EVM, magnitude error and phase error single value
 		results. If the last symbol of a slot is already excluded because SRS signals are allowed, the second but last symbol is
 		also excluded. \n
 			:param pucch: No help available
 		"""
 		param = Conversions.bool_to_str(pucch)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:MODulation:EEPeriods:PUCCh {param}')
 
-	def clone(self) -> 'EePeriods':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'EePeriodsCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = EePeriods(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = EePeriodsCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Modulation_/EePeriods_/Pusch.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Modulation/EePeriods/Pusch.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,57 +1,57 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal import Conversions
-from ...... import enums
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal import Conversions
+from ....... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Pusch:
-	"""Pusch commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class PuschCls:
+	"""Pusch commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("pusch", core, parent)
+		self._cmd_group = CommandsGroup("pusch", core, parent)
 
 	# noinspection PyTypeChecker
 	def get_leading(self) -> enums.LeadingExclPeriod:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:MODulation:EEPeriods:PUSCh:LEADing \n
-		Snippet: value: enums.LeadingExclPeriod = driver.configure.multiEval.modulation.eePeriods.pusch.get_leading() \n
+		Snippet: value: enums.LeadingExclPeriod = driver.configure.lteMeas.multiEval.modulation.eePeriods.pusch.get_leading() \n
 		Specifies an EVM exclusion period at the beginning of a subframe (detected channel type 'PUSCH') . The specified period
 		is excluded from the calculation of EVM, magnitude error and phase error results. \n
 			:return: leading: OFF: no exclusion MS25: 25 s excluded
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:MEValuation:MODulation:EEPeriods:PUSCh:LEADing?')
 		return Conversions.str_to_scalar_enum(response, enums.LeadingExclPeriod)
 
 	def set_leading(self, leading: enums.LeadingExclPeriod) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:MODulation:EEPeriods:PUSCh:LEADing \n
-		Snippet: driver.configure.multiEval.modulation.eePeriods.pusch.set_leading(leading = enums.LeadingExclPeriod.MS25) \n
+		Snippet: driver.configure.lteMeas.multiEval.modulation.eePeriods.pusch.set_leading(leading = enums.LeadingExclPeriod.MS25) \n
 		Specifies an EVM exclusion period at the beginning of a subframe (detected channel type 'PUSCH') . The specified period
 		is excluded from the calculation of EVM, magnitude error and phase error results. \n
 			:param leading: OFF: no exclusion MS25: 25 s excluded
 		"""
 		param = Conversions.enum_scalar_to_str(leading, enums.LeadingExclPeriod)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:MODulation:EEPeriods:PUSCh:LEADing {param}')
 
 	# noinspection PyTypeChecker
 	def get_lagging(self) -> enums.LaggingExclPeriod:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:MODulation:EEPeriods:PUSCh:LAGGing \n
-		Snippet: value: enums.LaggingExclPeriod = driver.configure.multiEval.modulation.eePeriods.pusch.get_lagging() \n
+		Snippet: value: enums.LaggingExclPeriod = driver.configure.lteMeas.multiEval.modulation.eePeriods.pusch.get_lagging() \n
 		Specifies an EVM exclusion period at the end of each subframe (detected channel type 'PUSCH') ; if SRS signals are
 		allowed, at the end of each shortened subframe. The specified period is excluded from the calculation of EVM, magnitude
 		error and phase error results. \n
 			:return: lagging: OFF: no exclusion MS05: 5 s excluded MS25: 25 s excluded
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:MEValuation:MODulation:EEPeriods:PUSCh:LAGGing?')
 		return Conversions.str_to_scalar_enum(response, enums.LaggingExclPeriod)
 
 	def set_lagging(self, lagging: enums.LaggingExclPeriod) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:MODulation:EEPeriods:PUSCh:LAGGing \n
-		Snippet: driver.configure.multiEval.modulation.eePeriods.pusch.set_lagging(lagging = enums.LaggingExclPeriod.MS05) \n
+		Snippet: driver.configure.lteMeas.multiEval.modulation.eePeriods.pusch.set_lagging(lagging = enums.LaggingExclPeriod.MS05) \n
 		Specifies an EVM exclusion period at the end of each subframe (detected channel type 'PUSCH') ; if SRS signals are
 		allowed, at the end of each shortened subframe. The specified period is excluded from the calculation of EVM, magnitude
 		error and phase error results. \n
 			:param lagging: OFF: no exclusion MS05: 5 s excluded MS25: 25 s excluded
 		"""
 		param = Conversions.enum_scalar_to_str(lagging, enums.LaggingExclPeriod)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:MODulation:EEPeriods:PUSCh:LAGGing {param}')
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Modulation_/EwLength.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Modulation/EwLength/__init__.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,62 +1,65 @@
 from typing import List
 
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
-from .....Internal.Types import DataType
-from .....Internal.StructBase import StructBase
-from .....Internal.ArgStruct import ArgStruct
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal.Types import DataType
+from .......Internal.StructBase import StructBase
+from .......Internal.ArgStruct import ArgStruct
+from .......Internal.ArgSingleList import ArgSingleList
+from .......Internal.ArgSingle import ArgSingle
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class EwLength:
-	"""EwLength commands group definition. 2 total commands, 1 Sub-groups, 1 group commands"""
+class EwLengthCls:
+	"""EwLength commands group definition. 2 total commands, 1 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("ewLength", core, parent)
+		self._cmd_group = CommandsGroup("ewLength", core, parent)
 
 	@property
 	def channelBw(self):
 		"""channelBw commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_channelBw'):
-			from .EwLength_.ChannelBw import ChannelBw
-			self._channelBw = ChannelBw(self._core, self._base)
+			from .ChannelBw import ChannelBwCls
+			self._channelBw = ChannelBwCls(self._core, self._cmd_group)
 		return self._channelBw
 
+	def set(self, length_cp_normal: List[int], length_cp_extended: List[int]) -> None:
+		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:MODulation:EWLength \n
+		Snippet: driver.configure.lteMeas.multiEval.modulation.ewLength.set(length_cp_normal = [1, 2, 3], length_cp_extended = [1, 2, 3]) \n
+		Specifies the EVM window length in samples for all channel bandwidths, depending on the cyclic prefix (CP) type. \n
+			:param length_cp_normal: No help available
+			:param length_cp_extended: No help available
+		"""
+		param = ArgSingleList().compose_cmd_string(ArgSingle('length_cp_normal', length_cp_normal, DataType.IntegerList, None, False, False, 6), ArgSingle('length_cp_extended', length_cp_extended, DataType.IntegerList, None, False, False, 6))
+		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:MODulation:EWLength {param}'.rstrip())
+
 	# noinspection PyTypeChecker
-	class ValueStruct(StructBase):
-		"""Structure for reading output parameters. Fields: \n
+	class EwLengthStruct(StructBase):
+		"""Response structure. Fields: \n
 			- Length_Cp_Normal: List[int]: No parameter help available
 			- Length_Cp_Extended: List[int]: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct('Length_Cp_Normal', DataType.IntegerList, None, False, False, 6),
 			ArgStruct('Length_Cp_Extended', DataType.IntegerList, None, False, False, 6)]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Length_Cp_Normal: List[int] = None
 			self.Length_Cp_Extended: List[int] = None
 
-	def get_value(self) -> ValueStruct:
+	def get(self) -> EwLengthStruct:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:MODulation:EWLength \n
-		Snippet: value: ValueStruct = driver.configure.multiEval.modulation.ewLength.get_value() \n
+		Snippet: value: EwLengthStruct = driver.configure.lteMeas.multiEval.modulation.ewLength.get() \n
 		Specifies the EVM window length in samples for all channel bandwidths, depending on the cyclic prefix (CP) type. \n
-			:return: structure: for return value, see the help for ValueStruct structure arguments.
-		"""
-		return self._core.io.query_struct('CONFigure:LTE:MEASurement<Instance>:MEValuation:MODulation:EWLength?', self.__class__.ValueStruct())
-
-	def set_value(self, value: ValueStruct) -> None:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:MODulation:EWLength \n
-		Snippet: driver.configure.multiEval.modulation.ewLength.set_value(value = ValueStruct()) \n
-		Specifies the EVM window length in samples for all channel bandwidths, depending on the cyclic prefix (CP) type. \n
-			:param value: see the help for ValueStruct structure arguments.
-		"""
-		self._core.io.write_struct('CONFigure:LTE:MEASurement<Instance>:MEValuation:MODulation:EWLength', value)
+			:return: structure: for return value, see the help for EwLengthStruct structure arguments."""
+		return self._core.io.query_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:MODulation:EWLength?', self.__class__.EwLengthStruct())
 
-	def clone(self) -> 'EwLength':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'EwLengthCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = EwLength(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = EwLengthCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/NsValue.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/NsValue.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,53 +1,53 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
-from ....Internal import Conversions
-from .... import enums
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
+from .....Internal import Conversions
+from ..... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class NsValue:
-	"""NsValue commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class NsValueCls:
+	"""NsValue commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("nsValue", core, parent)
+		self._cmd_group = CommandsGroup("nsValue", core, parent)
 
 	# noinspection PyTypeChecker
 	def get_carrier_aggregation(self) -> enums.NetworkSigValue:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:NSValue:CAGGregation \n
-		Snippet: value: enums.NetworkSigValue = driver.configure.multiEval.nsValue.get_carrier_aggregation() \n
+		Snippet: value: enums.NetworkSigValue = driver.configure.lteMeas.multiEval.nsValue.get_carrier_aggregation() \n
 		Selects the 'network signaled value' for measurements with carrier aggregation. \n
 			:return: value: Value CA_NS_01 to CA_NS_32
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:MEValuation:NSValue:CAGGregation?')
 		return Conversions.str_to_scalar_enum(response, enums.NetworkSigValue)
 
 	def set_carrier_aggregation(self, value: enums.NetworkSigValue) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:NSValue:CAGGregation \n
-		Snippet: driver.configure.multiEval.nsValue.set_carrier_aggregation(value = enums.NetworkSigValue.NS01) \n
+		Snippet: driver.configure.lteMeas.multiEval.nsValue.set_carrier_aggregation(value = enums.NetworkSigValue.NS01) \n
 		Selects the 'network signaled value' for measurements with carrier aggregation. \n
 			:param value: Value CA_NS_01 to CA_NS_32
 		"""
 		param = Conversions.enum_scalar_to_str(value, enums.NetworkSigValue)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:NSValue:CAGGregation {param}')
 
 	# noinspection PyTypeChecker
 	def get_value(self) -> enums.NetworkSigValueNoCarrAggr:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:NSValue \n
-		Snippet: value: enums.NetworkSigValueNoCarrAggr = driver.configure.multiEval.nsValue.get_value() \n
+		Snippet: value: enums.NetworkSigValueNoCarrAggr = driver.configure.lteMeas.multiEval.nsValue.get_value() \n
 		Selects the 'network signaled value' for measurements without carrier aggregation. For Signal Path = Network, the setting
 		is not configurable. \n
 			:return: value: Value NS_01 to NS_288
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:MEValuation:NSValue?')
 		return Conversions.str_to_scalar_enum(response, enums.NetworkSigValueNoCarrAggr)
 
 	def set_value(self, value: enums.NetworkSigValueNoCarrAggr) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:NSValue \n
-		Snippet: driver.configure.multiEval.nsValue.set_value(value = enums.NetworkSigValueNoCarrAggr.NS01) \n
+		Snippet: driver.configure.lteMeas.multiEval.nsValue.set_value(value = enums.NetworkSigValueNoCarrAggr.NS01) \n
 		Selects the 'network signaled value' for measurements without carrier aggregation. For Signal Path = Network, the setting
 		is not configurable. \n
 			:param value: Value NS_01 to NS_288
 		"""
 		param = Conversions.enum_scalar_to_str(value, enums.NetworkSigValueNoCarrAggr)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:NSValue {param}')
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Pcc.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Pcc.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,30 +1,30 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
-from ....Internal import Conversions
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
+from .....Internal import Conversions
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Pcc:
-	"""Pcc commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class PccCls:
+	"""Pcc commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("pcc", core, parent)
+		self._cmd_group = CommandsGroup("pcc", core, parent)
 
 	def get_plc_id(self) -> int:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation[:PCC]:PLCid \n
-		Snippet: value: int = driver.configure.multiEval.pcc.get_plc_id() \n
+		Snippet: value: int = driver.configure.lteMeas.multiEval.pcc.get_plc_id() \n
 		No command help available \n
 			:return: phs_layer_cell_id: No help available
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:MEValuation:PCC:PLCid?')
 		return Conversions.str_to_int(response)
 
 	def set_plc_id(self, phs_layer_cell_id: int) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation[:PCC]:PLCid \n
-		Snippet: driver.configure.multiEval.pcc.set_plc_id(phs_layer_cell_id = 1) \n
+		Snippet: driver.configure.lteMeas.multiEval.pcc.set_plc_id(phs_layer_cell_id = 1) \n
 		No command help available \n
 			:param phs_layer_cell_id: No help available
 		"""
 		param = Conversions.decimal_value_to_str(phs_layer_cell_id)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:PCC:PLCid {param}')
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Pdynamics.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Pdynamics/__init__.py`

 * *Files 23% similar despite different names*

```diff
@@ -1,48 +1,48 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
-from ....Internal import Conversions
-from .... import enums
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal import Conversions
+from ...... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Pdynamics:
-	"""Pdynamics commands group definition. 3 total commands, 1 Sub-groups, 1 group commands"""
+class PdynamicsCls:
+	"""Pdynamics commands group definition. 3 total commands, 1 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("pdynamics", core, parent)
+		self._cmd_group = CommandsGroup("pdynamics", core, parent)
 
 	@property
 	def aeoPower(self):
 		"""aeoPower commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_aeoPower'):
-			from .Pdynamics_.AeoPower import AeoPower
-			self._aeoPower = AeoPower(self._core, self._base)
+			from .AeoPower import AeoPowerCls
+			self._aeoPower = AeoPowerCls(self._core, self._cmd_group)
 		return self._aeoPower
 
 	# noinspection PyTypeChecker
 	def get_tmask(self) -> enums.TimeMask:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:PDYNamics:TMASk \n
-		Snippet: value: enums.TimeMask = driver.configure.multiEval.pdynamics.get_tmask() \n
+		Snippet: value: enums.TimeMask = driver.configure.lteMeas.multiEval.pdynamics.get_tmask() \n
 		Selects the time mask for power dynamics measurements. \n
-			:return: time_mask: GOO: General ON/OFF time mask PPSRs: PUCCH/PUSCH transmission before and after an SRS SBLanking: SRS blanking time mask
+			:return: time_mask: GOO: General time mask PPSRs: PUCCH/PUSCH transmission before and after an SRS SBLanking: SRS blanking time mask
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:MEValuation:PDYNamics:TMASk?')
 		return Conversions.str_to_scalar_enum(response, enums.TimeMask)
 
 	def set_tmask(self, time_mask: enums.TimeMask) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:PDYNamics:TMASk \n
-		Snippet: driver.configure.multiEval.pdynamics.set_tmask(time_mask = enums.TimeMask.GOO) \n
+		Snippet: driver.configure.lteMeas.multiEval.pdynamics.set_tmask(time_mask = enums.TimeMask.GOO) \n
 		Selects the time mask for power dynamics measurements. \n
-			:param time_mask: GOO: General ON/OFF time mask PPSRs: PUCCH/PUSCH transmission before and after an SRS SBLanking: SRS blanking time mask
+			:param time_mask: GOO: General time mask PPSRs: PUCCH/PUSCH transmission before and after an SRS SBLanking: SRS blanking time mask
 		"""
 		param = Conversions.enum_scalar_to_str(time_mask, enums.TimeMask)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:PDYNamics:TMASk {param}')
 
-	def clone(self) -> 'Pdynamics':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'PdynamicsCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Pdynamics(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = PdynamicsCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Pdynamics_/AeoPower.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Pdynamics/AeoPower.py`

 * *Files 11% similar despite different names*

```diff
@@ -1,48 +1,48 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
-from .....Internal import Conversions
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal import Conversions
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class AeoPower:
-	"""AeoPower commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class AeoPowerCls:
+	"""AeoPower commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("aeoPower", core, parent)
+		self._cmd_group = CommandsGroup("aeoPower", core, parent)
 
 	def get_leading(self) -> int:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:PDYNamics:AEOPower:LEADing \n
-		Snippet: value: int = driver.configure.multiEval.pdynamics.aeoPower.get_leading() \n
+		Snippet: value: int = driver.configure.lteMeas.multiEval.pdynamics.aeoPower.get_leading() \n
 		Shifts the beginning of the evaluation period for OFF power measurements. \n
 			:return: leading: Positive values reduce the evaluation period (starts later) . Negative values increase the evaluation period (starts earlier) .
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:MEValuation:PDYNamics:AEOPower:LEADing?')
 		return Conversions.str_to_int(response)
 
 	def set_leading(self, leading: int) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:PDYNamics:AEOPower:LEADing \n
-		Snippet: driver.configure.multiEval.pdynamics.aeoPower.set_leading(leading = 1) \n
+		Snippet: driver.configure.lteMeas.multiEval.pdynamics.aeoPower.set_leading(leading = 1) \n
 		Shifts the beginning of the evaluation period for OFF power measurements. \n
 			:param leading: Positive values reduce the evaluation period (starts later) . Negative values increase the evaluation period (starts earlier) .
 		"""
 		param = Conversions.decimal_value_to_str(leading)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:PDYNamics:AEOPower:LEADing {param}')
 
 	def get_lagging(self) -> int:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:PDYNamics:AEOPower:LAGGing \n
-		Snippet: value: int = driver.configure.multiEval.pdynamics.aeoPower.get_lagging() \n
+		Snippet: value: int = driver.configure.lteMeas.multiEval.pdynamics.aeoPower.get_lagging() \n
 		Shifts the end of the evaluation period for OFF power measurements. \n
 			:return: lagging: Positive values reduce the evaluation period (ends earlier) . Negative values increase the evaluation period (ends later) .
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:MEValuation:PDYNamics:AEOPower:LAGGing?')
 		return Conversions.str_to_int(response)
 
 	def set_lagging(self, lagging: int) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:PDYNamics:AEOPower:LAGGing \n
-		Snippet: driver.configure.multiEval.pdynamics.aeoPower.set_lagging(lagging = 1) \n
+		Snippet: driver.configure.lteMeas.multiEval.pdynamics.aeoPower.set_lagging(lagging = 1) \n
 		Shifts the end of the evaluation period for OFF power measurements. \n
 			:param lagging: Positive values reduce the evaluation period (ends earlier) . Negative values increase the evaluation period (ends later) .
 		"""
 		param = Conversions.decimal_value_to_str(lagging)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:PDYNamics:AEOPower:LAGGing {param}')
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Power.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Power.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,32 +1,30 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
-from ....Internal import Conversions
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
+from .....Internal import Conversions
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Power:
-	"""Power commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class PowerCls:
+	"""Power commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("power", core, parent)
+		self._cmd_group = CommandsGroup("power", core, parent)
 
 	def get_hdmode(self) -> bool:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:POWer:HDMode \n
-		Snippet: value: bool = driver.configure.multiEval.power.get_hdmode() \n
-		Enables or disables the high dynamic mode for power dynamics measurements. For Signal Path = Network, the setting is not
-		configurable. \n
+		Snippet: value: bool = driver.configure.lteMeas.multiEval.power.get_hdmode() \n
+		Enables or disables the high dynamic mode for power dynamics measurements. \n
 			:return: high_dynamic_mode: No help available
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:MEValuation:POWer:HDMode?')
 		return Conversions.str_to_bool(response)
 
 	def set_hdmode(self, high_dynamic_mode: bool) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:POWer:HDMode \n
-		Snippet: driver.configure.multiEval.power.set_hdmode(high_dynamic_mode = False) \n
-		Enables or disables the high dynamic mode for power dynamics measurements. For Signal Path = Network, the setting is not
-		configurable. \n
+		Snippet: driver.configure.lteMeas.multiEval.power.set_hdmode(high_dynamic_mode = False) \n
+		Enables or disables the high dynamic mode for power dynamics measurements. \n
 			:param high_dynamic_mode: No help available
 		"""
 		param = Conversions.bool_to_str(high_dynamic_mode)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:POWer:HDMode {param}')
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/RbAllocation.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/RbAllocation/__init__.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,62 +1,62 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
-from ....Internal import Conversions
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal import Conversions
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class RbAllocation:
-	"""RbAllocation commands group definition. 10 total commands, 3 Sub-groups, 1 group commands"""
+class RbAllocationCls:
+	"""RbAllocation commands group definition. 10 total commands, 3 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("rbAllocation", core, parent)
+		self._cmd_group = CommandsGroup("rbAllocation", core, parent)
 
 	@property
 	def nrb(self):
 		"""nrb commands group. 0 Sub-classes, 3 commands."""
 		if not hasattr(self, '_nrb'):
-			from .RbAllocation_.Nrb import Nrb
-			self._nrb = Nrb(self._core, self._base)
+			from .Nrb import NrbCls
+			self._nrb = NrbCls(self._core, self._cmd_group)
 		return self._nrb
 
 	@property
 	def mcluster(self):
 		"""mcluster commands group. 2 Sub-classes, 1 commands."""
 		if not hasattr(self, '_mcluster'):
-			from .RbAllocation_.Mcluster import Mcluster
-			self._mcluster = Mcluster(self._core, self._base)
+			from .Mcluster import MclusterCls
+			self._mcluster = MclusterCls(self._core, self._cmd_group)
 		return self._mcluster
 
 	@property
 	def orb(self):
 		"""orb commands group. 0 Sub-classes, 3 commands."""
 		if not hasattr(self, '_orb'):
-			from .RbAllocation_.Orb import Orb
-			self._orb = Orb(self._core, self._base)
+			from .Orb import OrbCls
+			self._orb = OrbCls(self._core, self._cmd_group)
 		return self._orb
 
 	def get_auto(self) -> bool:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:RBALlocation:AUTO \n
-		Snippet: value: bool = driver.configure.multiEval.rbAllocation.get_auto() \n
+		Snippet: value: bool = driver.configure.lteMeas.multiEval.rbAllocation.get_auto() \n
 		Enables or disables the automatic detection of the RB configuration. \n
 			:return: auto: OFF: manual definition ON: automatic detection
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:MEValuation:RBALlocation:AUTO?')
 		return Conversions.str_to_bool(response)
 
 	def set_auto(self, auto: bool) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:RBALlocation:AUTO \n
-		Snippet: driver.configure.multiEval.rbAllocation.set_auto(auto = False) \n
+		Snippet: driver.configure.lteMeas.multiEval.rbAllocation.set_auto(auto = False) \n
 		Enables or disables the automatic detection of the RB configuration. \n
 			:param auto: OFF: manual definition ON: automatic detection
 		"""
 		param = Conversions.bool_to_str(auto)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:RBALlocation:AUTO {param}')
 
-	def clone(self) -> 'RbAllocation':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'RbAllocationCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = RbAllocation(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = RbAllocationCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/RbAllocation_/Mcluster.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/RbAllocation/Mcluster/__init__.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,54 +1,54 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
-from .....Internal import Conversions
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal import Conversions
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Mcluster:
-	"""Mcluster commands group definition. 3 total commands, 2 Sub-groups, 1 group commands"""
+class MclusterCls:
+	"""Mcluster commands group definition. 3 total commands, 2 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("mcluster", core, parent)
+		self._cmd_group = CommandsGroup("mcluster", core, parent)
 
 	@property
 	def nrb(self):
 		"""nrb commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_nrb'):
-			from .Mcluster_.Nrb import Nrb
-			self._nrb = Nrb(self._core, self._base)
+			from .Nrb import NrbCls
+			self._nrb = NrbCls(self._core, self._cmd_group)
 		return self._nrb
 
 	@property
 	def orb(self):
 		"""orb commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_orb'):
-			from .Mcluster_.Orb import Orb
-			self._orb = Orb(self._core, self._base)
+			from .Orb import OrbCls
+			self._orb = OrbCls(self._core, self._cmd_group)
 		return self._orb
 
 	def get_value(self) -> bool:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:RBALlocation:MCLuster \n
-		Snippet: value: bool = driver.configure.multiEval.rbAllocation.mcluster.get_value() \n
+		Snippet: value: bool = driver.configure.lteMeas.multiEval.rbAllocation.mcluster.get_value() \n
 		Specifies whether the UL signal uses multi-cluster allocation or not. \n
 			:return: enable: OFF: contiguous allocation, resource allocation type 0 ON: multi-cluster allocation, resource allocation type 1
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:MEValuation:RBALlocation:MCLuster?')
 		return Conversions.str_to_bool(response)
 
 	def set_value(self, enable: bool) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:RBALlocation:MCLuster \n
-		Snippet: driver.configure.multiEval.rbAllocation.mcluster.set_value(enable = False) \n
+		Snippet: driver.configure.lteMeas.multiEval.rbAllocation.mcluster.set_value(enable = False) \n
 		Specifies whether the UL signal uses multi-cluster allocation or not. \n
 			:param enable: OFF: contiguous allocation, resource allocation type 0 ON: multi-cluster allocation, resource allocation type 1
 		"""
 		param = Conversions.bool_to_str(enable)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:RBALlocation:MCLuster {param}')
 
-	def clone(self) -> 'Mcluster':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'MclusterCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Mcluster(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = MclusterCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/RbAllocation_/Mcluster_/Nrb.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/RbAllocation/Mcluster/Nrb.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,55 +1,56 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal import Conversions
-from ......Internal.RepeatedCapability import RepeatedCapability
-from ...... import repcap
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal import Conversions
+from .......Internal.RepeatedCapability import RepeatedCapability
+from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Nrb:
-	"""Nrb commands group definition. 1 total commands, 0 Sub-groups, 1 group commands
+class NrbCls:
+	"""Nrb commands group definition. 1 total commands, 0 Subgroups, 1 group commands
 	Repeated Capability: RBcount, default value after init: RBcount.Nr1"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("nrb", core, parent)
-		self._base.rep_cap = RepeatedCapability(self._base.group_name, 'repcap_rBcount_get', 'repcap_rBcount_set', repcap.RBcount.Nr1)
+		self._cmd_group = CommandsGroup("nrb", core, parent)
+		self._cmd_group.rep_cap = RepeatedCapability(self._cmd_group.group_name, 'repcap_rBcount_get', 'repcap_rBcount_set', repcap.RBcount.Nr1)
 
-	def repcap_rBcount_set(self, enum_value: repcap.RBcount) -> None:
+	def repcap_rBcount_set(self, rBcount: repcap.RBcount) -> None:
 		"""Repeated Capability default value numeric suffix.
 		This value is used, if you do not explicitely set it in the child set/get methods, or if you leave it to RBcount.Default
 		Default value after init: RBcount.Nr1"""
-		self._base.set_repcap_enum_value(enum_value)
+		self._cmd_group.set_repcap_enum_value(rBcount)
 
 	def repcap_rBcount_get(self) -> repcap.RBcount:
 		"""Returns the current default repeated capability for the child set/get methods"""
 		# noinspection PyTypeChecker
-		return self._base.get_repcap_enum_value()
+		return self._cmd_group.get_repcap_enum_value()
 
 	def set(self, no_rb: int, rBcount=repcap.RBcount.Default) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:RBALlocation:MCLuster:NRB<Number> \n
-		Snippet: driver.configure.multiEval.rbAllocation.mcluster.nrb.set(no_rb = 1, rBcount = repcap.RBcount.Default) \n
+		Snippet: driver.configure.lteMeas.multiEval.rbAllocation.mcluster.nrb.set(no_rb = 1, rBcount = repcap.RBcount.Default) \n
 		Specifies the number of allocated RBs in the measured slot, for multi-cluster allocation. \n
-			:param no_rb: For the allowed input ranges, see 'Uplink Resource Block Allocation'.
-			:param rBcount: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Nrb')"""
+			:param no_rb: For the allowed input ranges, see 'Uplink resource block allocation'.
+			:param rBcount: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Nrb')
+		"""
 		param = Conversions.decimal_value_to_str(no_rb)
-		rBcount_cmd_val = self._base.get_repcap_cmd_value(rBcount, repcap.RBcount)
+		rBcount_cmd_val = self._cmd_group.get_repcap_cmd_value(rBcount, repcap.RBcount)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:RBALlocation:MCLuster:NRB{rBcount_cmd_val} {param}')
 
 	def get(self, rBcount=repcap.RBcount.Default) -> int:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:RBALlocation:MCLuster:NRB<Number> \n
-		Snippet: value: int = driver.configure.multiEval.rbAllocation.mcluster.nrb.get(rBcount = repcap.RBcount.Default) \n
+		Snippet: value: int = driver.configure.lteMeas.multiEval.rbAllocation.mcluster.nrb.get(rBcount = repcap.RBcount.Default) \n
 		Specifies the number of allocated RBs in the measured slot, for multi-cluster allocation. \n
 			:param rBcount: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Nrb')
-			:return: no_rb: For the allowed input ranges, see 'Uplink Resource Block Allocation'."""
-		rBcount_cmd_val = self._base.get_repcap_cmd_value(rBcount, repcap.RBcount)
+			:return: no_rb: For the allowed input ranges, see 'Uplink resource block allocation'."""
+		rBcount_cmd_val = self._cmd_group.get_repcap_cmd_value(rBcount, repcap.RBcount)
 		response = self._core.io.query_str(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:RBALlocation:MCLuster:NRB{rBcount_cmd_val}?')
 		return Conversions.str_to_int(response)
 
-	def clone(self) -> 'Nrb':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'NrbCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Nrb(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = NrbCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/RbAllocation_/Mcluster_/Orb.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/RbAllocation/Mcluster/Orb.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,55 +1,56 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal import Conversions
-from ......Internal.RepeatedCapability import RepeatedCapability
-from ...... import repcap
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal import Conversions
+from .......Internal.RepeatedCapability import RepeatedCapability
+from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Orb:
-	"""Orb commands group definition. 1 total commands, 0 Sub-groups, 1 group commands
+class OrbCls:
+	"""Orb commands group definition. 1 total commands, 0 Subgroups, 1 group commands
 	Repeated Capability: RBoffset, default value after init: RBoffset.Nr1"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("orb", core, parent)
-		self._base.rep_cap = RepeatedCapability(self._base.group_name, 'repcap_rBoffset_get', 'repcap_rBoffset_set', repcap.RBoffset.Nr1)
+		self._cmd_group = CommandsGroup("orb", core, parent)
+		self._cmd_group.rep_cap = RepeatedCapability(self._cmd_group.group_name, 'repcap_rBoffset_get', 'repcap_rBoffset_set', repcap.RBoffset.Nr1)
 
-	def repcap_rBoffset_set(self, enum_value: repcap.RBoffset) -> None:
+	def repcap_rBoffset_set(self, rBoffset: repcap.RBoffset) -> None:
 		"""Repeated Capability default value numeric suffix.
 		This value is used, if you do not explicitely set it in the child set/get methods, or if you leave it to RBoffset.Default
 		Default value after init: RBoffset.Nr1"""
-		self._base.set_repcap_enum_value(enum_value)
+		self._cmd_group.set_repcap_enum_value(rBoffset)
 
 	def repcap_rBoffset_get(self) -> repcap.RBoffset:
 		"""Returns the current default repeated capability for the child set/get methods"""
 		# noinspection PyTypeChecker
-		return self._base.get_repcap_enum_value()
+		return self._cmd_group.get_repcap_enum_value()
 
 	def set(self, offset_rb: int, rBoffset=repcap.RBoffset.Default) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:RBALlocation:MCLuster:ORB<Number> \n
-		Snippet: driver.configure.multiEval.rbAllocation.mcluster.orb.set(offset_rb = 1, rBoffset = repcap.RBoffset.Default) \n
+		Snippet: driver.configure.lteMeas.multiEval.rbAllocation.mcluster.orb.set(offset_rb = 1, rBoffset = repcap.RBoffset.Default) \n
 		Specifies the offset of the first allocated resource block, for multi-cluster allocation. \n
-			:param offset_rb: For the allowed input ranges, see 'Uplink Resource Block Allocation'.
-			:param rBoffset: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Orb')"""
+			:param offset_rb: For the allowed input ranges, see 'Uplink resource block allocation'.
+			:param rBoffset: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Orb')
+		"""
 		param = Conversions.decimal_value_to_str(offset_rb)
-		rBoffset_cmd_val = self._base.get_repcap_cmd_value(rBoffset, repcap.RBoffset)
+		rBoffset_cmd_val = self._cmd_group.get_repcap_cmd_value(rBoffset, repcap.RBoffset)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:RBALlocation:MCLuster:ORB{rBoffset_cmd_val} {param}')
 
 	def get(self, rBoffset=repcap.RBoffset.Default) -> int:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:RBALlocation:MCLuster:ORB<Number> \n
-		Snippet: value: int = driver.configure.multiEval.rbAllocation.mcluster.orb.get(rBoffset = repcap.RBoffset.Default) \n
+		Snippet: value: int = driver.configure.lteMeas.multiEval.rbAllocation.mcluster.orb.get(rBoffset = repcap.RBoffset.Default) \n
 		Specifies the offset of the first allocated resource block, for multi-cluster allocation. \n
 			:param rBoffset: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Orb')
-			:return: offset_rb: For the allowed input ranges, see 'Uplink Resource Block Allocation'."""
-		rBoffset_cmd_val = self._base.get_repcap_cmd_value(rBoffset, repcap.RBoffset)
+			:return: offset_rb: For the allowed input ranges, see 'Uplink resource block allocation'."""
+		rBoffset_cmd_val = self._cmd_group.get_repcap_cmd_value(rBoffset, repcap.RBoffset)
 		response = self._core.io.query_str(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:RBALlocation:MCLuster:ORB{rBoffset_cmd_val}?')
 		return Conversions.str_to_int(response)
 
-	def clone(self) -> 'Orb':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'OrbCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Orb(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = OrbCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/RbAllocation_/Nrb.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/RbAllocation/Nrb.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,72 +1,72 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
-from .....Internal import Conversions
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal import Conversions
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Nrb:
-	"""Nrb commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class NrbCls:
+	"""Nrb commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("nrb", core, parent)
+		self._cmd_group = CommandsGroup("nrb", core, parent)
 
 	def get_pscch(self) -> int:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:RBALlocation:NRB:PSCCh \n
-		Snippet: value: int = driver.configure.multiEval.rbAllocation.nrb.get_pscch() \n
+		Snippet: value: int = driver.configure.lteMeas.multiEval.rbAllocation.nrb.get_pscch() \n
 		Specifies the number of allocated RBs for the PSCCH in the measured slot. For manual RB allocation definition, for
 		sidelink signals. \n
 			:return: no_rb: The value is fixed.
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:MEValuation:RBALlocation:NRB:PSCCh?')
 		return Conversions.str_to_int(response)
 
 	def set_pscch(self, no_rb: int) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:RBALlocation:NRB:PSCCh \n
-		Snippet: driver.configure.multiEval.rbAllocation.nrb.set_pscch(no_rb = 1) \n
+		Snippet: driver.configure.lteMeas.multiEval.rbAllocation.nrb.set_pscch(no_rb = 1) \n
 		Specifies the number of allocated RBs for the PSCCH in the measured slot. For manual RB allocation definition, for
 		sidelink signals. \n
 			:param no_rb: The value is fixed.
 		"""
 		param = Conversions.decimal_value_to_str(no_rb)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:RBALlocation:NRB:PSCCh {param}')
 
 	def get_pssch(self) -> int:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:RBALlocation:NRB:PSSCh \n
-		Snippet: value: int = driver.configure.multiEval.rbAllocation.nrb.get_pssch() \n
+		Snippet: value: int = driver.configure.lteMeas.multiEval.rbAllocation.nrb.get_pssch() \n
 		Specifies the number of allocated RBs for the PSSCH in the measured slot. For manual RB allocation definition, for
 		sidelink signals. \n
-			:return: no_rb: For the allowed input range, see 'Sidelink Resource Block Allocation'.
+			:return: no_rb: For the allowed input range, see 'Sidelink resource block allocation'.
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:MEValuation:RBALlocation:NRB:PSSCh?')
 		return Conversions.str_to_int(response)
 
 	def set_pssch(self, no_rb: int) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:RBALlocation:NRB:PSSCh \n
-		Snippet: driver.configure.multiEval.rbAllocation.nrb.set_pssch(no_rb = 1) \n
+		Snippet: driver.configure.lteMeas.multiEval.rbAllocation.nrb.set_pssch(no_rb = 1) \n
 		Specifies the number of allocated RBs for the PSSCH in the measured slot. For manual RB allocation definition, for
 		sidelink signals. \n
-			:param no_rb: For the allowed input range, see 'Sidelink Resource Block Allocation'.
+			:param no_rb: For the allowed input range, see 'Sidelink resource block allocation'.
 		"""
 		param = Conversions.decimal_value_to_str(no_rb)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:RBALlocation:NRB:PSSCh {param}')
 
 	def get_value(self) -> int:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:RBALlocation:NRB \n
-		Snippet: value: int = driver.configure.multiEval.rbAllocation.nrb.get_value() \n
+		Snippet: value: int = driver.configure.lteMeas.multiEval.rbAllocation.nrb.get_value() \n
 		Specifies the number of allocated RBs in the measured slot. For manual RB allocation definition, for uplink signals
 		without multi-cluster allocation. \n
-			:return: no_rb: For the allowed input range, see 'Uplink Resource Block Allocation'.
+			:return: no_rb: For the allowed input range, see 'Uplink resource block allocation'.
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:MEValuation:RBALlocation:NRB?')
 		return Conversions.str_to_int(response)
 
 	def set_value(self, no_rb: int) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:RBALlocation:NRB \n
-		Snippet: driver.configure.multiEval.rbAllocation.nrb.set_value(no_rb = 1) \n
+		Snippet: driver.configure.lteMeas.multiEval.rbAllocation.nrb.set_value(no_rb = 1) \n
 		Specifies the number of allocated RBs in the measured slot. For manual RB allocation definition, for uplink signals
 		without multi-cluster allocation. \n
-			:param no_rb: For the allowed input range, see 'Uplink Resource Block Allocation'.
+			:param no_rb: For the allowed input range, see 'Uplink resource block allocation'.
 		"""
 		param = Conversions.decimal_value_to_str(no_rb)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:RBALlocation:NRB {param}')
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/RbAllocation_/Orb.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/RbAllocation/Orb.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,72 +1,72 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
-from .....Internal import Conversions
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal import Conversions
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Orb:
-	"""Orb commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class OrbCls:
+	"""Orb commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("orb", core, parent)
+		self._cmd_group = CommandsGroup("orb", core, parent)
 
 	def get_pscch(self) -> int:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:RBALlocation:ORB:PSCCh \n
-		Snippet: value: int = driver.configure.multiEval.rbAllocation.orb.get_pscch() \n
+		Snippet: value: int = driver.configure.lteMeas.multiEval.rbAllocation.orb.get_pscch() \n
 		Specifies the offset of the first allocated PSCCH resource block for manual RB allocation definition, for sidelink
 		signals. \n
-			:return: offset_rb: For the maximum number of RBs depending on the channel BW, see 'Uplink Resource Block Allocation'.
+			:return: offset_rb: For the maximum number of RBs depending on the channel BW, see 'Uplink resource block allocation'.
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:MEValuation:RBALlocation:ORB:PSCCh?')
 		return Conversions.str_to_int(response)
 
 	def set_pscch(self, offset_rb: int) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:RBALlocation:ORB:PSCCh \n
-		Snippet: driver.configure.multiEval.rbAllocation.orb.set_pscch(offset_rb = 1) \n
+		Snippet: driver.configure.lteMeas.multiEval.rbAllocation.orb.set_pscch(offset_rb = 1) \n
 		Specifies the offset of the first allocated PSCCH resource block for manual RB allocation definition, for sidelink
 		signals. \n
-			:param offset_rb: For the maximum number of RBs depending on the channel BW, see 'Uplink Resource Block Allocation'.
+			:param offset_rb: For the maximum number of RBs depending on the channel BW, see 'Uplink resource block allocation'.
 		"""
 		param = Conversions.decimal_value_to_str(offset_rb)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:RBALlocation:ORB:PSCCh {param}')
 
 	def get_pssch(self) -> int:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:RBALlocation:ORB:PSSCh \n
-		Snippet: value: int = driver.configure.multiEval.rbAllocation.orb.get_pssch() \n
+		Snippet: value: int = driver.configure.lteMeas.multiEval.rbAllocation.orb.get_pssch() \n
 		Specifies the offset of the first allocated PSSCH resource block for manual RB allocation definition, for sidelink
 		signals. \n
-			:return: offset_rb: The range depends on the OffsetRB for the PSCCH, the channel BW and the number of allocated PSSCH RBs, see 'Sidelink Resource Block Allocation'.
+			:return: offset_rb: The range depends on the OffsetRB for the PSCCH, the channel BW and the number of allocated PSSCH RBs, see 'Sidelink resource block allocation'.
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:MEValuation:RBALlocation:ORB:PSSCh?')
 		return Conversions.str_to_int(response)
 
 	def set_pssch(self, offset_rb: int) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:RBALlocation:ORB:PSSCh \n
-		Snippet: driver.configure.multiEval.rbAllocation.orb.set_pssch(offset_rb = 1) \n
+		Snippet: driver.configure.lteMeas.multiEval.rbAllocation.orb.set_pssch(offset_rb = 1) \n
 		Specifies the offset of the first allocated PSSCH resource block for manual RB allocation definition, for sidelink
 		signals. \n
-			:param offset_rb: The range depends on the OffsetRB for the PSCCH, the channel BW and the number of allocated PSSCH RBs, see 'Sidelink Resource Block Allocation'.
+			:param offset_rb: The range depends on the OffsetRB for the PSCCH, the channel BW and the number of allocated PSSCH RBs, see 'Sidelink resource block allocation'.
 		"""
 		param = Conversions.decimal_value_to_str(offset_rb)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:RBALlocation:ORB:PSSCh {param}')
 
 	def get_value(self) -> int:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:RBALlocation:ORB \n
-		Snippet: value: int = driver.configure.multiEval.rbAllocation.orb.get_value() \n
+		Snippet: value: int = driver.configure.lteMeas.multiEval.rbAllocation.orb.get_value() \n
 		Specifies the offset of the first allocated resource block for manual RB allocation definition, for uplink signals
 		without multi-cluster allocation. \n
-			:return: offset_rb: For the maximum number of RBs depending on the channel BW, see 'Uplink Resource Block Allocation'.
+			:return: offset_rb: For the maximum number of RBs depending on the channel BW, see 'Uplink resource block allocation'.
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:MEValuation:RBALlocation:ORB?')
 		return Conversions.str_to_int(response)
 
 	def set_value(self, offset_rb: int) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:RBALlocation:ORB \n
-		Snippet: driver.configure.multiEval.rbAllocation.orb.set_value(offset_rb = 1) \n
+		Snippet: driver.configure.lteMeas.multiEval.rbAllocation.orb.set_value(offset_rb = 1) \n
 		Specifies the offset of the first allocated resource block for manual RB allocation definition, for uplink signals
 		without multi-cluster allocation. \n
-			:param offset_rb: For the maximum number of RBs depending on the channel BW, see 'Uplink Resource Block Allocation'.
+			:param offset_rb: For the maximum number of RBs depending on the channel BW, see 'Uplink resource block allocation'.
 		"""
 		param = Conversions.decimal_value_to_str(offset_rb)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:RBALlocation:ORB {param}')
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Result.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Result/__init__.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,62 +1,62 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
-from ....Internal import Conversions
-from ....Internal.StructBase import StructBase
-from ....Internal.ArgStruct import ArgStruct
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal import Conversions
+from ......Internal.StructBase import StructBase
+from ......Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Result:
-	"""Result commands group definition. 16 total commands, 1 Sub-groups, 14 group commands"""
+class ResultCls:
+	"""Result commands group definition. 16 total commands, 1 Subgroups, 14 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("result", core, parent)
+		self._cmd_group = CommandsGroup("result", core, parent)
 
 	@property
 	def evMagnitude(self):
-		"""evMagnitude commands group. 0 Sub-classes, 2 commands."""
+		"""evMagnitude commands group. 1 Sub-classes, 1 commands."""
 		if not hasattr(self, '_evMagnitude'):
-			from .Result_.EvMagnitude import EvMagnitude
-			self._evMagnitude = EvMagnitude(self._core, self._base)
+			from .EvMagnitude import EvMagnitudeCls
+			self._evMagnitude = EvMagnitudeCls(self._core, self._cmd_group)
 		return self._evMagnitude
 
 	# noinspection PyTypeChecker
-	class AllStruct(StructBase):
-		"""Structure for reading output parameters. Fields: \n
-			- Evm: bool: Error vector magnitude OFF: Do not evaluate results ON: Evaluate results
+	class AllStruct(StructBase):  # From WriteStructDefinition CmdPropertyTemplate.xml
+		"""Structure for setting input parameters. Contains optional set arguments. Fields: \n
+			- Evm: bool: Error vector magnitude OFF: Do not evaluate the results. ON: Evaluate the results.
 			- Magnitude_Error: bool: No parameter help available
 			- Phase_Error: bool: No parameter help available
 			- Inband_Emissions: bool: No parameter help available
 			- Evm_Versus_C: bool: EVM vs subcarrier
 			- Iq: bool: I/Q constellation diagram
 			- Equ_Spec_Flatness: bool: Equalizer spectrum flatness
 			- Tx_Measurement: bool: TX measurement statistical overview
 			- Spec_Em_Mask: bool: Spectrum emission mask
 			- Aclr: bool: Adjacent channel leakage power ratio
-			- Rb_Alloc_Table: bool: Resource block allocation table
+			- Rb_Alloc_Table: bool: Optional setting parameter. Resource block allocation table
 			- Power_Monitor: bool: No parameter help available
-			- Bler: bool: Block error ratio
+			- Bler: bool: Optional setting parameter. Not supported
 			- Power_Dynamics: bool: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_bool('Evm'),
 			ArgStruct.scalar_bool('Magnitude_Error'),
 			ArgStruct.scalar_bool('Phase_Error'),
 			ArgStruct.scalar_bool('Inband_Emissions'),
 			ArgStruct.scalar_bool('Evm_Versus_C'),
 			ArgStruct.scalar_bool('Iq'),
 			ArgStruct.scalar_bool('Equ_Spec_Flatness'),
 			ArgStruct.scalar_bool('Tx_Measurement'),
 			ArgStruct.scalar_bool('Spec_Em_Mask'),
 			ArgStruct.scalar_bool('Aclr'),
-			ArgStruct.scalar_bool('Rb_Alloc_Table'),
-			ArgStruct.scalar_bool('Power_Monitor'),
-			ArgStruct.scalar_bool('Bler'),
-			ArgStruct.scalar_bool('Power_Dynamics')]
+			ArgStruct.scalar_bool_optional('Rb_Alloc_Table'),
+			ArgStruct.scalar_bool_optional('Power_Monitor'),
+			ArgStruct.scalar_bool_optional('Bler'),
+			ArgStruct.scalar_bool_optional('Power_Dynamics')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Evm: bool = None
 			self.Magnitude_Error: bool = None
 			self.Phase_Error: bool = None
 			self.Inband_Emissions: bool = None
@@ -69,648 +69,664 @@
 			self.Rb_Alloc_Table: bool = None
 			self.Power_Monitor: bool = None
 			self.Bler: bool = None
 			self.Power_Dynamics: bool = None
 
 	def get_all(self) -> AllStruct:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:RESult[:ALL] \n
-		Snippet: value: AllStruct = driver.configure.multiEval.result.get_all() \n
+		Snippet: value: AllStruct = driver.configure.lteMeas.multiEval.result.get_all() \n
 		Enables or disables the evaluation of results in the multi-evaluation measurement. This command combines most other
 		CONFigure:LTE:MEAS<i>:MEValuation:RESult... commands. \n
 			:return: structure: for return value, see the help for AllStruct structure arguments.
 		"""
 		return self._core.io.query_struct('CONFigure:LTE:MEASurement<Instance>:MEValuation:RESult:ALL?', self.__class__.AllStruct())
 
 	def set_all(self, value: AllStruct) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:RESult[:ALL] \n
-		Snippet: driver.configure.multiEval.result.set_all(value = AllStruct()) \n
+		Snippet with structure: \n
+		structure = driver.configure.lteMeas.multiEval.result.AllStruct() \n
+		structure.Evm: bool = False \n
+		structure.Magnitude_Error: bool = False \n
+		structure.Phase_Error: bool = False \n
+		structure.Inband_Emissions: bool = False \n
+		structure.Evm_Versus_C: bool = False \n
+		structure.Iq: bool = False \n
+		structure.Equ_Spec_Flatness: bool = False \n
+		structure.Tx_Measurement: bool = False \n
+		structure.Spec_Em_Mask: bool = False \n
+		structure.Aclr: bool = False \n
+		structure.Rb_Alloc_Table: bool = False \n
+		structure.Power_Monitor: bool = False \n
+		structure.Bler: bool = False \n
+		structure.Power_Dynamics: bool = False \n
+		driver.configure.lteMeas.multiEval.result.set_all(value = structure) \n
 		Enables or disables the evaluation of results in the multi-evaluation measurement. This command combines most other
 		CONFigure:LTE:MEAS<i>:MEValuation:RESult... commands. \n
 			:param value: see the help for AllStruct structure arguments.
 		"""
 		self._core.io.write_struct('CONFigure:LTE:MEASurement<Instance>:MEValuation:RESult:ALL', value)
 
 	def get_merror(self) -> bool:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:RESult:MERRor \n
-		Snippet: value: bool = driver.configure.multiEval.result.get_merror() \n
+		Snippet: value: bool = driver.configure.lteMeas.multiEval.result.get_merror() \n
 		Enables or disables the evaluation of results in the multi-evaluation measurement.
 			Table Header: Mnemonic / Description \n
 			- EVMagnitude / Error vector magnitude
 			- MERRor / Magnitude error
-			- IEMissions / Inband emissions
+			- IEMissions / In-band emissions
 			- ESFLatness / Equalizer spectrum flatness
 			- SEMask / Spectrum emission mask
 			- RBATable / Resource block allocation table
-			- BLER / Block error ratio
+			-
 			- EVMC / EVM vs subcarrier
 			- PERRor / Phase error
 			- IQ / I/Q constellation diagram
 			- TXM / TX meas. statistical overview
 			- ACLR / Adj. channel leakage power ratio
 			- PMONitor / Power monitor
 			- PDYNamics / Power dynamics
-		For reset values, see method RsCMPX_LteMeas.Configure.MultiEval.Result.all. \n
-			:return: enable: OFF: Do not evaluate results ON: Evaluate results
+		For reset values, see method RsCMPX_LteMeas.Configure.LteMeas.MultiEval.Result.all. \n
+			:return: enable: OFF: Do not evaluate the results. ON: Evaluate the results.
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:MEValuation:RESult:MERRor?')
 		return Conversions.str_to_bool(response)
 
 	def set_merror(self, enable: bool) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:RESult:MERRor \n
-		Snippet: driver.configure.multiEval.result.set_merror(enable = False) \n
+		Snippet: driver.configure.lteMeas.multiEval.result.set_merror(enable = False) \n
 		Enables or disables the evaluation of results in the multi-evaluation measurement.
 			Table Header: Mnemonic / Description \n
 			- EVMagnitude / Error vector magnitude
 			- MERRor / Magnitude error
-			- IEMissions / Inband emissions
+			- IEMissions / In-band emissions
 			- ESFLatness / Equalizer spectrum flatness
 			- SEMask / Spectrum emission mask
 			- RBATable / Resource block allocation table
-			- BLER / Block error ratio
+			-
 			- EVMC / EVM vs subcarrier
 			- PERRor / Phase error
 			- IQ / I/Q constellation diagram
 			- TXM / TX meas. statistical overview
 			- ACLR / Adj. channel leakage power ratio
 			- PMONitor / Power monitor
 			- PDYNamics / Power dynamics
-		For reset values, see method RsCMPX_LteMeas.Configure.MultiEval.Result.all. \n
-			:param enable: OFF: Do not evaluate results ON: Evaluate results
+		For reset values, see method RsCMPX_LteMeas.Configure.LteMeas.MultiEval.Result.all. \n
+			:param enable: OFF: Do not evaluate the results. ON: Evaluate the results.
 		"""
 		param = Conversions.bool_to_str(enable)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:RESult:MERRor {param}')
 
 	def get_perror(self) -> bool:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:RESult:PERRor \n
-		Snippet: value: bool = driver.configure.multiEval.result.get_perror() \n
+		Snippet: value: bool = driver.configure.lteMeas.multiEval.result.get_perror() \n
 		Enables or disables the evaluation of results in the multi-evaluation measurement.
 			Table Header: Mnemonic / Description \n
 			- EVMagnitude / Error vector magnitude
 			- MERRor / Magnitude error
-			- IEMissions / Inband emissions
+			- IEMissions / In-band emissions
 			- ESFLatness / Equalizer spectrum flatness
 			- SEMask / Spectrum emission mask
 			- RBATable / Resource block allocation table
-			- BLER / Block error ratio
+			-
 			- EVMC / EVM vs subcarrier
 			- PERRor / Phase error
 			- IQ / I/Q constellation diagram
 			- TXM / TX meas. statistical overview
 			- ACLR / Adj. channel leakage power ratio
 			- PMONitor / Power monitor
 			- PDYNamics / Power dynamics
-		For reset values, see method RsCMPX_LteMeas.Configure.MultiEval.Result.all. \n
-			:return: enable: OFF: Do not evaluate results ON: Evaluate results
+		For reset values, see method RsCMPX_LteMeas.Configure.LteMeas.MultiEval.Result.all. \n
+			:return: enable: OFF: Do not evaluate the results. ON: Evaluate the results.
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:MEValuation:RESult:PERRor?')
 		return Conversions.str_to_bool(response)
 
 	def set_perror(self, enable: bool) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:RESult:PERRor \n
-		Snippet: driver.configure.multiEval.result.set_perror(enable = False) \n
+		Snippet: driver.configure.lteMeas.multiEval.result.set_perror(enable = False) \n
 		Enables or disables the evaluation of results in the multi-evaluation measurement.
 			Table Header: Mnemonic / Description \n
 			- EVMagnitude / Error vector magnitude
 			- MERRor / Magnitude error
-			- IEMissions / Inband emissions
+			- IEMissions / In-band emissions
 			- ESFLatness / Equalizer spectrum flatness
 			- SEMask / Spectrum emission mask
 			- RBATable / Resource block allocation table
-			- BLER / Block error ratio
+			-
 			- EVMC / EVM vs subcarrier
 			- PERRor / Phase error
 			- IQ / I/Q constellation diagram
 			- TXM / TX meas. statistical overview
 			- ACLR / Adj. channel leakage power ratio
 			- PMONitor / Power monitor
 			- PDYNamics / Power dynamics
-		For reset values, see method RsCMPX_LteMeas.Configure.MultiEval.Result.all. \n
-			:param enable: OFF: Do not evaluate results ON: Evaluate results
+		For reset values, see method RsCMPX_LteMeas.Configure.LteMeas.MultiEval.Result.all. \n
+			:param enable: OFF: Do not evaluate the results. ON: Evaluate the results.
 		"""
 		param = Conversions.bool_to_str(enable)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:RESult:PERRor {param}')
 
 	def get_iemissions(self) -> bool:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:RESult:IEMissions \n
-		Snippet: value: bool = driver.configure.multiEval.result.get_iemissions() \n
+		Snippet: value: bool = driver.configure.lteMeas.multiEval.result.get_iemissions() \n
 		Enables or disables the evaluation of results in the multi-evaluation measurement.
 			Table Header: Mnemonic / Description \n
 			- EVMagnitude / Error vector magnitude
 			- MERRor / Magnitude error
-			- IEMissions / Inband emissions
+			- IEMissions / In-band emissions
 			- ESFLatness / Equalizer spectrum flatness
 			- SEMask / Spectrum emission mask
 			- RBATable / Resource block allocation table
-			- BLER / Block error ratio
+			-
 			- EVMC / EVM vs subcarrier
 			- PERRor / Phase error
 			- IQ / I/Q constellation diagram
 			- TXM / TX meas. statistical overview
 			- ACLR / Adj. channel leakage power ratio
 			- PMONitor / Power monitor
 			- PDYNamics / Power dynamics
-		For reset values, see method RsCMPX_LteMeas.Configure.MultiEval.Result.all. \n
-			:return: enable: OFF: Do not evaluate results ON: Evaluate results
+		For reset values, see method RsCMPX_LteMeas.Configure.LteMeas.MultiEval.Result.all. \n
+			:return: enable: OFF: Do not evaluate the results. ON: Evaluate the results.
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:MEValuation:RESult:IEMissions?')
 		return Conversions.str_to_bool(response)
 
 	def set_iemissions(self, enable: bool) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:RESult:IEMissions \n
-		Snippet: driver.configure.multiEval.result.set_iemissions(enable = False) \n
+		Snippet: driver.configure.lteMeas.multiEval.result.set_iemissions(enable = False) \n
 		Enables or disables the evaluation of results in the multi-evaluation measurement.
 			Table Header: Mnemonic / Description \n
 			- EVMagnitude / Error vector magnitude
 			- MERRor / Magnitude error
-			- IEMissions / Inband emissions
+			- IEMissions / In-band emissions
 			- ESFLatness / Equalizer spectrum flatness
 			- SEMask / Spectrum emission mask
 			- RBATable / Resource block allocation table
-			- BLER / Block error ratio
+			-
 			- EVMC / EVM vs subcarrier
 			- PERRor / Phase error
 			- IQ / I/Q constellation diagram
 			- TXM / TX meas. statistical overview
 			- ACLR / Adj. channel leakage power ratio
 			- PMONitor / Power monitor
 			- PDYNamics / Power dynamics
-		For reset values, see method RsCMPX_LteMeas.Configure.MultiEval.Result.all. \n
-			:param enable: OFF: Do not evaluate results ON: Evaluate results
+		For reset values, see method RsCMPX_LteMeas.Configure.LteMeas.MultiEval.Result.all. \n
+			:param enable: OFF: Do not evaluate the results. ON: Evaluate the results.
 		"""
 		param = Conversions.bool_to_str(enable)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:RESult:IEMissions {param}')
 
 	def get_evmc(self) -> bool:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:RESult:EVMC \n
-		Snippet: value: bool = driver.configure.multiEval.result.get_evmc() \n
+		Snippet: value: bool = driver.configure.lteMeas.multiEval.result.get_evmc() \n
 		Enables or disables the evaluation of results in the multi-evaluation measurement.
 			Table Header: Mnemonic / Description \n
 			- EVMagnitude / Error vector magnitude
 			- MERRor / Magnitude error
-			- IEMissions / Inband emissions
+			- IEMissions / In-band emissions
 			- ESFLatness / Equalizer spectrum flatness
 			- SEMask / Spectrum emission mask
 			- RBATable / Resource block allocation table
-			- BLER / Block error ratio
+			-
 			- EVMC / EVM vs subcarrier
 			- PERRor / Phase error
 			- IQ / I/Q constellation diagram
 			- TXM / TX meas. statistical overview
 			- ACLR / Adj. channel leakage power ratio
 			- PMONitor / Power monitor
 			- PDYNamics / Power dynamics
-		For reset values, see method RsCMPX_LteMeas.Configure.MultiEval.Result.all. \n
-			:return: enable: OFF: Do not evaluate results ON: Evaluate results
+		For reset values, see method RsCMPX_LteMeas.Configure.LteMeas.MultiEval.Result.all. \n
+			:return: enable: OFF: Do not evaluate the results. ON: Evaluate the results.
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:MEValuation:RESult:EVMC?')
 		return Conversions.str_to_bool(response)
 
 	def set_evmc(self, enable: bool) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:RESult:EVMC \n
-		Snippet: driver.configure.multiEval.result.set_evmc(enable = False) \n
+		Snippet: driver.configure.lteMeas.multiEval.result.set_evmc(enable = False) \n
 		Enables or disables the evaluation of results in the multi-evaluation measurement.
 			Table Header: Mnemonic / Description \n
 			- EVMagnitude / Error vector magnitude
 			- MERRor / Magnitude error
-			- IEMissions / Inband emissions
+			- IEMissions / In-band emissions
 			- ESFLatness / Equalizer spectrum flatness
 			- SEMask / Spectrum emission mask
 			- RBATable / Resource block allocation table
-			- BLER / Block error ratio
+			-
 			- EVMC / EVM vs subcarrier
 			- PERRor / Phase error
 			- IQ / I/Q constellation diagram
 			- TXM / TX meas. statistical overview
 			- ACLR / Adj. channel leakage power ratio
 			- PMONitor / Power monitor
 			- PDYNamics / Power dynamics
-		For reset values, see method RsCMPX_LteMeas.Configure.MultiEval.Result.all. \n
-			:param enable: OFF: Do not evaluate results ON: Evaluate results
+		For reset values, see method RsCMPX_LteMeas.Configure.LteMeas.MultiEval.Result.all. \n
+			:param enable: OFF: Do not evaluate the results. ON: Evaluate the results.
 		"""
 		param = Conversions.bool_to_str(enable)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:RESult:EVMC {param}')
 
 	def get_es_flatness(self) -> bool:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:RESult:ESFLatness \n
-		Snippet: value: bool = driver.configure.multiEval.result.get_es_flatness() \n
+		Snippet: value: bool = driver.configure.lteMeas.multiEval.result.get_es_flatness() \n
 		Enables or disables the evaluation of results in the multi-evaluation measurement.
 			Table Header: Mnemonic / Description \n
 			- EVMagnitude / Error vector magnitude
 			- MERRor / Magnitude error
-			- IEMissions / Inband emissions
+			- IEMissions / In-band emissions
 			- ESFLatness / Equalizer spectrum flatness
 			- SEMask / Spectrum emission mask
 			- RBATable / Resource block allocation table
-			- BLER / Block error ratio
+			-
 			- EVMC / EVM vs subcarrier
 			- PERRor / Phase error
 			- IQ / I/Q constellation diagram
 			- TXM / TX meas. statistical overview
 			- ACLR / Adj. channel leakage power ratio
 			- PMONitor / Power monitor
 			- PDYNamics / Power dynamics
-		For reset values, see method RsCMPX_LteMeas.Configure.MultiEval.Result.all. \n
-			:return: enable: OFF: Do not evaluate results ON: Evaluate results
+		For reset values, see method RsCMPX_LteMeas.Configure.LteMeas.MultiEval.Result.all. \n
+			:return: enable: OFF: Do not evaluate the results. ON: Evaluate the results.
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:MEValuation:RESult:ESFLatness?')
 		return Conversions.str_to_bool(response)
 
 	def set_es_flatness(self, enable: bool) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:RESult:ESFLatness \n
-		Snippet: driver.configure.multiEval.result.set_es_flatness(enable = False) \n
+		Snippet: driver.configure.lteMeas.multiEval.result.set_es_flatness(enable = False) \n
 		Enables or disables the evaluation of results in the multi-evaluation measurement.
 			Table Header: Mnemonic / Description \n
 			- EVMagnitude / Error vector magnitude
 			- MERRor / Magnitude error
-			- IEMissions / Inband emissions
+			- IEMissions / In-band emissions
 			- ESFLatness / Equalizer spectrum flatness
 			- SEMask / Spectrum emission mask
 			- RBATable / Resource block allocation table
-			- BLER / Block error ratio
+			-
 			- EVMC / EVM vs subcarrier
 			- PERRor / Phase error
 			- IQ / I/Q constellation diagram
 			- TXM / TX meas. statistical overview
 			- ACLR / Adj. channel leakage power ratio
 			- PMONitor / Power monitor
 			- PDYNamics / Power dynamics
-		For reset values, see method RsCMPX_LteMeas.Configure.MultiEval.Result.all. \n
-			:param enable: OFF: Do not evaluate results ON: Evaluate results
+		For reset values, see method RsCMPX_LteMeas.Configure.LteMeas.MultiEval.Result.all. \n
+			:param enable: OFF: Do not evaluate the results. ON: Evaluate the results.
 		"""
 		param = Conversions.bool_to_str(enable)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:RESult:ESFLatness {param}')
 
 	def get_txm(self) -> bool:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:RESult:TXM \n
-		Snippet: value: bool = driver.configure.multiEval.result.get_txm() \n
+		Snippet: value: bool = driver.configure.lteMeas.multiEval.result.get_txm() \n
 		Enables or disables the evaluation of results in the multi-evaluation measurement.
 			Table Header: Mnemonic / Description \n
 			- EVMagnitude / Error vector magnitude
 			- MERRor / Magnitude error
-			- IEMissions / Inband emissions
+			- IEMissions / In-band emissions
 			- ESFLatness / Equalizer spectrum flatness
 			- SEMask / Spectrum emission mask
 			- RBATable / Resource block allocation table
-			- BLER / Block error ratio
+			-
 			- EVMC / EVM vs subcarrier
 			- PERRor / Phase error
 			- IQ / I/Q constellation diagram
 			- TXM / TX meas. statistical overview
 			- ACLR / Adj. channel leakage power ratio
 			- PMONitor / Power monitor
 			- PDYNamics / Power dynamics
-		For reset values, see method RsCMPX_LteMeas.Configure.MultiEval.Result.all. \n
-			:return: enable: OFF: Do not evaluate results ON: Evaluate results
+		For reset values, see method RsCMPX_LteMeas.Configure.LteMeas.MultiEval.Result.all. \n
+			:return: enable: OFF: Do not evaluate the results. ON: Evaluate the results.
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:MEValuation:RESult:TXM?')
 		return Conversions.str_to_bool(response)
 
 	def set_txm(self, enable: bool) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:RESult:TXM \n
-		Snippet: driver.configure.multiEval.result.set_txm(enable = False) \n
+		Snippet: driver.configure.lteMeas.multiEval.result.set_txm(enable = False) \n
 		Enables or disables the evaluation of results in the multi-evaluation measurement.
 			Table Header: Mnemonic / Description \n
 			- EVMagnitude / Error vector magnitude
 			- MERRor / Magnitude error
-			- IEMissions / Inband emissions
+			- IEMissions / In-band emissions
 			- ESFLatness / Equalizer spectrum flatness
 			- SEMask / Spectrum emission mask
 			- RBATable / Resource block allocation table
-			- BLER / Block error ratio
+			-
 			- EVMC / EVM vs subcarrier
 			- PERRor / Phase error
 			- IQ / I/Q constellation diagram
 			- TXM / TX meas. statistical overview
 			- ACLR / Adj. channel leakage power ratio
 			- PMONitor / Power monitor
 			- PDYNamics / Power dynamics
-		For reset values, see method RsCMPX_LteMeas.Configure.MultiEval.Result.all. \n
-			:param enable: OFF: Do not evaluate results ON: Evaluate results
+		For reset values, see method RsCMPX_LteMeas.Configure.LteMeas.MultiEval.Result.all. \n
+			:param enable: OFF: Do not evaluate the results. ON: Evaluate the results.
 		"""
 		param = Conversions.bool_to_str(enable)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:RESult:TXM {param}')
 
 	def get_iq(self) -> bool:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:RESult:IQ \n
-		Snippet: value: bool = driver.configure.multiEval.result.get_iq() \n
+		Snippet: value: bool = driver.configure.lteMeas.multiEval.result.get_iq() \n
 		Enables or disables the evaluation of results in the multi-evaluation measurement.
 			Table Header: Mnemonic / Description \n
 			- EVMagnitude / Error vector magnitude
 			- MERRor / Magnitude error
-			- IEMissions / Inband emissions
+			- IEMissions / In-band emissions
 			- ESFLatness / Equalizer spectrum flatness
 			- SEMask / Spectrum emission mask
 			- RBATable / Resource block allocation table
-			- BLER / Block error ratio
+			-
 			- EVMC / EVM vs subcarrier
 			- PERRor / Phase error
 			- IQ / I/Q constellation diagram
 			- TXM / TX meas. statistical overview
 			- ACLR / Adj. channel leakage power ratio
 			- PMONitor / Power monitor
 			- PDYNamics / Power dynamics
-		For reset values, see method RsCMPX_LteMeas.Configure.MultiEval.Result.all. \n
-			:return: enable: OFF: Do not evaluate results ON: Evaluate results
+		For reset values, see method RsCMPX_LteMeas.Configure.LteMeas.MultiEval.Result.all. \n
+			:return: enable: OFF: Do not evaluate the results. ON: Evaluate the results.
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:MEValuation:RESult:IQ?')
 		return Conversions.str_to_bool(response)
 
 	def set_iq(self, enable: bool) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:RESult:IQ \n
-		Snippet: driver.configure.multiEval.result.set_iq(enable = False) \n
+		Snippet: driver.configure.lteMeas.multiEval.result.set_iq(enable = False) \n
 		Enables or disables the evaluation of results in the multi-evaluation measurement.
 			Table Header: Mnemonic / Description \n
 			- EVMagnitude / Error vector magnitude
 			- MERRor / Magnitude error
-			- IEMissions / Inband emissions
+			- IEMissions / In-band emissions
 			- ESFLatness / Equalizer spectrum flatness
 			- SEMask / Spectrum emission mask
 			- RBATable / Resource block allocation table
-			- BLER / Block error ratio
+			-
 			- EVMC / EVM vs subcarrier
 			- PERRor / Phase error
 			- IQ / I/Q constellation diagram
 			- TXM / TX meas. statistical overview
 			- ACLR / Adj. channel leakage power ratio
 			- PMONitor / Power monitor
 			- PDYNamics / Power dynamics
-		For reset values, see method RsCMPX_LteMeas.Configure.MultiEval.Result.all. \n
-			:param enable: OFF: Do not evaluate results ON: Evaluate results
+		For reset values, see method RsCMPX_LteMeas.Configure.LteMeas.MultiEval.Result.all. \n
+			:param enable: OFF: Do not evaluate the results. ON: Evaluate the results.
 		"""
 		param = Conversions.bool_to_str(enable)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:RESult:IQ {param}')
 
 	def get_se_mask(self) -> bool:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:RESult:SEMask \n
-		Snippet: value: bool = driver.configure.multiEval.result.get_se_mask() \n
+		Snippet: value: bool = driver.configure.lteMeas.multiEval.result.get_se_mask() \n
 		Enables or disables the evaluation of results in the multi-evaluation measurement.
 			Table Header: Mnemonic / Description \n
 			- EVMagnitude / Error vector magnitude
 			- MERRor / Magnitude error
-			- IEMissions / Inband emissions
+			- IEMissions / In-band emissions
 			- ESFLatness / Equalizer spectrum flatness
 			- SEMask / Spectrum emission mask
 			- RBATable / Resource block allocation table
-			- BLER / Block error ratio
+			-
 			- EVMC / EVM vs subcarrier
 			- PERRor / Phase error
 			- IQ / I/Q constellation diagram
 			- TXM / TX meas. statistical overview
 			- ACLR / Adj. channel leakage power ratio
 			- PMONitor / Power monitor
 			- PDYNamics / Power dynamics
-		For reset values, see method RsCMPX_LteMeas.Configure.MultiEval.Result.all. \n
-			:return: enable: OFF: Do not evaluate results ON: Evaluate results
+		For reset values, see method RsCMPX_LteMeas.Configure.LteMeas.MultiEval.Result.all. \n
+			:return: enable: OFF: Do not evaluate the results. ON: Evaluate the results.
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:MEValuation:RESult:SEMask?')
 		return Conversions.str_to_bool(response)
 
 	def set_se_mask(self, enable: bool) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:RESult:SEMask \n
-		Snippet: driver.configure.multiEval.result.set_se_mask(enable = False) \n
+		Snippet: driver.configure.lteMeas.multiEval.result.set_se_mask(enable = False) \n
 		Enables or disables the evaluation of results in the multi-evaluation measurement.
 			Table Header: Mnemonic / Description \n
 			- EVMagnitude / Error vector magnitude
 			- MERRor / Magnitude error
-			- IEMissions / Inband emissions
+			- IEMissions / In-band emissions
 			- ESFLatness / Equalizer spectrum flatness
 			- SEMask / Spectrum emission mask
 			- RBATable / Resource block allocation table
-			- BLER / Block error ratio
+			-
 			- EVMC / EVM vs subcarrier
 			- PERRor / Phase error
 			- IQ / I/Q constellation diagram
 			- TXM / TX meas. statistical overview
 			- ACLR / Adj. channel leakage power ratio
 			- PMONitor / Power monitor
 			- PDYNamics / Power dynamics
-		For reset values, see method RsCMPX_LteMeas.Configure.MultiEval.Result.all. \n
-			:param enable: OFF: Do not evaluate results ON: Evaluate results
+		For reset values, see method RsCMPX_LteMeas.Configure.LteMeas.MultiEval.Result.all. \n
+			:param enable: OFF: Do not evaluate the results. ON: Evaluate the results.
 		"""
 		param = Conversions.bool_to_str(enable)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:RESult:SEMask {param}')
 
 	def get_aclr(self) -> bool:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:RESult:ACLR \n
-		Snippet: value: bool = driver.configure.multiEval.result.get_aclr() \n
+		Snippet: value: bool = driver.configure.lteMeas.multiEval.result.get_aclr() \n
 		Enables or disables the evaluation of results in the multi-evaluation measurement.
 			Table Header: Mnemonic / Description \n
 			- EVMagnitude / Error vector magnitude
 			- MERRor / Magnitude error
-			- IEMissions / Inband emissions
+			- IEMissions / In-band emissions
 			- ESFLatness / Equalizer spectrum flatness
 			- SEMask / Spectrum emission mask
 			- RBATable / Resource block allocation table
-			- BLER / Block error ratio
+			-
 			- EVMC / EVM vs subcarrier
 			- PERRor / Phase error
 			- IQ / I/Q constellation diagram
 			- TXM / TX meas. statistical overview
 			- ACLR / Adj. channel leakage power ratio
 			- PMONitor / Power monitor
 			- PDYNamics / Power dynamics
-		For reset values, see method RsCMPX_LteMeas.Configure.MultiEval.Result.all. \n
-			:return: enable: OFF: Do not evaluate results ON: Evaluate results
+		For reset values, see method RsCMPX_LteMeas.Configure.LteMeas.MultiEval.Result.all. \n
+			:return: enable: OFF: Do not evaluate the results. ON: Evaluate the results.
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:MEValuation:RESult:ACLR?')
 		return Conversions.str_to_bool(response)
 
 	def set_aclr(self, enable: bool) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:RESult:ACLR \n
-		Snippet: driver.configure.multiEval.result.set_aclr(enable = False) \n
+		Snippet: driver.configure.lteMeas.multiEval.result.set_aclr(enable = False) \n
 		Enables or disables the evaluation of results in the multi-evaluation measurement.
 			Table Header: Mnemonic / Description \n
 			- EVMagnitude / Error vector magnitude
 			- MERRor / Magnitude error
-			- IEMissions / Inband emissions
+			- IEMissions / In-band emissions
 			- ESFLatness / Equalizer spectrum flatness
 			- SEMask / Spectrum emission mask
 			- RBATable / Resource block allocation table
-			- BLER / Block error ratio
+			-
 			- EVMC / EVM vs subcarrier
 			- PERRor / Phase error
 			- IQ / I/Q constellation diagram
 			- TXM / TX meas. statistical overview
 			- ACLR / Adj. channel leakage power ratio
 			- PMONitor / Power monitor
 			- PDYNamics / Power dynamics
-		For reset values, see method RsCMPX_LteMeas.Configure.MultiEval.Result.all. \n
-			:param enable: OFF: Do not evaluate results ON: Evaluate results
+		For reset values, see method RsCMPX_LteMeas.Configure.LteMeas.MultiEval.Result.all. \n
+			:param enable: OFF: Do not evaluate the results. ON: Evaluate the results.
 		"""
 		param = Conversions.bool_to_str(enable)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:RESult:ACLR {param}')
 
 	def get_rba_table(self) -> bool:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:RESult:RBATable \n
-		Snippet: value: bool = driver.configure.multiEval.result.get_rba_table() \n
+		Snippet: value: bool = driver.configure.lteMeas.multiEval.result.get_rba_table() \n
 		Enables or disables the evaluation of results in the multi-evaluation measurement.
 			Table Header: Mnemonic / Description \n
 			- EVMagnitude / Error vector magnitude
 			- MERRor / Magnitude error
-			- IEMissions / Inband emissions
+			- IEMissions / In-band emissions
 			- ESFLatness / Equalizer spectrum flatness
 			- SEMask / Spectrum emission mask
 			- RBATable / Resource block allocation table
-			- BLER / Block error ratio
+			-
 			- EVMC / EVM vs subcarrier
 			- PERRor / Phase error
 			- IQ / I/Q constellation diagram
 			- TXM / TX meas. statistical overview
 			- ACLR / Adj. channel leakage power ratio
 			- PMONitor / Power monitor
 			- PDYNamics / Power dynamics
-		For reset values, see method RsCMPX_LteMeas.Configure.MultiEval.Result.all. \n
-			:return: enable: OFF: Do not evaluate results ON: Evaluate results
+		For reset values, see method RsCMPX_LteMeas.Configure.LteMeas.MultiEval.Result.all. \n
+			:return: enable: OFF: Do not evaluate the results. ON: Evaluate the results.
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:MEValuation:RESult:RBATable?')
 		return Conversions.str_to_bool(response)
 
 	def set_rba_table(self, enable: bool) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:RESult:RBATable \n
-		Snippet: driver.configure.multiEval.result.set_rba_table(enable = False) \n
+		Snippet: driver.configure.lteMeas.multiEval.result.set_rba_table(enable = False) \n
 		Enables or disables the evaluation of results in the multi-evaluation measurement.
 			Table Header: Mnemonic / Description \n
 			- EVMagnitude / Error vector magnitude
 			- MERRor / Magnitude error
-			- IEMissions / Inband emissions
+			- IEMissions / In-band emissions
 			- ESFLatness / Equalizer spectrum flatness
 			- SEMask / Spectrum emission mask
 			- RBATable / Resource block allocation table
-			- BLER / Block error ratio
+			-
 			- EVMC / EVM vs subcarrier
 			- PERRor / Phase error
 			- IQ / I/Q constellation diagram
 			- TXM / TX meas. statistical overview
 			- ACLR / Adj. channel leakage power ratio
 			- PMONitor / Power monitor
 			- PDYNamics / Power dynamics
-		For reset values, see method RsCMPX_LteMeas.Configure.MultiEval.Result.all. \n
-			:param enable: OFF: Do not evaluate results ON: Evaluate results
+		For reset values, see method RsCMPX_LteMeas.Configure.LteMeas.MultiEval.Result.all. \n
+			:param enable: OFF: Do not evaluate the results. ON: Evaluate the results.
 		"""
 		param = Conversions.bool_to_str(enable)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:RESult:RBATable {param}')
 
 	def get_pmonitor(self) -> bool:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:RESult:PMONitor \n
-		Snippet: value: bool = driver.configure.multiEval.result.get_pmonitor() \n
+		Snippet: value: bool = driver.configure.lteMeas.multiEval.result.get_pmonitor() \n
 		Enables or disables the evaluation of results in the multi-evaluation measurement.
 			Table Header: Mnemonic / Description \n
 			- EVMagnitude / Error vector magnitude
 			- MERRor / Magnitude error
-			- IEMissions / Inband emissions
+			- IEMissions / In-band emissions
 			- ESFLatness / Equalizer spectrum flatness
 			- SEMask / Spectrum emission mask
 			- RBATable / Resource block allocation table
-			- BLER / Block error ratio
+			-
 			- EVMC / EVM vs subcarrier
 			- PERRor / Phase error
 			- IQ / I/Q constellation diagram
 			- TXM / TX meas. statistical overview
 			- ACLR / Adj. channel leakage power ratio
 			- PMONitor / Power monitor
 			- PDYNamics / Power dynamics
-		For reset values, see method RsCMPX_LteMeas.Configure.MultiEval.Result.all. \n
-			:return: enable: OFF: Do not evaluate results ON: Evaluate results
+		For reset values, see method RsCMPX_LteMeas.Configure.LteMeas.MultiEval.Result.all. \n
+			:return: enable: OFF: Do not evaluate the results. ON: Evaluate the results.
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:MEValuation:RESult:PMONitor?')
 		return Conversions.str_to_bool(response)
 
 	def set_pmonitor(self, enable: bool) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:RESult:PMONitor \n
-		Snippet: driver.configure.multiEval.result.set_pmonitor(enable = False) \n
+		Snippet: driver.configure.lteMeas.multiEval.result.set_pmonitor(enable = False) \n
 		Enables or disables the evaluation of results in the multi-evaluation measurement.
 			Table Header: Mnemonic / Description \n
 			- EVMagnitude / Error vector magnitude
 			- MERRor / Magnitude error
-			- IEMissions / Inband emissions
+			- IEMissions / In-band emissions
 			- ESFLatness / Equalizer spectrum flatness
 			- SEMask / Spectrum emission mask
 			- RBATable / Resource block allocation table
-			- BLER / Block error ratio
+			-
 			- EVMC / EVM vs subcarrier
 			- PERRor / Phase error
 			- IQ / I/Q constellation diagram
 			- TXM / TX meas. statistical overview
 			- ACLR / Adj. channel leakage power ratio
 			- PMONitor / Power monitor
 			- PDYNamics / Power dynamics
-		For reset values, see method RsCMPX_LteMeas.Configure.MultiEval.Result.all. \n
-			:param enable: OFF: Do not evaluate results ON: Evaluate results
+		For reset values, see method RsCMPX_LteMeas.Configure.LteMeas.MultiEval.Result.all. \n
+			:param enable: OFF: Do not evaluate the results. ON: Evaluate the results.
 		"""
 		param = Conversions.bool_to_str(enable)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:RESult:PMONitor {param}')
 
 	def get_pdynamics(self) -> bool:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:RESult:PDYNamics \n
-		Snippet: value: bool = driver.configure.multiEval.result.get_pdynamics() \n
+		Snippet: value: bool = driver.configure.lteMeas.multiEval.result.get_pdynamics() \n
 		Enables or disables the evaluation of results in the multi-evaluation measurement.
 			Table Header: Mnemonic / Description \n
 			- EVMagnitude / Error vector magnitude
 			- MERRor / Magnitude error
-			- IEMissions / Inband emissions
+			- IEMissions / In-band emissions
 			- ESFLatness / Equalizer spectrum flatness
 			- SEMask / Spectrum emission mask
 			- RBATable / Resource block allocation table
-			- BLER / Block error ratio
+			-
 			- EVMC / EVM vs subcarrier
 			- PERRor / Phase error
 			- IQ / I/Q constellation diagram
 			- TXM / TX meas. statistical overview
 			- ACLR / Adj. channel leakage power ratio
 			- PMONitor / Power monitor
 			- PDYNamics / Power dynamics
-		For reset values, see method RsCMPX_LteMeas.Configure.MultiEval.Result.all. \n
-			:return: enable: OFF: Do not evaluate results ON: Evaluate results
+		For reset values, see method RsCMPX_LteMeas.Configure.LteMeas.MultiEval.Result.all. \n
+			:return: enable: OFF: Do not evaluate the results. ON: Evaluate the results.
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:MEValuation:RESult:PDYNamics?')
 		return Conversions.str_to_bool(response)
 
 	def set_pdynamics(self, enable: bool) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:RESult:PDYNamics \n
-		Snippet: driver.configure.multiEval.result.set_pdynamics(enable = False) \n
+		Snippet: driver.configure.lteMeas.multiEval.result.set_pdynamics(enable = False) \n
 		Enables or disables the evaluation of results in the multi-evaluation measurement.
 			Table Header: Mnemonic / Description \n
 			- EVMagnitude / Error vector magnitude
 			- MERRor / Magnitude error
-			- IEMissions / Inband emissions
+			- IEMissions / In-band emissions
 			- ESFLatness / Equalizer spectrum flatness
 			- SEMask / Spectrum emission mask
 			- RBATable / Resource block allocation table
-			- BLER / Block error ratio
+			-
 			- EVMC / EVM vs subcarrier
 			- PERRor / Phase error
 			- IQ / I/Q constellation diagram
 			- TXM / TX meas. statistical overview
 			- ACLR / Adj. channel leakage power ratio
 			- PMONitor / Power monitor
 			- PDYNamics / Power dynamics
-		For reset values, see method RsCMPX_LteMeas.Configure.MultiEval.Result.all. \n
-			:param enable: OFF: Do not evaluate results ON: Evaluate results
+		For reset values, see method RsCMPX_LteMeas.Configure.LteMeas.MultiEval.Result.all. \n
+			:param enable: OFF: Do not evaluate the results. ON: Evaluate the results.
 		"""
 		param = Conversions.bool_to_str(enable)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:RESult:PDYNamics {param}')
 
 	def get_bler(self) -> bool:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:RESult:BLER \n
-		Snippet: value: bool = driver.configure.multiEval.result.get_bler() \n
+		Snippet: value: bool = driver.configure.lteMeas.multiEval.result.get_bler() \n
 		No command help available \n
 			:return: enable: No help available
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:MEValuation:RESult:BLER?')
 		return Conversions.str_to_bool(response)
 
 	def set_bler(self, enable: bool) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:RESult:BLER \n
-		Snippet: driver.configure.multiEval.result.set_bler(enable = False) \n
+		Snippet: driver.configure.lteMeas.multiEval.result.set_bler(enable = False) \n
 		No command help available \n
 			:param enable: No help available
 		"""
 		param = Conversions.bool_to_str(enable)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:RESult:BLER {param}')
 
-	def clone(self) -> 'Result':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'ResultCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Result(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = ResultCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Result_/EvMagnitude.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/SeMask/Current.py`

 * *Files 27% similar despite different names*

```diff
@@ -1,98 +1,80 @@
 from .....Internal.Core import Core
 from .....Internal.CommandsGroup import CommandsGroup
-from .....Internal import Conversions
 from .....Internal.StructBase import StructBase
 from .....Internal.ArgStruct import ArgStruct
-from ..... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class EvMagnitude:
-	"""EvMagnitude commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("evMagnitude", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	# noinspection PyTypeChecker
-	class EvmSymbolStruct(StructBase):
-		"""Structure for reading output parameters. Fields: \n
-			- Enable: bool: OFF: Do not measure the results ON: Measure the results
-			- Symbol: int: SC-FDMA symbol to be evaluated
-			- Low_High: enums.LowHigh: Low or high EVM window position"""
+	class ResultData(StructBase):
+		"""Response structure. Fields: \n
+			- Reliability: int: 'Reliability indicator'
+			- Out_Of_Tolerance: int: Out of tolerance result, i.e. the percentage of measurement intervals of the statistic count for spectrum emission measurements exceeding the specified spectrum emission mask limits.
+			- Obw: float: Occupied bandwidth
+			- Tx_Power: float: Total TX power in the slot over all component carriers"""
 		__meta_args_list = [
-			ArgStruct.scalar_bool('Enable'),
-			ArgStruct.scalar_int('Symbol'),
-			ArgStruct.scalar_enum('Low_High', enums.LowHigh)]
+			ArgStruct.scalar_int('Reliability', 'Reliability'),
+			ArgStruct.scalar_int('Out_Of_Tolerance'),
+			ArgStruct.scalar_float('Obw'),
+			ArgStruct.scalar_float('Tx_Power')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
-			self.Enable: bool = None
-			self.Symbol: int = None
-			self.Low_High: enums.LowHigh = None
-
-	def get_evm_symbol(self) -> EvmSymbolStruct:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:RESult:EVMagnitude:EVMSymbol \n
-		Snippet: value: EvmSymbolStruct = driver.configure.multiEval.result.evMagnitude.get_evm_symbol() \n
-		Enables or disables the measurement of EVM vs modulation symbol results and configures the scope of the measurement. \n
-			:return: structure: for return value, see the help for EvmSymbolStruct structure arguments.
-		"""
-		return self._core.io.query_struct('CONFigure:LTE:MEASurement<Instance>:MEValuation:RESult:EVMagnitude:EVMSymbol?', self.__class__.EvmSymbolStruct())
-
-	def set_evm_symbol(self, value: EvmSymbolStruct) -> None:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:RESult:EVMagnitude:EVMSymbol \n
-		Snippet: driver.configure.multiEval.result.evMagnitude.set_evm_symbol(value = EvmSymbolStruct()) \n
-		Enables or disables the measurement of EVM vs modulation symbol results and configures the scope of the measurement. \n
-			:param value: see the help for EvmSymbolStruct structure arguments.
-		"""
-		self._core.io.write_struct('CONFigure:LTE:MEASurement<Instance>:MEValuation:RESult:EVMagnitude:EVMSymbol', value)
-
-	def get_value(self) -> bool:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:RESult:EVMagnitude \n
-		Snippet: value: bool = driver.configure.multiEval.result.evMagnitude.get_value() \n
-		Enables or disables the evaluation of results in the multi-evaluation measurement.
-			Table Header: Mnemonic / Description \n
-			- EVMagnitude / Error vector magnitude
-			- MERRor / Magnitude error
-			- IEMissions / Inband emissions
-			- ESFLatness / Equalizer spectrum flatness
-			- SEMask / Spectrum emission mask
-			- RBATable / Resource block allocation table
-			- BLER / Block error ratio
-			- EVMC / EVM vs subcarrier
-			- PERRor / Phase error
-			- IQ / I/Q constellation diagram
-			- TXM / TX meas. statistical overview
-			- ACLR / Adj. channel leakage power ratio
-			- PMONitor / Power monitor
-			- PDYNamics / Power dynamics
-		For reset values, see method RsCMPX_LteMeas.Configure.MultiEval.Result.all. \n
-			:return: enable: OFF: Do not evaluate results ON: Evaluate results
-		"""
-		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:MEValuation:RESult:EVMagnitude?')
-		return Conversions.str_to_bool(response)
-
-	def set_value(self, enable: bool) -> None:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:RESult:EVMagnitude \n
-		Snippet: driver.configure.multiEval.result.evMagnitude.set_value(enable = False) \n
-		Enables or disables the evaluation of results in the multi-evaluation measurement.
-			Table Header: Mnemonic / Description \n
-			- EVMagnitude / Error vector magnitude
-			- MERRor / Magnitude error
-			- IEMissions / Inband emissions
-			- ESFLatness / Equalizer spectrum flatness
-			- SEMask / Spectrum emission mask
-			- RBATable / Resource block allocation table
-			- BLER / Block error ratio
-			- EVMC / EVM vs subcarrier
-			- PERRor / Phase error
-			- IQ / I/Q constellation diagram
-			- TXM / TX meas. statistical overview
-			- ACLR / Adj. channel leakage power ratio
-			- PMONitor / Power monitor
-			- PDYNamics / Power dynamics
-		For reset values, see method RsCMPX_LteMeas.Configure.MultiEval.Result.all. \n
-			:param enable: OFF: Do not evaluate results ON: Evaluate results
-		"""
-		param = Conversions.bool_to_str(enable)
-		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:RESult:EVMagnitude {param}')
+			self.Reliability: int = None
+			self.Out_Of_Tolerance: int = None
+			self.Obw: float = None
+			self.Tx_Power: float = None
+
+	def read(self) -> ResultData:
+		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:SEMask:CURRent \n
+		Snippet: value: ResultData = driver.lteMeas.multiEval.seMask.current.read() \n
+		Return the current, average and standard deviation single-value results of the spectrum emission measurement. The values
+		described below are returned by FETCh and READ commands. CALCulate commands return limit check results instead, one value
+		for each result listed below. \n
+			:return: structure: for return value, see the help for ResultData structure arguments."""
+		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:SEMask:CURRent?', self.__class__.ResultData())
+
+	def fetch(self) -> ResultData:
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:SEMask:CURRent \n
+		Snippet: value: ResultData = driver.lteMeas.multiEval.seMask.current.fetch() \n
+		Return the current, average and standard deviation single-value results of the spectrum emission measurement. The values
+		described below are returned by FETCh and READ commands. CALCulate commands return limit check results instead, one value
+		for each result listed below. \n
+			:return: structure: for return value, see the help for ResultData structure arguments."""
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:SEMask:CURRent?', self.__class__.ResultData())
+
+	# noinspection PyTypeChecker
+	class CalculateStruct(StructBase):
+		"""Response structure. Fields: \n
+			- Reliability: int: 'Reliability indicator'
+			- Out_Of_Tolerance: int: Out of tolerance result, i.e. the percentage of measurement intervals of the statistic count for spectrum emission measurements exceeding the specified spectrum emission mask limits.
+			- Obw: float or bool: Occupied bandwidth
+			- Tx_Power: float or bool: Total TX power in the slot over all component carriers"""
+		__meta_args_list = [
+			ArgStruct.scalar_int('Reliability', 'Reliability'),
+			ArgStruct.scalar_int('Out_Of_Tolerance'),
+			ArgStruct.scalar_float_ext('Obw'),
+			ArgStruct.scalar_float_ext('Tx_Power')]
+
+		def __init__(self):
+			StructBase.__init__(self, self)
+			self.Reliability: int = None
+			self.Out_Of_Tolerance: int = None
+			self.Obw: float or bool = None
+			self.Tx_Power: float or bool = None
+
+	def calculate(self) -> CalculateStruct:
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:SEMask:CURRent \n
+		Snippet: value: CalculateStruct = driver.lteMeas.multiEval.seMask.current.calculate() \n
+		Return the current, average and standard deviation single-value results of the spectrum emission measurement. The values
+		described below are returned by FETCh and READ commands. CALCulate commands return limit check results instead, one value
+		for each result listed below. \n
+			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
+		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:SEMask:CURRent?', self.__class__.CalculateStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Scc.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/CarrierAggregation/Scc/__init__.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,42 +1,42 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
-from ....Internal.RepeatedCapability import RepeatedCapability
-from .... import repcap
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal.RepeatedCapability import RepeatedCapability
+from ...... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Scc:
-	"""Scc commands group definition. 1 total commands, 1 Sub-groups, 0 group commands
+class SccCls:
+	"""Scc commands group definition. 1 total commands, 1 Subgroups, 0 group commands
 	Repeated Capability: SecondaryCC, default value after init: SecondaryCC.CC1"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("scc", core, parent)
-		self._base.rep_cap = RepeatedCapability(self._base.group_name, 'repcap_secondaryCC_get', 'repcap_secondaryCC_set', repcap.SecondaryCC.CC1)
+		self._cmd_group = CommandsGroup("scc", core, parent)
+		self._cmd_group.rep_cap = RepeatedCapability(self._cmd_group.group_name, 'repcap_secondaryCC_get', 'repcap_secondaryCC_set', repcap.SecondaryCC.CC1)
 
-	def repcap_secondaryCC_set(self, enum_value: repcap.SecondaryCC) -> None:
+	def repcap_secondaryCC_set(self, secondaryCC: repcap.SecondaryCC) -> None:
 		"""Repeated Capability default value numeric suffix.
 		This value is used, if you do not explicitely set it in the child set/get methods, or if you leave it to SecondaryCC.Default
 		Default value after init: SecondaryCC.CC1"""
-		self._base.set_repcap_enum_value(enum_value)
+		self._cmd_group.set_repcap_enum_value(secondaryCC)
 
 	def repcap_secondaryCC_get(self) -> repcap.SecondaryCC:
 		"""Returns the current default repeated capability for the child set/get methods"""
 		# noinspection PyTypeChecker
-		return self._base.get_repcap_enum_value()
+		return self._cmd_group.get_repcap_enum_value()
 
 	@property
-	def plcId(self):
-		"""plcId commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_plcId'):
-			from .Scc_.PlcId import PlcId
-			self._plcId = PlcId(self._core, self._base)
-		return self._plcId
+	def acSpacing(self):
+		"""acSpacing commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_acSpacing'):
+			from .AcSpacing import AcSpacingCls
+			self._acSpacing = AcSpacingCls(self._core, self._cmd_group)
+		return self._acSpacing
 
-	def clone(self) -> 'Scc':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'SccCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Scc(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = SccCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Scc_/PlcId.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Scc/PlcId.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,33 +1,34 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
-from .....Internal import Conversions
-from ..... import repcap
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal import Conversions
+from ...... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class PlcId:
-	"""PlcId commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class PlcIdCls:
+	"""PlcId commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("plcId", core, parent)
+		self._cmd_group = CommandsGroup("plcId", core, parent)
 
 	def set(self, phs_layer_cell_id: int, secondaryCC=repcap.SecondaryCC.Default) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:SCC<Nr>:PLCid \n
-		Snippet: driver.configure.multiEval.scc.plcId.set(phs_layer_cell_id = 1, secondaryCC = repcap.SecondaryCC.Default) \n
+		Snippet: driver.configure.lteMeas.multiEval.scc.plcId.set(phs_layer_cell_id = 1, secondaryCC = repcap.SecondaryCC.Default) \n
 		No command help available \n
 			:param phs_layer_cell_id: No help available
-			:param secondaryCC: optional repeated capability selector. Default value: CC1 (settable in the interface 'Scc')"""
+			:param secondaryCC: optional repeated capability selector. Default value: CC1 (settable in the interface 'Scc')
+		"""
 		param = Conversions.decimal_value_to_str(phs_layer_cell_id)
-		secondaryCC_cmd_val = self._base.get_repcap_cmd_value(secondaryCC, repcap.SecondaryCC)
+		secondaryCC_cmd_val = self._cmd_group.get_repcap_cmd_value(secondaryCC, repcap.SecondaryCC)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:SCC{secondaryCC_cmd_val}:PLCid {param}')
 
 	def get(self, secondaryCC=repcap.SecondaryCC.Default) -> int:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:SCC<Nr>:PLCid \n
-		Snippet: value: int = driver.configure.multiEval.scc.plcId.get(secondaryCC = repcap.SecondaryCC.Default) \n
+		Snippet: value: int = driver.configure.lteMeas.multiEval.scc.plcId.get(secondaryCC = repcap.SecondaryCC.Default) \n
 		No command help available \n
 			:param secondaryCC: optional repeated capability selector. Default value: CC1 (settable in the interface 'Scc')
 			:return: phs_layer_cell_id: No help available"""
-		secondaryCC_cmd_val = self._base.get_repcap_cmd_value(secondaryCC, repcap.SecondaryCC)
+		secondaryCC_cmd_val = self._cmd_group.get_repcap_cmd_value(secondaryCC, repcap.SecondaryCC)
 		response = self._core.io.query_str(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:SCC{secondaryCC_cmd_val}:PLCid?')
 		return Conversions.str_to_int(response)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Scount.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Scount/__init__.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,68 +1,68 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
-from ....Internal import Conversions
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal import Conversions
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Scount:
-	"""Scount commands group definition. 4 total commands, 1 Sub-groups, 2 group commands"""
+class ScountCls:
+	"""Scount commands group definition. 4 total commands, 1 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("scount", core, parent)
+		self._cmd_group = CommandsGroup("scount", core, parent)
 
 	@property
 	def spectrum(self):
 		"""spectrum commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_spectrum'):
-			from .Scount_.Spectrum import Spectrum
-			self._spectrum = Spectrum(self._core, self._base)
+			from .Spectrum import SpectrumCls
+			self._spectrum = SpectrumCls(self._core, self._cmd_group)
 		return self._spectrum
 
 	def get_modulation(self) -> int:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:SCOunt:MODulation \n
-		Snippet: value: int = driver.configure.multiEval.scount.get_modulation() \n
+		Snippet: value: int = driver.configure.lteMeas.multiEval.scount.get_modulation() \n
 		Specifies the statistic count of the measurement. The statistic count is equal to the number of measurement intervals per
 		single shot. \n
 			:return: statistic_count: No help available
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:MEValuation:SCOunt:MODulation?')
 		return Conversions.str_to_int(response)
 
 	def set_modulation(self, statistic_count: int) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:SCOunt:MODulation \n
-		Snippet: driver.configure.multiEval.scount.set_modulation(statistic_count = 1) \n
+		Snippet: driver.configure.lteMeas.multiEval.scount.set_modulation(statistic_count = 1) \n
 		Specifies the statistic count of the measurement. The statistic count is equal to the number of measurement intervals per
 		single shot. \n
 			:param statistic_count: No help available
 		"""
 		param = Conversions.decimal_value_to_str(statistic_count)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:SCOunt:MODulation {param}')
 
 	def get_power(self) -> int:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:SCOunt:POWer \n
-		Snippet: value: int = driver.configure.multiEval.scount.get_power() \n
+		Snippet: value: int = driver.configure.lteMeas.multiEval.scount.get_power() \n
 		Specifies the statistic count of the measurement. The statistic count is equal to the number of measurement intervals per
 		single shot. \n
 			:return: statistic_count: No help available
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:MEValuation:SCOunt:POWer?')
 		return Conversions.str_to_int(response)
 
 	def set_power(self, statistic_count: int) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:SCOunt:POWer \n
-		Snippet: driver.configure.multiEval.scount.set_power(statistic_count = 1) \n
+		Snippet: driver.configure.lteMeas.multiEval.scount.set_power(statistic_count = 1) \n
 		Specifies the statistic count of the measurement. The statistic count is equal to the number of measurement intervals per
 		single shot. \n
 			:param statistic_count: No help available
 		"""
 		param = Conversions.decimal_value_to_str(statistic_count)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:SCOunt:POWer {param}')
 
-	def clone(self) -> 'Scount':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'ScountCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Scount(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = ScountCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Scount_/Spectrum.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Scount/Spectrum.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,52 +1,52 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
-from .....Internal import Conversions
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal import Conversions
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Spectrum:
-	"""Spectrum commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class SpectrumCls:
+	"""Spectrum commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("spectrum", core, parent)
+		self._cmd_group = CommandsGroup("spectrum", core, parent)
 
 	def get_se_mask(self) -> int:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:SCOunt:SPECtrum:SEMask \n
-		Snippet: value: int = driver.configure.multiEval.scount.spectrum.get_se_mask() \n
+		Snippet: value: int = driver.configure.lteMeas.multiEval.scount.spectrum.get_se_mask() \n
 		Specifies the statistic count of the measurement. The statistic count is equal to the number of measurement intervals per
 		single shot. Separate statistic counts for ACLR and spectrum emission mask measurements are supported. \n
 			:return: statistic_count: No help available
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:MEValuation:SCOunt:SPECtrum:SEMask?')
 		return Conversions.str_to_int(response)
 
 	def set_se_mask(self, statistic_count: int) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:SCOunt:SPECtrum:SEMask \n
-		Snippet: driver.configure.multiEval.scount.spectrum.set_se_mask(statistic_count = 1) \n
+		Snippet: driver.configure.lteMeas.multiEval.scount.spectrum.set_se_mask(statistic_count = 1) \n
 		Specifies the statistic count of the measurement. The statistic count is equal to the number of measurement intervals per
 		single shot. Separate statistic counts for ACLR and spectrum emission mask measurements are supported. \n
 			:param statistic_count: No help available
 		"""
 		param = Conversions.decimal_value_to_str(statistic_count)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:SCOunt:SPECtrum:SEMask {param}')
 
 	def get_aclr(self) -> int:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:SCOunt:SPECtrum:ACLR \n
-		Snippet: value: int = driver.configure.multiEval.scount.spectrum.get_aclr() \n
+		Snippet: value: int = driver.configure.lteMeas.multiEval.scount.spectrum.get_aclr() \n
 		Specifies the statistic count of the measurement. The statistic count is equal to the number of measurement intervals per
 		single shot. Separate statistic counts for ACLR and spectrum emission mask measurements are supported. \n
 			:return: statistic_count: No help available
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:MEValuation:SCOunt:SPECtrum:ACLR?')
 		return Conversions.str_to_int(response)
 
 	def set_aclr(self, statistic_count: int) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:SCOunt:SPECtrum:ACLR \n
-		Snippet: driver.configure.multiEval.scount.spectrum.set_aclr(statistic_count = 1) \n
+		Snippet: driver.configure.lteMeas.multiEval.scount.spectrum.set_aclr(statistic_count = 1) \n
 		Specifies the statistic count of the measurement. The statistic count is equal to the number of measurement intervals per
 		single shot. Separate statistic counts for ACLR and spectrum emission mask measurements are supported. \n
 			:param statistic_count: No help available
 		"""
 		param = Conversions.decimal_value_to_str(statistic_count)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:SCOunt:SPECtrum:ACLR {param}')
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Spectrum.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Evmc/__init__.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,35 +1,27 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Spectrum:
-	"""Spectrum commands group definition. 2 total commands, 2 Sub-groups, 0 group commands"""
+class EvmcCls:
+	"""Evmc commands group definition. 8 total commands, 1 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("spectrum", core, parent)
+		self._cmd_group = CommandsGroup("evmc", core, parent)
 
 	@property
-	def seMask(self):
-		"""seMask commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_seMask'):
-			from .Spectrum_.SeMask import SeMask
-			self._seMask = SeMask(self._core, self._base)
-		return self._seMask
+	def peak(self):
+		"""peak commands group. 4 Sub-classes, 0 commands."""
+		if not hasattr(self, '_peak'):
+			from .Peak import PeakCls
+			self._peak = PeakCls(self._core, self._cmd_group)
+		return self._peak
 
-	@property
-	def aclr(self):
-		"""aclr commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_aclr'):
-			from .Spectrum_.Aclr import Aclr
-			self._aclr = Aclr(self._core, self._base)
-		return self._aclr
-
-	def clone(self) -> 'Spectrum':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'EvmcCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Spectrum(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = EvmcCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Spectrum_/Aclr.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/Modulation/Average/Mod.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,48 +1,43 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
-from .....Internal.StructBase import StructBase
-from .....Internal.ArgStruct import ArgStruct
+from ........Internal.Core import Core
+from ........Internal.CommandsGroup import CommandsGroup
+from ........Internal.StructBase import StructBase
+from ........Internal.ArgStruct import ArgStruct
+from ........ import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Aclr:
-	"""Aclr commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class ModCls:
+	"""Mod commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("aclr", core, parent)
+		self._cmd_group = CommandsGroup("mod", core, parent)
 
 	# noinspection PyTypeChecker
-	class EnableStruct(StructBase):
-		"""Structure for reading output parameters. Fields: \n
-			- Utra_1: bool: No parameter help available
-			- Utra_2: bool: No parameter help available
-			- Eutra: bool: No parameter help available"""
+	class FetchStruct(StructBase):
+		"""Response structure. Fields: \n
+			- Reliability: int: No parameter help available
+			- Iq_Offset: float: No parameter help available
+			- Frequency_Error: float: No parameter help available
+			- Timing_Error: float: No parameter help available"""
 		__meta_args_list = [
-			ArgStruct.scalar_bool('Utra_1'),
-			ArgStruct.scalar_bool('Utra_2'),
-			ArgStruct.scalar_bool('Eutra')]
+			ArgStruct.scalar_int('Reliability', 'Reliability'),
+			ArgStruct.scalar_float('Iq_Offset'),
+			ArgStruct.scalar_float('Frequency_Error'),
+			ArgStruct.scalar_float('Timing_Error')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
-			self.Utra_1: bool = None
-			self.Utra_2: bool = None
-			self.Eutra: bool = None
-
-	def get_enable(self) -> EnableStruct:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:SPECtrum:ACLR:ENABle \n
-		Snippet: value: EnableStruct = driver.configure.multiEval.spectrum.aclr.get_enable() \n
-		Enables or disables the evaluation of the first adjacent UTRA channels, second adjacent UTRA channels and first adjacent
-		E-UTRA channels. \n
-			:return: structure: for return value, see the help for EnableStruct structure arguments.
-		"""
-		return self._core.io.query_struct('CONFigure:LTE:MEASurement<Instance>:MEValuation:SPECtrum:ACLR:ENABle?', self.__class__.EnableStruct())
-
-	def set_enable(self, value: EnableStruct) -> None:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:SPECtrum:ACLR:ENABle \n
-		Snippet: driver.configure.multiEval.spectrum.aclr.set_enable(value = EnableStruct()) \n
-		Enables or disables the evaluation of the first adjacent UTRA channels, second adjacent UTRA channels and first adjacent
-		E-UTRA channels. \n
-			:param value: see the help for EnableStruct structure arguments.
-		"""
-		self._core.io.write_struct('CONFigure:LTE:MEASurement<Instance>:MEValuation:SPECtrum:ACLR:ENABle', value)
+			self.Reliability: int = None
+			self.Iq_Offset: float = None
+			self.Frequency_Error: float = None
+			self.Timing_Error: float = None
+
+	def fetch(self, segment=repcap.Segment.Default) -> FetchStruct:
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:MODulation:AVERage:MOD \n
+		Snippet: value: FetchStruct = driver.lteMeas.multiEval.listPy.segment.modulation.average.mod.fetch(segment = repcap.Segment.Default) \n
+		No command help available \n
+			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
+			:return: structure: for return value, see the help for FetchStruct structure arguments."""
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:MODulation:AVERage:MOD?', self.__class__.FetchStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Spectrum_/SeMask.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Spectrum/SeMask.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,32 +1,32 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
-from .....Internal import Conversions
-from ..... import enums
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal import Conversions
+from ...... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class SeMask:
-	"""SeMask commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class SeMaskCls:
+	"""SeMask commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("seMask", core, parent)
+		self._cmd_group = CommandsGroup("seMask", core, parent)
 
 	# noinspection PyTypeChecker
 	def get_mfilter(self) -> enums.MeasFilter:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:SPECtrum:SEMask:MFILter \n
-		Snippet: value: enums.MeasFilter = driver.configure.multiEval.spectrum.seMask.get_mfilter() \n
+		Snippet: value: enums.MeasFilter = driver.configure.lteMeas.multiEval.spectrum.seMask.get_mfilter() \n
 		Selects the resolution filter type for filter bandwidths of 50 kHz and greater. \n
 			:return: meas_filter: No help available
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:MEValuation:SPECtrum:SEMask:MFILter?')
 		return Conversions.str_to_scalar_enum(response, enums.MeasFilter)
 
 	def set_mfilter(self, meas_filter: enums.MeasFilter) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:SPECtrum:SEMask:MFILter \n
-		Snippet: driver.configure.multiEval.spectrum.seMask.set_mfilter(meas_filter = enums.MeasFilter.BANDpass) \n
+		Snippet: driver.configure.lteMeas.multiEval.spectrum.seMask.set_mfilter(meas_filter = enums.MeasFilter.BANDpass) \n
 		Selects the resolution filter type for filter bandwidths of 50 kHz and greater. \n
 			:param meas_filter: No help available
 		"""
 		param = Conversions.enum_scalar_to_str(meas_filter, enums.MeasFilter)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:SPECtrum:SEMask:MFILter {param}')
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Srs.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Srs.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,32 +1,32 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
-from ....Internal import Conversions
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
+from .....Internal import Conversions
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Srs:
-	"""Srs commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class SrsCls:
+	"""Srs commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("srs", core, parent)
+		self._cmd_group = CommandsGroup("srs", core, parent)
 
 	def get_enable(self) -> bool:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:SRS:ENABle \n
-		Snippet: value: bool = driver.configure.multiEval.srs.get_enable() \n
+		Snippet: value: bool = driver.configure.lteMeas.multiEval.srs.get_enable() \n
 		Specifies whether a sounding reference signal is allowed (ON) or not (OFF) . For Signal Path = Network, the setting is
 		not configurable. \n
-			:return: enable: OFF: no SRS signal ON: SRS signal allowed in the last SC-FDMA symbol of each subframe
+			:return: enable: OFF: No SRS signal is allowed. ON: An SRS signal is allowed in the last SC-FDMA symbol of each subframe.
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:MEValuation:SRS:ENABle?')
 		return Conversions.str_to_bool(response)
 
 	def set_enable(self, enable: bool) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:SRS:ENABle \n
-		Snippet: driver.configure.multiEval.srs.set_enable(enable = False) \n
+		Snippet: driver.configure.lteMeas.multiEval.srs.set_enable(enable = False) \n
 		Specifies whether a sounding reference signal is allowed (ON) or not (OFF) . For Signal Path = Network, the setting is
 		not configurable. \n
-			:param enable: OFF: no SRS signal ON: SRS signal allowed in the last SC-FDMA symbol of each subframe
+			:param enable: OFF: No SRS signal is allowed. ON: An SRS signal is allowed in the last SC-FDMA symbol of each subframe.
 		"""
 		param = Conversions.bool_to_str(enable)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:SRS:ENABle {param}')
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/MultiEval_/Tmode.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Tmode.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,64 +1,64 @@
 from typing import List
 
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
-from ....Internal import Conversions
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
+from .....Internal import Conversions
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Tmode:
-	"""Tmode commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class TmodeCls:
+	"""Tmode commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("tmode", core, parent)
+		self._cmd_group = CommandsGroup("tmode", core, parent)
 
 	def get_scount(self) -> List[int]:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:TMODe:SCOunt \n
-		Snippet: value: List[int] = driver.configure.multiEval.tmode.get_scount() \n
-		Defines the subframe counts for all entries of the TPC Mode list. For definition of the corresponding expected nominal
-		power values, see method RsCMPX_LteMeas.Configure.MultiEval.Tmode.envelopePower. \n
+		Snippet: value: List[int] = driver.configure.lteMeas.multiEval.tmode.get_scount() \n
+		Defines the subframe counts for all entries of the TPC Mode list. For the definition of the corresponding expected
+		nominal power values, see method RsCMPX_LteMeas.Configure.LteMeas.MultiEval.Tmode.envelopePower. \n
 			:return: sub_frame_count: Comma-separated list of 16 values, for list entry number 0 to 15
 		"""
 		response = self._core.io.query_bin_or_ascii_int_list('CONFigure:LTE:MEASurement<Instance>:MEValuation:TMODe:SCOunt?')
 		return response
 
 	def set_scount(self, sub_frame_count: List[int]) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:TMODe:SCOunt \n
-		Snippet: driver.configure.multiEval.tmode.set_scount(sub_frame_count = [1, 2, 3]) \n
-		Defines the subframe counts for all entries of the TPC Mode list. For definition of the corresponding expected nominal
-		power values, see method RsCMPX_LteMeas.Configure.MultiEval.Tmode.envelopePower. \n
+		Snippet: driver.configure.lteMeas.multiEval.tmode.set_scount(sub_frame_count = [1, 2, 3]) \n
+		Defines the subframe counts for all entries of the TPC Mode list. For the definition of the corresponding expected
+		nominal power values, see method RsCMPX_LteMeas.Configure.LteMeas.MultiEval.Tmode.envelopePower. \n
 			:param sub_frame_count: Comma-separated list of 16 values, for list entry number 0 to 15
 		"""
 		param = Conversions.list_to_csv_str(sub_frame_count)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:TMODe:SCOunt {param}')
 
 	def get_envelope_power(self) -> List[float]:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:TMODe:ENPower \n
-		Snippet: value: List[float] = driver.configure.multiEval.tmode.get_envelope_power() \n
-		Defines the expected nominal power values for all entries of the TPC Mode list. For definition of the corresponding
-		subframe count values, see method RsCMPX_LteMeas.Configure.MultiEval.Tmode.scount. \n
-			:return: exp_nom_pow: Comma-separated list of 16 values, for list entry number 0 to 15 The range of the expected nominal power can be calculated as follows: Range (Expected Nominal Power) = Range (Input Power) + External Attenuation - User Margin The input power range is stated in the data sheet.
+		Snippet: value: List[float] = driver.configure.lteMeas.multiEval.tmode.get_envelope_power() \n
+		Defines the expected nominal power values for all entries of the TPC Mode list. For the definition of the corresponding
+		subframe count values, see method RsCMPX_LteMeas.Configure.LteMeas.MultiEval.Tmode.scount. \n
+			:return: exp_nom_pow: Comma-separated list of 16 values, for list entry number 0 to 15 The range of the expected nominal power can be calculated as follows: Range (Expected Nominal Power) = Range (Input Power) + External Attenuation - User Margin The input power range is stated in the specifications document.
 		"""
 		response = self._core.io.query_bin_or_ascii_float_list('CONFigure:LTE:MEASurement<Instance>:MEValuation:TMODe:ENPower?')
 		return response
 
 	def set_envelope_power(self, exp_nom_pow: List[float]) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:TMODe:ENPower \n
-		Snippet: driver.configure.multiEval.tmode.set_envelope_power(exp_nom_pow = [1.1, 2.2, 3.3]) \n
-		Defines the expected nominal power values for all entries of the TPC Mode list. For definition of the corresponding
-		subframe count values, see method RsCMPX_LteMeas.Configure.MultiEval.Tmode.scount. \n
-			:param exp_nom_pow: Comma-separated list of 16 values, for list entry number 0 to 15 The range of the expected nominal power can be calculated as follows: Range (Expected Nominal Power) = Range (Input Power) + External Attenuation - User Margin The input power range is stated in the data sheet.
+		Snippet: driver.configure.lteMeas.multiEval.tmode.set_envelope_power(exp_nom_pow = [1.1, 2.2, 3.3]) \n
+		Defines the expected nominal power values for all entries of the TPC Mode list. For the definition of the corresponding
+		subframe count values, see method RsCMPX_LteMeas.Configure.LteMeas.MultiEval.Tmode.scount. \n
+			:param exp_nom_pow: Comma-separated list of 16 values, for list entry number 0 to 15 The range of the expected nominal power can be calculated as follows: Range (Expected Nominal Power) = Range (Input Power) + External Attenuation - User Margin The input power range is stated in the specifications document.
 		"""
 		param = Conversions.list_to_csv_str(exp_nom_pow)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:TMODe:ENPower {param}')
 
 	def get_rlevel(self) -> List[float]:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:TMODe:RLEVel \n
-		Snippet: value: List[float] = driver.configure.multiEval.tmode.get_rlevel() \n
+		Snippet: value: List[float] = driver.configure.lteMeas.multiEval.tmode.get_rlevel() \n
 		Queries the reference level for all entries of the TPC Mode list. The reference level is calculated from the expected
 		nominal power of each entry and the user margin. \n
-			:return: reference_level: Comma-separated list of 16 values, for list entry number 0 to 15 The range of the reference levels can be calculated as follows: Range (Reference Level) = Range (Input Power) + External Attenuation The input power range is stated in the data sheet.
+			:return: reference_level: Comma-separated list of 16 values, for list entry number 0 to 15 The range of the reference levels can be calculated as follows: Range (Reference Level) = Range (Input Power) + External Attenuation The input power range is stated in the specifications document.
 		"""
 		response = self._core.io.query_bin_or_ascii_float_list('CONFigure:LTE:MEASurement<Instance>:MEValuation:TMODe:RLEVel?')
 		return response
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/Network.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/Network.py`

 * *Files 23% similar despite different names*

```diff
@@ -1,51 +1,70 @@
-from ...Internal.Core import Core
-from ...Internal.CommandsGroup import CommandsGroup
-from ...Internal import Conversions
-from ... import enums
+from ....Internal.Core import Core
+from ....Internal.CommandsGroup import CommandsGroup
+from ....Internal import Conversions
+from .... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Network:
-	"""Network commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class NetworkCls:
+	"""Network commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("network", core, parent)
+		self._cmd_group = CommandsGroup("network", core, parent)
+
+	# noinspection PyTypeChecker
+	def get_rfp_sharing(self) -> enums.NetworkSharing:
+		"""SCPI: CONFigure:LTE:MEASurement<Instance>:NETWork:RFPSharing \n
+		Snippet: value: enums.NetworkSharing = driver.configure.lteMeas.network.get_rfp_sharing() \n
+		Selects the RF path sharing mode for a measurement with coupling to signaling settings. \n
+			:return: sharing: NSHared: not shared (independent connection) OCONnection: only connection shared FSHared: fully shared (only for RF unit)
+		"""
+		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:NETWork:RFPSharing?')
+		return Conversions.str_to_scalar_enum(response, enums.NetworkSharing)
+
+	def set_rfp_sharing(self, sharing: enums.NetworkSharing) -> None:
+		"""SCPI: CONFigure:LTE:MEASurement<Instance>:NETWork:RFPSharing \n
+		Snippet: driver.configure.lteMeas.network.set_rfp_sharing(sharing = enums.NetworkSharing.FSHared) \n
+		Selects the RF path sharing mode for a measurement with coupling to signaling settings. \n
+			:param sharing: NSHared: not shared (independent connection) OCONnection: only connection shared FSHared: fully shared (only for RF unit)
+		"""
+		param = Conversions.enum_scalar_to_str(sharing, enums.NetworkSharing)
+		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:NETWork:RFPSharing {param}')
 
 	# noinspection PyTypeChecker
 	def get_band(self) -> enums.Band:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:NETWork:BAND \n
-		Snippet: value: enums.Band = driver.configure.network.get_band() \n
+		Snippet: value: enums.Band = driver.configure.lteMeas.network.get_band() \n
 		No command help available \n
 			:return: band: No help available
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:NETWork:BAND?')
 		return Conversions.str_to_scalar_enum(response, enums.Band)
 
 	def set_band(self, band: enums.Band) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:NETWork:BAND \n
-		Snippet: driver.configure.network.set_band(band = enums.Band.OB1) \n
+		Snippet: driver.configure.lteMeas.network.set_band(band = enums.Band.OB1) \n
 		No command help available \n
 			:param band: No help available
 		"""
 		param = Conversions.enum_scalar_to_str(band, enums.Band)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:NETWork:BAND {param}')
 
 	# noinspection PyTypeChecker
 	def get_dmode(self) -> enums.Mode:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:NETWork:DMODe \n
-		Snippet: value: enums.Mode = driver.configure.network.get_dmode() \n
+		Snippet: value: enums.Mode = driver.configure.lteMeas.network.get_dmode() \n
 		No command help available \n
 			:return: mode: No help available
 		"""
 		response = self._core.io.query_str_with_opc('CONFigure:LTE:MEASurement<Instance>:NETWork:DMODe?')
 		return Conversions.str_to_scalar_enum(response, enums.Mode)
 
 	def set_dmode(self, mode: enums.Mode) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:NETWork:DMODe \n
-		Snippet: driver.configure.network.set_dmode(mode = enums.Mode.FDD) \n
+		Snippet: driver.configure.lteMeas.network.set_dmode(mode = enums.Mode.FDD) \n
 		No command help available \n
 			:param mode: No help available
 		"""
 		param = Conversions.enum_scalar_to_str(mode, enums.Mode)
 		self._core.io.write_with_opc(f'CONFigure:LTE:MEASurement<Instance>:NETWork:DMODe {param}')
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/Pcc.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/Pcc.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,32 +1,32 @@
-from ...Internal.Core import Core
-from ...Internal.CommandsGroup import CommandsGroup
-from ...Internal import Conversions
-from ... import enums
+from ....Internal.Core import Core
+from ....Internal.CommandsGroup import CommandsGroup
+from ....Internal import Conversions
+from .... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Pcc:
-	"""Pcc commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class PccCls:
+	"""Pcc commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("pcc", core, parent)
+		self._cmd_group = CommandsGroup("pcc", core, parent)
 
 	# noinspection PyTypeChecker
 	def get_channel_bw(self) -> enums.ChannelBandwidth:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>[:PCC]:CBANdwidth \n
-		Snippet: value: enums.ChannelBandwidth = driver.configure.pcc.get_channel_bw() \n
+		Snippet: value: enums.ChannelBandwidth = driver.configure.lteMeas.pcc.get_channel_bw() \n
 		No command help available \n
 			:return: channel_bw: No help available
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:PCC:CBANdwidth?')
 		return Conversions.str_to_scalar_enum(response, enums.ChannelBandwidth)
 
 	def set_channel_bw(self, channel_bw: enums.ChannelBandwidth) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>[:PCC]:CBANdwidth \n
-		Snippet: driver.configure.pcc.set_channel_bw(channel_bw = enums.ChannelBandwidth.B014) \n
+		Snippet: driver.configure.lteMeas.pcc.set_channel_bw(channel_bw = enums.ChannelBandwidth.B014) \n
 		No command help available \n
 			:param channel_bw: No help available
 		"""
 		param = Conversions.enum_scalar_to_str(channel_bw, enums.ChannelBandwidth)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:PCC:CBANdwidth {param}')
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/Prach.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/Prach/__init__.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,248 +1,268 @@
-from ...Internal.Core import Core
-from ...Internal.CommandsGroup import CommandsGroup
-from ...Internal import Conversions
-from ... import enums
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
+from .....Internal import Conversions
+from ..... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Prach:
-	"""Prach commands group definition. 35 total commands, 6 Sub-groups, 9 group commands"""
+class PrachCls:
+	"""Prach commands group definition. 36 total commands, 6 Subgroups, 10 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("prach", core, parent)
+		self._cmd_group = CommandsGroup("prach", core, parent)
 
 	@property
 	def pfOffset(self):
 		"""pfOffset commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_pfOffset'):
-			from .Prach_.PfOffset import PfOffset
-			self._pfOffset = PfOffset(self._core, self._base)
+			from .PfOffset import PfOffsetCls
+			self._pfOffset = PfOffsetCls(self._core, self._cmd_group)
 		return self._pfOffset
 
 	@property
 	def modulation(self):
 		"""modulation commands group. 2 Sub-classes, 3 commands."""
 		if not hasattr(self, '_modulation'):
-			from .Prach_.Modulation import Modulation
-			self._modulation = Modulation(self._core, self._base)
+			from .Modulation import ModulationCls
+			self._modulation = ModulationCls(self._core, self._cmd_group)
 		return self._modulation
 
 	@property
 	def power(self):
 		"""power commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_power'):
-			from .Prach_.Power import Power
-			self._power = Power(self._core, self._base)
+			from .Power import PowerCls
+			self._power = PowerCls(self._core, self._cmd_group)
 		return self._power
 
 	@property
 	def scount(self):
 		"""scount commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_scount'):
-			from .Prach_.Scount import Scount
-			self._scount = Scount(self._core, self._base)
+			from .Scount import ScountCls
+			self._scount = ScountCls(self._core, self._cmd_group)
 		return self._scount
 
 	@property
 	def result(self):
 		"""result commands group. 0 Sub-classes, 9 commands."""
 		if not hasattr(self, '_result'):
-			from .Prach_.Result import Result
-			self._result = Result(self._core, self._base)
+			from .Result import ResultCls
+			self._result = ResultCls(self._core, self._cmd_group)
 		return self._result
 
 	@property
 	def limit(self):
-		"""limit commands group. 0 Sub-classes, 5 commands."""
+		"""limit commands group. 4 Sub-classes, 1 commands."""
 		if not hasattr(self, '_limit'):
-			from .Prach_.Limit import Limit
-			self._limit = Limit(self._core, self._base)
+			from .Limit import LimitCls
+			self._limit = LimitCls(self._core, self._cmd_group)
 		return self._limit
 
 	# noinspection PyTypeChecker
 	def get_view(self) -> enums.ViewPrach:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:PRACh:VIEW \n
-		Snippet: value: enums.ViewPrach = driver.configure.prach.get_view() \n
+		Snippet: value: enums.ViewPrach = driver.configure.lteMeas.prach.get_view() \n
 		No command help available \n
 			:return: view: No help available
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:PRACh:VIEW?')
 		return Conversions.str_to_scalar_enum(response, enums.ViewPrach)
 
 	def set_view(self, view: enums.ViewPrach) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:PRACh:VIEW \n
-		Snippet: driver.configure.prach.set_view(view = enums.ViewPrach.EVMagnitude) \n
+		Snippet: driver.configure.lteMeas.prach.set_view(view = enums.ViewPrach.EVMagnitude) \n
 		No command help available \n
 			:param view: No help available
 		"""
 		param = Conversions.enum_scalar_to_str(view, enums.ViewPrach)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:PRACh:VIEW {param}')
 
 	def get_timeout(self) -> float:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:PRACh:TOUT \n
-		Snippet: value: float = driver.configure.prach.get_timeout() \n
+		Snippet: value: float = driver.configure.lteMeas.prach.get_timeout() \n
 		Defines a timeout for the measurement. The timer is started when the measurement is initiated via a READ or INIT command.
-		It is not started if the measurement is initiated manually (ON | OFF key or RESTART | STOP key) . When the measurement
-		has completed the first measurement cycle (first single shot) , the statistical depth is reached and the timer is reset.
-		If the first measurement cycle has not been completed when the timer expires, the measurement is stopped. The measurement
-		state changes to RDY. The reliability indicator is set to 1, indicating that a measurement timeout occurred.
-		Still running READ, FETCh or CALCulate commands are completed, returning the available results. At least for some results,
-		there are no values at all or the statistical depth has not been reached. A timeout of 0 s corresponds to an infinite
-		measurement timeout. \n
+		It is not started if the measurement is initiated manually. When the measurement has completed the first measurement
+		cycle (first single shot) , the statistical depth is reached and the timer is reset. If the first measurement cycle has
+		not been completed when the timer expires, the measurement is stopped. The measurement state changes to RDY.
+		The reliability indicator is set to 1, indicating that a measurement timeout occurred. Still running READ, FETCh or
+		CALCulate commands are completed, returning the available results. At least for some results, there are no values at all
+		or the statistical depth has not been reached. A timeout of 0 s corresponds to an infinite measurement timeout. \n
 			:return: timeout: No help available
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:PRACh:TOUT?')
 		return Conversions.str_to_float(response)
 
 	def set_timeout(self, timeout: float) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:PRACh:TOUT \n
-		Snippet: driver.configure.prach.set_timeout(timeout = 1.0) \n
+		Snippet: driver.configure.lteMeas.prach.set_timeout(timeout = 1.0) \n
 		Defines a timeout for the measurement. The timer is started when the measurement is initiated via a READ or INIT command.
-		It is not started if the measurement is initiated manually (ON | OFF key or RESTART | STOP key) . When the measurement
-		has completed the first measurement cycle (first single shot) , the statistical depth is reached and the timer is reset.
-		If the first measurement cycle has not been completed when the timer expires, the measurement is stopped. The measurement
-		state changes to RDY. The reliability indicator is set to 1, indicating that a measurement timeout occurred.
-		Still running READ, FETCh or CALCulate commands are completed, returning the available results. At least for some results,
-		there are no values at all or the statistical depth has not been reached. A timeout of 0 s corresponds to an infinite
-		measurement timeout. \n
+		It is not started if the measurement is initiated manually. When the measurement has completed the first measurement
+		cycle (first single shot) , the statistical depth is reached and the timer is reset. If the first measurement cycle has
+		not been completed when the timer expires, the measurement is stopped. The measurement state changes to RDY.
+		The reliability indicator is set to 1, indicating that a measurement timeout occurred. Still running READ, FETCh or
+		CALCulate commands are completed, returning the available results. At least for some results, there are no values at all
+		or the statistical depth has not been reached. A timeout of 0 s corresponds to an infinite measurement timeout. \n
 			:param timeout: No help available
 		"""
 		param = Conversions.decimal_value_to_str(timeout)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:PRACh:TOUT {param}')
 
 	# noinspection PyTypeChecker
 	def get_repetition(self) -> enums.Repeat:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:PRACh:REPetition \n
-		Snippet: value: enums.Repeat = driver.configure.prach.get_repetition() \n
+		Snippet: value: enums.Repeat = driver.configure.lteMeas.prach.get_repetition() \n
 		Specifies the repetition mode of the measurement. The repetition mode specifies whether the measurement is stopped after
 		a single shot or repeated continuously. Use CONFigure:..:MEAS<i>:...:SCOunt to determine the number of measurement
 		intervals per single shot. \n
 			:return: repetition: SINGleshot: Single-shot measurement CONTinuous: Continuous measurement
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:PRACh:REPetition?')
 		return Conversions.str_to_scalar_enum(response, enums.Repeat)
 
 	def set_repetition(self, repetition: enums.Repeat) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:PRACh:REPetition \n
-		Snippet: driver.configure.prach.set_repetition(repetition = enums.Repeat.CONTinuous) \n
+		Snippet: driver.configure.lteMeas.prach.set_repetition(repetition = enums.Repeat.CONTinuous) \n
 		Specifies the repetition mode of the measurement. The repetition mode specifies whether the measurement is stopped after
 		a single shot or repeated continuously. Use CONFigure:..:MEAS<i>:...:SCOunt to determine the number of measurement
 		intervals per single shot. \n
 			:param repetition: SINGleshot: Single-shot measurement CONTinuous: Continuous measurement
 		"""
 		param = Conversions.enum_scalar_to_str(repetition, enums.Repeat)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:PRACh:REPetition {param}')
 
 	# noinspection PyTypeChecker
 	def get_scondition(self) -> enums.StopCondition:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:PRACh:SCONdition \n
-		Snippet: value: enums.StopCondition = driver.configure.prach.get_scondition() \n
+		Snippet: value: enums.StopCondition = driver.configure.lteMeas.prach.get_scondition() \n
 		Qualifies whether the measurement is stopped after a failed limit check or continued. SLFail means that the measurement
 		is stopped and reaches the RDY state when one of the results exceeds the limits. \n
-			:return: stop_condition: NONE: Continue measurement irrespective of the limit check SLFail: Stop measurement on limit failure
+			:return: stop_condition: NONE: Continue measurement irrespective of the limit check. SLFail: Stop measurement on limit failure.
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:PRACh:SCONdition?')
 		return Conversions.str_to_scalar_enum(response, enums.StopCondition)
 
 	def set_scondition(self, stop_condition: enums.StopCondition) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:PRACh:SCONdition \n
-		Snippet: driver.configure.prach.set_scondition(stop_condition = enums.StopCondition.NONE) \n
+		Snippet: driver.configure.lteMeas.prach.set_scondition(stop_condition = enums.StopCondition.NONE) \n
 		Qualifies whether the measurement is stopped after a failed limit check or continued. SLFail means that the measurement
 		is stopped and reaches the RDY state when one of the results exceeds the limits. \n
-			:param stop_condition: NONE: Continue measurement irrespective of the limit check SLFail: Stop measurement on limit failure
+			:param stop_condition: NONE: Continue measurement irrespective of the limit check. SLFail: Stop measurement on limit failure.
 		"""
 		param = Conversions.enum_scalar_to_str(stop_condition, enums.StopCondition)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:PRACh:SCONdition {param}')
 
 	def get_mo_exception(self) -> bool:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:PRACh:MOEXception \n
-		Snippet: value: bool = driver.configure.prach.get_mo_exception() \n
-		Specifies whether measurement results that the R&S CMX500 identifies as faulty or inaccurate are rejected. \n
-			:return: meas_on_exception: OFF: Faulty results are rejected ON: Results are never rejected
+		Snippet: value: bool = driver.configure.lteMeas.prach.get_mo_exception() \n
+		Specifies whether measurement results that the CMX500 identifies as faulty or inaccurate are rejected. \n
+			:return: meas_on_exception: OFF: Faulty results are rejected. ON: Results are never rejected.
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:PRACh:MOEXception?')
 		return Conversions.str_to_bool(response)
 
 	def set_mo_exception(self, meas_on_exception: bool) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:PRACh:MOEXception \n
-		Snippet: driver.configure.prach.set_mo_exception(meas_on_exception = False) \n
-		Specifies whether measurement results that the R&S CMX500 identifies as faulty or inaccurate are rejected. \n
-			:param meas_on_exception: OFF: Faulty results are rejected ON: Results are never rejected
+		Snippet: driver.configure.lteMeas.prach.set_mo_exception(meas_on_exception = False) \n
+		Specifies whether measurement results that the CMX500 identifies as faulty or inaccurate are rejected. \n
+			:param meas_on_exception: OFF: Faulty results are rejected. ON: Results are never rejected.
 		"""
 		param = Conversions.bool_to_str(meas_on_exception)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:PRACh:MOEXception {param}')
 
 	def get_pc_index(self) -> int:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:PRACh:PCINdex \n
-		Snippet: value: int = driver.configure.prach.get_pc_index() \n
+		Snippet: value: int = driver.configure.lteMeas.prach.get_pc_index() \n
 		The PRACH configuration index identifies the PRACH configuration used by the UE (preamble format, which resources in the
-		time domain are allowed for transmission of preambles etc.) . \n
+		time domain are allowed for transmission of preambles etc.) .
+		For Signal Path = Network, use[CONFigure:]SIGNaling:LTE:CELL:POWer:UL:CINDex. \n
 			:return: prach_conf_index: No help available
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:PRACh:PCINdex?')
 		return Conversions.str_to_int(response)
 
 	def set_pc_index(self, prach_conf_index: int) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:PRACh:PCINdex \n
-		Snippet: driver.configure.prach.set_pc_index(prach_conf_index = 1) \n
+		Snippet: driver.configure.lteMeas.prach.set_pc_index(prach_conf_index = 1) \n
 		The PRACH configuration index identifies the PRACH configuration used by the UE (preamble format, which resources in the
-		time domain are allowed for transmission of preambles etc.) . \n
+		time domain are allowed for transmission of preambles etc.) .
+		For Signal Path = Network, use[CONFigure:]SIGNaling:LTE:CELL:POWer:UL:CINDex. \n
 			:param prach_conf_index: No help available
 		"""
 		param = Conversions.decimal_value_to_str(prach_conf_index)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:PRACh:PCINdex {param}')
 
+	def get_ssymbol(self) -> int:
+		"""SCPI: CONFigure:LTE:MEASurement<Instance>:PRACh:SSYMbol \n
+		Snippet: value: int = driver.configure.lteMeas.prach.get_ssymbol() \n
+		Selects the OFDM symbol to be evaluated for single-symbol modulation result diagrams. The number of OFDM symbols in the
+		preamble (<no of symbols>) depends on the preamble format, see Table 'Preambles in the time domain'. \n
+			:return: selected_symbol: No help available
+		"""
+		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:PRACh:SSYMbol?')
+		return Conversions.str_to_int(response)
+
+	def set_ssymbol(self, selected_symbol: int) -> None:
+		"""SCPI: CONFigure:LTE:MEASurement<Instance>:PRACh:SSYMbol \n
+		Snippet: driver.configure.lteMeas.prach.set_ssymbol(selected_symbol = 1) \n
+		Selects the OFDM symbol to be evaluated for single-symbol modulation result diagrams. The number of OFDM symbols in the
+		preamble (<no of symbols>) depends on the preamble format, see Table 'Preambles in the time domain'. \n
+			:param selected_symbol: No help available
+		"""
+		param = Conversions.decimal_value_to_str(selected_symbol)
+		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:PRACh:SSYMbol {param}')
+
 	def get_pformat(self) -> int:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:PRACh:PFORmat \n
-		Snippet: value: int = driver.configure.prach.get_pformat() \n
+		Snippet: value: int = driver.configure.lteMeas.prach.get_pformat() \n
 		No command help available \n
 			:return: preamble_format: No help available
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:PRACh:PFORmat?')
 		return Conversions.str_to_int(response)
 
 	def get_no_preambles(self) -> int:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:PRACh:NOPReambles \n
-		Snippet: value: int = driver.configure.prach.get_no_preambles() \n
+		Snippet: value: int = driver.configure.lteMeas.prach.get_no_preambles() \n
 		Specifies the number of preambles to be captured per measurement interval. \n
 			:return: number_preamble: No help available
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:PRACh:NOPReambles?')
 		return Conversions.str_to_int(response)
 
 	def set_no_preambles(self, number_preamble: int) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:PRACh:NOPReambles \n
-		Snippet: driver.configure.prach.set_no_preambles(number_preamble = 1) \n
+		Snippet: driver.configure.lteMeas.prach.set_no_preambles(number_preamble = 1) \n
 		Specifies the number of preambles to be captured per measurement interval. \n
 			:param number_preamble: No help available
 		"""
 		param = Conversions.decimal_value_to_str(number_preamble)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:PRACh:NOPReambles {param}')
 
 	# noinspection PyTypeChecker
 	def get_po_preambles(self) -> enums.PeriodPreamble:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:PRACh:POPReambles \n
-		Snippet: value: enums.PeriodPreamble = driver.configure.prach.get_po_preambles() \n
+		Snippet: value: enums.PeriodPreamble = driver.configure.lteMeas.prach.get_po_preambles() \n
 		Specifies the periodicity of preambles to be captured for multi-preamble result views. \n
 			:return: period_preamble: MS05: 5 ms MS10: 10 ms MS20: 20 ms
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:PRACh:POPReambles?')
 		return Conversions.str_to_scalar_enum(response, enums.PeriodPreamble)
 
 	def set_po_preambles(self, period_preamble: enums.PeriodPreamble) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:PRACh:POPReambles \n
-		Snippet: driver.configure.prach.set_po_preambles(period_preamble = enums.PeriodPreamble.MS05) \n
+		Snippet: driver.configure.lteMeas.prach.set_po_preambles(period_preamble = enums.PeriodPreamble.MS05) \n
 		Specifies the periodicity of preambles to be captured for multi-preamble result views. \n
 			:param period_preamble: MS05: 5 ms MS10: 10 ms MS20: 20 ms
 		"""
 		param = Conversions.enum_scalar_to_str(period_preamble, enums.PeriodPreamble)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:PRACh:POPReambles {param}')
 
-	def clone(self) -> 'Prach':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'PrachCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Prach(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = PrachCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/Prach_/Limit.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Limit/Qpsk/__init__.py`

 * *Files 27% similar despite different names*

```diff
@@ -1,160 +1,180 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
-from ....Internal import Conversions
-from ....Internal.StructBase import StructBase
-from ....Internal.ArgStruct import ArgStruct
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal import Conversions
+from .......Internal.StructBase import StructBase
+from .......Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Limit:
-	"""Limit commands group definition. 5 total commands, 0 Sub-groups, 5 group commands"""
+class QpskCls:
+	"""Qpsk commands group definition. 9 total commands, 5 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("limit", core, parent)
+		self._cmd_group = CommandsGroup("qpsk", core, parent)
 
-	# noinspection PyTypeChecker
-	class EvMagnitudeStruct(StructBase):
-		"""Structure for reading output parameters. Fields: \n
-			- Rms: float or bool: No parameter help available
-			- Peak: float or bool: No parameter help available"""
-		__meta_args_list = [
-			ArgStruct.scalar_float_ext('Rms'),
-			ArgStruct.scalar_float_ext('Peak')]
+	@property
+	def evMagnitude(self):
+		"""evMagnitude commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_evMagnitude'):
+			from .EvMagnitude import EvMagnitudeCls
+			self._evMagnitude = EvMagnitudeCls(self._core, self._cmd_group)
+		return self._evMagnitude
+
+	@property
+	def merror(self):
+		"""merror commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_merror'):
+			from .Merror import MerrorCls
+			self._merror = MerrorCls(self._core, self._cmd_group)
+		return self._merror
+
+	@property
+	def perror(self):
+		"""perror commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_perror'):
+			from .Perror import PerrorCls
+			self._perror = PerrorCls(self._core, self._cmd_group)
+		return self._perror
+
+	@property
+	def iqOffset(self):
+		"""iqOffset commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_iqOffset'):
+			from .IqOffset import IqOffsetCls
+			self._iqOffset = IqOffsetCls(self._core, self._cmd_group)
+		return self._iqOffset
+
+	@property
+	def ibe(self):
+		"""ibe commands group. 1 Sub-classes, 1 commands."""
+		if not hasattr(self, '_ibe'):
+			from .Ibe import IbeCls
+			self._ibe = IbeCls(self._core, self._cmd_group)
+		return self._ibe
 
-		def __init__(self):
-			StructBase.__init__(self, self)
-			self.Rms: float or bool = None
-			self.Peak: float or bool = None
-
-	def get_ev_magnitude(self) -> EvMagnitudeStruct:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:PRACh:LIMit:EVMagnitude \n
-		Snippet: value: EvMagnitudeStruct = driver.configure.prach.limit.get_ev_magnitude() \n
-		Defines upper limits for the RMS and peak values of the error vector magnitude (EVM) . \n
-			:return: structure: for return value, see the help for EvMagnitudeStruct structure arguments.
-		"""
-		return self._core.io.query_struct('CONFigure:LTE:MEASurement<Instance>:PRACh:LIMit:EVMagnitude?', self.__class__.EvMagnitudeStruct())
-
-	def set_ev_magnitude(self, value: EvMagnitudeStruct) -> None:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:PRACh:LIMit:EVMagnitude \n
-		Snippet: driver.configure.prach.limit.set_ev_magnitude(value = EvMagnitudeStruct()) \n
-		Defines upper limits for the RMS and peak values of the error vector magnitude (EVM) . \n
-			:param value: see the help for EvMagnitudeStruct structure arguments.
+	def get_freq_error(self) -> float or bool:
+		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QPSK:FERRor \n
+		Snippet: value: float or bool = driver.configure.lteMeas.multiEval.limit.qpsk.get_freq_error() \n
+		Defines an upper limit for the carrier frequency error (QPSK modulation) . \n
+			:return: frequency_error: (float or boolean) No help available
 		"""
-		self._core.io.write_struct('CONFigure:LTE:MEASurement<Instance>:PRACh:LIMit:EVMagnitude', value)
-
-	# noinspection PyTypeChecker
-	class MerrorStruct(StructBase):
-		"""Structure for reading output parameters. Fields: \n
-			- Rms: float or bool: No parameter help available
-			- Peak: float or bool: No parameter help available"""
-		__meta_args_list = [
-			ArgStruct.scalar_float_ext('Rms'),
-			ArgStruct.scalar_float_ext('Peak')]
-
-		def __init__(self):
-			StructBase.__init__(self, self)
-			self.Rms: float or bool = None
-			self.Peak: float or bool = None
+		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QPSK:FERRor?')
+		return Conversions.str_to_float_or_bool(response)
 
-	def get_merror(self) -> MerrorStruct:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:PRACh:LIMit:MERRor \n
-		Snippet: value: MerrorStruct = driver.configure.prach.limit.get_merror() \n
-		Defines upper limits for the RMS and peak values of the magnitude error. \n
-			:return: structure: for return value, see the help for MerrorStruct structure arguments.
-		"""
-		return self._core.io.query_struct('CONFigure:LTE:MEASurement<Instance>:PRACh:LIMit:MERRor?', self.__class__.MerrorStruct())
-
-	def set_merror(self, value: MerrorStruct) -> None:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:PRACh:LIMit:MERRor \n
-		Snippet: driver.configure.prach.limit.set_merror(value = MerrorStruct()) \n
-		Defines upper limits for the RMS and peak values of the magnitude error. \n
-			:param value: see the help for MerrorStruct structure arguments.
+	def set_freq_error(self, frequency_error: float or bool) -> None:
+		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QPSK:FERRor \n
+		Snippet: driver.configure.lteMeas.multiEval.limit.qpsk.set_freq_error(frequency_error = 1.0) \n
+		Defines an upper limit for the carrier frequency error (QPSK modulation) . \n
+			:param frequency_error: (float or boolean) No help available
 		"""
-		self._core.io.write_struct('CONFigure:LTE:MEASurement<Instance>:PRACh:LIMit:MERRor', value)
+		param = Conversions.decimal_or_bool_value_to_str(frequency_error)
+		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QPSK:FERRor {param}')
 
 	# noinspection PyTypeChecker
-	class PerrorStruct(StructBase):
-		"""Structure for reading output parameters. Fields: \n
-			- Rms: float or bool: No parameter help available
-			- Peak: float or bool: No parameter help available"""
+	class SflatnessStruct(StructBase):  # From WriteStructDefinition CmdPropertyTemplate.xml
+		"""Structure for setting input parameters. Fields: \n
+			- Enable: bool: No parameter help available
+			- Lower: float: No parameter help available
+			- Upper: float: No parameter help available
+			- Edge_Lower: float: No parameter help available
+			- Edge_Upper: float: No parameter help available
+			- Edge_Frequency: float: No parameter help available"""
 		__meta_args_list = [
-			ArgStruct.scalar_float_ext('Rms'),
-			ArgStruct.scalar_float_ext('Peak')]
+			ArgStruct.scalar_bool('Enable'),
+			ArgStruct.scalar_float('Lower'),
+			ArgStruct.scalar_float('Upper'),
+			ArgStruct.scalar_float('Edge_Lower'),
+			ArgStruct.scalar_float('Edge_Upper'),
+			ArgStruct.scalar_float('Edge_Frequency')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
-			self.Rms: float or bool = None
-			self.Peak: float or bool = None
-
-	def get_perror(self) -> PerrorStruct:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:PRACh:LIMit:PERRor \n
-		Snippet: value: PerrorStruct = driver.configure.prach.limit.get_perror() \n
-		Defines symmetric limits for the RMS and peak values of the phase error. The limit check fails if the absolute value of
-		the measured phase error exceeds the specified values. \n
-			:return: structure: for return value, see the help for PerrorStruct structure arguments.
-		"""
-		return self._core.io.query_struct('CONFigure:LTE:MEASurement<Instance>:PRACh:LIMit:PERRor?', self.__class__.PerrorStruct())
-
-	def set_perror(self, value: PerrorStruct) -> None:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:PRACh:LIMit:PERRor \n
-		Snippet: driver.configure.prach.limit.set_perror(value = PerrorStruct()) \n
-		Defines symmetric limits for the RMS and peak values of the phase error. The limit check fails if the absolute value of
-		the measured phase error exceeds the specified values. \n
-			:param value: see the help for PerrorStruct structure arguments.
-		"""
-		self._core.io.write_struct('CONFigure:LTE:MEASurement<Instance>:PRACh:LIMit:PERRor', value)
-
-	def get_freq_error(self) -> float or bool:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:PRACh:LIMit:FERRor \n
-		Snippet: value: float or bool = driver.configure.prach.limit.get_freq_error() \n
-		Defines an upper limit for the carrier frequency error. \n
-			:return: frequency_error: No help available
-		"""
-		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:PRACh:LIMit:FERRor?')
-		return Conversions.str_to_float_or_bool(response)
-
-	def set_freq_error(self, frequency_error: float or bool) -> None:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:PRACh:LIMit:FERRor \n
-		Snippet: driver.configure.prach.limit.set_freq_error(frequency_error = 1.0) \n
-		Defines an upper limit for the carrier frequency error. \n
-			:param frequency_error: No help available
+			self.Enable: bool = None
+			self.Lower: float = None
+			self.Upper: float = None
+			self.Edge_Lower: float = None
+			self.Edge_Upper: float = None
+			self.Edge_Frequency: float = None
+
+	def get_sflatness(self) -> SflatnessStruct:
+		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QPSK:SFLatness \n
+		Snippet: value: SflatnessStruct = driver.configure.lteMeas.multiEval.limit.qpsk.get_sflatness() \n
+		No command help available \n
+			:return: structure: for return value, see the help for SflatnessStruct structure arguments.
+		"""
+		return self._core.io.query_struct('CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QPSK:SFLatness?', self.__class__.SflatnessStruct())
+
+	def set_sflatness(self, value: SflatnessStruct) -> None:
+		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QPSK:SFLatness \n
+		Snippet with structure: \n
+		structure = driver.configure.lteMeas.multiEval.limit.qpsk.SflatnessStruct() \n
+		structure.Enable: bool = False \n
+		structure.Lower: float = 1.0 \n
+		structure.Upper: float = 1.0 \n
+		structure.Edge_Lower: float = 1.0 \n
+		structure.Edge_Upper: float = 1.0 \n
+		structure.Edge_Frequency: float = 1.0 \n
+		driver.configure.lteMeas.multiEval.limit.qpsk.set_sflatness(value = structure) \n
+		No command help available \n
+			:param value: see the help for SflatnessStruct structure arguments.
 		"""
-		param = Conversions.decimal_or_bool_value_to_str(frequency_error)
-		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:PRACh:LIMit:FERRor {param}')
+		self._core.io.write_struct('CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QPSK:SFLatness', value)
 
 	# noinspection PyTypeChecker
-	class PdynamicsStruct(StructBase):
-		"""Structure for reading output parameters. Fields: \n
+	class EsFlatnessStruct(StructBase):  # From WriteStructDefinition CmdPropertyTemplate.xml
+		"""Structure for setting input parameters. Fields: \n
 			- Enable: bool: OFF: disables the limit check ON: enables the limit check
-			- On_Power_Upper: float: Upper limit for the ON power
-			- On_Power_Lower: float: Lower limit for the ON power
-			- Off_Power_Upper: float: Upper limit for the OFF power"""
+			- Range_1: float: Upper limit for max(range 1) - min(range 1)
+			- Range_2: float: Upper limit for max(range 2) - min(range 2)
+			- Max_1_Min_2: float: Upper limit for max(range 1) - min(range 2)
+			- Max_2_Min_1: float: Upper limit for max(range 2) - min(range 1)
+			- Edge_Frequency: float: Frequency band edge distance of border between range 1 and range 2"""
 		__meta_args_list = [
 			ArgStruct.scalar_bool('Enable'),
-			ArgStruct.scalar_float('On_Power_Upper'),
-			ArgStruct.scalar_float('On_Power_Lower'),
-			ArgStruct.scalar_float('Off_Power_Upper')]
+			ArgStruct.scalar_float('Range_1'),
+			ArgStruct.scalar_float('Range_2'),
+			ArgStruct.scalar_float('Max_1_Min_2'),
+			ArgStruct.scalar_float('Max_2_Min_1'),
+			ArgStruct.scalar_float('Edge_Frequency')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Enable: bool = None
-			self.On_Power_Upper: float = None
-			self.On_Power_Lower: float = None
-			self.Off_Power_Upper: float = None
-
-	def get_pdynamics(self) -> PdynamicsStruct:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:PRACh:LIMit:PDYNamics \n
-		Snippet: value: PdynamicsStruct = driver.configure.prach.limit.get_pdynamics() \n
-		Defines limits for the ON power and OFF power determined with the power dynamics measurement. \n
-			:return: structure: for return value, see the help for PdynamicsStruct structure arguments.
-		"""
-		return self._core.io.query_struct('CONFigure:LTE:MEASurement<Instance>:PRACh:LIMit:PDYNamics?', self.__class__.PdynamicsStruct())
-
-	def set_pdynamics(self, value: PdynamicsStruct) -> None:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:PRACh:LIMit:PDYNamics \n
-		Snippet: driver.configure.prach.limit.set_pdynamics(value = PdynamicsStruct()) \n
-		Defines limits for the ON power and OFF power determined with the power dynamics measurement. \n
-			:param value: see the help for PdynamicsStruct structure arguments.
-		"""
-		self._core.io.write_struct('CONFigure:LTE:MEASurement<Instance>:PRACh:LIMit:PDYNamics', value)
+			self.Range_1: float = None
+			self.Range_2: float = None
+			self.Max_1_Min_2: float = None
+			self.Max_2_Min_1: float = None
+			self.Edge_Frequency: float = None
+
+	def get_es_flatness(self) -> EsFlatnessStruct:
+		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QPSK:ESFLatness \n
+		Snippet: value: EsFlatnessStruct = driver.configure.lteMeas.multiEval.limit.qpsk.get_es_flatness() \n
+		Defines limits for the equalizer spectrum flatness (QPSK modulation) . \n
+			:return: structure: for return value, see the help for EsFlatnessStruct structure arguments.
+		"""
+		return self._core.io.query_struct('CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QPSK:ESFLatness?', self.__class__.EsFlatnessStruct())
+
+	def set_es_flatness(self, value: EsFlatnessStruct) -> None:
+		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QPSK:ESFLatness \n
+		Snippet with structure: \n
+		structure = driver.configure.lteMeas.multiEval.limit.qpsk.EsFlatnessStruct() \n
+		structure.Enable: bool = False \n
+		structure.Range_1: float = 1.0 \n
+		structure.Range_2: float = 1.0 \n
+		structure.Max_1_Min_2: float = 1.0 \n
+		structure.Max_2_Min_1: float = 1.0 \n
+		structure.Edge_Frequency: float = 1.0 \n
+		driver.configure.lteMeas.multiEval.limit.qpsk.set_es_flatness(value = structure) \n
+		Defines limits for the equalizer spectrum flatness (QPSK modulation) . \n
+			:param value: see the help for EsFlatnessStruct structure arguments.
+		"""
+		self._core.io.write_struct('CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QPSK:ESFLatness', value)
+
+	def clone(self) -> 'QpskCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
+		Also copies all the existing default Repeated Capabilities setting,
+		which you can change independently without affecting the original group"""
+		new_group = QpskCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
+		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/Prach_/Modulation.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/Prach/Modulation/__init__.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,94 +1,96 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
-from ....Internal import Conversions
-from .... import enums
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal import Conversions
+from ...... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Modulation:
-	"""Modulation commands group definition. 7 total commands, 2 Sub-groups, 3 group commands"""
+class ModulationCls:
+	"""Modulation commands group definition. 7 total commands, 2 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("modulation", core, parent)
+		self._cmd_group = CommandsGroup("modulation", core, parent)
 
 	@property
 	def sindex(self):
 		"""sindex commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_sindex'):
-			from .Modulation_.Sindex import Sindex
-			self._sindex = Sindex(self._core, self._base)
+			from .Sindex import SindexCls
+			self._sindex = SindexCls(self._core, self._cmd_group)
 		return self._sindex
 
 	@property
 	def ewLength(self):
 		"""ewLength commands group. 1 Sub-classes, 1 commands."""
 		if not hasattr(self, '_ewLength'):
-			from .Modulation_.EwLength import EwLength
-			self._ewLength = EwLength(self._core, self._base)
+			from .EwLength import EwLengthCls
+			self._ewLength = EwLengthCls(self._core, self._cmd_group)
 		return self._ewLength
 
 	def get_lrs_index(self) -> int:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:PRACh:MODulation:LRSindex \n
-		Snippet: value: int = driver.configure.prach.modulation.get_lrs_index() \n
-		Specifies the logical root sequence index to be used for generation of the preamble sequence. \n
+		Snippet: value: int = driver.configure.lteMeas.prach.modulation.get_lrs_index() \n
+		Specifies the logical root sequence index to be used for generation of the preamble sequence. For Signal Path = Network,
+		the setting is not configurable. \n
 			:return: log_root_seq_index: No help available
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:PRACh:MODulation:LRSindex?')
 		return Conversions.str_to_int(response)
 
 	def set_lrs_index(self, log_root_seq_index: int) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:PRACh:MODulation:LRSindex \n
-		Snippet: driver.configure.prach.modulation.set_lrs_index(log_root_seq_index = 1) \n
-		Specifies the logical root sequence index to be used for generation of the preamble sequence. \n
+		Snippet: driver.configure.lteMeas.prach.modulation.set_lrs_index(log_root_seq_index = 1) \n
+		Specifies the logical root sequence index to be used for generation of the preamble sequence. For Signal Path = Network,
+		the setting is not configurable. \n
 			:param log_root_seq_index: No help available
 		"""
 		param = Conversions.decimal_value_to_str(log_root_seq_index)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:PRACh:MODulation:LRSindex {param}')
 
 	def get_zcz_config(self) -> int:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:PRACh:MODulation:ZCZConfig \n
-		Snippet: value: int = driver.configure.prach.modulation.get_zcz_config() \n
+		Snippet: value: int = driver.configure.lteMeas.prach.modulation.get_zcz_config() \n
 		Specifies the zero correlation zone config, i.e. which NCS value of an NCS set is used for generation of the preamble
-		sequence. \n
+		sequence. For Signal Path = Network, the setting is not configurable. \n
 			:return: zero_corr_zone_con: No help available
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:PRACh:MODulation:ZCZConfig?')
 		return Conversions.str_to_int(response)
 
 	def set_zcz_config(self, zero_corr_zone_con: int) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:PRACh:MODulation:ZCZConfig \n
-		Snippet: driver.configure.prach.modulation.set_zcz_config(zero_corr_zone_con = 1) \n
+		Snippet: driver.configure.lteMeas.prach.modulation.set_zcz_config(zero_corr_zone_con = 1) \n
 		Specifies the zero correlation zone config, i.e. which NCS value of an NCS set is used for generation of the preamble
-		sequence. \n
+		sequence. For Signal Path = Network, the setting is not configurable. \n
 			:param zero_corr_zone_con: No help available
 		"""
 		param = Conversions.decimal_value_to_str(zero_corr_zone_con)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:PRACh:MODulation:ZCZConfig {param}')
 
 	# noinspection PyTypeChecker
 	def get_ew_position(self) -> enums.LowHigh:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:PRACh:MODulation:EWPosition \n
-		Snippet: value: enums.LowHigh = driver.configure.prach.modulation.get_ew_position() \n
+		Snippet: value: enums.LowHigh = driver.configure.lteMeas.prach.modulation.get_ew_position() \n
 		Specifies the position of the EVM window used for calculation of the trace results. \n
 			:return: evm_window_pos: No help available
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:PRACh:MODulation:EWPosition?')
 		return Conversions.str_to_scalar_enum(response, enums.LowHigh)
 
 	def set_ew_position(self, evm_window_pos: enums.LowHigh) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:PRACh:MODulation:EWPosition \n
-		Snippet: driver.configure.prach.modulation.set_ew_position(evm_window_pos = enums.LowHigh.HIGH) \n
+		Snippet: driver.configure.lteMeas.prach.modulation.set_ew_position(evm_window_pos = enums.LowHigh.HIGH) \n
 		Specifies the position of the EVM window used for calculation of the trace results. \n
 			:param evm_window_pos: No help available
 		"""
 		param = Conversions.enum_scalar_to_str(evm_window_pos, enums.LowHigh)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:PRACh:MODulation:EWPosition {param}')
 
-	def clone(self) -> 'Modulation':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'ModulationCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Modulation(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = ModulationCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/Prach_/Modulation_/EwLength.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/Prach/Modulation/EwLength/__init__.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,48 +1,48 @@
 from typing import List
 
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
-from .....Internal import Conversions
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal import Conversions
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class EwLength:
-	"""EwLength commands group definition. 2 total commands, 1 Sub-groups, 1 group commands"""
+class EwLengthCls:
+	"""EwLength commands group definition. 2 total commands, 1 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("ewLength", core, parent)
+		self._cmd_group = CommandsGroup("ewLength", core, parent)
 
 	@property
 	def pformat(self):
 		"""pformat commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_pformat'):
-			from .EwLength_.Pformat import Pformat
-			self._pformat = Pformat(self._core, self._base)
+			from .Pformat import PformatCls
+			self._pformat = PformatCls(self._core, self._cmd_group)
 		return self._pformat
 
 	def get_value(self) -> List[int]:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:PRACh:MODulation:EWLength \n
-		Snippet: value: List[int] = driver.configure.prach.modulation.ewLength.get_value() \n
+		Snippet: value: List[int] = driver.configure.lteMeas.prach.modulation.ewLength.get_value() \n
 		Specifies the EVM window length in samples for all preamble formats. \n
 			:return: evm_window_length: No help available
 		"""
 		response = self._core.io.query_bin_or_ascii_int_list('CONFigure:LTE:MEASurement<Instance>:PRACh:MODulation:EWLength?')
 		return response
 
 	def set_value(self, evm_window_length: List[int]) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:PRACh:MODulation:EWLength \n
-		Snippet: driver.configure.prach.modulation.ewLength.set_value(evm_window_length = [1, 2, 3]) \n
+		Snippet: driver.configure.lteMeas.prach.modulation.ewLength.set_value(evm_window_length = [1, 2, 3]) \n
 		Specifies the EVM window length in samples for all preamble formats. \n
 			:param evm_window_length: No help available
 		"""
 		param = Conversions.list_to_csv_str(evm_window_length)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:PRACh:MODulation:EWLength {param}')
 
-	def clone(self) -> 'EwLength':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'EwLengthCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = EwLength(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = EwLengthCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/Prach_/Modulation_/EwLength_/Pformat.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/Prach/Modulation/EwLength/Pformat.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,55 +1,56 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal import Conversions
-from ......Internal.RepeatedCapability import RepeatedCapability
-from ...... import repcap
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal import Conversions
+from .......Internal.RepeatedCapability import RepeatedCapability
+from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Pformat:
-	"""Pformat commands group definition. 1 total commands, 0 Sub-groups, 1 group commands
+class PformatCls:
+	"""Pformat commands group definition. 1 total commands, 0 Subgroups, 1 group commands
 	Repeated Capability: PreambleFormat, default value after init: PreambleFormat.Fmt1"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("pformat", core, parent)
-		self._base.rep_cap = RepeatedCapability(self._base.group_name, 'repcap_preambleFormat_get', 'repcap_preambleFormat_set', repcap.PreambleFormat.Fmt1)
+		self._cmd_group = CommandsGroup("pformat", core, parent)
+		self._cmd_group.rep_cap = RepeatedCapability(self._cmd_group.group_name, 'repcap_preambleFormat_get', 'repcap_preambleFormat_set', repcap.PreambleFormat.Fmt1)
 
-	def repcap_preambleFormat_set(self, enum_value: repcap.PreambleFormat) -> None:
+	def repcap_preambleFormat_set(self, preambleFormat: repcap.PreambleFormat) -> None:
 		"""Repeated Capability default value numeric suffix.
 		This value is used, if you do not explicitely set it in the child set/get methods, or if you leave it to PreambleFormat.Default
 		Default value after init: PreambleFormat.Fmt1"""
-		self._base.set_repcap_enum_value(enum_value)
+		self._cmd_group.set_repcap_enum_value(preambleFormat)
 
 	def repcap_preambleFormat_get(self) -> repcap.PreambleFormat:
 		"""Returns the current default repeated capability for the child set/get methods"""
 		# noinspection PyTypeChecker
-		return self._base.get_repcap_enum_value()
+		return self._cmd_group.get_repcap_enum_value()
 
 	def set(self, evm_window_length: int, preambleFormat=repcap.PreambleFormat.Default) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:PRACh:MODulation:EWLength:PFORmat<PreambleFormat> \n
-		Snippet: driver.configure.prach.modulation.ewLength.pformat.set(evm_window_length = 1, preambleFormat = repcap.PreambleFormat.Default) \n
+		Snippet: driver.configure.lteMeas.prach.modulation.ewLength.pformat.set(evm_window_length = 1, preambleFormat = repcap.PreambleFormat.Default) \n
 		No command help available \n
 			:param evm_window_length: No help available
-			:param preambleFormat: optional repeated capability selector. Default value: Fmt1 (settable in the interface 'Pformat')"""
+			:param preambleFormat: optional repeated capability selector. Default value: Fmt1 (settable in the interface 'Pformat')
+		"""
 		param = Conversions.decimal_value_to_str(evm_window_length)
-		preambleFormat_cmd_val = self._base.get_repcap_cmd_value(preambleFormat, repcap.PreambleFormat)
+		preambleFormat_cmd_val = self._cmd_group.get_repcap_cmd_value(preambleFormat, repcap.PreambleFormat)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:PRACh:MODulation:EWLength:PFORmat{preambleFormat_cmd_val} {param}')
 
 	def get(self, preambleFormat=repcap.PreambleFormat.Default) -> int:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:PRACh:MODulation:EWLength:PFORmat<PreambleFormat> \n
-		Snippet: value: int = driver.configure.prach.modulation.ewLength.pformat.get(preambleFormat = repcap.PreambleFormat.Default) \n
+		Snippet: value: int = driver.configure.lteMeas.prach.modulation.ewLength.pformat.get(preambleFormat = repcap.PreambleFormat.Default) \n
 		No command help available \n
 			:param preambleFormat: optional repeated capability selector. Default value: Fmt1 (settable in the interface 'Pformat')
 			:return: evm_window_length: No help available"""
-		preambleFormat_cmd_val = self._base.get_repcap_cmd_value(preambleFormat, repcap.PreambleFormat)
+		preambleFormat_cmd_val = self._cmd_group.get_repcap_cmd_value(preambleFormat, repcap.PreambleFormat)
 		response = self._core.io.query_str(f'CONFigure:LTE:MEASurement<Instance>:PRACh:MODulation:EWLength:PFORmat{preambleFormat_cmd_val}?')
 		return Conversions.str_to_int(response)
 
-	def clone(self) -> 'Pformat':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'PformatCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Pformat(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = PformatCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/Prach_/Modulation_/Sindex.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/Prach/Modulation/Sindex.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,52 +1,52 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
-from .....Internal import Conversions
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal import Conversions
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Sindex:
-	"""Sindex commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class SindexCls:
+	"""Sindex commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("sindex", core, parent)
+		self._cmd_group = CommandsGroup("sindex", core, parent)
 
 	def get_auto(self) -> bool:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:PRACh:MODulation:SINDex:AUTO \n
-		Snippet: value: bool = driver.configure.prach.modulation.sindex.get_auto() \n
+		Snippet: value: bool = driver.configure.lteMeas.prach.modulation.sindex.get_auto() \n
 		Enables or disables automatic detection of the sequence index. To configure the index manually for disabled automatic
-		detection, see method RsCMPX_LteMeas.Configure.Prach.Modulation.Sindex.value. \n
+		detection, see method RsCMPX_LteMeas.Configure.LteMeas.Prach.Modulation.Sindex.value. \n
 			:return: seq_index_auto: No help available
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:PRACh:MODulation:SINDex:AUTO?')
 		return Conversions.str_to_bool(response)
 
 	def set_auto(self, seq_index_auto: bool) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:PRACh:MODulation:SINDex:AUTO \n
-		Snippet: driver.configure.prach.modulation.sindex.set_auto(seq_index_auto = False) \n
+		Snippet: driver.configure.lteMeas.prach.modulation.sindex.set_auto(seq_index_auto = False) \n
 		Enables or disables automatic detection of the sequence index. To configure the index manually for disabled automatic
-		detection, see method RsCMPX_LteMeas.Configure.Prach.Modulation.Sindex.value. \n
+		detection, see method RsCMPX_LteMeas.Configure.LteMeas.Prach.Modulation.Sindex.value. \n
 			:param seq_index_auto: No help available
 		"""
 		param = Conversions.bool_to_str(seq_index_auto)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:PRACh:MODulation:SINDex:AUTO {param}')
 
 	def get_value(self) -> int:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:PRACh:MODulation:SINDex \n
-		Snippet: value: int = driver.configure.prach.modulation.sindex.get_value() \n
+		Snippet: value: int = driver.configure.lteMeas.prach.modulation.sindex.get_value() \n
 		Specifies the sequence index, i.e. which of the 64 preamble sequences of the cell is used by the UE. This setting is only
-		relevant if automatic detection is disabled, see method RsCMPX_LteMeas.Configure.Prach.Modulation.Sindex.auto. \n
+		relevant if automatic detection is disabled, see method RsCMPX_LteMeas.Configure.LteMeas.Prach.Modulation.Sindex.auto. \n
 			:return: sequence_index: No help available
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:PRACh:MODulation:SINDex?')
 		return Conversions.str_to_int(response)
 
 	def set_value(self, sequence_index: int) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:PRACh:MODulation:SINDex \n
-		Snippet: driver.configure.prach.modulation.sindex.set_value(sequence_index = 1) \n
+		Snippet: driver.configure.lteMeas.prach.modulation.sindex.set_value(sequence_index = 1) \n
 		Specifies the sequence index, i.e. which of the 64 preamble sequences of the cell is used by the UE. This setting is only
-		relevant if automatic detection is disabled, see method RsCMPX_LteMeas.Configure.Prach.Modulation.Sindex.auto. \n
+		relevant if automatic detection is disabled, see method RsCMPX_LteMeas.Configure.LteMeas.Prach.Modulation.Sindex.auto. \n
 			:param sequence_index: No help available
 		"""
 		param = Conversions.decimal_value_to_str(sequence_index)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:PRACh:MODulation:SINDex {param}')
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/Prach_/PfOffset.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/Prach/PfOffset.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,52 +1,52 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
-from ....Internal import Conversions
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
+from .....Internal import Conversions
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class PfOffset:
-	"""PfOffset commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class PfOffsetCls:
+	"""PfOffset commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("pfOffset", core, parent)
+		self._cmd_group = CommandsGroup("pfOffset", core, parent)
 
 	def get_auto(self) -> bool:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:PRACh:PFOFfset:AUTO \n
-		Snippet: value: bool = driver.configure.prach.pfOffset.get_auto() \n
+		Snippet: value: bool = driver.configure.lteMeas.prach.pfOffset.get_auto() \n
 		Enables or disables automatic detection of the PRACH frequency offset. To configure the offset manually for disabled
-		automatic detection, see method RsCMPX_LteMeas.Configure.Prach.PfOffset.value. \n
+		automatic detection, see method RsCMPX_LteMeas.Configure.LteMeas.Prach.PfOffset.value. \n
 			:return: prach_freq_auto: No help available
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:PRACh:PFOFfset:AUTO?')
 		return Conversions.str_to_bool(response)
 
 	def set_auto(self, prach_freq_auto: bool) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:PRACh:PFOFfset:AUTO \n
-		Snippet: driver.configure.prach.pfOffset.set_auto(prach_freq_auto = False) \n
+		Snippet: driver.configure.lteMeas.prach.pfOffset.set_auto(prach_freq_auto = False) \n
 		Enables or disables automatic detection of the PRACH frequency offset. To configure the offset manually for disabled
-		automatic detection, see method RsCMPX_LteMeas.Configure.Prach.PfOffset.value. \n
+		automatic detection, see method RsCMPX_LteMeas.Configure.LteMeas.Prach.PfOffset.value. \n
 			:param prach_freq_auto: No help available
 		"""
 		param = Conversions.bool_to_str(prach_freq_auto)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:PRACh:PFOFfset:AUTO {param}')
 
 	def get_value(self) -> int:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:PRACh:PFOFfset \n
-		Snippet: value: int = driver.configure.prach.pfOffset.get_value() \n
+		Snippet: value: int = driver.configure.lteMeas.prach.pfOffset.get_value() \n
 		Specifies the PRACH frequency offset. This setting is only relevant if automatic detection is disabled, see method
-		RsCMPX_LteMeas.Configure.Prach.PfOffset.auto. \n
+		RsCMPX_LteMeas.Configure.LteMeas.Prach.PfOffset.auto. \n
 			:return: prach_freq_offset: No help available
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:PRACh:PFOFfset?')
 		return Conversions.str_to_int(response)
 
 	def set_value(self, prach_freq_offset: int) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:PRACh:PFOFfset \n
-		Snippet: driver.configure.prach.pfOffset.set_value(prach_freq_offset = 1) \n
+		Snippet: driver.configure.lteMeas.prach.pfOffset.set_value(prach_freq_offset = 1) \n
 		Specifies the PRACH frequency offset. This setting is only relevant if automatic detection is disabled, see method
-		RsCMPX_LteMeas.Configure.Prach.PfOffset.auto. \n
+		RsCMPX_LteMeas.Configure.LteMeas.Prach.PfOffset.auto. \n
 			:param prach_freq_offset: No help available
 		"""
 		param = Conversions.decimal_value_to_str(prach_freq_offset)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:PRACh:PFOFfset {param}')
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/Prach_/Result.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/Prach/Result.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,368 +1,378 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
-from ....Internal import Conversions
-from ....Internal.StructBase import StructBase
-from ....Internal.ArgStruct import ArgStruct
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
+from .....Internal import Conversions
+from .....Internal.StructBase import StructBase
+from .....Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Result:
-	"""Result commands group definition. 9 total commands, 0 Sub-groups, 9 group commands"""
+class ResultCls:
+	"""Result commands group definition. 9 total commands, 0 Subgroups, 9 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("result", core, parent)
+		self._cmd_group = CommandsGroup("result", core, parent)
 
 	# noinspection PyTypeChecker
-	class AllStruct(StructBase):
-		"""Structure for reading output parameters. Fields: \n
-			- Evm: bool: Error vector magnitude OFF: Do not evaluate results ON: Evaluate results
+	class AllStruct(StructBase):  # From WriteStructDefinition CmdPropertyTemplate.xml
+		"""Structure for setting input parameters. Contains optional set arguments. Fields: \n
+			- Evm: bool: Error vector magnitude OFF: Do not evaluate the results. ON: Evaluate the results.
 			- Magnitude_Error: bool: No parameter help available
 			- Phase_Error: bool: No parameter help available
 			- Iq: bool: I/Q constellation diagram
 			- Power_Dynamics: bool: No parameter help available
 			- Tx_Measurement: bool: TX measurement statistical overview
 			- Evm_Vs_Preamble: bool: No parameter help available
 			- Power_Vs_Preamble: bool: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_bool('Evm'),
 			ArgStruct.scalar_bool('Magnitude_Error'),
 			ArgStruct.scalar_bool('Phase_Error'),
 			ArgStruct.scalar_bool('Iq'),
 			ArgStruct.scalar_bool('Power_Dynamics'),
 			ArgStruct.scalar_bool('Tx_Measurement'),
-			ArgStruct.scalar_bool('Evm_Vs_Preamble'),
-			ArgStruct.scalar_bool('Power_Vs_Preamble')]
+			ArgStruct.scalar_bool_optional('Evm_Vs_Preamble'),
+			ArgStruct.scalar_bool_optional('Power_Vs_Preamble')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Evm: bool = None
 			self.Magnitude_Error: bool = None
 			self.Phase_Error: bool = None
 			self.Iq: bool = None
 			self.Power_Dynamics: bool = None
 			self.Tx_Measurement: bool = None
 			self.Evm_Vs_Preamble: bool = None
 			self.Power_Vs_Preamble: bool = None
 
 	def get_all(self) -> AllStruct:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:PRACh:RESult[:ALL] \n
-		Snippet: value: AllStruct = driver.configure.prach.result.get_all() \n
+		Snippet: value: AllStruct = driver.configure.lteMeas.prach.result.get_all() \n
 		Enables or disables the evaluation of results in the PRACH measurement.
 		This command combines all other CONFigure:LTE:MEAS<i>:PRACh:RESult... commands. \n
 			:return: structure: for return value, see the help for AllStruct structure arguments.
 		"""
 		return self._core.io.query_struct('CONFigure:LTE:MEASurement<Instance>:PRACh:RESult:ALL?', self.__class__.AllStruct())
 
 	def set_all(self, value: AllStruct) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:PRACh:RESult[:ALL] \n
-		Snippet: driver.configure.prach.result.set_all(value = AllStruct()) \n
+		Snippet with structure: \n
+		structure = driver.configure.lteMeas.prach.result.AllStruct() \n
+		structure.Evm: bool = False \n
+		structure.Magnitude_Error: bool = False \n
+		structure.Phase_Error: bool = False \n
+		structure.Iq: bool = False \n
+		structure.Power_Dynamics: bool = False \n
+		structure.Tx_Measurement: bool = False \n
+		structure.Evm_Vs_Preamble: bool = False \n
+		structure.Power_Vs_Preamble: bool = False \n
+		driver.configure.lteMeas.prach.result.set_all(value = structure) \n
 		Enables or disables the evaluation of results in the PRACH measurement.
 		This command combines all other CONFigure:LTE:MEAS<i>:PRACh:RESult... commands. \n
 			:param value: see the help for AllStruct structure arguments.
 		"""
 		self._core.io.write_struct('CONFigure:LTE:MEASurement<Instance>:PRACh:RESult:ALL', value)
 
 	def get_ev_magnitude(self) -> bool:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:PRACh:RESult:EVMagnitude \n
-		Snippet: value: bool = driver.configure.prach.result.get_ev_magnitude() \n
+		Snippet: value: bool = driver.configure.lteMeas.prach.result.get_ev_magnitude() \n
 		Enables or disables the evaluation of results in the PRACH measurement.
 			Table Header: Mnemonic / Description \n
 			- EVMagnitude / Error vector magnitude
 			- MERRor / Magnitude error
 			- PERRor / Phase error
 			- IQ / I/Q constellation diagram
 			- PDYNamics / Power dynamics
 			- TXM / TX meas. statistical overview
 			- EVPReamble / EVM vs preamble
 			- PVPReamble / Power vs preamble
-		For reset values, see method RsCMPX_LteMeas.Configure.Prach.Result.all. \n
-			:return: enable: OFF: Do not evaluate results ON: Evaluate results
+		For reset values, see method RsCMPX_LteMeas.Configure.LteMeas.Prach.Result.all. \n
+			:return: enable: OFF: Do not evaluate the results. ON: Evaluate the results.
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:PRACh:RESult:EVMagnitude?')
 		return Conversions.str_to_bool(response)
 
 	def set_ev_magnitude(self, enable: bool) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:PRACh:RESult:EVMagnitude \n
-		Snippet: driver.configure.prach.result.set_ev_magnitude(enable = False) \n
+		Snippet: driver.configure.lteMeas.prach.result.set_ev_magnitude(enable = False) \n
 		Enables or disables the evaluation of results in the PRACH measurement.
 			Table Header: Mnemonic / Description \n
 			- EVMagnitude / Error vector magnitude
 			- MERRor / Magnitude error
 			- PERRor / Phase error
 			- IQ / I/Q constellation diagram
 			- PDYNamics / Power dynamics
 			- TXM / TX meas. statistical overview
 			- EVPReamble / EVM vs preamble
 			- PVPReamble / Power vs preamble
-		For reset values, see method RsCMPX_LteMeas.Configure.Prach.Result.all. \n
-			:param enable: OFF: Do not evaluate results ON: Evaluate results
+		For reset values, see method RsCMPX_LteMeas.Configure.LteMeas.Prach.Result.all. \n
+			:param enable: OFF: Do not evaluate the results. ON: Evaluate the results.
 		"""
 		param = Conversions.bool_to_str(enable)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:PRACh:RESult:EVMagnitude {param}')
 
 	def get_ev_preamble(self) -> bool:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:PRACh:RESult:EVPReamble \n
-		Snippet: value: bool = driver.configure.prach.result.get_ev_preamble() \n
+		Snippet: value: bool = driver.configure.lteMeas.prach.result.get_ev_preamble() \n
 		Enables or disables the evaluation of results in the PRACH measurement.
 			Table Header: Mnemonic / Description \n
 			- EVMagnitude / Error vector magnitude
 			- MERRor / Magnitude error
 			- PERRor / Phase error
 			- IQ / I/Q constellation diagram
 			- PDYNamics / Power dynamics
 			- TXM / TX meas. statistical overview
 			- EVPReamble / EVM vs preamble
 			- PVPReamble / Power vs preamble
-		For reset values, see method RsCMPX_LteMeas.Configure.Prach.Result.all. \n
-			:return: enable: OFF: Do not evaluate results ON: Evaluate results
+		For reset values, see method RsCMPX_LteMeas.Configure.LteMeas.Prach.Result.all. \n
+			:return: enable: OFF: Do not evaluate the results. ON: Evaluate the results.
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:PRACh:RESult:EVPReamble?')
 		return Conversions.str_to_bool(response)
 
 	def set_ev_preamble(self, enable: bool) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:PRACh:RESult:EVPReamble \n
-		Snippet: driver.configure.prach.result.set_ev_preamble(enable = False) \n
+		Snippet: driver.configure.lteMeas.prach.result.set_ev_preamble(enable = False) \n
 		Enables or disables the evaluation of results in the PRACH measurement.
 			Table Header: Mnemonic / Description \n
 			- EVMagnitude / Error vector magnitude
 			- MERRor / Magnitude error
 			- PERRor / Phase error
 			- IQ / I/Q constellation diagram
 			- PDYNamics / Power dynamics
 			- TXM / TX meas. statistical overview
 			- EVPReamble / EVM vs preamble
 			- PVPReamble / Power vs preamble
-		For reset values, see method RsCMPX_LteMeas.Configure.Prach.Result.all. \n
-			:param enable: OFF: Do not evaluate results ON: Evaluate results
+		For reset values, see method RsCMPX_LteMeas.Configure.LteMeas.Prach.Result.all. \n
+			:param enable: OFF: Do not evaluate the results. ON: Evaluate the results.
 		"""
 		param = Conversions.bool_to_str(enable)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:PRACh:RESult:EVPReamble {param}')
 
 	def get_merror(self) -> bool:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:PRACh:RESult:MERRor \n
-		Snippet: value: bool = driver.configure.prach.result.get_merror() \n
+		Snippet: value: bool = driver.configure.lteMeas.prach.result.get_merror() \n
 		Enables or disables the evaluation of results in the PRACH measurement.
 			Table Header: Mnemonic / Description \n
 			- EVMagnitude / Error vector magnitude
 			- MERRor / Magnitude error
 			- PERRor / Phase error
 			- IQ / I/Q constellation diagram
 			- PDYNamics / Power dynamics
 			- TXM / TX meas. statistical overview
 			- EVPReamble / EVM vs preamble
 			- PVPReamble / Power vs preamble
-		For reset values, see method RsCMPX_LteMeas.Configure.Prach.Result.all. \n
-			:return: enable: OFF: Do not evaluate results ON: Evaluate results
+		For reset values, see method RsCMPX_LteMeas.Configure.LteMeas.Prach.Result.all. \n
+			:return: enable: OFF: Do not evaluate the results. ON: Evaluate the results.
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:PRACh:RESult:MERRor?')
 		return Conversions.str_to_bool(response)
 
 	def set_merror(self, enable: bool) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:PRACh:RESult:MERRor \n
-		Snippet: driver.configure.prach.result.set_merror(enable = False) \n
+		Snippet: driver.configure.lteMeas.prach.result.set_merror(enable = False) \n
 		Enables or disables the evaluation of results in the PRACH measurement.
 			Table Header: Mnemonic / Description \n
 			- EVMagnitude / Error vector magnitude
 			- MERRor / Magnitude error
 			- PERRor / Phase error
 			- IQ / I/Q constellation diagram
 			- PDYNamics / Power dynamics
 			- TXM / TX meas. statistical overview
 			- EVPReamble / EVM vs preamble
 			- PVPReamble / Power vs preamble
-		For reset values, see method RsCMPX_LteMeas.Configure.Prach.Result.all. \n
-			:param enable: OFF: Do not evaluate results ON: Evaluate results
+		For reset values, see method RsCMPX_LteMeas.Configure.LteMeas.Prach.Result.all. \n
+			:param enable: OFF: Do not evaluate the results. ON: Evaluate the results.
 		"""
 		param = Conversions.bool_to_str(enable)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:PRACh:RESult:MERRor {param}')
 
 	def get_perror(self) -> bool:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:PRACh:RESult:PERRor \n
-		Snippet: value: bool = driver.configure.prach.result.get_perror() \n
+		Snippet: value: bool = driver.configure.lteMeas.prach.result.get_perror() \n
 		Enables or disables the evaluation of results in the PRACH measurement.
 			Table Header: Mnemonic / Description \n
 			- EVMagnitude / Error vector magnitude
 			- MERRor / Magnitude error
 			- PERRor / Phase error
 			- IQ / I/Q constellation diagram
 			- PDYNamics / Power dynamics
 			- TXM / TX meas. statistical overview
 			- EVPReamble / EVM vs preamble
 			- PVPReamble / Power vs preamble
-		For reset values, see method RsCMPX_LteMeas.Configure.Prach.Result.all. \n
-			:return: enable: OFF: Do not evaluate results ON: Evaluate results
+		For reset values, see method RsCMPX_LteMeas.Configure.LteMeas.Prach.Result.all. \n
+			:return: enable: OFF: Do not evaluate the results. ON: Evaluate the results.
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:PRACh:RESult:PERRor?')
 		return Conversions.str_to_bool(response)
 
 	def set_perror(self, enable: bool) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:PRACh:RESult:PERRor \n
-		Snippet: driver.configure.prach.result.set_perror(enable = False) \n
+		Snippet: driver.configure.lteMeas.prach.result.set_perror(enable = False) \n
 		Enables or disables the evaluation of results in the PRACH measurement.
 			Table Header: Mnemonic / Description \n
 			- EVMagnitude / Error vector magnitude
 			- MERRor / Magnitude error
 			- PERRor / Phase error
 			- IQ / I/Q constellation diagram
 			- PDYNamics / Power dynamics
 			- TXM / TX meas. statistical overview
 			- EVPReamble / EVM vs preamble
 			- PVPReamble / Power vs preamble
-		For reset values, see method RsCMPX_LteMeas.Configure.Prach.Result.all. \n
-			:param enable: OFF: Do not evaluate results ON: Evaluate results
+		For reset values, see method RsCMPX_LteMeas.Configure.LteMeas.Prach.Result.all. \n
+			:param enable: OFF: Do not evaluate the results. ON: Evaluate the results.
 		"""
 		param = Conversions.bool_to_str(enable)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:PRACh:RESult:PERRor {param}')
 
 	def get_iq(self) -> bool:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:PRACh:RESult:IQ \n
-		Snippet: value: bool = driver.configure.prach.result.get_iq() \n
+		Snippet: value: bool = driver.configure.lteMeas.prach.result.get_iq() \n
 		Enables or disables the evaluation of results in the PRACH measurement.
 			Table Header: Mnemonic / Description \n
 			- EVMagnitude / Error vector magnitude
 			- MERRor / Magnitude error
 			- PERRor / Phase error
 			- IQ / I/Q constellation diagram
 			- PDYNamics / Power dynamics
 			- TXM / TX meas. statistical overview
 			- EVPReamble / EVM vs preamble
 			- PVPReamble / Power vs preamble
-		For reset values, see method RsCMPX_LteMeas.Configure.Prach.Result.all. \n
-			:return: enable: OFF: Do not evaluate results ON: Evaluate results
+		For reset values, see method RsCMPX_LteMeas.Configure.LteMeas.Prach.Result.all. \n
+			:return: enable: OFF: Do not evaluate the results. ON: Evaluate the results.
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:PRACh:RESult:IQ?')
 		return Conversions.str_to_bool(response)
 
 	def set_iq(self, enable: bool) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:PRACh:RESult:IQ \n
-		Snippet: driver.configure.prach.result.set_iq(enable = False) \n
+		Snippet: driver.configure.lteMeas.prach.result.set_iq(enable = False) \n
 		Enables or disables the evaluation of results in the PRACH measurement.
 			Table Header: Mnemonic / Description \n
 			- EVMagnitude / Error vector magnitude
 			- MERRor / Magnitude error
 			- PERRor / Phase error
 			- IQ / I/Q constellation diagram
 			- PDYNamics / Power dynamics
 			- TXM / TX meas. statistical overview
 			- EVPReamble / EVM vs preamble
 			- PVPReamble / Power vs preamble
-		For reset values, see method RsCMPX_LteMeas.Configure.Prach.Result.all. \n
-			:param enable: OFF: Do not evaluate results ON: Evaluate results
+		For reset values, see method RsCMPX_LteMeas.Configure.LteMeas.Prach.Result.all. \n
+			:param enable: OFF: Do not evaluate the results. ON: Evaluate the results.
 		"""
 		param = Conversions.bool_to_str(enable)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:PRACh:RESult:IQ {param}')
 
 	def get_pdynamics(self) -> bool:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:PRACh:RESult:PDYNamics \n
-		Snippet: value: bool = driver.configure.prach.result.get_pdynamics() \n
+		Snippet: value: bool = driver.configure.lteMeas.prach.result.get_pdynamics() \n
 		Enables or disables the evaluation of results in the PRACH measurement.
 			Table Header: Mnemonic / Description \n
 			- EVMagnitude / Error vector magnitude
 			- MERRor / Magnitude error
 			- PERRor / Phase error
 			- IQ / I/Q constellation diagram
 			- PDYNamics / Power dynamics
 			- TXM / TX meas. statistical overview
 			- EVPReamble / EVM vs preamble
 			- PVPReamble / Power vs preamble
-		For reset values, see method RsCMPX_LteMeas.Configure.Prach.Result.all. \n
-			:return: enable: OFF: Do not evaluate results ON: Evaluate results
+		For reset values, see method RsCMPX_LteMeas.Configure.LteMeas.Prach.Result.all. \n
+			:return: enable: OFF: Do not evaluate the results. ON: Evaluate the results.
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:PRACh:RESult:PDYNamics?')
 		return Conversions.str_to_bool(response)
 
 	def set_pdynamics(self, enable: bool) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:PRACh:RESult:PDYNamics \n
-		Snippet: driver.configure.prach.result.set_pdynamics(enable = False) \n
+		Snippet: driver.configure.lteMeas.prach.result.set_pdynamics(enable = False) \n
 		Enables or disables the evaluation of results in the PRACH measurement.
 			Table Header: Mnemonic / Description \n
 			- EVMagnitude / Error vector magnitude
 			- MERRor / Magnitude error
 			- PERRor / Phase error
 			- IQ / I/Q constellation diagram
 			- PDYNamics / Power dynamics
 			- TXM / TX meas. statistical overview
 			- EVPReamble / EVM vs preamble
 			- PVPReamble / Power vs preamble
-		For reset values, see method RsCMPX_LteMeas.Configure.Prach.Result.all. \n
-			:param enable: OFF: Do not evaluate results ON: Evaluate results
+		For reset values, see method RsCMPX_LteMeas.Configure.LteMeas.Prach.Result.all. \n
+			:param enable: OFF: Do not evaluate the results. ON: Evaluate the results.
 		"""
 		param = Conversions.bool_to_str(enable)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:PRACh:RESult:PDYNamics {param}')
 
 	def get_pv_preamble(self) -> bool:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:PRACh:RESult:PVPReamble \n
-		Snippet: value: bool = driver.configure.prach.result.get_pv_preamble() \n
+		Snippet: value: bool = driver.configure.lteMeas.prach.result.get_pv_preamble() \n
 		Enables or disables the evaluation of results in the PRACH measurement.
 			Table Header: Mnemonic / Description \n
 			- EVMagnitude / Error vector magnitude
 			- MERRor / Magnitude error
 			- PERRor / Phase error
 			- IQ / I/Q constellation diagram
 			- PDYNamics / Power dynamics
 			- TXM / TX meas. statistical overview
 			- EVPReamble / EVM vs preamble
 			- PVPReamble / Power vs preamble
-		For reset values, see method RsCMPX_LteMeas.Configure.Prach.Result.all. \n
-			:return: enable: OFF: Do not evaluate results ON: Evaluate results
+		For reset values, see method RsCMPX_LteMeas.Configure.LteMeas.Prach.Result.all. \n
+			:return: enable: OFF: Do not evaluate the results. ON: Evaluate the results.
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:PRACh:RESult:PVPReamble?')
 		return Conversions.str_to_bool(response)
 
 	def set_pv_preamble(self, enable: bool) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:PRACh:RESult:PVPReamble \n
-		Snippet: driver.configure.prach.result.set_pv_preamble(enable = False) \n
+		Snippet: driver.configure.lteMeas.prach.result.set_pv_preamble(enable = False) \n
 		Enables or disables the evaluation of results in the PRACH measurement.
 			Table Header: Mnemonic / Description \n
 			- EVMagnitude / Error vector magnitude
 			- MERRor / Magnitude error
 			- PERRor / Phase error
 			- IQ / I/Q constellation diagram
 			- PDYNamics / Power dynamics
 			- TXM / TX meas. statistical overview
 			- EVPReamble / EVM vs preamble
 			- PVPReamble / Power vs preamble
-		For reset values, see method RsCMPX_LteMeas.Configure.Prach.Result.all. \n
-			:param enable: OFF: Do not evaluate results ON: Evaluate results
+		For reset values, see method RsCMPX_LteMeas.Configure.LteMeas.Prach.Result.all. \n
+			:param enable: OFF: Do not evaluate the results. ON: Evaluate the results.
 		"""
 		param = Conversions.bool_to_str(enable)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:PRACh:RESult:PVPReamble {param}')
 
 	def get_txm(self) -> bool:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:PRACh:RESult:TXM \n
-		Snippet: value: bool = driver.configure.prach.result.get_txm() \n
+		Snippet: value: bool = driver.configure.lteMeas.prach.result.get_txm() \n
 		Enables or disables the evaluation of results in the PRACH measurement.
 			Table Header: Mnemonic / Description \n
 			- EVMagnitude / Error vector magnitude
 			- MERRor / Magnitude error
 			- PERRor / Phase error
 			- IQ / I/Q constellation diagram
 			- PDYNamics / Power dynamics
 			- TXM / TX meas. statistical overview
 			- EVPReamble / EVM vs preamble
 			- PVPReamble / Power vs preamble
-		For reset values, see method RsCMPX_LteMeas.Configure.Prach.Result.all. \n
-			:return: enable: OFF: Do not evaluate results ON: Evaluate results
+		For reset values, see method RsCMPX_LteMeas.Configure.LteMeas.Prach.Result.all. \n
+			:return: enable: OFF: Do not evaluate the results. ON: Evaluate the results.
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:PRACh:RESult:TXM?')
 		return Conversions.str_to_bool(response)
 
 	def set_txm(self, enable: bool) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:PRACh:RESult:TXM \n
-		Snippet: driver.configure.prach.result.set_txm(enable = False) \n
+		Snippet: driver.configure.lteMeas.prach.result.set_txm(enable = False) \n
 		Enables or disables the evaluation of results in the PRACH measurement.
 			Table Header: Mnemonic / Description \n
 			- EVMagnitude / Error vector magnitude
 			- MERRor / Magnitude error
 			- PERRor / Phase error
 			- IQ / I/Q constellation diagram
 			- PDYNamics / Power dynamics
 			- TXM / TX meas. statistical overview
 			- EVPReamble / EVM vs preamble
 			- PVPReamble / Power vs preamble
-		For reset values, see method RsCMPX_LteMeas.Configure.Prach.Result.all. \n
-			:param enable: OFF: Do not evaluate results ON: Evaluate results
+		For reset values, see method RsCMPX_LteMeas.Configure.LteMeas.Prach.Result.all. \n
+			:param enable: OFF: Do not evaluate the results. ON: Evaluate the results.
 		"""
 		param = Conversions.bool_to_str(enable)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:PRACh:RESult:TXM {param}')
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/Prach_/Scount.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/Prach/Scount.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,52 +1,52 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
-from ....Internal import Conversions
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
+from .....Internal import Conversions
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Scount:
-	"""Scount commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class ScountCls:
+	"""Scount commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("scount", core, parent)
+		self._cmd_group = CommandsGroup("scount", core, parent)
 
 	def get_modulation(self) -> int:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:PRACh:SCOunt:MODulation \n
-		Snippet: value: int = driver.configure.prach.scount.get_modulation() \n
+		Snippet: value: int = driver.configure.lteMeas.prach.scount.get_modulation() \n
 		Specifies the statistic count of the measurement. The statistic count is equal to the number of measurement intervals per
 		single shot. \n
 			:return: statistic_count: No help available
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:PRACh:SCOunt:MODulation?')
 		return Conversions.str_to_int(response)
 
 	def set_modulation(self, statistic_count: int) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:PRACh:SCOunt:MODulation \n
-		Snippet: driver.configure.prach.scount.set_modulation(statistic_count = 1) \n
+		Snippet: driver.configure.lteMeas.prach.scount.set_modulation(statistic_count = 1) \n
 		Specifies the statistic count of the measurement. The statistic count is equal to the number of measurement intervals per
 		single shot. \n
 			:param statistic_count: No help available
 		"""
 		param = Conversions.decimal_value_to_str(statistic_count)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:PRACh:SCOunt:MODulation {param}')
 
 	def get_pdynamics(self) -> int:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:PRACh:SCOunt:PDYNamics \n
-		Snippet: value: int = driver.configure.prach.scount.get_pdynamics() \n
+		Snippet: value: int = driver.configure.lteMeas.prach.scount.get_pdynamics() \n
 		Specifies the statistic count of the measurement. The statistic count is equal to the number of measurement intervals per
 		single shot. \n
 			:return: statistic_count: No help available
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:PRACh:SCOunt:PDYNamics?')
 		return Conversions.str_to_int(response)
 
 	def set_pdynamics(self, statistic_count: int) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:PRACh:SCOunt:PDYNamics \n
-		Snippet: driver.configure.prach.scount.set_pdynamics(statistic_count = 1) \n
+		Snippet: driver.configure.lteMeas.prach.scount.set_pdynamics(statistic_count = 1) \n
 		Specifies the statistic count of the measurement. The statistic count is equal to the number of measurement intervals per
 		single shot. \n
 			:param statistic_count: No help available
 		"""
 		param = Conversions.decimal_value_to_str(statistic_count)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:PRACh:SCOunt:PDYNamics {param}')
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/RfSettings.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/RfSettings/__init__.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,140 +1,142 @@
-from ...Internal.Core import Core
-from ...Internal.CommandsGroup import CommandsGroup
-from ...Internal import Conversions
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
+from .....Internal import Conversions
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class RfSettings:
-	"""RfSettings commands group definition. 8 total commands, 3 Sub-groups, 5 group commands"""
+class RfSettingsCls:
+	"""RfSettings commands group definition. 8 total commands, 3 Subgroups, 5 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("rfSettings", core, parent)
+		self._cmd_group = CommandsGroup("rfSettings", core, parent)
 
 	@property
 	def pcc(self):
 		"""pcc commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_pcc'):
-			from .RfSettings_.Pcc import Pcc
-			self._pcc = Pcc(self._core, self._base)
+			from .Pcc import PccCls
+			self._pcc = PccCls(self._core, self._cmd_group)
 		return self._pcc
 
 	@property
 	def scc(self):
 		"""scc commands group. 1 Sub-classes, 0 commands."""
 		if not hasattr(self, '_scc'):
-			from .RfSettings_.Scc import Scc
-			self._scc = Scc(self._core, self._base)
+			from .Scc import SccCls
+			self._scc = SccCls(self._core, self._cmd_group)
 		return self._scc
 
 	@property
 	def cc(self):
 		"""cc commands group. 1 Sub-classes, 0 commands."""
 		if not hasattr(self, '_cc'):
-			from .RfSettings_.Cc import Cc
-			self._cc = Cc(self._core, self._base)
+			from .Cc import CcCls
+			self._cc = CcCls(self._core, self._cmd_group)
 		return self._cc
 
 	def get_eattenuation(self) -> float:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:RFSettings:EATTenuation \n
-		Snippet: value: float = driver.configure.rfSettings.get_eattenuation() \n
-		Defines an external attenuation (or gain, if the value is negative) , to be applied to the input connector. \n
+		Snippet: value: float = driver.configure.lteMeas.rfSettings.get_eattenuation() \n
+		Defines an external attenuation (or gain, if the value is negative) , to be applied to the input connector. With full RF
+		path sharing, this command is not applicable. \n
 			:return: rf_input_ext_att: No help available
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:RFSettings:EATTenuation?')
 		return Conversions.str_to_float(response)
 
 	def set_eattenuation(self, rf_input_ext_att: float) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:RFSettings:EATTenuation \n
-		Snippet: driver.configure.rfSettings.set_eattenuation(rf_input_ext_att = 1.0) \n
-		Defines an external attenuation (or gain, if the value is negative) , to be applied to the input connector. \n
+		Snippet: driver.configure.lteMeas.rfSettings.set_eattenuation(rf_input_ext_att = 1.0) \n
+		Defines an external attenuation (or gain, if the value is negative) , to be applied to the input connector. With full RF
+		path sharing, this command is not applicable. \n
 			:param rf_input_ext_att: No help available
 		"""
 		param = Conversions.decimal_value_to_str(rf_input_ext_att)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:RFSettings:EATTenuation {param}')
 
 	def get_umargin(self) -> float:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:RFSettings:UMARgin \n
-		Snippet: value: float = driver.configure.rfSettings.get_umargin() \n
+		Snippet: value: float = driver.configure.lteMeas.rfSettings.get_umargin() \n
 		Sets the margin that the measurement adds to the expected nominal power to determine the reference power. The reference
 		power minus the external input attenuation must be within the power range of the selected input connector. Refer to the
-		data sheet. For Signal Path = Network, the setting is not configurable. \n
+		specifications document. With full RF path sharing, this command is not applicable. \n
 			:return: user_margin: No help available
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:RFSettings:UMARgin?')
 		return Conversions.str_to_float(response)
 
 	def set_umargin(self, user_margin: float) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:RFSettings:UMARgin \n
-		Snippet: driver.configure.rfSettings.set_umargin(user_margin = 1.0) \n
+		Snippet: driver.configure.lteMeas.rfSettings.set_umargin(user_margin = 1.0) \n
 		Sets the margin that the measurement adds to the expected nominal power to determine the reference power. The reference
 		power minus the external input attenuation must be within the power range of the selected input connector. Refer to the
-		data sheet. For Signal Path = Network, the setting is not configurable. \n
+		specifications document. With full RF path sharing, this command is not applicable. \n
 			:param user_margin: No help available
 		"""
 		param = Conversions.decimal_value_to_str(user_margin)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:RFSettings:UMARgin {param}')
 
 	def get_envelope_power(self) -> float:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:RFSettings:ENPower \n
-		Snippet: value: float = driver.configure.rfSettings.get_envelope_power() \n
-		Sets the expected nominal power of the measured RF signal. \n
-			:return: exp_nom_pow: The range of the expected nominal power can be calculated as follows: Range (Expected Nominal Power) = Range (Input Power) + External Attenuation - User Margin The input power range is stated in the data sheet.
+		Snippet: value: float = driver.configure.lteMeas.rfSettings.get_envelope_power() \n
+		Sets the expected nominal power of the measured RF signal. With full RF path sharing, use the signaling commands
+		controlling the uplink power. \n
+			:return: exp_nom_pow: The range of the expected nominal power can be calculated as follows: Range (Expected Nominal Power) = Range (Input Power) + External Attenuation - User Margin The input power range is stated in the specifications document.
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:RFSettings:ENPower?')
 		return Conversions.str_to_float(response)
 
 	def set_envelope_power(self, exp_nom_pow: float) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:RFSettings:ENPower \n
-		Snippet: driver.configure.rfSettings.set_envelope_power(exp_nom_pow = 1.0) \n
-		Sets the expected nominal power of the measured RF signal. \n
-			:param exp_nom_pow: The range of the expected nominal power can be calculated as follows: Range (Expected Nominal Power) = Range (Input Power) + External Attenuation - User Margin The input power range is stated in the data sheet.
+		Snippet: driver.configure.lteMeas.rfSettings.set_envelope_power(exp_nom_pow = 1.0) \n
+		Sets the expected nominal power of the measured RF signal. With full RF path sharing, use the signaling commands
+		controlling the uplink power. \n
+			:param exp_nom_pow: The range of the expected nominal power can be calculated as follows: Range (Expected Nominal Power) = Range (Input Power) + External Attenuation - User Margin The input power range is stated in the specifications document.
 		"""
 		param = Conversions.decimal_value_to_str(exp_nom_pow)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:RFSettings:ENPower {param}')
 
 	def get_foffset(self) -> int:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:RFSettings:FOFFset \n
-		Snippet: value: int = driver.configure.rfSettings.get_foffset() \n
-		Specifies a positive or negative frequency offset to be added to the carrier center frequency (method RsCMPX_LteMeas.
-		Configure.RfSettings.Cc.Frequency.set) . For Signal Path = Network, the setting is not configurable. \n
+		Snippet: value: int = driver.configure.lteMeas.rfSettings.get_foffset() \n
+		No command help available \n
 			:return: offset: No help available
 		"""
 		response = self._core.io.query_str_with_opc('CONFigure:LTE:MEASurement<Instance>:RFSettings:FOFFset?')
 		return Conversions.str_to_int(response)
 
 	def set_foffset(self, offset: int) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:RFSettings:FOFFset \n
-		Snippet: driver.configure.rfSettings.set_foffset(offset = 1) \n
-		Specifies a positive or negative frequency offset to be added to the carrier center frequency (method RsCMPX_LteMeas.
-		Configure.RfSettings.Cc.Frequency.set) . For Signal Path = Network, the setting is not configurable. \n
+		Snippet: driver.configure.lteMeas.rfSettings.set_foffset(offset = 1) \n
+		No command help available \n
 			:param offset: No help available
 		"""
 		param = Conversions.decimal_value_to_str(offset)
 		self._core.io.write_with_opc(f'CONFigure:LTE:MEASurement<Instance>:RFSettings:FOFFset {param}')
 
 	def get_ml_offset(self) -> float:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:RFSettings:MLOFfset \n
-		Snippet: value: float = driver.configure.rfSettings.get_ml_offset() \n
-		Varies the input level of the mixer in the analyzer path. For Signal Path = Network, the setting is not configurable. \n
+		Snippet: value: float = driver.configure.lteMeas.rfSettings.get_ml_offset() \n
+		No command help available \n
 			:return: mix_lev_offset: No help available
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:RFSettings:MLOFfset?')
 		return Conversions.str_to_float(response)
 
 	def set_ml_offset(self, mix_lev_offset: float) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:RFSettings:MLOFfset \n
-		Snippet: driver.configure.rfSettings.set_ml_offset(mix_lev_offset = 1.0) \n
-		Varies the input level of the mixer in the analyzer path. For Signal Path = Network, the setting is not configurable. \n
+		Snippet: driver.configure.lteMeas.rfSettings.set_ml_offset(mix_lev_offset = 1.0) \n
+		No command help available \n
 			:param mix_lev_offset: No help available
 		"""
 		param = Conversions.decimal_value_to_str(mix_lev_offset)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:RFSettings:MLOFfset {param}')
 
-	def clone(self) -> 'RfSettings':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'RfSettingsCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = RfSettings(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = RfSettingsCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/RfSettings_/Cc.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/RfSettings/Cc/__init__.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,42 +1,42 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
-from ....Internal.RepeatedCapability import RepeatedCapability
-from .... import repcap
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal.RepeatedCapability import RepeatedCapability
+from ...... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Cc:
-	"""Cc commands group definition. 1 total commands, 1 Sub-groups, 0 group commands
+class CcCls:
+	"""Cc commands group definition. 1 total commands, 1 Subgroups, 0 group commands
 	Repeated Capability: CarrierComponent, default value after init: CarrierComponent.Nr1"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("cc", core, parent)
-		self._base.rep_cap = RepeatedCapability(self._base.group_name, 'repcap_carrierComponent_get', 'repcap_carrierComponent_set', repcap.CarrierComponent.Nr1)
+		self._cmd_group = CommandsGroup("cc", core, parent)
+		self._cmd_group.rep_cap = RepeatedCapability(self._cmd_group.group_name, 'repcap_carrierComponent_get', 'repcap_carrierComponent_set', repcap.CarrierComponent.Nr1)
 
-	def repcap_carrierComponent_set(self, enum_value: repcap.CarrierComponent) -> None:
+	def repcap_carrierComponent_set(self, carrierComponent: repcap.CarrierComponent) -> None:
 		"""Repeated Capability default value numeric suffix.
 		This value is used, if you do not explicitely set it in the child set/get methods, or if you leave it to CarrierComponent.Default
 		Default value after init: CarrierComponent.Nr1"""
-		self._base.set_repcap_enum_value(enum_value)
+		self._cmd_group.set_repcap_enum_value(carrierComponent)
 
 	def repcap_carrierComponent_get(self) -> repcap.CarrierComponent:
 		"""Returns the current default repeated capability for the child set/get methods"""
 		# noinspection PyTypeChecker
-		return self._base.get_repcap_enum_value()
+		return self._cmd_group.get_repcap_enum_value()
 
 	@property
 	def frequency(self):
 		"""frequency commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_frequency'):
-			from .Cc_.Frequency import Frequency
-			self._frequency = Frequency(self._core, self._base)
+			from .Frequency import FrequencyCls
+			self._frequency = FrequencyCls(self._core, self._cmd_group)
 		return self._frequency
 
-	def clone(self) -> 'Cc':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'CcCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Cc(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = CcCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/RfSettings_/Cc_/Frequency.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/RfSettings/Cc/Frequency.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,45 +1,46 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
-from .....Internal import Conversions
-from ..... import repcap
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal import Conversions
+from ...... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Frequency:
-	"""Frequency commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class FrequencyCls:
+	"""Frequency commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("frequency", core, parent)
+		self._cmd_group = CommandsGroup("frequency", core, parent)
 
 	def set(self, analyzer_freq: float, carrierComponent=repcap.CarrierComponent.Default) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:RFSettings:CC<Nr>:FREQuency \n
-		Snippet: driver.configure.rfSettings.cc.frequency.set(analyzer_freq = 1.0, carrierComponent = repcap.CarrierComponent.Default) \n
+		Snippet: driver.configure.lteMeas.rfSettings.cc.frequency.set(analyzer_freq = 1.0, carrierComponent = repcap.CarrierComponent.Default) \n
 		Selects the center frequency of component carrier CC<no>. Without carrier aggregation, you can omit <no>. Using the unit
 		CH, the frequency can be set via the channel number. The allowed channel number range depends on the operating band, see
-		'Frequency Bands'.
+		'Frequency bands'.
 			INTRO_CMD_HELP: For Signal Path = Network, use: \n
 			- [CONFigure:]SIGNaling:LTE:CELL:RFSettings:UL:FREQuency
 			- [CONFigure:]SIGNaling:LTE:CELL:RFSettings:UL:EARFcn
-		For the supported frequency range, see 'Frequency Ranges'. \n
+		For the supported frequency range, see 'Frequency ranges'. \n
 			:param analyzer_freq: No help available
-			:param carrierComponent: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Cc')"""
+			:param carrierComponent: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Cc')
+		"""
 		param = Conversions.decimal_value_to_str(analyzer_freq)
-		carrierComponent_cmd_val = self._base.get_repcap_cmd_value(carrierComponent, repcap.CarrierComponent)
+		carrierComponent_cmd_val = self._cmd_group.get_repcap_cmd_value(carrierComponent, repcap.CarrierComponent)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:RFSettings:CC{carrierComponent_cmd_val}:FREQuency {param}')
 
 	def get(self, carrierComponent=repcap.CarrierComponent.Default) -> float:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:RFSettings:CC<Nr>:FREQuency \n
-		Snippet: value: float = driver.configure.rfSettings.cc.frequency.get(carrierComponent = repcap.CarrierComponent.Default) \n
+		Snippet: value: float = driver.configure.lteMeas.rfSettings.cc.frequency.get(carrierComponent = repcap.CarrierComponent.Default) \n
 		Selects the center frequency of component carrier CC<no>. Without carrier aggregation, you can omit <no>. Using the unit
 		CH, the frequency can be set via the channel number. The allowed channel number range depends on the operating band, see
-		'Frequency Bands'.
+		'Frequency bands'.
 			INTRO_CMD_HELP: For Signal Path = Network, use: \n
 			- [CONFigure:]SIGNaling:LTE:CELL:RFSettings:UL:FREQuency
 			- [CONFigure:]SIGNaling:LTE:CELL:RFSettings:UL:EARFcn
-		For the supported frequency range, see 'Frequency Ranges'. \n
+		For the supported frequency range, see 'Frequency ranges'. \n
 			:param carrierComponent: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Cc')
 			:return: analyzer_freq: No help available"""
-		carrierComponent_cmd_val = self._base.get_repcap_cmd_value(carrierComponent, repcap.CarrierComponent)
+		carrierComponent_cmd_val = self._cmd_group.get_repcap_cmd_value(carrierComponent, repcap.CarrierComponent)
 		response = self._core.io.query_str(f'CONFigure:LTE:MEASurement<Instance>:RFSettings:CC{carrierComponent_cmd_val}:FREQuency?')
 		return Conversions.str_to_float(response)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/RfSettings_/Pcc.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/RfSettings/Pcc.py`

 * *Files 11% similar despite different names*

```diff
@@ -1,30 +1,30 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
-from ....Internal import Conversions
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
+from .....Internal import Conversions
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Pcc:
-	"""Pcc commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class PccCls:
+	"""Pcc commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("pcc", core, parent)
+		self._cmd_group = CommandsGroup("pcc", core, parent)
 
 	def get_frequency(self) -> float:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:RFSettings[:PCC]:FREQuency \n
-		Snippet: value: float = driver.configure.rfSettings.pcc.get_frequency() \n
+		Snippet: value: float = driver.configure.lteMeas.rfSettings.pcc.get_frequency() \n
 		No command help available \n
 			:return: analyzer_freq: No help available
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:RFSettings:PCC:FREQuency?')
 		return Conversions.str_to_float(response)
 
 	def set_frequency(self, analyzer_freq: float) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:RFSettings[:PCC]:FREQuency \n
-		Snippet: driver.configure.rfSettings.pcc.set_frequency(analyzer_freq = 1.0) \n
+		Snippet: driver.configure.lteMeas.rfSettings.pcc.set_frequency(analyzer_freq = 1.0) \n
 		No command help available \n
 			:param analyzer_freq: No help available
 		"""
 		param = Conversions.decimal_value_to_str(analyzer_freq)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:RFSettings:PCC:FREQuency {param}')
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/RfSettings_/Scc.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/Scc/__init__.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,42 +1,42 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
-from ....Internal.RepeatedCapability import RepeatedCapability
-from .... import repcap
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
+from .....Internal.RepeatedCapability import RepeatedCapability
+from ..... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Scc:
-	"""Scc commands group definition. 1 total commands, 1 Sub-groups, 0 group commands
+class SccCls:
+	"""Scc commands group definition. 1 total commands, 1 Subgroups, 0 group commands
 	Repeated Capability: SecondaryCC, default value after init: SecondaryCC.CC1"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("scc", core, parent)
-		self._base.rep_cap = RepeatedCapability(self._base.group_name, 'repcap_secondaryCC_get', 'repcap_secondaryCC_set', repcap.SecondaryCC.CC1)
+		self._cmd_group = CommandsGroup("scc", core, parent)
+		self._cmd_group.rep_cap = RepeatedCapability(self._cmd_group.group_name, 'repcap_secondaryCC_get', 'repcap_secondaryCC_set', repcap.SecondaryCC.CC1)
 
-	def repcap_secondaryCC_set(self, enum_value: repcap.SecondaryCC) -> None:
+	def repcap_secondaryCC_set(self, secondaryCC: repcap.SecondaryCC) -> None:
 		"""Repeated Capability default value numeric suffix.
 		This value is used, if you do not explicitely set it in the child set/get methods, or if you leave it to SecondaryCC.Default
 		Default value after init: SecondaryCC.CC1"""
-		self._base.set_repcap_enum_value(enum_value)
+		self._cmd_group.set_repcap_enum_value(secondaryCC)
 
 	def repcap_secondaryCC_get(self) -> repcap.SecondaryCC:
 		"""Returns the current default repeated capability for the child set/get methods"""
 		# noinspection PyTypeChecker
-		return self._base.get_repcap_enum_value()
+		return self._cmd_group.get_repcap_enum_value()
 
 	@property
-	def frequency(self):
-		"""frequency commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_frequency'):
-			from .Scc_.Frequency import Frequency
-			self._frequency = Frequency(self._core, self._base)
-		return self._frequency
+	def channelBw(self):
+		"""channelBw commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_channelBw'):
+			from .ChannelBw import ChannelBwCls
+			self._channelBw = ChannelBwCls(self._core, self._cmd_group)
+		return self._channelBw
 
-	def clone(self) -> 'Scc':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'SccCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Scc(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = SccCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/RfSettings_/Scc_/Frequency.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/RfSettings/Scc/Frequency.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,33 +1,34 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
-from .....Internal import Conversions
-from ..... import repcap
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal import Conversions
+from ...... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Frequency:
-	"""Frequency commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class FrequencyCls:
+	"""Frequency commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("frequency", core, parent)
+		self._cmd_group = CommandsGroup("frequency", core, parent)
 
 	def set(self, analyzer_freq: float, secondaryCC=repcap.SecondaryCC.Default) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:RFSettings:SCC<Nr>:FREQuency \n
-		Snippet: driver.configure.rfSettings.scc.frequency.set(analyzer_freq = 1.0, secondaryCC = repcap.SecondaryCC.Default) \n
+		Snippet: driver.configure.lteMeas.rfSettings.scc.frequency.set(analyzer_freq = 1.0, secondaryCC = repcap.SecondaryCC.Default) \n
 		No command help available \n
 			:param analyzer_freq: No help available
-			:param secondaryCC: optional repeated capability selector. Default value: CC1 (settable in the interface 'Scc')"""
+			:param secondaryCC: optional repeated capability selector. Default value: CC1 (settable in the interface 'Scc')
+		"""
 		param = Conversions.decimal_value_to_str(analyzer_freq)
-		secondaryCC_cmd_val = self._base.get_repcap_cmd_value(secondaryCC, repcap.SecondaryCC)
+		secondaryCC_cmd_val = self._cmd_group.get_repcap_cmd_value(secondaryCC, repcap.SecondaryCC)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:RFSettings:SCC{secondaryCC_cmd_val}:FREQuency {param}')
 
 	def get(self, secondaryCC=repcap.SecondaryCC.Default) -> float:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:RFSettings:SCC<Nr>:FREQuency \n
-		Snippet: value: float = driver.configure.rfSettings.scc.frequency.get(secondaryCC = repcap.SecondaryCC.Default) \n
+		Snippet: value: float = driver.configure.lteMeas.rfSettings.scc.frequency.get(secondaryCC = repcap.SecondaryCC.Default) \n
 		No command help available \n
 			:param secondaryCC: optional repeated capability selector. Default value: CC1 (settable in the interface 'Scc')
 			:return: analyzer_freq: No help available"""
-		secondaryCC_cmd_val = self._base.get_repcap_cmd_value(secondaryCC, repcap.SecondaryCC)
+		secondaryCC_cmd_val = self._cmd_group.get_repcap_cmd_value(secondaryCC, repcap.SecondaryCC)
 		response = self._core.io.query_str(f'CONFigure:LTE:MEASurement<Instance>:RFSettings:SCC{secondaryCC_cmd_val}:FREQuency?')
 		return Conversions.str_to_float(response)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/Scc.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/InbandEmission/Ulca/Scc/__init__.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,42 +1,42 @@
-from ...Internal.Core import Core
-from ...Internal.CommandsGroup import CommandsGroup
-from ...Internal.RepeatedCapability import RepeatedCapability
-from ... import repcap
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal.RepeatedCapability import RepeatedCapability
+from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Scc:
-	"""Scc commands group definition. 1 total commands, 1 Sub-groups, 0 group commands
+class SccCls:
+	"""Scc commands group definition. 6 total commands, 1 Subgroups, 0 group commands
 	Repeated Capability: SecondaryCC, default value after init: SecondaryCC.CC1"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("scc", core, parent)
-		self._base.rep_cap = RepeatedCapability(self._base.group_name, 'repcap_secondaryCC_get', 'repcap_secondaryCC_set', repcap.SecondaryCC.CC1)
+		self._cmd_group = CommandsGroup("scc", core, parent)
+		self._cmd_group.rep_cap = RepeatedCapability(self._cmd_group.group_name, 'repcap_secondaryCC_get', 'repcap_secondaryCC_set', repcap.SecondaryCC.CC1)
 
-	def repcap_secondaryCC_set(self, enum_value: repcap.SecondaryCC) -> None:
+	def repcap_secondaryCC_set(self, secondaryCC: repcap.SecondaryCC) -> None:
 		"""Repeated Capability default value numeric suffix.
 		This value is used, if you do not explicitely set it in the child set/get methods, or if you leave it to SecondaryCC.Default
 		Default value after init: SecondaryCC.CC1"""
-		self._base.set_repcap_enum_value(enum_value)
+		self._cmd_group.set_repcap_enum_value(secondaryCC)
 
 	def repcap_secondaryCC_get(self) -> repcap.SecondaryCC:
 		"""Returns the current default repeated capability for the child set/get methods"""
 		# noinspection PyTypeChecker
-		return self._base.get_repcap_enum_value()
+		return self._cmd_group.get_repcap_enum_value()
 
 	@property
-	def channelBw(self):
-		"""channelBw commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_channelBw'):
-			from .Scc_.ChannelBw import ChannelBw
-			self._channelBw = ChannelBw(self._core, self._base)
-		return self._channelBw
+	def margin(self):
+		"""margin commands group. 4 Sub-classes, 0 commands."""
+		if not hasattr(self, '_margin'):
+			from .Margin import MarginCls
+			self._margin = MarginCls(self._core, self._cmd_group)
+		return self._margin
 
-	def clone(self) -> 'Scc':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'SccCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Scc(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = SccCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/Scc_/ChannelBw.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/Scc/ChannelBw.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,35 +1,36 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
-from ....Internal import Conversions
-from .... import enums
-from .... import repcap
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
+from .....Internal import Conversions
+from ..... import enums
+from ..... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class ChannelBw:
-	"""ChannelBw commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class ChannelBwCls:
+	"""ChannelBw commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("channelBw", core, parent)
+		self._cmd_group = CommandsGroup("channelBw", core, parent)
 
 	def set(self, channel_bw: enums.ChannelBandwidth, secondaryCC=repcap.SecondaryCC.Default) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:SCC<Nr>:CBANdwidth \n
-		Snippet: driver.configure.scc.channelBw.set(channel_bw = enums.ChannelBandwidth.B014, secondaryCC = repcap.SecondaryCC.Default) \n
+		Snippet: driver.configure.lteMeas.scc.channelBw.set(channel_bw = enums.ChannelBandwidth.B014, secondaryCC = repcap.SecondaryCC.Default) \n
 		No command help available \n
 			:param channel_bw: No help available
-			:param secondaryCC: optional repeated capability selector. Default value: CC1 (settable in the interface 'Scc')"""
+			:param secondaryCC: optional repeated capability selector. Default value: CC1 (settable in the interface 'Scc')
+		"""
 		param = Conversions.enum_scalar_to_str(channel_bw, enums.ChannelBandwidth)
-		secondaryCC_cmd_val = self._base.get_repcap_cmd_value(secondaryCC, repcap.SecondaryCC)
+		secondaryCC_cmd_val = self._cmd_group.get_repcap_cmd_value(secondaryCC, repcap.SecondaryCC)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:SCC{secondaryCC_cmd_val}:CBANdwidth {param}')
 
 	# noinspection PyTypeChecker
 	def get(self, secondaryCC=repcap.SecondaryCC.Default) -> enums.ChannelBandwidth:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:SCC<Nr>:CBANdwidth \n
-		Snippet: value: enums.ChannelBandwidth = driver.configure.scc.channelBw.get(secondaryCC = repcap.SecondaryCC.Default) \n
+		Snippet: value: enums.ChannelBandwidth = driver.configure.lteMeas.scc.channelBw.get(secondaryCC = repcap.SecondaryCC.Default) \n
 		No command help available \n
 			:param secondaryCC: optional repeated capability selector. Default value: CC1 (settable in the interface 'Scc')
 			:return: channel_bw: No help available"""
-		secondaryCC_cmd_val = self._base.get_repcap_cmd_value(secondaryCC, repcap.SecondaryCC)
+		secondaryCC_cmd_val = self._cmd_group.get_repcap_cmd_value(secondaryCC, repcap.SecondaryCC)
 		response = self._core.io.query_str(f'CONFigure:LTE:MEASurement<Instance>:SCC{secondaryCC_cmd_val}:CBANdwidth?')
 		return Conversions.str_to_scalar_enum(response, enums.ChannelBandwidth)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/Srs.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/Srs/__init__.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,168 +1,168 @@
-from ...Internal.Core import Core
-from ...Internal.CommandsGroup import CommandsGroup
-from ...Internal import Conversions
-from ... import enums
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
+from .....Internal import Conversions
+from ..... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Srs:
-	"""Srs commands group definition. 8 total commands, 2 Sub-groups, 6 group commands"""
+class SrsCls:
+	"""Srs commands group definition. 8 total commands, 2 Subgroups, 6 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("srs", core, parent)
+		self._cmd_group = CommandsGroup("srs", core, parent)
 
 	@property
 	def scount(self):
 		"""scount commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_scount'):
-			from .Srs_.Scount import Scount
-			self._scount = Scount(self._core, self._base)
+			from .Scount import ScountCls
+			self._scount = ScountCls(self._core, self._cmd_group)
 		return self._scount
 
 	@property
 	def limit(self):
-		"""limit commands group. 0 Sub-classes, 1 commands."""
+		"""limit commands group. 1 Sub-classes, 0 commands."""
 		if not hasattr(self, '_limit'):
-			from .Srs_.Limit import Limit
-			self._limit = Limit(self._core, self._base)
+			from .Limit import LimitCls
+			self._limit = LimitCls(self._core, self._cmd_group)
 		return self._limit
 
 	# noinspection PyTypeChecker
 	def get_view(self) -> enums.ViewSrs:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:SRS:VIEW \n
-		Snippet: value: enums.ViewSrs = driver.configure.srs.get_view() \n
+		Snippet: value: enums.ViewSrs = driver.configure.lteMeas.srs.get_view() \n
 		No command help available \n
 			:return: view: No help available
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:SRS:VIEW?')
 		return Conversions.str_to_scalar_enum(response, enums.ViewSrs)
 
 	def set_view(self, view: enums.ViewSrs) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:SRS:VIEW \n
-		Snippet: driver.configure.srs.set_view(view = enums.ViewSrs.PDYNamics) \n
+		Snippet: driver.configure.lteMeas.srs.set_view(view = enums.ViewSrs.PDYNamics) \n
 		No command help available \n
 			:param view: No help available
 		"""
 		param = Conversions.enum_scalar_to_str(view, enums.ViewSrs)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:SRS:VIEW {param}')
 
 	def get_timeout(self) -> float:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:SRS:TOUT \n
-		Snippet: value: float = driver.configure.srs.get_timeout() \n
+		Snippet: value: float = driver.configure.lteMeas.srs.get_timeout() \n
 		Defines a timeout for the measurement. The timer is started when the measurement is initiated via a READ or INIT command.
-		It is not started if the measurement is initiated manually (ON | OFF key or RESTART | STOP key) . When the measurement
-		has completed the first measurement cycle (first single shot) , the statistical depth is reached and the timer is reset.
-		If the first measurement cycle has not been completed when the timer expires, the measurement is stopped. The measurement
-		state changes to RDY. The reliability indicator is set to 1, indicating that a measurement timeout occurred.
-		Still running READ, FETCh or CALCulate commands are completed, returning the available results. At least for some results,
-		there are no values at all or the statistical depth has not been reached. A timeout of 0 s corresponds to an infinite
-		measurement timeout. \n
+		It is not started if the measurement is initiated manually. When the measurement has completed the first measurement
+		cycle (first single shot) , the statistical depth is reached and the timer is reset. If the first measurement cycle has
+		not been completed when the timer expires, the measurement is stopped. The measurement state changes to RDY.
+		The reliability indicator is set to 1, indicating that a measurement timeout occurred. Still running READ, FETCh or
+		CALCulate commands are completed, returning the available results. At least for some results, there are no values at all
+		or the statistical depth has not been reached. A timeout of 0 s corresponds to an infinite measurement timeout. \n
 			:return: timeout: No help available
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:SRS:TOUT?')
 		return Conversions.str_to_float(response)
 
 	def set_timeout(self, timeout: float) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:SRS:TOUT \n
-		Snippet: driver.configure.srs.set_timeout(timeout = 1.0) \n
+		Snippet: driver.configure.lteMeas.srs.set_timeout(timeout = 1.0) \n
 		Defines a timeout for the measurement. The timer is started when the measurement is initiated via a READ or INIT command.
-		It is not started if the measurement is initiated manually (ON | OFF key or RESTART | STOP key) . When the measurement
-		has completed the first measurement cycle (first single shot) , the statistical depth is reached and the timer is reset.
-		If the first measurement cycle has not been completed when the timer expires, the measurement is stopped. The measurement
-		state changes to RDY. The reliability indicator is set to 1, indicating that a measurement timeout occurred.
-		Still running READ, FETCh or CALCulate commands are completed, returning the available results. At least for some results,
-		there are no values at all or the statistical depth has not been reached. A timeout of 0 s corresponds to an infinite
-		measurement timeout. \n
+		It is not started if the measurement is initiated manually. When the measurement has completed the first measurement
+		cycle (first single shot) , the statistical depth is reached and the timer is reset. If the first measurement cycle has
+		not been completed when the timer expires, the measurement is stopped. The measurement state changes to RDY.
+		The reliability indicator is set to 1, indicating that a measurement timeout occurred. Still running READ, FETCh or
+		CALCulate commands are completed, returning the available results. At least for some results, there are no values at all
+		or the statistical depth has not been reached. A timeout of 0 s corresponds to an infinite measurement timeout. \n
 			:param timeout: No help available
 		"""
 		param = Conversions.decimal_value_to_str(timeout)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:SRS:TOUT {param}')
 
 	# noinspection PyTypeChecker
 	def get_repetition(self) -> enums.Repeat:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:SRS:REPetition \n
-		Snippet: value: enums.Repeat = driver.configure.srs.get_repetition() \n
+		Snippet: value: enums.Repeat = driver.configure.lteMeas.srs.get_repetition() \n
 		Specifies the repetition mode of the measurement. The repetition mode specifies whether the measurement is stopped after
 		a single shot or repeated continuously. Use CONFigure:..:MEAS<i>:...:SCOunt to determine the number of measurement
 		intervals per single shot. \n
 			:return: repetition: SINGleshot: Single-shot measurement CONTinuous: Continuous measurement
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:SRS:REPetition?')
 		return Conversions.str_to_scalar_enum(response, enums.Repeat)
 
 	def set_repetition(self, repetition: enums.Repeat) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:SRS:REPetition \n
-		Snippet: driver.configure.srs.set_repetition(repetition = enums.Repeat.CONTinuous) \n
+		Snippet: driver.configure.lteMeas.srs.set_repetition(repetition = enums.Repeat.CONTinuous) \n
 		Specifies the repetition mode of the measurement. The repetition mode specifies whether the measurement is stopped after
 		a single shot or repeated continuously. Use CONFigure:..:MEAS<i>:...:SCOunt to determine the number of measurement
 		intervals per single shot. \n
 			:param repetition: SINGleshot: Single-shot measurement CONTinuous: Continuous measurement
 		"""
 		param = Conversions.enum_scalar_to_str(repetition, enums.Repeat)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:SRS:REPetition {param}')
 
 	# noinspection PyTypeChecker
 	def get_scondition(self) -> enums.StopCondition:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:SRS:SCONdition \n
-		Snippet: value: enums.StopCondition = driver.configure.srs.get_scondition() \n
+		Snippet: value: enums.StopCondition = driver.configure.lteMeas.srs.get_scondition() \n
 		Qualifies whether the measurement is stopped after a failed limit check or continued. SLFail means that the measurement
 		is stopped and reaches the RDY state when one of the results exceeds the limits. \n
-			:return: stop_condition: NONE: Continue measurement irrespective of the limit check SLFail: Stop measurement on limit failure
+			:return: stop_condition: NONE: Continue measurement irrespective of the limit check. SLFail: Stop measurement on limit failure.
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:SRS:SCONdition?')
 		return Conversions.str_to_scalar_enum(response, enums.StopCondition)
 
 	def set_scondition(self, stop_condition: enums.StopCondition) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:SRS:SCONdition \n
-		Snippet: driver.configure.srs.set_scondition(stop_condition = enums.StopCondition.NONE) \n
+		Snippet: driver.configure.lteMeas.srs.set_scondition(stop_condition = enums.StopCondition.NONE) \n
 		Qualifies whether the measurement is stopped after a failed limit check or continued. SLFail means that the measurement
 		is stopped and reaches the RDY state when one of the results exceeds the limits. \n
-			:param stop_condition: NONE: Continue measurement irrespective of the limit check SLFail: Stop measurement on limit failure
+			:param stop_condition: NONE: Continue measurement irrespective of the limit check. SLFail: Stop measurement on limit failure.
 		"""
 		param = Conversions.enum_scalar_to_str(stop_condition, enums.StopCondition)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:SRS:SCONdition {param}')
 
 	def get_mo_exception(self) -> bool:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:SRS:MOEXception \n
-		Snippet: value: bool = driver.configure.srs.get_mo_exception() \n
-		Specifies whether measurement results that the R&S CMX500 identifies as faulty or inaccurate are rejected. \n
-			:return: meas_on_exception: OFF: Faulty results are rejected ON: Results are never rejected
+		Snippet: value: bool = driver.configure.lteMeas.srs.get_mo_exception() \n
+		Specifies whether measurement results that the CMX500 identifies as faulty or inaccurate are rejected. \n
+			:return: meas_on_exception: OFF: Faulty results are rejected. ON: Results are never rejected.
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:SRS:MOEXception?')
 		return Conversions.str_to_bool(response)
 
 	def set_mo_exception(self, meas_on_exception: bool) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:SRS:MOEXception \n
-		Snippet: driver.configure.srs.set_mo_exception(meas_on_exception = False) \n
-		Specifies whether measurement results that the R&S CMX500 identifies as faulty or inaccurate are rejected. \n
-			:param meas_on_exception: OFF: Faulty results are rejected ON: Results are never rejected
+		Snippet: driver.configure.lteMeas.srs.set_mo_exception(meas_on_exception = False) \n
+		Specifies whether measurement results that the CMX500 identifies as faulty or inaccurate are rejected. \n
+			:param meas_on_exception: OFF: Faulty results are rejected. ON: Results are never rejected.
 		"""
 		param = Conversions.bool_to_str(meas_on_exception)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:SRS:MOEXception {param}')
 
 	def get_hdmode(self) -> bool:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:SRS:HDMode \n
-		Snippet: value: bool = driver.configure.srs.get_hdmode() \n
-		Enables or disables the high dynamic mode for power dynamics measurements. \n
+		Snippet: value: bool = driver.configure.lteMeas.srs.get_hdmode() \n
+		Enables or disables the high dynamic mode for power dynamics measurements. With RF path sharing, this command is not
+		applicable. \n
 			:return: high_dynamic_mode: No help available
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:SRS:HDMode?')
 		return Conversions.str_to_bool(response)
 
 	def set_hdmode(self, high_dynamic_mode: bool) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:SRS:HDMode \n
-		Snippet: driver.configure.srs.set_hdmode(high_dynamic_mode = False) \n
-		Enables or disables the high dynamic mode for power dynamics measurements. \n
+		Snippet: driver.configure.lteMeas.srs.set_hdmode(high_dynamic_mode = False) \n
+		Enables or disables the high dynamic mode for power dynamics measurements. With RF path sharing, this command is not
+		applicable. \n
 			:param high_dynamic_mode: No help available
 		"""
 		param = Conversions.bool_to_str(high_dynamic_mode)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:SRS:HDMode {param}')
 
-	def clone(self) -> 'Srs':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'SrsCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Srs(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = SrsCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/Srs_/Limit.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/Srs/Limit/Pdynamics.py`

 * *Files 21% similar despite different names*

```diff
@@ -1,24 +1,39 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
-from ....Internal.StructBase import StructBase
-from ....Internal.ArgStruct import ArgStruct
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal.Types import DataType
+from ......Internal.StructBase import StructBase
+from ......Internal.ArgStruct import ArgStruct
+from ......Internal.ArgSingleList import ArgSingleList
+from ......Internal.ArgSingle import ArgSingle
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Limit:
-	"""Limit commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class PdynamicsCls:
+	"""Pdynamics commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("limit", core, parent)
+		self._cmd_group = CommandsGroup("pdynamics", core, parent)
+
+	def set(self, enable: bool, on_power_upper: float, on_power_lower: float, off_power_upper: float) -> None:
+		"""SCPI: CONFigure:LTE:MEASurement<Instance>:SRS:LIMit:PDYNamics \n
+		Snippet: driver.configure.lteMeas.srs.limit.pdynamics.set(enable = False, on_power_upper = 1.0, on_power_lower = 1.0, off_power_upper = 1.0) \n
+		Defines limits for the ON power and OFF power determined with the power dynamics measurement. \n
+			:param enable: OFF: disables the limit check ON: enables the limit check
+			:param on_power_upper: Upper limit for the ON power
+			:param on_power_lower: Lower limit for the ON power
+			:param off_power_upper: Upper limit for the OFF power
+		"""
+		param = ArgSingleList().compose_cmd_string(ArgSingle('enable', enable, DataType.Boolean), ArgSingle('on_power_upper', on_power_upper, DataType.Float), ArgSingle('on_power_lower', on_power_lower, DataType.Float), ArgSingle('off_power_upper', off_power_upper, DataType.Float))
+		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:SRS:LIMit:PDYNamics {param}'.rstrip())
 
 	# noinspection PyTypeChecker
 	class PdynamicsStruct(StructBase):
-		"""Structure for reading output parameters. Fields: \n
+		"""Response structure. Fields: \n
 			- Enable: bool: OFF: disables the limit check ON: enables the limit check
 			- On_Power_Upper: float: Upper limit for the ON power
 			- On_Power_Lower: float: Lower limit for the ON power
 			- Off_Power_Upper: float: Upper limit for the OFF power"""
 		__meta_args_list = [
 			ArgStruct.scalar_bool('Enable'),
 			ArgStruct.scalar_float('On_Power_Upper'),
@@ -28,22 +43,13 @@
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Enable: bool = None
 			self.On_Power_Upper: float = None
 			self.On_Power_Lower: float = None
 			self.Off_Power_Upper: float = None
 
-	def get_pdynamics(self) -> PdynamicsStruct:
+	def get(self) -> PdynamicsStruct:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:SRS:LIMit:PDYNamics \n
-		Snippet: value: PdynamicsStruct = driver.configure.srs.limit.get_pdynamics() \n
+		Snippet: value: PdynamicsStruct = driver.configure.lteMeas.srs.limit.pdynamics.get() \n
 		Defines limits for the ON power and OFF power determined with the power dynamics measurement. \n
-			:return: structure: for return value, see the help for PdynamicsStruct structure arguments.
-		"""
-		return self._core.io.query_struct('CONFigure:LTE:MEASurement<Instance>:SRS:LIMit:PDYNamics?', self.__class__.PdynamicsStruct())
-
-	def set_pdynamics(self, value: PdynamicsStruct) -> None:
-		"""SCPI: CONFigure:LTE:MEASurement<Instance>:SRS:LIMit:PDYNamics \n
-		Snippet: driver.configure.srs.limit.set_pdynamics(value = PdynamicsStruct()) \n
-		Defines limits for the ON power and OFF power determined with the power dynamics measurement. \n
-			:param value: see the help for PdynamicsStruct structure arguments.
-		"""
-		self._core.io.write_struct('CONFigure:LTE:MEASurement<Instance>:SRS:LIMit:PDYNamics', value)
+			:return: structure: for return value, see the help for PdynamicsStruct structure arguments."""
+		return self._core.io.query_struct(f'CONFigure:LTE:MEASurement<Instance>:SRS:LIMit:PDYNamics?', self.__class__.PdynamicsStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Configure_/Srs_/Scount.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/Srs/Scount.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,32 +1,32 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
-from ....Internal import Conversions
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
+from .....Internal import Conversions
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Scount:
-	"""Scount commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class ScountCls:
+	"""Scount commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("scount", core, parent)
+		self._cmd_group = CommandsGroup("scount", core, parent)
 
 	def get_pdynamics(self) -> int:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:SRS:SCOunt:PDYNamics \n
-		Snippet: value: int = driver.configure.srs.scount.get_pdynamics() \n
+		Snippet: value: int = driver.configure.lteMeas.srs.scount.get_pdynamics() \n
 		Specifies the statistic count of the measurement. The statistic count is equal to the number of measurement intervals per
 		single shot. \n
 			:return: statistic_count: Number of measurement intervals
 		"""
 		response = self._core.io.query_str('CONFigure:LTE:MEASurement<Instance>:SRS:SCOunt:PDYNamics?')
 		return Conversions.str_to_int(response)
 
 	def set_pdynamics(self, statistic_count: int) -> None:
 		"""SCPI: CONFigure:LTE:MEASurement<Instance>:SRS:SCOunt:PDYNamics \n
-		Snippet: driver.configure.srs.scount.set_pdynamics(statistic_count = 1) \n
+		Snippet: driver.configure.lteMeas.srs.scount.set_pdynamics(statistic_count = 1) \n
 		Specifies the statistic count of the measurement. The statistic count is equal to the number of measurement intervals per
 		single shot. \n
 			:param statistic_count: Number of measurement intervals
 		"""
 		param = Conversions.decimal_value_to_str(statistic_count)
 		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:SRS:SCOunt:PDYNamics {param}')
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/__init__.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,216 +1,216 @@
-from ..Internal.Core import Core
-from ..Internal.CommandsGroup import CommandsGroup
+from ....Internal.Core import Core
+from ....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class MultiEval:
-	"""MultiEval commands group definition. 657 total commands, 16 Sub-groups, 3 group commands"""
+class MultiEvalCls:
+	"""MultiEval commands group definition. 684 total commands, 19 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("multiEval", core, parent)
+		self._cmd_group = CommandsGroup("multiEval", core, parent)
 
 	@property
 	def state(self):
 		"""state commands group. 1 Sub-classes, 1 commands."""
 		if not hasattr(self, '_state'):
-			from .MultiEval_.State import State
-			self._state = State(self._core, self._base)
+			from .State import StateCls
+			self._state = StateCls(self._core, self._cmd_group)
 		return self._state
 
 	@property
+	def referenceMarker(self):
+		"""referenceMarker commands group. 5 Sub-classes, 0 commands."""
+		if not hasattr(self, '_referenceMarker'):
+			from .ReferenceMarker import ReferenceMarkerCls
+			self._referenceMarker = ReferenceMarkerCls(self._core, self._cmd_group)
+		return self._referenceMarker
+
+	@property
+	def amarker(self):
+		"""amarker commands group. 5 Sub-classes, 0 commands."""
+		if not hasattr(self, '_amarker'):
+			from .Amarker import AmarkerCls
+			self._amarker = AmarkerCls(self._core, self._cmd_group)
+		return self._amarker
+
+	@property
+	def dmarker(self):
+		"""dmarker commands group. 5 Sub-classes, 0 commands."""
+		if not hasattr(self, '_dmarker'):
+			from .Dmarker import DmarkerCls
+			self._dmarker = DmarkerCls(self._core, self._cmd_group)
+		return self._dmarker
+
+	@property
 	def trace(self):
 		"""trace commands group. 10 Sub-classes, 0 commands."""
 		if not hasattr(self, '_trace'):
-			from .MultiEval_.Trace import Trace
-			self._trace = Trace(self._core, self._base)
+			from .Trace import TraceCls
+			self._trace = TraceCls(self._core, self._cmd_group)
 		return self._trace
 
 	@property
 	def vfThroughput(self):
 		"""vfThroughput commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_vfThroughput'):
-			from .MultiEval_.VfThroughput import VfThroughput
-			self._vfThroughput = VfThroughput(self._core, self._base)
+			from .VfThroughput import VfThroughputCls
+			self._vfThroughput = VfThroughputCls(self._core, self._cmd_group)
 		return self._vfThroughput
 
 	@property
 	def evMagnitude(self):
 		"""evMagnitude commands group. 4 Sub-classes, 0 commands."""
 		if not hasattr(self, '_evMagnitude'):
-			from .MultiEval_.EvMagnitude import EvMagnitude
-			self._evMagnitude = EvMagnitude(self._core, self._base)
+			from .EvMagnitude import EvMagnitudeCls
+			self._evMagnitude = EvMagnitudeCls(self._core, self._cmd_group)
 		return self._evMagnitude
 
 	@property
 	def merror(self):
 		"""merror commands group. 3 Sub-classes, 0 commands."""
 		if not hasattr(self, '_merror'):
-			from .MultiEval_.Merror import Merror
-			self._merror = Merror(self._core, self._base)
+			from .Merror import MerrorCls
+			self._merror = MerrorCls(self._core, self._cmd_group)
 		return self._merror
 
 	@property
 	def perror(self):
 		"""perror commands group. 3 Sub-classes, 0 commands."""
 		if not hasattr(self, '_perror'):
-			from .MultiEval_.Perror import Perror
-			self._perror = Perror(self._core, self._base)
+			from .Perror import PerrorCls
+			self._perror = PerrorCls(self._core, self._cmd_group)
 		return self._perror
 
 	@property
 	def inbandEmission(self):
 		"""inbandEmission commands group. 4 Sub-classes, 0 commands."""
 		if not hasattr(self, '_inbandEmission'):
-			from .MultiEval_.InbandEmission import InbandEmission
-			self._inbandEmission = InbandEmission(self._core, self._base)
+			from .InbandEmission import InbandEmissionCls
+			self._inbandEmission = InbandEmissionCls(self._core, self._cmd_group)
 		return self._inbandEmission
 
 	@property
 	def esFlatness(self):
 		"""esFlatness commands group. 4 Sub-classes, 0 commands."""
 		if not hasattr(self, '_esFlatness'):
-			from .MultiEval_.EsFlatness import EsFlatness
-			self._esFlatness = EsFlatness(self._core, self._base)
+			from .EsFlatness import EsFlatnessCls
+			self._esFlatness = EsFlatnessCls(self._core, self._cmd_group)
 		return self._esFlatness
 
 	@property
 	def evmc(self):
 		"""evmc commands group. 1 Sub-classes, 0 commands."""
 		if not hasattr(self, '_evmc'):
-			from .MultiEval_.Evmc import Evmc
-			self._evmc = Evmc(self._core, self._base)
+			from .Evmc import EvmcCls
+			self._evmc = EvmcCls(self._core, self._cmd_group)
 		return self._evmc
 
 	@property
 	def modulation(self):
 		"""modulation commands group. 8 Sub-classes, 0 commands."""
 		if not hasattr(self, '_modulation'):
-			from .MultiEval_.Modulation import Modulation
-			self._modulation = Modulation(self._core, self._base)
+			from .Modulation import ModulationCls
+			self._modulation = ModulationCls(self._core, self._cmd_group)
 		return self._modulation
 
 	@property
 	def seMask(self):
 		"""seMask commands group. 9 Sub-classes, 0 commands."""
 		if not hasattr(self, '_seMask'):
-			from .MultiEval_.SeMask import SeMask
-			self._seMask = SeMask(self._core, self._base)
+			from .SeMask import SeMaskCls
+			self._seMask = SeMaskCls(self._core, self._cmd_group)
 		return self._seMask
 
 	@property
 	def aclr(self):
 		"""aclr commands group. 4 Sub-classes, 0 commands."""
 		if not hasattr(self, '_aclr'):
-			from .MultiEval_.Aclr import Aclr
-			self._aclr = Aclr(self._core, self._base)
+			from .Aclr import AclrCls
+			self._aclr = AclrCls(self._core, self._cmd_group)
 		return self._aclr
 
 	@property
 	def pdynamics(self):
 		"""pdynamics commands group. 5 Sub-classes, 0 commands."""
 		if not hasattr(self, '_pdynamics'):
-			from .MultiEval_.Pdynamics import Pdynamics
-			self._pdynamics = Pdynamics(self._core, self._base)
+			from .Pdynamics import PdynamicsCls
+			self._pdynamics = PdynamicsCls(self._core, self._cmd_group)
 		return self._pdynamics
 
 	@property
 	def pmonitor(self):
 		"""pmonitor commands group. 9 Sub-classes, 0 commands."""
 		if not hasattr(self, '_pmonitor'):
-			from .MultiEval_.Pmonitor import Pmonitor
-			self._pmonitor = Pmonitor(self._core, self._base)
+			from .Pmonitor import PmonitorCls
+			self._pmonitor = PmonitorCls(self._core, self._cmd_group)
 		return self._pmonitor
 
 	@property
 	def bler(self):
 		"""bler commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_bler'):
-			from .MultiEval_.Bler import Bler
-			self._bler = Bler(self._core, self._base)
+			from .Bler import BlerCls
+			self._bler = BlerCls(self._core, self._cmd_group)
 		return self._bler
 
 	@property
 	def listPy(self):
 		"""listPy commands group. 9 Sub-classes, 0 commands."""
 		if not hasattr(self, '_listPy'):
-			from .MultiEval_.ListPy import ListPy
-			self._listPy = ListPy(self._core, self._base)
+			from .ListPy import ListPyCls
+			self._listPy = ListPyCls(self._core, self._cmd_group)
 		return self._listPy
 
-	def initiate(self) -> None:
+	def initiate(self, opc_timeout_ms: int = -1) -> None:
 		"""SCPI: INITiate:LTE:MEASurement<Instance>:MEValuation \n
-		Snippet: driver.multiEval.initiate() \n
-			INTRO_CMD_HELP: Starts, stops, or aborts the measurement: \n
-			- INITiate... starts or restarts the measurement. The measurement enters the 'RUN' state.
-			- STOP... halts the measurement immediately. The measurement enters the 'RDY' state. Measurement results are kept. The resources remain allocated to the measurement.
-			- ABORt... halts the measurement immediately. The measurement enters the 'OFF' state. All measurement values are set to NAV. Allocated resources are released.
+		Snippet: driver.lteMeas.multiEval.initiate() \n
+			INTRO_CMD_HELP: Starts, stops or aborts the measurement: \n
+			- INITiate... starts or restarts the measurement. The measurement enters the RUN state.
+			- STOP... halts the measurement immediately. The measurement enters the RDY state. Measurement results are kept. The resources remain allocated to the measurement.
+			- ABORt... halts the measurement immediately. The measurement enters the OFF state. All measurement values are set to NAV. Allocated resources are released.
 		Use FETCh...STATe? to query the current measurement state. \n
-		"""
-		self._core.io.write(f'INITiate:LTE:MEASurement<Instance>:MEValuation')
-
-	def initiate_with_opc(self) -> None:
-		"""SCPI: INITiate:LTE:MEASurement<Instance>:MEValuation \n
-		Snippet: driver.multiEval.initiate_with_opc() \n
-			INTRO_CMD_HELP: Starts, stops, or aborts the measurement: \n
-			- INITiate... starts or restarts the measurement. The measurement enters the 'RUN' state.
-			- STOP... halts the measurement immediately. The measurement enters the 'RDY' state. Measurement results are kept. The resources remain allocated to the measurement.
-			- ABORt... halts the measurement immediately. The measurement enters the 'OFF' state. All measurement values are set to NAV. Allocated resources are released.
-		Use FETCh...STATe? to query the current measurement state. \n
-		Same as initiate, but waits for the operation to complete before continuing further. Use the RsCMPX_LteMeas.utilities.opc_timeout_set() to set the timeout value. \n
-		"""
-		self._core.io.write_with_opc(f'INITiate:LTE:MEASurement<Instance>:MEValuation')
+			:param opc_timeout_ms: Maximum time to wait in milliseconds, valid only for this call."""
+		self._core.io.write_with_opc(f'INITiate:LTE:MEASurement<Instance>:MEValuation', opc_timeout_ms)
 
 	def stop(self) -> None:
 		"""SCPI: STOP:LTE:MEASurement<Instance>:MEValuation \n
-		Snippet: driver.multiEval.stop() \n
-			INTRO_CMD_HELP: Starts, stops, or aborts the measurement: \n
-			- INITiate... starts or restarts the measurement. The measurement enters the 'RUN' state.
-			- STOP... halts the measurement immediately. The measurement enters the 'RDY' state. Measurement results are kept. The resources remain allocated to the measurement.
-			- ABORt... halts the measurement immediately. The measurement enters the 'OFF' state. All measurement values are set to NAV. Allocated resources are released.
+		Snippet: driver.lteMeas.multiEval.stop() \n
+			INTRO_CMD_HELP: Starts, stops or aborts the measurement: \n
+			- INITiate... starts or restarts the measurement. The measurement enters the RUN state.
+			- STOP... halts the measurement immediately. The measurement enters the RDY state. Measurement results are kept. The resources remain allocated to the measurement.
+			- ABORt... halts the measurement immediately. The measurement enters the OFF state. All measurement values are set to NAV. Allocated resources are released.
 		Use FETCh...STATe? to query the current measurement state. \n
 		"""
 		self._core.io.write(f'STOP:LTE:MEASurement<Instance>:MEValuation')
 
-	def stop_with_opc(self) -> None:
+	def stop_with_opc(self, opc_timeout_ms: int = -1) -> None:
 		"""SCPI: STOP:LTE:MEASurement<Instance>:MEValuation \n
-		Snippet: driver.multiEval.stop_with_opc() \n
-			INTRO_CMD_HELP: Starts, stops, or aborts the measurement: \n
-			- INITiate... starts or restarts the measurement. The measurement enters the 'RUN' state.
-			- STOP... halts the measurement immediately. The measurement enters the 'RDY' state. Measurement results are kept. The resources remain allocated to the measurement.
-			- ABORt... halts the measurement immediately. The measurement enters the 'OFF' state. All measurement values are set to NAV. Allocated resources are released.
+		Snippet: driver.lteMeas.multiEval.stop_with_opc() \n
+			INTRO_CMD_HELP: Starts, stops or aborts the measurement: \n
+			- INITiate... starts or restarts the measurement. The measurement enters the RUN state.
+			- STOP... halts the measurement immediately. The measurement enters the RDY state. Measurement results are kept. The resources remain allocated to the measurement.
+			- ABORt... halts the measurement immediately. The measurement enters the OFF state. All measurement values are set to NAV. Allocated resources are released.
 		Use FETCh...STATe? to query the current measurement state. \n
 		Same as stop, but waits for the operation to complete before continuing further. Use the RsCMPX_LteMeas.utilities.opc_timeout_set() to set the timeout value. \n
-		"""
-		self._core.io.write_with_opc(f'STOP:LTE:MEASurement<Instance>:MEValuation')
-
-	def abort(self) -> None:
-		"""SCPI: ABORt:LTE:MEASurement<Instance>:MEValuation \n
-		Snippet: driver.multiEval.abort() \n
-			INTRO_CMD_HELP: Starts, stops, or aborts the measurement: \n
-			- INITiate... starts or restarts the measurement. The measurement enters the 'RUN' state.
-			- STOP... halts the measurement immediately. The measurement enters the 'RDY' state. Measurement results are kept. The resources remain allocated to the measurement.
-			- ABORt... halts the measurement immediately. The measurement enters the 'OFF' state. All measurement values are set to NAV. Allocated resources are released.
-		Use FETCh...STATe? to query the current measurement state. \n
-		"""
-		self._core.io.write(f'ABORt:LTE:MEASurement<Instance>:MEValuation')
+			:param opc_timeout_ms: Maximum time to wait in milliseconds, valid only for this call."""
+		self._core.io.write_with_opc(f'STOP:LTE:MEASurement<Instance>:MEValuation', opc_timeout_ms)
 
-	def abort_with_opc(self) -> None:
+	def abort(self, opc_timeout_ms: int = -1) -> None:
 		"""SCPI: ABORt:LTE:MEASurement<Instance>:MEValuation \n
-		Snippet: driver.multiEval.abort_with_opc() \n
-			INTRO_CMD_HELP: Starts, stops, or aborts the measurement: \n
-			- INITiate... starts or restarts the measurement. The measurement enters the 'RUN' state.
-			- STOP... halts the measurement immediately. The measurement enters the 'RDY' state. Measurement results are kept. The resources remain allocated to the measurement.
-			- ABORt... halts the measurement immediately. The measurement enters the 'OFF' state. All measurement values are set to NAV. Allocated resources are released.
+		Snippet: driver.lteMeas.multiEval.abort() \n
+			INTRO_CMD_HELP: Starts, stops or aborts the measurement: \n
+			- INITiate... starts or restarts the measurement. The measurement enters the RUN state.
+			- STOP... halts the measurement immediately. The measurement enters the RDY state. Measurement results are kept. The resources remain allocated to the measurement.
+			- ABORt... halts the measurement immediately. The measurement enters the OFF state. All measurement values are set to NAV. Allocated resources are released.
 		Use FETCh...STATe? to query the current measurement state. \n
-		Same as abort, but waits for the operation to complete before continuing further. Use the RsCMPX_LteMeas.utilities.opc_timeout_set() to set the timeout value. \n
-		"""
-		self._core.io.write_with_opc(f'ABORt:LTE:MEASurement<Instance>:MEValuation')
+			:param opc_timeout_ms: Maximum time to wait in milliseconds, valid only for this call."""
+		self._core.io.write_with_opc(f'ABORt:LTE:MEASurement<Instance>:MEValuation', opc_timeout_ms)
 
-	def clone(self) -> 'MultiEval':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'MultiEvalCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = MultiEval(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = MultiEvalCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Aclr.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Aclr/Eutra/Negativ/__init__.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,51 +1,35 @@
-from ...Internal.Core import Core
-from ...Internal.CommandsGroup import CommandsGroup
+from ........Internal.Core import Core
+from ........Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Aclr:
-	"""Aclr commands group definition. 8 total commands, 4 Sub-groups, 0 group commands"""
+class NegativCls:
+	"""Negativ commands group definition. 4 total commands, 2 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("aclr", core, parent)
+		self._cmd_group = CommandsGroup("negativ", core, parent)
 
 	@property
 	def current(self):
-		"""current commands group. 0 Sub-classes, 3 commands."""
+		"""current commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_current'):
-			from .Aclr_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
 	@property
 	def average(self):
-		"""average commands group. 0 Sub-classes, 3 commands."""
+		"""average commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_average'):
-			from .Aclr_.Average import Average
-			self._average = Average(self._core, self._base)
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
 		return self._average
 
-	@property
-	def dchType(self):
-		"""dchType commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_dchType'):
-			from .Aclr_.DchType import DchType
-			self._dchType = DchType(self._core, self._base)
-		return self._dchType
-
-	@property
-	def dallocation(self):
-		"""dallocation commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_dallocation'):
-			from .Aclr_.Dallocation import Dallocation
-			self._dallocation = Dallocation(self._core, self._base)
-		return self._dallocation
-
-	def clone(self) -> 'Aclr':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'NegativCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Aclr(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = NegativCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Aclr_/Average.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Aclr/Current.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,26 +1,26 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
-from ....Internal.StructBase import StructBase
-from ....Internal.ArgStruct import ArgStruct
-from .... import enums
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
+from .....Internal.StructBase import StructBase
+from .....Internal.ArgStruct import ArgStruct
+from ..... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
+			- Reliability: int: 'Reliability indicator'
 			- Utra_2_Neg: float: ACLR for the second UTRA channel with lower frequency
 			- Utra_1_Neg: float: ACLR for the first UTRA channel with lower frequency
 			- Eutra_Negativ: float: ACLR for the first E-UTRA channel with lower frequency
 			- Eutra: float: Power in the allocated E-UTRA channel
 			- Eutra_Positiv: float: ACLR for the first E-UTRA channel with higher frequency
 			- Utra_1_Pos: float: ACLR for the first UTRA channel with higher frequency
 			- Utra_2_Pos: float: ACLR for the second UTRA channel with higher frequency"""
@@ -42,35 +42,35 @@
 			self.Eutra_Negativ: float = None
 			self.Eutra: float = None
 			self.Eutra_Positiv: float = None
 			self.Utra_1_Pos: float = None
 			self.Utra_2_Pos: float = None
 
 	def read(self) -> ResultData:
-		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:ACLR:AVERage \n
-		Snippet: value: ResultData = driver.multiEval.aclr.average.read() \n
+		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:ACLR:CURRent \n
+		Snippet: value: ResultData = driver.lteMeas.multiEval.aclr.current.read() \n
 		Returns the relative ACLR values as displayed in the table below the ACLR diagram. The current and average values can be
 		retrieved. See also 'Square Spectrum ACLR'. The values described below are returned by FETCh and READ commands. CALCulate
 		commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:ACLR:AVERage?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:ACLR:CURRent?', self.__class__.ResultData())
 
 	def fetch(self) -> ResultData:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:ACLR:AVERage \n
-		Snippet: value: ResultData = driver.multiEval.aclr.average.fetch() \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:ACLR:CURRent \n
+		Snippet: value: ResultData = driver.lteMeas.multiEval.aclr.current.fetch() \n
 		Returns the relative ACLR values as displayed in the table below the ACLR diagram. The current and average values can be
 		retrieved. See also 'Square Spectrum ACLR'. The values described below are returned by FETCh and READ commands. CALCulate
 		commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:ACLR:AVERage?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:ACLR:CURRent?', self.__class__.ResultData())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
+			- Reliability: int: 'Reliability indicator'
 			- Utra_2_Neg: enums.ResultStatus2: ACLR for the second UTRA channel with lower frequency
 			- Utra_1_Neg: enums.ResultStatus2: ACLR for the first UTRA channel with lower frequency
 			- Eutra_Negativ: enums.ResultStatus2: ACLR for the first E-UTRA channel with lower frequency
 			- Eutra: enums.ResultStatus2: Power in the allocated E-UTRA channel
 			- Eutra_Positiv: enums.ResultStatus2: ACLR for the first E-UTRA channel with higher frequency
 			- Utra_1_Pos: enums.ResultStatus2: ACLR for the first UTRA channel with higher frequency
 			- Utra_2_Pos: enums.ResultStatus2: ACLR for the second UTRA channel with higher frequency"""
@@ -92,14 +92,14 @@
 			self.Eutra_Negativ: enums.ResultStatus2 = None
 			self.Eutra: enums.ResultStatus2 = None
 			self.Eutra_Positiv: enums.ResultStatus2 = None
 			self.Utra_1_Pos: enums.ResultStatus2 = None
 			self.Utra_2_Pos: enums.ResultStatus2 = None
 
 	def calculate(self) -> CalculateStruct:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:ACLR:AVERage \n
-		Snippet: value: CalculateStruct = driver.multiEval.aclr.average.calculate() \n
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:ACLR:CURRent \n
+		Snippet: value: CalculateStruct = driver.lteMeas.multiEval.aclr.current.calculate() \n
 		Returns the relative ACLR values as displayed in the table below the ACLR diagram. The current and average values can be
 		retrieved. See also 'Square Spectrum ACLR'. The values described below are returned by FETCh and READ commands. CALCulate
 		commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:ACLR:AVERage?', self.__class__.CalculateStruct())
+		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:ACLR:CURRent?', self.__class__.CalculateStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Aclr_/Current.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Aclr/Average.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,26 +1,26 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
-from ....Internal.StructBase import StructBase
-from ....Internal.ArgStruct import ArgStruct
-from .... import enums
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
+from .....Internal.StructBase import StructBase
+from .....Internal.ArgStruct import ArgStruct
+from ..... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class AverageCls:
+	"""Average commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
+			- Reliability: int: 'Reliability indicator'
 			- Utra_2_Neg: float: ACLR for the second UTRA channel with lower frequency
 			- Utra_1_Neg: float: ACLR for the first UTRA channel with lower frequency
 			- Eutra_Negativ: float: ACLR for the first E-UTRA channel with lower frequency
 			- Eutra: float: Power in the allocated E-UTRA channel
 			- Eutra_Positiv: float: ACLR for the first E-UTRA channel with higher frequency
 			- Utra_1_Pos: float: ACLR for the first UTRA channel with higher frequency
 			- Utra_2_Pos: float: ACLR for the second UTRA channel with higher frequency"""
@@ -42,35 +42,35 @@
 			self.Eutra_Negativ: float = None
 			self.Eutra: float = None
 			self.Eutra_Positiv: float = None
 			self.Utra_1_Pos: float = None
 			self.Utra_2_Pos: float = None
 
 	def read(self) -> ResultData:
-		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:ACLR:CURRent \n
-		Snippet: value: ResultData = driver.multiEval.aclr.current.read() \n
+		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:ACLR:AVERage \n
+		Snippet: value: ResultData = driver.lteMeas.multiEval.aclr.average.read() \n
 		Returns the relative ACLR values as displayed in the table below the ACLR diagram. The current and average values can be
 		retrieved. See also 'Square Spectrum ACLR'. The values described below are returned by FETCh and READ commands. CALCulate
 		commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:ACLR:CURRent?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:ACLR:AVERage?', self.__class__.ResultData())
 
 	def fetch(self) -> ResultData:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:ACLR:CURRent \n
-		Snippet: value: ResultData = driver.multiEval.aclr.current.fetch() \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:ACLR:AVERage \n
+		Snippet: value: ResultData = driver.lteMeas.multiEval.aclr.average.fetch() \n
 		Returns the relative ACLR values as displayed in the table below the ACLR diagram. The current and average values can be
 		retrieved. See also 'Square Spectrum ACLR'. The values described below are returned by FETCh and READ commands. CALCulate
 		commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:ACLR:CURRent?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:ACLR:AVERage?', self.__class__.ResultData())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
+			- Reliability: int: 'Reliability indicator'
 			- Utra_2_Neg: enums.ResultStatus2: ACLR for the second UTRA channel with lower frequency
 			- Utra_1_Neg: enums.ResultStatus2: ACLR for the first UTRA channel with lower frequency
 			- Eutra_Negativ: enums.ResultStatus2: ACLR for the first E-UTRA channel with lower frequency
 			- Eutra: enums.ResultStatus2: Power in the allocated E-UTRA channel
 			- Eutra_Positiv: enums.ResultStatus2: ACLR for the first E-UTRA channel with higher frequency
 			- Utra_1_Pos: enums.ResultStatus2: ACLR for the first UTRA channel with higher frequency
 			- Utra_2_Pos: enums.ResultStatus2: ACLR for the second UTRA channel with higher frequency"""
@@ -92,14 +92,14 @@
 			self.Eutra_Negativ: enums.ResultStatus2 = None
 			self.Eutra: enums.ResultStatus2 = None
 			self.Eutra_Positiv: enums.ResultStatus2 = None
 			self.Utra_1_Pos: enums.ResultStatus2 = None
 			self.Utra_2_Pos: enums.ResultStatus2 = None
 
 	def calculate(self) -> CalculateStruct:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:ACLR:CURRent \n
-		Snippet: value: CalculateStruct = driver.multiEval.aclr.current.calculate() \n
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:ACLR:AVERage \n
+		Snippet: value: CalculateStruct = driver.lteMeas.multiEval.aclr.average.calculate() \n
 		Returns the relative ACLR values as displayed in the table below the ACLR diagram. The current and average values can be
 		retrieved. See also 'Square Spectrum ACLR'. The values described below are returned by FETCh and READ commands. CALCulate
 		commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:ACLR:CURRent?', self.__class__.CalculateStruct())
+		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:ACLR:AVERage?', self.__class__.CalculateStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Aclr_/Dallocation.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Aclr/Dallocation.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,25 +1,25 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
-from ....Internal.StructBase import StructBase
-from ....Internal.ArgStruct import ArgStruct
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
+from .....Internal.StructBase import StructBase
+from .....Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Dallocation:
-	"""Dallocation commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class DallocationCls:
+	"""Dallocation commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("dallocation", core, parent)
+		self._cmd_group = CommandsGroup("dallocation", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
+			- Reliability: int: 'Reliability indicator'
 			- Nr_Res_Blocks: int: Number of allocated resource blocks
 			- Offset_Res_Blocks: int: Offset of the first allocated resource block from the edge of the allocated UL transmission bandwidth"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Nr_Res_Blocks'),
 			ArgStruct.scalar_int('Offset_Res_Blocks')]
 
@@ -27,13 +27,13 @@
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Nr_Res_Blocks: int = None
 			self.Offset_Res_Blocks: int = None
 
 	def fetch(self) -> FetchStruct:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:ACLR:DALLocation \n
-		Snippet: value: FetchStruct = driver.multiEval.aclr.dallocation.fetch() \n
+		Snippet: value: FetchStruct = driver.lteMeas.multiEval.aclr.dallocation.fetch() \n
 		Returns the detected allocation for the measured slot. If the same slot is measured by the individual measurements, all
 		commands yield the same result. If different statistic counts are defined for the modulation, ACLR and spectrum emission
 		mask measurements, different slots can be measured and different results can be returned by the individual commands. \n
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
 		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:ACLR:DALLocation?', self.__class__.FetchStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Aclr_/DchType.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/SeMask/DchType.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,28 +1,28 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
-from ....Internal import Conversions
-from ....Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ....Internal.Types import DataType
-from .... import enums
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
+from .....Internal import Conversions
+from .....Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .....Internal.Types import DataType
+from ..... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class DchType:
-	"""DchType commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class DchTypeCls:
+	"""DchType commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("dchType", core, parent)
+		self._cmd_group = CommandsGroup("dchType", core, parent)
 
 	# noinspection PyTypeChecker
 	def fetch(self) -> enums.UplinkChannelType:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:ACLR:DCHType \n
-		Snippet: value: enums.UplinkChannelType = driver.multiEval.aclr.dchType.fetch() \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:SEMask:DCHType \n
+		Snippet: value: enums.UplinkChannelType = driver.lteMeas.multiEval.seMask.dchType.fetch() \n
 		Returns the uplink channel type for the measured slot. If the same slot is measured by the individual measurements, all
 		commands yield the same result. If different statistic counts are defined for the modulation, ACLR and spectrum emission
 		mask measurements, different slots can be measured and different results can be returned by the individual commands. \n
 		Suppressed linked return values: reliability \n
 			:return: channel_type: No help available"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_str_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:ACLR:DCHType?', suppressed)
+		response = self._core.io.query_str_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:SEMask:DCHType?', suppressed)
 		return Conversions.str_to_scalar_enum(response, enums.UplinkChannelType)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Bler.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Bler.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,20 +1,20 @@
-from ...Internal.Core import Core
-from ...Internal.CommandsGroup import CommandsGroup
-from ...Internal.StructBase import StructBase
-from ...Internal.ArgStruct import ArgStruct
+from ....Internal.Core import Core
+from ....Internal.CommandsGroup import CommandsGroup
+from ....Internal.StructBase import StructBase
+from ....Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Bler:
-	"""Bler commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class BlerCls:
+	"""Bler commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("bler", core, parent)
+		self._cmd_group = CommandsGroup("bler", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
 			- Reliability: int: No parameter help available
 			- Ack: float: No parameter help available
 			- Nack: float: No parameter help available
@@ -33,18 +33,18 @@
 			self.Ack: float = None
 			self.Nack: float = None
 			self.Bler: float = None
 			self.Dtx: float = None
 
 	def fetch(self) -> ResultData:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:BLER \n
-		Snippet: value: ResultData = driver.multiEval.bler.fetch() \n
+		Snippet: value: ResultData = driver.lteMeas.multiEval.bler.fetch() \n
 		No command help available \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
 		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:BLER?', self.__class__.ResultData())
 
 	def read(self) -> ResultData:
 		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:BLER \n
-		Snippet: value: ResultData = driver.multiEval.bler.read() \n
+		Snippet: value: ResultData = driver.lteMeas.multiEval.bler.read() \n
 		No command help available \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
 		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:BLER?', self.__class__.ResultData())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/EsFlatness.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Terror/__init__.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,51 +1,51 @@
-from ...Internal.Core import Core
-from ...Internal.CommandsGroup import CommandsGroup
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class EsFlatness:
-	"""EsFlatness commands group definition. 13 total commands, 4 Sub-groups, 0 group commands"""
+class TerrorCls:
+	"""Terror commands group definition. 7 total commands, 4 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("esFlatness", core, parent)
+		self._cmd_group = CommandsGroup("terror", core, parent)
 
 	@property
 	def current(self):
-		"""current commands group. 1 Sub-classes, 3 commands."""
+		"""current commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_current'):
-			from .EsFlatness_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
 	@property
 	def average(self):
-		"""average commands group. 0 Sub-classes, 3 commands."""
+		"""average commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_average'):
-			from .EsFlatness_.Average import Average
-			self._average = Average(self._core, self._base)
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
 		return self._average
 
 	@property
 	def extreme(self):
-		"""extreme commands group. 0 Sub-classes, 3 commands."""
+		"""extreme commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_extreme'):
-			from .EsFlatness_.Extreme import Extreme
-			self._extreme = Extreme(self._core, self._base)
+			from .Extreme import ExtremeCls
+			self._extreme = ExtremeCls(self._core, self._cmd_group)
 		return self._extreme
 
 	@property
 	def standardDev(self):
-		"""standardDev commands group. 0 Sub-classes, 3 commands."""
+		"""standardDev commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_standardDev'):
-			from .EsFlatness_.StandardDev import StandardDev
-			self._standardDev = StandardDev(self._core, self._base)
+			from .StandardDev import StandardDevCls
+			self._standardDev = StandardDevCls(self._core, self._cmd_group)
 		return self._standardDev
 
-	def clone(self) -> 'EsFlatness':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'TerrorCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = EsFlatness(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = TerrorCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/EsFlatness_/Average.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/EsFlatness/Average.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,26 +1,26 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
-from ....Internal.StructBase import StructBase
-from ....Internal.ArgStruct import ArgStruct
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
+from .....Internal.StructBase import StructBase
+from .....Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class AverageCls:
+	"""Average commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Out_Of_Tolerance: int: Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for modulation measurements exceeding the specified modulation limits.
+			- Reliability: int: 'Reliability indicator'
+			- Out_Of_Tolerance: int: Out of tolerance result, i.e. the percentage of measurement intervals of the statistic count for modulation measurements exceeding the specified modulation limits.
 			- Ripple_1: float: Max (range 1) - min (range 1)
 			- Ripple_2: float: Max (range 2) - min (range 2)
 			- Max_R_1_Min_R_2: float: Max (range 1) - min (range 2)
 			- Max_R_2_Min_R_1: float: Max (range 2) - min (range 1)
 			- Min_R_1: float: Min (range 1)
 			- Max_R_1: float: Max (range 1)
 			- Min_R_2: float: Min (range 2)
@@ -48,54 +48,54 @@
 			self.Min_R_1: float = None
 			self.Max_R_1: float = None
 			self.Min_R_2: float = None
 			self.Max_R_2: float = None
 
 	def read(self) -> ResultData:
 		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:ESFLatness:AVERage \n
-		Snippet: value: ResultData = driver.multiEval.esFlatness.average.read() \n
-		Return current, average, extreme and standard deviation single value results of the equalizer spectrum flatness
-		measurement. See also 'Equalizer Spectrum Flatness Limits'. \n
+		Snippet: value: ResultData = driver.lteMeas.multiEval.esFlatness.average.read() \n
+		Return current, average, extreme and standard deviation single-value results of the equalizer spectrum flatness
+		measurement. See also 'Equalizer spectrum flatness limits'. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
 		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:ESFLatness:AVERage?', self.__class__.ResultData())
 
 	def fetch(self) -> ResultData:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:ESFLatness:AVERage \n
-		Snippet: value: ResultData = driver.multiEval.esFlatness.average.fetch() \n
-		Return current, average, extreme and standard deviation single value results of the equalizer spectrum flatness
-		measurement. See also 'Equalizer Spectrum Flatness Limits'. \n
+		Snippet: value: ResultData = driver.lteMeas.multiEval.esFlatness.average.fetch() \n
+		Return current, average, extreme and standard deviation single-value results of the equalizer spectrum flatness
+		measurement. See also 'Equalizer spectrum flatness limits'. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
 		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:ESFLatness:AVERage?', self.__class__.ResultData())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Out_Of_Tolerance: int: Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for modulation measurements exceeding the specified modulation limits.
-			- Ripple_1: float: Limit check result for max (range 1) - min (range 1)
-			- Ripple_2: float: Limit check result for max (range 2) - min (range 2)
-			- Max_R_1_Min_R_2: float: Limit check result for max (range 1) - min (range 2)
-			- Max_R_2_Min_R_1: float: Limit check result for max (range 2) - min (range 1)"""
+			- Reliability: int: 'Reliability indicator'
+			- Out_Of_Tolerance: int: Out of tolerance result, i.e. the percentage of measurement intervals of the statistic count for modulation measurements exceeding the specified modulation limits.
+			- Ripple_1: float or bool: Limit check result for max (range 1) - min (range 1) .
+			- Ripple_2: float or bool: Limit check result for max (range 2) - min (range 2) .
+			- Max_R_1_Min_R_2: float or bool: Limit check result for max (range 1) - min (range 2) .
+			- Max_R_2_Min_R_1: float or bool: Limit check result for max (range 2) - min (range 1) ."""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
-			ArgStruct.scalar_float('Ripple_1'),
-			ArgStruct.scalar_float('Ripple_2'),
-			ArgStruct.scalar_float('Max_R_1_Min_R_2'),
-			ArgStruct.scalar_float('Max_R_2_Min_R_1')]
+			ArgStruct.scalar_float_ext('Ripple_1'),
+			ArgStruct.scalar_float_ext('Ripple_2'),
+			ArgStruct.scalar_float_ext('Max_R_1_Min_R_2'),
+			ArgStruct.scalar_float_ext('Max_R_2_Min_R_1')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tolerance: int = None
-			self.Ripple_1: float = None
-			self.Ripple_2: float = None
-			self.Max_R_1_Min_R_2: float = None
-			self.Max_R_2_Min_R_1: float = None
+			self.Ripple_1: float or bool = None
+			self.Ripple_2: float or bool = None
+			self.Max_R_1_Min_R_2: float or bool = None
+			self.Max_R_2_Min_R_1: float or bool = None
 
 	def calculate(self) -> CalculateStruct:
 		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:ESFLatness:AVERage \n
-		Snippet: value: CalculateStruct = driver.multiEval.esFlatness.average.calculate() \n
-		Return current, average and extreme single value results of the equalizer spectrum flatness measurement.
-		See also 'Equalizer Spectrum Flatness Limits'. \n
+		Snippet: value: CalculateStruct = driver.lteMeas.multiEval.esFlatness.average.calculate() \n
+		Return current, average and extreme single-value results of the equalizer spectrum flatness measurement.
+		See also 'Equalizer spectrum flatness limits'. \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
 		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:ESFLatness:AVERage?', self.__class__.CalculateStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/EsFlatness_/Current.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/EsFlatness/Current/__init__.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,34 +1,34 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
-from ....Internal.StructBase import StructBase
-from ....Internal.ArgStruct import ArgStruct
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal.StructBase import StructBase
+from ......Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 4 total commands, 1 Sub-groups, 3 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 4 total commands, 1 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	@property
 	def scIndex(self):
 		"""scIndex commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_scIndex'):
-			from .Current_.ScIndex import ScIndex
-			self._scIndex = ScIndex(self._core, self._base)
+			from .ScIndex import ScIndexCls
+			self._scIndex = ScIndexCls(self._core, self._cmd_group)
 		return self._scIndex
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Out_Of_Tolerance: int: Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for modulation measurements exceeding the specified modulation limits.
+			- Reliability: int: 'Reliability indicator'
+			- Out_Of_Tolerance: int: Out of tolerance result, i.e. the percentage of measurement intervals of the statistic count for modulation measurements exceeding the specified modulation limits.
 			- Ripple_1: float: Max (range 1) - min (range 1)
 			- Ripple_2: float: Max (range 2) - min (range 2)
 			- Max_R_1_Min_R_2: float: Max (range 1) - min (range 2)
 			- Max_R_2_Min_R_1: float: Max (range 2) - min (range 1)
 			- Min_R_1: float: Min (range 1)
 			- Max_R_1: float: Max (range 1)
 			- Min_R_2: float: Min (range 2)
@@ -56,62 +56,62 @@
 			self.Min_R_1: float = None
 			self.Max_R_1: float = None
 			self.Min_R_2: float = None
 			self.Max_R_2: float = None
 
 	def read(self) -> ResultData:
 		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:ESFLatness:CURRent \n
-		Snippet: value: ResultData = driver.multiEval.esFlatness.current.read() \n
-		Return current, average, extreme and standard deviation single value results of the equalizer spectrum flatness
-		measurement. See also 'Equalizer Spectrum Flatness Limits'. \n
+		Snippet: value: ResultData = driver.lteMeas.multiEval.esFlatness.current.read() \n
+		Return current, average, extreme and standard deviation single-value results of the equalizer spectrum flatness
+		measurement. See also 'Equalizer spectrum flatness limits'. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
 		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:ESFLatness:CURRent?', self.__class__.ResultData())
 
 	def fetch(self) -> ResultData:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:ESFLatness:CURRent \n
-		Snippet: value: ResultData = driver.multiEval.esFlatness.current.fetch() \n
-		Return current, average, extreme and standard deviation single value results of the equalizer spectrum flatness
-		measurement. See also 'Equalizer Spectrum Flatness Limits'. \n
+		Snippet: value: ResultData = driver.lteMeas.multiEval.esFlatness.current.fetch() \n
+		Return current, average, extreme and standard deviation single-value results of the equalizer spectrum flatness
+		measurement. See also 'Equalizer spectrum flatness limits'. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
 		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:ESFLatness:CURRent?', self.__class__.ResultData())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Out_Of_Tolerance: int: Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for modulation measurements exceeding the specified modulation limits.
-			- Ripple_1: float: Limit check result for max (range 1) - min (range 1)
-			- Ripple_2: float: Limit check result for max (range 2) - min (range 2)
-			- Max_R_1_Min_R_2: float: Limit check result for max (range 1) - min (range 2)
-			- Max_R_2_Min_R_1: float: Limit check result for max (range 2) - min (range 1)"""
+			- Reliability: int: 'Reliability indicator'
+			- Out_Of_Tolerance: int: Out of tolerance result, i.e. the percentage of measurement intervals of the statistic count for modulation measurements exceeding the specified modulation limits.
+			- Ripple_1: float or bool: Limit check result for max (range 1) - min (range 1) .
+			- Ripple_2: float or bool: Limit check result for max (range 2) - min (range 2) .
+			- Max_R_1_Min_R_2: float or bool: Limit check result for max (range 1) - min (range 2) .
+			- Max_R_2_Min_R_1: float or bool: Limit check result for max (range 2) - min (range 1) ."""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
-			ArgStruct.scalar_float('Ripple_1'),
-			ArgStruct.scalar_float('Ripple_2'),
-			ArgStruct.scalar_float('Max_R_1_Min_R_2'),
-			ArgStruct.scalar_float('Max_R_2_Min_R_1')]
+			ArgStruct.scalar_float_ext('Ripple_1'),
+			ArgStruct.scalar_float_ext('Ripple_2'),
+			ArgStruct.scalar_float_ext('Max_R_1_Min_R_2'),
+			ArgStruct.scalar_float_ext('Max_R_2_Min_R_1')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tolerance: int = None
-			self.Ripple_1: float = None
-			self.Ripple_2: float = None
-			self.Max_R_1_Min_R_2: float = None
-			self.Max_R_2_Min_R_1: float = None
+			self.Ripple_1: float or bool = None
+			self.Ripple_2: float or bool = None
+			self.Max_R_1_Min_R_2: float or bool = None
+			self.Max_R_2_Min_R_1: float or bool = None
 
 	def calculate(self) -> CalculateStruct:
 		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:ESFLatness:CURRent \n
-		Snippet: value: CalculateStruct = driver.multiEval.esFlatness.current.calculate() \n
-		Return current, average and extreme single value results of the equalizer spectrum flatness measurement.
-		See also 'Equalizer Spectrum Flatness Limits'. \n
+		Snippet: value: CalculateStruct = driver.lteMeas.multiEval.esFlatness.current.calculate() \n
+		Return current, average and extreme single-value results of the equalizer spectrum flatness measurement.
+		See also 'Equalizer spectrum flatness limits'. \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
 		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:ESFLatness:CURRent?', self.__class__.CalculateStruct())
 
-	def clone(self) -> 'Current':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'CurrentCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Current(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = CurrentCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/EsFlatness_/Current_/ScIndex.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/EsFlatness/Current/ScIndex.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,26 +1,26 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
-from .....Internal.StructBase import StructBase
-from .....Internal.ArgStruct import ArgStruct
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal.StructBase import StructBase
+from ......Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class ScIndex:
-	"""ScIndex commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class ScIndexCls:
+	"""ScIndex commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("scIndex", core, parent)
+		self._cmd_group = CommandsGroup("scIndex", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Out_Of_Tolerance: int: Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for modulation measurements exceeding the specified modulation limits.
+			- Reliability: int: 'Reliability indicator'
+			- Out_Of_Tolerance: int: Out of tolerance result, i.e. the percentage of measurement intervals of the statistic count for modulation measurements exceeding the specified modulation limits.
 			- Maximum_1: int: SC index of Max (Range 1)
 			- Minimum_1: int: SC index of Min (Range 1)
 			- Maximum_2: int: SC index of Max (Range 2)
 			- Minimum_2: int: SC index of Min (Range 2)"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
@@ -36,12 +36,12 @@
 			self.Maximum_1: int = None
 			self.Minimum_1: int = None
 			self.Maximum_2: int = None
 			self.Minimum_2: int = None
 
 	def fetch(self) -> FetchStruct:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:ESFLatness:CURRent:SCINdex \n
-		Snippet: value: FetchStruct = driver.multiEval.esFlatness.current.scIndex.fetch() \n
+		Snippet: value: FetchStruct = driver.lteMeas.multiEval.esFlatness.current.scIndex.fetch() \n
 		Returns subcarrier indices of the equalizer spectrum flatness measurement. At these SC indices, the current minimum and
 		maximum power of the equalizer coefficients have been detected within range 1 and range 2. \n
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
 		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:ESFLatness:CURRent:SCINdex?', self.__class__.FetchStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/EsFlatness_/Extreme.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/EsFlatness/Extreme.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,26 +1,26 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
-from ....Internal.StructBase import StructBase
-from ....Internal.ArgStruct import ArgStruct
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
+from .....Internal.StructBase import StructBase
+from .....Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Extreme:
-	"""Extreme commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class ExtremeCls:
+	"""Extreme commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("extreme", core, parent)
+		self._cmd_group = CommandsGroup("extreme", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Out_Of_Tolerance: int: Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for modulation measurements exceeding the specified modulation limits.
+			- Reliability: int: 'Reliability indicator'
+			- Out_Of_Tolerance: int: Out of tolerance result, i.e. the percentage of measurement intervals of the statistic count for modulation measurements exceeding the specified modulation limits.
 			- Ripple_1: float: Max (range 1) - min (range 1)
 			- Ripple_2: float: Max (range 2) - min (range 2)
 			- Max_R_1_Min_R_2: float: Max (range 1) - min (range 2)
 			- Max_R_2_Min_R_1: float: Max (range 2) - min (range 1)
 			- Min_R_1: float: Min (range 1)
 			- Max_R_1: float: Max (range 1)
 			- Min_R_2: float: Min (range 2)
@@ -48,54 +48,54 @@
 			self.Min_R_1: float = None
 			self.Max_R_1: float = None
 			self.Min_R_2: float = None
 			self.Max_R_2: float = None
 
 	def read(self) -> ResultData:
 		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:ESFLatness:EXTReme \n
-		Snippet: value: ResultData = driver.multiEval.esFlatness.extreme.read() \n
-		Return current, average, extreme and standard deviation single value results of the equalizer spectrum flatness
-		measurement. See also 'Equalizer Spectrum Flatness Limits'. \n
+		Snippet: value: ResultData = driver.lteMeas.multiEval.esFlatness.extreme.read() \n
+		Return current, average, extreme and standard deviation single-value results of the equalizer spectrum flatness
+		measurement. See also 'Equalizer spectrum flatness limits'. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
 		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:ESFLatness:EXTReme?', self.__class__.ResultData())
 
 	def fetch(self) -> ResultData:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:ESFLatness:EXTReme \n
-		Snippet: value: ResultData = driver.multiEval.esFlatness.extreme.fetch() \n
-		Return current, average, extreme and standard deviation single value results of the equalizer spectrum flatness
-		measurement. See also 'Equalizer Spectrum Flatness Limits'. \n
+		Snippet: value: ResultData = driver.lteMeas.multiEval.esFlatness.extreme.fetch() \n
+		Return current, average, extreme and standard deviation single-value results of the equalizer spectrum flatness
+		measurement. See also 'Equalizer spectrum flatness limits'. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
 		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:ESFLatness:EXTReme?', self.__class__.ResultData())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Out_Of_Tolerance: int: Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for modulation measurements exceeding the specified modulation limits.
-			- Ripple_1: float: Limit check result for max (range 1) - min (range 1)
-			- Ripple_2: float: Limit check result for max (range 2) - min (range 2)
-			- Max_R_1_Min_R_2: float: Limit check result for max (range 1) - min (range 2)
-			- Max_R_2_Min_R_1: float: Limit check result for max (range 2) - min (range 1)"""
+			- Reliability: int: 'Reliability indicator'
+			- Out_Of_Tolerance: int: Out of tolerance result, i.e. the percentage of measurement intervals of the statistic count for modulation measurements exceeding the specified modulation limits.
+			- Ripple_1: float or bool: Limit check result for max (range 1) - min (range 1) .
+			- Ripple_2: float or bool: Limit check result for max (range 2) - min (range 2) .
+			- Max_R_1_Min_R_2: float or bool: Limit check result for max (range 1) - min (range 2) .
+			- Max_R_2_Min_R_1: float or bool: Limit check result for max (range 2) - min (range 1) ."""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
-			ArgStruct.scalar_float('Ripple_1'),
-			ArgStruct.scalar_float('Ripple_2'),
-			ArgStruct.scalar_float('Max_R_1_Min_R_2'),
-			ArgStruct.scalar_float('Max_R_2_Min_R_1')]
+			ArgStruct.scalar_float_ext('Ripple_1'),
+			ArgStruct.scalar_float_ext('Ripple_2'),
+			ArgStruct.scalar_float_ext('Max_R_1_Min_R_2'),
+			ArgStruct.scalar_float_ext('Max_R_2_Min_R_1')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tolerance: int = None
-			self.Ripple_1: float = None
-			self.Ripple_2: float = None
-			self.Max_R_1_Min_R_2: float = None
-			self.Max_R_2_Min_R_1: float = None
+			self.Ripple_1: float or bool = None
+			self.Ripple_2: float or bool = None
+			self.Max_R_1_Min_R_2: float or bool = None
+			self.Max_R_2_Min_R_1: float or bool = None
 
 	def calculate(self) -> CalculateStruct:
 		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:ESFLatness:EXTReme \n
-		Snippet: value: CalculateStruct = driver.multiEval.esFlatness.extreme.calculate() \n
-		Return current, average and extreme single value results of the equalizer spectrum flatness measurement.
-		See also 'Equalizer Spectrum Flatness Limits'. \n
+		Snippet: value: CalculateStruct = driver.lteMeas.multiEval.esFlatness.extreme.calculate() \n
+		Return current, average and extreme single-value results of the equalizer spectrum flatness measurement.
+		See also 'Equalizer spectrum flatness limits'. \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
 		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:ESFLatness:EXTReme?', self.__class__.CalculateStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/EsFlatness_/StandardDev.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/EsFlatness/StandardDev.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,26 +1,26 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
-from ....Internal.StructBase import StructBase
-from ....Internal.ArgStruct import ArgStruct
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
+from .....Internal.StructBase import StructBase
+from .....Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class StandardDev:
-	"""StandardDev commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class StandardDevCls:
+	"""StandardDev commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("standardDev", core, parent)
+		self._cmd_group = CommandsGroup("standardDev", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Out_Of_Tolerance: int: Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for modulation measurements exceeding the specified modulation limits.
+			- Reliability: int: 'Reliability indicator'
+			- Out_Of_Tolerance: int: Out of tolerance result, i.e. the percentage of measurement intervals of the statistic count for modulation measurements exceeding the specified modulation limits.
 			- Ripple_1: float: Max (range 1) - min (range 1)
 			- Ripple_2: float: Max (range 2) - min (range 2)
 			- Max_R_1_Min_R_2: float: Max (range 1) - min (range 2)
 			- Max_R_2_Min_R_1: float: Max (range 2) - min (range 1)
 			- Min_R_1: float: Min (range 1)
 			- Max_R_1: float: Max (range 1)
 			- Min_R_2: float: Min (range 2)
@@ -48,53 +48,53 @@
 			self.Min_R_1: float = None
 			self.Max_R_1: float = None
 			self.Min_R_2: float = None
 			self.Max_R_2: float = None
 
 	def read(self) -> ResultData:
 		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:ESFLatness:SDEViation \n
-		Snippet: value: ResultData = driver.multiEval.esFlatness.standardDev.read() \n
-		Return current, average, extreme and standard deviation single value results of the equalizer spectrum flatness
-		measurement. See also 'Equalizer Spectrum Flatness Limits'. \n
+		Snippet: value: ResultData = driver.lteMeas.multiEval.esFlatness.standardDev.read() \n
+		Return current, average, extreme and standard deviation single-value results of the equalizer spectrum flatness
+		measurement. See also 'Equalizer spectrum flatness limits'. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
 		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:ESFLatness:SDEViation?', self.__class__.ResultData())
 
 	def fetch(self) -> ResultData:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:ESFLatness:SDEViation \n
-		Snippet: value: ResultData = driver.multiEval.esFlatness.standardDev.fetch() \n
-		Return current, average, extreme and standard deviation single value results of the equalizer spectrum flatness
-		measurement. See also 'Equalizer Spectrum Flatness Limits'. \n
+		Snippet: value: ResultData = driver.lteMeas.multiEval.esFlatness.standardDev.fetch() \n
+		Return current, average, extreme and standard deviation single-value results of the equalizer spectrum flatness
+		measurement. See also 'Equalizer spectrum flatness limits'. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
 		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:ESFLatness:SDEViation?', self.__class__.ResultData())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
 			- Reliability: int: No parameter help available
 			- Out_Of_Tolerance: int: No parameter help available
-			- Ripple_1: float: No parameter help available
-			- Ripple_2: float: No parameter help available
-			- Max_R_1_Min_R_2: float: No parameter help available
-			- Max_R_2_Min_R_1: float: No parameter help available"""
+			- Ripple_1: float or bool: No parameter help available
+			- Ripple_2: float or bool: No parameter help available
+			- Max_R_1_Min_R_2: float or bool: No parameter help available
+			- Max_R_2_Min_R_1: float or bool: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
-			ArgStruct.scalar_float('Ripple_1'),
-			ArgStruct.scalar_float('Ripple_2'),
-			ArgStruct.scalar_float('Max_R_1_Min_R_2'),
-			ArgStruct.scalar_float('Max_R_2_Min_R_1')]
+			ArgStruct.scalar_float_ext('Ripple_1'),
+			ArgStruct.scalar_float_ext('Ripple_2'),
+			ArgStruct.scalar_float_ext('Max_R_1_Min_R_2'),
+			ArgStruct.scalar_float_ext('Max_R_2_Min_R_1')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tolerance: int = None
-			self.Ripple_1: float = None
-			self.Ripple_2: float = None
-			self.Max_R_1_Min_R_2: float = None
-			self.Max_R_2_Min_R_1: float = None
+			self.Ripple_1: float or bool = None
+			self.Ripple_2: float or bool = None
+			self.Max_R_1_Min_R_2: float or bool = None
+			self.Max_R_2_Min_R_1: float or bool = None
 
 	def calculate(self) -> CalculateStruct:
 		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:ESFLatness:SDEViation \n
-		Snippet: value: CalculateStruct = driver.multiEval.esFlatness.standardDev.calculate() \n
+		Snippet: value: CalculateStruct = driver.lteMeas.multiEval.esFlatness.standardDev.calculate() \n
 		No command help available \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
 		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:ESFLatness:SDEViation?', self.__class__.CalculateStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/EvMagnitude.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/FreqError/__init__.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,51 +1,51 @@
-from ...Internal.Core import Core
-from ...Internal.CommandsGroup import CommandsGroup
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class EvMagnitude:
-	"""EvMagnitude commands group definition. 21 total commands, 4 Sub-groups, 0 group commands"""
+class FreqErrorCls:
+	"""FreqError commands group definition. 7 total commands, 4 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("evMagnitude", core, parent)
+		self._cmd_group = CommandsGroup("freqError", core, parent)
 
 	@property
 	def current(self):
-		"""current commands group. 1 Sub-classes, 3 commands."""
+		"""current commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_current'):
-			from .EvMagnitude_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
 	@property
 	def average(self):
-		"""average commands group. 1 Sub-classes, 3 commands."""
+		"""average commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_average'):
-			from .EvMagnitude_.Average import Average
-			self._average = Average(self._core, self._base)
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
 		return self._average
 
 	@property
-	def maximum(self):
-		"""maximum commands group. 1 Sub-classes, 3 commands."""
-		if not hasattr(self, '_maximum'):
-			from .EvMagnitude_.Maximum import Maximum
-			self._maximum = Maximum(self._core, self._base)
-		return self._maximum
+	def extreme(self):
+		"""extreme commands group. 0 Sub-classes, 2 commands."""
+		if not hasattr(self, '_extreme'):
+			from .Extreme import ExtremeCls
+			self._extreme = ExtremeCls(self._core, self._cmd_group)
+		return self._extreme
 
 	@property
-	def peak(self):
-		"""peak commands group. 3 Sub-classes, 0 commands."""
-		if not hasattr(self, '_peak'):
-			from .EvMagnitude_.Peak import Peak
-			self._peak = Peak(self._core, self._base)
-		return self._peak
+	def standardDev(self):
+		"""standardDev commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_standardDev'):
+			from .StandardDev import StandardDevCls
+			self._standardDev = StandardDevCls(self._core, self._cmd_group)
+		return self._standardDev
 
-	def clone(self) -> 'EvMagnitude':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'FreqErrorCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = EvMagnitude(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = FreqErrorCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/EvMagnitude_/Average.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Perror/Maximum/__init__.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,67 +1,69 @@
 from typing import List
 
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
-from ....Internal.Types import DataType
-from ....Internal.StructBase import StructBase
-from ....Internal.ArgStruct import ArgStruct
-from .... import enums
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal.Types import DataType
+from ......Internal.StructBase import StructBase
+from ......Internal.ArgStruct import ArgStruct
+from ...... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 5 total commands, 1 Sub-groups, 3 group commands"""
+class MaximumCls:
+	"""Maximum commands group definition. 5 total commands, 1 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("maximum", core, parent)
 
 	@property
 	def nref(self):
 		"""nref commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_nref'):
-			from .Average_.Nref import Nref
-			self._nref = Nref(self._core, self._base)
+			from .Nref import NrefCls
+			self._nref = NrefCls(self._core, self._cmd_group)
 		return self._nref
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Low: List[float]: EVM value for low EVM window position
-			- High: List[float]: EVM value for high EVM window position"""
+			- Reliability: int: 'Reliability indicator'
+			- Low: List[float]: Phase error value for low EVM window position
+			- High: List[float]: Phase error value for high EVM window position"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct('Low', DataType.FloatList, None, False, True, 1),
 			ArgStruct('High', DataType.FloatList, None, False, True, 1)]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Low: List[float] = None
 			self.High: List[float] = None
 
 	def read(self) -> ResultData:
-		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:EVMagnitude:AVERage \n
-		Snippet: value: ResultData = driver.multiEval.evMagnitude.average.read() \n
-		Returns the values of the EVM RMS bar graphs for the SC-FDMA symbols in the measured slot. The results of the current,
-		average and maximum bar graphs can be retrieved. There is one pair of EVM values per SC-FDMA symbol, returned in the
-		following order: <Reliability>, {<Low>, <High>}symbol 0, {<Low>, <High>}symbol 1, ... See also 'Square EVM'. \n
+		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:PERRor:MAXimum \n
+		Snippet: value: ResultData = driver.lteMeas.multiEval.perror.maximum.read() \n
+		Returns the values of the phase error diagrams for the SC-FDMA symbols in the measured slot. The results of the current,
+		average and maximum diagrams can be retrieved. There is one pair of phase error values per SC-FDMA symbol, returned in
+		the following order: <Reliability>, {<Low>, <High>}symbol 0, {<Low>, <High>}symbol 1, ... See also 'Square Magnitude
+		Error, Phase Error'. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:EVMagnitude:AVERage?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:PERRor:MAXimum?', self.__class__.ResultData())
 
 	def fetch(self) -> ResultData:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:EVMagnitude:AVERage \n
-		Snippet: value: ResultData = driver.multiEval.evMagnitude.average.fetch() \n
-		Returns the values of the EVM RMS bar graphs for the SC-FDMA symbols in the measured slot. The results of the current,
-		average and maximum bar graphs can be retrieved. There is one pair of EVM values per SC-FDMA symbol, returned in the
-		following order: <Reliability>, {<Low>, <High>}symbol 0, {<Low>, <High>}symbol 1, ... See also 'Square EVM'. \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:PERRor:MAXimum \n
+		Snippet: value: ResultData = driver.lteMeas.multiEval.perror.maximum.fetch() \n
+		Returns the values of the phase error diagrams for the SC-FDMA symbols in the measured slot. The results of the current,
+		average and maximum diagrams can be retrieved. There is one pair of phase error values per SC-FDMA symbol, returned in
+		the following order: <Reliability>, {<Low>, <High>}symbol 0, {<Low>, <High>}symbol 1, ... See also 'Square Magnitude
+		Error, Phase Error'. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:EVMagnitude:AVERage?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:PERRor:MAXimum?', self.__class__.ResultData())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
 			- Reliability: int: No parameter help available
 			- Low: List[enums.ResultStatus2]: No parameter help available
 			- High: List[enums.ResultStatus2]: No parameter help available"""
@@ -73,20 +75,20 @@
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Low: List[enums.ResultStatus2] = None
 			self.High: List[enums.ResultStatus2] = None
 
 	def calculate(self) -> CalculateStruct:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:EVMagnitude:AVERage \n
-		Snippet: value: CalculateStruct = driver.multiEval.evMagnitude.average.calculate() \n
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:PERRor:MAXimum \n
+		Snippet: value: CalculateStruct = driver.lteMeas.multiEval.perror.maximum.calculate() \n
 		No command help available \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:EVMagnitude:AVERage?', self.__class__.CalculateStruct())
+		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:PERRor:MAXimum?', self.__class__.CalculateStruct())
 
-	def clone(self) -> 'Average':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'MaximumCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Average(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = MaximumCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/EvMagnitude_/Average_/Nref.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/EvMagnitude/Average/Nref.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,20 +1,20 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
-from .....Internal.StructBase import StructBase
-from .....Internal.ArgStruct import ArgStruct
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal.StructBase import StructBase
+from ......Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Nref:
-	"""Nref commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class NrefCls:
+	"""Nref commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("nref", core, parent)
+		self._cmd_group = CommandsGroup("nref", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
 			- Reliability: int: No parameter help available
 			- Sym_1_L: float: No parameter help available
 			- Sym_1_H: float: No parameter help available
@@ -57,18 +57,18 @@
 			self.Sym_6_L: float = None
 			self.Sym_6_H: float = None
 			self.Sym_7_L: float = None
 			self.Sym_7_H: float = None
 
 	def read(self) -> ResultData:
 		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:EVMagnitude:AVERage:NREF \n
-		Snippet: value: ResultData = driver.multiEval.evMagnitude.average.nref.read() \n
+		Snippet: value: ResultData = driver.lteMeas.multiEval.evMagnitude.average.nref.read() \n
 		No command help available \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
 		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:EVMagnitude:AVERage:NREF?', self.__class__.ResultData())
 
 	def fetch(self) -> ResultData:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:EVMagnitude:AVERage:NREF \n
-		Snippet: value: ResultData = driver.multiEval.evMagnitude.average.nref.fetch() \n
+		Snippet: value: ResultData = driver.lteMeas.multiEval.evMagnitude.average.nref.fetch() \n
 		No command help available \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
 		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:EVMagnitude:AVERage:NREF?', self.__class__.ResultData())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/EvMagnitude_/Current.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/EvMagnitude/Current/__init__.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,37 +1,37 @@
 from typing import List
 
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
-from ....Internal.Types import DataType
-from ....Internal.StructBase import StructBase
-from ....Internal.ArgStruct import ArgStruct
-from .... import enums
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal.Types import DataType
+from ......Internal.StructBase import StructBase
+from ......Internal.ArgStruct import ArgStruct
+from ...... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 5 total commands, 1 Sub-groups, 3 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 5 total commands, 1 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	@property
 	def nref(self):
 		"""nref commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_nref'):
-			from .Current_.Nref import Nref
-			self._nref = Nref(self._core, self._base)
+			from .Nref import NrefCls
+			self._nref = NrefCls(self._core, self._cmd_group)
 		return self._nref
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
+			- Reliability: int: 'Reliability indicator'
 			- Low: List[float]: EVM value for low EVM window position
 			- High: List[float]: EVM value for high EVM window position"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct('Low', DataType.FloatList, None, False, True, 1),
 			ArgStruct('High', DataType.FloatList, None, False, True, 1)]
 
@@ -39,26 +39,26 @@
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Low: List[float] = None
 			self.High: List[float] = None
 
 	def read(self) -> ResultData:
 		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:EVMagnitude:CURRent \n
-		Snippet: value: ResultData = driver.multiEval.evMagnitude.current.read() \n
-		Returns the values of the EVM RMS bar graphs for the SC-FDMA symbols in the measured slot. The results of the current,
-		average and maximum bar graphs can be retrieved. There is one pair of EVM values per SC-FDMA symbol, returned in the
+		Snippet: value: ResultData = driver.lteMeas.multiEval.evMagnitude.current.read() \n
+		Returns the values of the EVM RMS diagrams for the SC-FDMA symbols in the measured slot. The results of the current,
+		average and maximum diagrams can be retrieved. There is one pair of EVM values per SC-FDMA symbol, returned in the
 		following order: <Reliability>, {<Low>, <High>}symbol 0, {<Low>, <High>}symbol 1, ... See also 'Square EVM'. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
 		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:EVMagnitude:CURRent?', self.__class__.ResultData())
 
 	def fetch(self) -> ResultData:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:EVMagnitude:CURRent \n
-		Snippet: value: ResultData = driver.multiEval.evMagnitude.current.fetch() \n
-		Returns the values of the EVM RMS bar graphs for the SC-FDMA symbols in the measured slot. The results of the current,
-		average and maximum bar graphs can be retrieved. There is one pair of EVM values per SC-FDMA symbol, returned in the
+		Snippet: value: ResultData = driver.lteMeas.multiEval.evMagnitude.current.fetch() \n
+		Returns the values of the EVM RMS diagrams for the SC-FDMA symbols in the measured slot. The results of the current,
+		average and maximum diagrams can be retrieved. There is one pair of EVM values per SC-FDMA symbol, returned in the
 		following order: <Reliability>, {<Low>, <High>}symbol 0, {<Low>, <High>}symbol 1, ... See also 'Square EVM'. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
 		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:EVMagnitude:CURRent?', self.__class__.ResultData())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
@@ -74,19 +74,19 @@
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Low: List[enums.ResultStatus2] = None
 			self.High: List[enums.ResultStatus2] = None
 
 	def calculate(self) -> CalculateStruct:
 		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:EVMagnitude:CURRent \n
-		Snippet: value: CalculateStruct = driver.multiEval.evMagnitude.current.calculate() \n
+		Snippet: value: CalculateStruct = driver.lteMeas.multiEval.evMagnitude.current.calculate() \n
 		No command help available \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
 		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:EVMagnitude:CURRent?', self.__class__.CalculateStruct())
 
-	def clone(self) -> 'Current':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'CurrentCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Current(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = CurrentCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/EvMagnitude_/Current_/Nref.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Merror/Current/Nref.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,20 +1,20 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
-from .....Internal.StructBase import StructBase
-from .....Internal.ArgStruct import ArgStruct
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal.StructBase import StructBase
+from ......Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Nref:
-	"""Nref commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class NrefCls:
+	"""Nref commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("nref", core, parent)
+		self._cmd_group = CommandsGroup("nref", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
 			- Reliability: int: No parameter help available
 			- Sym_1_L: float: No parameter help available
 			- Sym_1_H: float: No parameter help available
@@ -56,19 +56,19 @@
 			self.Sym_5_H: float = None
 			self.Sym_6_L: float = None
 			self.Sym_6_H: float = None
 			self.Sym_7_L: float = None
 			self.Sym_7_H: float = None
 
 	def read(self) -> ResultData:
-		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:EVMagnitude:CURRent:NREF \n
-		Snippet: value: ResultData = driver.multiEval.evMagnitude.current.nref.read() \n
+		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:MERRor:CURRent:NREF \n
+		Snippet: value: ResultData = driver.lteMeas.multiEval.merror.current.nref.read() \n
 		No command help available \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:EVMagnitude:CURRent:NREF?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:MERRor:CURRent:NREF?', self.__class__.ResultData())
 
 	def fetch(self) -> ResultData:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:EVMagnitude:CURRent:NREF \n
-		Snippet: value: ResultData = driver.multiEval.evMagnitude.current.nref.fetch() \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:MERRor:CURRent:NREF \n
+		Snippet: value: ResultData = driver.lteMeas.multiEval.merror.current.nref.fetch() \n
 		No command help available \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:EVMagnitude:CURRent:NREF?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:MERRor:CURRent:NREF?', self.__class__.ResultData())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/EvMagnitude_/Maximum.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/EvMagnitude/Maximum/__init__.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,37 +1,37 @@
 from typing import List
 
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
-from ....Internal.Types import DataType
-from ....Internal.StructBase import StructBase
-from ....Internal.ArgStruct import ArgStruct
-from .... import enums
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal.Types import DataType
+from ......Internal.StructBase import StructBase
+from ......Internal.ArgStruct import ArgStruct
+from ...... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Maximum:
-	"""Maximum commands group definition. 5 total commands, 1 Sub-groups, 3 group commands"""
+class MaximumCls:
+	"""Maximum commands group definition. 5 total commands, 1 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("maximum", core, parent)
+		self._cmd_group = CommandsGroup("maximum", core, parent)
 
 	@property
 	def nref(self):
 		"""nref commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_nref'):
-			from .Maximum_.Nref import Nref
-			self._nref = Nref(self._core, self._base)
+			from .Nref import NrefCls
+			self._nref = NrefCls(self._core, self._cmd_group)
 		return self._nref
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
+			- Reliability: int: 'Reliability indicator'
 			- Low: List[float]: EVM value for low EVM window position
 			- High: List[float]: EVM value for high EVM window position"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct('Low', DataType.FloatList, None, False, True, 1),
 			ArgStruct('High', DataType.FloatList, None, False, True, 1)]
 
@@ -39,26 +39,26 @@
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Low: List[float] = None
 			self.High: List[float] = None
 
 	def read(self) -> ResultData:
 		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:EVMagnitude:MAXimum \n
-		Snippet: value: ResultData = driver.multiEval.evMagnitude.maximum.read() \n
-		Returns the values of the EVM RMS bar graphs for the SC-FDMA symbols in the measured slot. The results of the current,
-		average and maximum bar graphs can be retrieved. There is one pair of EVM values per SC-FDMA symbol, returned in the
+		Snippet: value: ResultData = driver.lteMeas.multiEval.evMagnitude.maximum.read() \n
+		Returns the values of the EVM RMS diagrams for the SC-FDMA symbols in the measured slot. The results of the current,
+		average and maximum diagrams can be retrieved. There is one pair of EVM values per SC-FDMA symbol, returned in the
 		following order: <Reliability>, {<Low>, <High>}symbol 0, {<Low>, <High>}symbol 1, ... See also 'Square EVM'. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
 		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:EVMagnitude:MAXimum?', self.__class__.ResultData())
 
 	def fetch(self) -> ResultData:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:EVMagnitude:MAXimum \n
-		Snippet: value: ResultData = driver.multiEval.evMagnitude.maximum.fetch() \n
-		Returns the values of the EVM RMS bar graphs for the SC-FDMA symbols in the measured slot. The results of the current,
-		average and maximum bar graphs can be retrieved. There is one pair of EVM values per SC-FDMA symbol, returned in the
+		Snippet: value: ResultData = driver.lteMeas.multiEval.evMagnitude.maximum.fetch() \n
+		Returns the values of the EVM RMS diagrams for the SC-FDMA symbols in the measured slot. The results of the current,
+		average and maximum diagrams can be retrieved. There is one pair of EVM values per SC-FDMA symbol, returned in the
 		following order: <Reliability>, {<Low>, <High>}symbol 0, {<Low>, <High>}symbol 1, ... See also 'Square EVM'. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
 		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:EVMagnitude:MAXimum?', self.__class__.ResultData())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
@@ -74,19 +74,19 @@
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Low: List[enums.ResultStatus2] = None
 			self.High: List[enums.ResultStatus2] = None
 
 	def calculate(self) -> CalculateStruct:
 		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:EVMagnitude:MAXimum \n
-		Snippet: value: CalculateStruct = driver.multiEval.evMagnitude.maximum.calculate() \n
+		Snippet: value: CalculateStruct = driver.lteMeas.multiEval.evMagnitude.maximum.calculate() \n
 		No command help available \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
 		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:EVMagnitude:MAXimum?', self.__class__.CalculateStruct())
 
-	def clone(self) -> 'Maximum':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'MaximumCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Maximum(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = MaximumCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/EvMagnitude_/Maximum_/Nref.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Merror/Average/Nref.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,20 +1,20 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
-from .....Internal.StructBase import StructBase
-from .....Internal.ArgStruct import ArgStruct
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal.StructBase import StructBase
+from ......Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Nref:
-	"""Nref commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class NrefCls:
+	"""Nref commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("nref", core, parent)
+		self._cmd_group = CommandsGroup("nref", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
 			- Reliability: int: No parameter help available
 			- Sym_1_L: float: No parameter help available
 			- Sym_1_H: float: No parameter help available
@@ -56,19 +56,19 @@
 			self.Sym_5_H: float = None
 			self.Sym_6_L: float = None
 			self.Sym_6_H: float = None
 			self.Sym_7_L: float = None
 			self.Sym_7_H: float = None
 
 	def read(self) -> ResultData:
-		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:EVMagnitude:MAXimum:NREF \n
-		Snippet: value: ResultData = driver.multiEval.evMagnitude.maximum.nref.read() \n
+		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:MERRor:AVERage:NREF \n
+		Snippet: value: ResultData = driver.lteMeas.multiEval.merror.average.nref.read() \n
 		No command help available \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:EVMagnitude:MAXimum:NREF?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:MERRor:AVERage:NREF?', self.__class__.ResultData())
 
 	def fetch(self) -> ResultData:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:EVMagnitude:MAXimum:NREF \n
-		Snippet: value: ResultData = driver.multiEval.evMagnitude.maximum.nref.fetch() \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:MERRor:AVERage:NREF \n
+		Snippet: value: ResultData = driver.lteMeas.multiEval.merror.average.nref.fetch() \n
 		No command help available \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:EVMagnitude:MAXimum:NREF?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:MERRor:AVERage:NREF?', self.__class__.ResultData())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/EvMagnitude_/Peak.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Trace/Aclr/__init__.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,43 +1,35 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Peak:
-	"""Peak commands group definition. 6 total commands, 3 Sub-groups, 0 group commands"""
+class AclrCls:
+	"""Aclr commands group definition. 4 total commands, 2 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("peak", core, parent)
+		self._cmd_group = CommandsGroup("aclr", core, parent)
 
 	@property
 	def current(self):
 		"""current commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_current'):
-			from .Peak_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
 	@property
 	def average(self):
 		"""average commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_average'):
-			from .Peak_.Average import Average
-			self._average = Average(self._core, self._base)
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
 		return self._average
 
-	@property
-	def maximum(self):
-		"""maximum commands group. 0 Sub-classes, 2 commands."""
-		if not hasattr(self, '_maximum'):
-			from .Peak_.Maximum import Maximum
-			self._maximum = Maximum(self._core, self._base)
-		return self._maximum
-
-	def clone(self) -> 'Peak':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'AclrCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Peak(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = AclrCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/EvMagnitude_/Peak_/Average.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/EvMagnitude/Peak/Average.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,28 +1,28 @@
 from typing import List
 
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
-from .....Internal.Types import DataType
-from .....Internal.StructBase import StructBase
-from .....Internal.ArgStruct import ArgStruct
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal.Types import DataType
+from ......Internal.StructBase import StructBase
+from ......Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class AverageCls:
+	"""Average commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
+			- Reliability: int: 'Reliability indicator'
 			- Low: List[float]: EVM value for low EVM window position
 			- High: List[float]: EVM value for high EVM window position"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct('Low', DataType.FloatList, None, False, True, 1),
 			ArgStruct('High', DataType.FloatList, None, False, True, 1)]
 
@@ -30,22 +30,22 @@
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Low: List[float] = None
 			self.High: List[float] = None
 
 	def read(self) -> ResultData:
 		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:EVMagnitude:PEAK:AVERage \n
-		Snippet: value: ResultData = driver.multiEval.evMagnitude.peak.average.read() \n
-		Returns the values of the EVM peak bar graphs for the SC-FDMA symbols in the measured slot. The results of the current,
-		average and maximum bar graphs can be retrieved. There is one pair of EVM values per SC-FDMA symbol, returned in the
+		Snippet: value: ResultData = driver.lteMeas.multiEval.evMagnitude.peak.average.read() \n
+		Returns the values of the EVM peak diagrams for the SC-FDMA symbols in the measured slot. The results of the current,
+		average and maximum diagrams can be retrieved. There is one pair of EVM values per SC-FDMA symbol, returned in the
 		following order: <Reliability>, {<Low>, <High>}symbol 0, {<Low>, <High>}symbol 1, ... See also 'Square EVM'. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
 		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:EVMagnitude:PEAK:AVERage?', self.__class__.ResultData())
 
 	def fetch(self) -> ResultData:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:EVMagnitude:PEAK:AVERage \n
-		Snippet: value: ResultData = driver.multiEval.evMagnitude.peak.average.fetch() \n
-		Returns the values of the EVM peak bar graphs for the SC-FDMA symbols in the measured slot. The results of the current,
-		average and maximum bar graphs can be retrieved. There is one pair of EVM values per SC-FDMA symbol, returned in the
+		Snippet: value: ResultData = driver.lteMeas.multiEval.evMagnitude.peak.average.fetch() \n
+		Returns the values of the EVM peak diagrams for the SC-FDMA symbols in the measured slot. The results of the current,
+		average and maximum diagrams can be retrieved. There is one pair of EVM values per SC-FDMA symbol, returned in the
 		following order: <Reliability>, {<Low>, <High>}symbol 0, {<Low>, <High>}symbol 1, ... See also 'Square EVM'. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
 		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:EVMagnitude:PEAK:AVERage?', self.__class__.ResultData())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/EvMagnitude_/Peak_/Current.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/EvMagnitude/Peak/Current.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,28 +1,28 @@
 from typing import List
 
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
-from .....Internal.Types import DataType
-from .....Internal.StructBase import StructBase
-from .....Internal.ArgStruct import ArgStruct
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal.Types import DataType
+from ......Internal.StructBase import StructBase
+from ......Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
+			- Reliability: int: 'Reliability indicator'
 			- Low: List[float]: EVM value for low EVM window position
 			- High: List[float]: EVM value for high EVM window position"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct('Low', DataType.FloatList, None, False, True, 1),
 			ArgStruct('High', DataType.FloatList, None, False, True, 1)]
 
@@ -30,22 +30,22 @@
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Low: List[float] = None
 			self.High: List[float] = None
 
 	def read(self) -> ResultData:
 		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:EVMagnitude:PEAK:CURRent \n
-		Snippet: value: ResultData = driver.multiEval.evMagnitude.peak.current.read() \n
-		Returns the values of the EVM peak bar graphs for the SC-FDMA symbols in the measured slot. The results of the current,
-		average and maximum bar graphs can be retrieved. There is one pair of EVM values per SC-FDMA symbol, returned in the
+		Snippet: value: ResultData = driver.lteMeas.multiEval.evMagnitude.peak.current.read() \n
+		Returns the values of the EVM peak diagrams for the SC-FDMA symbols in the measured slot. The results of the current,
+		average and maximum diagrams can be retrieved. There is one pair of EVM values per SC-FDMA symbol, returned in the
 		following order: <Reliability>, {<Low>, <High>}symbol 0, {<Low>, <High>}symbol 1, ... See also 'Square EVM'. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
 		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:EVMagnitude:PEAK:CURRent?', self.__class__.ResultData())
 
 	def fetch(self) -> ResultData:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:EVMagnitude:PEAK:CURRent \n
-		Snippet: value: ResultData = driver.multiEval.evMagnitude.peak.current.fetch() \n
-		Returns the values of the EVM peak bar graphs for the SC-FDMA symbols in the measured slot. The results of the current,
-		average and maximum bar graphs can be retrieved. There is one pair of EVM values per SC-FDMA symbol, returned in the
+		Snippet: value: ResultData = driver.lteMeas.multiEval.evMagnitude.peak.current.fetch() \n
+		Returns the values of the EVM peak diagrams for the SC-FDMA symbols in the measured slot. The results of the current,
+		average and maximum diagrams can be retrieved. There is one pair of EVM values per SC-FDMA symbol, returned in the
 		following order: <Reliability>, {<Low>, <High>}symbol 0, {<Low>, <High>}symbol 1, ... See also 'Square EVM'. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
 		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:EVMagnitude:PEAK:CURRent?', self.__class__.ResultData())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/EvMagnitude_/Peak_/Maximum.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/EvMagnitude/Peak/Maximum.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,28 +1,28 @@
 from typing import List
 
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
-from .....Internal.Types import DataType
-from .....Internal.StructBase import StructBase
-from .....Internal.ArgStruct import ArgStruct
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal.Types import DataType
+from ......Internal.StructBase import StructBase
+from ......Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Maximum:
-	"""Maximum commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class MaximumCls:
+	"""Maximum commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("maximum", core, parent)
+		self._cmd_group = CommandsGroup("maximum", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
+			- Reliability: int: 'Reliability indicator'
 			- Low: List[float]: EVM value for low EVM window position
 			- High: List[float]: EVM value for high EVM window position"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct('Low', DataType.FloatList, None, False, True, 1),
 			ArgStruct('High', DataType.FloatList, None, False, True, 1)]
 
@@ -30,22 +30,22 @@
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Low: List[float] = None
 			self.High: List[float] = None
 
 	def read(self) -> ResultData:
 		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:EVMagnitude:PEAK:MAXimum \n
-		Snippet: value: ResultData = driver.multiEval.evMagnitude.peak.maximum.read() \n
-		Returns the values of the EVM peak bar graphs for the SC-FDMA symbols in the measured slot. The results of the current,
-		average and maximum bar graphs can be retrieved. There is one pair of EVM values per SC-FDMA symbol, returned in the
+		Snippet: value: ResultData = driver.lteMeas.multiEval.evMagnitude.peak.maximum.read() \n
+		Returns the values of the EVM peak diagrams for the SC-FDMA symbols in the measured slot. The results of the current,
+		average and maximum diagrams can be retrieved. There is one pair of EVM values per SC-FDMA symbol, returned in the
 		following order: <Reliability>, {<Low>, <High>}symbol 0, {<Low>, <High>}symbol 1, ... See also 'Square EVM'. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
 		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:EVMagnitude:PEAK:MAXimum?', self.__class__.ResultData())
 
 	def fetch(self) -> ResultData:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:EVMagnitude:PEAK:MAXimum \n
-		Snippet: value: ResultData = driver.multiEval.evMagnitude.peak.maximum.fetch() \n
-		Returns the values of the EVM peak bar graphs for the SC-FDMA symbols in the measured slot. The results of the current,
-		average and maximum bar graphs can be retrieved. There is one pair of EVM values per SC-FDMA symbol, returned in the
+		Snippet: value: ResultData = driver.lteMeas.multiEval.evMagnitude.peak.maximum.fetch() \n
+		Returns the values of the EVM peak diagrams for the SC-FDMA symbols in the measured slot. The results of the current,
+		average and maximum diagrams can be retrieved. There is one pair of EVM values per SC-FDMA symbol, returned in the
 		following order: <Reliability>, {<Low>, <High>}symbol 0, {<Low>, <High>}symbol 1, ... See also 'Square EVM'. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
 		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:EVMagnitude:PEAK:MAXimum?', self.__class__.ResultData())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Evmc.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/InbandEmission/Ulca/__init__.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,27 +1,35 @@
-from ...Internal.Core import Core
-from ...Internal.CommandsGroup import CommandsGroup
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Evmc:
-	"""Evmc commands group definition. 8 total commands, 1 Sub-groups, 0 group commands"""
+class UlcaCls:
+	"""Ulca commands group definition. 12 total commands, 2 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("evmc", core, parent)
+		self._cmd_group = CommandsGroup("ulca", core, parent)
 
 	@property
-	def peak(self):
-		"""peak commands group. 4 Sub-classes, 0 commands."""
-		if not hasattr(self, '_peak'):
-			from .Evmc_.Peak import Peak
-			self._peak = Peak(self._core, self._base)
-		return self._peak
+	def scc(self):
+		"""scc commands group. 1 Sub-classes, 0 commands."""
+		if not hasattr(self, '_scc'):
+			from .Scc import SccCls
+			self._scc = SccCls(self._core, self._cmd_group)
+		return self._scc
 
-	def clone(self) -> 'Evmc':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	@property
+	def pcc(self):
+		"""pcc commands group. 1 Sub-classes, 0 commands."""
+		if not hasattr(self, '_pcc'):
+			from .Pcc import PccCls
+			self._pcc = PccCls(self._core, self._cmd_group)
+		return self._pcc
+
+	def clone(self) -> 'UlcaCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Evmc(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = UlcaCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Evmc_/Peak.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Pmonitor/Scc/__init__.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,51 +1,59 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Peak:
-	"""Peak commands group definition. 8 total commands, 4 Sub-groups, 0 group commands"""
+class SccCls:
+	"""Scc commands group definition. 10 total commands, 5 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("peak", core, parent)
+		self._cmd_group = CommandsGroup("scc", core, parent)
 
 	@property
 	def current(self):
 		"""current commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_current'):
-			from .Peak_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
 	@property
 	def average(self):
 		"""average commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_average'):
-			from .Peak_.Average import Average
-			self._average = Average(self._core, self._base)
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
 		return self._average
 
 	@property
 	def maximum(self):
 		"""maximum commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_maximum'):
-			from .Peak_.Maximum import Maximum
-			self._maximum = Maximum(self._core, self._base)
+			from .Maximum import MaximumCls
+			self._maximum = MaximumCls(self._core, self._cmd_group)
 		return self._maximum
 
 	@property
+	def minimum(self):
+		"""minimum commands group. 0 Sub-classes, 2 commands."""
+		if not hasattr(self, '_minimum'):
+			from .Minimum import MinimumCls
+			self._minimum = MinimumCls(self._core, self._cmd_group)
+		return self._minimum
+
+	@property
 	def standardDev(self):
 		"""standardDev commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_standardDev'):
-			from .Peak_.StandardDev import StandardDev
-			self._standardDev = StandardDev(self._core, self._base)
+			from .StandardDev import StandardDevCls
+			self._standardDev = StandardDevCls(self._core, self._cmd_group)
 		return self._standardDev
 
-	def clone(self) -> 'Peak':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'SccCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Peak(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = SccCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Evmc_/Peak_/Average.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Evmc/Peak/Average.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,36 +1,36 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
-from .....Internal import Conversions
-from .....Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from .....Internal.Types import DataType
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal import Conversions
+from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from ......Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class AverageCls:
+	"""Average commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	def read(self) -> float:
 		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:EVMC:PEAK:AVERage \n
-		Snippet: value: float = driver.multiEval.evmc.peak.average.read() \n
+		Snippet: value: float = driver.lteMeas.multiEval.evmc.peak.average.read() \n
 		The CURRent command returns the maximum value of the EVM vs subcarrier trace. The AVERage, MAXimum and SDEViation values
 		are calculated from the CURRent values. The peak results cannot be displayed at the GUI. \n
 		Suppressed linked return values: reliability \n
 			:return: evm_cpeak_average: No help available"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_str_suppressed(f'READ:LTE:MEASurement<Instance>:MEValuation:EVMC:PEAK:AVERage?', suppressed)
 		return Conversions.str_to_float(response)
 
 	def fetch(self) -> float:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:EVMC:PEAK:AVERage \n
-		Snippet: value: float = driver.multiEval.evmc.peak.average.fetch() \n
+		Snippet: value: float = driver.lteMeas.multiEval.evmc.peak.average.fetch() \n
 		The CURRent command returns the maximum value of the EVM vs subcarrier trace. The AVERage, MAXimum and SDEViation values
 		are calculated from the CURRent values. The peak results cannot be displayed at the GUI. \n
 		Suppressed linked return values: reliability \n
 			:return: evm_cpeak_average: No help available"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_str_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:EVMC:PEAK:AVERage?', suppressed)
 		return Conversions.str_to_float(response)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Evmc_/Peak_/Current.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Evmc/Peak/StandardDev.py`

 * *Files 11% similar despite different names*

```diff
@@ -1,36 +1,36 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
-from .....Internal import Conversions
-from .....Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from .....Internal.Types import DataType
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal import Conversions
+from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from ......Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class StandardDevCls:
+	"""StandardDev commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("standardDev", core, parent)
 
 	def read(self) -> float:
-		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:EVMC:PEAK:CURRent \n
-		Snippet: value: float = driver.multiEval.evmc.peak.current.read() \n
+		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:EVMC:PEAK:SDEViation \n
+		Snippet: value: float = driver.lteMeas.multiEval.evmc.peak.standardDev.read() \n
 		The CURRent command returns the maximum value of the EVM vs subcarrier trace. The AVERage, MAXimum and SDEViation values
 		are calculated from the CURRent values. The peak results cannot be displayed at the GUI. \n
 		Suppressed linked return values: reliability \n
-			:return: evm_cpeak_current: No help available"""
+			:return: evm_cpeak_std_dev: No help available"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_str_suppressed(f'READ:LTE:MEASurement<Instance>:MEValuation:EVMC:PEAK:CURRent?', suppressed)
+		response = self._core.io.query_str_suppressed(f'READ:LTE:MEASurement<Instance>:MEValuation:EVMC:PEAK:SDEViation?', suppressed)
 		return Conversions.str_to_float(response)
 
 	def fetch(self) -> float:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:EVMC:PEAK:CURRent \n
-		Snippet: value: float = driver.multiEval.evmc.peak.current.fetch() \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:EVMC:PEAK:SDEViation \n
+		Snippet: value: float = driver.lteMeas.multiEval.evmc.peak.standardDev.fetch() \n
 		The CURRent command returns the maximum value of the EVM vs subcarrier trace. The AVERage, MAXimum and SDEViation values
 		are calculated from the CURRent values. The peak results cannot be displayed at the GUI. \n
 		Suppressed linked return values: reliability \n
-			:return: evm_cpeak_current: No help available"""
+			:return: evm_cpeak_std_dev: No help available"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_str_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:EVMC:PEAK:CURRent?', suppressed)
+		response = self._core.io.query_str_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:EVMC:PEAK:SDEViation?', suppressed)
 		return Conversions.str_to_float(response)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Evmc_/Peak_/Maximum.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Evmc/Peak/Maximum.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,36 +1,36 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
-from .....Internal import Conversions
-from .....Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from .....Internal.Types import DataType
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal import Conversions
+from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from ......Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Maximum:
-	"""Maximum commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class MaximumCls:
+	"""Maximum commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("maximum", core, parent)
+		self._cmd_group = CommandsGroup("maximum", core, parent)
 
 	def read(self) -> float:
 		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:EVMC:PEAK:MAXimum \n
-		Snippet: value: float = driver.multiEval.evmc.peak.maximum.read() \n
+		Snippet: value: float = driver.lteMeas.multiEval.evmc.peak.maximum.read() \n
 		The CURRent command returns the maximum value of the EVM vs subcarrier trace. The AVERage, MAXimum and SDEViation values
 		are calculated from the CURRent values. The peak results cannot be displayed at the GUI. \n
 		Suppressed linked return values: reliability \n
 			:return: evm_cpeak_maximum: No help available"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_str_suppressed(f'READ:LTE:MEASurement<Instance>:MEValuation:EVMC:PEAK:MAXimum?', suppressed)
 		return Conversions.str_to_float(response)
 
 	def fetch(self) -> float:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:EVMC:PEAK:MAXimum \n
-		Snippet: value: float = driver.multiEval.evmc.peak.maximum.fetch() \n
+		Snippet: value: float = driver.lteMeas.multiEval.evmc.peak.maximum.fetch() \n
 		The CURRent command returns the maximum value of the EVM vs subcarrier trace. The AVERage, MAXimum and SDEViation values
 		are calculated from the CURRent values. The peak results cannot be displayed at the GUI. \n
 		Suppressed linked return values: reliability \n
 			:return: evm_cpeak_maximum: No help available"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_str_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:EVMC:PEAK:MAXimum?', suppressed)
 		return Conversions.str_to_float(response)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Evmc_/Peak_/StandardDev.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Evmc/Peak/Current.py`

 * *Files 11% similar despite different names*

```diff
@@ -1,36 +1,36 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
-from .....Internal import Conversions
-from .....Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from .....Internal.Types import DataType
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal import Conversions
+from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from ......Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class StandardDev:
-	"""StandardDev commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("standardDev", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	def read(self) -> float:
-		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:EVMC:PEAK:SDEViation \n
-		Snippet: value: float = driver.multiEval.evmc.peak.standardDev.read() \n
+		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:EVMC:PEAK:CURRent \n
+		Snippet: value: float = driver.lteMeas.multiEval.evmc.peak.current.read() \n
 		The CURRent command returns the maximum value of the EVM vs subcarrier trace. The AVERage, MAXimum and SDEViation values
 		are calculated from the CURRent values. The peak results cannot be displayed at the GUI. \n
 		Suppressed linked return values: reliability \n
-			:return: evm_cpeak_std_dev: No help available"""
+			:return: evm_cpeak_current: No help available"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_str_suppressed(f'READ:LTE:MEASurement<Instance>:MEValuation:EVMC:PEAK:SDEViation?', suppressed)
+		response = self._core.io.query_str_suppressed(f'READ:LTE:MEASurement<Instance>:MEValuation:EVMC:PEAK:CURRent?', suppressed)
 		return Conversions.str_to_float(response)
 
 	def fetch(self) -> float:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:EVMC:PEAK:SDEViation \n
-		Snippet: value: float = driver.multiEval.evmc.peak.standardDev.fetch() \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:EVMC:PEAK:CURRent \n
+		Snippet: value: float = driver.lteMeas.multiEval.evmc.peak.current.fetch() \n
 		The CURRent command returns the maximum value of the EVM vs subcarrier trace. The AVERage, MAXimum and SDEViation values
 		are calculated from the CURRent values. The peak results cannot be displayed at the GUI. \n
 		Suppressed linked return values: reliability \n
-			:return: evm_cpeak_std_dev: No help available"""
+			:return: evm_cpeak_current: No help available"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_str_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:EVMC:PEAK:SDEViation?', suppressed)
+		response = self._core.io.query_str_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:EVMC:PEAK:CURRent?', suppressed)
 		return Conversions.str_to_float(response)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/InbandEmission.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Trace/Iemissions/__init__.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,51 +1,51 @@
-from ...Internal.Core import Core
-from ...Internal.CommandsGroup import CommandsGroup
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class InbandEmission:
-	"""InbandEmission commands group definition. 30 total commands, 4 Sub-groups, 0 group commands"""
+class IemissionsCls:
+	"""Iemissions commands group definition. 10 total commands, 4 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("inbandEmission", core, parent)
+		self._cmd_group = CommandsGroup("iemissions", core, parent)
 
 	@property
 	def scc(self):
-		"""scc commands group. 1 Sub-classes, 0 commands."""
+		"""scc commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_scc'):
-			from .InbandEmission_.Scc import Scc
-			self._scc = Scc(self._core, self._base)
+			from .Scc import SccCls
+			self._scc = SccCls(self._core, self._cmd_group)
 		return self._scc
 
 	@property
 	def ulca(self):
 		"""ulca commands group. 2 Sub-classes, 0 commands."""
 		if not hasattr(self, '_ulca'):
-			from .InbandEmission_.Ulca import Ulca
-			self._ulca = Ulca(self._core, self._base)
+			from .Ulca import UlcaCls
+			self._ulca = UlcaCls(self._core, self._cmd_group)
 		return self._ulca
 
 	@property
 	def cc(self):
-		"""cc commands group. 1 Sub-classes, 0 commands."""
+		"""cc commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_cc'):
-			from .InbandEmission_.Cc import Cc
-			self._cc = Cc(self._core, self._base)
+			from .Cc import CcCls
+			self._cc = CcCls(self._core, self._cmd_group)
 		return self._cc
 
 	@property
 	def pcc(self):
-		"""pcc commands group. 1 Sub-classes, 0 commands."""
+		"""pcc commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_pcc'):
-			from .InbandEmission_.Pcc import Pcc
-			self._pcc = Pcc(self._core, self._base)
+			from .Pcc import PccCls
+			self._pcc = PccCls(self._core, self._cmd_group)
 		return self._pcc
 
-	def clone(self) -> 'InbandEmission':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'IemissionsCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = InbandEmission(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = IemissionsCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/InbandEmission_/Cc.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/InbandEmission/Cc/__init__.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,42 +1,42 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
-from ....Internal.RepeatedCapability import RepeatedCapability
-from .... import repcap
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal.RepeatedCapability import RepeatedCapability
+from ...... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Cc:
-	"""Cc commands group definition. 6 total commands, 1 Sub-groups, 0 group commands
+class CcCls:
+	"""Cc commands group definition. 6 total commands, 1 Subgroups, 0 group commands
 	Repeated Capability: CarrierComponent, default value after init: CarrierComponent.Nr1"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("cc", core, parent)
-		self._base.rep_cap = RepeatedCapability(self._base.group_name, 'repcap_carrierComponent_get', 'repcap_carrierComponent_set', repcap.CarrierComponent.Nr1)
+		self._cmd_group = CommandsGroup("cc", core, parent)
+		self._cmd_group.rep_cap = RepeatedCapability(self._cmd_group.group_name, 'repcap_carrierComponent_get', 'repcap_carrierComponent_set', repcap.CarrierComponent.Nr1)
 
-	def repcap_carrierComponent_set(self, enum_value: repcap.CarrierComponent) -> None:
+	def repcap_carrierComponent_set(self, carrierComponent: repcap.CarrierComponent) -> None:
 		"""Repeated Capability default value numeric suffix.
 		This value is used, if you do not explicitely set it in the child set/get methods, or if you leave it to CarrierComponent.Default
 		Default value after init: CarrierComponent.Nr1"""
-		self._base.set_repcap_enum_value(enum_value)
+		self._cmd_group.set_repcap_enum_value(carrierComponent)
 
 	def repcap_carrierComponent_get(self) -> repcap.CarrierComponent:
 		"""Returns the current default repeated capability for the child set/get methods"""
 		# noinspection PyTypeChecker
-		return self._base.get_repcap_enum_value()
+		return self._cmd_group.get_repcap_enum_value()
 
 	@property
 	def margin(self):
 		"""margin commands group. 4 Sub-classes, 0 commands."""
 		if not hasattr(self, '_margin'):
-			from .Cc_.Margin import Margin
-			self._margin = Margin(self._core, self._base)
+			from .Margin import MarginCls
+			self._margin = MarginCls(self._core, self._cmd_group)
 		return self._margin
 
-	def clone(self) -> 'Cc':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'CcCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Cc(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = CcCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/InbandEmission_/Cc_/Margin.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/EsFlatness/__init__.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,51 +1,51 @@
 from .....Internal.Core import Core
 from .....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Margin:
-	"""Margin commands group definition. 6 total commands, 4 Sub-groups, 0 group commands"""
+class EsFlatnessCls:
+	"""EsFlatness commands group definition. 13 total commands, 4 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("margin", core, parent)
+		self._cmd_group = CommandsGroup("esFlatness", core, parent)
 
 	@property
 	def current(self):
-		"""current commands group. 1 Sub-classes, 1 commands."""
+		"""current commands group. 1 Sub-classes, 3 commands."""
 		if not hasattr(self, '_current'):
-			from .Margin_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
 	@property
 	def average(self):
-		"""average commands group. 0 Sub-classes, 1 commands."""
+		"""average commands group. 0 Sub-classes, 3 commands."""
 		if not hasattr(self, '_average'):
-			from .Margin_.Average import Average
-			self._average = Average(self._core, self._base)
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
 		return self._average
 
 	@property
 	def extreme(self):
-		"""extreme commands group. 1 Sub-classes, 1 commands."""
+		"""extreme commands group. 0 Sub-classes, 3 commands."""
 		if not hasattr(self, '_extreme'):
-			from .Margin_.Extreme import Extreme
-			self._extreme = Extreme(self._core, self._base)
+			from .Extreme import ExtremeCls
+			self._extreme = ExtremeCls(self._core, self._cmd_group)
 		return self._extreme
 
 	@property
 	def standardDev(self):
-		"""standardDev commands group. 0 Sub-classes, 1 commands."""
+		"""standardDev commands group. 0 Sub-classes, 3 commands."""
 		if not hasattr(self, '_standardDev'):
-			from .Margin_.StandardDev import StandardDev
-			self._standardDev = StandardDev(self._core, self._base)
+			from .StandardDev import StandardDevCls
+			self._standardDev = StandardDevCls(self._core, self._cmd_group)
 		return self._standardDev
 
-	def clone(self) -> 'Margin':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'EsFlatnessCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Margin(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = EsFlatnessCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/InbandEmission_/Cc_/Margin_/Average.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/InbandEmission/Cc/Margin/Average.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,43 +1,43 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.StructBase import StructBase
-from ......Internal.ArgStruct import ArgStruct
-from ...... import repcap
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal.StructBase import StructBase
+from .......Internal.ArgStruct import ArgStruct
+from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class AverageCls:
+	"""Average commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Out_Of_Tolerance: int: Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for modulation measurements exceeding the specified modulation limits.
+			- Reliability: int: 'Reliability indicator'
+			- Out_Of_Tolerance: int: Out of tolerance result, i.e. the percentage of measurement intervals of the statistic count for modulation measurements exceeding the specified modulation limits.
 			- Margin: float: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
 			ArgStruct.scalar_float('Margin')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tolerance: int = None
 			self.Margin: float = None
 
 	def fetch(self, carrierComponent=repcap.CarrierComponent.Default) -> FetchStruct:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:IEMission:CC<Nr>:MARGin:AVERage \n
-		Snippet: value: FetchStruct = driver.multiEval.inbandEmission.cc.margin.average.fetch(carrierComponent = repcap.CarrierComponent.Default) \n
+		Snippet: value: FetchStruct = driver.lteMeas.multiEval.inbandEmission.cc.margin.average.fetch(carrierComponent = repcap.CarrierComponent.Default) \n
 		Return the limit line margin results for the CC<no> diagram. The CURRent margin indicates the minimum (vertical) distance
-		between the inband emissions limit line and the current trace. A negative result indicates that the limit is exceeded.
+		between the in-band emissions limit line and the current trace. A negative result indicates that the limit is exceeded.
 		The AVERage, EXTReme and SDEViation values are calculated from the current margins. The margin results cannot be
 		displayed at the GUI. \n
 			:param carrierComponent: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Cc')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		carrierComponent_cmd_val = self._base.get_repcap_cmd_value(carrierComponent, repcap.CarrierComponent)
+		carrierComponent_cmd_val = self._cmd_group.get_repcap_cmd_value(carrierComponent, repcap.CarrierComponent)
 		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:IEMission:CC{carrierComponent_cmd_val}:MARGin:AVERage?', self.__class__.FetchStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/InbandEmission_/Cc_/Margin_/Current.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/InbandEmission/Cc/Margin/StandardDev.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,59 +1,43 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.StructBase import StructBase
-from ......Internal.ArgStruct import ArgStruct
-from ...... import repcap
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal.StructBase import StructBase
+from .......Internal.ArgStruct import ArgStruct
+from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 2 total commands, 1 Sub-groups, 1 group commands"""
+class StandardDevCls:
+	"""StandardDev commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
-
-	@property
-	def rbIndex(self):
-		"""rbIndex commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_rbIndex'):
-			from .Current_.RbIndex import RbIndex
-			self._rbIndex = RbIndex(self._core, self._base)
-		return self._rbIndex
+		self._cmd_group = CommandsGroup("standardDev", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Out_Of_Tolerance: int: Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for modulation measurements exceeding the specified modulation limits.
+			- Reliability: int: 'Reliability indicator'
+			- Out_Of_Tolerance: int: Out of tolerance result, i.e. the percentage of measurement intervals of the statistic count for modulation measurements exceeding the specified modulation limits.
 			- Margin: float: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
 			ArgStruct.scalar_float('Margin')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tolerance: int = None
 			self.Margin: float = None
 
 	def fetch(self, carrierComponent=repcap.CarrierComponent.Default) -> FetchStruct:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:IEMission:CC<Nr>:MARGin:CURRent \n
-		Snippet: value: FetchStruct = driver.multiEval.inbandEmission.cc.margin.current.fetch(carrierComponent = repcap.CarrierComponent.Default) \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:IEMission:CC<Nr>:MARGin:SDEViation \n
+		Snippet: value: FetchStruct = driver.lteMeas.multiEval.inbandEmission.cc.margin.standardDev.fetch(carrierComponent = repcap.CarrierComponent.Default) \n
 		Return the limit line margin results for the CC<no> diagram. The CURRent margin indicates the minimum (vertical) distance
-		between the inband emissions limit line and the current trace. A negative result indicates that the limit is exceeded.
+		between the in-band emissions limit line and the current trace. A negative result indicates that the limit is exceeded.
 		The AVERage, EXTReme and SDEViation values are calculated from the current margins. The margin results cannot be
 		displayed at the GUI. \n
 			:param carrierComponent: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Cc')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		carrierComponent_cmd_val = self._base.get_repcap_cmd_value(carrierComponent, repcap.CarrierComponent)
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:IEMission:CC{carrierComponent_cmd_val}:MARGin:CURRent?', self.__class__.FetchStruct())
-
-	def clone(self) -> 'Current':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
-		Also copies all the existing default Repeated Capabilities setting,
-		which you can change independently without affecting the original group"""
-		new_group = Current(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
-		return new_group
+		carrierComponent_cmd_val = self._cmd_group.get_repcap_cmd_value(carrierComponent, repcap.CarrierComponent)
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:IEMission:CC{carrierComponent_cmd_val}:MARGin:SDEViation?', self.__class__.FetchStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/InbandEmission_/Cc_/Margin_/Current_/RbIndex.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/InbandEmission/Cc/Margin/Current/RbIndex.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,41 +1,41 @@
-from .......Internal.Core import Core
-from .......Internal.CommandsGroup import CommandsGroup
-from .......Internal.StructBase import StructBase
-from .......Internal.ArgStruct import ArgStruct
-from ....... import repcap
+from ........Internal.Core import Core
+from ........Internal.CommandsGroup import CommandsGroup
+from ........Internal.StructBase import StructBase
+from ........Internal.ArgStruct import ArgStruct
+from ........ import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class RbIndex:
-	"""RbIndex commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class RbIndexCls:
+	"""RbIndex commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("rbIndex", core, parent)
+		self._cmd_group = CommandsGroup("rbIndex", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Out_Of_Tolerance: int: Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for modulation measurements exceeding the specified modulation limits.
+			- Reliability: int: 'Reliability indicator'
+			- Out_Of_Tolerance: int: Out of tolerance result, i.e. the percentage of measurement intervals of the statistic count for modulation measurements exceeding the specified modulation limits.
 			- Rb_Index: int: Resource block index"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
 			ArgStruct.scalar_int('Rb_Index')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tolerance: int = None
 			self.Rb_Index: int = None
 
 	def fetch(self, carrierComponent=repcap.CarrierComponent.Default) -> FetchStruct:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:IEMission:CC<Nr>:MARGin:CURRent:RBINdex \n
-		Snippet: value: FetchStruct = driver.multiEval.inbandEmission.cc.margin.current.rbIndex.fetch(carrierComponent = repcap.CarrierComponent.Default) \n
-		Return resource block indices for CC<no> inband emission margins. At these RB indices, the CURRent and EXTReme margins
-		have been detected (see method RsCMPX_LteMeas.MultiEval.InbandEmission.Cc.Margin.Current.fetch and ...:EXTReme) . \n
+		Snippet: value: FetchStruct = driver.lteMeas.multiEval.inbandEmission.cc.margin.current.rbIndex.fetch(carrierComponent = repcap.CarrierComponent.Default) \n
+		Return resource block indices for CC<no> in-band emission margins. At these RB indices, the CURRent and EXTReme margins
+		have been detected (see method RsCMPX_LteMeas.LteMeas.MultiEval.InbandEmission.Cc.Margin.Current.fetch and ...:EXTReme) . \n
 			:param carrierComponent: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Cc')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		carrierComponent_cmd_val = self._base.get_repcap_cmd_value(carrierComponent, repcap.CarrierComponent)
+		carrierComponent_cmd_val = self._cmd_group.get_repcap_cmd_value(carrierComponent, repcap.CarrierComponent)
 		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:IEMission:CC{carrierComponent_cmd_val}:MARGin:CURRent:RBINdex?', self.__class__.FetchStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/InbandEmission_/Cc_/Margin_/Extreme.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/InbandEmission/Cc/Margin/Extreme/__init__.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,59 +1,59 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.StructBase import StructBase
-from ......Internal.ArgStruct import ArgStruct
-from ...... import repcap
+from ........Internal.Core import Core
+from ........Internal.CommandsGroup import CommandsGroup
+from ........Internal.StructBase import StructBase
+from ........Internal.ArgStruct import ArgStruct
+from ........ import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Extreme:
-	"""Extreme commands group definition. 2 total commands, 1 Sub-groups, 1 group commands"""
+class ExtremeCls:
+	"""Extreme commands group definition. 2 total commands, 1 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("extreme", core, parent)
+		self._cmd_group = CommandsGroup("extreme", core, parent)
 
 	@property
 	def rbIndex(self):
 		"""rbIndex commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_rbIndex'):
-			from .Extreme_.RbIndex import RbIndex
-			self._rbIndex = RbIndex(self._core, self._base)
+			from .RbIndex import RbIndexCls
+			self._rbIndex = RbIndexCls(self._core, self._cmd_group)
 		return self._rbIndex
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Out_Of_Tolerance: int: Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for modulation measurements exceeding the specified modulation limits.
+			- Reliability: int: 'Reliability indicator'
+			- Out_Of_Tolerance: int: Out of tolerance result, i.e. the percentage of measurement intervals of the statistic count for modulation measurements exceeding the specified modulation limits.
 			- Margin: float: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
 			ArgStruct.scalar_float('Margin')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tolerance: int = None
 			self.Margin: float = None
 
 	def fetch(self, carrierComponent=repcap.CarrierComponent.Default) -> FetchStruct:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:IEMission:CC<Nr>:MARGin:EXTReme \n
-		Snippet: value: FetchStruct = driver.multiEval.inbandEmission.cc.margin.extreme.fetch(carrierComponent = repcap.CarrierComponent.Default) \n
+		Snippet: value: FetchStruct = driver.lteMeas.multiEval.inbandEmission.cc.margin.extreme.fetch(carrierComponent = repcap.CarrierComponent.Default) \n
 		Return the limit line margin results for the CC<no> diagram. The CURRent margin indicates the minimum (vertical) distance
-		between the inband emissions limit line and the current trace. A negative result indicates that the limit is exceeded.
+		between the in-band emissions limit line and the current trace. A negative result indicates that the limit is exceeded.
 		The AVERage, EXTReme and SDEViation values are calculated from the current margins. The margin results cannot be
 		displayed at the GUI. \n
 			:param carrierComponent: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Cc')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		carrierComponent_cmd_val = self._base.get_repcap_cmd_value(carrierComponent, repcap.CarrierComponent)
+		carrierComponent_cmd_val = self._cmd_group.get_repcap_cmd_value(carrierComponent, repcap.CarrierComponent)
 		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:IEMission:CC{carrierComponent_cmd_val}:MARGin:EXTReme?', self.__class__.FetchStruct())
 
-	def clone(self) -> 'Extreme':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'ExtremeCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Extreme(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = ExtremeCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/InbandEmission_/Cc_/Margin_/Extreme_/RbIndex.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/InbandEmission/Cc/Margin/Extreme/RbIndex.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,41 +1,41 @@
-from .......Internal.Core import Core
-from .......Internal.CommandsGroup import CommandsGroup
-from .......Internal.StructBase import StructBase
-from .......Internal.ArgStruct import ArgStruct
-from ....... import repcap
+from ........Internal.Core import Core
+from ........Internal.CommandsGroup import CommandsGroup
+from ........Internal.StructBase import StructBase
+from ........Internal.ArgStruct import ArgStruct
+from ........ import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class RbIndex:
-	"""RbIndex commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class RbIndexCls:
+	"""RbIndex commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("rbIndex", core, parent)
+		self._cmd_group = CommandsGroup("rbIndex", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Out_Of_Tolerance: int: Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for modulation measurements exceeding the specified modulation limits.
+			- Reliability: int: 'Reliability indicator'
+			- Out_Of_Tolerance: int: Out of tolerance result, i.e. the percentage of measurement intervals of the statistic count for modulation measurements exceeding the specified modulation limits.
 			- Rb_Index: int: Resource block index"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
 			ArgStruct.scalar_int('Rb_Index')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tolerance: int = None
 			self.Rb_Index: int = None
 
 	def fetch(self, carrierComponent=repcap.CarrierComponent.Default) -> FetchStruct:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:IEMission:CC<Nr>:MARGin:EXTReme:RBINdex \n
-		Snippet: value: FetchStruct = driver.multiEval.inbandEmission.cc.margin.extreme.rbIndex.fetch(carrierComponent = repcap.CarrierComponent.Default) \n
-		Return resource block indices for CC<no> inband emission margins. At these RB indices, the CURRent and EXTReme margins
-		have been detected (see method RsCMPX_LteMeas.MultiEval.InbandEmission.Cc.Margin.Current.fetch and ...:EXTReme) . \n
+		Snippet: value: FetchStruct = driver.lteMeas.multiEval.inbandEmission.cc.margin.extreme.rbIndex.fetch(carrierComponent = repcap.CarrierComponent.Default) \n
+		Return resource block indices for CC<no> in-band emission margins. At these RB indices, the CURRent and EXTReme margins
+		have been detected (see method RsCMPX_LteMeas.LteMeas.MultiEval.InbandEmission.Cc.Margin.Current.fetch and ...:EXTReme) . \n
 			:param carrierComponent: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Cc')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		carrierComponent_cmd_val = self._base.get_repcap_cmd_value(carrierComponent, repcap.CarrierComponent)
+		carrierComponent_cmd_val = self._cmd_group.get_repcap_cmd_value(carrierComponent, repcap.CarrierComponent)
 		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:IEMission:CC{carrierComponent_cmd_val}:MARGin:EXTReme:RBINdex?', self.__class__.FetchStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/InbandEmission_/Cc_/Margin_/StandardDev.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/InbandEmission/Cc/Margin/Current/__init__.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,43 +1,59 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.StructBase import StructBase
-from ......Internal.ArgStruct import ArgStruct
-from ...... import repcap
+from ........Internal.Core import Core
+from ........Internal.CommandsGroup import CommandsGroup
+from ........Internal.StructBase import StructBase
+from ........Internal.ArgStruct import ArgStruct
+from ........ import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class StandardDev:
-	"""StandardDev commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 2 total commands, 1 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("standardDev", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
+
+	@property
+	def rbIndex(self):
+		"""rbIndex commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_rbIndex'):
+			from .RbIndex import RbIndexCls
+			self._rbIndex = RbIndexCls(self._core, self._cmd_group)
+		return self._rbIndex
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Out_Of_Tolerance: int: Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for modulation measurements exceeding the specified modulation limits.
+			- Reliability: int: 'Reliability indicator'
+			- Out_Of_Tolerance: int: Out of tolerance result, i.e. the percentage of measurement intervals of the statistic count for modulation measurements exceeding the specified modulation limits.
 			- Margin: float: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
 			ArgStruct.scalar_float('Margin')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tolerance: int = None
 			self.Margin: float = None
 
 	def fetch(self, carrierComponent=repcap.CarrierComponent.Default) -> FetchStruct:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:IEMission:CC<Nr>:MARGin:SDEViation \n
-		Snippet: value: FetchStruct = driver.multiEval.inbandEmission.cc.margin.standardDev.fetch(carrierComponent = repcap.CarrierComponent.Default) \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:IEMission:CC<Nr>:MARGin:CURRent \n
+		Snippet: value: FetchStruct = driver.lteMeas.multiEval.inbandEmission.cc.margin.current.fetch(carrierComponent = repcap.CarrierComponent.Default) \n
 		Return the limit line margin results for the CC<no> diagram. The CURRent margin indicates the minimum (vertical) distance
-		between the inband emissions limit line and the current trace. A negative result indicates that the limit is exceeded.
+		between the in-band emissions limit line and the current trace. A negative result indicates that the limit is exceeded.
 		The AVERage, EXTReme and SDEViation values are calculated from the current margins. The margin results cannot be
 		displayed at the GUI. \n
 			:param carrierComponent: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Cc')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		carrierComponent_cmd_val = self._base.get_repcap_cmd_value(carrierComponent, repcap.CarrierComponent)
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:IEMission:CC{carrierComponent_cmd_val}:MARGin:SDEViation?', self.__class__.FetchStruct())
+		carrierComponent_cmd_val = self._cmd_group.get_repcap_cmd_value(carrierComponent, repcap.CarrierComponent)
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:IEMission:CC{carrierComponent_cmd_val}:MARGin:CURRent?', self.__class__.FetchStruct())
+
+	def clone(self) -> 'CurrentCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
+		Also copies all the existing default Repeated Capabilities setting,
+		which you can change independently without affecting the original group"""
+		new_group = CurrentCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
+		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/InbandEmission_/Pcc.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Spectrum/Aclr/__init__.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,27 +1,27 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Pcc:
-	"""Pcc commands group definition. 6 total commands, 1 Sub-groups, 0 group commands"""
+class AclrCls:
+	"""Aclr commands group definition. 1 total commands, 1 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("pcc", core, parent)
+		self._cmd_group = CommandsGroup("aclr", core, parent)
 
 	@property
-	def margin(self):
-		"""margin commands group. 4 Sub-classes, 0 commands."""
-		if not hasattr(self, '_margin'):
-			from .Pcc_.Margin import Margin
-			self._margin = Margin(self._core, self._base)
-		return self._margin
+	def enable(self):
+		"""enable commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_enable'):
+			from .Enable import EnableCls
+			self._enable = EnableCls(self._core, self._cmd_group)
+		return self._enable
 
-	def clone(self) -> 'Pcc':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'AclrCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Pcc(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = AclrCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/InbandEmission_/Pcc_/Margin.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/InbandEmission/Cc/Margin/__init__.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,51 +1,51 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Margin:
-	"""Margin commands group definition. 6 total commands, 4 Sub-groups, 0 group commands"""
+class MarginCls:
+	"""Margin commands group definition. 6 total commands, 4 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("margin", core, parent)
+		self._cmd_group = CommandsGroup("margin", core, parent)
 
 	@property
 	def current(self):
 		"""current commands group. 1 Sub-classes, 1 commands."""
 		if not hasattr(self, '_current'):
-			from .Margin_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
 	@property
 	def average(self):
 		"""average commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_average'):
-			from .Margin_.Average import Average
-			self._average = Average(self._core, self._base)
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
 		return self._average
 
 	@property
 	def extreme(self):
 		"""extreme commands group. 1 Sub-classes, 1 commands."""
 		if not hasattr(self, '_extreme'):
-			from .Margin_.Extreme import Extreme
-			self._extreme = Extreme(self._core, self._base)
+			from .Extreme import ExtremeCls
+			self._extreme = ExtremeCls(self._core, self._cmd_group)
 		return self._extreme
 
 	@property
 	def standardDev(self):
 		"""standardDev commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_standardDev'):
-			from .Margin_.StandardDev import StandardDev
-			self._standardDev = StandardDev(self._core, self._base)
+			from .StandardDev import StandardDevCls
+			self._standardDev = StandardDevCls(self._core, self._cmd_group)
 		return self._standardDev
 
-	def clone(self) -> 'Margin':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'MarginCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Margin(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = MarginCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/InbandEmission_/Pcc_/Margin_/Average.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/InbandEmission/Pcc/Margin/Average.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,20 +1,20 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.StructBase import StructBase
-from ......Internal.ArgStruct import ArgStruct
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal.StructBase import StructBase
+from .......Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class AverageCls:
+	"""Average commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
 			- Reliability: int: No parameter help available
 			- Out_Of_Tolerance: int: No parameter help available
 			- Margin: float: No parameter help available"""
@@ -27,11 +27,11 @@
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tolerance: int = None
 			self.Margin: float = None
 
 	def fetch(self) -> FetchStruct:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:IEMission[:PCC]:MARGin:AVERage \n
-		Snippet: value: FetchStruct = driver.multiEval.inbandEmission.pcc.margin.average.fetch() \n
+		Snippet: value: FetchStruct = driver.lteMeas.multiEval.inbandEmission.pcc.margin.average.fetch() \n
 		No command help available \n
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
 		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:IEMission:PCC:MARGin:AVERage?', self.__class__.FetchStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/InbandEmission_/Pcc_/Margin_/Current.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/InbandEmission/Pcc/Margin/Current/__init__.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,27 +1,27 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.StructBase import StructBase
-from ......Internal.ArgStruct import ArgStruct
+from ........Internal.Core import Core
+from ........Internal.CommandsGroup import CommandsGroup
+from ........Internal.StructBase import StructBase
+from ........Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 2 total commands, 1 Sub-groups, 1 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 2 total commands, 1 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	@property
 	def rbIndex(self):
 		"""rbIndex commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_rbIndex'):
-			from .Current_.RbIndex import RbIndex
-			self._rbIndex = RbIndex(self._core, self._base)
+			from .RbIndex import RbIndexCls
+			self._rbIndex = RbIndexCls(self._core, self._cmd_group)
 		return self._rbIndex
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
 			- Reliability: int: No parameter help available
 			- Out_Of_Tolerance: int: No parameter help available
@@ -35,19 +35,19 @@
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tolerance: int = None
 			self.Margin: float = None
 
 	def fetch(self) -> FetchStruct:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:IEMission[:PCC]:MARGin:CURRent \n
-		Snippet: value: FetchStruct = driver.multiEval.inbandEmission.pcc.margin.current.fetch() \n
+		Snippet: value: FetchStruct = driver.lteMeas.multiEval.inbandEmission.pcc.margin.current.fetch() \n
 		No command help available \n
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
 		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:IEMission:PCC:MARGin:CURRent?', self.__class__.FetchStruct())
 
-	def clone(self) -> 'Current':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'CurrentCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Current(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = CurrentCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/InbandEmission_/Pcc_/Margin_/Current_/RbIndex.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/InbandEmission/Scc/Margin/Extreme/RbIndex.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,20 +1,20 @@
-from .......Internal.Core import Core
-from .......Internal.CommandsGroup import CommandsGroup
-from .......Internal.StructBase import StructBase
-from .......Internal.ArgStruct import ArgStruct
+from ........Internal.Core import Core
+from ........Internal.CommandsGroup import CommandsGroup
+from ........Internal.StructBase import StructBase
+from ........Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class RbIndex:
-	"""RbIndex commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class RbIndexCls:
+	"""RbIndex commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("rbIndex", core, parent)
+		self._cmd_group = CommandsGroup("rbIndex", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
 			- Reliability: int: No parameter help available
 			- Out_Of_Tolerance: int: No parameter help available
 			- Rb_Index: int: No parameter help available"""
@@ -26,12 +26,12 @@
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tolerance: int = None
 			self.Rb_Index: int = None
 
 	def fetch(self) -> FetchStruct:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:IEMission[:PCC]:MARGin:CURRent:RBINdex \n
-		Snippet: value: FetchStruct = driver.multiEval.inbandEmission.pcc.margin.current.rbIndex.fetch() \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:IEMission:SCC:MARGin:EXTReme:RBINdex \n
+		Snippet: value: FetchStruct = driver.lteMeas.multiEval.inbandEmission.scc.margin.extreme.rbIndex.fetch() \n
 		No command help available \n
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:IEMission:PCC:MARGin:CURRent:RBINdex?', self.__class__.FetchStruct())
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:IEMission:SCC:MARGin:EXTReme:RBINdex?', self.__class__.FetchStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/InbandEmission_/Pcc_/Margin_/Extreme.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/InbandEmission/Scc/Margin/Current/__init__.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,27 +1,27 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.StructBase import StructBase
-from ......Internal.ArgStruct import ArgStruct
+from ........Internal.Core import Core
+from ........Internal.CommandsGroup import CommandsGroup
+from ........Internal.StructBase import StructBase
+from ........Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Extreme:
-	"""Extreme commands group definition. 2 total commands, 1 Sub-groups, 1 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 2 total commands, 1 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("extreme", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	@property
 	def rbIndex(self):
 		"""rbIndex commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_rbIndex'):
-			from .Extreme_.RbIndex import RbIndex
-			self._rbIndex = RbIndex(self._core, self._base)
+			from .RbIndex import RbIndexCls
+			self._rbIndex = RbIndexCls(self._core, self._cmd_group)
 		return self._rbIndex
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
 			- Reliability: int: No parameter help available
 			- Out_Of_Tolerance: int: No parameter help available
@@ -34,20 +34,20 @@
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tolerance: int = None
 			self.Margin: float = None
 
 	def fetch(self) -> FetchStruct:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:IEMission[:PCC]:MARGin:EXTReme \n
-		Snippet: value: FetchStruct = driver.multiEval.inbandEmission.pcc.margin.extreme.fetch() \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:IEMission:SCC:MARGin:CURRent \n
+		Snippet: value: FetchStruct = driver.lteMeas.multiEval.inbandEmission.scc.margin.current.fetch() \n
 		No command help available \n
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:IEMission:PCC:MARGin:EXTReme?', self.__class__.FetchStruct())
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:IEMission:SCC:MARGin:CURRent?', self.__class__.FetchStruct())
 
-	def clone(self) -> 'Extreme':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'CurrentCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Extreme(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = CurrentCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/InbandEmission_/Pcc_/Margin_/Extreme_/RbIndex.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/InbandEmission/Ulca/Pcc/Margin/Current/RbIndex.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,20 +1,20 @@
-from .......Internal.Core import Core
-from .......Internal.CommandsGroup import CommandsGroup
-from .......Internal.StructBase import StructBase
-from .......Internal.ArgStruct import ArgStruct
+from .........Internal.Core import Core
+from .........Internal.CommandsGroup import CommandsGroup
+from .........Internal.StructBase import StructBase
+from .........Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class RbIndex:
-	"""RbIndex commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class RbIndexCls:
+	"""RbIndex commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("rbIndex", core, parent)
+		self._cmd_group = CommandsGroup("rbIndex", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
 			- Reliability: int: No parameter help available
 			- Out_Of_Tolerance: int: No parameter help available
 			- Rb_Index: int: No parameter help available"""
@@ -26,12 +26,12 @@
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tolerance: int = None
 			self.Rb_Index: int = None
 
 	def fetch(self) -> FetchStruct:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:IEMission[:PCC]:MARGin:EXTReme:RBINdex \n
-		Snippet: value: FetchStruct = driver.multiEval.inbandEmission.pcc.margin.extreme.rbIndex.fetch() \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:IEMission:ULCA[:PCC]:MARGin:CURRent:RBINdex \n
+		Snippet: value: FetchStruct = driver.lteMeas.multiEval.inbandEmission.ulca.pcc.margin.current.rbIndex.fetch() \n
 		No command help available \n
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:IEMission:PCC:MARGin:EXTReme:RBINdex?', self.__class__.FetchStruct())
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:IEMission:ULCA:PCC:MARGin:CURRent:RBINdex?', self.__class__.FetchStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/InbandEmission_/Pcc_/Margin_/StandardDev.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/InbandEmission/Pcc/Margin/StandardDev.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,20 +1,20 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.StructBase import StructBase
-from ......Internal.ArgStruct import ArgStruct
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal.StructBase import StructBase
+from .......Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class StandardDev:
-	"""StandardDev commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class StandardDevCls:
+	"""StandardDev commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("standardDev", core, parent)
+		self._cmd_group = CommandsGroup("standardDev", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
 			- Reliability: int: No parameter help available
 			- Out_Of_Tolerance: int: No parameter help available
 			- Margin: float: No parameter help available"""
@@ -27,11 +27,11 @@
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tolerance: int = None
 			self.Margin: float = None
 
 	def fetch(self) -> FetchStruct:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:IEMission[:PCC]:MARGin:SDEViation \n
-		Snippet: value: FetchStruct = driver.multiEval.inbandEmission.pcc.margin.standardDev.fetch() \n
+		Snippet: value: FetchStruct = driver.lteMeas.multiEval.inbandEmission.pcc.margin.standardDev.fetch() \n
 		No command help available \n
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
 		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:IEMission:PCC:MARGin:SDEViation?', self.__class__.FetchStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/InbandEmission_/Scc.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/SeMask/Margin/__init__.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,27 +1,27 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Scc:
-	"""Scc commands group definition. 6 total commands, 1 Sub-groups, 0 group commands"""
+class MarginCls:
+	"""Margin commands group definition. 6 total commands, 1 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("scc", core, parent)
+		self._cmd_group = CommandsGroup("margin", core, parent)
 
 	@property
-	def margin(self):
-		"""margin commands group. 4 Sub-classes, 0 commands."""
-		if not hasattr(self, '_margin'):
-			from .Scc_.Margin import Margin
-			self._margin = Margin(self._core, self._base)
-		return self._margin
+	def area(self):
+		"""area commands group. 2 Sub-classes, 0 commands."""
+		if not hasattr(self, '_area'):
+			from .Area import AreaCls
+			self._area = AreaCls(self._core, self._cmd_group)
+		return self._area
 
-	def clone(self) -> 'Scc':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'MarginCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Scc(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = MarginCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/InbandEmission_/Scc_/Margin.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/InbandEmission/Pcc/Margin/__init__.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,51 +1,51 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Margin:
-	"""Margin commands group definition. 6 total commands, 4 Sub-groups, 0 group commands"""
+class MarginCls:
+	"""Margin commands group definition. 6 total commands, 4 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("margin", core, parent)
+		self._cmd_group = CommandsGroup("margin", core, parent)
 
 	@property
 	def current(self):
 		"""current commands group. 1 Sub-classes, 1 commands."""
 		if not hasattr(self, '_current'):
-			from .Margin_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
 	@property
 	def average(self):
 		"""average commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_average'):
-			from .Margin_.Average import Average
-			self._average = Average(self._core, self._base)
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
 		return self._average
 
 	@property
 	def extreme(self):
 		"""extreme commands group. 1 Sub-classes, 1 commands."""
 		if not hasattr(self, '_extreme'):
-			from .Margin_.Extreme import Extreme
-			self._extreme = Extreme(self._core, self._base)
+			from .Extreme import ExtremeCls
+			self._extreme = ExtremeCls(self._core, self._cmd_group)
 		return self._extreme
 
 	@property
 	def standardDev(self):
 		"""standardDev commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_standardDev'):
-			from .Margin_.StandardDev import StandardDev
-			self._standardDev = StandardDev(self._core, self._base)
+			from .StandardDev import StandardDevCls
+			self._standardDev = StandardDevCls(self._core, self._cmd_group)
 		return self._standardDev
 
-	def clone(self) -> 'Margin':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'MarginCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Margin(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = MarginCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/InbandEmission_/Scc_/Margin_/Average.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/InbandEmission/Ulca/Pcc/Margin/StandardDev.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,20 +1,20 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.StructBase import StructBase
-from ......Internal.ArgStruct import ArgStruct
+from ........Internal.Core import Core
+from ........Internal.CommandsGroup import CommandsGroup
+from ........Internal.StructBase import StructBase
+from ........Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class StandardDevCls:
+	"""StandardDev commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("standardDev", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
 			- Reliability: int: No parameter help available
 			- Out_Of_Tolerance: int: No parameter help available
 			- Margin: float: No parameter help available"""
@@ -26,12 +26,12 @@
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tolerance: int = None
 			self.Margin: float = None
 
 	def fetch(self) -> FetchStruct:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:IEMission:SCC:MARGin:AVERage \n
-		Snippet: value: FetchStruct = driver.multiEval.inbandEmission.scc.margin.average.fetch() \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:IEMission:ULCA[:PCC]:MARGin:SDEViation \n
+		Snippet: value: FetchStruct = driver.lteMeas.multiEval.inbandEmission.ulca.pcc.margin.standardDev.fetch() \n
 		No command help available \n
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:IEMission:SCC:MARGin:AVERage?', self.__class__.FetchStruct())
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:IEMission:ULCA:PCC:MARGin:SDEViation?', self.__class__.FetchStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/InbandEmission_/Scc_/Margin_/Current.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/InbandEmission/Margin/Current/__init__.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,53 +1,62 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.StructBase import StructBase
-from ......Internal.ArgStruct import ArgStruct
+from .........Internal.Core import Core
+from .........Internal.CommandsGroup import CommandsGroup
+from .........Internal.StructBase import StructBase
+from .........Internal.ArgStruct import ArgStruct
+from ......... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 2 total commands, 1 Sub-groups, 1 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 2 total commands, 1 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	@property
 	def rbIndex(self):
 		"""rbIndex commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_rbIndex'):
-			from .Current_.RbIndex import RbIndex
-			self._rbIndex = RbIndex(self._core, self._base)
+			from .RbIndex import RbIndexCls
+			self._rbIndex = RbIndexCls(self._core, self._cmd_group)
 		return self._rbIndex
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
 			- Reliability: int: No parameter help available
+			- Seg_Reliability: int: No parameter help available
+			- Statist_Expired: int: No parameter help available
 			- Out_Of_Tolerance: int: No parameter help available
 			- Margin: float: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
+			ArgStruct.scalar_int('Seg_Reliability'),
+			ArgStruct.scalar_int('Statist_Expired'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
 			ArgStruct.scalar_float('Margin')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
+			self.Seg_Reliability: int = None
+			self.Statist_Expired: int = None
 			self.Out_Of_Tolerance: int = None
 			self.Margin: float = None
 
-	def fetch(self) -> FetchStruct:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:IEMission:SCC:MARGin:CURRent \n
-		Snippet: value: FetchStruct = driver.multiEval.inbandEmission.scc.margin.current.fetch() \n
+	def fetch(self, segment=repcap.Segment.Default) -> FetchStruct:
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:IEMission:MARGin:CURRent \n
+		Snippet: value: FetchStruct = driver.lteMeas.multiEval.listPy.segment.inbandEmission.margin.current.fetch(segment = repcap.Segment.Default) \n
 		No command help available \n
+			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:IEMission:SCC:MARGin:CURRent?', self.__class__.FetchStruct())
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:IEMission:MARGin:CURRent?', self.__class__.FetchStruct())
 
-	def clone(self) -> 'Current':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'CurrentCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Current(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = CurrentCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/InbandEmission_/Scc_/Margin_/Current_/RbIndex.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/InbandEmission/Pcc/Margin/Current/RbIndex.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,20 +1,20 @@
-from .......Internal.Core import Core
-from .......Internal.CommandsGroup import CommandsGroup
-from .......Internal.StructBase import StructBase
-from .......Internal.ArgStruct import ArgStruct
+from ........Internal.Core import Core
+from ........Internal.CommandsGroup import CommandsGroup
+from ........Internal.StructBase import StructBase
+from ........Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class RbIndex:
-	"""RbIndex commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class RbIndexCls:
+	"""RbIndex commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("rbIndex", core, parent)
+		self._cmd_group = CommandsGroup("rbIndex", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
 			- Reliability: int: No parameter help available
 			- Out_Of_Tolerance: int: No parameter help available
 			- Rb_Index: int: No parameter help available"""
@@ -26,12 +26,12 @@
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tolerance: int = None
 			self.Rb_Index: int = None
 
 	def fetch(self) -> FetchStruct:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:IEMission:SCC:MARGin:CURRent:RBINdex \n
-		Snippet: value: FetchStruct = driver.multiEval.inbandEmission.scc.margin.current.rbIndex.fetch() \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:IEMission[:PCC]:MARGin:CURRent:RBINdex \n
+		Snippet: value: FetchStruct = driver.lteMeas.multiEval.inbandEmission.pcc.margin.current.rbIndex.fetch() \n
 		No command help available \n
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:IEMission:SCC:MARGin:CURRent:RBINdex?', self.__class__.FetchStruct())
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:IEMission:PCC:MARGin:CURRent:RBINdex?', self.__class__.FetchStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/InbandEmission_/Scc_/Margin_/Extreme.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/InbandEmission/Ulca/Pcc/Margin/Current/__init__.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,27 +1,27 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.StructBase import StructBase
-from ......Internal.ArgStruct import ArgStruct
+from .........Internal.Core import Core
+from .........Internal.CommandsGroup import CommandsGroup
+from .........Internal.StructBase import StructBase
+from .........Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Extreme:
-	"""Extreme commands group definition. 2 total commands, 1 Sub-groups, 1 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 2 total commands, 1 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("extreme", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	@property
 	def rbIndex(self):
 		"""rbIndex commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_rbIndex'):
-			from .Extreme_.RbIndex import RbIndex
-			self._rbIndex = RbIndex(self._core, self._base)
+			from .RbIndex import RbIndexCls
+			self._rbIndex = RbIndexCls(self._core, self._cmd_group)
 		return self._rbIndex
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
 			- Reliability: int: No parameter help available
 			- Out_Of_Tolerance: int: No parameter help available
@@ -34,20 +34,20 @@
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tolerance: int = None
 			self.Margin: float = None
 
 	def fetch(self) -> FetchStruct:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:IEMission:SCC:MARGin:EXTReme \n
-		Snippet: value: FetchStruct = driver.multiEval.inbandEmission.scc.margin.extreme.fetch() \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:IEMission:ULCA[:PCC]:MARGin:CURRent \n
+		Snippet: value: FetchStruct = driver.lteMeas.multiEval.inbandEmission.ulca.pcc.margin.current.fetch() \n
 		No command help available \n
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:IEMission:SCC:MARGin:EXTReme?', self.__class__.FetchStruct())
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:IEMission:ULCA:PCC:MARGin:CURRent?', self.__class__.FetchStruct())
 
-	def clone(self) -> 'Extreme':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'CurrentCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Extreme(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = CurrentCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/InbandEmission_/Scc_/Margin_/Extreme_/RbIndex.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/InbandEmission/Pcc/Margin/Extreme/RbIndex.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,20 +1,20 @@
-from .......Internal.Core import Core
-from .......Internal.CommandsGroup import CommandsGroup
-from .......Internal.StructBase import StructBase
-from .......Internal.ArgStruct import ArgStruct
+from ........Internal.Core import Core
+from ........Internal.CommandsGroup import CommandsGroup
+from ........Internal.StructBase import StructBase
+from ........Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class RbIndex:
-	"""RbIndex commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class RbIndexCls:
+	"""RbIndex commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("rbIndex", core, parent)
+		self._cmd_group = CommandsGroup("rbIndex", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
 			- Reliability: int: No parameter help available
 			- Out_Of_Tolerance: int: No parameter help available
 			- Rb_Index: int: No parameter help available"""
@@ -26,12 +26,12 @@
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tolerance: int = None
 			self.Rb_Index: int = None
 
 	def fetch(self) -> FetchStruct:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:IEMission:SCC:MARGin:EXTReme:RBINdex \n
-		Snippet: value: FetchStruct = driver.multiEval.inbandEmission.scc.margin.extreme.rbIndex.fetch() \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:IEMission[:PCC]:MARGin:EXTReme:RBINdex \n
+		Snippet: value: FetchStruct = driver.lteMeas.multiEval.inbandEmission.pcc.margin.extreme.rbIndex.fetch() \n
 		No command help available \n
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:IEMission:SCC:MARGin:EXTReme:RBINdex?', self.__class__.FetchStruct())
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:IEMission:PCC:MARGin:EXTReme:RBINdex?', self.__class__.FetchStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/InbandEmission_/Scc_/Margin_/StandardDev.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/InbandEmission/Scc/Margin/StandardDev.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,20 +1,20 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.StructBase import StructBase
-from ......Internal.ArgStruct import ArgStruct
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal.StructBase import StructBase
+from .......Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class StandardDev:
-	"""StandardDev commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class StandardDevCls:
+	"""StandardDev commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("standardDev", core, parent)
+		self._cmd_group = CommandsGroup("standardDev", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
 			- Reliability: int: No parameter help available
 			- Out_Of_Tolerance: int: No parameter help available
 			- Margin: float: No parameter help available"""
@@ -27,11 +27,11 @@
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tolerance: int = None
 			self.Margin: float = None
 
 	def fetch(self) -> FetchStruct:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:IEMission:SCC:MARGin:SDEViation \n
-		Snippet: value: FetchStruct = driver.multiEval.inbandEmission.scc.margin.standardDev.fetch() \n
+		Snippet: value: FetchStruct = driver.lteMeas.multiEval.inbandEmission.scc.margin.standardDev.fetch() \n
 		No command help available \n
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
 		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:IEMission:SCC:MARGin:SDEViation?', self.__class__.FetchStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/InbandEmission_/Ulca.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Evm/Peak/__init__.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,35 +1,35 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
+from ........Internal.Core import Core
+from ........Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Ulca:
-	"""Ulca commands group definition. 12 total commands, 2 Sub-groups, 0 group commands"""
+class PeakCls:
+	"""Peak commands group definition. 14 total commands, 2 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("ulca", core, parent)
+		self._cmd_group = CommandsGroup("peak", core, parent)
 
 	@property
-	def scc(self):
-		"""scc commands group. 1 Sub-classes, 0 commands."""
-		if not hasattr(self, '_scc'):
-			from .Ulca_.Scc import Scc
-			self._scc = Scc(self._core, self._base)
-		return self._scc
+	def low(self):
+		"""low commands group. 4 Sub-classes, 0 commands."""
+		if not hasattr(self, '_low'):
+			from .Low import LowCls
+			self._low = LowCls(self._core, self._cmd_group)
+		return self._low
 
 	@property
-	def pcc(self):
-		"""pcc commands group. 1 Sub-classes, 0 commands."""
-		if not hasattr(self, '_pcc'):
-			from .Ulca_.Pcc import Pcc
-			self._pcc = Pcc(self._core, self._base)
-		return self._pcc
+	def high(self):
+		"""high commands group. 4 Sub-classes, 0 commands."""
+		if not hasattr(self, '_high'):
+			from .High import HighCls
+			self._high = HighCls(self._core, self._cmd_group)
+		return self._high
 
-	def clone(self) -> 'Ulca':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'PeakCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Ulca(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = PeakCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/InbandEmission_/Ulca_/Pcc.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/InbandEmission/Ulca/Pcc/__init__.py`

 * *Files 21% similar despite different names*

```diff
@@ -1,27 +1,27 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Pcc:
-	"""Pcc commands group definition. 6 total commands, 1 Sub-groups, 0 group commands"""
+class PccCls:
+	"""Pcc commands group definition. 6 total commands, 1 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("pcc", core, parent)
+		self._cmd_group = CommandsGroup("pcc", core, parent)
 
 	@property
 	def margin(self):
 		"""margin commands group. 4 Sub-classes, 0 commands."""
 		if not hasattr(self, '_margin'):
-			from .Pcc_.Margin import Margin
-			self._margin = Margin(self._core, self._base)
+			from .Margin import MarginCls
+			self._margin = MarginCls(self._core, self._cmd_group)
 		return self._margin
 
-	def clone(self) -> 'Pcc':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'PccCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Pcc(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = PccCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/InbandEmission_/Ulca_/Pcc_/Margin.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/InbandEmission/Scc/Margin/__init__.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,51 +1,51 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Margin:
-	"""Margin commands group definition. 6 total commands, 4 Sub-groups, 0 group commands"""
+class MarginCls:
+	"""Margin commands group definition. 6 total commands, 4 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("margin", core, parent)
+		self._cmd_group = CommandsGroup("margin", core, parent)
 
 	@property
 	def current(self):
 		"""current commands group. 1 Sub-classes, 1 commands."""
 		if not hasattr(self, '_current'):
-			from .Margin_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
 	@property
 	def average(self):
 		"""average commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_average'):
-			from .Margin_.Average import Average
-			self._average = Average(self._core, self._base)
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
 		return self._average
 
 	@property
 	def extreme(self):
 		"""extreme commands group. 1 Sub-classes, 1 commands."""
 		if not hasattr(self, '_extreme'):
-			from .Margin_.Extreme import Extreme
-			self._extreme = Extreme(self._core, self._base)
+			from .Extreme import ExtremeCls
+			self._extreme = ExtremeCls(self._core, self._cmd_group)
 		return self._extreme
 
 	@property
 	def standardDev(self):
 		"""standardDev commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_standardDev'):
-			from .Margin_.StandardDev import StandardDev
-			self._standardDev = StandardDev(self._core, self._base)
+			from .StandardDev import StandardDevCls
+			self._standardDev = StandardDevCls(self._core, self._cmd_group)
 		return self._standardDev
 
-	def clone(self) -> 'Margin':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'MarginCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Margin(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = MarginCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/InbandEmission_/Ulca_/Pcc_/Margin_/Average.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/InbandEmission/Scc/Margin/Average.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,20 +1,20 @@
 from .......Internal.Core import Core
 from .......Internal.CommandsGroup import CommandsGroup
 from .......Internal.StructBase import StructBase
 from .......Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class AverageCls:
+	"""Average commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
 			- Reliability: int: No parameter help available
 			- Out_Of_Tolerance: int: No parameter help available
 			- Margin: float: No parameter help available"""
@@ -26,12 +26,12 @@
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tolerance: int = None
 			self.Margin: float = None
 
 	def fetch(self) -> FetchStruct:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:IEMission:ULCA[:PCC]:MARGin:AVERage \n
-		Snippet: value: FetchStruct = driver.multiEval.inbandEmission.ulca.pcc.margin.average.fetch() \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:IEMission:SCC:MARGin:AVERage \n
+		Snippet: value: FetchStruct = driver.lteMeas.multiEval.inbandEmission.scc.margin.average.fetch() \n
 		No command help available \n
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:IEMission:ULCA:PCC:MARGin:AVERage?', self.__class__.FetchStruct())
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:IEMission:SCC:MARGin:AVERage?', self.__class__.FetchStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/InbandEmission_/Ulca_/Pcc_/Margin_/Current.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/InbandEmission/Ulca/Pcc/Margin/Average.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,28 +1,20 @@
-from .......Internal.Core import Core
-from .......Internal.CommandsGroup import CommandsGroup
-from .......Internal.StructBase import StructBase
-from .......Internal.ArgStruct import ArgStruct
+from ........Internal.Core import Core
+from ........Internal.CommandsGroup import CommandsGroup
+from ........Internal.StructBase import StructBase
+from ........Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 2 total commands, 1 Sub-groups, 1 group commands"""
+class AverageCls:
+	"""Average commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
-
-	@property
-	def rbIndex(self):
-		"""rbIndex commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_rbIndex'):
-			from .Current_.RbIndex import RbIndex
-			self._rbIndex = RbIndex(self._core, self._base)
-		return self._rbIndex
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
 			- Reliability: int: No parameter help available
 			- Out_Of_Tolerance: int: No parameter help available
 			- Margin: float: No parameter help available"""
@@ -34,20 +26,12 @@
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tolerance: int = None
 			self.Margin: float = None
 
 	def fetch(self) -> FetchStruct:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:IEMission:ULCA[:PCC]:MARGin:CURRent \n
-		Snippet: value: FetchStruct = driver.multiEval.inbandEmission.ulca.pcc.margin.current.fetch() \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:IEMission:ULCA[:PCC]:MARGin:AVERage \n
+		Snippet: value: FetchStruct = driver.lteMeas.multiEval.inbandEmission.ulca.pcc.margin.average.fetch() \n
 		No command help available \n
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:IEMission:ULCA:PCC:MARGin:CURRent?', self.__class__.FetchStruct())
-
-	def clone(self) -> 'Current':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
-		Also copies all the existing default Repeated Capabilities setting,
-		which you can change independently without affecting the original group"""
-		new_group = Current(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
-		return new_group
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:IEMission:ULCA:PCC:MARGin:AVERage?', self.__class__.FetchStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/InbandEmission_/Ulca_/Pcc_/Margin_/Current_/RbIndex.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/InbandEmission/Ulca/Pcc/Margin/Extreme/RbIndex.py`

 * *Files 11% similar despite different names*

```diff
@@ -1,20 +1,20 @@
-from ........Internal.Core import Core
-from ........Internal.CommandsGroup import CommandsGroup
-from ........Internal.StructBase import StructBase
-from ........Internal.ArgStruct import ArgStruct
+from .........Internal.Core import Core
+from .........Internal.CommandsGroup import CommandsGroup
+from .........Internal.StructBase import StructBase
+from .........Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class RbIndex:
-	"""RbIndex commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class RbIndexCls:
+	"""RbIndex commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("rbIndex", core, parent)
+		self._cmd_group = CommandsGroup("rbIndex", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
 			- Reliability: int: No parameter help available
 			- Out_Of_Tolerance: int: No parameter help available
 			- Rb_Index: int: No parameter help available"""
@@ -26,12 +26,12 @@
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tolerance: int = None
 			self.Rb_Index: int = None
 
 	def fetch(self) -> FetchStruct:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:IEMission:ULCA[:PCC]:MARGin:CURRent:RBINdex \n
-		Snippet: value: FetchStruct = driver.multiEval.inbandEmission.ulca.pcc.margin.current.rbIndex.fetch() \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:IEMission:ULCA[:PCC]:MARGin:EXTReme:RBINdex \n
+		Snippet: value: FetchStruct = driver.lteMeas.multiEval.inbandEmission.ulca.pcc.margin.extreme.rbIndex.fetch() \n
 		No command help available \n
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:IEMission:ULCA:PCC:MARGin:CURRent:RBINdex?', self.__class__.FetchStruct())
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:IEMission:ULCA:PCC:MARGin:EXTReme:RBINdex?', self.__class__.FetchStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/InbandEmission_/Ulca_/Pcc_/Margin_/Extreme.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/InbandEmission/Ulca/Scc/Margin/Extreme/__init__.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,27 +1,28 @@
-from .......Internal.Core import Core
-from .......Internal.CommandsGroup import CommandsGroup
-from .......Internal.StructBase import StructBase
-from .......Internal.ArgStruct import ArgStruct
+from .........Internal.Core import Core
+from .........Internal.CommandsGroup import CommandsGroup
+from .........Internal.StructBase import StructBase
+from .........Internal.ArgStruct import ArgStruct
+from ......... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Extreme:
-	"""Extreme commands group definition. 2 total commands, 1 Sub-groups, 1 group commands"""
+class ExtremeCls:
+	"""Extreme commands group definition. 2 total commands, 1 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("extreme", core, parent)
+		self._cmd_group = CommandsGroup("extreme", core, parent)
 
 	@property
 	def rbIndex(self):
 		"""rbIndex commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_rbIndex'):
-			from .Extreme_.RbIndex import RbIndex
-			self._rbIndex = RbIndex(self._core, self._base)
+			from .RbIndex import RbIndexCls
+			self._rbIndex = RbIndexCls(self._core, self._cmd_group)
 		return self._rbIndex
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
 			- Reliability: int: No parameter help available
 			- Out_Of_Tolerance: int: No parameter help available
@@ -33,21 +34,23 @@
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tolerance: int = None
 			self.Margin: float = None
 
-	def fetch(self) -> FetchStruct:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:IEMission:ULCA[:PCC]:MARGin:EXTReme \n
-		Snippet: value: FetchStruct = driver.multiEval.inbandEmission.ulca.pcc.margin.extreme.fetch() \n
+	def fetch(self, secondaryCC=repcap.SecondaryCC.Default) -> FetchStruct:
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:IEMission:ULCA:SCC<Nr>:MARGin:EXTReme \n
+		Snippet: value: FetchStruct = driver.lteMeas.multiEval.inbandEmission.ulca.scc.margin.extreme.fetch(secondaryCC = repcap.SecondaryCC.Default) \n
 		No command help available \n
+			:param secondaryCC: optional repeated capability selector. Default value: CC1 (settable in the interface 'Scc')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:IEMission:ULCA:PCC:MARGin:EXTReme?', self.__class__.FetchStruct())
+		secondaryCC_cmd_val = self._cmd_group.get_repcap_cmd_value(secondaryCC, repcap.SecondaryCC)
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:IEMission:ULCA:SCC{secondaryCC_cmd_val}:MARGin:EXTReme?', self.__class__.FetchStruct())
 
-	def clone(self) -> 'Extreme':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'ExtremeCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Extreme(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = ExtremeCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/InbandEmission_/Ulca_/Pcc_/Margin_/Extreme_/RbIndex.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/InbandEmission/Ulca/Scc/Margin/Extreme/RbIndex.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,20 +1,21 @@
-from ........Internal.Core import Core
-from ........Internal.CommandsGroup import CommandsGroup
-from ........Internal.StructBase import StructBase
-from ........Internal.ArgStruct import ArgStruct
+from .........Internal.Core import Core
+from .........Internal.CommandsGroup import CommandsGroup
+from .........Internal.StructBase import StructBase
+from .........Internal.ArgStruct import ArgStruct
+from ......... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class RbIndex:
-	"""RbIndex commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class RbIndexCls:
+	"""RbIndex commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("rbIndex", core, parent)
+		self._cmd_group = CommandsGroup("rbIndex", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
 			- Reliability: int: No parameter help available
 			- Out_Of_Tolerance: int: No parameter help available
 			- Rb_Index: int: No parameter help available"""
@@ -25,13 +26,15 @@
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tolerance: int = None
 			self.Rb_Index: int = None
 
-	def fetch(self) -> FetchStruct:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:IEMission:ULCA[:PCC]:MARGin:EXTReme:RBINdex \n
-		Snippet: value: FetchStruct = driver.multiEval.inbandEmission.ulca.pcc.margin.extreme.rbIndex.fetch() \n
+	def fetch(self, secondaryCC=repcap.SecondaryCC.Default) -> FetchStruct:
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:IEMission:ULCA:SCC<Nr>:MARGin:EXTReme:RBINdex \n
+		Snippet: value: FetchStruct = driver.lteMeas.multiEval.inbandEmission.ulca.scc.margin.extreme.rbIndex.fetch(secondaryCC = repcap.SecondaryCC.Default) \n
 		No command help available \n
+			:param secondaryCC: optional repeated capability selector. Default value: CC1 (settable in the interface 'Scc')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:IEMission:ULCA:PCC:MARGin:EXTReme:RBINdex?', self.__class__.FetchStruct())
+		secondaryCC_cmd_val = self._cmd_group.get_repcap_cmd_value(secondaryCC, repcap.SecondaryCC)
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:IEMission:ULCA:SCC{secondaryCC_cmd_val}:MARGin:EXTReme:RBINdex?', self.__class__.FetchStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/InbandEmission_/Ulca_/Pcc_/Margin_/StandardDev.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/InbandEmission/Margin/Average.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,37 +1,46 @@
-from .......Internal.Core import Core
-from .......Internal.CommandsGroup import CommandsGroup
-from .......Internal.StructBase import StructBase
-from .......Internal.ArgStruct import ArgStruct
+from ........Internal.Core import Core
+from ........Internal.CommandsGroup import CommandsGroup
+from ........Internal.StructBase import StructBase
+from ........Internal.ArgStruct import ArgStruct
+from ........ import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class StandardDev:
-	"""StandardDev commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class AverageCls:
+	"""Average commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("standardDev", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
 			- Reliability: int: No parameter help available
+			- Seg_Reliability: int: No parameter help available
+			- Statist_Expired: int: No parameter help available
 			- Out_Of_Tolerance: int: No parameter help available
 			- Margin: float: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
+			ArgStruct.scalar_int('Seg_Reliability'),
+			ArgStruct.scalar_int('Statist_Expired'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
 			ArgStruct.scalar_float('Margin')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
+			self.Seg_Reliability: int = None
+			self.Statist_Expired: int = None
 			self.Out_Of_Tolerance: int = None
 			self.Margin: float = None
 
-	def fetch(self) -> FetchStruct:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:IEMission:ULCA[:PCC]:MARGin:SDEViation \n
-		Snippet: value: FetchStruct = driver.multiEval.inbandEmission.ulca.pcc.margin.standardDev.fetch() \n
+	def fetch(self, segment=repcap.Segment.Default) -> FetchStruct:
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:IEMission:MARGin:AVERage \n
+		Snippet: value: FetchStruct = driver.lteMeas.multiEval.listPy.segment.inbandEmission.margin.average.fetch(segment = repcap.Segment.Default) \n
 		No command help available \n
+			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:IEMission:ULCA:PCC:MARGin:SDEViation?', self.__class__.FetchStruct())
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:IEMission:MARGin:AVERage?', self.__class__.FetchStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/InbandEmission_/Ulca_/Scc.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/InbandEmission/Scc/__init__.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,42 +1,42 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
-from .....Internal.RepeatedCapability import RepeatedCapability
-from ..... import repcap
+from ........Internal.Core import Core
+from ........Internal.CommandsGroup import CommandsGroup
+from ........Internal.RepeatedCapability import RepeatedCapability
+from ........ import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Scc:
-	"""Scc commands group definition. 6 total commands, 1 Sub-groups, 0 group commands
+class SccCls:
+	"""Scc commands group definition. 6 total commands, 1 Subgroups, 0 group commands
 	Repeated Capability: SecondaryCC, default value after init: SecondaryCC.CC1"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("scc", core, parent)
-		self._base.rep_cap = RepeatedCapability(self._base.group_name, 'repcap_secondaryCC_get', 'repcap_secondaryCC_set', repcap.SecondaryCC.CC1)
+		self._cmd_group = CommandsGroup("scc", core, parent)
+		self._cmd_group.rep_cap = RepeatedCapability(self._cmd_group.group_name, 'repcap_secondaryCC_get', 'repcap_secondaryCC_set', repcap.SecondaryCC.CC1)
 
-	def repcap_secondaryCC_set(self, enum_value: repcap.SecondaryCC) -> None:
+	def repcap_secondaryCC_set(self, secondaryCC: repcap.SecondaryCC) -> None:
 		"""Repeated Capability default value numeric suffix.
 		This value is used, if you do not explicitely set it in the child set/get methods, or if you leave it to SecondaryCC.Default
 		Default value after init: SecondaryCC.CC1"""
-		self._base.set_repcap_enum_value(enum_value)
+		self._cmd_group.set_repcap_enum_value(secondaryCC)
 
 	def repcap_secondaryCC_get(self) -> repcap.SecondaryCC:
 		"""Returns the current default repeated capability for the child set/get methods"""
 		# noinspection PyTypeChecker
-		return self._base.get_repcap_enum_value()
+		return self._cmd_group.get_repcap_enum_value()
 
 	@property
 	def margin(self):
 		"""margin commands group. 4 Sub-classes, 0 commands."""
 		if not hasattr(self, '_margin'):
-			from .Scc_.Margin import Margin
-			self._margin = Margin(self._core, self._base)
+			from .Margin import MarginCls
+			self._margin = MarginCls(self._core, self._cmd_group)
 		return self._margin
 
-	def clone(self) -> 'Scc':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'SccCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Scc(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = SccCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/InbandEmission_/Ulca_/Scc_/Margin.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/InbandEmission/Ulca/Pcc/Margin/__init__.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,51 +1,51 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
+from ........Internal.Core import Core
+from ........Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Margin:
-	"""Margin commands group definition. 6 total commands, 4 Sub-groups, 0 group commands"""
+class MarginCls:
+	"""Margin commands group definition. 6 total commands, 4 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("margin", core, parent)
+		self._cmd_group = CommandsGroup("margin", core, parent)
 
 	@property
 	def current(self):
 		"""current commands group. 1 Sub-classes, 1 commands."""
 		if not hasattr(self, '_current'):
-			from .Margin_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
 	@property
 	def average(self):
 		"""average commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_average'):
-			from .Margin_.Average import Average
-			self._average = Average(self._core, self._base)
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
 		return self._average
 
 	@property
 	def extreme(self):
 		"""extreme commands group. 1 Sub-classes, 1 commands."""
 		if not hasattr(self, '_extreme'):
-			from .Margin_.Extreme import Extreme
-			self._extreme = Extreme(self._core, self._base)
+			from .Extreme import ExtremeCls
+			self._extreme = ExtremeCls(self._core, self._cmd_group)
 		return self._extreme
 
 	@property
 	def standardDev(self):
 		"""standardDev commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_standardDev'):
-			from .Margin_.StandardDev import StandardDev
-			self._standardDev = StandardDev(self._core, self._base)
+			from .StandardDev import StandardDevCls
+			self._standardDev = StandardDevCls(self._core, self._cmd_group)
 		return self._standardDev
 
-	def clone(self) -> 'Margin':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'MarginCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Margin(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = MarginCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/InbandEmission_/Ulca_/Scc_/Margin_/Average.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/InbandEmission/Ulca/Scc/Margin/StandardDev.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,21 +1,21 @@
-from .......Internal.Core import Core
-from .......Internal.CommandsGroup import CommandsGroup
-from .......Internal.StructBase import StructBase
-from .......Internal.ArgStruct import ArgStruct
-from ....... import repcap
+from ........Internal.Core import Core
+from ........Internal.CommandsGroup import CommandsGroup
+from ........Internal.StructBase import StructBase
+from ........Internal.ArgStruct import ArgStruct
+from ........ import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class StandardDevCls:
+	"""StandardDev commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("standardDev", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
 			- Reliability: int: No parameter help available
 			- Out_Of_Tolerance: int: No parameter help available
 			- Margin: float: No parameter help available"""
@@ -27,14 +27,14 @@
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tolerance: int = None
 			self.Margin: float = None
 
 	def fetch(self, secondaryCC=repcap.SecondaryCC.Default) -> FetchStruct:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:IEMission:ULCA:SCC<Nr>:MARGin:AVERage \n
-		Snippet: value: FetchStruct = driver.multiEval.inbandEmission.ulca.scc.margin.average.fetch(secondaryCC = repcap.SecondaryCC.Default) \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:IEMission:ULCA:SCC<Nr>:MARGin:SDEViation \n
+		Snippet: value: FetchStruct = driver.lteMeas.multiEval.inbandEmission.ulca.scc.margin.standardDev.fetch(secondaryCC = repcap.SecondaryCC.Default) \n
 		No command help available \n
 			:param secondaryCC: optional repeated capability selector. Default value: CC1 (settable in the interface 'Scc')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		secondaryCC_cmd_val = self._base.get_repcap_cmd_value(secondaryCC, repcap.SecondaryCC)
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:IEMission:ULCA:SCC{secondaryCC_cmd_val}:MARGin:AVERage?', self.__class__.FetchStruct())
+		secondaryCC_cmd_val = self._cmd_group.get_repcap_cmd_value(secondaryCC, repcap.SecondaryCC)
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:IEMission:ULCA:SCC{secondaryCC_cmd_val}:MARGin:SDEViation?', self.__class__.FetchStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/InbandEmission_/Ulca_/Scc_/Margin_/Current.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/InbandEmission/Ulca/Scc/Margin/Current/__init__.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,28 +1,28 @@
-from .......Internal.Core import Core
-from .......Internal.CommandsGroup import CommandsGroup
-from .......Internal.StructBase import StructBase
-from .......Internal.ArgStruct import ArgStruct
-from ....... import repcap
+from .........Internal.Core import Core
+from .........Internal.CommandsGroup import CommandsGroup
+from .........Internal.StructBase import StructBase
+from .........Internal.ArgStruct import ArgStruct
+from ......... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 2 total commands, 1 Sub-groups, 1 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 2 total commands, 1 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	@property
 	def rbIndex(self):
 		"""rbIndex commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_rbIndex'):
-			from .Current_.RbIndex import RbIndex
-			self._rbIndex = RbIndex(self._core, self._base)
+			from .RbIndex import RbIndexCls
+			self._rbIndex = RbIndexCls(self._core, self._cmd_group)
 		return self._rbIndex
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
 			- Reliability: int: No parameter help available
 			- Out_Of_Tolerance: int: No parameter help available
@@ -36,21 +36,21 @@
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tolerance: int = None
 			self.Margin: float = None
 
 	def fetch(self, secondaryCC=repcap.SecondaryCC.Default) -> FetchStruct:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:IEMission:ULCA:SCC<Nr>:MARGin:CURRent \n
-		Snippet: value: FetchStruct = driver.multiEval.inbandEmission.ulca.scc.margin.current.fetch(secondaryCC = repcap.SecondaryCC.Default) \n
+		Snippet: value: FetchStruct = driver.lteMeas.multiEval.inbandEmission.ulca.scc.margin.current.fetch(secondaryCC = repcap.SecondaryCC.Default) \n
 		No command help available \n
 			:param secondaryCC: optional repeated capability selector. Default value: CC1 (settable in the interface 'Scc')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		secondaryCC_cmd_val = self._base.get_repcap_cmd_value(secondaryCC, repcap.SecondaryCC)
+		secondaryCC_cmd_val = self._cmd_group.get_repcap_cmd_value(secondaryCC, repcap.SecondaryCC)
 		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:IEMission:ULCA:SCC{secondaryCC_cmd_val}:MARGin:CURRent?', self.__class__.FetchStruct())
 
-	def clone(self) -> 'Current':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'CurrentCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Current(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = CurrentCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/InbandEmission_/Ulca_/Scc_/Margin_/Current_/RbIndex.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/InbandEmission/Ulca/Scc/Margin/Current/RbIndex.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,21 +1,21 @@
-from ........Internal.Core import Core
-from ........Internal.CommandsGroup import CommandsGroup
-from ........Internal.StructBase import StructBase
-from ........Internal.ArgStruct import ArgStruct
-from ........ import repcap
+from .........Internal.Core import Core
+from .........Internal.CommandsGroup import CommandsGroup
+from .........Internal.StructBase import StructBase
+from .........Internal.ArgStruct import ArgStruct
+from ......... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class RbIndex:
-	"""RbIndex commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class RbIndexCls:
+	"""RbIndex commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("rbIndex", core, parent)
+		self._cmd_group = CommandsGroup("rbIndex", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
 			- Reliability: int: No parameter help available
 			- Out_Of_Tolerance: int: No parameter help available
 			- Rb_Index: int: No parameter help available"""
@@ -28,13 +28,13 @@
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tolerance: int = None
 			self.Rb_Index: int = None
 
 	def fetch(self, secondaryCC=repcap.SecondaryCC.Default) -> FetchStruct:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:IEMission:ULCA:SCC<Nr>:MARGin:CURRent:RBINdex \n
-		Snippet: value: FetchStruct = driver.multiEval.inbandEmission.ulca.scc.margin.current.rbIndex.fetch(secondaryCC = repcap.SecondaryCC.Default) \n
+		Snippet: value: FetchStruct = driver.lteMeas.multiEval.inbandEmission.ulca.scc.margin.current.rbIndex.fetch(secondaryCC = repcap.SecondaryCC.Default) \n
 		No command help available \n
 			:param secondaryCC: optional repeated capability selector. Default value: CC1 (settable in the interface 'Scc')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		secondaryCC_cmd_val = self._base.get_repcap_cmd_value(secondaryCC, repcap.SecondaryCC)
+		secondaryCC_cmd_val = self._cmd_group.get_repcap_cmd_value(secondaryCC, repcap.SecondaryCC)
 		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:IEMission:ULCA:SCC{secondaryCC_cmd_val}:MARGin:CURRent:RBINdex?', self.__class__.FetchStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/InbandEmission_/Ulca_/Scc_/Margin_/Extreme.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/InbandEmission/Scc/Margin/Extreme/__init__.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,56 +1,64 @@
-from .......Internal.Core import Core
-from .......Internal.CommandsGroup import CommandsGroup
-from .......Internal.StructBase import StructBase
-from .......Internal.ArgStruct import ArgStruct
-from ....... import repcap
+from ..........Internal.Core import Core
+from ..........Internal.CommandsGroup import CommandsGroup
+from ..........Internal.StructBase import StructBase
+from ..........Internal.ArgStruct import ArgStruct
+from .......... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Extreme:
-	"""Extreme commands group definition. 2 total commands, 1 Sub-groups, 1 group commands"""
+class ExtremeCls:
+	"""Extreme commands group definition. 2 total commands, 1 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("extreme", core, parent)
+		self._cmd_group = CommandsGroup("extreme", core, parent)
 
 	@property
 	def rbIndex(self):
 		"""rbIndex commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_rbIndex'):
-			from .Extreme_.RbIndex import RbIndex
-			self._rbIndex = RbIndex(self._core, self._base)
+			from .RbIndex import RbIndexCls
+			self._rbIndex = RbIndexCls(self._core, self._cmd_group)
 		return self._rbIndex
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
 			- Reliability: int: No parameter help available
+			- Seg_Reliability: int: No parameter help available
+			- Statist_Expired: int: No parameter help available
 			- Out_Of_Tolerance: int: No parameter help available
 			- Margin: float: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
+			ArgStruct.scalar_int('Seg_Reliability'),
+			ArgStruct.scalar_int('Statist_Expired'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
 			ArgStruct.scalar_float('Margin')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
+			self.Seg_Reliability: int = None
+			self.Statist_Expired: int = None
 			self.Out_Of_Tolerance: int = None
 			self.Margin: float = None
 
-	def fetch(self, secondaryCC=repcap.SecondaryCC.Default) -> FetchStruct:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:IEMission:ULCA:SCC<Nr>:MARGin:EXTReme \n
-		Snippet: value: FetchStruct = driver.multiEval.inbandEmission.ulca.scc.margin.extreme.fetch(secondaryCC = repcap.SecondaryCC.Default) \n
+	def fetch(self, segment=repcap.Segment.Default, secondaryCC=repcap.SecondaryCC.Default) -> FetchStruct:
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:IEMission:SCC<c>:MARGin:EXTReme \n
+		Snippet: value: FetchStruct = driver.lteMeas.multiEval.listPy.segment.inbandEmission.scc.margin.extreme.fetch(segment = repcap.Segment.Default, secondaryCC = repcap.SecondaryCC.Default) \n
 		No command help available \n
+			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
 			:param secondaryCC: optional repeated capability selector. Default value: CC1 (settable in the interface 'Scc')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		secondaryCC_cmd_val = self._base.get_repcap_cmd_value(secondaryCC, repcap.SecondaryCC)
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:IEMission:ULCA:SCC{secondaryCC_cmd_val}:MARGin:EXTReme?', self.__class__.FetchStruct())
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
+		secondaryCC_cmd_val = self._cmd_group.get_repcap_cmd_value(secondaryCC, repcap.SecondaryCC)
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:IEMission:SCC{secondaryCC_cmd_val}:MARGin:EXTReme?', self.__class__.FetchStruct())
 
-	def clone(self) -> 'Extreme':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'ExtremeCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Extreme(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = ExtremeCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/InbandEmission_/Ulca_/Scc_/Margin_/Extreme_/RbIndex.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/InbandEmission/Scc/Margin/Average.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,40 +1,48 @@
-from ........Internal.Core import Core
-from ........Internal.CommandsGroup import CommandsGroup
-from ........Internal.StructBase import StructBase
-from ........Internal.ArgStruct import ArgStruct
-from ........ import repcap
+from .........Internal.Core import Core
+from .........Internal.CommandsGroup import CommandsGroup
+from .........Internal.StructBase import StructBase
+from .........Internal.ArgStruct import ArgStruct
+from ......... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class RbIndex:
-	"""RbIndex commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class AverageCls:
+	"""Average commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("rbIndex", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
 			- Reliability: int: No parameter help available
+			- Seg_Reliability: int: No parameter help available
+			- Statist_Expired: int: No parameter help available
 			- Out_Of_Tolerance: int: No parameter help available
-			- Rb_Index: int: No parameter help available"""
+			- Margin: float: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
+			ArgStruct.scalar_int('Seg_Reliability'),
+			ArgStruct.scalar_int('Statist_Expired'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
-			ArgStruct.scalar_int('Rb_Index')]
+			ArgStruct.scalar_float('Margin')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
+			self.Seg_Reliability: int = None
+			self.Statist_Expired: int = None
 			self.Out_Of_Tolerance: int = None
-			self.Rb_Index: int = None
+			self.Margin: float = None
 
-	def fetch(self, secondaryCC=repcap.SecondaryCC.Default) -> FetchStruct:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:IEMission:ULCA:SCC<Nr>:MARGin:EXTReme:RBINdex \n
-		Snippet: value: FetchStruct = driver.multiEval.inbandEmission.ulca.scc.margin.extreme.rbIndex.fetch(secondaryCC = repcap.SecondaryCC.Default) \n
+	def fetch(self, segment=repcap.Segment.Default, secondaryCC=repcap.SecondaryCC.Default) -> FetchStruct:
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:IEMission:SCC<c>:MARGin:AVERage \n
+		Snippet: value: FetchStruct = driver.lteMeas.multiEval.listPy.segment.inbandEmission.scc.margin.average.fetch(segment = repcap.Segment.Default, secondaryCC = repcap.SecondaryCC.Default) \n
 		No command help available \n
+			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
 			:param secondaryCC: optional repeated capability selector. Default value: CC1 (settable in the interface 'Scc')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		secondaryCC_cmd_val = self._base.get_repcap_cmd_value(secondaryCC, repcap.SecondaryCC)
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:IEMission:ULCA:SCC{secondaryCC_cmd_val}:MARGin:EXTReme:RBINdex?', self.__class__.FetchStruct())
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
+		secondaryCC_cmd_val = self._cmd_group.get_repcap_cmd_value(secondaryCC, repcap.SecondaryCC)
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:IEMission:SCC{secondaryCC_cmd_val}:MARGin:AVERage?', self.__class__.FetchStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/InbandEmission_/Ulca_/Scc_/Margin_/StandardDev.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/InbandEmission/Ulca/Scc/Margin/Average.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,21 +1,21 @@
-from .......Internal.Core import Core
-from .......Internal.CommandsGroup import CommandsGroup
-from .......Internal.StructBase import StructBase
-from .......Internal.ArgStruct import ArgStruct
-from ....... import repcap
+from ........Internal.Core import Core
+from ........Internal.CommandsGroup import CommandsGroup
+from ........Internal.StructBase import StructBase
+from ........Internal.ArgStruct import ArgStruct
+from ........ import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class StandardDev:
-	"""StandardDev commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class AverageCls:
+	"""Average commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("standardDev", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
 			- Reliability: int: No parameter help available
 			- Out_Of_Tolerance: int: No parameter help available
 			- Margin: float: No parameter help available"""
@@ -27,14 +27,14 @@
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tolerance: int = None
 			self.Margin: float = None
 
 	def fetch(self, secondaryCC=repcap.SecondaryCC.Default) -> FetchStruct:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:IEMission:ULCA:SCC<Nr>:MARGin:SDEViation \n
-		Snippet: value: FetchStruct = driver.multiEval.inbandEmission.ulca.scc.margin.standardDev.fetch(secondaryCC = repcap.SecondaryCC.Default) \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:IEMission:ULCA:SCC<Nr>:MARGin:AVERage \n
+		Snippet: value: FetchStruct = driver.lteMeas.multiEval.inbandEmission.ulca.scc.margin.average.fetch(secondaryCC = repcap.SecondaryCC.Default) \n
 		No command help available \n
 			:param secondaryCC: optional repeated capability selector. Default value: CC1 (settable in the interface 'Scc')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		secondaryCC_cmd_val = self._base.get_repcap_cmd_value(secondaryCC, repcap.SecondaryCC)
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:IEMission:ULCA:SCC{secondaryCC_cmd_val}:MARGin:SDEViation?', self.__class__.FetchStruct())
+		secondaryCC_cmd_val = self._cmd_group.get_repcap_cmd_value(secondaryCC, repcap.SecondaryCC)
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:IEMission:ULCA:SCC{secondaryCC_cmd_val}:MARGin:AVERage?', self.__class__.FetchStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/__init__.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,91 +1,91 @@
-from ...Internal.Core import Core
-from ...Internal.CommandsGroup import CommandsGroup
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class ListPy:
-	"""ListPy commands group definition. 355 total commands, 9 Sub-groups, 0 group commands"""
+class ListPyCls:
+	"""ListPy commands group definition. 364 total commands, 9 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("listPy", core, parent)
+		self._cmd_group = CommandsGroup("listPy", core, parent)
 
 	@property
 	def sreliability(self):
 		"""sreliability commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_sreliability'):
-			from .ListPy_.Sreliability import Sreliability
-			self._sreliability = Sreliability(self._core, self._base)
+			from .Sreliability import SreliabilityCls
+			self._sreliability = SreliabilityCls(self._core, self._cmd_group)
 		return self._sreliability
 
 	@property
 	def modulation(self):
 		"""modulation commands group. 13 Sub-classes, 0 commands."""
 		if not hasattr(self, '_modulation'):
-			from .ListPy_.Modulation import Modulation
-			self._modulation = Modulation(self._core, self._base)
+			from .Modulation import ModulationCls
+			self._modulation = ModulationCls(self._core, self._cmd_group)
 		return self._modulation
 
 	@property
 	def inbandEmission(self):
 		"""inbandEmission commands group. 1 Sub-classes, 0 commands."""
 		if not hasattr(self, '_inbandEmission'):
-			from .ListPy_.InbandEmission import InbandEmission
-			self._inbandEmission = InbandEmission(self._core, self._base)
+			from .InbandEmission import InbandEmissionCls
+			self._inbandEmission = InbandEmissionCls(self._core, self._cmd_group)
 		return self._inbandEmission
 
 	@property
 	def esFlatness(self):
 		"""esFlatness commands group. 5 Sub-classes, 0 commands."""
 		if not hasattr(self, '_esFlatness'):
-			from .ListPy_.EsFlatness import EsFlatness
-			self._esFlatness = EsFlatness(self._core, self._base)
+			from .EsFlatness import EsFlatnessCls
+			self._esFlatness = EsFlatnessCls(self._core, self._cmd_group)
 		return self._esFlatness
 
 	@property
 	def segment(self):
 		"""segment commands group. 7 Sub-classes, 0 commands."""
 		if not hasattr(self, '_segment'):
-			from .ListPy_.Segment import Segment
-			self._segment = Segment(self._core, self._base)
+			from .Segment import SegmentCls
+			self._segment = SegmentCls(self._core, self._cmd_group)
 		return self._segment
 
 	@property
 	def seMask(self):
 		"""seMask commands group. 5 Sub-classes, 0 commands."""
 		if not hasattr(self, '_seMask'):
-			from .ListPy_.SeMask import SeMask
-			self._seMask = SeMask(self._core, self._base)
+			from .SeMask import SeMaskCls
+			self._seMask = SeMaskCls(self._core, self._cmd_group)
 		return self._seMask
 
 	@property
 	def aclr(self):
 		"""aclr commands group. 4 Sub-classes, 0 commands."""
 		if not hasattr(self, '_aclr'):
-			from .ListPy_.Aclr import Aclr
-			self._aclr = Aclr(self._core, self._base)
+			from .Aclr import AclrCls
+			self._aclr = AclrCls(self._core, self._cmd_group)
 		return self._aclr
 
 	@property
 	def power(self):
 		"""power commands group. 1 Sub-classes, 0 commands."""
 		if not hasattr(self, '_power'):
-			from .ListPy_.Power import Power
-			self._power = Power(self._core, self._base)
+			from .Power import PowerCls
+			self._power = PowerCls(self._core, self._cmd_group)
 		return self._power
 
 	@property
 	def pmonitor(self):
 		"""pmonitor commands group. 2 Sub-classes, 0 commands."""
 		if not hasattr(self, '_pmonitor'):
-			from .ListPy_.Pmonitor import Pmonitor
-			self._pmonitor = Pmonitor(self._core, self._base)
+			from .Pmonitor import PmonitorCls
+			self._pmonitor = PmonitorCls(self._core, self._cmd_group)
 		return self._pmonitor
 
-	def clone(self) -> 'ListPy':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'ListPyCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = ListPy(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = ListPyCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Aclr.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Aclr/__init__.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,51 +1,51 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Aclr:
-	"""Aclr commands group definition. 22 total commands, 4 Sub-groups, 0 group commands"""
+class AclrCls:
+	"""Aclr commands group definition. 22 total commands, 4 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("aclr", core, parent)
+		self._cmd_group = CommandsGroup("aclr", core, parent)
 
 	@property
 	def utra(self):
 		"""utra commands group. 2 Sub-classes, 0 commands."""
 		if not hasattr(self, '_utra'):
-			from .Aclr_.Utra import Utra
-			self._utra = Utra(self._core, self._base)
+			from .Utra import UtraCls
+			self._utra = UtraCls(self._core, self._cmd_group)
 		return self._utra
 
 	@property
 	def eutra(self):
 		"""eutra commands group. 4 Sub-classes, 0 commands."""
 		if not hasattr(self, '_eutra'):
-			from .Aclr_.Eutra import Eutra
-			self._eutra = Eutra(self._core, self._base)
+			from .Eutra import EutraCls
+			self._eutra = EutraCls(self._core, self._cmd_group)
 		return self._eutra
 
 	@property
 	def dchType(self):
 		"""dchType commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_dchType'):
-			from .Aclr_.DchType import DchType
-			self._dchType = DchType(self._core, self._base)
+			from .DchType import DchTypeCls
+			self._dchType = DchTypeCls(self._core, self._cmd_group)
 		return self._dchType
 
 	@property
 	def dallocation(self):
 		"""dallocation commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_dallocation'):
-			from .Aclr_.Dallocation import Dallocation
-			self._dallocation = Dallocation(self._core, self._base)
+			from .Dallocation import DallocationCls
+			self._dallocation = DallocationCls(self._core, self._cmd_group)
 		return self._dallocation
 
-	def clone(self) -> 'Aclr':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'AclrCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Aclr(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = AclrCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Aclr_/Dallocation.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Aclr/Dallocation.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,28 +1,28 @@
 from typing import List
 
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
-from .....Internal.Types import DataType
-from .....Internal.StructBase import StructBase
-from .....Internal.ArgStruct import ArgStruct
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal.Types import DataType
+from ......Internal.StructBase import StructBase
+from ......Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Dallocation:
-	"""Dallocation commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class DallocationCls:
+	"""Dallocation commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("dallocation", core, parent)
+		self._cmd_group = CommandsGroup("dallocation", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
+			- Reliability: int: 'Reliability indicator'
 			- Nr_Res_Blocks: List[int]: Number of allocated resource blocks
 			- Offset_Res_Blocks: List[int]: Offset of the first allocated resource block from the edge of the allocated UL transmission bandwidth"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct('Nr_Res_Blocks', DataType.IntegerList, None, False, True, 1),
 			ArgStruct('Offset_Res_Blocks', DataType.IntegerList, None, False, True, 1)]
 
@@ -30,15 +30,15 @@
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Nr_Res_Blocks: List[int] = None
 			self.Offset_Res_Blocks: List[int] = None
 
 	def fetch(self) -> FetchStruct:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:ACLR:DALLocation \n
-		Snippet: value: FetchStruct = driver.multiEval.listPy.aclr.dallocation.fetch() \n
+		Snippet: value: FetchStruct = driver.lteMeas.multiEval.listPy.aclr.dallocation.fetch() \n
 		Return the detected allocation for all measured list mode segments. The result is determined from the last measured slot
-		of the statistical length of a segment. The individual measurements provide identical detected allocation results when
-		measuring the same slot. However different statistical lengths can be defined for the measurements so that the measured
-		slots and returned results can differ. The results are returned as pairs per segment: <Reliability>, {<NrResBlocks>,
-		<OffsetResBlocks>}Seg 1, {<NrResBlocks>, <OffsetResBlocks>}Seg 2, ... \n
+		of the statistical length of a segment. The individual measurements provide the same result when measuring the same slot.
+		However different statistical lengths can be defined for the measurements so that the measured slots and returned results
+		can differ. The results are returned as pairs per segment: <Reliability>, {<NrResBlocks>, <OffsetResBlocks>}Seg 1,
+		{<NrResBlocks>, <OffsetResBlocks>}Seg 2, ... \n
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
 		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:ACLR:DALLocation?', self.__class__.FetchStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Aclr_/DchType.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/DchType.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,31 +1,31 @@
 from typing import List
 
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
-from .....Internal import Conversions
-from .....Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from .....Internal.Types import DataType
-from ..... import enums
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal import Conversions
+from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from ......Internal.Types import DataType
+from ...... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class DchType:
-	"""DchType commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class DchTypeCls:
+	"""DchType commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("dchType", core, parent)
+		self._cmd_group = CommandsGroup("dchType", core, parent)
 
 	# noinspection PyTypeChecker
 	def fetch(self) -> List[enums.UplinkChannelType]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:ACLR:DCHType \n
-		Snippet: value: List[enums.UplinkChannelType] = driver.multiEval.listPy.aclr.dchType.fetch() \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:DCHType \n
+		Snippet: value: List[enums.UplinkChannelType] = driver.lteMeas.multiEval.listPy.modulation.dchType.fetch() \n
 		Return the uplink channel type for all measured list mode segments. The result is determined from the last measured slot
-		of the statistical length of a segment. The individual measurements provide identical detected channel type results when
-		measuring the same slot. However different statistical lengths can be defined for the measurements so that the measured
-		slots and returned results can differ. \n
+		of the statistical length of a segment. The individual measurements provide the same result when measuring the same slot.
+		However different statistical lengths can be defined for the measurements so that the measured slots and returned results
+		can differ. \n
 		Suppressed linked return values: reliability \n
 			:return: channel_type: Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_str_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:ACLR:DCHType?', suppressed)
+		response = self._core.io.query_str_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:DCHType?', suppressed)
 		return Conversions.str_to_list_enum(response, enums.UplinkChannelType)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Aclr_/Eutra.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/SeMask/Margin/Minimum/__init__.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,51 +1,35 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Eutra:
-	"""Eutra commands group definition. 12 total commands, 4 Sub-groups, 0 group commands"""
+class MinimumCls:
+	"""Minimum commands group definition. 2 total commands, 2 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("eutra", core, parent)
+		self._cmd_group = CommandsGroup("minimum", core, parent)
 
 	@property
 	def negativ(self):
-		"""negativ commands group. 2 Sub-classes, 0 commands."""
+		"""negativ commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_negativ'):
-			from .Eutra_.Negativ import Negativ
-			self._negativ = Negativ(self._core, self._base)
+			from .Negativ import NegativCls
+			self._negativ = NegativCls(self._core, self._cmd_group)
 		return self._negativ
 
 	@property
-	def current(self):
-		"""current commands group. 0 Sub-classes, 2 commands."""
-		if not hasattr(self, '_current'):
-			from .Eutra_.Current import Current
-			self._current = Current(self._core, self._base)
-		return self._current
-
-	@property
 	def positiv(self):
-		"""positiv commands group. 2 Sub-classes, 0 commands."""
+		"""positiv commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_positiv'):
-			from .Eutra_.Positiv import Positiv
-			self._positiv = Positiv(self._core, self._base)
+			from .Positiv import PositivCls
+			self._positiv = PositivCls(self._core, self._cmd_group)
 		return self._positiv
 
-	@property
-	def average(self):
-		"""average commands group. 0 Sub-classes, 2 commands."""
-		if not hasattr(self, '_average'):
-			from .Eutra_.Average import Average
-			self._average = Average(self._core, self._base)
-		return self._average
-
-	def clone(self) -> 'Eutra':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'MinimumCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Eutra(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = MinimumCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Aclr_/Eutra_/Average.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Aclr/Eutra/Positiv/Average.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,40 +1,42 @@
 from typing import List
 
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal import Conversions
-from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ......Internal.Types import DataType
-from ...... import enums
+from ........Internal.Core import Core
+from ........Internal.CommandsGroup import CommandsGroup
+from ........Internal import Conversions
+from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from ........Internal.Types import DataType
+from ........ import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class AverageCls:
+	"""Average commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:ACLR:EUTRa:AVERage \n
-		Snippet: value: List[float] = driver.multiEval.listPy.aclr.eutra.average.fetch() \n
-		Return the power in the allocated E-UTRA channel for all measured list mode segments. The values described below are
-		returned by FETCh commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:ACLR:EUTRa:POSitiv:AVERage \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.listPy.aclr.eutra.positiv.average.fetch() \n
+		Return the ACLR for the first adjacent E-UTRA channel above (POSitiv) or below (NEGativ) the carrier frequency for all
+		measured list mode segments. The values described below are returned by FETCh commands. CALCulate commands return limit
+		check results instead, one value for each result listed below. \n
 		Suppressed linked return values: reliability \n
-			:return: eutra: Comma-separated list of values, one per measured segment"""
+			:return: eutra_positiv: Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:ACLR:EUTRa:AVERage?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:ACLR:EUTRa:POSitiv:AVERage?', suppressed)
 		return response
 
 	# noinspection PyTypeChecker
 	def calculate(self) -> List[enums.ResultStatus2]:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:ACLR:EUTRa:AVERage \n
-		Snippet: value: List[enums.ResultStatus2] = driver.multiEval.listPy.aclr.eutra.average.calculate() \n
-		Return the power in the allocated E-UTRA channel for all measured list mode segments. The values described below are
-		returned by FETCh commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:ACLR:EUTRa:POSitiv:AVERage \n
+		Snippet: value: List[enums.ResultStatus2] = driver.lteMeas.multiEval.listPy.aclr.eutra.positiv.average.calculate() \n
+		Return the ACLR for the first adjacent E-UTRA channel above (POSitiv) or below (NEGativ) the carrier frequency for all
+		measured list mode segments. The values described below are returned by FETCh commands. CALCulate commands return limit
+		check results instead, one value for each result listed below. \n
 		Suppressed linked return values: reliability \n
-			:return: eutra: Comma-separated list of values, one per measured segment"""
+			:return: eutra_positiv: Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:ACLR:EUTRa:AVERage?', suppressed)
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:ACLR:EUTRa:POSitiv:AVERage?', suppressed)
 		return Conversions.str_to_list_enum(response, enums.ResultStatus2)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Aclr_/Eutra_/Current.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Aclr/Eutra/Current.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,40 +1,40 @@
 from typing import List
 
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal import Conversions
-from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ......Internal.Types import DataType
-from ...... import enums
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal import Conversions
+from .......Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .......Internal.Types import DataType
+from ....... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	def fetch(self) -> List[float]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:ACLR:EUTRa:CURRent \n
-		Snippet: value: List[float] = driver.multiEval.listPy.aclr.eutra.current.fetch() \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.listPy.aclr.eutra.current.fetch() \n
 		Return the power in the allocated E-UTRA channel for all measured list mode segments. The values described below are
 		returned by FETCh commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 		Suppressed linked return values: reliability \n
 			:return: eutra: Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:ACLR:EUTRa:CURRent?', suppressed)
 		return response
 
 	# noinspection PyTypeChecker
 	def calculate(self) -> List[enums.ResultStatus2]:
 		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:ACLR:EUTRa:CURRent \n
-		Snippet: value: List[enums.ResultStatus2] = driver.multiEval.listPy.aclr.eutra.current.calculate() \n
+		Snippet: value: List[enums.ResultStatus2] = driver.lteMeas.multiEval.listPy.aclr.eutra.current.calculate() \n
 		Return the power in the allocated E-UTRA channel for all measured list mode segments. The values described below are
 		returned by FETCh commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 		Suppressed linked return values: reliability \n
 			:return: eutra: Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:ACLR:EUTRa:CURRent?', suppressed)
 		return Conversions.str_to_list_enum(response, enums.ResultStatus2)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Aclr_/Eutra_/Negativ.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Aclr/Utra/Negativ/__init__.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,35 +1,35 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
+from ........Internal.Core import Core
+from ........Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Negativ:
-	"""Negativ commands group definition. 4 total commands, 2 Sub-groups, 0 group commands"""
+class NegativCls:
+	"""Negativ commands group definition. 4 total commands, 2 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("negativ", core, parent)
+		self._cmd_group = CommandsGroup("negativ", core, parent)
 
 	@property
 	def current(self):
 		"""current commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_current'):
-			from .Negativ_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
 	@property
 	def average(self):
 		"""average commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_average'):
-			from .Negativ_.Average import Average
-			self._average = Average(self._core, self._base)
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
 		return self._average
 
-	def clone(self) -> 'Negativ':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'NegativCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Negativ(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = NegativCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Aclr_/Eutra_/Negativ_/Average.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Aclr/Eutra/Negativ/Average.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,41 +1,41 @@
 from typing import List
 
-from .......Internal.Core import Core
-from .......Internal.CommandsGroup import CommandsGroup
-from .......Internal import Conversions
-from .......Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from .......Internal.Types import DataType
-from ....... import enums
+from ........Internal.Core import Core
+from ........Internal.CommandsGroup import CommandsGroup
+from ........Internal import Conversions
+from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from ........Internal.Types import DataType
+from ........ import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class AverageCls:
+	"""Average commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	def fetch(self) -> List[float]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:ACLR:EUTRa:NEGativ:AVERage \n
-		Snippet: value: List[float] = driver.multiEval.listPy.aclr.eutra.negativ.average.fetch() \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.listPy.aclr.eutra.negativ.average.fetch() \n
 		Return the ACLR for the first adjacent E-UTRA channel above (POSitiv) or below (NEGativ) the carrier frequency for all
 		measured list mode segments. The values described below are returned by FETCh commands. CALCulate commands return limit
 		check results instead, one value for each result listed below. \n
 		Suppressed linked return values: reliability \n
 			:return: eutra_negativ: Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:ACLR:EUTRa:NEGativ:AVERage?', suppressed)
 		return response
 
 	# noinspection PyTypeChecker
 	def calculate(self) -> List[enums.ResultStatus2]:
 		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:ACLR:EUTRa:NEGativ:AVERage \n
-		Snippet: value: List[enums.ResultStatus2] = driver.multiEval.listPy.aclr.eutra.negativ.average.calculate() \n
+		Snippet: value: List[enums.ResultStatus2] = driver.lteMeas.multiEval.listPy.aclr.eutra.negativ.average.calculate() \n
 		Return the ACLR for the first adjacent E-UTRA channel above (POSitiv) or below (NEGativ) the carrier frequency for all
 		measured list mode segments. The values described below are returned by FETCh commands. CALCulate commands return limit
 		check results instead, one value for each result listed below. \n
 		Suppressed linked return values: reliability \n
 			:return: eutra_negativ: Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:ACLR:EUTRa:NEGativ:AVERage?', suppressed)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Aclr_/Eutra_/Negativ_/Current.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Aclr/Eutra/Negativ/Current.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,41 +1,41 @@
 from typing import List
 
-from .......Internal.Core import Core
-from .......Internal.CommandsGroup import CommandsGroup
-from .......Internal import Conversions
-from .......Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from .......Internal.Types import DataType
-from ....... import enums
+from ........Internal.Core import Core
+from ........Internal.CommandsGroup import CommandsGroup
+from ........Internal import Conversions
+from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from ........Internal.Types import DataType
+from ........ import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	def fetch(self) -> List[float]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:ACLR:EUTRa:NEGativ:CURRent \n
-		Snippet: value: List[float] = driver.multiEval.listPy.aclr.eutra.negativ.current.fetch() \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.listPy.aclr.eutra.negativ.current.fetch() \n
 		Return the ACLR for the first adjacent E-UTRA channel above (POSitiv) or below (NEGativ) the carrier frequency for all
 		measured list mode segments. The values described below are returned by FETCh commands. CALCulate commands return limit
 		check results instead, one value for each result listed below. \n
 		Suppressed linked return values: reliability \n
 			:return: eutra_negativ: Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:ACLR:EUTRa:NEGativ:CURRent?', suppressed)
 		return response
 
 	# noinspection PyTypeChecker
 	def calculate(self) -> List[enums.ResultStatus2]:
 		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:ACLR:EUTRa:NEGativ:CURRent \n
-		Snippet: value: List[enums.ResultStatus2] = driver.multiEval.listPy.aclr.eutra.negativ.current.calculate() \n
+		Snippet: value: List[enums.ResultStatus2] = driver.lteMeas.multiEval.listPy.aclr.eutra.negativ.current.calculate() \n
 		Return the ACLR for the first adjacent E-UTRA channel above (POSitiv) or below (NEGativ) the carrier frequency for all
 		measured list mode segments. The values described below are returned by FETCh commands. CALCulate commands return limit
 		check results instead, one value for each result listed below. \n
 		Suppressed linked return values: reliability \n
 			:return: eutra_negativ: Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:ACLR:EUTRa:NEGativ:CURRent?', suppressed)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Aclr_/Eutra_/Positiv.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Trace/EvmSymbol/__init__.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,35 +1,43 @@
 from ......Internal.Core import Core
 from ......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Positiv:
-	"""Positiv commands group definition. 4 total commands, 2 Sub-groups, 0 group commands"""
+class EvmSymbolCls:
+	"""EvmSymbol commands group definition. 6 total commands, 3 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("positiv", core, parent)
+		self._cmd_group = CommandsGroup("evmSymbol", core, parent)
 
 	@property
 	def current(self):
 		"""current commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_current'):
-			from .Positiv_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
 	@property
 	def average(self):
 		"""average commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_average'):
-			from .Positiv_.Average import Average
-			self._average = Average(self._core, self._base)
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
 		return self._average
 
-	def clone(self) -> 'Positiv':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	@property
+	def maximum(self):
+		"""maximum commands group. 0 Sub-classes, 2 commands."""
+		if not hasattr(self, '_maximum'):
+			from .Maximum import MaximumCls
+			self._maximum = MaximumCls(self._core, self._cmd_group)
+		return self._maximum
+
+	def clone(self) -> 'EvmSymbolCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Positiv(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = EvmSymbolCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Aclr_/Eutra_/Positiv_/Average.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Aclr/Eutra/Positiv/Current.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,42 +1,42 @@
 from typing import List
 
-from .......Internal.Core import Core
-from .......Internal.CommandsGroup import CommandsGroup
-from .......Internal import Conversions
-from .......Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from .......Internal.Types import DataType
-from ....... import enums
+from ........Internal.Core import Core
+from ........Internal.CommandsGroup import CommandsGroup
+from ........Internal import Conversions
+from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from ........Internal.Types import DataType
+from ........ import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:ACLR:EUTRa:POSitiv:AVERage \n
-		Snippet: value: List[float] = driver.multiEval.listPy.aclr.eutra.positiv.average.fetch() \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:ACLR:EUTRa:POSitiv:CURRent \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.listPy.aclr.eutra.positiv.current.fetch() \n
 		Return the ACLR for the first adjacent E-UTRA channel above (POSitiv) or below (NEGativ) the carrier frequency for all
 		measured list mode segments. The values described below are returned by FETCh commands. CALCulate commands return limit
 		check results instead, one value for each result listed below. \n
 		Suppressed linked return values: reliability \n
 			:return: eutra_positiv: Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:ACLR:EUTRa:POSitiv:AVERage?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:ACLR:EUTRa:POSitiv:CURRent?', suppressed)
 		return response
 
 	# noinspection PyTypeChecker
 	def calculate(self) -> List[enums.ResultStatus2]:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:ACLR:EUTRa:POSitiv:AVERage \n
-		Snippet: value: List[enums.ResultStatus2] = driver.multiEval.listPy.aclr.eutra.positiv.average.calculate() \n
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:ACLR:EUTRa:POSitiv:CURRent \n
+		Snippet: value: List[enums.ResultStatus2] = driver.lteMeas.multiEval.listPy.aclr.eutra.positiv.current.calculate() \n
 		Return the ACLR for the first adjacent E-UTRA channel above (POSitiv) or below (NEGativ) the carrier frequency for all
 		measured list mode segments. The values described below are returned by FETCh commands. CALCulate commands return limit
 		check results instead, one value for each result listed below. \n
 		Suppressed linked return values: reliability \n
 			:return: eutra_positiv: Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:ACLR:EUTRa:POSitiv:AVERage?', suppressed)
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:ACLR:EUTRa:POSitiv:CURRent?', suppressed)
 		return Conversions.str_to_list_enum(response, enums.ResultStatus2)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Aclr_/Eutra_/Positiv_/Current.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Merror/Rms/High/Average.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,42 +1,40 @@
 from typing import List
 
-from .......Internal.Core import Core
-from .......Internal.CommandsGroup import CommandsGroup
-from .......Internal import Conversions
-from .......Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from .......Internal.Types import DataType
-from ....... import enums
+from .........Internal.Core import Core
+from .........Internal.CommandsGroup import CommandsGroup
+from .........Internal import Conversions
+from .........Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .........Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class AverageCls:
+	"""Average commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:ACLR:EUTRa:POSitiv:CURRent \n
-		Snippet: value: List[float] = driver.multiEval.listPy.aclr.eutra.positiv.current.fetch() \n
-		Return the ACLR for the first adjacent E-UTRA channel above (POSitiv) or below (NEGativ) the carrier frequency for all
-		measured list mode segments. The values described below are returned by FETCh commands. CALCulate commands return limit
-		check results instead, one value for each result listed below. \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:RMS:HIGH:AVERage \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.listPy.modulation.merror.rms.high.average.fetch() \n
+		Return magnitude error RMS values for low and high EVM window position, for all measured list mode segments. The values
+		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
+		result listed below. \n
 		Suppressed linked return values: reliability \n
-			:return: eutra_positiv: Comma-separated list of values, one per measured segment"""
+			:return: mag_error_rms_high: Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:ACLR:EUTRa:POSitiv:CURRent?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:RMS:HIGH:AVERage?', suppressed)
 		return response
 
-	# noinspection PyTypeChecker
-	def calculate(self) -> List[enums.ResultStatus2]:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:ACLR:EUTRa:POSitiv:CURRent \n
-		Snippet: value: List[enums.ResultStatus2] = driver.multiEval.listPy.aclr.eutra.positiv.current.calculate() \n
-		Return the ACLR for the first adjacent E-UTRA channel above (POSitiv) or below (NEGativ) the carrier frequency for all
-		measured list mode segments. The values described below are returned by FETCh commands. CALCulate commands return limit
-		check results instead, one value for each result listed below. \n
+	def calculate(self) -> List[float or bool]:
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:RMS:HIGH:AVERage \n
+		Snippet: value: List[float or bool] = driver.lteMeas.multiEval.listPy.modulation.merror.rms.high.average.calculate() \n
+		Return magnitude error RMS values for low and high EVM window position, for all measured list mode segments. The values
+		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
+		result listed below. \n
 		Suppressed linked return values: reliability \n
-			:return: eutra_positiv: Comma-separated list of values, one per measured segment"""
+			:return: mag_error_rms_high: (float or boolean items) Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:ACLR:EUTRa:POSitiv:CURRent?', suppressed)
-		return Conversions.str_to_list_enum(response, enums.ResultStatus2)
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:RMS:HIGH:AVERage?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Aclr_/Utra.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/SeMask/Margin/Area/__init__.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,50 +1,50 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
-from .....Internal.RepeatedCapability import RepeatedCapability
-from ..... import repcap
+from ........Internal.Core import Core
+from ........Internal.CommandsGroup import CommandsGroup
+from ........Internal.RepeatedCapability import RepeatedCapability
+from ........ import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Utra:
-	"""Utra commands group definition. 8 total commands, 2 Sub-groups, 0 group commands
-	Repeated Capability: UtraAdjChannel, default value after init: UtraAdjChannel.Ch1"""
+class AreaCls:
+	"""Area commands group definition. 6 total commands, 2 Subgroups, 0 group commands
+	Repeated Capability: Area, default value after init: Area.Nr1"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("utra", core, parent)
-		self._base.rep_cap = RepeatedCapability(self._base.group_name, 'repcap_utraAdjChannel_get', 'repcap_utraAdjChannel_set', repcap.UtraAdjChannel.Ch1)
+		self._cmd_group = CommandsGroup("area", core, parent)
+		self._cmd_group.rep_cap = RepeatedCapability(self._cmd_group.group_name, 'repcap_area_get', 'repcap_area_set', repcap.Area.Nr1)
 
-	def repcap_utraAdjChannel_set(self, enum_value: repcap.UtraAdjChannel) -> None:
+	def repcap_area_set(self, area: repcap.Area) -> None:
 		"""Repeated Capability default value numeric suffix.
-		This value is used, if you do not explicitely set it in the child set/get methods, or if you leave it to UtraAdjChannel.Default
-		Default value after init: UtraAdjChannel.Ch1"""
-		self._base.set_repcap_enum_value(enum_value)
+		This value is used, if you do not explicitely set it in the child set/get methods, or if you leave it to Area.Default
+		Default value after init: Area.Nr1"""
+		self._cmd_group.set_repcap_enum_value(area)
 
-	def repcap_utraAdjChannel_get(self) -> repcap.UtraAdjChannel:
+	def repcap_area_get(self) -> repcap.Area:
 		"""Returns the current default repeated capability for the child set/get methods"""
 		# noinspection PyTypeChecker
-		return self._base.get_repcap_enum_value()
+		return self._cmd_group.get_repcap_enum_value()
 
 	@property
 	def negativ(self):
-		"""negativ commands group. 2 Sub-classes, 0 commands."""
+		"""negativ commands group. 3 Sub-classes, 0 commands."""
 		if not hasattr(self, '_negativ'):
-			from .Utra_.Negativ import Negativ
-			self._negativ = Negativ(self._core, self._base)
+			from .Negativ import NegativCls
+			self._negativ = NegativCls(self._core, self._cmd_group)
 		return self._negativ
 
 	@property
 	def positiv(self):
-		"""positiv commands group. 2 Sub-classes, 0 commands."""
+		"""positiv commands group. 3 Sub-classes, 0 commands."""
 		if not hasattr(self, '_positiv'):
-			from .Utra_.Positiv import Positiv
-			self._positiv = Positiv(self._core, self._base)
+			from .Positiv import PositivCls
+			self._positiv = PositivCls(self._core, self._cmd_group)
 		return self._positiv
 
-	def clone(self) -> 'Utra':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'AreaCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Utra(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = AreaCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Aclr_/Utra_/Negativ.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Aclr/Eutra/Positiv/__init__.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,35 +1,35 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
+from ........Internal.Core import Core
+from ........Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Negativ:
-	"""Negativ commands group definition. 4 total commands, 2 Sub-groups, 0 group commands"""
+class PositivCls:
+	"""Positiv commands group definition. 4 total commands, 2 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("negativ", core, parent)
+		self._cmd_group = CommandsGroup("positiv", core, parent)
 
 	@property
 	def current(self):
 		"""current commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_current'):
-			from .Negativ_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
 	@property
 	def average(self):
 		"""average commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_average'):
-			from .Negativ_.Average import Average
-			self._average = Average(self._core, self._base)
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
 		return self._average
 
-	def clone(self) -> 'Negativ':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'PositivCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Negativ(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = PositivCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Aclr_/Utra_/Negativ_/Average.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Aclr/Utra/Negativ/Average.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,47 +1,47 @@
 from typing import List
 
-from .......Internal.Core import Core
-from .......Internal.CommandsGroup import CommandsGroup
-from .......Internal import Conversions
-from .......Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from .......Internal.Types import DataType
-from ....... import enums
-from ....... import repcap
+from ........Internal.Core import Core
+from ........Internal.CommandsGroup import CommandsGroup
+from ........Internal import Conversions
+from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from ........Internal.Types import DataType
+from ........ import enums
+from ........ import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class AverageCls:
+	"""Average commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	def fetch(self, utraAdjChannel=repcap.UtraAdjChannel.Default) -> List[float]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:ACLR:UTRA<nr>:NEGativ:AVERage \n
-		Snippet: value: List[float] = driver.multiEval.listPy.aclr.utra.negativ.average.fetch(utraAdjChannel = repcap.UtraAdjChannel.Default) \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.listPy.aclr.utra.negativ.average.fetch(utraAdjChannel = repcap.UtraAdjChannel.Default) \n
 		Return the ACLR for the first or second adjacent UTRA channel above (POSitiv) or below (NEGativ) the carrier frequency
 		for all measured list mode segments. The values described below are returned by FETCh commands. CALCulate commands return
 		limit check results instead, one value for each result listed below. \n
 		Suppressed linked return values: reliability \n
 			:param utraAdjChannel: optional repeated capability selector. Default value: Ch1 (settable in the interface 'Utra')
 			:return: utra_negativ: Comma-separated list of values, one per measured segment"""
-		utraAdjChannel_cmd_val = self._base.get_repcap_cmd_value(utraAdjChannel, repcap.UtraAdjChannel)
+		utraAdjChannel_cmd_val = self._cmd_group.get_repcap_cmd_value(utraAdjChannel, repcap.UtraAdjChannel)
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:ACLR:UTRA{utraAdjChannel_cmd_val}:NEGativ:AVERage?', suppressed)
 		return response
 
 	# noinspection PyTypeChecker
 	def calculate(self, utraAdjChannel=repcap.UtraAdjChannel.Default) -> List[enums.ResultStatus2]:
 		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:ACLR:UTRA<nr>:NEGativ:AVERage \n
-		Snippet: value: List[enums.ResultStatus2] = driver.multiEval.listPy.aclr.utra.negativ.average.calculate(utraAdjChannel = repcap.UtraAdjChannel.Default) \n
+		Snippet: value: List[enums.ResultStatus2] = driver.lteMeas.multiEval.listPy.aclr.utra.negativ.average.calculate(utraAdjChannel = repcap.UtraAdjChannel.Default) \n
 		Return the ACLR for the first or second adjacent UTRA channel above (POSitiv) or below (NEGativ) the carrier frequency
 		for all measured list mode segments. The values described below are returned by FETCh commands. CALCulate commands return
 		limit check results instead, one value for each result listed below. \n
 		Suppressed linked return values: reliability \n
 			:param utraAdjChannel: optional repeated capability selector. Default value: Ch1 (settable in the interface 'Utra')
 			:return: utra_negativ: Comma-separated list of values, one per measured segment"""
-		utraAdjChannel_cmd_val = self._base.get_repcap_cmd_value(utraAdjChannel, repcap.UtraAdjChannel)
+		utraAdjChannel_cmd_val = self._cmd_group.get_repcap_cmd_value(utraAdjChannel, repcap.UtraAdjChannel)
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:ACLR:UTRA{utraAdjChannel_cmd_val}:NEGativ:AVERage?', suppressed)
 		return Conversions.str_to_list_enum(response, enums.ResultStatus2)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Aclr_/Utra_/Negativ_/Current.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Aclr/Utra/Negativ/Current.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,47 +1,47 @@
 from typing import List
 
-from .......Internal.Core import Core
-from .......Internal.CommandsGroup import CommandsGroup
-from .......Internal import Conversions
-from .......Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from .......Internal.Types import DataType
-from ....... import enums
-from ....... import repcap
+from ........Internal.Core import Core
+from ........Internal.CommandsGroup import CommandsGroup
+from ........Internal import Conversions
+from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from ........Internal.Types import DataType
+from ........ import enums
+from ........ import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	def fetch(self, utraAdjChannel=repcap.UtraAdjChannel.Default) -> List[float]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:ACLR:UTRA<nr>:NEGativ:CURRent \n
-		Snippet: value: List[float] = driver.multiEval.listPy.aclr.utra.negativ.current.fetch(utraAdjChannel = repcap.UtraAdjChannel.Default) \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.listPy.aclr.utra.negativ.current.fetch(utraAdjChannel = repcap.UtraAdjChannel.Default) \n
 		Return the ACLR for the first or second adjacent UTRA channel above (POSitiv) or below (NEGativ) the carrier frequency
 		for all measured list mode segments. The values described below are returned by FETCh commands. CALCulate commands return
 		limit check results instead, one value for each result listed below. \n
 		Suppressed linked return values: reliability \n
 			:param utraAdjChannel: optional repeated capability selector. Default value: Ch1 (settable in the interface 'Utra')
 			:return: utra_negativ: Comma-separated list of values, one per measured segment"""
-		utraAdjChannel_cmd_val = self._base.get_repcap_cmd_value(utraAdjChannel, repcap.UtraAdjChannel)
+		utraAdjChannel_cmd_val = self._cmd_group.get_repcap_cmd_value(utraAdjChannel, repcap.UtraAdjChannel)
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:ACLR:UTRA{utraAdjChannel_cmd_val}:NEGativ:CURRent?', suppressed)
 		return response
 
 	# noinspection PyTypeChecker
 	def calculate(self, utraAdjChannel=repcap.UtraAdjChannel.Default) -> List[enums.ResultStatus2]:
 		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:ACLR:UTRA<nr>:NEGativ:CURRent \n
-		Snippet: value: List[enums.ResultStatus2] = driver.multiEval.listPy.aclr.utra.negativ.current.calculate(utraAdjChannel = repcap.UtraAdjChannel.Default) \n
+		Snippet: value: List[enums.ResultStatus2] = driver.lteMeas.multiEval.listPy.aclr.utra.negativ.current.calculate(utraAdjChannel = repcap.UtraAdjChannel.Default) \n
 		Return the ACLR for the first or second adjacent UTRA channel above (POSitiv) or below (NEGativ) the carrier frequency
 		for all measured list mode segments. The values described below are returned by FETCh commands. CALCulate commands return
 		limit check results instead, one value for each result listed below. \n
 		Suppressed linked return values: reliability \n
 			:param utraAdjChannel: optional repeated capability selector. Default value: Ch1 (settable in the interface 'Utra')
 			:return: utra_negativ: Comma-separated list of values, one per measured segment"""
-		utraAdjChannel_cmd_val = self._base.get_repcap_cmd_value(utraAdjChannel, repcap.UtraAdjChannel)
+		utraAdjChannel_cmd_val = self._cmd_group.get_repcap_cmd_value(utraAdjChannel, repcap.UtraAdjChannel)
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:ACLR:UTRA{utraAdjChannel_cmd_val}:NEGativ:CURRent?', suppressed)
 		return Conversions.str_to_list_enum(response, enums.ResultStatus2)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Aclr_/Utra_/Positiv.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Aclr/Utra/Positiv/__init__.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,35 +1,35 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
+from ........Internal.Core import Core
+from ........Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Positiv:
-	"""Positiv commands group definition. 4 total commands, 2 Sub-groups, 0 group commands"""
+class PositivCls:
+	"""Positiv commands group definition. 4 total commands, 2 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("positiv", core, parent)
+		self._cmd_group = CommandsGroup("positiv", core, parent)
 
 	@property
 	def current(self):
 		"""current commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_current'):
-			from .Positiv_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
 	@property
 	def average(self):
 		"""average commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_average'):
-			from .Positiv_.Average import Average
-			self._average = Average(self._core, self._base)
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
 		return self._average
 
-	def clone(self) -> 'Positiv':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'PositivCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Positiv(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = PositivCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Aclr_/Utra_/Positiv_/Average.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Aclr/Utra/Positiv/Average.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,47 +1,47 @@
 from typing import List
 
-from .......Internal.Core import Core
-from .......Internal.CommandsGroup import CommandsGroup
-from .......Internal import Conversions
-from .......Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from .......Internal.Types import DataType
-from ....... import enums
-from ....... import repcap
+from ........Internal.Core import Core
+from ........Internal.CommandsGroup import CommandsGroup
+from ........Internal import Conversions
+from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from ........Internal.Types import DataType
+from ........ import enums
+from ........ import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class AverageCls:
+	"""Average commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	def fetch(self, utraAdjChannel=repcap.UtraAdjChannel.Default) -> List[float]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:ACLR:UTRA<nr>:POSitiv:AVERage \n
-		Snippet: value: List[float] = driver.multiEval.listPy.aclr.utra.positiv.average.fetch(utraAdjChannel = repcap.UtraAdjChannel.Default) \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.listPy.aclr.utra.positiv.average.fetch(utraAdjChannel = repcap.UtraAdjChannel.Default) \n
 		Return the ACLR for the first or second adjacent UTRA channel above (POSitiv) or below (NEGativ) the carrier frequency
 		for all measured list mode segments. The values described below are returned by FETCh commands. CALCulate commands return
 		limit check results instead, one value for each result listed below. \n
 		Suppressed linked return values: reliability \n
 			:param utraAdjChannel: optional repeated capability selector. Default value: Ch1 (settable in the interface 'Utra')
 			:return: utra_positiv: Comma-separated list of values, one per measured segment"""
-		utraAdjChannel_cmd_val = self._base.get_repcap_cmd_value(utraAdjChannel, repcap.UtraAdjChannel)
+		utraAdjChannel_cmd_val = self._cmd_group.get_repcap_cmd_value(utraAdjChannel, repcap.UtraAdjChannel)
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:ACLR:UTRA{utraAdjChannel_cmd_val}:POSitiv:AVERage?', suppressed)
 		return response
 
 	# noinspection PyTypeChecker
 	def calculate(self, utraAdjChannel=repcap.UtraAdjChannel.Default) -> List[enums.ResultStatus2]:
 		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:ACLR:UTRA<nr>:POSitiv:AVERage \n
-		Snippet: value: List[enums.ResultStatus2] = driver.multiEval.listPy.aclr.utra.positiv.average.calculate(utraAdjChannel = repcap.UtraAdjChannel.Default) \n
+		Snippet: value: List[enums.ResultStatus2] = driver.lteMeas.multiEval.listPy.aclr.utra.positiv.average.calculate(utraAdjChannel = repcap.UtraAdjChannel.Default) \n
 		Return the ACLR for the first or second adjacent UTRA channel above (POSitiv) or below (NEGativ) the carrier frequency
 		for all measured list mode segments. The values described below are returned by FETCh commands. CALCulate commands return
 		limit check results instead, one value for each result listed below. \n
 		Suppressed linked return values: reliability \n
 			:param utraAdjChannel: optional repeated capability selector. Default value: Ch1 (settable in the interface 'Utra')
 			:return: utra_positiv: Comma-separated list of values, one per measured segment"""
-		utraAdjChannel_cmd_val = self._base.get_repcap_cmd_value(utraAdjChannel, repcap.UtraAdjChannel)
+		utraAdjChannel_cmd_val = self._cmd_group.get_repcap_cmd_value(utraAdjChannel, repcap.UtraAdjChannel)
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:ACLR:UTRA{utraAdjChannel_cmd_val}:POSitiv:AVERage?', suppressed)
 		return Conversions.str_to_list_enum(response, enums.ResultStatus2)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Aclr_/Utra_/Positiv_/Current.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Aclr/Utra/Positiv/Current.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,47 +1,47 @@
 from typing import List
 
-from .......Internal.Core import Core
-from .......Internal.CommandsGroup import CommandsGroup
-from .......Internal import Conversions
-from .......Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from .......Internal.Types import DataType
-from ....... import enums
-from ....... import repcap
+from ........Internal.Core import Core
+from ........Internal.CommandsGroup import CommandsGroup
+from ........Internal import Conversions
+from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from ........Internal.Types import DataType
+from ........ import enums
+from ........ import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	def fetch(self, utraAdjChannel=repcap.UtraAdjChannel.Default) -> List[float]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:ACLR:UTRA<nr>:POSitiv:CURRent \n
-		Snippet: value: List[float] = driver.multiEval.listPy.aclr.utra.positiv.current.fetch(utraAdjChannel = repcap.UtraAdjChannel.Default) \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.listPy.aclr.utra.positiv.current.fetch(utraAdjChannel = repcap.UtraAdjChannel.Default) \n
 		Return the ACLR for the first or second adjacent UTRA channel above (POSitiv) or below (NEGativ) the carrier frequency
 		for all measured list mode segments. The values described below are returned by FETCh commands. CALCulate commands return
 		limit check results instead, one value for each result listed below. \n
 		Suppressed linked return values: reliability \n
 			:param utraAdjChannel: optional repeated capability selector. Default value: Ch1 (settable in the interface 'Utra')
 			:return: utra_positiv: Comma-separated list of values, one per measured segment"""
-		utraAdjChannel_cmd_val = self._base.get_repcap_cmd_value(utraAdjChannel, repcap.UtraAdjChannel)
+		utraAdjChannel_cmd_val = self._cmd_group.get_repcap_cmd_value(utraAdjChannel, repcap.UtraAdjChannel)
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:ACLR:UTRA{utraAdjChannel_cmd_val}:POSitiv:CURRent?', suppressed)
 		return response
 
 	# noinspection PyTypeChecker
 	def calculate(self, utraAdjChannel=repcap.UtraAdjChannel.Default) -> List[enums.ResultStatus2]:
 		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:ACLR:UTRA<nr>:POSitiv:CURRent \n
-		Snippet: value: List[enums.ResultStatus2] = driver.multiEval.listPy.aclr.utra.positiv.current.calculate(utraAdjChannel = repcap.UtraAdjChannel.Default) \n
+		Snippet: value: List[enums.ResultStatus2] = driver.lteMeas.multiEval.listPy.aclr.utra.positiv.current.calculate(utraAdjChannel = repcap.UtraAdjChannel.Default) \n
 		Return the ACLR for the first or second adjacent UTRA channel above (POSitiv) or below (NEGativ) the carrier frequency
 		for all measured list mode segments. The values described below are returned by FETCh commands. CALCulate commands return
 		limit check results instead, one value for each result listed below. \n
 		Suppressed linked return values: reliability \n
 			:param utraAdjChannel: optional repeated capability selector. Default value: Ch1 (settable in the interface 'Utra')
 			:return: utra_positiv: Comma-separated list of values, one per measured segment"""
-		utraAdjChannel_cmd_val = self._base.get_repcap_cmd_value(utraAdjChannel, repcap.UtraAdjChannel)
+		utraAdjChannel_cmd_val = self._cmd_group.get_repcap_cmd_value(utraAdjChannel, repcap.UtraAdjChannel)
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:ACLR:UTRA{utraAdjChannel_cmd_val}:POSitiv:CURRent?', suppressed)
 		return Conversions.str_to_list_enum(response, enums.ResultStatus2)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/EsFlatness.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/SeMask/__init__.py`

 * *Files 21% similar despite different names*

```diff
@@ -1,59 +1,59 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class EsFlatness:
-	"""EsFlatness commands group definition. 30 total commands, 5 Sub-groups, 0 group commands"""
+class SeMaskCls:
+	"""SeMask commands group definition. 24 total commands, 5 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("esFlatness", core, parent)
+		self._cmd_group = CommandsGroup("seMask", core, parent)
 
 	@property
-	def ripple(self):
-		"""ripple commands group. 4 Sub-classes, 0 commands."""
-		if not hasattr(self, '_ripple'):
-			from .EsFlatness_.Ripple import Ripple
-			self._ripple = Ripple(self._core, self._base)
-		return self._ripple
+	def obw(self):
+		"""obw commands group. 4 Sub-classes, 0 commands."""
+		if not hasattr(self, '_obw'):
+			from .Obw import ObwCls
+			self._obw = ObwCls(self._core, self._cmd_group)
+		return self._obw
 
 	@property
-	def difference(self):
-		"""difference commands group. 4 Sub-classes, 0 commands."""
-		if not hasattr(self, '_difference'):
-			from .EsFlatness_.Difference import Difference
-			self._difference = Difference(self._core, self._base)
-		return self._difference
+	def txPower(self):
+		"""txPower commands group. 5 Sub-classes, 0 commands."""
+		if not hasattr(self, '_txPower'):
+			from .TxPower import TxPowerCls
+			self._txPower = TxPowerCls(self._core, self._cmd_group)
+		return self._txPower
 
 	@property
-	def minr(self):
-		"""minr commands group. 4 Sub-classes, 0 commands."""
-		if not hasattr(self, '_minr'):
-			from .EsFlatness_.Minr import Minr
-			self._minr = Minr(self._core, self._base)
-		return self._minr
+	def margin(self):
+		"""margin commands group. 1 Sub-classes, 0 commands."""
+		if not hasattr(self, '_margin'):
+			from .Margin import MarginCls
+			self._margin = MarginCls(self._core, self._cmd_group)
+		return self._margin
 
 	@property
-	def maxr(self):
-		"""maxr commands group. 4 Sub-classes, 0 commands."""
-		if not hasattr(self, '_maxr'):
-			from .EsFlatness_.Maxr import Maxr
-			self._maxr = Maxr(self._core, self._base)
-		return self._maxr
+	def dchType(self):
+		"""dchType commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_dchType'):
+			from .DchType import DchTypeCls
+			self._dchType = DchTypeCls(self._core, self._cmd_group)
+		return self._dchType
 
 	@property
-	def scIndex(self):
-		"""scIndex commands group. 2 Sub-classes, 0 commands."""
-		if not hasattr(self, '_scIndex'):
-			from .EsFlatness_.ScIndex import ScIndex
-			self._scIndex = ScIndex(self._core, self._base)
-		return self._scIndex
+	def dallocation(self):
+		"""dallocation commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_dallocation'):
+			from .Dallocation import DallocationCls
+			self._dallocation = DallocationCls(self._core, self._cmd_group)
+		return self._dallocation
 
-	def clone(self) -> 'EsFlatness':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'SeMaskCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = EsFlatness(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = SeMaskCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/Difference.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/EsFlatness/Difference/__init__.py`

 * *Files 11% similar despite different names*

```diff
@@ -1,66 +1,66 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
-from .....Internal.RepeatedCapability import RepeatedCapability
-from ..... import repcap
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal.RepeatedCapability import RepeatedCapability
+from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Difference:
-	"""Difference commands group definition. 7 total commands, 4 Sub-groups, 0 group commands
+class DifferenceCls:
+	"""Difference commands group definition. 7 total commands, 4 Subgroups, 0 group commands
 	Repeated Capability: Difference, default value after init: Difference.Nr1"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("difference", core, parent)
-		self._base.rep_cap = RepeatedCapability(self._base.group_name, 'repcap_difference_get', 'repcap_difference_set', repcap.Difference.Nr1)
+		self._cmd_group = CommandsGroup("difference", core, parent)
+		self._cmd_group.rep_cap = RepeatedCapability(self._cmd_group.group_name, 'repcap_difference_get', 'repcap_difference_set', repcap.Difference.Nr1)
 
-	def repcap_difference_set(self, enum_value: repcap.Difference) -> None:
+	def repcap_difference_set(self, difference: repcap.Difference) -> None:
 		"""Repeated Capability default value numeric suffix.
 		This value is used, if you do not explicitely set it in the child set/get methods, or if you leave it to Difference.Default
 		Default value after init: Difference.Nr1"""
-		self._base.set_repcap_enum_value(enum_value)
+		self._cmd_group.set_repcap_enum_value(difference)
 
 	def repcap_difference_get(self) -> repcap.Difference:
 		"""Returns the current default repeated capability for the child set/get methods"""
 		# noinspection PyTypeChecker
-		return self._base.get_repcap_enum_value()
+		return self._cmd_group.get_repcap_enum_value()
 
 	@property
 	def current(self):
 		"""current commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_current'):
-			from .Difference_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
 	@property
 	def average(self):
 		"""average commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_average'):
-			from .Difference_.Average import Average
-			self._average = Average(self._core, self._base)
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
 		return self._average
 
 	@property
 	def extreme(self):
 		"""extreme commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_extreme'):
-			from .Difference_.Extreme import Extreme
-			self._extreme = Extreme(self._core, self._base)
+			from .Extreme import ExtremeCls
+			self._extreme = ExtremeCls(self._core, self._cmd_group)
 		return self._extreme
 
 	@property
 	def standardDev(self):
 		"""standardDev commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_standardDev'):
-			from .Difference_.StandardDev import StandardDev
-			self._standardDev = StandardDev(self._core, self._base)
+			from .StandardDev import StandardDevCls
+			self._standardDev = StandardDevCls(self._core, self._cmd_group)
 		return self._standardDev
 
-	def clone(self) -> 'Difference':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'DifferenceCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Difference(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = DifferenceCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/Difference_/Average.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/EsFlatness/Difference/Average.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,44 +1,45 @@
 from typing import List
 
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ......Internal.Types import DataType
-from ...... import repcap
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal import Conversions
+from .......Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .......Internal.Types import DataType
+from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class AverageCls:
+	"""Average commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	def fetch(self, difference=repcap.Difference.Default) -> List[float]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:DIFFerence<nr>:AVERage \n
-		Snippet: value: List[float] = driver.multiEval.listPy.esFlatness.difference.average.fetch(difference = repcap.Difference.Default) \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.listPy.esFlatness.difference.average.fetch(difference = repcap.Difference.Default) \n
 		Return equalizer spectrum flatness single value results (differences between ranges) for all measured list mode segments.
 		The values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one
 		value for each result listed below. \n
 		Suppressed linked return values: reliability \n
 			:param difference: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Difference')
 			:return: difference: Comma-separated list of values, one per measured segment"""
-		difference_cmd_val = self._base.get_repcap_cmd_value(difference, repcap.Difference)
+		difference_cmd_val = self._cmd_group.get_repcap_cmd_value(difference, repcap.Difference)
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:DIFFerence{difference_cmd_val}:AVERage?', suppressed)
 		return response
 
-	def calculate(self, difference=repcap.Difference.Default) -> List[float]:
+	def calculate(self, difference=repcap.Difference.Default) -> List[float or bool]:
 		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:DIFFerence<nr>:AVERage \n
-		Snippet: value: List[float] = driver.multiEval.listPy.esFlatness.difference.average.calculate(difference = repcap.Difference.Default) \n
+		Snippet: value: List[float or bool] = driver.lteMeas.multiEval.listPy.esFlatness.difference.average.calculate(difference = repcap.Difference.Default) \n
 		Return equalizer spectrum flatness single value results (differences between ranges) for all measured list mode segments.
 		The values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one
 		value for each result listed below. \n
 		Suppressed linked return values: reliability \n
 			:param difference: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Difference')
-			:return: difference: Comma-separated list of values, one per measured segment"""
-		difference_cmd_val = self._base.get_repcap_cmd_value(difference, repcap.Difference)
+			:return: difference: (float or boolean items) Comma-separated list of values, one per measured segment"""
+		difference_cmd_val = self._cmd_group.get_repcap_cmd_value(difference, repcap.Difference)
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:DIFFerence{difference_cmd_val}:AVERage?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:DIFFerence{difference_cmd_val}:AVERage?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/Difference_/Current.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/EsFlatness/Difference/Current.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,44 +1,45 @@
 from typing import List
 
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ......Internal.Types import DataType
-from ...... import repcap
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal import Conversions
+from .......Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .......Internal.Types import DataType
+from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	def fetch(self, difference=repcap.Difference.Default) -> List[float]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:DIFFerence<nr>:CURRent \n
-		Snippet: value: List[float] = driver.multiEval.listPy.esFlatness.difference.current.fetch(difference = repcap.Difference.Default) \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.listPy.esFlatness.difference.current.fetch(difference = repcap.Difference.Default) \n
 		Return equalizer spectrum flatness single value results (differences between ranges) for all measured list mode segments.
 		The values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one
 		value for each result listed below. \n
 		Suppressed linked return values: reliability \n
 			:param difference: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Difference')
 			:return: difference: Comma-separated list of values, one per measured segment"""
-		difference_cmd_val = self._base.get_repcap_cmd_value(difference, repcap.Difference)
+		difference_cmd_val = self._cmd_group.get_repcap_cmd_value(difference, repcap.Difference)
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:DIFFerence{difference_cmd_val}:CURRent?', suppressed)
 		return response
 
-	def calculate(self, difference=repcap.Difference.Default) -> List[float]:
+	def calculate(self, difference=repcap.Difference.Default) -> List[float or bool]:
 		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:DIFFerence<nr>:CURRent \n
-		Snippet: value: List[float] = driver.multiEval.listPy.esFlatness.difference.current.calculate(difference = repcap.Difference.Default) \n
+		Snippet: value: List[float or bool] = driver.lteMeas.multiEval.listPy.esFlatness.difference.current.calculate(difference = repcap.Difference.Default) \n
 		Return equalizer spectrum flatness single value results (differences between ranges) for all measured list mode segments.
 		The values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one
 		value for each result listed below. \n
 		Suppressed linked return values: reliability \n
 			:param difference: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Difference')
-			:return: difference: Comma-separated list of values, one per measured segment"""
-		difference_cmd_val = self._base.get_repcap_cmd_value(difference, repcap.Difference)
+			:return: difference: (float or boolean items) Comma-separated list of values, one per measured segment"""
+		difference_cmd_val = self._cmd_group.get_repcap_cmd_value(difference, repcap.Difference)
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:DIFFerence{difference_cmd_val}:CURRent?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:DIFFerence{difference_cmd_val}:CURRent?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/Difference_/Extreme.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/EsFlatness/Difference/Extreme.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,44 +1,45 @@
 from typing import List
 
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ......Internal.Types import DataType
-from ...... import repcap
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal import Conversions
+from .......Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .......Internal.Types import DataType
+from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Extreme:
-	"""Extreme commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class ExtremeCls:
+	"""Extreme commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("extreme", core, parent)
+		self._cmd_group = CommandsGroup("extreme", core, parent)
 
 	def fetch(self, difference=repcap.Difference.Default) -> List[float]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:DIFFerence<nr>:EXTReme \n
-		Snippet: value: List[float] = driver.multiEval.listPy.esFlatness.difference.extreme.fetch(difference = repcap.Difference.Default) \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.listPy.esFlatness.difference.extreme.fetch(difference = repcap.Difference.Default) \n
 		Return equalizer spectrum flatness single value results (differences between ranges) for all measured list mode segments.
 		The values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one
 		value for each result listed below. \n
 		Suppressed linked return values: reliability \n
 			:param difference: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Difference')
 			:return: difference: Comma-separated list of values, one per measured segment"""
-		difference_cmd_val = self._base.get_repcap_cmd_value(difference, repcap.Difference)
+		difference_cmd_val = self._cmd_group.get_repcap_cmd_value(difference, repcap.Difference)
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:DIFFerence{difference_cmd_val}:EXTReme?', suppressed)
 		return response
 
-	def calculate(self, difference=repcap.Difference.Default) -> List[float]:
+	def calculate(self, difference=repcap.Difference.Default) -> List[float or bool]:
 		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:DIFFerence<nr>:EXTReme \n
-		Snippet: value: List[float] = driver.multiEval.listPy.esFlatness.difference.extreme.calculate(difference = repcap.Difference.Default) \n
+		Snippet: value: List[float or bool] = driver.lteMeas.multiEval.listPy.esFlatness.difference.extreme.calculate(difference = repcap.Difference.Default) \n
 		Return equalizer spectrum flatness single value results (differences between ranges) for all measured list mode segments.
 		The values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one
 		value for each result listed below. \n
 		Suppressed linked return values: reliability \n
 			:param difference: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Difference')
-			:return: difference: Comma-separated list of values, one per measured segment"""
-		difference_cmd_val = self._base.get_repcap_cmd_value(difference, repcap.Difference)
+			:return: difference: (float or boolean items) Comma-separated list of values, one per measured segment"""
+		difference_cmd_val = self._cmd_group.get_repcap_cmd_value(difference, repcap.Difference)
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:DIFFerence{difference_cmd_val}:EXTReme?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:DIFFerence{difference_cmd_val}:EXTReme?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/Difference_/StandardDev.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/EsFlatness/Difference/StandardDev.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,30 +1,30 @@
 from typing import List
 
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ......Internal.Types import DataType
-from ...... import repcap
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .......Internal.Types import DataType
+from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class StandardDev:
-	"""StandardDev commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class StandardDevCls:
+	"""StandardDev commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("standardDev", core, parent)
+		self._cmd_group = CommandsGroup("standardDev", core, parent)
 
 	def fetch(self, difference=repcap.Difference.Default) -> List[float]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:DIFFerence<nr>:SDEViation \n
-		Snippet: value: List[float] = driver.multiEval.listPy.esFlatness.difference.standardDev.fetch(difference = repcap.Difference.Default) \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.listPy.esFlatness.difference.standardDev.fetch(difference = repcap.Difference.Default) \n
 		Return equalizer spectrum flatness single value results (differences between ranges) for all measured list mode segments.
 		The values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one
 		value for each result listed below. \n
 		Suppressed linked return values: reliability \n
 			:param difference: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Difference')
 			:return: difference: Comma-separated list of values, one per measured segment"""
-		difference_cmd_val = self._base.get_repcap_cmd_value(difference, repcap.Difference)
+		difference_cmd_val = self._cmd_group.get_repcap_cmd_value(difference, repcap.Difference)
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:DIFFerence{difference_cmd_val}:SDEViation?', suppressed)
 		return response
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/Maxr.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/EsFlatness/Minr/__init__.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,66 +1,66 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
-from .....Internal.RepeatedCapability import RepeatedCapability
-from ..... import repcap
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal.RepeatedCapability import RepeatedCapability
+from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Maxr:
-	"""Maxr commands group definition. 7 total commands, 4 Sub-groups, 0 group commands
-	Repeated Capability: MaxRange, default value after init: MaxRange.Nr1"""
+class MinrCls:
+	"""Minr commands group definition. 7 total commands, 4 Subgroups, 0 group commands
+	Repeated Capability: MinRange, default value after init: MinRange.Nr1"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("maxr", core, parent)
-		self._base.rep_cap = RepeatedCapability(self._base.group_name, 'repcap_maxRange_get', 'repcap_maxRange_set', repcap.MaxRange.Nr1)
+		self._cmd_group = CommandsGroup("minr", core, parent)
+		self._cmd_group.rep_cap = RepeatedCapability(self._cmd_group.group_name, 'repcap_minRange_get', 'repcap_minRange_set', repcap.MinRange.Nr1)
 
-	def repcap_maxRange_set(self, enum_value: repcap.MaxRange) -> None:
+	def repcap_minRange_set(self, minRange: repcap.MinRange) -> None:
 		"""Repeated Capability default value numeric suffix.
-		This value is used, if you do not explicitely set it in the child set/get methods, or if you leave it to MaxRange.Default
-		Default value after init: MaxRange.Nr1"""
-		self._base.set_repcap_enum_value(enum_value)
+		This value is used, if you do not explicitely set it in the child set/get methods, or if you leave it to MinRange.Default
+		Default value after init: MinRange.Nr1"""
+		self._cmd_group.set_repcap_enum_value(minRange)
 
-	def repcap_maxRange_get(self) -> repcap.MaxRange:
+	def repcap_minRange_get(self) -> repcap.MinRange:
 		"""Returns the current default repeated capability for the child set/get methods"""
 		# noinspection PyTypeChecker
-		return self._base.get_repcap_enum_value()
+		return self._cmd_group.get_repcap_enum_value()
 
 	@property
 	def current(self):
 		"""current commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_current'):
-			from .Maxr_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
 	@property
 	def average(self):
 		"""average commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_average'):
-			from .Maxr_.Average import Average
-			self._average = Average(self._core, self._base)
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
 		return self._average
 
 	@property
 	def extreme(self):
 		"""extreme commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_extreme'):
-			from .Maxr_.Extreme import Extreme
-			self._extreme = Extreme(self._core, self._base)
+			from .Extreme import ExtremeCls
+			self._extreme = ExtremeCls(self._core, self._cmd_group)
 		return self._extreme
 
 	@property
 	def standardDev(self):
 		"""standardDev commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_standardDev'):
-			from .Maxr_.StandardDev import StandardDev
-			self._standardDev = StandardDev(self._core, self._base)
+			from .StandardDev import StandardDevCls
+			self._standardDev = StandardDevCls(self._core, self._cmd_group)
 		return self._standardDev
 
-	def clone(self) -> 'Maxr':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'MinrCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Maxr(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = MinrCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/Maxr_/Average.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/EsFlatness/Maxr/Average.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,44 +1,45 @@
 from typing import List
 
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ......Internal.Types import DataType
-from ...... import repcap
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal import Conversions
+from .......Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .......Internal.Types import DataType
+from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class AverageCls:
+	"""Average commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	def fetch(self, maxRange=repcap.MaxRange.Default) -> List[float]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:MAXR<nr>:AVERage \n
-		Snippet: value: List[float] = driver.multiEval.listPy.esFlatness.maxr.average.fetch(maxRange = repcap.MaxRange.Default) \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.listPy.esFlatness.maxr.average.fetch(maxRange = repcap.MaxRange.Default) \n
 		Return equalizer spectrum flatness single value results (maximum within a range) for all measured list mode segments. The
 		values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value
 		for each result listed below. \n
 		Suppressed linked return values: reliability \n
 			:param maxRange: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Maxr')
-			:return: maxr: Comma-separated list of values, one per measured segment"""
-		maxRange_cmd_val = self._base.get_repcap_cmd_value(maxRange, repcap.MaxRange)
+			:return: maxr: Comma-separated list of values, one per measured segment."""
+		maxRange_cmd_val = self._cmd_group.get_repcap_cmd_value(maxRange, repcap.MaxRange)
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:MAXR{maxRange_cmd_val}:AVERage?', suppressed)
 		return response
 
-	def calculate(self, maxRange=repcap.MaxRange.Default) -> List[float]:
+	def calculate(self, maxRange=repcap.MaxRange.Default) -> List[float or bool]:
 		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:MAXR<nr>:AVERage \n
-		Snippet: value: List[float] = driver.multiEval.listPy.esFlatness.maxr.average.calculate(maxRange = repcap.MaxRange.Default) \n
+		Snippet: value: List[float or bool] = driver.lteMeas.multiEval.listPy.esFlatness.maxr.average.calculate(maxRange = repcap.MaxRange.Default) \n
 		Return equalizer spectrum flatness single value results (maximum within a range) for all measured list mode segments. The
 		values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value
 		for each result listed below. \n
 		Suppressed linked return values: reliability \n
 			:param maxRange: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Maxr')
-			:return: maxr: Comma-separated list of values, one per measured segment"""
-		maxRange_cmd_val = self._base.get_repcap_cmd_value(maxRange, repcap.MaxRange)
+			:return: maxr: (float or boolean items) Comma-separated list of values, one per measured segment."""
+		maxRange_cmd_val = self._cmd_group.get_repcap_cmd_value(maxRange, repcap.MaxRange)
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:MAXR{maxRange_cmd_val}:AVERage?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:MAXR{maxRange_cmd_val}:AVERage?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/Maxr_/Current.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/EsFlatness/Maxr/Current.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,44 +1,45 @@
 from typing import List
 
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ......Internal.Types import DataType
-from ...... import repcap
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal import Conversions
+from .......Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .......Internal.Types import DataType
+from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	def fetch(self, maxRange=repcap.MaxRange.Default) -> List[float]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:MAXR<nr>:CURRent \n
-		Snippet: value: List[float] = driver.multiEval.listPy.esFlatness.maxr.current.fetch(maxRange = repcap.MaxRange.Default) \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.listPy.esFlatness.maxr.current.fetch(maxRange = repcap.MaxRange.Default) \n
 		Return equalizer spectrum flatness single value results (maximum within a range) for all measured list mode segments. The
 		values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value
 		for each result listed below. \n
 		Suppressed linked return values: reliability \n
 			:param maxRange: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Maxr')
-			:return: maxr: Comma-separated list of values, one per measured segment"""
-		maxRange_cmd_val = self._base.get_repcap_cmd_value(maxRange, repcap.MaxRange)
+			:return: maxr: Comma-separated list of values, one per measured segment."""
+		maxRange_cmd_val = self._cmd_group.get_repcap_cmd_value(maxRange, repcap.MaxRange)
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:MAXR{maxRange_cmd_val}:CURRent?', suppressed)
 		return response
 
-	def calculate(self, maxRange=repcap.MaxRange.Default) -> List[float]:
+	def calculate(self, maxRange=repcap.MaxRange.Default) -> List[float or bool]:
 		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:MAXR<nr>:CURRent \n
-		Snippet: value: List[float] = driver.multiEval.listPy.esFlatness.maxr.current.calculate(maxRange = repcap.MaxRange.Default) \n
+		Snippet: value: List[float or bool] = driver.lteMeas.multiEval.listPy.esFlatness.maxr.current.calculate(maxRange = repcap.MaxRange.Default) \n
 		Return equalizer spectrum flatness single value results (maximum within a range) for all measured list mode segments. The
 		values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value
 		for each result listed below. \n
 		Suppressed linked return values: reliability \n
 			:param maxRange: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Maxr')
-			:return: maxr: Comma-separated list of values, one per measured segment"""
-		maxRange_cmd_val = self._base.get_repcap_cmd_value(maxRange, repcap.MaxRange)
+			:return: maxr: (float or boolean items) Comma-separated list of values, one per measured segment."""
+		maxRange_cmd_val = self._cmd_group.get_repcap_cmd_value(maxRange, repcap.MaxRange)
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:MAXR{maxRange_cmd_val}:CURRent?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:MAXR{maxRange_cmd_val}:CURRent?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/Maxr_/Extreme.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/EsFlatness/Maxr/Extreme.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,44 +1,45 @@
 from typing import List
 
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ......Internal.Types import DataType
-from ...... import repcap
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal import Conversions
+from .......Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .......Internal.Types import DataType
+from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Extreme:
-	"""Extreme commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class ExtremeCls:
+	"""Extreme commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("extreme", core, parent)
+		self._cmd_group = CommandsGroup("extreme", core, parent)
 
 	def fetch(self, maxRange=repcap.MaxRange.Default) -> List[float]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:MAXR<nr>:EXTReme \n
-		Snippet: value: List[float] = driver.multiEval.listPy.esFlatness.maxr.extreme.fetch(maxRange = repcap.MaxRange.Default) \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.listPy.esFlatness.maxr.extreme.fetch(maxRange = repcap.MaxRange.Default) \n
 		Return equalizer spectrum flatness single value results (maximum within a range) for all measured list mode segments. The
 		values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value
 		for each result listed below. \n
 		Suppressed linked return values: reliability \n
 			:param maxRange: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Maxr')
-			:return: maxr: Comma-separated list of values, one per measured segment"""
-		maxRange_cmd_val = self._base.get_repcap_cmd_value(maxRange, repcap.MaxRange)
+			:return: maxr: Comma-separated list of values, one per measured segment."""
+		maxRange_cmd_val = self._cmd_group.get_repcap_cmd_value(maxRange, repcap.MaxRange)
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:MAXR{maxRange_cmd_val}:EXTReme?', suppressed)
 		return response
 
-	def calculate(self, maxRange=repcap.MaxRange.Default) -> List[float]:
+	def calculate(self, maxRange=repcap.MaxRange.Default) -> List[float or bool]:
 		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:MAXR<nr>:EXTReme \n
-		Snippet: value: List[float] = driver.multiEval.listPy.esFlatness.maxr.extreme.calculate(maxRange = repcap.MaxRange.Default) \n
+		Snippet: value: List[float or bool] = driver.lteMeas.multiEval.listPy.esFlatness.maxr.extreme.calculate(maxRange = repcap.MaxRange.Default) \n
 		Return equalizer spectrum flatness single value results (maximum within a range) for all measured list mode segments. The
 		values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value
 		for each result listed below. \n
 		Suppressed linked return values: reliability \n
 			:param maxRange: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Maxr')
-			:return: maxr: Comma-separated list of values, one per measured segment"""
-		maxRange_cmd_val = self._base.get_repcap_cmd_value(maxRange, repcap.MaxRange)
+			:return: maxr: (float or boolean items) Comma-separated list of values, one per measured segment."""
+		maxRange_cmd_val = self._cmd_group.get_repcap_cmd_value(maxRange, repcap.MaxRange)
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:MAXR{maxRange_cmd_val}:EXTReme?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:MAXR{maxRange_cmd_val}:EXTReme?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/Maxr_/StandardDev.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/EsFlatness/Maxr/StandardDev.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,30 +1,30 @@
 from typing import List
 
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ......Internal.Types import DataType
-from ...... import repcap
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .......Internal.Types import DataType
+from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class StandardDev:
-	"""StandardDev commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class StandardDevCls:
+	"""StandardDev commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("standardDev", core, parent)
+		self._cmd_group = CommandsGroup("standardDev", core, parent)
 
 	def fetch(self, maxRange=repcap.MaxRange.Default) -> List[float]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:MAXR<nr>:SDEViation \n
-		Snippet: value: List[float] = driver.multiEval.listPy.esFlatness.maxr.standardDev.fetch(maxRange = repcap.MaxRange.Default) \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.listPy.esFlatness.maxr.standardDev.fetch(maxRange = repcap.MaxRange.Default) \n
 		Return equalizer spectrum flatness single value results (maximum within a range) for all measured list mode segments. The
 		values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value
 		for each result listed below. \n
 		Suppressed linked return values: reliability \n
 			:param maxRange: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Maxr')
-			:return: maxr: Comma-separated list of values, one per measured segment"""
-		maxRange_cmd_val = self._base.get_repcap_cmd_value(maxRange, repcap.MaxRange)
+			:return: maxr: Comma-separated list of values, one per measured segment."""
+		maxRange_cmd_val = self._cmd_group.get_repcap_cmd_value(maxRange, repcap.MaxRange)
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:MAXR{maxRange_cmd_val}:SDEViation?', suppressed)
 		return response
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/Minr.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/EsFlatness/Maxr/__init__.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,66 +1,66 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
-from .....Internal.RepeatedCapability import RepeatedCapability
-from ..... import repcap
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal.RepeatedCapability import RepeatedCapability
+from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Minr:
-	"""Minr commands group definition. 7 total commands, 4 Sub-groups, 0 group commands
-	Repeated Capability: MinRange, default value after init: MinRange.Nr1"""
+class MaxrCls:
+	"""Maxr commands group definition. 7 total commands, 4 Subgroups, 0 group commands
+	Repeated Capability: MaxRange, default value after init: MaxRange.Nr1"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("minr", core, parent)
-		self._base.rep_cap = RepeatedCapability(self._base.group_name, 'repcap_minRange_get', 'repcap_minRange_set', repcap.MinRange.Nr1)
+		self._cmd_group = CommandsGroup("maxr", core, parent)
+		self._cmd_group.rep_cap = RepeatedCapability(self._cmd_group.group_name, 'repcap_maxRange_get', 'repcap_maxRange_set', repcap.MaxRange.Nr1)
 
-	def repcap_minRange_set(self, enum_value: repcap.MinRange) -> None:
+	def repcap_maxRange_set(self, maxRange: repcap.MaxRange) -> None:
 		"""Repeated Capability default value numeric suffix.
-		This value is used, if you do not explicitely set it in the child set/get methods, or if you leave it to MinRange.Default
-		Default value after init: MinRange.Nr1"""
-		self._base.set_repcap_enum_value(enum_value)
+		This value is used, if you do not explicitely set it in the child set/get methods, or if you leave it to MaxRange.Default
+		Default value after init: MaxRange.Nr1"""
+		self._cmd_group.set_repcap_enum_value(maxRange)
 
-	def repcap_minRange_get(self) -> repcap.MinRange:
+	def repcap_maxRange_get(self) -> repcap.MaxRange:
 		"""Returns the current default repeated capability for the child set/get methods"""
 		# noinspection PyTypeChecker
-		return self._base.get_repcap_enum_value()
+		return self._cmd_group.get_repcap_enum_value()
 
 	@property
 	def current(self):
 		"""current commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_current'):
-			from .Minr_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
 	@property
 	def average(self):
 		"""average commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_average'):
-			from .Minr_.Average import Average
-			self._average = Average(self._core, self._base)
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
 		return self._average
 
 	@property
 	def extreme(self):
 		"""extreme commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_extreme'):
-			from .Minr_.Extreme import Extreme
-			self._extreme = Extreme(self._core, self._base)
+			from .Extreme import ExtremeCls
+			self._extreme = ExtremeCls(self._core, self._cmd_group)
 		return self._extreme
 
 	@property
 	def standardDev(self):
 		"""standardDev commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_standardDev'):
-			from .Minr_.StandardDev import StandardDev
-			self._standardDev = StandardDev(self._core, self._base)
+			from .StandardDev import StandardDevCls
+			self._standardDev = StandardDevCls(self._core, self._cmd_group)
 		return self._standardDev
 
-	def clone(self) -> 'Minr':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'MaxrCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Minr(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = MaxrCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/Minr_/Average.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/EsFlatness/Minr/Average.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,44 +1,45 @@
 from typing import List
 
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ......Internal.Types import DataType
-from ...... import repcap
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal import Conversions
+from .......Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .......Internal.Types import DataType
+from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class AverageCls:
+	"""Average commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	def fetch(self, minRange=repcap.MinRange.Default) -> List[float]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:MINR<nr>:AVERage \n
-		Snippet: value: List[float] = driver.multiEval.listPy.esFlatness.minr.average.fetch(minRange = repcap.MinRange.Default) \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.listPy.esFlatness.minr.average.fetch(minRange = repcap.MinRange.Default) \n
 		Return equalizer spectrum flatness single value results (minimum within a range) for all measured list mode segments. The
 		values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value
 		for each result listed below. \n
 		Suppressed linked return values: reliability \n
 			:param minRange: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Minr')
-			:return: minr: Comma-separated list of values, one per measured segment"""
-		minRange_cmd_val = self._base.get_repcap_cmd_value(minRange, repcap.MinRange)
+			:return: minr: Comma-separated list of values, one per measured segment."""
+		minRange_cmd_val = self._cmd_group.get_repcap_cmd_value(minRange, repcap.MinRange)
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:MINR{minRange_cmd_val}:AVERage?', suppressed)
 		return response
 
-	def calculate(self, minRange=repcap.MinRange.Default) -> List[float]:
+	def calculate(self, minRange=repcap.MinRange.Default) -> List[float or bool]:
 		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:MINR<nr>:AVERage \n
-		Snippet: value: List[float] = driver.multiEval.listPy.esFlatness.minr.average.calculate(minRange = repcap.MinRange.Default) \n
+		Snippet: value: List[float or bool] = driver.lteMeas.multiEval.listPy.esFlatness.minr.average.calculate(minRange = repcap.MinRange.Default) \n
 		Return equalizer spectrum flatness single value results (minimum within a range) for all measured list mode segments. The
 		values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value
 		for each result listed below. \n
 		Suppressed linked return values: reliability \n
 			:param minRange: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Minr')
-			:return: minr: Comma-separated list of values, one per measured segment"""
-		minRange_cmd_val = self._base.get_repcap_cmd_value(minRange, repcap.MinRange)
+			:return: minr: (float or boolean items) Comma-separated list of values, one per measured segment."""
+		minRange_cmd_val = self._cmd_group.get_repcap_cmd_value(minRange, repcap.MinRange)
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:MINR{minRange_cmd_val}:AVERage?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:MINR{minRange_cmd_val}:AVERage?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/Minr_/Current.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/EsFlatness/Minr/Current.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,44 +1,45 @@
 from typing import List
 
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ......Internal.Types import DataType
-from ...... import repcap
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal import Conversions
+from .......Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .......Internal.Types import DataType
+from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	def fetch(self, minRange=repcap.MinRange.Default) -> List[float]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:MINR<nr>:CURRent \n
-		Snippet: value: List[float] = driver.multiEval.listPy.esFlatness.minr.current.fetch(minRange = repcap.MinRange.Default) \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.listPy.esFlatness.minr.current.fetch(minRange = repcap.MinRange.Default) \n
 		Return equalizer spectrum flatness single value results (minimum within a range) for all measured list mode segments. The
 		values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value
 		for each result listed below. \n
 		Suppressed linked return values: reliability \n
 			:param minRange: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Minr')
-			:return: minr: Comma-separated list of values, one per measured segment"""
-		minRange_cmd_val = self._base.get_repcap_cmd_value(minRange, repcap.MinRange)
+			:return: minr: Comma-separated list of values, one per measured segment."""
+		minRange_cmd_val = self._cmd_group.get_repcap_cmd_value(minRange, repcap.MinRange)
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:MINR{minRange_cmd_val}:CURRent?', suppressed)
 		return response
 
-	def calculate(self, minRange=repcap.MinRange.Default) -> List[float]:
+	def calculate(self, minRange=repcap.MinRange.Default) -> List[float or bool]:
 		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:MINR<nr>:CURRent \n
-		Snippet: value: List[float] = driver.multiEval.listPy.esFlatness.minr.current.calculate(minRange = repcap.MinRange.Default) \n
+		Snippet: value: List[float or bool] = driver.lteMeas.multiEval.listPy.esFlatness.minr.current.calculate(minRange = repcap.MinRange.Default) \n
 		Return equalizer spectrum flatness single value results (minimum within a range) for all measured list mode segments. The
 		values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value
 		for each result listed below. \n
 		Suppressed linked return values: reliability \n
 			:param minRange: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Minr')
-			:return: minr: Comma-separated list of values, one per measured segment"""
-		minRange_cmd_val = self._base.get_repcap_cmd_value(minRange, repcap.MinRange)
+			:return: minr: (float or boolean items) Comma-separated list of values, one per measured segment."""
+		minRange_cmd_val = self._cmd_group.get_repcap_cmd_value(minRange, repcap.MinRange)
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:MINR{minRange_cmd_val}:CURRent?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:MINR{minRange_cmd_val}:CURRent?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/Minr_/Extreme.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/EsFlatness/Minr/Extreme.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,44 +1,45 @@
 from typing import List
 
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ......Internal.Types import DataType
-from ...... import repcap
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal import Conversions
+from .......Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .......Internal.Types import DataType
+from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Extreme:
-	"""Extreme commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class ExtremeCls:
+	"""Extreme commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("extreme", core, parent)
+		self._cmd_group = CommandsGroup("extreme", core, parent)
 
 	def fetch(self, minRange=repcap.MinRange.Default) -> List[float]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:MINR<nr>:EXTReme \n
-		Snippet: value: List[float] = driver.multiEval.listPy.esFlatness.minr.extreme.fetch(minRange = repcap.MinRange.Default) \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.listPy.esFlatness.minr.extreme.fetch(minRange = repcap.MinRange.Default) \n
 		Return equalizer spectrum flatness single value results (minimum within a range) for all measured list mode segments. The
 		values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value
 		for each result listed below. \n
 		Suppressed linked return values: reliability \n
 			:param minRange: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Minr')
-			:return: minr: Comma-separated list of values, one per measured segment"""
-		minRange_cmd_val = self._base.get_repcap_cmd_value(minRange, repcap.MinRange)
+			:return: minr: Comma-separated list of values, one per measured segment."""
+		minRange_cmd_val = self._cmd_group.get_repcap_cmd_value(minRange, repcap.MinRange)
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:MINR{minRange_cmd_val}:EXTReme?', suppressed)
 		return response
 
-	def calculate(self, minRange=repcap.MinRange.Default) -> List[float]:
+	def calculate(self, minRange=repcap.MinRange.Default) -> List[float or bool]:
 		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:MINR<nr>:EXTReme \n
-		Snippet: value: List[float] = driver.multiEval.listPy.esFlatness.minr.extreme.calculate(minRange = repcap.MinRange.Default) \n
+		Snippet: value: List[float or bool] = driver.lteMeas.multiEval.listPy.esFlatness.minr.extreme.calculate(minRange = repcap.MinRange.Default) \n
 		Return equalizer spectrum flatness single value results (minimum within a range) for all measured list mode segments. The
 		values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value
 		for each result listed below. \n
 		Suppressed linked return values: reliability \n
 			:param minRange: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Minr')
-			:return: minr: Comma-separated list of values, one per measured segment"""
-		minRange_cmd_val = self._base.get_repcap_cmd_value(minRange, repcap.MinRange)
+			:return: minr: (float or boolean items) Comma-separated list of values, one per measured segment."""
+		minRange_cmd_val = self._cmd_group.get_repcap_cmd_value(minRange, repcap.MinRange)
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:MINR{minRange_cmd_val}:EXTReme?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:MINR{minRange_cmd_val}:EXTReme?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/Minr_/StandardDev.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/EsFlatness/Minr/StandardDev.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,30 +1,30 @@
 from typing import List
 
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ......Internal.Types import DataType
-from ...... import repcap
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .......Internal.Types import DataType
+from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class StandardDev:
-	"""StandardDev commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class StandardDevCls:
+	"""StandardDev commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("standardDev", core, parent)
+		self._cmd_group = CommandsGroup("standardDev", core, parent)
 
 	def fetch(self, minRange=repcap.MinRange.Default) -> List[float]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:MINR<nr>:SDEViation \n
-		Snippet: value: List[float] = driver.multiEval.listPy.esFlatness.minr.standardDev.fetch(minRange = repcap.MinRange.Default) \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.listPy.esFlatness.minr.standardDev.fetch(minRange = repcap.MinRange.Default) \n
 		Return equalizer spectrum flatness single value results (minimum within a range) for all measured list mode segments. The
 		values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value
 		for each result listed below. \n
 		Suppressed linked return values: reliability \n
 			:param minRange: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Minr')
-			:return: minr: Comma-separated list of values, one per measured segment"""
-		minRange_cmd_val = self._base.get_repcap_cmd_value(minRange, repcap.MinRange)
+			:return: minr: Comma-separated list of values, one per measured segment."""
+		minRange_cmd_val = self._cmd_group.get_repcap_cmd_value(minRange, repcap.MinRange)
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:MINR{minRange_cmd_val}:SDEViation?', suppressed)
 		return response
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/Ripple.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/EsFlatness/Ripple/__init__.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,66 +1,66 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
-from .....Internal.RepeatedCapability import RepeatedCapability
-from ..... import repcap
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal.RepeatedCapability import RepeatedCapability
+from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Ripple:
-	"""Ripple commands group definition. 7 total commands, 4 Sub-groups, 0 group commands
+class RippleCls:
+	"""Ripple commands group definition. 7 total commands, 4 Subgroups, 0 group commands
 	Repeated Capability: Ripple, default value after init: Ripple.Nr1"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("ripple", core, parent)
-		self._base.rep_cap = RepeatedCapability(self._base.group_name, 'repcap_ripple_get', 'repcap_ripple_set', repcap.Ripple.Nr1)
+		self._cmd_group = CommandsGroup("ripple", core, parent)
+		self._cmd_group.rep_cap = RepeatedCapability(self._cmd_group.group_name, 'repcap_ripple_get', 'repcap_ripple_set', repcap.Ripple.Nr1)
 
-	def repcap_ripple_set(self, enum_value: repcap.Ripple) -> None:
+	def repcap_ripple_set(self, ripple: repcap.Ripple) -> None:
 		"""Repeated Capability default value numeric suffix.
 		This value is used, if you do not explicitely set it in the child set/get methods, or if you leave it to Ripple.Default
 		Default value after init: Ripple.Nr1"""
-		self._base.set_repcap_enum_value(enum_value)
+		self._cmd_group.set_repcap_enum_value(ripple)
 
 	def repcap_ripple_get(self) -> repcap.Ripple:
 		"""Returns the current default repeated capability for the child set/get methods"""
 		# noinspection PyTypeChecker
-		return self._base.get_repcap_enum_value()
+		return self._cmd_group.get_repcap_enum_value()
 
 	@property
 	def current(self):
 		"""current commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_current'):
-			from .Ripple_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
 	@property
 	def average(self):
 		"""average commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_average'):
-			from .Ripple_.Average import Average
-			self._average = Average(self._core, self._base)
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
 		return self._average
 
 	@property
 	def extreme(self):
 		"""extreme commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_extreme'):
-			from .Ripple_.Extreme import Extreme
-			self._extreme = Extreme(self._core, self._base)
+			from .Extreme import ExtremeCls
+			self._extreme = ExtremeCls(self._core, self._cmd_group)
 		return self._extreme
 
 	@property
 	def standardDev(self):
 		"""standardDev commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_standardDev'):
-			from .Ripple_.StandardDev import StandardDev
-			self._standardDev = StandardDev(self._core, self._base)
+			from .StandardDev import StandardDevCls
+			self._standardDev = StandardDevCls(self._core, self._cmd_group)
 		return self._standardDev
 
-	def clone(self) -> 'Ripple':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'RippleCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Ripple(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = RippleCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/Ripple_/Average.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/EsFlatness/Ripple/Current.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,44 +1,45 @@
 from typing import List
 
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ......Internal.Types import DataType
-from ...... import repcap
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal import Conversions
+from .......Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .......Internal.Types import DataType
+from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	def fetch(self, ripple=repcap.Ripple.Default) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:RIPPle<nr>:AVERage \n
-		Snippet: value: List[float] = driver.multiEval.listPy.esFlatness.ripple.average.fetch(ripple = repcap.Ripple.Default) \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:RIPPle<nr>:CURRent \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.listPy.esFlatness.ripple.current.fetch(ripple = repcap.Ripple.Default) \n
 		Return equalizer spectrum flatness single value results (ripple 1 or ripple 2) for all measured list mode segments. The
 		values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value
 		for each result listed below. \n
 		Suppressed linked return values: reliability \n
 			:param ripple: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Ripple')
 			:return: ripple: Comma-separated list of values, one per measured segment"""
-		ripple_cmd_val = self._base.get_repcap_cmd_value(ripple, repcap.Ripple)
+		ripple_cmd_val = self._cmd_group.get_repcap_cmd_value(ripple, repcap.Ripple)
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:RIPPle{ripple_cmd_val}:AVERage?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:RIPPle{ripple_cmd_val}:CURRent?', suppressed)
 		return response
 
-	def calculate(self, ripple=repcap.Ripple.Default) -> List[float]:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:RIPPle<nr>:AVERage \n
-		Snippet: value: List[float] = driver.multiEval.listPy.esFlatness.ripple.average.calculate(ripple = repcap.Ripple.Default) \n
+	def calculate(self, ripple=repcap.Ripple.Default) -> List[float or bool]:
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:RIPPle<nr>:CURRent \n
+		Snippet: value: List[float or bool] = driver.lteMeas.multiEval.listPy.esFlatness.ripple.current.calculate(ripple = repcap.Ripple.Default) \n
 		Return equalizer spectrum flatness single value results (ripple 1 or ripple 2) for all measured list mode segments. The
 		values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value
 		for each result listed below. \n
 		Suppressed linked return values: reliability \n
 			:param ripple: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Ripple')
-			:return: ripple: Comma-separated list of values, one per measured segment"""
-		ripple_cmd_val = self._base.get_repcap_cmd_value(ripple, repcap.Ripple)
+			:return: ripple: (float or boolean items) Comma-separated list of values, one per measured segment"""
+		ripple_cmd_val = self._cmd_group.get_repcap_cmd_value(ripple, repcap.Ripple)
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:RIPPle{ripple_cmd_val}:AVERage?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:RIPPle{ripple_cmd_val}:CURRent?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/Ripple_/Current.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/EsFlatness/Ripple/Average.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,44 +1,45 @@
 from typing import List
 
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ......Internal.Types import DataType
-from ...... import repcap
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal import Conversions
+from .......Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .......Internal.Types import DataType
+from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class AverageCls:
+	"""Average commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	def fetch(self, ripple=repcap.Ripple.Default) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:RIPPle<nr>:CURRent \n
-		Snippet: value: List[float] = driver.multiEval.listPy.esFlatness.ripple.current.fetch(ripple = repcap.Ripple.Default) \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:RIPPle<nr>:AVERage \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.listPy.esFlatness.ripple.average.fetch(ripple = repcap.Ripple.Default) \n
 		Return equalizer spectrum flatness single value results (ripple 1 or ripple 2) for all measured list mode segments. The
 		values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value
 		for each result listed below. \n
 		Suppressed linked return values: reliability \n
 			:param ripple: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Ripple')
 			:return: ripple: Comma-separated list of values, one per measured segment"""
-		ripple_cmd_val = self._base.get_repcap_cmd_value(ripple, repcap.Ripple)
+		ripple_cmd_val = self._cmd_group.get_repcap_cmd_value(ripple, repcap.Ripple)
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:RIPPle{ripple_cmd_val}:CURRent?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:RIPPle{ripple_cmd_val}:AVERage?', suppressed)
 		return response
 
-	def calculate(self, ripple=repcap.Ripple.Default) -> List[float]:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:RIPPle<nr>:CURRent \n
-		Snippet: value: List[float] = driver.multiEval.listPy.esFlatness.ripple.current.calculate(ripple = repcap.Ripple.Default) \n
+	def calculate(self, ripple=repcap.Ripple.Default) -> List[float or bool]:
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:RIPPle<nr>:AVERage \n
+		Snippet: value: List[float or bool] = driver.lteMeas.multiEval.listPy.esFlatness.ripple.average.calculate(ripple = repcap.Ripple.Default) \n
 		Return equalizer spectrum flatness single value results (ripple 1 or ripple 2) for all measured list mode segments. The
 		values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value
 		for each result listed below. \n
 		Suppressed linked return values: reliability \n
 			:param ripple: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Ripple')
-			:return: ripple: Comma-separated list of values, one per measured segment"""
-		ripple_cmd_val = self._base.get_repcap_cmd_value(ripple, repcap.Ripple)
+			:return: ripple: (float or boolean items) Comma-separated list of values, one per measured segment"""
+		ripple_cmd_val = self._cmd_group.get_repcap_cmd_value(ripple, repcap.Ripple)
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:RIPPle{ripple_cmd_val}:CURRent?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:RIPPle{ripple_cmd_val}:AVERage?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/Ripple_/Extreme.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/EsFlatness/Ripple/StandardDev.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,44 +1,30 @@
 from typing import List
 
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ......Internal.Types import DataType
-from ...... import repcap
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .......Internal.Types import DataType
+from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Extreme:
-	"""Extreme commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class StandardDevCls:
+	"""StandardDev commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("extreme", core, parent)
+		self._cmd_group = CommandsGroup("standardDev", core, parent)
 
 	def fetch(self, ripple=repcap.Ripple.Default) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:RIPPle<nr>:EXTReme \n
-		Snippet: value: List[float] = driver.multiEval.listPy.esFlatness.ripple.extreme.fetch(ripple = repcap.Ripple.Default) \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:RIPPle<nr>:SDEViation \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.listPy.esFlatness.ripple.standardDev.fetch(ripple = repcap.Ripple.Default) \n
 		Return equalizer spectrum flatness single value results (ripple 1 or ripple 2) for all measured list mode segments. The
 		values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value
 		for each result listed below. \n
 		Suppressed linked return values: reliability \n
 			:param ripple: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Ripple')
 			:return: ripple: Comma-separated list of values, one per measured segment"""
-		ripple_cmd_val = self._base.get_repcap_cmd_value(ripple, repcap.Ripple)
+		ripple_cmd_val = self._cmd_group.get_repcap_cmd_value(ripple, repcap.Ripple)
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:RIPPle{ripple_cmd_val}:EXTReme?', suppressed)
-		return response
-
-	def calculate(self, ripple=repcap.Ripple.Default) -> List[float]:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:RIPPle<nr>:EXTReme \n
-		Snippet: value: List[float] = driver.multiEval.listPy.esFlatness.ripple.extreme.calculate(ripple = repcap.Ripple.Default) \n
-		Return equalizer spectrum flatness single value results (ripple 1 or ripple 2) for all measured list mode segments. The
-		values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value
-		for each result listed below. \n
-		Suppressed linked return values: reliability \n
-			:param ripple: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Ripple')
-			:return: ripple: Comma-separated list of values, one per measured segment"""
-		ripple_cmd_val = self._base.get_repcap_cmd_value(ripple, repcap.Ripple)
-		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:RIPPle{ripple_cmd_val}:EXTReme?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:RIPPle{ripple_cmd_val}:SDEViation?', suppressed)
 		return response
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/Ripple_/StandardDev.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Psd/StandardDev.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,30 +1,26 @@
 from typing import List
 
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ......Internal.Types import DataType
-from ...... import repcap
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .......Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class StandardDev:
-	"""StandardDev commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class StandardDevCls:
+	"""StandardDev commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("standardDev", core, parent)
+		self._cmd_group = CommandsGroup("standardDev", core, parent)
 
-	def fetch(self, ripple=repcap.Ripple.Default) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:RIPPle<nr>:SDEViation \n
-		Snippet: value: List[float] = driver.multiEval.listPy.esFlatness.ripple.standardDev.fetch(ripple = repcap.Ripple.Default) \n
-		Return equalizer spectrum flatness single value results (ripple 1 or ripple 2) for all measured list mode segments. The
-		values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value
-		for each result listed below. \n
+	def fetch(self) -> List[float]:
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PSD:SDEViation \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.listPy.modulation.psd.standardDev.fetch() \n
+		Return RB power values for all measured list mode segments. The values described below are returned by FETCh commands.
+		CALCulate commands return limit check results instead, one value for each result listed below. \n
 		Suppressed linked return values: reliability \n
-			:param ripple: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Ripple')
-			:return: ripple: Comma-separated list of values, one per measured segment"""
-		ripple_cmd_val = self._base.get_repcap_cmd_value(ripple, repcap.Ripple)
+			:return: psd: Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:RIPPle{ripple_cmd_val}:SDEViation?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PSD:SDEViation?', suppressed)
 		return response
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/ScIndex.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/EvMagnitude/Peak/__init__.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,35 +1,43 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class ScIndex:
-	"""ScIndex commands group definition. 2 total commands, 2 Sub-groups, 0 group commands"""
+class PeakCls:
+	"""Peak commands group definition. 6 total commands, 3 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("scIndex", core, parent)
+		self._cmd_group = CommandsGroup("peak", core, parent)
 
 	@property
-	def minimum(self):
-		"""minimum commands group. 1 Sub-classes, 0 commands."""
-		if not hasattr(self, '_minimum'):
-			from .ScIndex_.Minimum import Minimum
-			self._minimum = Minimum(self._core, self._base)
-		return self._minimum
+	def current(self):
+		"""current commands group. 0 Sub-classes, 2 commands."""
+		if not hasattr(self, '_current'):
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
+		return self._current
+
+	@property
+	def average(self):
+		"""average commands group. 0 Sub-classes, 2 commands."""
+		if not hasattr(self, '_average'):
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
+		return self._average
 
 	@property
 	def maximum(self):
-		"""maximum commands group. 1 Sub-classes, 0 commands."""
+		"""maximum commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_maximum'):
-			from .ScIndex_.Maximum import Maximum
-			self._maximum = Maximum(self._core, self._base)
+			from .Maximum import MaximumCls
+			self._maximum = MaximumCls(self._core, self._cmd_group)
 		return self._maximum
 
-	def clone(self) -> 'ScIndex':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'PeakCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = ScIndex(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = PeakCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/ScIndex_/Maximum.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/EsFlatness/ScIndex/Maximum/__init__.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,42 +1,42 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.RepeatedCapability import RepeatedCapability
-from ...... import repcap
+from ........Internal.Core import Core
+from ........Internal.CommandsGroup import CommandsGroup
+from ........Internal.RepeatedCapability import RepeatedCapability
+from ........ import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Maximum:
-	"""Maximum commands group definition. 1 total commands, 1 Sub-groups, 0 group commands
+class MaximumCls:
+	"""Maximum commands group definition. 1 total commands, 1 Subgroups, 0 group commands
 	Repeated Capability: MaxRange, default value after init: MaxRange.Nr1"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("maximum", core, parent)
-		self._base.rep_cap = RepeatedCapability(self._base.group_name, 'repcap_maxRange_get', 'repcap_maxRange_set', repcap.MaxRange.Nr1)
+		self._cmd_group = CommandsGroup("maximum", core, parent)
+		self._cmd_group.rep_cap = RepeatedCapability(self._cmd_group.group_name, 'repcap_maxRange_get', 'repcap_maxRange_set', repcap.MaxRange.Nr1)
 
-	def repcap_maxRange_set(self, enum_value: repcap.MaxRange) -> None:
+	def repcap_maxRange_set(self, maxRange: repcap.MaxRange) -> None:
 		"""Repeated Capability default value numeric suffix.
 		This value is used, if you do not explicitely set it in the child set/get methods, or if you leave it to MaxRange.Default
 		Default value after init: MaxRange.Nr1"""
-		self._base.set_repcap_enum_value(enum_value)
+		self._cmd_group.set_repcap_enum_value(maxRange)
 
 	def repcap_maxRange_get(self) -> repcap.MaxRange:
 		"""Returns the current default repeated capability for the child set/get methods"""
 		# noinspection PyTypeChecker
-		return self._base.get_repcap_enum_value()
+		return self._cmd_group.get_repcap_enum_value()
 
 	@property
 	def current(self):
 		"""current commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_current'):
-			from .Maximum_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
-	def clone(self) -> 'Maximum':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'MaximumCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Maximum(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = MaximumCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/ScIndex_/Maximum_/Current.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/EsFlatness/ScIndex/Maximum/Current.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,29 +1,29 @@
 from typing import List
 
-from .......Internal.Core import Core
-from .......Internal.CommandsGroup import CommandsGroup
-from .......Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from .......Internal.Types import DataType
-from ....... import repcap
+from ........Internal.Core import Core
+from ........Internal.CommandsGroup import CommandsGroup
+from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from ........Internal.Types import DataType
+from ........ import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	def fetch(self, maxRange=repcap.MaxRange.Default) -> List[int]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:SCINdex:MAXimum<nr>:CURRent \n
-		Snippet: value: List[int] = driver.multiEval.listPy.esFlatness.scIndex.maximum.current.fetch(maxRange = repcap.MaxRange.Default) \n
+		Snippet: value: List[int] = driver.lteMeas.multiEval.listPy.esFlatness.scIndex.maximum.current.fetch(maxRange = repcap.MaxRange.Default) \n
 		Return subcarrier indices of the equalizer spectrum flatness measurement for all measured list mode segments. At these SC
 		indices, the current MINimum or MAXimum power of the equalizer coefficients has been detected within the selected range. \n
 		Suppressed linked return values: reliability \n
 			:param maxRange: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Maximum')
 			:return: maximum: Comma-separated list of values, one per measured segment"""
-		maxRange_cmd_val = self._base.get_repcap_cmd_value(maxRange, repcap.MaxRange)
+		maxRange_cmd_val = self._cmd_group.get_repcap_cmd_value(maxRange, repcap.MaxRange)
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_int_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:SCINdex:MAXimum{maxRange_cmd_val}:CURRent?', suppressed)
 		return response
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/ScIndex_/Minimum.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/EsFlatness/ScIndex/Minimum/__init__.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,42 +1,42 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.RepeatedCapability import RepeatedCapability
-from ...... import repcap
+from ........Internal.Core import Core
+from ........Internal.CommandsGroup import CommandsGroup
+from ........Internal.RepeatedCapability import RepeatedCapability
+from ........ import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Minimum:
-	"""Minimum commands group definition. 1 total commands, 1 Sub-groups, 0 group commands
+class MinimumCls:
+	"""Minimum commands group definition. 1 total commands, 1 Subgroups, 0 group commands
 	Repeated Capability: MinRange, default value after init: MinRange.Nr1"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("minimum", core, parent)
-		self._base.rep_cap = RepeatedCapability(self._base.group_name, 'repcap_minRange_get', 'repcap_minRange_set', repcap.MinRange.Nr1)
+		self._cmd_group = CommandsGroup("minimum", core, parent)
+		self._cmd_group.rep_cap = RepeatedCapability(self._cmd_group.group_name, 'repcap_minRange_get', 'repcap_minRange_set', repcap.MinRange.Nr1)
 
-	def repcap_minRange_set(self, enum_value: repcap.MinRange) -> None:
+	def repcap_minRange_set(self, minRange: repcap.MinRange) -> None:
 		"""Repeated Capability default value numeric suffix.
 		This value is used, if you do not explicitely set it in the child set/get methods, or if you leave it to MinRange.Default
 		Default value after init: MinRange.Nr1"""
-		self._base.set_repcap_enum_value(enum_value)
+		self._cmd_group.set_repcap_enum_value(minRange)
 
 	def repcap_minRange_get(self) -> repcap.MinRange:
 		"""Returns the current default repeated capability for the child set/get methods"""
 		# noinspection PyTypeChecker
-		return self._base.get_repcap_enum_value()
+		return self._cmd_group.get_repcap_enum_value()
 
 	@property
 	def current(self):
 		"""current commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_current'):
-			from .Minimum_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
-	def clone(self) -> 'Minimum':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'MinimumCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Minimum(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = MinimumCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/EsFlatness_/ScIndex_/Minimum_/Current.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/EsFlatness/ScIndex/Minimum/Current.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,29 +1,29 @@
 from typing import List
 
-from .......Internal.Core import Core
-from .......Internal.CommandsGroup import CommandsGroup
-from .......Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from .......Internal.Types import DataType
-from ....... import repcap
+from ........Internal.Core import Core
+from ........Internal.CommandsGroup import CommandsGroup
+from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from ........Internal.Types import DataType
+from ........ import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	def fetch(self, minRange=repcap.MinRange.Default) -> List[int]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:SCINdex:MINimum<nr>:CURRent \n
-		Snippet: value: List[int] = driver.multiEval.listPy.esFlatness.scIndex.minimum.current.fetch(minRange = repcap.MinRange.Default) \n
+		Snippet: value: List[int] = driver.lteMeas.multiEval.listPy.esFlatness.scIndex.minimum.current.fetch(minRange = repcap.MinRange.Default) \n
 		Return subcarrier indices of the equalizer spectrum flatness measurement for all measured list mode segments. At these SC
 		indices, the current MINimum or MAXimum power of the equalizer coefficients has been detected within the selected range. \n
 		Suppressed linked return values: reliability \n
 			:param minRange: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Minimum')
 			:return: minimum: Comma-separated list of values, one per measured segment"""
-		minRange_cmd_val = self._base.get_repcap_cmd_value(minRange, repcap.MinRange)
+		minRange_cmd_val = self._cmd_group.get_repcap_cmd_value(minRange, repcap.MinRange)
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_int_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:ESFLatness:SCINdex:MINimum{minRange_cmd_val}:CURRent?', suppressed)
 		return response
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/InbandEmission.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/InbandEmission/__init__.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,27 +1,27 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class InbandEmission:
-	"""InbandEmission commands group definition. 6 total commands, 1 Sub-groups, 0 group commands"""
+class InbandEmissionCls:
+	"""InbandEmission commands group definition. 6 total commands, 1 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("inbandEmission", core, parent)
+		self._cmd_group = CommandsGroup("inbandEmission", core, parent)
 
 	@property
 	def margin(self):
 		"""margin commands group. 5 Sub-classes, 0 commands."""
 		if not hasattr(self, '_margin'):
-			from .InbandEmission_.Margin import Margin
-			self._margin = Margin(self._core, self._base)
+			from .Margin import MarginCls
+			self._margin = MarginCls(self._core, self._cmd_group)
 		return self._margin
 
-	def clone(self) -> 'InbandEmission':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'InbandEmissionCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = InbandEmission(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = InbandEmissionCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/InbandEmission_/Margin.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/SeMask/__init__.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,59 +1,83 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Margin:
-	"""Margin commands group definition. 6 total commands, 5 Sub-groups, 0 group commands"""
+class SeMaskCls:
+	"""SeMask commands group definition. 19 total commands, 8 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("margin", core, parent)
+		self._cmd_group = CommandsGroup("seMask", core, parent)
 
 	@property
 	def current(self):
-		"""current commands group. 0 Sub-classes, 1 commands."""
+		"""current commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_current'):
-			from .Margin_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
 	@property
 	def average(self):
-		"""average commands group. 0 Sub-classes, 1 commands."""
+		"""average commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_average'):
-			from .Margin_.Average import Average
-			self._average = Average(self._core, self._base)
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
 		return self._average
 
 	@property
 	def extreme(self):
-		"""extreme commands group. 0 Sub-classes, 1 commands."""
+		"""extreme commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_extreme'):
-			from .Margin_.Extreme import Extreme
-			self._extreme = Extreme(self._core, self._base)
+			from .Extreme import ExtremeCls
+			self._extreme = ExtremeCls(self._core, self._cmd_group)
 		return self._extreme
 
 	@property
 	def standardDev(self):
-		"""standardDev commands group. 0 Sub-classes, 1 commands."""
+		"""standardDev commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_standardDev'):
-			from .Margin_.StandardDev import StandardDev
-			self._standardDev = StandardDev(self._core, self._base)
+			from .StandardDev import StandardDevCls
+			self._standardDev = StandardDevCls(self._core, self._cmd_group)
 		return self._standardDev
 
 	@property
-	def rbIndex(self):
-		"""rbIndex commands group. 2 Sub-classes, 0 commands."""
-		if not hasattr(self, '_rbIndex'):
-			from .Margin_.RbIndex import RbIndex
-			self._rbIndex = RbIndex(self._core, self._base)
-		return self._rbIndex
+	def margin(self):
+		"""margin commands group. 4 Sub-classes, 1 commands."""
+		if not hasattr(self, '_margin'):
+			from .Margin import MarginCls
+			self._margin = MarginCls(self._core, self._cmd_group)
+		return self._margin
 
-	def clone(self) -> 'Margin':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	@property
+	def dmodulation(self):
+		"""dmodulation commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_dmodulation'):
+			from .Dmodulation import DmodulationCls
+			self._dmodulation = DmodulationCls(self._core, self._cmd_group)
+		return self._dmodulation
+
+	@property
+	def dchType(self):
+		"""dchType commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_dchType'):
+			from .DchType import DchTypeCls
+			self._dchType = DchTypeCls(self._core, self._cmd_group)
+		return self._dchType
+
+	@property
+	def dallocation(self):
+		"""dallocation commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_dallocation'):
+			from .Dallocation import DallocationCls
+			self._dallocation = DallocationCls(self._core, self._cmd_group)
+		return self._dallocation
+
+	def clone(self) -> 'SeMaskCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Margin(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = SeMaskCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/InbandEmission_/Margin_/Average.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/InbandEmission/Margin/Average.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,27 +1,27 @@
 from typing import List
 
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ......Internal.Types import DataType
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .......Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class AverageCls:
+	"""Average commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	def fetch(self) -> List[float]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:IEMission:MARGin:AVERage \n
-		Snippet: value: List[float] = driver.multiEval.listPy.inbandEmission.margin.average.fetch() \n
-		Return the inband emission limit line margin results for all measured list mode segments. The CURRent margins indicate
+		Snippet: value: List[float] = driver.lteMeas.multiEval.listPy.inbandEmission.margin.average.fetch() \n
+		Return the in-band emission limit line margin results for all measured list mode segments. The CURRent margins indicate
 		the minimum (vertical) distance between the limit line and the current trace. A negative result indicates that the limit
 		is exceeded. The AVERage, EXTReme and SDEViation values are calculated from the current margins. \n
 		Suppressed linked return values: reliability \n
 			:return: margin: Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:IEMission:MARGin:AVERage?', suppressed)
 		return response
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/InbandEmission_/Margin_/Current.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/InbandEmission/Margin/Current.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,27 +1,27 @@
 from typing import List
 
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ......Internal.Types import DataType
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .......Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	def fetch(self) -> List[float]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:IEMission:MARGin:CURRent \n
-		Snippet: value: List[float] = driver.multiEval.listPy.inbandEmission.margin.current.fetch() \n
-		Return the inband emission limit line margin results for all measured list mode segments. The CURRent margins indicate
+		Snippet: value: List[float] = driver.lteMeas.multiEval.listPy.inbandEmission.margin.current.fetch() \n
+		Return the in-band emission limit line margin results for all measured list mode segments. The CURRent margins indicate
 		the minimum (vertical) distance between the limit line and the current trace. A negative result indicates that the limit
 		is exceeded. The AVERage, EXTReme and SDEViation values are calculated from the current margins. \n
 		Suppressed linked return values: reliability \n
 			:return: margin: Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:IEMission:MARGin:CURRent?', suppressed)
 		return response
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/InbandEmission_/Margin_/Extreme.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/InbandEmission/Margin/Extreme.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,27 +1,27 @@
 from typing import List
 
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ......Internal.Types import DataType
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .......Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Extreme:
-	"""Extreme commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class ExtremeCls:
+	"""Extreme commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("extreme", core, parent)
+		self._cmd_group = CommandsGroup("extreme", core, parent)
 
 	def fetch(self) -> List[float]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:IEMission:MARGin:EXTReme \n
-		Snippet: value: List[float] = driver.multiEval.listPy.inbandEmission.margin.extreme.fetch() \n
-		Return the inband emission limit line margin results for all measured list mode segments. The CURRent margins indicate
+		Snippet: value: List[float] = driver.lteMeas.multiEval.listPy.inbandEmission.margin.extreme.fetch() \n
+		Return the in-band emission limit line margin results for all measured list mode segments. The CURRent margins indicate
 		the minimum (vertical) distance between the limit line and the current trace. A negative result indicates that the limit
 		is exceeded. The AVERage, EXTReme and SDEViation values are calculated from the current margins. \n
 		Suppressed linked return values: reliability \n
 			:return: margin: Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:IEMission:MARGin:EXTReme?', suppressed)
 		return response
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/InbandEmission_/Margin_/RbIndex.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/Pmonitor/Array/__init__.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,35 +1,35 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
+from ........Internal.Core import Core
+from ........Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class RbIndex:
-	"""RbIndex commands group definition. 2 total commands, 2 Sub-groups, 0 group commands"""
+class ArrayCls:
+	"""Array commands group definition. 2 total commands, 2 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("rbIndex", core, parent)
+		self._cmd_group = CommandsGroup("array", core, parent)
 
 	@property
-	def current(self):
-		"""current commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_current'):
-			from .RbIndex_.Current import Current
-			self._current = Current(self._core, self._base)
-		return self._current
+	def start(self):
+		"""start commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_start'):
+			from .Start import StartCls
+			self._start = StartCls(self._core, self._cmd_group)
+		return self._start
 
 	@property
-	def extreme(self):
-		"""extreme commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_extreme'):
-			from .RbIndex_.Extreme import Extreme
-			self._extreme = Extreme(self._core, self._base)
-		return self._extreme
+	def length(self):
+		"""length commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_length'):
+			from .Length import LengthCls
+			self._length = LengthCls(self._core, self._cmd_group)
+		return self._length
 
-	def clone(self) -> 'RbIndex':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'ArrayCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = RbIndex(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = ArrayCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/InbandEmission_/Margin_/RbIndex_/Current.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/InbandEmission/Margin/RbIndex/Current.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,26 +1,26 @@
 from typing import List
 
-from .......Internal.Core import Core
-from .......Internal.CommandsGroup import CommandsGroup
-from .......Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from .......Internal.Types import DataType
+from ........Internal.Core import Core
+from ........Internal.CommandsGroup import CommandsGroup
+from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from ........Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	def fetch(self) -> List[int]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:IEMission:MARGin:RBINdex:CURRent \n
-		Snippet: value: List[int] = driver.multiEval.listPy.inbandEmission.margin.rbIndex.current.fetch() \n
-		Return resource block indices of the inband emission measurement for all measured list mode segments. At these RB indices,
-		the CURRent and EXTReme margins have been detected. \n
+		Snippet: value: List[int] = driver.lteMeas.multiEval.listPy.inbandEmission.margin.rbIndex.current.fetch() \n
+		Return resource block indices of the in-band emission measurement for all measured list mode segments.
+		At these RB indices, the CURRent and EXTReme margins have been detected. \n
 		Suppressed linked return values: reliability \n
 			:return: rb_index: Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_int_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:IEMission:MARGin:RBINdex:CURRent?', suppressed)
 		return response
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/InbandEmission_/Margin_/RbIndex_/Extreme.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/InbandEmission/Margin/RbIndex/Extreme.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,26 +1,26 @@
 from typing import List
 
-from .......Internal.Core import Core
-from .......Internal.CommandsGroup import CommandsGroup
-from .......Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from .......Internal.Types import DataType
+from ........Internal.Core import Core
+from ........Internal.CommandsGroup import CommandsGroup
+from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from ........Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Extreme:
-	"""Extreme commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class ExtremeCls:
+	"""Extreme commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("extreme", core, parent)
+		self._cmd_group = CommandsGroup("extreme", core, parent)
 
 	def fetch(self) -> List[int]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:IEMission:MARGin:RBINdex:EXTReme \n
-		Snippet: value: List[int] = driver.multiEval.listPy.inbandEmission.margin.rbIndex.extreme.fetch() \n
-		Return resource block indices of the inband emission measurement for all measured list mode segments. At these RB indices,
-		the CURRent and EXTReme margins have been detected. \n
+		Snippet: value: List[int] = driver.lteMeas.multiEval.listPy.inbandEmission.margin.rbIndex.extreme.fetch() \n
+		Return resource block indices of the in-band emission measurement for all measured list mode segments.
+		At these RB indices, the CURRent and EXTReme margins have been detected. \n
 		Suppressed linked return values: reliability \n
 			:return: rb_index: Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_int_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:IEMission:MARGin:RBINdex:EXTReme?', suppressed)
 		return response
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/InbandEmission_/Margin_/StandardDev.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/InbandEmission/Margin/StandardDev.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,27 +1,27 @@
 from typing import List
 
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ......Internal.Types import DataType
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .......Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class StandardDev:
-	"""StandardDev commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class StandardDevCls:
+	"""StandardDev commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("standardDev", core, parent)
+		self._cmd_group = CommandsGroup("standardDev", core, parent)
 
 	def fetch(self) -> List[float]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:IEMission:MARGin:SDEViation \n
-		Snippet: value: List[float] = driver.multiEval.listPy.inbandEmission.margin.standardDev.fetch() \n
-		Return the inband emission limit line margin results for all measured list mode segments. The CURRent margins indicate
+		Snippet: value: List[float] = driver.lteMeas.multiEval.listPy.inbandEmission.margin.standardDev.fetch() \n
+		Return the in-band emission limit line margin results for all measured list mode segments. The CURRent margins indicate
 		the minimum (vertical) distance between the limit line and the current trace. A negative result indicates that the limit
 		is exceeded. The AVERage, EXTReme and SDEViation values are calculated from the current margins. \n
 		Suppressed linked return values: reliability \n
 			:return: margin: Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:IEMission:MARGin:SDEViation?', suppressed)
 		return response
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/__init__.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,123 +1,123 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Modulation:
-	"""Modulation commands group definition. 178 total commands, 13 Sub-groups, 0 group commands"""
+class ModulationCls:
+	"""Modulation commands group definition. 178 total commands, 13 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("modulation", core, parent)
+		self._cmd_group = CommandsGroup("modulation", core, parent)
 
 	@property
 	def evm(self):
 		"""evm commands group. 3 Sub-classes, 0 commands."""
 		if not hasattr(self, '_evm'):
-			from .Modulation_.Evm import Evm
-			self._evm = Evm(self._core, self._base)
+			from .Evm import EvmCls
+			self._evm = EvmCls(self._core, self._cmd_group)
 		return self._evm
 
 	@property
 	def merror(self):
 		"""merror commands group. 3 Sub-classes, 0 commands."""
 		if not hasattr(self, '_merror'):
-			from .Modulation_.Merror import Merror
-			self._merror = Merror(self._core, self._base)
+			from .Merror import MerrorCls
+			self._merror = MerrorCls(self._core, self._cmd_group)
 		return self._merror
 
 	@property
 	def perror(self):
 		"""perror commands group. 3 Sub-classes, 0 commands."""
 		if not hasattr(self, '_perror'):
-			from .Modulation_.Perror import Perror
-			self._perror = Perror(self._core, self._base)
+			from .Perror import PerrorCls
+			self._perror = PerrorCls(self._core, self._cmd_group)
 		return self._perror
 
 	@property
 	def iqOffset(self):
 		"""iqOffset commands group. 4 Sub-classes, 0 commands."""
 		if not hasattr(self, '_iqOffset'):
-			from .Modulation_.IqOffset import IqOffset
-			self._iqOffset = IqOffset(self._core, self._base)
+			from .IqOffset import IqOffsetCls
+			self._iqOffset = IqOffsetCls(self._core, self._cmd_group)
 		return self._iqOffset
 
 	@property
 	def freqError(self):
 		"""freqError commands group. 4 Sub-classes, 0 commands."""
 		if not hasattr(self, '_freqError'):
-			from .Modulation_.FreqError import FreqError
-			self._freqError = FreqError(self._core, self._base)
+			from .FreqError import FreqErrorCls
+			self._freqError = FreqErrorCls(self._core, self._cmd_group)
 		return self._freqError
 
 	@property
 	def terror(self):
 		"""terror commands group. 4 Sub-classes, 0 commands."""
 		if not hasattr(self, '_terror'):
-			from .Modulation_.Terror import Terror
-			self._terror = Terror(self._core, self._base)
+			from .Terror import TerrorCls
+			self._terror = TerrorCls(self._core, self._cmd_group)
 		return self._terror
 
 	@property
 	def tpower(self):
 		"""tpower commands group. 5 Sub-classes, 0 commands."""
 		if not hasattr(self, '_tpower'):
-			from .Modulation_.Tpower import Tpower
-			self._tpower = Tpower(self._core, self._base)
+			from .Tpower import TpowerCls
+			self._tpower = TpowerCls(self._core, self._cmd_group)
 		return self._tpower
 
 	@property
 	def ppower(self):
 		"""ppower commands group. 5 Sub-classes, 0 commands."""
 		if not hasattr(self, '_ppower'):
-			from .Modulation_.Ppower import Ppower
-			self._ppower = Ppower(self._core, self._base)
+			from .Ppower import PpowerCls
+			self._ppower = PpowerCls(self._core, self._cmd_group)
 		return self._ppower
 
 	@property
 	def psd(self):
 		"""psd commands group. 5 Sub-classes, 0 commands."""
 		if not hasattr(self, '_psd'):
-			from .Modulation_.Psd import Psd
-			self._psd = Psd(self._core, self._base)
+			from .Psd import PsdCls
+			self._psd = PsdCls(self._core, self._cmd_group)
 		return self._psd
 
 	@property
 	def dmodulation(self):
 		"""dmodulation commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_dmodulation'):
-			from .Modulation_.Dmodulation import Dmodulation
-			self._dmodulation = Dmodulation(self._core, self._base)
+			from .Dmodulation import DmodulationCls
+			self._dmodulation = DmodulationCls(self._core, self._cmd_group)
 		return self._dmodulation
 
 	@property
 	def dchType(self):
 		"""dchType commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_dchType'):
-			from .Modulation_.DchType import DchType
-			self._dchType = DchType(self._core, self._base)
+			from .DchType import DchTypeCls
+			self._dchType = DchTypeCls(self._core, self._cmd_group)
 		return self._dchType
 
 	@property
 	def schType(self):
 		"""schType commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_schType'):
-			from .Modulation_.SchType import SchType
-			self._schType = SchType(self._core, self._base)
+			from .SchType import SchTypeCls
+			self._schType = SchTypeCls(self._core, self._cmd_group)
 		return self._schType
 
 	@property
 	def dallocation(self):
 		"""dallocation commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_dallocation'):
-			from .Modulation_.Dallocation import Dallocation
-			self._dallocation = Dallocation(self._core, self._base)
+			from .Dallocation import DallocationCls
+			self._dallocation = DallocationCls(self._core, self._cmd_group)
 		return self._dallocation
 
-	def clone(self) -> 'Modulation':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'ModulationCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Modulation(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = ModulationCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Dallocation.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Dallocation.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,28 +1,28 @@
 from typing import List
 
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
-from .....Internal.Types import DataType
-from .....Internal.StructBase import StructBase
-from .....Internal.ArgStruct import ArgStruct
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal.Types import DataType
+from ......Internal.StructBase import StructBase
+from ......Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Dallocation:
-	"""Dallocation commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class DallocationCls:
+	"""Dallocation commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("dallocation", core, parent)
+		self._cmd_group = CommandsGroup("dallocation", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
+			- Reliability: int: 'Reliability indicator'
 			- Nr_Res_Blocks: List[int]: Number of allocated resource blocks
 			- Offset_Res_Blocks: List[int]: Offset of the first allocated resource block from the edge of the allocated UL transmission bandwidth"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct('Nr_Res_Blocks', DataType.IntegerList, None, False, True, 1),
 			ArgStruct('Offset_Res_Blocks', DataType.IntegerList, None, False, True, 1)]
 
@@ -30,15 +30,15 @@
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Nr_Res_Blocks: List[int] = None
 			self.Offset_Res_Blocks: List[int] = None
 
 	def fetch(self) -> FetchStruct:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:DALLocation \n
-		Snippet: value: FetchStruct = driver.multiEval.listPy.modulation.dallocation.fetch() \n
+		Snippet: value: FetchStruct = driver.lteMeas.multiEval.listPy.modulation.dallocation.fetch() \n
 		Return the detected allocation for all measured list mode segments. The result is determined from the last measured slot
-		of the statistical length of a segment. The individual measurements provide identical detected allocation results when
-		measuring the same slot. However different statistical lengths can be defined for the measurements so that the measured
-		slots and returned results can differ. The results are returned as pairs per segment: <Reliability>, {<NrResBlocks>,
-		<OffsetResBlocks>}Seg 1, {<NrResBlocks>, <OffsetResBlocks>}Seg 2, ... \n
+		of the statistical length of a segment. The individual measurements provide the same result when measuring the same slot.
+		However different statistical lengths can be defined for the measurements so that the measured slots and returned results
+		can differ. The results are returned as pairs per segment: <Reliability>, {<NrResBlocks>, <OffsetResBlocks>}Seg 1,
+		{<NrResBlocks>, <OffsetResBlocks>}Seg 2, ... \n
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
 		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:DALLocation?', self.__class__.FetchStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/DchType.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Dmodulation.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,31 +1,30 @@
 from typing import List
 
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
-from .....Internal import Conversions
-from .....Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from .....Internal.Types import DataType
-from ..... import enums
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal import Conversions
+from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from ......Internal.Types import DataType
+from ...... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class DchType:
-	"""DchType commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class DmodulationCls:
+	"""Dmodulation commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("dchType", core, parent)
+		self._cmd_group = CommandsGroup("dmodulation", core, parent)
 
 	# noinspection PyTypeChecker
-	def fetch(self) -> List[enums.UplinkChannelType]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:DCHType \n
-		Snippet: value: List[enums.UplinkChannelType] = driver.multiEval.listPy.modulation.dchType.fetch() \n
-		Return the uplink channel type for all measured list mode segments. The result is determined from the last measured slot
-		of the statistical length of a segment. The individual measurements provide identical detected channel type results when
-		measuring the same slot. However different statistical lengths can be defined for the measurements so that the measured
-		slots and returned results can differ. \n
+	def fetch(self) -> List[enums.Modulation]:
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:DMODulation \n
+		Snippet: value: List[enums.Modulation] = driver.lteMeas.multiEval.listPy.modulation.dmodulation.fetch() \n
+		Return the detected modulation scheme for all measured list mode segments. The result is determined from the last
+		measured slot of the statistical length of a segment. If channel type PUCCH is detected, QPSK is returned for the
+		modulation scheme because the QPSK limits are applied in that case. \n
 		Suppressed linked return values: reliability \n
-			:return: channel_type: Comma-separated list of values, one per measured segment"""
+			:return: modulation: Comma-separated list of values, one per measured segment QPSK, 16QAM, 64QAM, 256QAM"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_str_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:DCHType?', suppressed)
-		return Conversions.str_to_list_enum(response, enums.UplinkChannelType)
+		response = self._core.io.query_str_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:DMODulation?', suppressed)
+		return Conversions.str_to_list_enum(response, enums.Modulation)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Dmodulation.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Modulation/Dmodulation.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,30 +1,27 @@
-from typing import List
-
 from .....Internal.Core import Core
 from .....Internal.CommandsGroup import CommandsGroup
 from .....Internal import Conversions
 from .....Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from .....Internal.Types import DataType
 from ..... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Dmodulation:
-	"""Dmodulation commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class DmodulationCls:
+	"""Dmodulation commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("dmodulation", core, parent)
+		self._cmd_group = CommandsGroup("dmodulation", core, parent)
 
 	# noinspection PyTypeChecker
-	def fetch(self) -> List[enums.Modulation]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:DMODulation \n
-		Snippet: value: List[enums.Modulation] = driver.multiEval.listPy.modulation.dmodulation.fetch() \n
-		Return the detected modulation scheme for all measured list mode segments. The result is determined from the last
-		measured slot of the statistical length of a segment. If channel type PUCCH is detected, QPSK is returned as modulation
-		type because the QPSK limits are applied in that case. \n
+	def fetch(self) -> enums.Modulation:
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:MODulation:DMODulation \n
+		Snippet: value: enums.Modulation = driver.lteMeas.multiEval.modulation.dmodulation.fetch() \n
+		Returns the detected modulation scheme in the measured slot. If channel type PUCCH is detected, QPSK is returned for the
+		modulation scheme because the QPSK limits are applied in that case. \n
 		Suppressed linked return values: reliability \n
-			:return: modulation: Comma-separated list of values, one per measured segment QPSK, 16-QAM, 64-QAM, 256-QAM"""
+			:return: modulation: QPSK, 16QAM, 64QAM, 256QAM"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_str_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:DMODulation?', suppressed)
-		return Conversions.str_to_list_enum(response, enums.Modulation)
+		response = self._core.io.query_str_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:MODulation:DMODulation?', suppressed)
+		return Conversions.str_to_scalar_enum(response, enums.Modulation)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Evm/__init__.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,43 +1,43 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Evm:
-	"""Evm commands group definition. 42 total commands, 3 Sub-groups, 0 group commands"""
+class EvmCls:
+	"""Evm commands group definition. 42 total commands, 3 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("evm", core, parent)
+		self._cmd_group = CommandsGroup("evm", core, parent)
 
 	@property
 	def rms(self):
 		"""rms commands group. 2 Sub-classes, 0 commands."""
 		if not hasattr(self, '_rms'):
-			from .Evm_.Rms import Rms
-			self._rms = Rms(self._core, self._base)
+			from .Rms import RmsCls
+			self._rms = RmsCls(self._core, self._cmd_group)
 		return self._rms
 
 	@property
 	def peak(self):
 		"""peak commands group. 2 Sub-classes, 0 commands."""
 		if not hasattr(self, '_peak'):
-			from .Evm_.Peak import Peak
-			self._peak = Peak(self._core, self._base)
+			from .Peak import PeakCls
+			self._peak = PeakCls(self._core, self._cmd_group)
 		return self._peak
 
 	@property
 	def dmrs(self):
 		"""dmrs commands group. 2 Sub-classes, 0 commands."""
 		if not hasattr(self, '_dmrs'):
-			from .Evm_.Dmrs import Dmrs
-			self._dmrs = Dmrs(self._core, self._base)
+			from .Dmrs import DmrsCls
+			self._dmrs = DmrsCls(self._core, self._cmd_group)
 		return self._dmrs
 
-	def clone(self) -> 'Evm':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'EvmCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Evm(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = EvmCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Dmrs.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Pmonitor/__init__.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,35 +1,35 @@
 from ......Internal.Core import Core
 from ......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Dmrs:
-	"""Dmrs commands group definition. 14 total commands, 2 Sub-groups, 0 group commands"""
+class PmonitorCls:
+	"""Pmonitor commands group definition. 2 total commands, 2 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("dmrs", core, parent)
+		self._cmd_group = CommandsGroup("pmonitor", core, parent)
 
 	@property
-	def low(self):
-		"""low commands group. 4 Sub-classes, 0 commands."""
-		if not hasattr(self, '_low'):
-			from .Dmrs_.Low import Low
-			self._low = Low(self._core, self._base)
-		return self._low
+	def rms(self):
+		"""rms commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_rms'):
+			from .Rms import RmsCls
+			self._rms = RmsCls(self._core, self._cmd_group)
+		return self._rms
 
 	@property
-	def high(self):
-		"""high commands group. 4 Sub-classes, 0 commands."""
-		if not hasattr(self, '_high'):
-			from .Dmrs_.High import High
-			self._high = High(self._core, self._base)
-		return self._high
+	def peak(self):
+		"""peak commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_peak'):
+			from .Peak import PeakCls
+			self._peak = PeakCls(self._core, self._cmd_group)
+		return self._peak
 
-	def clone(self) -> 'Dmrs':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'PmonitorCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Dmrs(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = PmonitorCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Dmrs_/High.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Trace/Iemissions/Ulca/__init__.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,51 +1,35 @@
 from .......Internal.Core import Core
 from .......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class High:
-	"""High commands group definition. 7 total commands, 4 Sub-groups, 0 group commands"""
+class UlcaCls:
+	"""Ulca commands group definition. 4 total commands, 2 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("high", core, parent)
+		self._cmd_group = CommandsGroup("ulca", core, parent)
 
 	@property
-	def current(self):
-		"""current commands group. 0 Sub-classes, 2 commands."""
-		if not hasattr(self, '_current'):
-			from .High_.Current import Current
-			self._current = Current(self._core, self._base)
-		return self._current
+	def scc(self):
+		"""scc commands group. 0 Sub-classes, 2 commands."""
+		if not hasattr(self, '_scc'):
+			from .Scc import SccCls
+			self._scc = SccCls(self._core, self._cmd_group)
+		return self._scc
 
 	@property
-	def average(self):
-		"""average commands group. 0 Sub-classes, 2 commands."""
-		if not hasattr(self, '_average'):
-			from .High_.Average import Average
-			self._average = Average(self._core, self._base)
-		return self._average
+	def pcc(self):
+		"""pcc commands group. 0 Sub-classes, 2 commands."""
+		if not hasattr(self, '_pcc'):
+			from .Pcc import PccCls
+			self._pcc = PccCls(self._core, self._cmd_group)
+		return self._pcc
 
-	@property
-	def extreme(self):
-		"""extreme commands group. 0 Sub-classes, 2 commands."""
-		if not hasattr(self, '_extreme'):
-			from .High_.Extreme import Extreme
-			self._extreme = Extreme(self._core, self._base)
-		return self._extreme
-
-	@property
-	def standardDev(self):
-		"""standardDev commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_standardDev'):
-			from .High_.StandardDev import StandardDev
-			self._standardDev = StandardDev(self._core, self._base)
-		return self._standardDev
-
-	def clone(self) -> 'High':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'UlcaCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = High(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = UlcaCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Dmrs_/High_/Average.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Evm/Dmrs/High/Average.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,39 +1,40 @@
 from typing import List
 
-from ........Internal.Core import Core
-from ........Internal.CommandsGroup import CommandsGroup
-from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ........Internal.Types import DataType
+from .........Internal.Core import Core
+from .........Internal.CommandsGroup import CommandsGroup
+from .........Internal import Conversions
+from .........Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .........Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class AverageCls:
+	"""Average commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	def fetch(self) -> List[float]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:DMRS:HIGH:AVERage \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.evm.dmrs.high.average.fetch() \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.listPy.modulation.evm.dmrs.high.average.fetch() \n
 		Return error vector magnitude DMRS values for low and high EVM window position, for all measured list mode segments. The
 		values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value
 		for each result listed below. \n
 		Suppressed linked return values: reliability \n
 			:return: evm_dmrs_high: Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:DMRS:HIGH:AVERage?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
+	def calculate(self) -> List[float or bool]:
 		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:DMRS:HIGH:AVERage \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.evm.dmrs.high.average.calculate() \n
+		Snippet: value: List[float or bool] = driver.lteMeas.multiEval.listPy.modulation.evm.dmrs.high.average.calculate() \n
 		Return error vector magnitude DMRS values for low and high EVM window position, for all measured list mode segments. The
 		values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value
 		for each result listed below. \n
 		Suppressed linked return values: reliability \n
-			:return: evm_dmrs_high: Comma-separated list of values, one per measured segment"""
+			:return: evm_dmrs_high: (float or boolean items) Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:DMRS:HIGH:AVERage?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:DMRS:HIGH:AVERage?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Dmrs_/High_/Current.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Evm/Dmrs/High/Current.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,39 +1,40 @@
 from typing import List
 
-from ........Internal.Core import Core
-from ........Internal.CommandsGroup import CommandsGroup
-from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ........Internal.Types import DataType
+from .........Internal.Core import Core
+from .........Internal.CommandsGroup import CommandsGroup
+from .........Internal import Conversions
+from .........Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .........Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	def fetch(self) -> List[float]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:DMRS:HIGH:CURRent \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.evm.dmrs.high.current.fetch() \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.listPy.modulation.evm.dmrs.high.current.fetch() \n
 		Return error vector magnitude DMRS values for low and high EVM window position, for all measured list mode segments. The
 		values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value
 		for each result listed below. \n
 		Suppressed linked return values: reliability \n
 			:return: evm_dmrs_high: Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:DMRS:HIGH:CURRent?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
+	def calculate(self) -> List[float or bool]:
 		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:DMRS:HIGH:CURRent \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.evm.dmrs.high.current.calculate() \n
+		Snippet: value: List[float or bool] = driver.lteMeas.multiEval.listPy.modulation.evm.dmrs.high.current.calculate() \n
 		Return error vector magnitude DMRS values for low and high EVM window position, for all measured list mode segments. The
 		values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value
 		for each result listed below. \n
 		Suppressed linked return values: reliability \n
-			:return: evm_dmrs_high: Comma-separated list of values, one per measured segment"""
+			:return: evm_dmrs_high: (float or boolean items) Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:DMRS:HIGH:CURRent?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:DMRS:HIGH:CURRent?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Dmrs_/High_/Extreme.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Evm/Dmrs/High/Extreme.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,39 +1,40 @@
 from typing import List
 
-from ........Internal.Core import Core
-from ........Internal.CommandsGroup import CommandsGroup
-from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ........Internal.Types import DataType
+from .........Internal.Core import Core
+from .........Internal.CommandsGroup import CommandsGroup
+from .........Internal import Conversions
+from .........Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .........Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Extreme:
-	"""Extreme commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class ExtremeCls:
+	"""Extreme commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("extreme", core, parent)
+		self._cmd_group = CommandsGroup("extreme", core, parent)
 
 	def fetch(self) -> List[float]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:DMRS:HIGH:EXTReme \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.evm.dmrs.high.extreme.fetch() \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.listPy.modulation.evm.dmrs.high.extreme.fetch() \n
 		Return error vector magnitude DMRS values for low and high EVM window position, for all measured list mode segments. The
 		values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value
 		for each result listed below. \n
 		Suppressed linked return values: reliability \n
 			:return: evm_dmrs_high: Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:DMRS:HIGH:EXTReme?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
+	def calculate(self) -> List[float or bool]:
 		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:DMRS:HIGH:EXTReme \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.evm.dmrs.high.extreme.calculate() \n
+		Snippet: value: List[float or bool] = driver.lteMeas.multiEval.listPy.modulation.evm.dmrs.high.extreme.calculate() \n
 		Return error vector magnitude DMRS values for low and high EVM window position, for all measured list mode segments. The
 		values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value
 		for each result listed below. \n
 		Suppressed linked return values: reliability \n
-			:return: evm_dmrs_high: Comma-separated list of values, one per measured segment"""
+			:return: evm_dmrs_high: (float or boolean items) Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:DMRS:HIGH:EXTReme?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:DMRS:HIGH:EXTReme?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Dmrs_/High_/StandardDev.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Evm/Dmrs/High/StandardDev.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,26 +1,26 @@
 from typing import List
 
-from ........Internal.Core import Core
-from ........Internal.CommandsGroup import CommandsGroup
-from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ........Internal.Types import DataType
+from .........Internal.Core import Core
+from .........Internal.CommandsGroup import CommandsGroup
+from .........Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .........Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class StandardDev:
-	"""StandardDev commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class StandardDevCls:
+	"""StandardDev commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("standardDev", core, parent)
+		self._cmd_group = CommandsGroup("standardDev", core, parent)
 
 	def fetch(self) -> List[float]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:DMRS:HIGH:SDEViation \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.evm.dmrs.high.standardDev.fetch() \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.listPy.modulation.evm.dmrs.high.standardDev.fetch() \n
 		Return error vector magnitude DMRS values for low and high EVM window position, for all measured list mode segments. The
 		values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value
 		for each result listed below. \n
 		Suppressed linked return values: reliability \n
 			:return: evm_dmrs_high: Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:DMRS:HIGH:SDEViation?', suppressed)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Dmrs_/Low.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Merror/__init__.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,51 +1,43 @@
 from .......Internal.Core import Core
 from .......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Low:
-	"""Low commands group definition. 7 total commands, 4 Sub-groups, 0 group commands"""
+class MerrorCls:
+	"""Merror commands group definition. 42 total commands, 3 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("low", core, parent)
+		self._cmd_group = CommandsGroup("merror", core, parent)
 
 	@property
-	def current(self):
-		"""current commands group. 0 Sub-classes, 2 commands."""
-		if not hasattr(self, '_current'):
-			from .Low_.Current import Current
-			self._current = Current(self._core, self._base)
-		return self._current
+	def rms(self):
+		"""rms commands group. 2 Sub-classes, 0 commands."""
+		if not hasattr(self, '_rms'):
+			from .Rms import RmsCls
+			self._rms = RmsCls(self._core, self._cmd_group)
+		return self._rms
 
 	@property
-	def average(self):
-		"""average commands group. 0 Sub-classes, 2 commands."""
-		if not hasattr(self, '_average'):
-			from .Low_.Average import Average
-			self._average = Average(self._core, self._base)
-		return self._average
+	def peak(self):
+		"""peak commands group. 2 Sub-classes, 0 commands."""
+		if not hasattr(self, '_peak'):
+			from .Peak import PeakCls
+			self._peak = PeakCls(self._core, self._cmd_group)
+		return self._peak
 
 	@property
-	def extreme(self):
-		"""extreme commands group. 0 Sub-classes, 2 commands."""
-		if not hasattr(self, '_extreme'):
-			from .Low_.Extreme import Extreme
-			self._extreme = Extreme(self._core, self._base)
-		return self._extreme
+	def dmrs(self):
+		"""dmrs commands group. 2 Sub-classes, 0 commands."""
+		if not hasattr(self, '_dmrs'):
+			from .Dmrs import DmrsCls
+			self._dmrs = DmrsCls(self._core, self._cmd_group)
+		return self._dmrs
 
-	@property
-	def standardDev(self):
-		"""standardDev commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_standardDev'):
-			from .Low_.StandardDev import StandardDev
-			self._standardDev = StandardDev(self._core, self._base)
-		return self._standardDev
-
-	def clone(self) -> 'Low':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'MerrorCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Low(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = MerrorCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Dmrs_/Low_/Average.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Evm/Rms/Low/Average.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,39 +1,40 @@
 from typing import List
 
-from ........Internal.Core import Core
-from ........Internal.CommandsGroup import CommandsGroup
-from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ........Internal.Types import DataType
+from .........Internal.Core import Core
+from .........Internal.CommandsGroup import CommandsGroup
+from .........Internal import Conversions
+from .........Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .........Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class AverageCls:
+	"""Average commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:DMRS:LOW:AVERage \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.evm.dmrs.low.average.fetch() \n
-		Return error vector magnitude DMRS values for low and high EVM window position, for all measured list mode segments. The
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:RMS:LOW:AVERage \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.listPy.modulation.evm.rms.low.average.fetch() \n
+		Return error vector magnitude RMS values for low and high EVM window position, for all measured list mode segments. The
 		values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value
 		for each result listed below. \n
 		Suppressed linked return values: reliability \n
-			:return: evm_dmrs_low: Comma-separated list of values, one per measured segment"""
+			:return: evm_rms_low: Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:DMRS:LOW:AVERage?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:RMS:LOW:AVERage?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:DMRS:LOW:AVERage \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.evm.dmrs.low.average.calculate() \n
-		Return error vector magnitude DMRS values for low and high EVM window position, for all measured list mode segments. The
+	def calculate(self) -> List[float or bool]:
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:RMS:LOW:AVERage \n
+		Snippet: value: List[float or bool] = driver.lteMeas.multiEval.listPy.modulation.evm.rms.low.average.calculate() \n
+		Return error vector magnitude RMS values for low and high EVM window position, for all measured list mode segments. The
 		values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value
 		for each result listed below. \n
 		Suppressed linked return values: reliability \n
-			:return: evm_dmrs_low: Comma-separated list of values, one per measured segment"""
+			:return: evm_rms_low: (float or boolean items) Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:DMRS:LOW:AVERage?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:RMS:LOW:AVERage?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Dmrs_/Low_/Current.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Evm/Dmrs/Low/Current.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,39 +1,40 @@
 from typing import List
 
-from ........Internal.Core import Core
-from ........Internal.CommandsGroup import CommandsGroup
-from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ........Internal.Types import DataType
+from .........Internal.Core import Core
+from .........Internal.CommandsGroup import CommandsGroup
+from .........Internal import Conversions
+from .........Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .........Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	def fetch(self) -> List[float]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:DMRS:LOW:CURRent \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.evm.dmrs.low.current.fetch() \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.listPy.modulation.evm.dmrs.low.current.fetch() \n
 		Return error vector magnitude DMRS values for low and high EVM window position, for all measured list mode segments. The
 		values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value
 		for each result listed below. \n
 		Suppressed linked return values: reliability \n
 			:return: evm_dmrs_low: Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:DMRS:LOW:CURRent?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
+	def calculate(self) -> List[float or bool]:
 		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:DMRS:LOW:CURRent \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.evm.dmrs.low.current.calculate() \n
+		Snippet: value: List[float or bool] = driver.lteMeas.multiEval.listPy.modulation.evm.dmrs.low.current.calculate() \n
 		Return error vector magnitude DMRS values for low and high EVM window position, for all measured list mode segments. The
 		values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value
 		for each result listed below. \n
 		Suppressed linked return values: reliability \n
-			:return: evm_dmrs_low: Comma-separated list of values, one per measured segment"""
+			:return: evm_dmrs_low: (float or boolean items) Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:DMRS:LOW:CURRent?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:DMRS:LOW:CURRent?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Dmrs_/Low_/Extreme.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Evm/Dmrs/Low/Extreme.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,39 +1,40 @@
 from typing import List
 
-from ........Internal.Core import Core
-from ........Internal.CommandsGroup import CommandsGroup
-from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ........Internal.Types import DataType
+from .........Internal.Core import Core
+from .........Internal.CommandsGroup import CommandsGroup
+from .........Internal import Conversions
+from .........Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .........Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Extreme:
-	"""Extreme commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class ExtremeCls:
+	"""Extreme commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("extreme", core, parent)
+		self._cmd_group = CommandsGroup("extreme", core, parent)
 
 	def fetch(self) -> List[float]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:DMRS:LOW:EXTReme \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.evm.dmrs.low.extreme.fetch() \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.listPy.modulation.evm.dmrs.low.extreme.fetch() \n
 		Return error vector magnitude DMRS values for low and high EVM window position, for all measured list mode segments. The
 		values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value
 		for each result listed below. \n
 		Suppressed linked return values: reliability \n
 			:return: evm_dmrs_low: Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:DMRS:LOW:EXTReme?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
+	def calculate(self) -> List[float or bool]:
 		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:DMRS:LOW:EXTReme \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.evm.dmrs.low.extreme.calculate() \n
+		Snippet: value: List[float or bool] = driver.lteMeas.multiEval.listPy.modulation.evm.dmrs.low.extreme.calculate() \n
 		Return error vector magnitude DMRS values for low and high EVM window position, for all measured list mode segments. The
 		values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value
 		for each result listed below. \n
 		Suppressed linked return values: reliability \n
-			:return: evm_dmrs_low: Comma-separated list of values, one per measured segment"""
+			:return: evm_dmrs_low: (float or boolean items) Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:DMRS:LOW:EXTReme?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:DMRS:LOW:EXTReme?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Dmrs_/Low_/StandardDev.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/IqOffset/StandardDev.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,27 +1,26 @@
 from typing import List
 
-from ........Internal.Core import Core
-from ........Internal.CommandsGroup import CommandsGroup
-from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ........Internal.Types import DataType
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .......Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class StandardDev:
-	"""StandardDev commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class StandardDevCls:
+	"""StandardDev commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("standardDev", core, parent)
+		self._cmd_group = CommandsGroup("standardDev", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:DMRS:LOW:SDEViation \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.evm.dmrs.low.standardDev.fetch() \n
-		Return error vector magnitude DMRS values for low and high EVM window position, for all measured list mode segments. The
-		values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value
-		for each result listed below. \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:IQOFfset:SDEViation \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.listPy.modulation.iqOffset.standardDev.fetch() \n
+		Return I/Q origin offset values for all measured list mode segments. The values described below are returned by FETCh
+		commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 		Suppressed linked return values: reliability \n
-			:return: evm_dmrs_low: Comma-separated list of values, one per measured segment"""
+			:return: iq_offset: Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:DMRS:LOW:SDEViation?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:IQOFfset:SDEViation?', suppressed)
 		return response
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Peak.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Trace/Iq/__init__.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,35 +1,35 @@
 from ......Internal.Core import Core
 from ......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Peak:
-	"""Peak commands group definition. 14 total commands, 2 Sub-groups, 0 group commands"""
+class IqCls:
+	"""Iq commands group definition. 2 total commands, 2 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("peak", core, parent)
+		self._cmd_group = CommandsGroup("iq", core, parent)
 
 	@property
 	def low(self):
-		"""low commands group. 4 Sub-classes, 0 commands."""
+		"""low commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_low'):
-			from .Peak_.Low import Low
-			self._low = Low(self._core, self._base)
+			from .Low import LowCls
+			self._low = LowCls(self._core, self._cmd_group)
 		return self._low
 
 	@property
 	def high(self):
-		"""high commands group. 4 Sub-classes, 0 commands."""
+		"""high commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_high'):
-			from .Peak_.High import High
-			self._high = High(self._core, self._base)
+			from .High import HighCls
+			self._high = HighCls(self._core, self._cmd_group)
 		return self._high
 
-	def clone(self) -> 'Peak':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'IqCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Peak(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = IqCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Peak_/High.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Trace/Pmonitor/Ulca/__init__.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,51 +1,35 @@
 from .......Internal.Core import Core
 from .......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class High:
-	"""High commands group definition. 7 total commands, 4 Sub-groups, 0 group commands"""
+class UlcaCls:
+	"""Ulca commands group definition. 4 total commands, 2 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("high", core, parent)
+		self._cmd_group = CommandsGroup("ulca", core, parent)
 
 	@property
-	def current(self):
-		"""current commands group. 0 Sub-classes, 2 commands."""
-		if not hasattr(self, '_current'):
-			from .High_.Current import Current
-			self._current = Current(self._core, self._base)
-		return self._current
+	def scc(self):
+		"""scc commands group. 0 Sub-classes, 2 commands."""
+		if not hasattr(self, '_scc'):
+			from .Scc import SccCls
+			self._scc = SccCls(self._core, self._cmd_group)
+		return self._scc
 
 	@property
-	def average(self):
-		"""average commands group. 0 Sub-classes, 2 commands."""
-		if not hasattr(self, '_average'):
-			from .High_.Average import Average
-			self._average = Average(self._core, self._base)
-		return self._average
+	def pcc(self):
+		"""pcc commands group. 0 Sub-classes, 2 commands."""
+		if not hasattr(self, '_pcc'):
+			from .Pcc import PccCls
+			self._pcc = PccCls(self._core, self._cmd_group)
+		return self._pcc
 
-	@property
-	def extreme(self):
-		"""extreme commands group. 0 Sub-classes, 2 commands."""
-		if not hasattr(self, '_extreme'):
-			from .High_.Extreme import Extreme
-			self._extreme = Extreme(self._core, self._base)
-		return self._extreme
-
-	@property
-	def standardDev(self):
-		"""standardDev commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_standardDev'):
-			from .High_.StandardDev import StandardDev
-			self._standardDev = StandardDev(self._core, self._base)
-		return self._standardDev
-
-	def clone(self) -> 'High':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'UlcaCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = High(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = UlcaCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Peak_/High_/Average.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Evm/Peak/High/Average.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,39 +1,40 @@
 from typing import List
 
-from ........Internal.Core import Core
-from ........Internal.CommandsGroup import CommandsGroup
-from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ........Internal.Types import DataType
+from .........Internal.Core import Core
+from .........Internal.CommandsGroup import CommandsGroup
+from .........Internal import Conversions
+from .........Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .........Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class AverageCls:
+	"""Average commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	def fetch(self) -> List[float]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:PEAK:HIGH:AVERage \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.evm.peak.high.average.fetch() \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.listPy.modulation.evm.peak.high.average.fetch() \n
 		Return error vector magnitude peak values for low and high EVM window position, for all measured list mode segments. The
 		values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value
 		for each result listed below. \n
 		Suppressed linked return values: reliability \n
 			:return: evm_peak_high: Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:PEAK:HIGH:AVERage?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
+	def calculate(self) -> List[float or bool]:
 		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:PEAK:HIGH:AVERage \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.evm.peak.high.average.calculate() \n
+		Snippet: value: List[float or bool] = driver.lteMeas.multiEval.listPy.modulation.evm.peak.high.average.calculate() \n
 		Return error vector magnitude peak values for low and high EVM window position, for all measured list mode segments. The
 		values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value
 		for each result listed below. \n
 		Suppressed linked return values: reliability \n
-			:return: evm_peak_high: Comma-separated list of values, one per measured segment"""
+			:return: evm_peak_high: (float or boolean items) Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:PEAK:HIGH:AVERage?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:PEAK:HIGH:AVERage?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Peak_/High_/Current.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Evm/Peak/High/StandardDev.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,39 +1,27 @@
 from typing import List
 
-from ........Internal.Core import Core
-from ........Internal.CommandsGroup import CommandsGroup
-from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ........Internal.Types import DataType
+from .........Internal.Core import Core
+from .........Internal.CommandsGroup import CommandsGroup
+from .........Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .........Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class StandardDevCls:
+	"""StandardDev commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("standardDev", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:PEAK:HIGH:CURRent \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.evm.peak.high.current.fetch() \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:PEAK:HIGH:SDEViation \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.listPy.modulation.evm.peak.high.standardDev.fetch() \n
 		Return error vector magnitude peak values for low and high EVM window position, for all measured list mode segments. The
 		values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value
 		for each result listed below. \n
 		Suppressed linked return values: reliability \n
 			:return: evm_peak_high: Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:PEAK:HIGH:CURRent?', suppressed)
-		return response
-
-	def calculate(self) -> List[float]:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:PEAK:HIGH:CURRent \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.evm.peak.high.current.calculate() \n
-		Return error vector magnitude peak values for low and high EVM window position, for all measured list mode segments. The
-		values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value
-		for each result listed below. \n
-		Suppressed linked return values: reliability \n
-			:return: evm_peak_high: Comma-separated list of values, one per measured segment"""
-		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:PEAK:HIGH:CURRent?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:PEAK:HIGH:SDEViation?', suppressed)
 		return response
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Peak_/High_/Extreme.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Evm/Peak/High/Extreme.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,39 +1,40 @@
 from typing import List
 
-from ........Internal.Core import Core
-from ........Internal.CommandsGroup import CommandsGroup
-from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ........Internal.Types import DataType
+from .........Internal.Core import Core
+from .........Internal.CommandsGroup import CommandsGroup
+from .........Internal import Conversions
+from .........Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .........Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Extreme:
-	"""Extreme commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class ExtremeCls:
+	"""Extreme commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("extreme", core, parent)
+		self._cmd_group = CommandsGroup("extreme", core, parent)
 
 	def fetch(self) -> List[float]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:PEAK:HIGH:EXTReme \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.evm.peak.high.extreme.fetch() \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.listPy.modulation.evm.peak.high.extreme.fetch() \n
 		Return error vector magnitude peak values for low and high EVM window position, for all measured list mode segments. The
 		values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value
 		for each result listed below. \n
 		Suppressed linked return values: reliability \n
 			:return: evm_peak_high: Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:PEAK:HIGH:EXTReme?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
+	def calculate(self) -> List[float or bool]:
 		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:PEAK:HIGH:EXTReme \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.evm.peak.high.extreme.calculate() \n
+		Snippet: value: List[float or bool] = driver.lteMeas.multiEval.listPy.modulation.evm.peak.high.extreme.calculate() \n
 		Return error vector magnitude peak values for low and high EVM window position, for all measured list mode segments. The
 		values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value
 		for each result listed below. \n
 		Suppressed linked return values: reliability \n
-			:return: evm_peak_high: Comma-separated list of values, one per measured segment"""
+			:return: evm_peak_high: (float or boolean items) Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:PEAK:HIGH:EXTReme?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:PEAK:HIGH:EXTReme?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Peak_/High_/StandardDev.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Evm/Peak/Low/StandardDev.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,27 +1,27 @@
 from typing import List
 
-from ........Internal.Core import Core
-from ........Internal.CommandsGroup import CommandsGroup
-from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ........Internal.Types import DataType
+from .........Internal.Core import Core
+from .........Internal.CommandsGroup import CommandsGroup
+from .........Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .........Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class StandardDev:
-	"""StandardDev commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class StandardDevCls:
+	"""StandardDev commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("standardDev", core, parent)
+		self._cmd_group = CommandsGroup("standardDev", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:PEAK:HIGH:SDEViation \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.evm.peak.high.standardDev.fetch() \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:PEAK:LOW:SDEViation \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.listPy.modulation.evm.peak.low.standardDev.fetch() \n
 		Return error vector magnitude peak values for low and high EVM window position, for all measured list mode segments. The
 		values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value
 		for each result listed below. \n
 		Suppressed linked return values: reliability \n
-			:return: evm_peak_high: Comma-separated list of values, one per measured segment"""
+			:return: evm_peak_low: Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:PEAK:HIGH:SDEViation?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:PEAK:LOW:SDEViation?', suppressed)
 		return response
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Peak_/Low.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Trace/RbaTable/Ulca/__init__.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,51 +1,35 @@
 from .......Internal.Core import Core
 from .......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Low:
-	"""Low commands group definition. 7 total commands, 4 Sub-groups, 0 group commands"""
+class UlcaCls:
+	"""Ulca commands group definition. 4 total commands, 2 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("low", core, parent)
+		self._cmd_group = CommandsGroup("ulca", core, parent)
 
 	@property
-	def current(self):
-		"""current commands group. 0 Sub-classes, 2 commands."""
-		if not hasattr(self, '_current'):
-			from .Low_.Current import Current
-			self._current = Current(self._core, self._base)
-		return self._current
+	def scc(self):
+		"""scc commands group. 0 Sub-classes, 2 commands."""
+		if not hasattr(self, '_scc'):
+			from .Scc import SccCls
+			self._scc = SccCls(self._core, self._cmd_group)
+		return self._scc
 
 	@property
-	def average(self):
-		"""average commands group. 0 Sub-classes, 2 commands."""
-		if not hasattr(self, '_average'):
-			from .Low_.Average import Average
-			self._average = Average(self._core, self._base)
-		return self._average
+	def pcc(self):
+		"""pcc commands group. 0 Sub-classes, 2 commands."""
+		if not hasattr(self, '_pcc'):
+			from .Pcc import PccCls
+			self._pcc = PccCls(self._core, self._cmd_group)
+		return self._pcc
 
-	@property
-	def extreme(self):
-		"""extreme commands group. 0 Sub-classes, 2 commands."""
-		if not hasattr(self, '_extreme'):
-			from .Low_.Extreme import Extreme
-			self._extreme = Extreme(self._core, self._base)
-		return self._extreme
-
-	@property
-	def standardDev(self):
-		"""standardDev commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_standardDev'):
-			from .Low_.StandardDev import StandardDev
-			self._standardDev = StandardDev(self._core, self._base)
-		return self._standardDev
-
-	def clone(self) -> 'Low':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'UlcaCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Low(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = UlcaCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Peak_/Low_/Average.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Evm/Peak/Low/Average.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,39 +1,40 @@
 from typing import List
 
-from ........Internal.Core import Core
-from ........Internal.CommandsGroup import CommandsGroup
-from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ........Internal.Types import DataType
+from .........Internal.Core import Core
+from .........Internal.CommandsGroup import CommandsGroup
+from .........Internal import Conversions
+from .........Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .........Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class AverageCls:
+	"""Average commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	def fetch(self) -> List[float]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:PEAK:LOW:AVERage \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.evm.peak.low.average.fetch() \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.listPy.modulation.evm.peak.low.average.fetch() \n
 		Return error vector magnitude peak values for low and high EVM window position, for all measured list mode segments. The
 		values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value
 		for each result listed below. \n
 		Suppressed linked return values: reliability \n
 			:return: evm_peak_low: Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:PEAK:LOW:AVERage?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
+	def calculate(self) -> List[float or bool]:
 		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:PEAK:LOW:AVERage \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.evm.peak.low.average.calculate() \n
+		Snippet: value: List[float or bool] = driver.lteMeas.multiEval.listPy.modulation.evm.peak.low.average.calculate() \n
 		Return error vector magnitude peak values for low and high EVM window position, for all measured list mode segments. The
 		values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value
 		for each result listed below. \n
 		Suppressed linked return values: reliability \n
-			:return: evm_peak_low: Comma-separated list of values, one per measured segment"""
+			:return: evm_peak_low: (float or boolean items) Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:PEAK:LOW:AVERage?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:PEAK:LOW:AVERage?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Peak_/Low_/Current.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Evm/Peak/High/Current.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,39 +1,40 @@
 from typing import List
 
-from ........Internal.Core import Core
-from ........Internal.CommandsGroup import CommandsGroup
-from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ........Internal.Types import DataType
+from .........Internal.Core import Core
+from .........Internal.CommandsGroup import CommandsGroup
+from .........Internal import Conversions
+from .........Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .........Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:PEAK:LOW:CURRent \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.evm.peak.low.current.fetch() \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:PEAK:HIGH:CURRent \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.listPy.modulation.evm.peak.high.current.fetch() \n
 		Return error vector magnitude peak values for low and high EVM window position, for all measured list mode segments. The
 		values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value
 		for each result listed below. \n
 		Suppressed linked return values: reliability \n
-			:return: evm_peak_low: Comma-separated list of values, one per measured segment"""
+			:return: evm_peak_high: Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:PEAK:LOW:CURRent?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:PEAK:HIGH:CURRent?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:PEAK:LOW:CURRent \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.evm.peak.low.current.calculate() \n
+	def calculate(self) -> List[float or bool]:
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:PEAK:HIGH:CURRent \n
+		Snippet: value: List[float or bool] = driver.lteMeas.multiEval.listPy.modulation.evm.peak.high.current.calculate() \n
 		Return error vector magnitude peak values for low and high EVM window position, for all measured list mode segments. The
 		values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value
 		for each result listed below. \n
 		Suppressed linked return values: reliability \n
-			:return: evm_peak_low: Comma-separated list of values, one per measured segment"""
+			:return: evm_peak_high: (float or boolean items) Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:PEAK:LOW:CURRent?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:PEAK:HIGH:CURRent?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Peak_/Low_/Extreme.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Evm/Rms/Low/Extreme.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,39 +1,40 @@
 from typing import List
 
-from ........Internal.Core import Core
-from ........Internal.CommandsGroup import CommandsGroup
-from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ........Internal.Types import DataType
+from .........Internal.Core import Core
+from .........Internal.CommandsGroup import CommandsGroup
+from .........Internal import Conversions
+from .........Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .........Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Extreme:
-	"""Extreme commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class ExtremeCls:
+	"""Extreme commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("extreme", core, parent)
+		self._cmd_group = CommandsGroup("extreme", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:PEAK:LOW:EXTReme \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.evm.peak.low.extreme.fetch() \n
-		Return error vector magnitude peak values for low and high EVM window position, for all measured list mode segments. The
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:RMS:LOW:EXTReme \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.listPy.modulation.evm.rms.low.extreme.fetch() \n
+		Return error vector magnitude RMS values for low and high EVM window position, for all measured list mode segments. The
 		values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value
 		for each result listed below. \n
 		Suppressed linked return values: reliability \n
-			:return: evm_peak_low: Comma-separated list of values, one per measured segment"""
+			:return: evm_rms_low: Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:PEAK:LOW:EXTReme?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:RMS:LOW:EXTReme?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:PEAK:LOW:EXTReme \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.evm.peak.low.extreme.calculate() \n
-		Return error vector magnitude peak values for low and high EVM window position, for all measured list mode segments. The
+	def calculate(self) -> List[float or bool]:
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:RMS:LOW:EXTReme \n
+		Snippet: value: List[float or bool] = driver.lteMeas.multiEval.listPy.modulation.evm.rms.low.extreme.calculate() \n
+		Return error vector magnitude RMS values for low and high EVM window position, for all measured list mode segments. The
 		values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value
 		for each result listed below. \n
 		Suppressed linked return values: reliability \n
-			:return: evm_peak_low: Comma-separated list of values, one per measured segment"""
+			:return: evm_rms_low: (float or boolean items) Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:PEAK:LOW:EXTReme?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:RMS:LOW:EXTReme?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Peak_/Low_/StandardDev.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Perror/Rms/Low/StandardDev.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,27 +1,27 @@
 from typing import List
 
-from ........Internal.Core import Core
-from ........Internal.CommandsGroup import CommandsGroup
-from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ........Internal.Types import DataType
+from .........Internal.Core import Core
+from .........Internal.CommandsGroup import CommandsGroup
+from .........Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .........Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class StandardDev:
-	"""StandardDev commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class StandardDevCls:
+	"""StandardDev commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("standardDev", core, parent)
+		self._cmd_group = CommandsGroup("standardDev", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:PEAK:LOW:SDEViation \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.evm.peak.low.standardDev.fetch() \n
-		Return error vector magnitude peak values for low and high EVM window position, for all measured list mode segments. The
-		values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value
-		for each result listed below. \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:RMS:LOW:SDEViation \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.listPy.modulation.perror.rms.low.standardDev.fetch() \n
+		Return phase error RMS values for low and high EVM window position, for all measured list mode segments.
+		The values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one
+		value for each result listed below. \n
 		Suppressed linked return values: reliability \n
-			:return: evm_peak_low: Comma-separated list of values, one per measured segment"""
+			:return: ph_error_rms_low: Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:PEAK:LOW:SDEViation?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:RMS:LOW:SDEViation?', suppressed)
 		return response
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Rms.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Perror/__init__.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,35 +1,43 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Rms:
-	"""Rms commands group definition. 14 total commands, 2 Sub-groups, 0 group commands"""
+class PerrorCls:
+	"""Perror commands group definition. 42 total commands, 3 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("rms", core, parent)
+		self._cmd_group = CommandsGroup("perror", core, parent)
 
 	@property
-	def low(self):
-		"""low commands group. 4 Sub-classes, 0 commands."""
-		if not hasattr(self, '_low'):
-			from .Rms_.Low import Low
-			self._low = Low(self._core, self._base)
-		return self._low
+	def rms(self):
+		"""rms commands group. 2 Sub-classes, 0 commands."""
+		if not hasattr(self, '_rms'):
+			from .Rms import RmsCls
+			self._rms = RmsCls(self._core, self._cmd_group)
+		return self._rms
 
 	@property
-	def high(self):
-		"""high commands group. 4 Sub-classes, 0 commands."""
-		if not hasattr(self, '_high'):
-			from .Rms_.High import High
-			self._high = High(self._core, self._base)
-		return self._high
+	def peak(self):
+		"""peak commands group. 2 Sub-classes, 0 commands."""
+		if not hasattr(self, '_peak'):
+			from .Peak import PeakCls
+			self._peak = PeakCls(self._core, self._cmd_group)
+		return self._peak
 
-	def clone(self) -> 'Rms':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	@property
+	def dmrs(self):
+		"""dmrs commands group. 2 Sub-classes, 0 commands."""
+		if not hasattr(self, '_dmrs'):
+			from .Dmrs import DmrsCls
+			self._dmrs = DmrsCls(self._core, self._cmd_group)
+		return self._dmrs
+
+	def clone(self) -> 'PerrorCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Rms(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = PerrorCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Rms_/High.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Trace/RbaTable/__init__.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,51 +1,51 @@
-from .......Internal.Core import Core
-from .......Internal.CommandsGroup import CommandsGroup
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class High:
-	"""High commands group definition. 7 total commands, 4 Sub-groups, 0 group commands"""
+class RbaTableCls:
+	"""RbaTable commands group definition. 10 total commands, 4 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("high", core, parent)
+		self._cmd_group = CommandsGroup("rbaTable", core, parent)
 
 	@property
-	def current(self):
-		"""current commands group. 0 Sub-classes, 2 commands."""
-		if not hasattr(self, '_current'):
-			from .High_.Current import Current
-			self._current = Current(self._core, self._base)
-		return self._current
+	def scc(self):
+		"""scc commands group. 0 Sub-classes, 2 commands."""
+		if not hasattr(self, '_scc'):
+			from .Scc import SccCls
+			self._scc = SccCls(self._core, self._cmd_group)
+		return self._scc
 
 	@property
-	def average(self):
-		"""average commands group. 0 Sub-classes, 2 commands."""
-		if not hasattr(self, '_average'):
-			from .High_.Average import Average
-			self._average = Average(self._core, self._base)
-		return self._average
+	def ulca(self):
+		"""ulca commands group. 2 Sub-classes, 0 commands."""
+		if not hasattr(self, '_ulca'):
+			from .Ulca import UlcaCls
+			self._ulca = UlcaCls(self._core, self._cmd_group)
+		return self._ulca
 
 	@property
-	def extreme(self):
-		"""extreme commands group. 0 Sub-classes, 2 commands."""
-		if not hasattr(self, '_extreme'):
-			from .High_.Extreme import Extreme
-			self._extreme = Extreme(self._core, self._base)
-		return self._extreme
+	def cc(self):
+		"""cc commands group. 0 Sub-classes, 2 commands."""
+		if not hasattr(self, '_cc'):
+			from .Cc import CcCls
+			self._cc = CcCls(self._core, self._cmd_group)
+		return self._cc
 
 	@property
-	def standardDev(self):
-		"""standardDev commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_standardDev'):
-			from .High_.StandardDev import StandardDev
-			self._standardDev = StandardDev(self._core, self._base)
-		return self._standardDev
+	def pcc(self):
+		"""pcc commands group. 0 Sub-classes, 2 commands."""
+		if not hasattr(self, '_pcc'):
+			from .Pcc import PccCls
+			self._pcc = PccCls(self._core, self._cmd_group)
+		return self._pcc
 
-	def clone(self) -> 'High':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'RbaTableCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = High(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = RbaTableCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Rms_/High_/Average.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Evm/Rms/High/Average.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,39 +1,40 @@
 from typing import List
 
-from ........Internal.Core import Core
-from ........Internal.CommandsGroup import CommandsGroup
-from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ........Internal.Types import DataType
+from .........Internal.Core import Core
+from .........Internal.CommandsGroup import CommandsGroup
+from .........Internal import Conversions
+from .........Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .........Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class AverageCls:
+	"""Average commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	def fetch(self) -> List[float]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:RMS:HIGH:AVERage \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.evm.rms.high.average.fetch() \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.listPy.modulation.evm.rms.high.average.fetch() \n
 		Return error vector magnitude RMS values for low and high EVM window position, for all measured list mode segments. The
 		values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value
 		for each result listed below. \n
 		Suppressed linked return values: reliability \n
 			:return: evm_rms_high: Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:RMS:HIGH:AVERage?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
+	def calculate(self) -> List[float or bool]:
 		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:RMS:HIGH:AVERage \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.evm.rms.high.average.calculate() \n
+		Snippet: value: List[float or bool] = driver.lteMeas.multiEval.listPy.modulation.evm.rms.high.average.calculate() \n
 		Return error vector magnitude RMS values for low and high EVM window position, for all measured list mode segments. The
 		values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value
 		for each result listed below. \n
 		Suppressed linked return values: reliability \n
-			:return: evm_rms_high: Comma-separated list of values, one per measured segment"""
+			:return: evm_rms_high: (float or boolean items) Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:RMS:HIGH:AVERage?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:RMS:HIGH:AVERage?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Rms_/High_/Current.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Evm/Rms/High/Current.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,39 +1,40 @@
 from typing import List
 
-from ........Internal.Core import Core
-from ........Internal.CommandsGroup import CommandsGroup
-from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ........Internal.Types import DataType
+from .........Internal.Core import Core
+from .........Internal.CommandsGroup import CommandsGroup
+from .........Internal import Conversions
+from .........Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .........Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	def fetch(self) -> List[float]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:RMS:HIGH:CURRent \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.evm.rms.high.current.fetch() \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.listPy.modulation.evm.rms.high.current.fetch() \n
 		Return error vector magnitude RMS values for low and high EVM window position, for all measured list mode segments. The
 		values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value
 		for each result listed below. \n
 		Suppressed linked return values: reliability \n
 			:return: evm_rms_high: Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:RMS:HIGH:CURRent?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
+	def calculate(self) -> List[float or bool]:
 		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:RMS:HIGH:CURRent \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.evm.rms.high.current.calculate() \n
+		Snippet: value: List[float or bool] = driver.lteMeas.multiEval.listPy.modulation.evm.rms.high.current.calculate() \n
 		Return error vector magnitude RMS values for low and high EVM window position, for all measured list mode segments. The
 		values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value
 		for each result listed below. \n
 		Suppressed linked return values: reliability \n
-			:return: evm_rms_high: Comma-separated list of values, one per measured segment"""
+			:return: evm_rms_high: (float or boolean items) Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:RMS:HIGH:CURRent?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:RMS:HIGH:CURRent?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Rms_/High_/Extreme.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Evm/Rms/High/Extreme.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,39 +1,40 @@
 from typing import List
 
-from ........Internal.Core import Core
-from ........Internal.CommandsGroup import CommandsGroup
-from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ........Internal.Types import DataType
+from .........Internal.Core import Core
+from .........Internal.CommandsGroup import CommandsGroup
+from .........Internal import Conversions
+from .........Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .........Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Extreme:
-	"""Extreme commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class ExtremeCls:
+	"""Extreme commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("extreme", core, parent)
+		self._cmd_group = CommandsGroup("extreme", core, parent)
 
 	def fetch(self) -> List[float]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:RMS:HIGH:EXTReme \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.evm.rms.high.extreme.fetch() \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.listPy.modulation.evm.rms.high.extreme.fetch() \n
 		Return error vector magnitude RMS values for low and high EVM window position, for all measured list mode segments. The
 		values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value
 		for each result listed below. \n
 		Suppressed linked return values: reliability \n
 			:return: evm_rms_high: Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:RMS:HIGH:EXTReme?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
+	def calculate(self) -> List[float or bool]:
 		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:RMS:HIGH:EXTReme \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.evm.rms.high.extreme.calculate() \n
+		Snippet: value: List[float or bool] = driver.lteMeas.multiEval.listPy.modulation.evm.rms.high.extreme.calculate() \n
 		Return error vector magnitude RMS values for low and high EVM window position, for all measured list mode segments. The
 		values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value
 		for each result listed below. \n
 		Suppressed linked return values: reliability \n
-			:return: evm_rms_high: Comma-separated list of values, one per measured segment"""
+			:return: evm_rms_high: (float or boolean items) Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:RMS:HIGH:EXTReme?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:RMS:HIGH:EXTReme?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Rms_/High_/StandardDev.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Evm/Rms/High/StandardDev.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,26 +1,26 @@
 from typing import List
 
-from ........Internal.Core import Core
-from ........Internal.CommandsGroup import CommandsGroup
-from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ........Internal.Types import DataType
+from .........Internal.Core import Core
+from .........Internal.CommandsGroup import CommandsGroup
+from .........Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .........Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class StandardDev:
-	"""StandardDev commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class StandardDevCls:
+	"""StandardDev commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("standardDev", core, parent)
+		self._cmd_group = CommandsGroup("standardDev", core, parent)
 
 	def fetch(self) -> List[float]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:RMS:HIGH:SDEViation \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.evm.rms.high.standardDev.fetch() \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.listPy.modulation.evm.rms.high.standardDev.fetch() \n
 		Return error vector magnitude RMS values for low and high EVM window position, for all measured list mode segments. The
 		values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value
 		for each result listed below. \n
 		Suppressed linked return values: reliability \n
 			:return: evm_rms_high: Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:RMS:HIGH:SDEViation?', suppressed)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Rms_/Low.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/InbandEmission/__init__.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,51 +1,51 @@
-from .......Internal.Core import Core
-from .......Internal.CommandsGroup import CommandsGroup
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Low:
-	"""Low commands group definition. 7 total commands, 4 Sub-groups, 0 group commands"""
+class InbandEmissionCls:
+	"""InbandEmission commands group definition. 30 total commands, 4 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("low", core, parent)
+		self._cmd_group = CommandsGroup("inbandEmission", core, parent)
 
 	@property
-	def current(self):
-		"""current commands group. 0 Sub-classes, 2 commands."""
-		if not hasattr(self, '_current'):
-			from .Low_.Current import Current
-			self._current = Current(self._core, self._base)
-		return self._current
+	def scc(self):
+		"""scc commands group. 1 Sub-classes, 0 commands."""
+		if not hasattr(self, '_scc'):
+			from .Scc import SccCls
+			self._scc = SccCls(self._core, self._cmd_group)
+		return self._scc
 
 	@property
-	def average(self):
-		"""average commands group. 0 Sub-classes, 2 commands."""
-		if not hasattr(self, '_average'):
-			from .Low_.Average import Average
-			self._average = Average(self._core, self._base)
-		return self._average
+	def ulca(self):
+		"""ulca commands group. 2 Sub-classes, 0 commands."""
+		if not hasattr(self, '_ulca'):
+			from .Ulca import UlcaCls
+			self._ulca = UlcaCls(self._core, self._cmd_group)
+		return self._ulca
 
 	@property
-	def extreme(self):
-		"""extreme commands group. 0 Sub-classes, 2 commands."""
-		if not hasattr(self, '_extreme'):
-			from .Low_.Extreme import Extreme
-			self._extreme = Extreme(self._core, self._base)
-		return self._extreme
+	def cc(self):
+		"""cc commands group. 1 Sub-classes, 0 commands."""
+		if not hasattr(self, '_cc'):
+			from .Cc import CcCls
+			self._cc = CcCls(self._core, self._cmd_group)
+		return self._cc
 
 	@property
-	def standardDev(self):
-		"""standardDev commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_standardDev'):
-			from .Low_.StandardDev import StandardDev
-			self._standardDev = StandardDev(self._core, self._base)
-		return self._standardDev
+	def pcc(self):
+		"""pcc commands group. 1 Sub-classes, 0 commands."""
+		if not hasattr(self, '_pcc'):
+			from .Pcc import PccCls
+			self._pcc = PccCls(self._core, self._cmd_group)
+		return self._pcc
 
-	def clone(self) -> 'Low':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'InbandEmissionCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Low(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = InbandEmissionCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Rms_/Low_/Average.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Evm/Dmrs/Low/Average.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,39 +1,40 @@
 from typing import List
 
-from ........Internal.Core import Core
-from ........Internal.CommandsGroup import CommandsGroup
-from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ........Internal.Types import DataType
+from .........Internal.Core import Core
+from .........Internal.CommandsGroup import CommandsGroup
+from .........Internal import Conversions
+from .........Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .........Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class AverageCls:
+	"""Average commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:RMS:LOW:AVERage \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.evm.rms.low.average.fetch() \n
-		Return error vector magnitude RMS values for low and high EVM window position, for all measured list mode segments. The
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:DMRS:LOW:AVERage \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.listPy.modulation.evm.dmrs.low.average.fetch() \n
+		Return error vector magnitude DMRS values for low and high EVM window position, for all measured list mode segments. The
 		values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value
 		for each result listed below. \n
 		Suppressed linked return values: reliability \n
-			:return: evm_rms_low: Comma-separated list of values, one per measured segment"""
+			:return: evm_dmrs_low: Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:RMS:LOW:AVERage?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:DMRS:LOW:AVERage?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:RMS:LOW:AVERage \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.evm.rms.low.average.calculate() \n
-		Return error vector magnitude RMS values for low and high EVM window position, for all measured list mode segments. The
+	def calculate(self) -> List[float or bool]:
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:DMRS:LOW:AVERage \n
+		Snippet: value: List[float or bool] = driver.lteMeas.multiEval.listPy.modulation.evm.dmrs.low.average.calculate() \n
+		Return error vector magnitude DMRS values for low and high EVM window position, for all measured list mode segments. The
 		values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value
 		for each result listed below. \n
 		Suppressed linked return values: reliability \n
-			:return: evm_rms_low: Comma-separated list of values, one per measured segment"""
+			:return: evm_dmrs_low: (float or boolean items) Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:RMS:LOW:AVERage?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:DMRS:LOW:AVERage?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Rms_/Low_/Current.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Perror/Rms/Low/Current.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,39 +1,40 @@
 from typing import List
 
-from ........Internal.Core import Core
-from ........Internal.CommandsGroup import CommandsGroup
-from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ........Internal.Types import DataType
+from .........Internal.Core import Core
+from .........Internal.CommandsGroup import CommandsGroup
+from .........Internal import Conversions
+from .........Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .........Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:RMS:LOW:CURRent \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.evm.rms.low.current.fetch() \n
-		Return error vector magnitude RMS values for low and high EVM window position, for all measured list mode segments. The
-		values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value
-		for each result listed below. \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:RMS:LOW:CURRent \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.listPy.modulation.perror.rms.low.current.fetch() \n
+		Return phase error RMS values for low and high EVM window position, for all measured list mode segments.
+		The values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one
+		value for each result listed below. \n
 		Suppressed linked return values: reliability \n
-			:return: evm_rms_low: Comma-separated list of values, one per measured segment"""
+			:return: ph_error_rms_low: Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:RMS:LOW:CURRent?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:RMS:LOW:CURRent?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:RMS:LOW:CURRent \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.evm.rms.low.current.calculate() \n
-		Return error vector magnitude RMS values for low and high EVM window position, for all measured list mode segments. The
-		values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value
-		for each result listed below. \n
+	def calculate(self) -> List[float or bool]:
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:RMS:LOW:CURRent \n
+		Snippet: value: List[float or bool] = driver.lteMeas.multiEval.listPy.modulation.perror.rms.low.current.calculate() \n
+		Return phase error RMS values for low and high EVM window position, for all measured list mode segments.
+		The values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one
+		value for each result listed below. \n
 		Suppressed linked return values: reliability \n
-			:return: evm_rms_low: Comma-separated list of values, one per measured segment"""
+			:return: ph_error_rms_low: (float or boolean items) Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:RMS:LOW:CURRent?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:RMS:LOW:CURRent?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Rms_/Low_/Extreme.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Evm/Peak/Low/Extreme.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,39 +1,40 @@
 from typing import List
 
-from ........Internal.Core import Core
-from ........Internal.CommandsGroup import CommandsGroup
-from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ........Internal.Types import DataType
+from .........Internal.Core import Core
+from .........Internal.CommandsGroup import CommandsGroup
+from .........Internal import Conversions
+from .........Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .........Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Extreme:
-	"""Extreme commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class ExtremeCls:
+	"""Extreme commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("extreme", core, parent)
+		self._cmd_group = CommandsGroup("extreme", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:RMS:LOW:EXTReme \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.evm.rms.low.extreme.fetch() \n
-		Return error vector magnitude RMS values for low and high EVM window position, for all measured list mode segments. The
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:PEAK:LOW:EXTReme \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.listPy.modulation.evm.peak.low.extreme.fetch() \n
+		Return error vector magnitude peak values for low and high EVM window position, for all measured list mode segments. The
 		values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value
 		for each result listed below. \n
 		Suppressed linked return values: reliability \n
-			:return: evm_rms_low: Comma-separated list of values, one per measured segment"""
+			:return: evm_peak_low: Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:RMS:LOW:EXTReme?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:PEAK:LOW:EXTReme?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:RMS:LOW:EXTReme \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.evm.rms.low.extreme.calculate() \n
-		Return error vector magnitude RMS values for low and high EVM window position, for all measured list mode segments. The
+	def calculate(self) -> List[float or bool]:
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:PEAK:LOW:EXTReme \n
+		Snippet: value: List[float or bool] = driver.lteMeas.multiEval.listPy.modulation.evm.peak.low.extreme.calculate() \n
+		Return error vector magnitude peak values for low and high EVM window position, for all measured list mode segments. The
 		values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value
 		for each result listed below. \n
 		Suppressed linked return values: reliability \n
-			:return: evm_rms_low: Comma-separated list of values, one per measured segment"""
+			:return: evm_peak_low: (float or boolean items) Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:RMS:LOW:EXTReme?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:PEAK:LOW:EXTReme?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Evm_/Rms_/Low_/StandardDev.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Evm/Rms/Low/StandardDev.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,26 +1,26 @@
 from typing import List
 
-from ........Internal.Core import Core
-from ........Internal.CommandsGroup import CommandsGroup
-from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ........Internal.Types import DataType
+from .........Internal.Core import Core
+from .........Internal.CommandsGroup import CommandsGroup
+from .........Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .........Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class StandardDev:
-	"""StandardDev commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class StandardDevCls:
+	"""StandardDev commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("standardDev", core, parent)
+		self._cmd_group = CommandsGroup("standardDev", core, parent)
 
 	def fetch(self) -> List[float]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:RMS:LOW:SDEViation \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.evm.rms.low.standardDev.fetch() \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.listPy.modulation.evm.rms.low.standardDev.fetch() \n
 		Return error vector magnitude RMS values for low and high EVM window position, for all measured list mode segments. The
 		values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value
 		for each result listed below. \n
 		Suppressed linked return values: reliability \n
 			:return: evm_rms_low: Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:RMS:LOW:SDEViation?', suppressed)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/FreqError.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/InbandEmission/Margin/RbIndex/__init__.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,51 +1,35 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
+from ........Internal.Core import Core
+from ........Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class FreqError:
-	"""FreqError commands group definition. 7 total commands, 4 Sub-groups, 0 group commands"""
+class RbIndexCls:
+	"""RbIndex commands group definition. 2 total commands, 2 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("freqError", core, parent)
+		self._cmd_group = CommandsGroup("rbIndex", core, parent)
 
 	@property
 	def current(self):
-		"""current commands group. 0 Sub-classes, 2 commands."""
+		"""current commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_current'):
-			from .FreqError_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
 	@property
-	def average(self):
-		"""average commands group. 0 Sub-classes, 2 commands."""
-		if not hasattr(self, '_average'):
-			from .FreqError_.Average import Average
-			self._average = Average(self._core, self._base)
-		return self._average
-
-	@property
 	def extreme(self):
-		"""extreme commands group. 0 Sub-classes, 2 commands."""
+		"""extreme commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_extreme'):
-			from .FreqError_.Extreme import Extreme
-			self._extreme = Extreme(self._core, self._base)
+			from .Extreme import ExtremeCls
+			self._extreme = ExtremeCls(self._core, self._cmd_group)
 		return self._extreme
 
-	@property
-	def standardDev(self):
-		"""standardDev commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_standardDev'):
-			from .FreqError_.StandardDev import StandardDev
-			self._standardDev = StandardDev(self._core, self._base)
-		return self._standardDev
-
-	def clone(self) -> 'FreqError':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'RbIndexCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = FreqError(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = RbIndexCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/FreqError_/Average.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Merror/Rms/High/Extreme.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,37 +1,40 @@
 from typing import List
 
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ......Internal.Types import DataType
+from .........Internal.Core import Core
+from .........Internal.CommandsGroup import CommandsGroup
+from .........Internal import Conversions
+from .........Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .........Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class ExtremeCls:
+	"""Extreme commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("extreme", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:FERRor:AVERage \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.freqError.average.fetch() \n
-		Return carrier frequency error values for all measured list mode segments. The values described below are returned by
-		FETCh commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:RMS:HIGH:EXTReme \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.listPy.modulation.merror.rms.high.extreme.fetch() \n
+		Return magnitude error RMS values for low and high EVM window position, for all measured list mode segments. The values
+		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
+		result listed below. \n
 		Suppressed linked return values: reliability \n
-			:return: frequency_error: Comma-separated list of values, one per measured segment"""
+			:return: mag_error_rms_high: Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:FERRor:AVERage?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:RMS:HIGH:EXTReme?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:FERRor:AVERage \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.freqError.average.calculate() \n
-		Return carrier frequency error values for all measured list mode segments. The values described below are returned by
-		FETCh commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
+	def calculate(self) -> List[float or bool]:
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:RMS:HIGH:EXTReme \n
+		Snippet: value: List[float or bool] = driver.lteMeas.multiEval.listPy.modulation.merror.rms.high.extreme.calculate() \n
+		Return magnitude error RMS values for low and high EVM window position, for all measured list mode segments. The values
+		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
+		result listed below. \n
 		Suppressed linked return values: reliability \n
-			:return: frequency_error: Comma-separated list of values, one per measured segment"""
+			:return: mag_error_rms_high: (float or boolean items) Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:FERRor:AVERage?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:RMS:HIGH:EXTReme?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/FreqError_/Current.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/FreqError/Current.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,37 +1,38 @@
 from typing import List
 
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ......Internal.Types import DataType
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal import Conversions
+from .......Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .......Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	def fetch(self) -> List[float]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:FERRor:CURRent \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.freqError.current.fetch() \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.listPy.modulation.freqError.current.fetch() \n
 		Return carrier frequency error values for all measured list mode segments. The values described below are returned by
 		FETCh commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 		Suppressed linked return values: reliability \n
 			:return: frequency_error: Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:FERRor:CURRent?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
+	def calculate(self) -> List[float or bool]:
 		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:FERRor:CURRent \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.freqError.current.calculate() \n
+		Snippet: value: List[float or bool] = driver.lteMeas.multiEval.listPy.modulation.freqError.current.calculate() \n
 		Return carrier frequency error values for all measured list mode segments. The values described below are returned by
 		FETCh commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 		Suppressed linked return values: reliability \n
-			:return: frequency_error: Comma-separated list of values, one per measured segment"""
+			:return: frequency_error: (float or boolean items) Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:FERRor:CURRent?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:FERRor:CURRent?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/FreqError_/Extreme.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/FreqError/Extreme.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,37 +1,38 @@
 from typing import List
 
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ......Internal.Types import DataType
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal import Conversions
+from .......Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .......Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Extreme:
-	"""Extreme commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class ExtremeCls:
+	"""Extreme commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("extreme", core, parent)
+		self._cmd_group = CommandsGroup("extreme", core, parent)
 
 	def fetch(self) -> List[float]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:FERRor:EXTReme \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.freqError.extreme.fetch() \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.listPy.modulation.freqError.extreme.fetch() \n
 		Return carrier frequency error values for all measured list mode segments. The values described below are returned by
 		FETCh commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 		Suppressed linked return values: reliability \n
 			:return: frequency_error: Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:FERRor:EXTReme?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
+	def calculate(self) -> List[float or bool]:
 		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:FERRor:EXTReme \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.freqError.extreme.calculate() \n
+		Snippet: value: List[float or bool] = driver.lteMeas.multiEval.listPy.modulation.freqError.extreme.calculate() \n
 		Return carrier frequency error values for all measured list mode segments. The values described below are returned by
 		FETCh commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 		Suppressed linked return values: reliability \n
-			:return: frequency_error: Comma-separated list of values, one per measured segment"""
+			:return: frequency_error: (float or boolean items) Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:FERRor:EXTReme?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:FERRor:EXTReme?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/FreqError_/StandardDev.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/FreqError/StandardDev.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,26 +1,26 @@
 from typing import List
 
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ......Internal.Types import DataType
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .......Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class StandardDev:
-	"""StandardDev commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class StandardDevCls:
+	"""StandardDev commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("standardDev", core, parent)
+		self._cmd_group = CommandsGroup("standardDev", core, parent)
 
 	def fetch(self) -> List[float]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:FERRor:SDEViation \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.freqError.standardDev.fetch() \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.listPy.modulation.freqError.standardDev.fetch() \n
 		Return carrier frequency error values for all measured list mode segments. The values described below are returned by
 		FETCh commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 		Suppressed linked return values: reliability \n
 			:return: frequency_error: Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:FERRor:SDEViation?', suppressed)
 		return response
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/IqOffset.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/EsFlatness/__init__.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,51 +1,51 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class IqOffset:
-	"""IqOffset commands group definition. 7 total commands, 4 Sub-groups, 0 group commands"""
+class EsFlatnessCls:
+	"""EsFlatness commands group definition. 9 total commands, 4 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("iqOffset", core, parent)
+		self._cmd_group = CommandsGroup("esFlatness", core, parent)
 
 	@property
 	def current(self):
-		"""current commands group. 0 Sub-classes, 2 commands."""
+		"""current commands group. 1 Sub-classes, 2 commands."""
 		if not hasattr(self, '_current'):
-			from .IqOffset_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
 	@property
 	def average(self):
 		"""average commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_average'):
-			from .IqOffset_.Average import Average
-			self._average = Average(self._core, self._base)
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
 		return self._average
 
 	@property
 	def extreme(self):
 		"""extreme commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_extreme'):
-			from .IqOffset_.Extreme import Extreme
-			self._extreme = Extreme(self._core, self._base)
+			from .Extreme import ExtremeCls
+			self._extreme = ExtremeCls(self._core, self._cmd_group)
 		return self._extreme
 
 	@property
 	def standardDev(self):
-		"""standardDev commands group. 0 Sub-classes, 1 commands."""
+		"""standardDev commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_standardDev'):
-			from .IqOffset_.StandardDev import StandardDev
-			self._standardDev = StandardDev(self._core, self._base)
+			from .StandardDev import StandardDevCls
+			self._standardDev = StandardDevCls(self._core, self._cmd_group)
 		return self._standardDev
 
-	def clone(self) -> 'IqOffset':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'EsFlatnessCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = IqOffset(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = EsFlatnessCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/IqOffset_/Average.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Tpower/Average.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,37 +1,38 @@
 from typing import List
 
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ......Internal.Types import DataType
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal import Conversions
+from .......Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .......Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class AverageCls:
+	"""Average commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:IQOFfset:AVERage \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.iqOffset.average.fetch() \n
-		Return I/Q origin offset values for all measured list mode segments. The values described below are returned by FETCh
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:TPOWer:AVERage \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.listPy.modulation.tpower.average.fetch() \n
+		Return user equipment power values for all measured list mode segments. The values described below are returned by FETCh
 		commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 		Suppressed linked return values: reliability \n
-			:return: iq_offset: Comma-separated list of values, one per measured segment"""
+			:return: tx_power: Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:IQOFfset:AVERage?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:TPOWer:AVERage?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:IQOFfset:AVERage \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.iqOffset.average.calculate() \n
-		Return I/Q origin offset values for all measured list mode segments. The values described below are returned by FETCh
+	def calculate(self) -> List[float or bool]:
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:TPOWer:AVERage \n
+		Snippet: value: List[float or bool] = driver.lteMeas.multiEval.listPy.modulation.tpower.average.calculate() \n
+		Return user equipment power values for all measured list mode segments. The values described below are returned by FETCh
 		commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 		Suppressed linked return values: reliability \n
-			:return: iq_offset: Comma-separated list of values, one per measured segment"""
+			:return: tx_power: (float or boolean items) Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:IQOFfset:AVERage?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:TPOWer:AVERage?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/IqOffset_/Current.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/IqOffset/Current.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,37 +1,38 @@
 from typing import List
 
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ......Internal.Types import DataType
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal import Conversions
+from .......Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .......Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	def fetch(self) -> List[float]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:IQOFfset:CURRent \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.iqOffset.current.fetch() \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.listPy.modulation.iqOffset.current.fetch() \n
 		Return I/Q origin offset values for all measured list mode segments. The values described below are returned by FETCh
 		commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 		Suppressed linked return values: reliability \n
 			:return: iq_offset: Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:IQOFfset:CURRent?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
+	def calculate(self) -> List[float or bool]:
 		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:IQOFfset:CURRent \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.iqOffset.current.calculate() \n
+		Snippet: value: List[float or bool] = driver.lteMeas.multiEval.listPy.modulation.iqOffset.current.calculate() \n
 		Return I/Q origin offset values for all measured list mode segments. The values described below are returned by FETCh
 		commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 		Suppressed linked return values: reliability \n
-			:return: iq_offset: Comma-separated list of values, one per measured segment"""
+			:return: iq_offset: (float or boolean items) Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:IQOFfset:CURRent?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:IQOFfset:CURRent?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/IqOffset_/Extreme.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/IqOffset/Extreme.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,37 +1,38 @@
 from typing import List
 
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ......Internal.Types import DataType
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal import Conversions
+from .......Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .......Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Extreme:
-	"""Extreme commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class ExtremeCls:
+	"""Extreme commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("extreme", core, parent)
+		self._cmd_group = CommandsGroup("extreme", core, parent)
 
 	def fetch(self) -> List[float]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:IQOFfset:EXTReme \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.iqOffset.extreme.fetch() \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.listPy.modulation.iqOffset.extreme.fetch() \n
 		Return I/Q origin offset values for all measured list mode segments. The values described below are returned by FETCh
 		commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 		Suppressed linked return values: reliability \n
 			:return: iq_offset: Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:IQOFfset:EXTReme?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
+	def calculate(self) -> List[float or bool]:
 		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:IQOFfset:EXTReme \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.iqOffset.extreme.calculate() \n
+		Snippet: value: List[float or bool] = driver.lteMeas.multiEval.listPy.modulation.iqOffset.extreme.calculate() \n
 		Return I/Q origin offset values for all measured list mode segments. The values described below are returned by FETCh
 		commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 		Suppressed linked return values: reliability \n
-			:return: iq_offset: Comma-separated list of values, one per measured segment"""
+			:return: iq_offset: (float or boolean items) Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:IQOFfset:EXTReme?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:IQOFfset:EXTReme?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/IqOffset_/StandardDev.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Merror/Rms/Low/StandardDev.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,26 +1,27 @@
 from typing import List
 
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ......Internal.Types import DataType
+from .........Internal.Core import Core
+from .........Internal.CommandsGroup import CommandsGroup
+from .........Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .........Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class StandardDev:
-	"""StandardDev commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class StandardDevCls:
+	"""StandardDev commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("standardDev", core, parent)
+		self._cmd_group = CommandsGroup("standardDev", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:IQOFfset:SDEViation \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.iqOffset.standardDev.fetch() \n
-		Return I/Q origin offset values for all measured list mode segments. The values described below are returned by FETCh
-		commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:RMS:LOW:SDEViation \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.listPy.modulation.merror.rms.low.standardDev.fetch() \n
+		Return magnitude error RMS values for low and high EVM window position, for all measured list mode segments. The values
+		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
+		result listed below. \n
 		Suppressed linked return values: reliability \n
-			:return: iq_offset: Comma-separated list of values, one per measured segment"""
+			:return: mag_error_rms_low: Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:IQOFfset:SDEViation?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:RMS:LOW:SDEViation?', suppressed)
 		return response
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Trace/Pmonitor/__init__.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,43 +1,51 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Merror:
-	"""Merror commands group definition. 42 total commands, 3 Sub-groups, 0 group commands"""
+class PmonitorCls:
+	"""Pmonitor commands group definition. 10 total commands, 4 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("merror", core, parent)
+		self._cmd_group = CommandsGroup("pmonitor", core, parent)
 
 	@property
-	def rms(self):
-		"""rms commands group. 2 Sub-classes, 0 commands."""
-		if not hasattr(self, '_rms'):
-			from .Merror_.Rms import Rms
-			self._rms = Rms(self._core, self._base)
-		return self._rms
+	def scc(self):
+		"""scc commands group. 0 Sub-classes, 2 commands."""
+		if not hasattr(self, '_scc'):
+			from .Scc import SccCls
+			self._scc = SccCls(self._core, self._cmd_group)
+		return self._scc
 
 	@property
-	def peak(self):
-		"""peak commands group. 2 Sub-classes, 0 commands."""
-		if not hasattr(self, '_peak'):
-			from .Merror_.Peak import Peak
-			self._peak = Peak(self._core, self._base)
-		return self._peak
+	def ulca(self):
+		"""ulca commands group. 2 Sub-classes, 0 commands."""
+		if not hasattr(self, '_ulca'):
+			from .Ulca import UlcaCls
+			self._ulca = UlcaCls(self._core, self._cmd_group)
+		return self._ulca
 
 	@property
-	def dmrs(self):
-		"""dmrs commands group. 2 Sub-classes, 0 commands."""
-		if not hasattr(self, '_dmrs'):
-			from .Merror_.Dmrs import Dmrs
-			self._dmrs = Dmrs(self._core, self._base)
-		return self._dmrs
+	def cc(self):
+		"""cc commands group. 0 Sub-classes, 2 commands."""
+		if not hasattr(self, '_cc'):
+			from .Cc import CcCls
+			self._cc = CcCls(self._core, self._cmd_group)
+		return self._cc
 
-	def clone(self) -> 'Merror':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	@property
+	def pcc(self):
+		"""pcc commands group. 0 Sub-classes, 2 commands."""
+		if not hasattr(self, '_pcc'):
+			from .Pcc import PccCls
+			self._pcc = PccCls(self._core, self._cmd_group)
+		return self._pcc
+
+	def clone(self) -> 'PmonitorCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Merror(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = PmonitorCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Dmrs.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/Pmonitor/__init__.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,35 +1,43 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Dmrs:
-	"""Dmrs commands group definition. 14 total commands, 2 Sub-groups, 0 group commands"""
+class PmonitorCls:
+	"""Pmonitor commands group definition. 4 total commands, 3 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("dmrs", core, parent)
+		self._cmd_group = CommandsGroup("pmonitor", core, parent)
 
 	@property
-	def low(self):
-		"""low commands group. 4 Sub-classes, 0 commands."""
-		if not hasattr(self, '_low'):
-			from .Dmrs_.Low import Low
-			self._low = Low(self._core, self._base)
-		return self._low
+	def rms(self):
+		"""rms commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_rms'):
+			from .Rms import RmsCls
+			self._rms = RmsCls(self._core, self._cmd_group)
+		return self._rms
 
 	@property
-	def high(self):
-		"""high commands group. 4 Sub-classes, 0 commands."""
-		if not hasattr(self, '_high'):
-			from .Dmrs_.High import High
-			self._high = High(self._core, self._base)
-		return self._high
+	def peak(self):
+		"""peak commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_peak'):
+			from .Peak import PeakCls
+			self._peak = PeakCls(self._core, self._cmd_group)
+		return self._peak
 
-	def clone(self) -> 'Dmrs':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	@property
+	def array(self):
+		"""array commands group. 2 Sub-classes, 0 commands."""
+		if not hasattr(self, '_array'):
+			from .Array import ArrayCls
+			self._array = ArrayCls(self._core, self._cmd_group)
+		return self._array
+
+	def clone(self) -> 'PmonitorCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Dmrs(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = PmonitorCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Dmrs_/High.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Pdynamics/__init__.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,51 +1,59 @@
-from .......Internal.Core import Core
-from .......Internal.CommandsGroup import CommandsGroup
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class High:
-	"""High commands group definition. 7 total commands, 4 Sub-groups, 0 group commands"""
+class PdynamicsCls:
+	"""Pdynamics commands group definition. 15 total commands, 5 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("high", core, parent)
+		self._cmd_group = CommandsGroup("pdynamics", core, parent)
 
 	@property
 	def current(self):
-		"""current commands group. 0 Sub-classes, 2 commands."""
+		"""current commands group. 0 Sub-classes, 3 commands."""
 		if not hasattr(self, '_current'):
-			from .High_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
 	@property
 	def average(self):
-		"""average commands group. 0 Sub-classes, 2 commands."""
+		"""average commands group. 0 Sub-classes, 3 commands."""
 		if not hasattr(self, '_average'):
-			from .High_.Average import Average
-			self._average = Average(self._core, self._base)
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
 		return self._average
 
 	@property
-	def extreme(self):
-		"""extreme commands group. 0 Sub-classes, 2 commands."""
-		if not hasattr(self, '_extreme'):
-			from .High_.Extreme import Extreme
-			self._extreme = Extreme(self._core, self._base)
-		return self._extreme
+	def maximum(self):
+		"""maximum commands group. 0 Sub-classes, 3 commands."""
+		if not hasattr(self, '_maximum'):
+			from .Maximum import MaximumCls
+			self._maximum = MaximumCls(self._core, self._cmd_group)
+		return self._maximum
+
+	@property
+	def minimum(self):
+		"""minimum commands group. 0 Sub-classes, 3 commands."""
+		if not hasattr(self, '_minimum'):
+			from .Minimum import MinimumCls
+			self._minimum = MinimumCls(self._core, self._cmd_group)
+		return self._minimum
 
 	@property
 	def standardDev(self):
-		"""standardDev commands group. 0 Sub-classes, 1 commands."""
+		"""standardDev commands group. 0 Sub-classes, 3 commands."""
 		if not hasattr(self, '_standardDev'):
-			from .High_.StandardDev import StandardDev
-			self._standardDev = StandardDev(self._core, self._base)
+			from .StandardDev import StandardDevCls
+			self._standardDev = StandardDevCls(self._core, self._cmd_group)
 		return self._standardDev
 
-	def clone(self) -> 'High':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'PdynamicsCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = High(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = PdynamicsCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Dmrs_/High_/Average.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Merror/Dmrs/Low/Average.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,39 +1,40 @@
 from typing import List
 
-from ........Internal.Core import Core
-from ........Internal.CommandsGroup import CommandsGroup
-from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ........Internal.Types import DataType
+from .........Internal.Core import Core
+from .........Internal.CommandsGroup import CommandsGroup
+from .........Internal import Conversions
+from .........Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .........Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class AverageCls:
+	"""Average commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:DMRS:HIGH:AVERage \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.merror.dmrs.high.average.fetch() \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:DMRS:LOW:AVERage \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.listPy.modulation.merror.dmrs.low.average.fetch() \n
 		Return magnitude error DMRS values for low and high EVM window position, for all measured list mode segments. The values
 		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
 		result listed below. \n
 		Suppressed linked return values: reliability \n
-			:return: mag_err_dmrs_high: Comma-separated list of values, one per measured segment"""
+			:return: mag_err_dmrs_low: Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:DMRS:HIGH:AVERage?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:DMRS:LOW:AVERage?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:DMRS:HIGH:AVERage \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.merror.dmrs.high.average.calculate() \n
+	def calculate(self) -> List[float or bool]:
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:DMRS:LOW:AVERage \n
+		Snippet: value: List[float or bool] = driver.lteMeas.multiEval.listPy.modulation.merror.dmrs.low.average.calculate() \n
 		Return magnitude error DMRS values for low and high EVM window position, for all measured list mode segments. The values
 		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
 		result listed below. \n
 		Suppressed linked return values: reliability \n
-			:return: mag_err_dmrs_high: Comma-separated list of values, one per measured segment"""
+			:return: mag_err_dmrs_low: (float or boolean items) Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:DMRS:HIGH:AVERage?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:DMRS:LOW:AVERage?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Dmrs_/High_/Current.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Merror/Dmrs/Low/Current.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,39 +1,40 @@
 from typing import List
 
-from ........Internal.Core import Core
-from ........Internal.CommandsGroup import CommandsGroup
-from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ........Internal.Types import DataType
+from .........Internal.Core import Core
+from .........Internal.CommandsGroup import CommandsGroup
+from .........Internal import Conversions
+from .........Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .........Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:DMRS:HIGH:CURRent \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.merror.dmrs.high.current.fetch() \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:DMRS:LOW:CURRent \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.listPy.modulation.merror.dmrs.low.current.fetch() \n
 		Return magnitude error DMRS values for low and high EVM window position, for all measured list mode segments. The values
 		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
 		result listed below. \n
 		Suppressed linked return values: reliability \n
-			:return: mag_err_dmrs_high: Comma-separated list of values, one per measured segment"""
+			:return: mag_err_dmrs_low: Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:DMRS:HIGH:CURRent?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:DMRS:LOW:CURRent?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:DMRS:HIGH:CURRent \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.merror.dmrs.high.current.calculate() \n
+	def calculate(self) -> List[float or bool]:
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:DMRS:LOW:CURRent \n
+		Snippet: value: List[float or bool] = driver.lteMeas.multiEval.listPy.modulation.merror.dmrs.low.current.calculate() \n
 		Return magnitude error DMRS values for low and high EVM window position, for all measured list mode segments. The values
 		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
 		result listed below. \n
 		Suppressed linked return values: reliability \n
-			:return: mag_err_dmrs_high: Comma-separated list of values, one per measured segment"""
+			:return: mag_err_dmrs_low: (float or boolean items) Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:DMRS:HIGH:CURRent?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:DMRS:LOW:CURRent?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Dmrs_/High_/Extreme.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Merror/Dmrs/Low/Extreme.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,39 +1,40 @@
 from typing import List
 
-from ........Internal.Core import Core
-from ........Internal.CommandsGroup import CommandsGroup
-from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ........Internal.Types import DataType
+from .........Internal.Core import Core
+from .........Internal.CommandsGroup import CommandsGroup
+from .........Internal import Conversions
+from .........Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .........Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Extreme:
-	"""Extreme commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class ExtremeCls:
+	"""Extreme commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("extreme", core, parent)
+		self._cmd_group = CommandsGroup("extreme", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:DMRS:HIGH:EXTReme \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.merror.dmrs.high.extreme.fetch() \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:DMRS:LOW:EXTReme \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.listPy.modulation.merror.dmrs.low.extreme.fetch() \n
 		Return magnitude error DMRS values for low and high EVM window position, for all measured list mode segments. The values
 		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
 		result listed below. \n
 		Suppressed linked return values: reliability \n
-			:return: mag_err_dmrs_high: Comma-separated list of values, one per measured segment"""
+			:return: mag_err_dmrs_low: Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:DMRS:HIGH:EXTReme?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:DMRS:LOW:EXTReme?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:DMRS:HIGH:EXTReme \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.merror.dmrs.high.extreme.calculate() \n
+	def calculate(self) -> List[float or bool]:
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:DMRS:LOW:EXTReme \n
+		Snippet: value: List[float or bool] = driver.lteMeas.multiEval.listPy.modulation.merror.dmrs.low.extreme.calculate() \n
 		Return magnitude error DMRS values for low and high EVM window position, for all measured list mode segments. The values
 		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
 		result listed below. \n
 		Suppressed linked return values: reliability \n
-			:return: mag_err_dmrs_high: Comma-separated list of values, one per measured segment"""
+			:return: mag_err_dmrs_low: (float or boolean items) Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:DMRS:HIGH:EXTReme?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:DMRS:LOW:EXTReme?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Dmrs_/High_/StandardDev.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Merror/Peak/High/StandardDev.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,27 +1,27 @@
 from typing import List
 
-from ........Internal.Core import Core
-from ........Internal.CommandsGroup import CommandsGroup
-from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ........Internal.Types import DataType
+from .........Internal.Core import Core
+from .........Internal.CommandsGroup import CommandsGroup
+from .........Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .........Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class StandardDev:
-	"""StandardDev commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class StandardDevCls:
+	"""StandardDev commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("standardDev", core, parent)
+		self._cmd_group = CommandsGroup("standardDev", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:DMRS:HIGH:SDEViation \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.merror.dmrs.high.standardDev.fetch() \n
-		Return magnitude error DMRS values for low and high EVM window position, for all measured list mode segments. The values
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:PEAK:HIGH:SDEViation \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.listPy.modulation.merror.peak.high.standardDev.fetch() \n
+		Return magnitude error peak values for low and high EVM window position, for all measured list mode segments. The values
 		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
 		result listed below. \n
 		Suppressed linked return values: reliability \n
-			:return: mag_err_dmrs_high: Comma-separated list of values, one per measured segment"""
+			:return: mag_err_peak_high: Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:DMRS:HIGH:SDEViation?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:PEAK:HIGH:SDEViation?', suppressed)
 		return response
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Dmrs_/Low.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/Power/__init__.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,51 +1,67 @@
 from .......Internal.Core import Core
 from .......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Low:
-	"""Low commands group definition. 7 total commands, 4 Sub-groups, 0 group commands"""
+class PowerCls:
+	"""Power commands group definition. 18 total commands, 6 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("low", core, parent)
+		self._cmd_group = CommandsGroup("power", core, parent)
 
 	@property
 	def current(self):
 		"""current commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_current'):
-			from .Low_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
 	@property
 	def average(self):
 		"""average commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_average'):
-			from .Low_.Average import Average
-			self._average = Average(self._core, self._base)
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
 		return self._average
 
 	@property
-	def extreme(self):
-		"""extreme commands group. 0 Sub-classes, 2 commands."""
-		if not hasattr(self, '_extreme'):
-			from .Low_.Extreme import Extreme
-			self._extreme = Extreme(self._core, self._base)
-		return self._extreme
+	def minimum(self):
+		"""minimum commands group. 0 Sub-classes, 2 commands."""
+		if not hasattr(self, '_minimum'):
+			from .Minimum import MinimumCls
+			self._minimum = MinimumCls(self._core, self._cmd_group)
+		return self._minimum
+
+	@property
+	def maximum(self):
+		"""maximum commands group. 0 Sub-classes, 2 commands."""
+		if not hasattr(self, '_maximum'):
+			from .Maximum import MaximumCls
+			self._maximum = MaximumCls(self._core, self._cmd_group)
+		return self._maximum
 
 	@property
 	def standardDev(self):
 		"""standardDev commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_standardDev'):
-			from .Low_.StandardDev import StandardDev
-			self._standardDev = StandardDev(self._core, self._base)
+			from .StandardDev import StandardDevCls
+			self._standardDev = StandardDevCls(self._core, self._cmd_group)
 		return self._standardDev
 
-	def clone(self) -> 'Low':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	@property
+	def cc(self):
+		"""cc commands group. 5 Sub-classes, 0 commands."""
+		if not hasattr(self, '_cc'):
+			from .Cc import CcCls
+			self._cc = CcCls(self._core, self._cmd_group)
+		return self._cc
+
+	def clone(self) -> 'PowerCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Low(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = PowerCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Dmrs_/Low_/Average.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Merror/Peak/Low/Average.py`

 * *Files 11% similar despite different names*

```diff
@@ -1,39 +1,40 @@
 from typing import List
 
-from ........Internal.Core import Core
-from ........Internal.CommandsGroup import CommandsGroup
-from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ........Internal.Types import DataType
+from .........Internal.Core import Core
+from .........Internal.CommandsGroup import CommandsGroup
+from .........Internal import Conversions
+from .........Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .........Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class AverageCls:
+	"""Average commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:DMRS:LOW:AVERage \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.merror.dmrs.low.average.fetch() \n
-		Return magnitude error DMRS values for low and high EVM window position, for all measured list mode segments. The values
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:PEAK:LOW:AVERage \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.listPy.modulation.merror.peak.low.average.fetch() \n
+		Return magnitude error peak values for low and high EVM window position, for all measured list mode segments. The values
 		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
 		result listed below. \n
 		Suppressed linked return values: reliability \n
-			:return: mag_err_dmrs_low: Comma-separated list of values, one per measured segment"""
+			:return: mag_error_peak_low: Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:DMRS:LOW:AVERage?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:PEAK:LOW:AVERage?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:DMRS:LOW:AVERage \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.merror.dmrs.low.average.calculate() \n
-		Return magnitude error DMRS values for low and high EVM window position, for all measured list mode segments. The values
+	def calculate(self) -> List[float or bool]:
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:PEAK:LOW:AVERage \n
+		Snippet: value: List[float or bool] = driver.lteMeas.multiEval.listPy.modulation.merror.peak.low.average.calculate() \n
+		Return magnitude error peak values for low and high EVM window position, for all measured list mode segments. The values
 		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
 		result listed below. \n
 		Suppressed linked return values: reliability \n
-			:return: mag_err_dmrs_low: Comma-separated list of values, one per measured segment"""
+			:return: mag_error_peak_low: (float or boolean items) Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:DMRS:LOW:AVERage?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:PEAK:LOW:AVERage?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Dmrs_/Low_/Current.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Merror/Dmrs/High/Current.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,39 +1,40 @@
 from typing import List
 
-from ........Internal.Core import Core
-from ........Internal.CommandsGroup import CommandsGroup
-from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ........Internal.Types import DataType
+from .........Internal.Core import Core
+from .........Internal.CommandsGroup import CommandsGroup
+from .........Internal import Conversions
+from .........Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .........Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:DMRS:LOW:CURRent \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.merror.dmrs.low.current.fetch() \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:DMRS:HIGH:CURRent \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.listPy.modulation.merror.dmrs.high.current.fetch() \n
 		Return magnitude error DMRS values for low and high EVM window position, for all measured list mode segments. The values
 		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
 		result listed below. \n
 		Suppressed linked return values: reliability \n
-			:return: mag_err_dmrs_low: Comma-separated list of values, one per measured segment"""
+			:return: mag_err_dmrs_high: Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:DMRS:LOW:CURRent?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:DMRS:HIGH:CURRent?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:DMRS:LOW:CURRent \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.merror.dmrs.low.current.calculate() \n
+	def calculate(self) -> List[float or bool]:
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:DMRS:HIGH:CURRent \n
+		Snippet: value: List[float or bool] = driver.lteMeas.multiEval.listPy.modulation.merror.dmrs.high.current.calculate() \n
 		Return magnitude error DMRS values for low and high EVM window position, for all measured list mode segments. The values
 		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
 		result listed below. \n
 		Suppressed linked return values: reliability \n
-			:return: mag_err_dmrs_low: Comma-separated list of values, one per measured segment"""
+			:return: mag_err_dmrs_high: (float or boolean items) Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:DMRS:LOW:CURRent?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:DMRS:HIGH:CURRent?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Dmrs_/Low_/Extreme.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Merror/Peak/Low/Extreme.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,39 +1,40 @@
 from typing import List
 
-from ........Internal.Core import Core
-from ........Internal.CommandsGroup import CommandsGroup
-from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ........Internal.Types import DataType
+from .........Internal.Core import Core
+from .........Internal.CommandsGroup import CommandsGroup
+from .........Internal import Conversions
+from .........Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .........Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Extreme:
-	"""Extreme commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class ExtremeCls:
+	"""Extreme commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("extreme", core, parent)
+		self._cmd_group = CommandsGroup("extreme", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:DMRS:LOW:EXTReme \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.merror.dmrs.low.extreme.fetch() \n
-		Return magnitude error DMRS values for low and high EVM window position, for all measured list mode segments. The values
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:PEAK:LOW:EXTReme \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.listPy.modulation.merror.peak.low.extreme.fetch() \n
+		Return magnitude error peak values for low and high EVM window position, for all measured list mode segments. The values
 		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
 		result listed below. \n
 		Suppressed linked return values: reliability \n
-			:return: mag_err_dmrs_low: Comma-separated list of values, one per measured segment"""
+			:return: mag_error_peak_low: Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:DMRS:LOW:EXTReme?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:PEAK:LOW:EXTReme?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:DMRS:LOW:EXTReme \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.merror.dmrs.low.extreme.calculate() \n
-		Return magnitude error DMRS values for low and high EVM window position, for all measured list mode segments. The values
+	def calculate(self) -> List[float or bool]:
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:PEAK:LOW:EXTReme \n
+		Snippet: value: List[float or bool] = driver.lteMeas.multiEval.listPy.modulation.merror.peak.low.extreme.calculate() \n
+		Return magnitude error peak values for low and high EVM window position, for all measured list mode segments. The values
 		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
 		result listed below. \n
 		Suppressed linked return values: reliability \n
-			:return: mag_err_dmrs_low: Comma-separated list of values, one per measured segment"""
+			:return: mag_error_peak_low: (float or boolean items) Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:DMRS:LOW:EXTReme?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:PEAK:LOW:EXTReme?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Dmrs_/Low_/StandardDev.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Perror/Dmrs/Low/StandardDev.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,27 +1,27 @@
 from typing import List
 
-from ........Internal.Core import Core
-from ........Internal.CommandsGroup import CommandsGroup
-from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ........Internal.Types import DataType
+from .........Internal.Core import Core
+from .........Internal.CommandsGroup import CommandsGroup
+from .........Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .........Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class StandardDev:
-	"""StandardDev commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class StandardDevCls:
+	"""StandardDev commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("standardDev", core, parent)
+		self._cmd_group = CommandsGroup("standardDev", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:DMRS:LOW:SDEViation \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.merror.dmrs.low.standardDev.fetch() \n
-		Return magnitude error DMRS values for low and high EVM window position, for all measured list mode segments. The values
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:DMRS:LOW:SDEViation \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.listPy.modulation.perror.dmrs.low.standardDev.fetch() \n
+		Return phase error DMRS values for low and high EVM window position, for all measured list mode segments. The values
 		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
 		result listed below. \n
 		Suppressed linked return values: reliability \n
-			:return: mag_err_dmrs_low: Comma-separated list of values, one per measured segment"""
+			:return: ph_error_dmrs_low: Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:DMRS:LOW:SDEViation?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:DMRS:LOW:SDEViation?', suppressed)
 		return response
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Peak.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/InbandEmission/__init__.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,35 +1,43 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Peak:
-	"""Peak commands group definition. 14 total commands, 2 Sub-groups, 0 group commands"""
+class InbandEmissionCls:
+	"""InbandEmission commands group definition. 18 total commands, 3 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("peak", core, parent)
+		self._cmd_group = CommandsGroup("inbandEmission", core, parent)
 
 	@property
-	def low(self):
-		"""low commands group. 4 Sub-classes, 0 commands."""
-		if not hasattr(self, '_low'):
-			from .Peak_.Low import Low
-			self._low = Low(self._core, self._base)
-		return self._low
+	def scc(self):
+		"""scc commands group. 1 Sub-classes, 0 commands."""
+		if not hasattr(self, '_scc'):
+			from .Scc import SccCls
+			self._scc = SccCls(self._core, self._cmd_group)
+		return self._scc
 
 	@property
-	def high(self):
-		"""high commands group. 4 Sub-classes, 0 commands."""
-		if not hasattr(self, '_high'):
-			from .Peak_.High import High
-			self._high = High(self._core, self._base)
-		return self._high
+	def cc(self):
+		"""cc commands group. 1 Sub-classes, 0 commands."""
+		if not hasattr(self, '_cc'):
+			from .Cc import CcCls
+			self._cc = CcCls(self._core, self._cmd_group)
+		return self._cc
 
-	def clone(self) -> 'Peak':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	@property
+	def margin(self):
+		"""margin commands group. 4 Sub-classes, 0 commands."""
+		if not hasattr(self, '_margin'):
+			from .Margin import MarginCls
+			self._margin = MarginCls(self._core, self._cmd_group)
+		return self._margin
+
+	def clone(self) -> 'InbandEmissionCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Peak(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = InbandEmissionCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Peak_/High.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/Prach/Pdynamics/__init__.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,51 +1,59 @@
-from .......Internal.Core import Core
-from .......Internal.CommandsGroup import CommandsGroup
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class High:
-	"""High commands group definition. 7 total commands, 4 Sub-groups, 0 group commands"""
+class PdynamicsCls:
+	"""Pdynamics commands group definition. 15 total commands, 5 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("high", core, parent)
+		self._cmd_group = CommandsGroup("pdynamics", core, parent)
 
 	@property
 	def current(self):
-		"""current commands group. 0 Sub-classes, 2 commands."""
+		"""current commands group. 0 Sub-classes, 3 commands."""
 		if not hasattr(self, '_current'):
-			from .High_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
 	@property
 	def average(self):
-		"""average commands group. 0 Sub-classes, 2 commands."""
+		"""average commands group. 0 Sub-classes, 3 commands."""
 		if not hasattr(self, '_average'):
-			from .High_.Average import Average
-			self._average = Average(self._core, self._base)
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
 		return self._average
 
 	@property
-	def extreme(self):
-		"""extreme commands group. 0 Sub-classes, 2 commands."""
-		if not hasattr(self, '_extreme'):
-			from .High_.Extreme import Extreme
-			self._extreme = Extreme(self._core, self._base)
-		return self._extreme
+	def maximum(self):
+		"""maximum commands group. 0 Sub-classes, 3 commands."""
+		if not hasattr(self, '_maximum'):
+			from .Maximum import MaximumCls
+			self._maximum = MaximumCls(self._core, self._cmd_group)
+		return self._maximum
+
+	@property
+	def minimum(self):
+		"""minimum commands group. 0 Sub-classes, 3 commands."""
+		if not hasattr(self, '_minimum'):
+			from .Minimum import MinimumCls
+			self._minimum = MinimumCls(self._core, self._cmd_group)
+		return self._minimum
 
 	@property
 	def standardDev(self):
-		"""standardDev commands group. 0 Sub-classes, 1 commands."""
+		"""standardDev commands group. 0 Sub-classes, 3 commands."""
 		if not hasattr(self, '_standardDev'):
-			from .High_.StandardDev import StandardDev
-			self._standardDev = StandardDev(self._core, self._base)
+			from .StandardDev import StandardDevCls
+			self._standardDev = StandardDevCls(self._core, self._cmd_group)
 		return self._standardDev
 
-	def clone(self) -> 'High':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'PdynamicsCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = High(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = PdynamicsCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Peak_/High_/Average.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Merror/Peak/High/Average.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,39 +1,40 @@
 from typing import List
 
-from ........Internal.Core import Core
-from ........Internal.CommandsGroup import CommandsGroup
-from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ........Internal.Types import DataType
+from .........Internal.Core import Core
+from .........Internal.CommandsGroup import CommandsGroup
+from .........Internal import Conversions
+from .........Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .........Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class AverageCls:
+	"""Average commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	def fetch(self) -> List[float]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:PEAK:HIGH:AVERage \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.merror.peak.high.average.fetch() \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.listPy.modulation.merror.peak.high.average.fetch() \n
 		Return magnitude error peak values for low and high EVM window position, for all measured list mode segments. The values
 		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
 		result listed below. \n
 		Suppressed linked return values: reliability \n
 			:return: mag_err_peak_high: Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:PEAK:HIGH:AVERage?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
+	def calculate(self) -> List[float or bool]:
 		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:PEAK:HIGH:AVERage \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.merror.peak.high.average.calculate() \n
+		Snippet: value: List[float or bool] = driver.lteMeas.multiEval.listPy.modulation.merror.peak.high.average.calculate() \n
 		Return magnitude error peak values for low and high EVM window position, for all measured list mode segments. The values
 		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
 		result listed below. \n
 		Suppressed linked return values: reliability \n
-			:return: mag_err_peak_high: Comma-separated list of values, one per measured segment"""
+			:return: mag_err_peak_high: (float or boolean items) Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:PEAK:HIGH:AVERage?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:PEAK:HIGH:AVERage?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Peak_/High_/Current.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Perror/Peak/High/Extreme.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,39 +1,40 @@
 from typing import List
 
-from ........Internal.Core import Core
-from ........Internal.CommandsGroup import CommandsGroup
-from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ........Internal.Types import DataType
+from .........Internal.Core import Core
+from .........Internal.CommandsGroup import CommandsGroup
+from .........Internal import Conversions
+from .........Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .........Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class ExtremeCls:
+	"""Extreme commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("extreme", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:PEAK:HIGH:CURRent \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.merror.peak.high.current.fetch() \n
-		Return magnitude error peak values for low and high EVM window position, for all measured list mode segments. The values
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:PEAK:HIGH:EXTReme \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.listPy.modulation.perror.peak.high.extreme.fetch() \n
+		Return phase error peak values for low and high EVM window position, for all measured list mode segments. The values
 		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
 		result listed below. \n
 		Suppressed linked return values: reliability \n
-			:return: mag_err_peak_high: Comma-separated list of values, one per measured segment"""
+			:return: ph_error_peak_high: Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:PEAK:HIGH:CURRent?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:PEAK:HIGH:EXTReme?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:PEAK:HIGH:CURRent \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.merror.peak.high.current.calculate() \n
-		Return magnitude error peak values for low and high EVM window position, for all measured list mode segments. The values
+	def calculate(self) -> List[float or bool]:
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:PEAK:HIGH:EXTReme \n
+		Snippet: value: List[float or bool] = driver.lteMeas.multiEval.listPy.modulation.perror.peak.high.extreme.calculate() \n
+		Return phase error peak values for low and high EVM window position, for all measured list mode segments. The values
 		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
 		result listed below. \n
 		Suppressed linked return values: reliability \n
-			:return: mag_err_peak_high: Comma-separated list of values, one per measured segment"""
+			:return: ph_error_peak_high: (float or boolean items) Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:PEAK:HIGH:CURRent?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:PEAK:HIGH:EXTReme?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Peak_/High_/Extreme.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Merror/Peak/High/Extreme.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,39 +1,40 @@
 from typing import List
 
-from ........Internal.Core import Core
-from ........Internal.CommandsGroup import CommandsGroup
-from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ........Internal.Types import DataType
+from .........Internal.Core import Core
+from .........Internal.CommandsGroup import CommandsGroup
+from .........Internal import Conversions
+from .........Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .........Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Extreme:
-	"""Extreme commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class ExtremeCls:
+	"""Extreme commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("extreme", core, parent)
+		self._cmd_group = CommandsGroup("extreme", core, parent)
 
 	def fetch(self) -> List[float]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:PEAK:HIGH:EXTReme \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.merror.peak.high.extreme.fetch() \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.listPy.modulation.merror.peak.high.extreme.fetch() \n
 		Return magnitude error peak values for low and high EVM window position, for all measured list mode segments. The values
 		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
 		result listed below. \n
 		Suppressed linked return values: reliability \n
 			:return: mag_err_peak_high: Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:PEAK:HIGH:EXTReme?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
+	def calculate(self) -> List[float or bool]:
 		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:PEAK:HIGH:EXTReme \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.merror.peak.high.extreme.calculate() \n
+		Snippet: value: List[float or bool] = driver.lteMeas.multiEval.listPy.modulation.merror.peak.high.extreme.calculate() \n
 		Return magnitude error peak values for low and high EVM window position, for all measured list mode segments. The values
 		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
 		result listed below. \n
 		Suppressed linked return values: reliability \n
-			:return: mag_err_peak_high: Comma-separated list of values, one per measured segment"""
+			:return: mag_err_peak_high: (float or boolean items) Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:PEAK:HIGH:EXTReme?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:PEAK:HIGH:EXTReme?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Peak_/High_/StandardDev.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Perror/Peak/High/StandardDev.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,27 +1,27 @@
 from typing import List
 
-from ........Internal.Core import Core
-from ........Internal.CommandsGroup import CommandsGroup
-from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ........Internal.Types import DataType
+from .........Internal.Core import Core
+from .........Internal.CommandsGroup import CommandsGroup
+from .........Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .........Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class StandardDev:
-	"""StandardDev commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class StandardDevCls:
+	"""StandardDev commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("standardDev", core, parent)
+		self._cmd_group = CommandsGroup("standardDev", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:PEAK:HIGH:SDEViation \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.merror.peak.high.standardDev.fetch() \n
-		Return magnitude error peak values for low and high EVM window position, for all measured list mode segments. The values
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:PEAK:HIGH:SDEViation \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.listPy.modulation.perror.peak.high.standardDev.fetch() \n
+		Return phase error peak values for low and high EVM window position, for all measured list mode segments. The values
 		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
 		result listed below. \n
 		Suppressed linked return values: reliability \n
-			:return: mag_err_peak_high: Comma-separated list of values, one per measured segment"""
+			:return: ph_error_peak_high: Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:PEAK:HIGH:SDEViation?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:PEAK:HIGH:SDEViation?', suppressed)
 		return response
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Peak_/Low.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Merror/Peak/__init__.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,51 +1,35 @@
-from .......Internal.Core import Core
-from .......Internal.CommandsGroup import CommandsGroup
+from ........Internal.Core import Core
+from ........Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Low:
-	"""Low commands group definition. 7 total commands, 4 Sub-groups, 0 group commands"""
+class PeakCls:
+	"""Peak commands group definition. 14 total commands, 2 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("low", core, parent)
+		self._cmd_group = CommandsGroup("peak", core, parent)
 
 	@property
-	def current(self):
-		"""current commands group. 0 Sub-classes, 2 commands."""
-		if not hasattr(self, '_current'):
-			from .Low_.Current import Current
-			self._current = Current(self._core, self._base)
-		return self._current
+	def low(self):
+		"""low commands group. 4 Sub-classes, 0 commands."""
+		if not hasattr(self, '_low'):
+			from .Low import LowCls
+			self._low = LowCls(self._core, self._cmd_group)
+		return self._low
 
 	@property
-	def average(self):
-		"""average commands group. 0 Sub-classes, 2 commands."""
-		if not hasattr(self, '_average'):
-			from .Low_.Average import Average
-			self._average = Average(self._core, self._base)
-		return self._average
+	def high(self):
+		"""high commands group. 4 Sub-classes, 0 commands."""
+		if not hasattr(self, '_high'):
+			from .High import HighCls
+			self._high = HighCls(self._core, self._cmd_group)
+		return self._high
 
-	@property
-	def extreme(self):
-		"""extreme commands group. 0 Sub-classes, 2 commands."""
-		if not hasattr(self, '_extreme'):
-			from .Low_.Extreme import Extreme
-			self._extreme = Extreme(self._core, self._base)
-		return self._extreme
-
-	@property
-	def standardDev(self):
-		"""standardDev commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_standardDev'):
-			from .Low_.StandardDev import StandardDev
-			self._standardDev = StandardDev(self._core, self._base)
-		return self._standardDev
-
-	def clone(self) -> 'Low':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'PeakCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Low(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = PeakCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Peak_/Low_/Average.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Merror/Rms/Low/Average.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,39 +1,40 @@
 from typing import List
 
-from ........Internal.Core import Core
-from ........Internal.CommandsGroup import CommandsGroup
-from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ........Internal.Types import DataType
+from .........Internal.Core import Core
+from .........Internal.CommandsGroup import CommandsGroup
+from .........Internal import Conversions
+from .........Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .........Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class AverageCls:
+	"""Average commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:PEAK:LOW:AVERage \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.merror.peak.low.average.fetch() \n
-		Return magnitude error peak values for low and high EVM window position, for all measured list mode segments. The values
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:RMS:LOW:AVERage \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.listPy.modulation.merror.rms.low.average.fetch() \n
+		Return magnitude error RMS values for low and high EVM window position, for all measured list mode segments. The values
 		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
 		result listed below. \n
 		Suppressed linked return values: reliability \n
-			:return: mag_error_peak_low: Comma-separated list of values, one per measured segment"""
+			:return: mag_error_rms_low: Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:PEAK:LOW:AVERage?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:RMS:LOW:AVERage?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:PEAK:LOW:AVERage \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.merror.peak.low.average.calculate() \n
-		Return magnitude error peak values for low and high EVM window position, for all measured list mode segments. The values
+	def calculate(self) -> List[float or bool]:
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:RMS:LOW:AVERage \n
+		Snippet: value: List[float or bool] = driver.lteMeas.multiEval.listPy.modulation.merror.rms.low.average.calculate() \n
+		Return magnitude error RMS values for low and high EVM window position, for all measured list mode segments. The values
 		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
 		result listed below. \n
 		Suppressed linked return values: reliability \n
-			:return: mag_error_peak_low: Comma-separated list of values, one per measured segment"""
+			:return: mag_error_rms_low: (float or boolean items) Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:PEAK:LOW:AVERage?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:RMS:LOW:AVERage?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Peak_/Low_/Current.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Merror/Peak/Low/Current.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,39 +1,40 @@
 from typing import List
 
-from ........Internal.Core import Core
-from ........Internal.CommandsGroup import CommandsGroup
-from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ........Internal.Types import DataType
+from .........Internal.Core import Core
+from .........Internal.CommandsGroup import CommandsGroup
+from .........Internal import Conversions
+from .........Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .........Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	def fetch(self) -> List[float]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:PEAK:LOW:CURRent \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.merror.peak.low.current.fetch() \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.listPy.modulation.merror.peak.low.current.fetch() \n
 		Return magnitude error peak values for low and high EVM window position, for all measured list mode segments. The values
 		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
 		result listed below. \n
 		Suppressed linked return values: reliability \n
 			:return: mag_error_peak_low: Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:PEAK:LOW:CURRent?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
+	def calculate(self) -> List[float or bool]:
 		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:PEAK:LOW:CURRent \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.merror.peak.low.current.calculate() \n
+		Snippet: value: List[float or bool] = driver.lteMeas.multiEval.listPy.modulation.merror.peak.low.current.calculate() \n
 		Return magnitude error peak values for low and high EVM window position, for all measured list mode segments. The values
 		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
 		result listed below. \n
 		Suppressed linked return values: reliability \n
-			:return: mag_error_peak_low: Comma-separated list of values, one per measured segment"""
+			:return: mag_error_peak_low: (float or boolean items) Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:PEAK:LOW:CURRent?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:PEAK:LOW:CURRent?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Peak_/Low_/Extreme.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Perror/Peak/Low/Extreme.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,39 +1,40 @@
 from typing import List
 
-from ........Internal.Core import Core
-from ........Internal.CommandsGroup import CommandsGroup
-from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ........Internal.Types import DataType
+from .........Internal.Core import Core
+from .........Internal.CommandsGroup import CommandsGroup
+from .........Internal import Conversions
+from .........Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .........Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Extreme:
-	"""Extreme commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class ExtremeCls:
+	"""Extreme commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("extreme", core, parent)
+		self._cmd_group = CommandsGroup("extreme", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:PEAK:LOW:EXTReme \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.merror.peak.low.extreme.fetch() \n
-		Return magnitude error peak values for low and high EVM window position, for all measured list mode segments. The values
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:PEAK:LOW:EXTReme \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.listPy.modulation.perror.peak.low.extreme.fetch() \n
+		Return phase error peak values for low and high EVM window position, for all measured list mode segments. The values
 		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
 		result listed below. \n
 		Suppressed linked return values: reliability \n
-			:return: mag_error_peak_low: Comma-separated list of values, one per measured segment"""
+			:return: ph_error_peak_low: Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:PEAK:LOW:EXTReme?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:PEAK:LOW:EXTReme?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:PEAK:LOW:EXTReme \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.merror.peak.low.extreme.calculate() \n
-		Return magnitude error peak values for low and high EVM window position, for all measured list mode segments. The values
+	def calculate(self) -> List[float or bool]:
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:PEAK:LOW:EXTReme \n
+		Snippet: value: List[float or bool] = driver.lteMeas.multiEval.listPy.modulation.perror.peak.low.extreme.calculate() \n
+		Return phase error peak values for low and high EVM window position, for all measured list mode segments. The values
 		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
 		result listed below. \n
 		Suppressed linked return values: reliability \n
-			:return: mag_error_peak_low: Comma-separated list of values, one per measured segment"""
+			:return: ph_error_peak_low: (float or boolean items) Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:PEAK:LOW:EXTReme?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:PEAK:LOW:EXTReme?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Peak_/Low_/StandardDev.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Merror/Peak/Low/StandardDev.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,26 +1,26 @@
 from typing import List
 
-from ........Internal.Core import Core
-from ........Internal.CommandsGroup import CommandsGroup
-from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ........Internal.Types import DataType
+from .........Internal.Core import Core
+from .........Internal.CommandsGroup import CommandsGroup
+from .........Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .........Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class StandardDev:
-	"""StandardDev commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class StandardDevCls:
+	"""StandardDev commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("standardDev", core, parent)
+		self._cmd_group = CommandsGroup("standardDev", core, parent)
 
 	def fetch(self) -> List[float]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:PEAK:LOW:SDEViation \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.merror.peak.low.standardDev.fetch() \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.listPy.modulation.merror.peak.low.standardDev.fetch() \n
 		Return magnitude error peak values for low and high EVM window position, for all measured list mode segments. The values
 		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
 		result listed below. \n
 		Suppressed linked return values: reliability \n
 			:return: mag_error_peak_low: Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:PEAK:LOW:SDEViation?', suppressed)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Rms.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Perror/Peak/__init__.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,35 +1,35 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
+from ........Internal.Core import Core
+from ........Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Rms:
-	"""Rms commands group definition. 14 total commands, 2 Sub-groups, 0 group commands"""
+class PeakCls:
+	"""Peak commands group definition. 14 total commands, 2 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("rms", core, parent)
+		self._cmd_group = CommandsGroup("peak", core, parent)
 
 	@property
 	def low(self):
 		"""low commands group. 4 Sub-classes, 0 commands."""
 		if not hasattr(self, '_low'):
-			from .Rms_.Low import Low
-			self._low = Low(self._core, self._base)
+			from .Low import LowCls
+			self._low = LowCls(self._core, self._cmd_group)
 		return self._low
 
 	@property
 	def high(self):
 		"""high commands group. 4 Sub-classes, 0 commands."""
 		if not hasattr(self, '_high'):
-			from .Rms_.High import High
-			self._high = High(self._core, self._base)
+			from .High import HighCls
+			self._high = HighCls(self._core, self._cmd_group)
 		return self._high
 
-	def clone(self) -> 'Rms':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'PeakCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Rms(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = PeakCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Rms_/High.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/Srs/Pdynamics/__init__.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,51 +1,59 @@
-from .......Internal.Core import Core
-from .......Internal.CommandsGroup import CommandsGroup
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class High:
-	"""High commands group definition. 7 total commands, 4 Sub-groups, 0 group commands"""
+class PdynamicsCls:
+	"""Pdynamics commands group definition. 15 total commands, 5 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("high", core, parent)
+		self._cmd_group = CommandsGroup("pdynamics", core, parent)
 
 	@property
 	def current(self):
-		"""current commands group. 0 Sub-classes, 2 commands."""
+		"""current commands group. 0 Sub-classes, 3 commands."""
 		if not hasattr(self, '_current'):
-			from .High_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
 	@property
 	def average(self):
-		"""average commands group. 0 Sub-classes, 2 commands."""
+		"""average commands group. 0 Sub-classes, 3 commands."""
 		if not hasattr(self, '_average'):
-			from .High_.Average import Average
-			self._average = Average(self._core, self._base)
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
 		return self._average
 
 	@property
-	def extreme(self):
-		"""extreme commands group. 0 Sub-classes, 2 commands."""
-		if not hasattr(self, '_extreme'):
-			from .High_.Extreme import Extreme
-			self._extreme = Extreme(self._core, self._base)
-		return self._extreme
+	def maximum(self):
+		"""maximum commands group. 0 Sub-classes, 3 commands."""
+		if not hasattr(self, '_maximum'):
+			from .Maximum import MaximumCls
+			self._maximum = MaximumCls(self._core, self._cmd_group)
+		return self._maximum
+
+	@property
+	def minimum(self):
+		"""minimum commands group. 0 Sub-classes, 3 commands."""
+		if not hasattr(self, '_minimum'):
+			from .Minimum import MinimumCls
+			self._minimum = MinimumCls(self._core, self._cmd_group)
+		return self._minimum
 
 	@property
 	def standardDev(self):
-		"""standardDev commands group. 0 Sub-classes, 1 commands."""
+		"""standardDev commands group. 0 Sub-classes, 3 commands."""
 		if not hasattr(self, '_standardDev'):
-			from .High_.StandardDev import StandardDev
-			self._standardDev = StandardDev(self._core, self._base)
+			from .StandardDev import StandardDevCls
+			self._standardDev = StandardDevCls(self._core, self._cmd_group)
 		return self._standardDev
 
-	def clone(self) -> 'High':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'PdynamicsCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = High(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = PdynamicsCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Rms_/High_/Average.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/IqOffset/Average.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,39 +1,38 @@
 from typing import List
 
-from ........Internal.Core import Core
-from ........Internal.CommandsGroup import CommandsGroup
-from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ........Internal.Types import DataType
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal import Conversions
+from .......Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .......Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class AverageCls:
+	"""Average commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:RMS:HIGH:AVERage \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.merror.rms.high.average.fetch() \n
-		Return magnitude error RMS values for low and high EVM window position, for all measured list mode segments. The values
-		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
-		result listed below. \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:IQOFfset:AVERage \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.listPy.modulation.iqOffset.average.fetch() \n
+		Return I/Q origin offset values for all measured list mode segments. The values described below are returned by FETCh
+		commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 		Suppressed linked return values: reliability \n
-			:return: mag_error_rms_high: Comma-separated list of values, one per measured segment"""
+			:return: iq_offset: Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:RMS:HIGH:AVERage?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:IQOFfset:AVERage?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:RMS:HIGH:AVERage \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.merror.rms.high.average.calculate() \n
-		Return magnitude error RMS values for low and high EVM window position, for all measured list mode segments. The values
-		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
-		result listed below. \n
+	def calculate(self) -> List[float or bool]:
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:IQOFfset:AVERage \n
+		Snippet: value: List[float or bool] = driver.lteMeas.multiEval.listPy.modulation.iqOffset.average.calculate() \n
+		Return I/Q origin offset values for all measured list mode segments. The values described below are returned by FETCh
+		commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 		Suppressed linked return values: reliability \n
-			:return: mag_error_rms_high: Comma-separated list of values, one per measured segment"""
+			:return: iq_offset: (float or boolean items) Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:RMS:HIGH:AVERage?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:IQOFfset:AVERage?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Rms_/High_/Current.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Evm/Rms/Low/Current.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,39 +1,40 @@
 from typing import List
 
-from ........Internal.Core import Core
-from ........Internal.CommandsGroup import CommandsGroup
-from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ........Internal.Types import DataType
+from .........Internal.Core import Core
+from .........Internal.CommandsGroup import CommandsGroup
+from .........Internal import Conversions
+from .........Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .........Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:RMS:HIGH:CURRent \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.merror.rms.high.current.fetch() \n
-		Return magnitude error RMS values for low and high EVM window position, for all measured list mode segments. The values
-		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
-		result listed below. \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:RMS:LOW:CURRent \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.listPy.modulation.evm.rms.low.current.fetch() \n
+		Return error vector magnitude RMS values for low and high EVM window position, for all measured list mode segments. The
+		values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value
+		for each result listed below. \n
 		Suppressed linked return values: reliability \n
-			:return: mag_error_rms_high: Comma-separated list of values, one per measured segment"""
+			:return: evm_rms_low: Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:RMS:HIGH:CURRent?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:RMS:LOW:CURRent?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:RMS:HIGH:CURRent \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.merror.rms.high.current.calculate() \n
-		Return magnitude error RMS values for low and high EVM window position, for all measured list mode segments. The values
-		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
-		result listed below. \n
+	def calculate(self) -> List[float or bool]:
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:RMS:LOW:CURRent \n
+		Snippet: value: List[float or bool] = driver.lteMeas.multiEval.listPy.modulation.evm.rms.low.current.calculate() \n
+		Return error vector magnitude RMS values for low and high EVM window position, for all measured list mode segments. The
+		values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value
+		for each result listed below. \n
 		Suppressed linked return values: reliability \n
-			:return: mag_error_rms_high: Comma-separated list of values, one per measured segment"""
+			:return: evm_rms_low: (float or boolean items) Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:RMS:HIGH:CURRent?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:RMS:LOW:CURRent?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Rms_/High_/Extreme.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Merror/Rms/Low/Extreme.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,39 +1,40 @@
 from typing import List
 
-from ........Internal.Core import Core
-from ........Internal.CommandsGroup import CommandsGroup
-from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ........Internal.Types import DataType
+from .........Internal.Core import Core
+from .........Internal.CommandsGroup import CommandsGroup
+from .........Internal import Conversions
+from .........Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .........Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Extreme:
-	"""Extreme commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class ExtremeCls:
+	"""Extreme commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("extreme", core, parent)
+		self._cmd_group = CommandsGroup("extreme", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:RMS:HIGH:EXTReme \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.merror.rms.high.extreme.fetch() \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:RMS:LOW:EXTReme \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.listPy.modulation.merror.rms.low.extreme.fetch() \n
 		Return magnitude error RMS values for low and high EVM window position, for all measured list mode segments. The values
 		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
 		result listed below. \n
 		Suppressed linked return values: reliability \n
-			:return: mag_error_rms_high: Comma-separated list of values, one per measured segment"""
+			:return: mag_error_rms_low: Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:RMS:HIGH:EXTReme?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:RMS:LOW:EXTReme?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:RMS:HIGH:EXTReme \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.merror.rms.high.extreme.calculate() \n
+	def calculate(self) -> List[float or bool]:
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:RMS:LOW:EXTReme \n
+		Snippet: value: List[float or bool] = driver.lteMeas.multiEval.listPy.modulation.merror.rms.low.extreme.calculate() \n
 		Return magnitude error RMS values for low and high EVM window position, for all measured list mode segments. The values
 		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
 		result listed below. \n
 		Suppressed linked return values: reliability \n
-			:return: mag_error_rms_high: Comma-separated list of values, one per measured segment"""
+			:return: mag_error_rms_low: (float or boolean items) Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:RMS:HIGH:EXTReme?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:RMS:LOW:EXTReme?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Rms_/High_/StandardDev.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Merror/Rms/High/StandardDev.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,26 +1,26 @@
 from typing import List
 
-from ........Internal.Core import Core
-from ........Internal.CommandsGroup import CommandsGroup
-from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ........Internal.Types import DataType
+from .........Internal.Core import Core
+from .........Internal.CommandsGroup import CommandsGroup
+from .........Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .........Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class StandardDev:
-	"""StandardDev commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class StandardDevCls:
+	"""StandardDev commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("standardDev", core, parent)
+		self._cmd_group = CommandsGroup("standardDev", core, parent)
 
 	def fetch(self) -> List[float]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:RMS:HIGH:SDEViation \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.merror.rms.high.standardDev.fetch() \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.listPy.modulation.merror.rms.high.standardDev.fetch() \n
 		Return magnitude error RMS values for low and high EVM window position, for all measured list mode segments. The values
 		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
 		result listed below. \n
 		Suppressed linked return values: reliability \n
 			:return: mag_error_rms_high: Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:RMS:HIGH:SDEViation?', suppressed)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Rms_/Low.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/SeMask/Margin/Current/__init__.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,51 +1,35 @@
 from .......Internal.Core import Core
 from .......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Low:
-	"""Low commands group definition. 7 total commands, 4 Sub-groups, 0 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 2 total commands, 2 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("low", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	@property
-	def current(self):
-		"""current commands group. 0 Sub-classes, 2 commands."""
-		if not hasattr(self, '_current'):
-			from .Low_.Current import Current
-			self._current = Current(self._core, self._base)
-		return self._current
+	def negativ(self):
+		"""negativ commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_negativ'):
+			from .Negativ import NegativCls
+			self._negativ = NegativCls(self._core, self._cmd_group)
+		return self._negativ
 
 	@property
-	def average(self):
-		"""average commands group. 0 Sub-classes, 2 commands."""
-		if not hasattr(self, '_average'):
-			from .Low_.Average import Average
-			self._average = Average(self._core, self._base)
-		return self._average
+	def positiv(self):
+		"""positiv commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_positiv'):
+			from .Positiv import PositivCls
+			self._positiv = PositivCls(self._core, self._cmd_group)
+		return self._positiv
 
-	@property
-	def extreme(self):
-		"""extreme commands group. 0 Sub-classes, 2 commands."""
-		if not hasattr(self, '_extreme'):
-			from .Low_.Extreme import Extreme
-			self._extreme = Extreme(self._core, self._base)
-		return self._extreme
-
-	@property
-	def standardDev(self):
-		"""standardDev commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_standardDev'):
-			from .Low_.StandardDev import StandardDev
-			self._standardDev = StandardDev(self._core, self._base)
-		return self._standardDev
-
-	def clone(self) -> 'Low':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'CurrentCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Low(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = CurrentCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Rms_/Low_/Average.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/SeMask/Obw/Average.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,39 +1,38 @@
 from typing import List
 
-from ........Internal.Core import Core
-from ........Internal.CommandsGroup import CommandsGroup
-from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ........Internal.Types import DataType
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal import Conversions
+from .......Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .......Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class AverageCls:
+	"""Average commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:RMS:LOW:AVERage \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.merror.rms.low.average.fetch() \n
-		Return magnitude error RMS values for low and high EVM window position, for all measured list mode segments. The values
-		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
-		result listed below. \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEMask:OBW:AVERage \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.listPy.seMask.obw.average.fetch() \n
+		Return the occupied bandwidth for all measured list mode segments. The values described below are returned by FETCh
+		commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 		Suppressed linked return values: reliability \n
-			:return: mag_error_rms_low: Comma-separated list of values, one per measured segment"""
+			:return: obw: Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:RMS:LOW:AVERage?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEMask:OBW:AVERage?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:RMS:LOW:AVERage \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.merror.rms.low.average.calculate() \n
-		Return magnitude error RMS values for low and high EVM window position, for all measured list mode segments. The values
-		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
-		result listed below. \n
+	def calculate(self) -> List[float or bool]:
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEMask:OBW:AVERage \n
+		Snippet: value: List[float or bool] = driver.lteMeas.multiEval.listPy.seMask.obw.average.calculate() \n
+		Return the occupied bandwidth for all measured list mode segments. The values described below are returned by FETCh
+		commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 		Suppressed linked return values: reliability \n
-			:return: mag_error_rms_low: Comma-separated list of values, one per measured segment"""
+			:return: obw: (float or boolean items) Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:RMS:LOW:AVERage?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEMask:OBW:AVERage?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Rms_/Low_/Current.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Terror/Current.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,39 +1,38 @@
 from typing import List
 
-from ........Internal.Core import Core
-from ........Internal.CommandsGroup import CommandsGroup
-from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ........Internal.Types import DataType
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal import Conversions
+from .......Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .......Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:RMS:LOW:CURRent \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.merror.rms.low.current.fetch() \n
-		Return magnitude error RMS values for low and high EVM window position, for all measured list mode segments. The values
-		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
-		result listed below. \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:TERRor:CURRent \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.listPy.modulation.terror.current.fetch() \n
+		Return transmit time error values for all measured list mode segments. The values described below are returned by FETCh
+		commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 		Suppressed linked return values: reliability \n
-			:return: mag_error_rms_low: Comma-separated list of values, one per measured segment"""
+			:return: timing_error: Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:RMS:LOW:CURRent?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:TERRor:CURRent?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:RMS:LOW:CURRent \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.merror.rms.low.current.calculate() \n
-		Return magnitude error RMS values for low and high EVM window position, for all measured list mode segments. The values
-		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
-		result listed below. \n
+	def calculate(self) -> List[float or bool]:
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:TERRor:CURRent \n
+		Snippet: value: List[float or bool] = driver.lteMeas.multiEval.listPy.modulation.terror.current.calculate() \n
+		Return transmit time error values for all measured list mode segments. The values described below are returned by FETCh
+		commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 		Suppressed linked return values: reliability \n
-			:return: mag_error_rms_low: Comma-separated list of values, one per measured segment"""
+			:return: timing_error: (float or boolean items) Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:RMS:LOW:CURRent?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:TERRor:CURRent?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Rms_/Low_/Extreme.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Perror/Dmrs/Low/Extreme.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,39 +1,40 @@
 from typing import List
 
-from ........Internal.Core import Core
-from ........Internal.CommandsGroup import CommandsGroup
-from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ........Internal.Types import DataType
+from .........Internal.Core import Core
+from .........Internal.CommandsGroup import CommandsGroup
+from .........Internal import Conversions
+from .........Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .........Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Extreme:
-	"""Extreme commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class ExtremeCls:
+	"""Extreme commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("extreme", core, parent)
+		self._cmd_group = CommandsGroup("extreme", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:RMS:LOW:EXTReme \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.merror.rms.low.extreme.fetch() \n
-		Return magnitude error RMS values for low and high EVM window position, for all measured list mode segments. The values
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:DMRS:LOW:EXTReme \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.listPy.modulation.perror.dmrs.low.extreme.fetch() \n
+		Return phase error DMRS values for low and high EVM window position, for all measured list mode segments. The values
 		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
 		result listed below. \n
 		Suppressed linked return values: reliability \n
-			:return: mag_error_rms_low: Comma-separated list of values, one per measured segment"""
+			:return: ph_error_dmrs_low: Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:RMS:LOW:EXTReme?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:DMRS:LOW:EXTReme?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:RMS:LOW:EXTReme \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.merror.rms.low.extreme.calculate() \n
-		Return magnitude error RMS values for low and high EVM window position, for all measured list mode segments. The values
+	def calculate(self) -> List[float or bool]:
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:DMRS:LOW:EXTReme \n
+		Snippet: value: List[float or bool] = driver.lteMeas.multiEval.listPy.modulation.perror.dmrs.low.extreme.calculate() \n
+		Return phase error DMRS values for low and high EVM window position, for all measured list mode segments. The values
 		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
 		result listed below. \n
 		Suppressed linked return values: reliability \n
-			:return: mag_error_rms_low: Comma-separated list of values, one per measured segment"""
+			:return: ph_error_dmrs_low: (float or boolean items) Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:RMS:LOW:EXTReme?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:DMRS:LOW:EXTReme?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Merror_/Rms_/Low_/StandardDev.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Perror/Rms/High/StandardDev.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,27 +1,27 @@
 from typing import List
 
-from ........Internal.Core import Core
-from ........Internal.CommandsGroup import CommandsGroup
-from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ........Internal.Types import DataType
+from .........Internal.Core import Core
+from .........Internal.CommandsGroup import CommandsGroup
+from .........Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .........Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class StandardDev:
-	"""StandardDev commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class StandardDevCls:
+	"""StandardDev commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("standardDev", core, parent)
+		self._cmd_group = CommandsGroup("standardDev", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:RMS:LOW:SDEViation \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.merror.rms.low.standardDev.fetch() \n
-		Return magnitude error RMS values for low and high EVM window position, for all measured list mode segments. The values
-		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
-		result listed below. \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:RMS:HIGH:SDEViation \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.listPy.modulation.perror.rms.high.standardDev.fetch() \n
+		Return phase error RMS values for low and high EVM window position, for all measured list mode segments.
+		The values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one
+		value for each result listed below. \n
 		Suppressed linked return values: reliability \n
-			:return: mag_error_rms_low: Comma-separated list of values, one per measured segment"""
+			:return: ph_error_rms_high: Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:RMS:LOW:SDEViation?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:RMS:HIGH:SDEViation?', suppressed)
 		return response
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Evm/Dmrs/__init__.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,43 +1,35 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
+from ........Internal.Core import Core
+from ........Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Perror:
-	"""Perror commands group definition. 42 total commands, 3 Sub-groups, 0 group commands"""
+class DmrsCls:
+	"""Dmrs commands group definition. 14 total commands, 2 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("perror", core, parent)
+		self._cmd_group = CommandsGroup("dmrs", core, parent)
 
 	@property
-	def rms(self):
-		"""rms commands group. 2 Sub-classes, 0 commands."""
-		if not hasattr(self, '_rms'):
-			from .Perror_.Rms import Rms
-			self._rms = Rms(self._core, self._base)
-		return self._rms
+	def low(self):
+		"""low commands group. 4 Sub-classes, 0 commands."""
+		if not hasattr(self, '_low'):
+			from .Low import LowCls
+			self._low = LowCls(self._core, self._cmd_group)
+		return self._low
 
 	@property
-	def peak(self):
-		"""peak commands group. 2 Sub-classes, 0 commands."""
-		if not hasattr(self, '_peak'):
-			from .Perror_.Peak import Peak
-			self._peak = Peak(self._core, self._base)
-		return self._peak
+	def high(self):
+		"""high commands group. 4 Sub-classes, 0 commands."""
+		if not hasattr(self, '_high'):
+			from .High import HighCls
+			self._high = HighCls(self._core, self._cmd_group)
+		return self._high
 
-	@property
-	def dmrs(self):
-		"""dmrs commands group. 2 Sub-classes, 0 commands."""
-		if not hasattr(self, '_dmrs'):
-			from .Perror_.Dmrs import Dmrs
-			self._dmrs = Dmrs(self._core, self._base)
-		return self._dmrs
-
-	def clone(self) -> 'Perror':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'DmrsCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Perror(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = DmrsCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Dmrs.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/Srs/Limit/__init__.py`

 * *Files 21% similar despite different names*

```diff
@@ -1,35 +1,27 @@
 from ......Internal.Core import Core
 from ......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Dmrs:
-	"""Dmrs commands group definition. 14 total commands, 2 Sub-groups, 0 group commands"""
+class LimitCls:
+	"""Limit commands group definition. 1 total commands, 1 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("dmrs", core, parent)
+		self._cmd_group = CommandsGroup("limit", core, parent)
 
 	@property
-	def low(self):
-		"""low commands group. 4 Sub-classes, 0 commands."""
-		if not hasattr(self, '_low'):
-			from .Dmrs_.Low import Low
-			self._low = Low(self._core, self._base)
-		return self._low
+	def pdynamics(self):
+		"""pdynamics commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_pdynamics'):
+			from .Pdynamics import PdynamicsCls
+			self._pdynamics = PdynamicsCls(self._core, self._cmd_group)
+		return self._pdynamics
 
-	@property
-	def high(self):
-		"""high commands group. 4 Sub-classes, 0 commands."""
-		if not hasattr(self, '_high'):
-			from .Dmrs_.High import High
-			self._high = High(self._core, self._base)
-		return self._high
-
-	def clone(self) -> 'Dmrs':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'LimitCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Dmrs(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = LimitCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Dmrs_/High.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Evm/Dmrs/High/__init__.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,51 +1,51 @@
-from .......Internal.Core import Core
-from .......Internal.CommandsGroup import CommandsGroup
+from .........Internal.Core import Core
+from .........Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class High:
-	"""High commands group definition. 7 total commands, 4 Sub-groups, 0 group commands"""
+class HighCls:
+	"""High commands group definition. 7 total commands, 4 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("high", core, parent)
+		self._cmd_group = CommandsGroup("high", core, parent)
 
 	@property
 	def current(self):
 		"""current commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_current'):
-			from .High_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
 	@property
 	def average(self):
 		"""average commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_average'):
-			from .High_.Average import Average
-			self._average = Average(self._core, self._base)
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
 		return self._average
 
 	@property
 	def extreme(self):
 		"""extreme commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_extreme'):
-			from .High_.Extreme import Extreme
-			self._extreme = Extreme(self._core, self._base)
+			from .Extreme import ExtremeCls
+			self._extreme = ExtremeCls(self._core, self._cmd_group)
 		return self._extreme
 
 	@property
 	def standardDev(self):
 		"""standardDev commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_standardDev'):
-			from .High_.StandardDev import StandardDev
-			self._standardDev = StandardDev(self._core, self._base)
+			from .StandardDev import StandardDevCls
+			self._standardDev = StandardDevCls(self._core, self._cmd_group)
 		return self._standardDev
 
-	def clone(self) -> 'High':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'HighCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = High(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = HighCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Dmrs_/High_/Average.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Perror/Dmrs/Low/Average.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,39 +1,40 @@
 from typing import List
 
-from ........Internal.Core import Core
-from ........Internal.CommandsGroup import CommandsGroup
-from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ........Internal.Types import DataType
+from .........Internal.Core import Core
+from .........Internal.CommandsGroup import CommandsGroup
+from .........Internal import Conversions
+from .........Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .........Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class AverageCls:
+	"""Average commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:DMRS:HIGH:AVERage \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.perror.dmrs.high.average.fetch() \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:DMRS:LOW:AVERage \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.listPy.modulation.perror.dmrs.low.average.fetch() \n
 		Return phase error DMRS values for low and high EVM window position, for all measured list mode segments. The values
 		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
 		result listed below. \n
 		Suppressed linked return values: reliability \n
-			:return: ph_error_dmrs_high: Comma-separated list of values, one per measured segment"""
+			:return: ph_error_dmrs_low: Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:DMRS:HIGH:AVERage?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:DMRS:LOW:AVERage?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:DMRS:HIGH:AVERage \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.perror.dmrs.high.average.calculate() \n
+	def calculate(self) -> List[float or bool]:
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:DMRS:LOW:AVERage \n
+		Snippet: value: List[float or bool] = driver.lteMeas.multiEval.listPy.modulation.perror.dmrs.low.average.calculate() \n
 		Return phase error DMRS values for low and high EVM window position, for all measured list mode segments. The values
 		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
 		result listed below. \n
 		Suppressed linked return values: reliability \n
-			:return: ph_error_dmrs_high: Comma-separated list of values, one per measured segment"""
+			:return: ph_error_dmrs_low: (float or boolean items) Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:DMRS:HIGH:AVERage?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:DMRS:LOW:AVERage?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Dmrs_/High_/Current.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Perror/Dmrs/High/Current.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,39 +1,40 @@
 from typing import List
 
-from ........Internal.Core import Core
-from ........Internal.CommandsGroup import CommandsGroup
-from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ........Internal.Types import DataType
+from .........Internal.Core import Core
+from .........Internal.CommandsGroup import CommandsGroup
+from .........Internal import Conversions
+from .........Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .........Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	def fetch(self) -> List[float]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:DMRS:HIGH:CURRent \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.perror.dmrs.high.current.fetch() \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.listPy.modulation.perror.dmrs.high.current.fetch() \n
 		Return phase error DMRS values for low and high EVM window position, for all measured list mode segments. The values
 		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
 		result listed below. \n
 		Suppressed linked return values: reliability \n
 			:return: ph_error_dmrs_high: Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:DMRS:HIGH:CURRent?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
+	def calculate(self) -> List[float or bool]:
 		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:DMRS:HIGH:CURRent \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.perror.dmrs.high.current.calculate() \n
+		Snippet: value: List[float or bool] = driver.lteMeas.multiEval.listPy.modulation.perror.dmrs.high.current.calculate() \n
 		Return phase error DMRS values for low and high EVM window position, for all measured list mode segments. The values
 		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
 		result listed below. \n
 		Suppressed linked return values: reliability \n
-			:return: ph_error_dmrs_high: Comma-separated list of values, one per measured segment"""
+			:return: ph_error_dmrs_high: (float or boolean items) Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:DMRS:HIGH:CURRent?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:DMRS:HIGH:CURRent?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Dmrs_/High_/Extreme.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Perror/Dmrs/High/Extreme.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,39 +1,40 @@
 from typing import List
 
-from ........Internal.Core import Core
-from ........Internal.CommandsGroup import CommandsGroup
-from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ........Internal.Types import DataType
+from .........Internal.Core import Core
+from .........Internal.CommandsGroup import CommandsGroup
+from .........Internal import Conversions
+from .........Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .........Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Extreme:
-	"""Extreme commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class ExtremeCls:
+	"""Extreme commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("extreme", core, parent)
+		self._cmd_group = CommandsGroup("extreme", core, parent)
 
 	def fetch(self) -> List[float]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:DMRS:HIGH:EXTReme \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.perror.dmrs.high.extreme.fetch() \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.listPy.modulation.perror.dmrs.high.extreme.fetch() \n
 		Return phase error DMRS values for low and high EVM window position, for all measured list mode segments. The values
 		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
 		result listed below. \n
 		Suppressed linked return values: reliability \n
 			:return: ph_error_dmrs_high: Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:DMRS:HIGH:EXTReme?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
+	def calculate(self) -> List[float or bool]:
 		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:DMRS:HIGH:EXTReme \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.perror.dmrs.high.extreme.calculate() \n
+		Snippet: value: List[float or bool] = driver.lteMeas.multiEval.listPy.modulation.perror.dmrs.high.extreme.calculate() \n
 		Return phase error DMRS values for low and high EVM window position, for all measured list mode segments. The values
 		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
 		result listed below. \n
 		Suppressed linked return values: reliability \n
-			:return: ph_error_dmrs_high: Comma-separated list of values, one per measured segment"""
+			:return: ph_error_dmrs_high: (float or boolean items) Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:DMRS:HIGH:EXTReme?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:DMRS:HIGH:EXTReme?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Dmrs_/High_/StandardDev.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Perror/Dmrs/High/StandardDev.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,26 +1,26 @@
 from typing import List
 
-from ........Internal.Core import Core
-from ........Internal.CommandsGroup import CommandsGroup
-from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ........Internal.Types import DataType
+from .........Internal.Core import Core
+from .........Internal.CommandsGroup import CommandsGroup
+from .........Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .........Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class StandardDev:
-	"""StandardDev commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class StandardDevCls:
+	"""StandardDev commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("standardDev", core, parent)
+		self._cmd_group = CommandsGroup("standardDev", core, parent)
 
 	def fetch(self) -> List[float]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:DMRS:HIGH:SDEViation \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.perror.dmrs.high.standardDev.fetch() \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.listPy.modulation.perror.dmrs.high.standardDev.fetch() \n
 		Return phase error DMRS values for low and high EVM window position, for all measured list mode segments. The values
 		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
 		result listed below. \n
 		Suppressed linked return values: reliability \n
 			:return: ph_error_dmrs_high: Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:DMRS:HIGH:SDEViation?', suppressed)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Dmrs_/Low.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Sense/LteMeas/MultiEval/__init__.py`

 * *Files 21% similar despite different names*

```diff
@@ -1,51 +1,35 @@
-from .......Internal.Core import Core
-from .......Internal.CommandsGroup import CommandsGroup
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Low:
-	"""Low commands group definition. 7 total commands, 4 Sub-groups, 0 group commands"""
+class MultiEvalCls:
+	"""MultiEval commands group definition. 5 total commands, 2 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("low", core, parent)
+		self._cmd_group = CommandsGroup("multiEval", core, parent)
 
 	@property
-	def current(self):
-		"""current commands group. 0 Sub-classes, 2 commands."""
-		if not hasattr(self, '_current'):
-			from .Low_.Current import Current
-			self._current = Current(self._core, self._base)
-		return self._current
+	def spectrum(self):
+		"""spectrum commands group. 1 Sub-classes, 0 commands."""
+		if not hasattr(self, '_spectrum'):
+			from .Spectrum import SpectrumCls
+			self._spectrum = SpectrumCls(self._core, self._cmd_group)
+		return self._spectrum
 
 	@property
-	def average(self):
-		"""average commands group. 0 Sub-classes, 2 commands."""
-		if not hasattr(self, '_average'):
-			from .Low_.Average import Average
-			self._average = Average(self._core, self._base)
-		return self._average
+	def limit(self):
+		"""limit commands group. 1 Sub-classes, 0 commands."""
+		if not hasattr(self, '_limit'):
+			from .Limit import LimitCls
+			self._limit = LimitCls(self._core, self._cmd_group)
+		return self._limit
 
-	@property
-	def extreme(self):
-		"""extreme commands group. 0 Sub-classes, 2 commands."""
-		if not hasattr(self, '_extreme'):
-			from .Low_.Extreme import Extreme
-			self._extreme = Extreme(self._core, self._base)
-		return self._extreme
-
-	@property
-	def standardDev(self):
-		"""standardDev commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_standardDev'):
-			from .Low_.StandardDev import StandardDev
-			self._standardDev = StandardDev(self._core, self._base)
-		return self._standardDev
-
-	def clone(self) -> 'Low':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'MultiEvalCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Low(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = MultiEvalCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Dmrs_/Low_/Average.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Perror/Peak/Low/Average.py`

 * *Files 21% similar despite different names*

```diff
@@ -1,39 +1,40 @@
 from typing import List
 
-from ........Internal.Core import Core
-from ........Internal.CommandsGroup import CommandsGroup
-from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ........Internal.Types import DataType
+from .........Internal.Core import Core
+from .........Internal.CommandsGroup import CommandsGroup
+from .........Internal import Conversions
+from .........Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .........Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class AverageCls:
+	"""Average commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:DMRS:LOW:AVERage \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.perror.dmrs.low.average.fetch() \n
-		Return phase error DMRS values for low and high EVM window position, for all measured list mode segments. The values
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:PEAK:LOW:AVERage \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.listPy.modulation.perror.peak.low.average.fetch() \n
+		Return phase error peak values for low and high EVM window position, for all measured list mode segments. The values
 		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
 		result listed below. \n
 		Suppressed linked return values: reliability \n
-			:return: ph_error_dmrs_low: Comma-separated list of values, one per measured segment"""
+			:return: ph_error_peak_low: Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:DMRS:LOW:AVERage?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:PEAK:LOW:AVERage?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:DMRS:LOW:AVERage \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.perror.dmrs.low.average.calculate() \n
-		Return phase error DMRS values for low and high EVM window position, for all measured list mode segments. The values
+	def calculate(self) -> List[float or bool]:
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:PEAK:LOW:AVERage \n
+		Snippet: value: List[float or bool] = driver.lteMeas.multiEval.listPy.modulation.perror.peak.low.average.calculate() \n
+		Return phase error peak values for low and high EVM window position, for all measured list mode segments. The values
 		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
 		result listed below. \n
 		Suppressed linked return values: reliability \n
-			:return: ph_error_dmrs_low: Comma-separated list of values, one per measured segment"""
+			:return: ph_error_peak_low: (float or boolean items) Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:DMRS:LOW:AVERage?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:PEAK:LOW:AVERage?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Dmrs_/Low_/Current.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Perror/Dmrs/Low/Current.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,39 +1,40 @@
 from typing import List
 
-from ........Internal.Core import Core
-from ........Internal.CommandsGroup import CommandsGroup
-from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ........Internal.Types import DataType
+from .........Internal.Core import Core
+from .........Internal.CommandsGroup import CommandsGroup
+from .........Internal import Conversions
+from .........Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .........Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	def fetch(self) -> List[float]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:DMRS:LOW:CURRent \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.perror.dmrs.low.current.fetch() \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.listPy.modulation.perror.dmrs.low.current.fetch() \n
 		Return phase error DMRS values for low and high EVM window position, for all measured list mode segments. The values
 		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
 		result listed below. \n
 		Suppressed linked return values: reliability \n
 			:return: ph_error_dmrs_low: Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:DMRS:LOW:CURRent?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
+	def calculate(self) -> List[float or bool]:
 		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:DMRS:LOW:CURRent \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.perror.dmrs.low.current.calculate() \n
+		Snippet: value: List[float or bool] = driver.lteMeas.multiEval.listPy.modulation.perror.dmrs.low.current.calculate() \n
 		Return phase error DMRS values for low and high EVM window position, for all measured list mode segments. The values
 		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
 		result listed below. \n
 		Suppressed linked return values: reliability \n
-			:return: ph_error_dmrs_low: Comma-separated list of values, one per measured segment"""
+			:return: ph_error_dmrs_low: (float or boolean items) Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:DMRS:LOW:CURRent?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:DMRS:LOW:CURRent?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Dmrs_/Low_/Extreme.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Perror/Dmrs/High/Average.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,39 +1,40 @@
 from typing import List
 
-from ........Internal.Core import Core
-from ........Internal.CommandsGroup import CommandsGroup
-from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ........Internal.Types import DataType
+from .........Internal.Core import Core
+from .........Internal.CommandsGroup import CommandsGroup
+from .........Internal import Conversions
+from .........Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .........Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Extreme:
-	"""Extreme commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class AverageCls:
+	"""Average commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("extreme", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:DMRS:LOW:EXTReme \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.perror.dmrs.low.extreme.fetch() \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:DMRS:HIGH:AVERage \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.listPy.modulation.perror.dmrs.high.average.fetch() \n
 		Return phase error DMRS values for low and high EVM window position, for all measured list mode segments. The values
 		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
 		result listed below. \n
 		Suppressed linked return values: reliability \n
-			:return: ph_error_dmrs_low: Comma-separated list of values, one per measured segment"""
+			:return: ph_error_dmrs_high: Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:DMRS:LOW:EXTReme?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:DMRS:HIGH:AVERage?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:DMRS:LOW:EXTReme \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.perror.dmrs.low.extreme.calculate() \n
+	def calculate(self) -> List[float or bool]:
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:DMRS:HIGH:AVERage \n
+		Snippet: value: List[float or bool] = driver.lteMeas.multiEval.listPy.modulation.perror.dmrs.high.average.calculate() \n
 		Return phase error DMRS values for low and high EVM window position, for all measured list mode segments. The values
 		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
 		result listed below. \n
 		Suppressed linked return values: reliability \n
-			:return: ph_error_dmrs_low: Comma-separated list of values, one per measured segment"""
+			:return: ph_error_dmrs_high: (float or boolean items) Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:DMRS:LOW:EXTReme?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:DMRS:HIGH:AVERage?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Dmrs_/Low_/StandardDev.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Perror/Peak/Low/StandardDev.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,27 +1,27 @@
 from typing import List
 
-from ........Internal.Core import Core
-from ........Internal.CommandsGroup import CommandsGroup
-from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ........Internal.Types import DataType
+from .........Internal.Core import Core
+from .........Internal.CommandsGroup import CommandsGroup
+from .........Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .........Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class StandardDev:
-	"""StandardDev commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class StandardDevCls:
+	"""StandardDev commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("standardDev", core, parent)
+		self._cmd_group = CommandsGroup("standardDev", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:DMRS:LOW:SDEViation \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.perror.dmrs.low.standardDev.fetch() \n
-		Return phase error DMRS values for low and high EVM window position, for all measured list mode segments. The values
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:PEAK:LOW:SDEViation \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.listPy.modulation.perror.peak.low.standardDev.fetch() \n
+		Return phase error peak values for low and high EVM window position, for all measured list mode segments. The values
 		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
 		result listed below. \n
 		Suppressed linked return values: reliability \n
-			:return: ph_error_dmrs_low: Comma-separated list of values, one per measured segment"""
+			:return: ph_error_peak_low: Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:DMRS:LOW:SDEViation?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:PEAK:LOW:SDEViation?', suppressed)
 		return response
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Peak.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Bler/__init__.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,35 +1,27 @@
 from ......Internal.Core import Core
 from ......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Peak:
-	"""Peak commands group definition. 14 total commands, 2 Sub-groups, 0 group commands"""
+class BlerCls:
+	"""Bler commands group definition. 1 total commands, 1 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("peak", core, parent)
+		self._cmd_group = CommandsGroup("bler", core, parent)
 
 	@property
-	def low(self):
-		"""low commands group. 4 Sub-classes, 0 commands."""
-		if not hasattr(self, '_low'):
-			from .Peak_.Low import Low
-			self._low = Low(self._core, self._base)
-		return self._low
+	def sframes(self):
+		"""sframes commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_sframes'):
+			from .Sframes import SframesCls
+			self._sframes = SframesCls(self._core, self._cmd_group)
+		return self._sframes
 
-	@property
-	def high(self):
-		"""high commands group. 4 Sub-classes, 0 commands."""
-		if not hasattr(self, '_high'):
-			from .Peak_.High import High
-			self._high = High(self._core, self._base)
-		return self._high
-
-	def clone(self) -> 'Peak':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'BlerCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Peak(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = BlerCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Peak_/High.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Evm/Peak/High/__init__.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,51 +1,51 @@
-from .......Internal.Core import Core
-from .......Internal.CommandsGroup import CommandsGroup
+from .........Internal.Core import Core
+from .........Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class High:
-	"""High commands group definition. 7 total commands, 4 Sub-groups, 0 group commands"""
+class HighCls:
+	"""High commands group definition. 7 total commands, 4 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("high", core, parent)
+		self._cmd_group = CommandsGroup("high", core, parent)
 
 	@property
 	def current(self):
 		"""current commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_current'):
-			from .High_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
 	@property
 	def average(self):
 		"""average commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_average'):
-			from .High_.Average import Average
-			self._average = Average(self._core, self._base)
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
 		return self._average
 
 	@property
 	def extreme(self):
 		"""extreme commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_extreme'):
-			from .High_.Extreme import Extreme
-			self._extreme = Extreme(self._core, self._base)
+			from .Extreme import ExtremeCls
+			self._extreme = ExtremeCls(self._core, self._cmd_group)
 		return self._extreme
 
 	@property
 	def standardDev(self):
 		"""standardDev commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_standardDev'):
-			from .High_.StandardDev import StandardDev
-			self._standardDev = StandardDev(self._core, self._base)
+			from .StandardDev import StandardDevCls
+			self._standardDev = StandardDevCls(self._core, self._cmd_group)
 		return self._standardDev
 
-	def clone(self) -> 'High':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'HighCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = High(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = HighCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Peak_/High_/Average.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/FreqError/Average.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,39 +1,38 @@
 from typing import List
 
-from ........Internal.Core import Core
-from ........Internal.CommandsGroup import CommandsGroup
-from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ........Internal.Types import DataType
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal import Conversions
+from .......Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .......Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class AverageCls:
+	"""Average commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:PEAK:HIGH:AVERage \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.perror.peak.high.average.fetch() \n
-		Return phase error peak values for low and high EVM window position, for all measured list mode segments. The values
-		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
-		result listed below. \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:FERRor:AVERage \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.listPy.modulation.freqError.average.fetch() \n
+		Return carrier frequency error values for all measured list mode segments. The values described below are returned by
+		FETCh commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 		Suppressed linked return values: reliability \n
-			:return: ph_error_peak_high: Comma-separated list of values, one per measured segment"""
+			:return: frequency_error: Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:PEAK:HIGH:AVERage?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:FERRor:AVERage?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:PEAK:HIGH:AVERage \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.perror.peak.high.average.calculate() \n
-		Return phase error peak values for low and high EVM window position, for all measured list mode segments. The values
-		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
-		result listed below. \n
+	def calculate(self) -> List[float or bool]:
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:FERRor:AVERage \n
+		Snippet: value: List[float or bool] = driver.lteMeas.multiEval.listPy.modulation.freqError.average.calculate() \n
+		Return carrier frequency error values for all measured list mode segments. The values described below are returned by
+		FETCh commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 		Suppressed linked return values: reliability \n
-			:return: ph_error_peak_high: Comma-separated list of values, one per measured segment"""
+			:return: frequency_error: (float or boolean items) Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:PEAK:HIGH:AVERage?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:FERRor:AVERage?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Peak_/High_/Current.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Merror/Peak/High/Current.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,39 +1,40 @@
 from typing import List
 
-from ........Internal.Core import Core
-from ........Internal.CommandsGroup import CommandsGroup
-from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ........Internal.Types import DataType
+from .........Internal.Core import Core
+from .........Internal.CommandsGroup import CommandsGroup
+from .........Internal import Conversions
+from .........Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .........Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:PEAK:HIGH:CURRent \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.perror.peak.high.current.fetch() \n
-		Return phase error peak values for low and high EVM window position, for all measured list mode segments. The values
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:PEAK:HIGH:CURRent \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.listPy.modulation.merror.peak.high.current.fetch() \n
+		Return magnitude error peak values for low and high EVM window position, for all measured list mode segments. The values
 		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
 		result listed below. \n
 		Suppressed linked return values: reliability \n
-			:return: ph_error_peak_high: Comma-separated list of values, one per measured segment"""
+			:return: mag_err_peak_high: Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:PEAK:HIGH:CURRent?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:PEAK:HIGH:CURRent?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:PEAK:HIGH:CURRent \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.perror.peak.high.current.calculate() \n
-		Return phase error peak values for low and high EVM window position, for all measured list mode segments. The values
+	def calculate(self) -> List[float or bool]:
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:PEAK:HIGH:CURRent \n
+		Snippet: value: List[float or bool] = driver.lteMeas.multiEval.listPy.modulation.merror.peak.high.current.calculate() \n
+		Return magnitude error peak values for low and high EVM window position, for all measured list mode segments. The values
 		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
 		result listed below. \n
 		Suppressed linked return values: reliability \n
-			:return: ph_error_peak_high: Comma-separated list of values, one per measured segment"""
+			:return: mag_err_peak_high: (float or boolean items) Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:PEAK:HIGH:CURRent?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:PEAK:HIGH:CURRent?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Peak_/High_/Extreme.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Perror/Peak/Low/Current.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,39 +1,40 @@
 from typing import List
 
-from ........Internal.Core import Core
-from ........Internal.CommandsGroup import CommandsGroup
-from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ........Internal.Types import DataType
+from .........Internal.Core import Core
+from .........Internal.CommandsGroup import CommandsGroup
+from .........Internal import Conversions
+from .........Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .........Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Extreme:
-	"""Extreme commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("extreme", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:PEAK:HIGH:EXTReme \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.perror.peak.high.extreme.fetch() \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:PEAK:LOW:CURRent \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.listPy.modulation.perror.peak.low.current.fetch() \n
 		Return phase error peak values for low and high EVM window position, for all measured list mode segments. The values
 		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
 		result listed below. \n
 		Suppressed linked return values: reliability \n
-			:return: ph_error_peak_high: Comma-separated list of values, one per measured segment"""
+			:return: ph_error_peak_low: Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:PEAK:HIGH:EXTReme?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:PEAK:LOW:CURRent?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:PEAK:HIGH:EXTReme \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.perror.peak.high.extreme.calculate() \n
+	def calculate(self) -> List[float or bool]:
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:PEAK:LOW:CURRent \n
+		Snippet: value: List[float or bool] = driver.lteMeas.multiEval.listPy.modulation.perror.peak.low.current.calculate() \n
 		Return phase error peak values for low and high EVM window position, for all measured list mode segments. The values
 		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
 		result listed below. \n
 		Suppressed linked return values: reliability \n
-			:return: ph_error_peak_high: Comma-separated list of values, one per measured segment"""
+			:return: ph_error_peak_low: (float or boolean items) Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:PEAK:HIGH:EXTReme?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:PEAK:LOW:CURRent?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Peak_/High_/StandardDev.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Merror/Dmrs/High/StandardDev.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,27 +1,27 @@
 from typing import List
 
-from ........Internal.Core import Core
-from ........Internal.CommandsGroup import CommandsGroup
-from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ........Internal.Types import DataType
+from .........Internal.Core import Core
+from .........Internal.CommandsGroup import CommandsGroup
+from .........Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .........Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class StandardDev:
-	"""StandardDev commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class StandardDevCls:
+	"""StandardDev commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("standardDev", core, parent)
+		self._cmd_group = CommandsGroup("standardDev", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:PEAK:HIGH:SDEViation \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.perror.peak.high.standardDev.fetch() \n
-		Return phase error peak values for low and high EVM window position, for all measured list mode segments. The values
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:DMRS:HIGH:SDEViation \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.listPy.modulation.merror.dmrs.high.standardDev.fetch() \n
+		Return magnitude error DMRS values for low and high EVM window position, for all measured list mode segments. The values
 		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
 		result listed below. \n
 		Suppressed linked return values: reliability \n
-			:return: ph_error_peak_high: Comma-separated list of values, one per measured segment"""
+			:return: mag_err_dmrs_high: Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:PEAK:HIGH:SDEViation?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:DMRS:HIGH:SDEViation?', suppressed)
 		return response
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Peak_/Low.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Evm/Dmrs/Low/__init__.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,51 +1,51 @@
-from .......Internal.Core import Core
-from .......Internal.CommandsGroup import CommandsGroup
+from .........Internal.Core import Core
+from .........Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Low:
-	"""Low commands group definition. 7 total commands, 4 Sub-groups, 0 group commands"""
+class LowCls:
+	"""Low commands group definition. 7 total commands, 4 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("low", core, parent)
+		self._cmd_group = CommandsGroup("low", core, parent)
 
 	@property
 	def current(self):
 		"""current commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_current'):
-			from .Low_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
 	@property
 	def average(self):
 		"""average commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_average'):
-			from .Low_.Average import Average
-			self._average = Average(self._core, self._base)
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
 		return self._average
 
 	@property
 	def extreme(self):
 		"""extreme commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_extreme'):
-			from .Low_.Extreme import Extreme
-			self._extreme = Extreme(self._core, self._base)
+			from .Extreme import ExtremeCls
+			self._extreme = ExtremeCls(self._core, self._cmd_group)
 		return self._extreme
 
 	@property
 	def standardDev(self):
 		"""standardDev commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_standardDev'):
-			from .Low_.StandardDev import StandardDev
-			self._standardDev = StandardDev(self._core, self._base)
+			from .StandardDev import StandardDevCls
+			self._standardDev = StandardDevCls(self._core, self._cmd_group)
 		return self._standardDev
 
-	def clone(self) -> 'Low':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'LowCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Low(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = LowCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Peak_/Low_/Average.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Perror/Rms/Low/Average.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,39 +1,40 @@
 from typing import List
 
-from ........Internal.Core import Core
-from ........Internal.CommandsGroup import CommandsGroup
-from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ........Internal.Types import DataType
+from .........Internal.Core import Core
+from .........Internal.CommandsGroup import CommandsGroup
+from .........Internal import Conversions
+from .........Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .........Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class AverageCls:
+	"""Average commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:PEAK:LOW:AVERage \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.perror.peak.low.average.fetch() \n
-		Return phase error peak values for low and high EVM window position, for all measured list mode segments. The values
-		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
-		result listed below. \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:RMS:LOW:AVERage \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.listPy.modulation.perror.rms.low.average.fetch() \n
+		Return phase error RMS values for low and high EVM window position, for all measured list mode segments.
+		The values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one
+		value for each result listed below. \n
 		Suppressed linked return values: reliability \n
-			:return: ph_error_peak_low: Comma-separated list of values, one per measured segment"""
+			:return: ph_error_rms_low: Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:PEAK:LOW:AVERage?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:RMS:LOW:AVERage?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:PEAK:LOW:AVERage \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.perror.peak.low.average.calculate() \n
-		Return phase error peak values for low and high EVM window position, for all measured list mode segments. The values
-		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
-		result listed below. \n
+	def calculate(self) -> List[float or bool]:
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:RMS:LOW:AVERage \n
+		Snippet: value: List[float or bool] = driver.lteMeas.multiEval.listPy.modulation.perror.rms.low.average.calculate() \n
+		Return phase error RMS values for low and high EVM window position, for all measured list mode segments.
+		The values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one
+		value for each result listed below. \n
 		Suppressed linked return values: reliability \n
-			:return: ph_error_peak_low: Comma-separated list of values, one per measured segment"""
+			:return: ph_error_rms_low: (float or boolean items) Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:PEAK:LOW:AVERage?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:RMS:LOW:AVERage?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Peak_/Low_/Current.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Merror/Dmrs/High/Average.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,39 +1,40 @@
 from typing import List
 
-from ........Internal.Core import Core
-from ........Internal.CommandsGroup import CommandsGroup
-from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ........Internal.Types import DataType
+from .........Internal.Core import Core
+from .........Internal.CommandsGroup import CommandsGroup
+from .........Internal import Conversions
+from .........Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .........Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class AverageCls:
+	"""Average commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:PEAK:LOW:CURRent \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.perror.peak.low.current.fetch() \n
-		Return phase error peak values for low and high EVM window position, for all measured list mode segments. The values
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:DMRS:HIGH:AVERage \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.listPy.modulation.merror.dmrs.high.average.fetch() \n
+		Return magnitude error DMRS values for low and high EVM window position, for all measured list mode segments. The values
 		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
 		result listed below. \n
 		Suppressed linked return values: reliability \n
-			:return: ph_error_peak_low: Comma-separated list of values, one per measured segment"""
+			:return: mag_err_dmrs_high: Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:PEAK:LOW:CURRent?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:DMRS:HIGH:AVERage?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:PEAK:LOW:CURRent \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.perror.peak.low.current.calculate() \n
-		Return phase error peak values for low and high EVM window position, for all measured list mode segments. The values
+	def calculate(self) -> List[float or bool]:
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:DMRS:HIGH:AVERage \n
+		Snippet: value: List[float or bool] = driver.lteMeas.multiEval.listPy.modulation.merror.dmrs.high.average.calculate() \n
+		Return magnitude error DMRS values for low and high EVM window position, for all measured list mode segments. The values
 		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
 		result listed below. \n
 		Suppressed linked return values: reliability \n
-			:return: ph_error_peak_low: Comma-separated list of values, one per measured segment"""
+			:return: mag_err_dmrs_high: (float or boolean items) Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:PEAK:LOW:CURRent?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:DMRS:HIGH:AVERage?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Peak_/Low_/Extreme.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Perror/Rms/Low/Extreme.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,39 +1,40 @@
 from typing import List
 
-from ........Internal.Core import Core
-from ........Internal.CommandsGroup import CommandsGroup
-from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ........Internal.Types import DataType
+from .........Internal.Core import Core
+from .........Internal.CommandsGroup import CommandsGroup
+from .........Internal import Conversions
+from .........Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .........Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Extreme:
-	"""Extreme commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class ExtremeCls:
+	"""Extreme commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("extreme", core, parent)
+		self._cmd_group = CommandsGroup("extreme", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:PEAK:LOW:EXTReme \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.perror.peak.low.extreme.fetch() \n
-		Return phase error peak values for low and high EVM window position, for all measured list mode segments. The values
-		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
-		result listed below. \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:RMS:LOW:EXTReme \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.listPy.modulation.perror.rms.low.extreme.fetch() \n
+		Return phase error RMS values for low and high EVM window position, for all measured list mode segments.
+		The values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one
+		value for each result listed below. \n
 		Suppressed linked return values: reliability \n
-			:return: ph_error_peak_low: Comma-separated list of values, one per measured segment"""
+			:return: ph_error_rms_low: Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:PEAK:LOW:EXTReme?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:RMS:LOW:EXTReme?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:PEAK:LOW:EXTReme \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.perror.peak.low.extreme.calculate() \n
-		Return phase error peak values for low and high EVM window position, for all measured list mode segments. The values
-		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
-		result listed below. \n
+	def calculate(self) -> List[float or bool]:
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:RMS:LOW:EXTReme \n
+		Snippet: value: List[float or bool] = driver.lteMeas.multiEval.listPy.modulation.perror.rms.low.extreme.calculate() \n
+		Return phase error RMS values for low and high EVM window position, for all measured list mode segments.
+		The values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one
+		value for each result listed below. \n
 		Suppressed linked return values: reliability \n
-			:return: ph_error_peak_low: Comma-separated list of values, one per measured segment"""
+			:return: ph_error_rms_low: (float or boolean items) Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:PEAK:LOW:EXTReme?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:RMS:LOW:EXTReme?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Peak_/Low_/StandardDev.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Tpower/StandardDev.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,27 +1,26 @@
 from typing import List
 
-from ........Internal.Core import Core
-from ........Internal.CommandsGroup import CommandsGroup
-from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ........Internal.Types import DataType
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .......Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class StandardDev:
-	"""StandardDev commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class StandardDevCls:
+	"""StandardDev commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("standardDev", core, parent)
+		self._cmd_group = CommandsGroup("standardDev", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:PEAK:LOW:SDEViation \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.perror.peak.low.standardDev.fetch() \n
-		Return phase error peak values for low and high EVM window position, for all measured list mode segments. The values
-		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
-		result listed below. \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:TPOWer:SDEViation \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.listPy.modulation.tpower.standardDev.fetch() \n
+		Return user equipment power values for all measured list mode segments. The values described below are returned by FETCh
+		commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 		Suppressed linked return values: reliability \n
-			:return: ph_error_peak_low: Comma-separated list of values, one per measured segment"""
+			:return: tx_power: Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:PEAK:LOW:SDEViation?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:TPOWer:SDEViation?', suppressed)
 		return response
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Rms.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/SeMask/Margin/Minimum/__init__.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,35 +1,35 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
+from .........Internal.Core import Core
+from .........Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Rms:
-	"""Rms commands group definition. 14 total commands, 2 Sub-groups, 0 group commands"""
+class MinimumCls:
+	"""Minimum commands group definition. 2 total commands, 2 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("rms", core, parent)
+		self._cmd_group = CommandsGroup("minimum", core, parent)
 
 	@property
-	def low(self):
-		"""low commands group. 4 Sub-classes, 0 commands."""
-		if not hasattr(self, '_low'):
-			from .Rms_.Low import Low
-			self._low = Low(self._core, self._base)
-		return self._low
+	def negativ(self):
+		"""negativ commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_negativ'):
+			from .Negativ import NegativCls
+			self._negativ = NegativCls(self._core, self._cmd_group)
+		return self._negativ
 
 	@property
-	def high(self):
-		"""high commands group. 4 Sub-classes, 0 commands."""
-		if not hasattr(self, '_high'):
-			from .Rms_.High import High
-			self._high = High(self._core, self._base)
-		return self._high
+	def positiv(self):
+		"""positiv commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_positiv'):
+			from .Positiv import PositivCls
+			self._positiv = PositivCls(self._core, self._cmd_group)
+		return self._positiv
 
-	def clone(self) -> 'Rms':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'MinimumCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Rms(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = MinimumCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Rms_/High.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Evm/Rms/High/__init__.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,51 +1,51 @@
-from .......Internal.Core import Core
-from .......Internal.CommandsGroup import CommandsGroup
+from .........Internal.Core import Core
+from .........Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class High:
-	"""High commands group definition. 7 total commands, 4 Sub-groups, 0 group commands"""
+class HighCls:
+	"""High commands group definition. 7 total commands, 4 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("high", core, parent)
+		self._cmd_group = CommandsGroup("high", core, parent)
 
 	@property
 	def current(self):
 		"""current commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_current'):
-			from .High_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
 	@property
 	def average(self):
 		"""average commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_average'):
-			from .High_.Average import Average
-			self._average = Average(self._core, self._base)
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
 		return self._average
 
 	@property
 	def extreme(self):
 		"""extreme commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_extreme'):
-			from .High_.Extreme import Extreme
-			self._extreme = Extreme(self._core, self._base)
+			from .Extreme import ExtremeCls
+			self._extreme = ExtremeCls(self._core, self._cmd_group)
 		return self._extreme
 
 	@property
 	def standardDev(self):
 		"""standardDev commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_standardDev'):
-			from .High_.StandardDev import StandardDev
-			self._standardDev = StandardDev(self._core, self._base)
+			from .StandardDev import StandardDevCls
+			self._standardDev = StandardDevCls(self._core, self._cmd_group)
 		return self._standardDev
 
-	def clone(self) -> 'High':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'HighCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = High(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = HighCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Rms_/High_/Average.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Perror/Rms/High/Average.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,39 +1,40 @@
 from typing import List
 
-from ........Internal.Core import Core
-from ........Internal.CommandsGroup import CommandsGroup
-from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ........Internal.Types import DataType
+from .........Internal.Core import Core
+from .........Internal.CommandsGroup import CommandsGroup
+from .........Internal import Conversions
+from .........Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .........Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class AverageCls:
+	"""Average commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	def fetch(self) -> List[float]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:RMS:HIGH:AVERage \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.perror.rms.high.average.fetch() \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.listPy.modulation.perror.rms.high.average.fetch() \n
 		Return phase error RMS values for low and high EVM window position, for all measured list mode segments.
 		The values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one
 		value for each result listed below. \n
 		Suppressed linked return values: reliability \n
 			:return: ph_error_rms_high: Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:RMS:HIGH:AVERage?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
+	def calculate(self) -> List[float or bool]:
 		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:RMS:HIGH:AVERage \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.perror.rms.high.average.calculate() \n
+		Snippet: value: List[float or bool] = driver.lteMeas.multiEval.listPy.modulation.perror.rms.high.average.calculate() \n
 		Return phase error RMS values for low and high EVM window position, for all measured list mode segments.
 		The values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one
 		value for each result listed below. \n
 		Suppressed linked return values: reliability \n
-			:return: ph_error_rms_high: Comma-separated list of values, one per measured segment"""
+			:return: ph_error_rms_high: (float or boolean items) Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:RMS:HIGH:AVERage?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:RMS:HIGH:AVERage?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Rms_/High_/Current.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Merror/Dmrs/Low/StandardDev.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,39 +1,27 @@
 from typing import List
 
-from ........Internal.Core import Core
-from ........Internal.CommandsGroup import CommandsGroup
-from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ........Internal.Types import DataType
+from .........Internal.Core import Core
+from .........Internal.CommandsGroup import CommandsGroup
+from .........Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .........Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class StandardDevCls:
+	"""StandardDev commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("standardDev", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:RMS:HIGH:CURRent \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.perror.rms.high.current.fetch() \n
-		Return phase error RMS values for low and high EVM window position, for all measured list mode segments.
-		The values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one
-		value for each result listed below. \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:DMRS:LOW:SDEViation \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.listPy.modulation.merror.dmrs.low.standardDev.fetch() \n
+		Return magnitude error DMRS values for low and high EVM window position, for all measured list mode segments. The values
+		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
+		result listed below. \n
 		Suppressed linked return values: reliability \n
-			:return: ph_error_rms_high: Comma-separated list of values, one per measured segment"""
+			:return: mag_err_dmrs_low: Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:RMS:HIGH:CURRent?', suppressed)
-		return response
-
-	def calculate(self) -> List[float]:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:RMS:HIGH:CURRent \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.perror.rms.high.current.calculate() \n
-		Return phase error RMS values for low and high EVM window position, for all measured list mode segments.
-		The values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one
-		value for each result listed below. \n
-		Suppressed linked return values: reliability \n
-			:return: ph_error_rms_high: Comma-separated list of values, one per measured segment"""
-		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:RMS:HIGH:CURRent?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:DMRS:LOW:SDEViation?', suppressed)
 		return response
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Rms_/High_/Extreme.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Evm/Peak/Low/Current.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,39 +1,40 @@
 from typing import List
 
-from ........Internal.Core import Core
-from ........Internal.CommandsGroup import CommandsGroup
-from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ........Internal.Types import DataType
+from .........Internal.Core import Core
+from .........Internal.CommandsGroup import CommandsGroup
+from .........Internal import Conversions
+from .........Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .........Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Extreme:
-	"""Extreme commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("extreme", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:RMS:HIGH:EXTReme \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.perror.rms.high.extreme.fetch() \n
-		Return phase error RMS values for low and high EVM window position, for all measured list mode segments.
-		The values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one
-		value for each result listed below. \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:PEAK:LOW:CURRent \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.listPy.modulation.evm.peak.low.current.fetch() \n
+		Return error vector magnitude peak values for low and high EVM window position, for all measured list mode segments. The
+		values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value
+		for each result listed below. \n
 		Suppressed linked return values: reliability \n
-			:return: ph_error_rms_high: Comma-separated list of values, one per measured segment"""
+			:return: evm_peak_low: Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:RMS:HIGH:EXTReme?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:PEAK:LOW:CURRent?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:RMS:HIGH:EXTReme \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.perror.rms.high.extreme.calculate() \n
-		Return phase error RMS values for low and high EVM window position, for all measured list mode segments.
-		The values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one
-		value for each result listed below. \n
+	def calculate(self) -> List[float or bool]:
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:PEAK:LOW:CURRent \n
+		Snippet: value: List[float or bool] = driver.lteMeas.multiEval.listPy.modulation.evm.peak.low.current.calculate() \n
+		Return error vector magnitude peak values for low and high EVM window position, for all measured list mode segments. The
+		values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value
+		for each result listed below. \n
 		Suppressed linked return values: reliability \n
-			:return: ph_error_rms_high: Comma-separated list of values, one per measured segment"""
+			:return: evm_peak_low: (float or boolean items) Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:RMS:HIGH:EXTReme?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:PEAK:LOW:CURRent?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Rms_/High_/StandardDev.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Ppower/StandardDev.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,27 +1,26 @@
 from typing import List
 
-from ........Internal.Core import Core
-from ........Internal.CommandsGroup import CommandsGroup
-from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ........Internal.Types import DataType
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .......Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class StandardDev:
-	"""StandardDev commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class StandardDevCls:
+	"""StandardDev commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("standardDev", core, parent)
+		self._cmd_group = CommandsGroup("standardDev", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:RMS:HIGH:SDEViation \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.perror.rms.high.standardDev.fetch() \n
-		Return phase error RMS values for low and high EVM window position, for all measured list mode segments.
-		The values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one
-		value for each result listed below. \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PPOWer:SDEViation \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.listPy.modulation.ppower.standardDev.fetch() \n
+		Return user equipment peak power values for all measured list mode segments. The values described below are returned by
+		FETCh commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 		Suppressed linked return values: reliability \n
-			:return: ph_error_rms_high: Comma-separated list of values, one per measured segment"""
+			:return: peak_power: Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:RMS:HIGH:SDEViation?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PPOWer:SDEViation?', suppressed)
 		return response
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Rms_/Low.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Evm/Peak/Low/__init__.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,51 +1,51 @@
-from .......Internal.Core import Core
-from .......Internal.CommandsGroup import CommandsGroup
+from .........Internal.Core import Core
+from .........Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Low:
-	"""Low commands group definition. 7 total commands, 4 Sub-groups, 0 group commands"""
+class LowCls:
+	"""Low commands group definition. 7 total commands, 4 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("low", core, parent)
+		self._cmd_group = CommandsGroup("low", core, parent)
 
 	@property
 	def current(self):
 		"""current commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_current'):
-			from .Low_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
 	@property
 	def average(self):
 		"""average commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_average'):
-			from .Low_.Average import Average
-			self._average = Average(self._core, self._base)
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
 		return self._average
 
 	@property
 	def extreme(self):
 		"""extreme commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_extreme'):
-			from .Low_.Extreme import Extreme
-			self._extreme = Extreme(self._core, self._base)
+			from .Extreme import ExtremeCls
+			self._extreme = ExtremeCls(self._core, self._cmd_group)
 		return self._extreme
 
 	@property
 	def standardDev(self):
 		"""standardDev commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_standardDev'):
-			from .Low_.StandardDev import StandardDev
-			self._standardDev = StandardDev(self._core, self._base)
+			from .StandardDev import StandardDevCls
+			self._standardDev = StandardDevCls(self._core, self._cmd_group)
 		return self._standardDev
 
-	def clone(self) -> 'Low':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'LowCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Low(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = LowCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Rms_/Low_/Average.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Tpower/Minimum.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,39 +1,38 @@
 from typing import List
 
-from ........Internal.Core import Core
-from ........Internal.CommandsGroup import CommandsGroup
-from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ........Internal.Types import DataType
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal import Conversions
+from .......Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .......Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class MinimumCls:
+	"""Minimum commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("minimum", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:RMS:LOW:AVERage \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.perror.rms.low.average.fetch() \n
-		Return phase error RMS values for low and high EVM window position, for all measured list mode segments.
-		The values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one
-		value for each result listed below. \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:TPOWer:MINimum \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.listPy.modulation.tpower.minimum.fetch() \n
+		Return user equipment power values for all measured list mode segments. The values described below are returned by FETCh
+		commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 		Suppressed linked return values: reliability \n
-			:return: ph_error_rms_low: Comma-separated list of values, one per measured segment"""
+			:return: tx_power: Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:RMS:LOW:AVERage?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:TPOWer:MINimum?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:RMS:LOW:AVERage \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.perror.rms.low.average.calculate() \n
-		Return phase error RMS values for low and high EVM window position, for all measured list mode segments.
-		The values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one
-		value for each result listed below. \n
+	def calculate(self) -> List[float or bool]:
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:TPOWer:MINimum \n
+		Snippet: value: List[float or bool] = driver.lteMeas.multiEval.listPy.modulation.tpower.minimum.calculate() \n
+		Return user equipment power values for all measured list mode segments. The values described below are returned by FETCh
+		commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 		Suppressed linked return values: reliability \n
-			:return: ph_error_rms_low: Comma-separated list of values, one per measured segment"""
+			:return: tx_power: (float or boolean items) Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:RMS:LOW:AVERage?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:TPOWer:MINimum?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Rms_/Low_/Current.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Merror/Rms/Low/Current.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,39 +1,40 @@
 from typing import List
 
-from ........Internal.Core import Core
-from ........Internal.CommandsGroup import CommandsGroup
-from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ........Internal.Types import DataType
+from .........Internal.Core import Core
+from .........Internal.CommandsGroup import CommandsGroup
+from .........Internal import Conversions
+from .........Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .........Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:RMS:LOW:CURRent \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.perror.rms.low.current.fetch() \n
-		Return phase error RMS values for low and high EVM window position, for all measured list mode segments.
-		The values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one
-		value for each result listed below. \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:RMS:LOW:CURRent \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.listPy.modulation.merror.rms.low.current.fetch() \n
+		Return magnitude error RMS values for low and high EVM window position, for all measured list mode segments. The values
+		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
+		result listed below. \n
 		Suppressed linked return values: reliability \n
-			:return: ph_error_rms_low: Comma-separated list of values, one per measured segment"""
+			:return: mag_error_rms_low: Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:RMS:LOW:CURRent?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:RMS:LOW:CURRent?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:RMS:LOW:CURRent \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.perror.rms.low.current.calculate() \n
-		Return phase error RMS values for low and high EVM window position, for all measured list mode segments.
-		The values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one
-		value for each result listed below. \n
+	def calculate(self) -> List[float or bool]:
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:RMS:LOW:CURRent \n
+		Snippet: value: List[float or bool] = driver.lteMeas.multiEval.listPy.modulation.merror.rms.low.current.calculate() \n
+		Return magnitude error RMS values for low and high EVM window position, for all measured list mode segments. The values
+		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
+		result listed below. \n
 		Suppressed linked return values: reliability \n
-			:return: ph_error_rms_low: Comma-separated list of values, one per measured segment"""
+			:return: mag_error_rms_low: (float or boolean items) Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:RMS:LOW:CURRent?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:RMS:LOW:CURRent?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Rms_/Low_/Extreme.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Perror/Rms/High/Extreme.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,39 +1,40 @@
 from typing import List
 
-from ........Internal.Core import Core
-from ........Internal.CommandsGroup import CommandsGroup
-from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ........Internal.Types import DataType
+from .........Internal.Core import Core
+from .........Internal.CommandsGroup import CommandsGroup
+from .........Internal import Conversions
+from .........Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .........Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Extreme:
-	"""Extreme commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class ExtremeCls:
+	"""Extreme commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("extreme", core, parent)
+		self._cmd_group = CommandsGroup("extreme", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:RMS:LOW:EXTReme \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.perror.rms.low.extreme.fetch() \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:RMS:HIGH:EXTReme \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.listPy.modulation.perror.rms.high.extreme.fetch() \n
 		Return phase error RMS values for low and high EVM window position, for all measured list mode segments.
 		The values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one
 		value for each result listed below. \n
 		Suppressed linked return values: reliability \n
-			:return: ph_error_rms_low: Comma-separated list of values, one per measured segment"""
+			:return: ph_error_rms_high: Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:RMS:LOW:EXTReme?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:RMS:HIGH:EXTReme?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:RMS:LOW:EXTReme \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.perror.rms.low.extreme.calculate() \n
+	def calculate(self) -> List[float or bool]:
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:RMS:HIGH:EXTReme \n
+		Snippet: value: List[float or bool] = driver.lteMeas.multiEval.listPy.modulation.perror.rms.high.extreme.calculate() \n
 		Return phase error RMS values for low and high EVM window position, for all measured list mode segments.
 		The values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one
 		value for each result listed below. \n
 		Suppressed linked return values: reliability \n
-			:return: ph_error_rms_low: Comma-separated list of values, one per measured segment"""
+			:return: ph_error_rms_high: (float or boolean items) Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:RMS:LOW:EXTReme?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:RMS:HIGH:EXTReme?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Perror_/Rms_/Low_/StandardDev.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Evm/Dmrs/Low/StandardDev.py`

 * *Files 11% similar despite different names*

```diff
@@ -1,27 +1,27 @@
 from typing import List
 
-from ........Internal.Core import Core
-from ........Internal.CommandsGroup import CommandsGroup
-from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ........Internal.Types import DataType
+from .........Internal.Core import Core
+from .........Internal.CommandsGroup import CommandsGroup
+from .........Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .........Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class StandardDev:
-	"""StandardDev commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class StandardDevCls:
+	"""StandardDev commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("standardDev", core, parent)
+		self._cmd_group = CommandsGroup("standardDev", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:RMS:LOW:SDEViation \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.perror.rms.low.standardDev.fetch() \n
-		Return phase error RMS values for low and high EVM window position, for all measured list mode segments.
-		The values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one
-		value for each result listed below. \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:DMRS:LOW:SDEViation \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.listPy.modulation.evm.dmrs.low.standardDev.fetch() \n
+		Return error vector magnitude DMRS values for low and high EVM window position, for all measured list mode segments. The
+		values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value
+		for each result listed below. \n
 		Suppressed linked return values: reliability \n
-			:return: ph_error_rms_low: Comma-separated list of values, one per measured segment"""
+			:return: evm_dmrs_low: Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:RMS:LOW:SDEViation?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:EVM:DMRS:LOW:SDEViation?', suppressed)
 		return response
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Ppower.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Psd/__init__.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,59 +1,59 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Ppower:
-	"""Ppower commands group definition. 9 total commands, 5 Sub-groups, 0 group commands"""
+class PsdCls:
+	"""Psd commands group definition. 9 total commands, 5 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("ppower", core, parent)
+		self._cmd_group = CommandsGroup("psd", core, parent)
 
 	@property
 	def current(self):
 		"""current commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_current'):
-			from .Ppower_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
 	@property
 	def average(self):
 		"""average commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_average'):
-			from .Ppower_.Average import Average
-			self._average = Average(self._core, self._base)
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
 		return self._average
 
 	@property
 	def minimum(self):
 		"""minimum commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_minimum'):
-			from .Ppower_.Minimum import Minimum
-			self._minimum = Minimum(self._core, self._base)
+			from .Minimum import MinimumCls
+			self._minimum = MinimumCls(self._core, self._cmd_group)
 		return self._minimum
 
 	@property
 	def maximum(self):
 		"""maximum commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_maximum'):
-			from .Ppower_.Maximum import Maximum
-			self._maximum = Maximum(self._core, self._base)
+			from .Maximum import MaximumCls
+			self._maximum = MaximumCls(self._core, self._cmd_group)
 		return self._maximum
 
 	@property
 	def standardDev(self):
 		"""standardDev commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_standardDev'):
-			from .Ppower_.StandardDev import StandardDev
-			self._standardDev = StandardDev(self._core, self._base)
+			from .StandardDev import StandardDevCls
+			self._standardDev = StandardDevCls(self._core, self._cmd_group)
 		return self._standardDev
 
-	def clone(self) -> 'Ppower':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'PsdCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Ppower(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = PsdCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Ppower_/Average.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Psd/Average.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,37 +1,38 @@
 from typing import List
 
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ......Internal.Types import DataType
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal import Conversions
+from .......Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .......Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class AverageCls:
+	"""Average commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PPOWer:AVERage \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.ppower.average.fetch() \n
-		Return user equipment peak power values for all measured list mode segments. The values described below are returned by
-		FETCh commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PSD:AVERage \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.listPy.modulation.psd.average.fetch() \n
+		Return RB power values for all measured list mode segments. The values described below are returned by FETCh commands.
+		CALCulate commands return limit check results instead, one value for each result listed below. \n
 		Suppressed linked return values: reliability \n
-			:return: peak_power: Comma-separated list of values, one per measured segment"""
+			:return: psd: Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PPOWer:AVERage?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PSD:AVERage?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PPOWer:AVERage \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.ppower.average.calculate() \n
-		Return user equipment peak power values for all measured list mode segments. The values described below are returned by
-		FETCh commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
+	def calculate(self) -> List[float or bool]:
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PSD:AVERage \n
+		Snippet: value: List[float or bool] = driver.lteMeas.multiEval.listPy.modulation.psd.average.calculate() \n
+		Return RB power values for all measured list mode segments. The values described below are returned by FETCh commands.
+		CALCulate commands return limit check results instead, one value for each result listed below. \n
 		Suppressed linked return values: reliability \n
-			:return: peak_power: Comma-separated list of values, one per measured segment"""
+			:return: psd: (float or boolean items) Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PPOWer:AVERage?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PSD:AVERage?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Ppower_/Current.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Tpower/Maximum.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,37 +1,38 @@
 from typing import List
 
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ......Internal.Types import DataType
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal import Conversions
+from .......Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .......Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class MaximumCls:
+	"""Maximum commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("maximum", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PPOWer:CURRent \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.ppower.current.fetch() \n
-		Return user equipment peak power values for all measured list mode segments. The values described below are returned by
-		FETCh commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:TPOWer:MAXimum \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.listPy.modulation.tpower.maximum.fetch() \n
+		Return user equipment power values for all measured list mode segments. The values described below are returned by FETCh
+		commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 		Suppressed linked return values: reliability \n
-			:return: peak_power: Comma-separated list of values, one per measured segment"""
+			:return: tx_power: Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PPOWer:CURRent?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:TPOWer:MAXimum?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PPOWer:CURRent \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.ppower.current.calculate() \n
-		Return user equipment peak power values for all measured list mode segments. The values described below are returned by
-		FETCh commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
+	def calculate(self) -> List[float or bool]:
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:TPOWer:MAXimum \n
+		Snippet: value: List[float or bool] = driver.lteMeas.multiEval.listPy.modulation.tpower.maximum.calculate() \n
+		Return user equipment power values for all measured list mode segments. The values described below are returned by FETCh
+		commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 		Suppressed linked return values: reliability \n
-			:return: peak_power: Comma-separated list of values, one per measured segment"""
+			:return: tx_power: (float or boolean items) Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PPOWer:CURRent?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:TPOWer:MAXimum?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Ppower_/Maximum.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Ppower/Maximum.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,37 +1,38 @@
 from typing import List
 
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ......Internal.Types import DataType
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal import Conversions
+from .......Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .......Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Maximum:
-	"""Maximum commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class MaximumCls:
+	"""Maximum commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("maximum", core, parent)
+		self._cmd_group = CommandsGroup("maximum", core, parent)
 
 	def fetch(self) -> List[float]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PPOWer:MAXimum \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.ppower.maximum.fetch() \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.listPy.modulation.ppower.maximum.fetch() \n
 		Return user equipment peak power values for all measured list mode segments. The values described below are returned by
 		FETCh commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 		Suppressed linked return values: reliability \n
 			:return: peak_power: Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PPOWer:MAXimum?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
+	def calculate(self) -> List[float or bool]:
 		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PPOWer:MAXimum \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.ppower.maximum.calculate() \n
+		Snippet: value: List[float or bool] = driver.lteMeas.multiEval.listPy.modulation.ppower.maximum.calculate() \n
 		Return user equipment peak power values for all measured list mode segments. The values described below are returned by
 		FETCh commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 		Suppressed linked return values: reliability \n
-			:return: peak_power: Comma-separated list of values, one per measured segment"""
+			:return: peak_power: (float or boolean items) Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PPOWer:MAXimum?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PPOWer:MAXimum?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Ppower_/Minimum.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Ppower/Minimum.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,37 +1,38 @@
 from typing import List
 
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ......Internal.Types import DataType
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal import Conversions
+from .......Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .......Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Minimum:
-	"""Minimum commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class MinimumCls:
+	"""Minimum commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("minimum", core, parent)
+		self._cmd_group = CommandsGroup("minimum", core, parent)
 
 	def fetch(self) -> List[float]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PPOWer:MINimum \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.ppower.minimum.fetch() \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.listPy.modulation.ppower.minimum.fetch() \n
 		Return user equipment peak power values for all measured list mode segments. The values described below are returned by
 		FETCh commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 		Suppressed linked return values: reliability \n
 			:return: peak_power: Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PPOWer:MINimum?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
+	def calculate(self) -> List[float or bool]:
 		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PPOWer:MINimum \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.ppower.minimum.calculate() \n
+		Snippet: value: List[float or bool] = driver.lteMeas.multiEval.listPy.modulation.ppower.minimum.calculate() \n
 		Return user equipment peak power values for all measured list mode segments. The values described below are returned by
 		FETCh commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 		Suppressed linked return values: reliability \n
-			:return: peak_power: Comma-separated list of values, one per measured segment"""
+			:return: peak_power: (float or boolean items) Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PPOWer:MINimum?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PPOWer:MINimum?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Ppower_/StandardDev.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/SeMask/TxPower/StandardDev.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,26 +1,26 @@
 from typing import List
 
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ......Internal.Types import DataType
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .......Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class StandardDev:
-	"""StandardDev commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class StandardDevCls:
+	"""StandardDev commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("standardDev", core, parent)
+		self._cmd_group = CommandsGroup("standardDev", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PPOWer:SDEViation \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.ppower.standardDev.fetch() \n
-		Return user equipment peak power values for all measured list mode segments. The values described below are returned by
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEMask:TXPower:SDEViation \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.listPy.seMask.txPower.standardDev.fetch() \n
+		Return the total TX power in the slot for all measured list mode segments. The values described below are returned by
 		FETCh commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 		Suppressed linked return values: reliability \n
-			:return: peak_power: Comma-separated list of values, one per measured segment"""
+			:return: tx_power: Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PPOWer:SDEViation?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEMask:TXPower:SDEViation?', suppressed)
 		return response
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Psd.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Pmonitor/Pcc/__init__.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,59 +1,59 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Psd:
-	"""Psd commands group definition. 9 total commands, 5 Sub-groups, 0 group commands"""
+class PccCls:
+	"""Pcc commands group definition. 10 total commands, 5 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("psd", core, parent)
+		self._cmd_group = CommandsGroup("pcc", core, parent)
 
 	@property
 	def current(self):
 		"""current commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_current'):
-			from .Psd_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
 	@property
 	def average(self):
 		"""average commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_average'):
-			from .Psd_.Average import Average
-			self._average = Average(self._core, self._base)
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
 		return self._average
 
 	@property
-	def minimum(self):
-		"""minimum commands group. 0 Sub-classes, 2 commands."""
-		if not hasattr(self, '_minimum'):
-			from .Psd_.Minimum import Minimum
-			self._minimum = Minimum(self._core, self._base)
-		return self._minimum
-
-	@property
 	def maximum(self):
 		"""maximum commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_maximum'):
-			from .Psd_.Maximum import Maximum
-			self._maximum = Maximum(self._core, self._base)
+			from .Maximum import MaximumCls
+			self._maximum = MaximumCls(self._core, self._cmd_group)
 		return self._maximum
 
 	@property
+	def minimum(self):
+		"""minimum commands group. 0 Sub-classes, 2 commands."""
+		if not hasattr(self, '_minimum'):
+			from .Minimum import MinimumCls
+			self._minimum = MinimumCls(self._core, self._cmd_group)
+		return self._minimum
+
+	@property
 	def standardDev(self):
-		"""standardDev commands group. 0 Sub-classes, 1 commands."""
+		"""standardDev commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_standardDev'):
-			from .Psd_.StandardDev import StandardDev
-			self._standardDev = StandardDev(self._core, self._base)
+			from .StandardDev import StandardDevCls
+			self._standardDev = StandardDevCls(self._core, self._cmd_group)
 		return self._standardDev
 
-	def clone(self) -> 'Psd':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'PccCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Psd(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = PccCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Psd_/Average.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Perror/Peak/High/Average.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,37 +1,40 @@
 from typing import List
 
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ......Internal.Types import DataType
+from .........Internal.Core import Core
+from .........Internal.CommandsGroup import CommandsGroup
+from .........Internal import Conversions
+from .........Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .........Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class AverageCls:
+	"""Average commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PSD:AVERage \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.psd.average.fetch() \n
-		Return RB power values (power spectral density) for all measured list mode segments. The values described below are
-		returned by FETCh commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:PEAK:HIGH:AVERage \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.listPy.modulation.perror.peak.high.average.fetch() \n
+		Return phase error peak values for low and high EVM window position, for all measured list mode segments. The values
+		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
+		result listed below. \n
 		Suppressed linked return values: reliability \n
-			:return: psd: Comma-separated list of values, one per measured segment"""
+			:return: ph_error_peak_high: Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PSD:AVERage?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:PEAK:HIGH:AVERage?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PSD:AVERage \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.psd.average.calculate() \n
-		Return RB power values (power spectral density) for all measured list mode segments. The values described below are
-		returned by FETCh commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
+	def calculate(self) -> List[float or bool]:
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:PEAK:HIGH:AVERage \n
+		Snippet: value: List[float or bool] = driver.lteMeas.multiEval.listPy.modulation.perror.peak.high.average.calculate() \n
+		Return phase error peak values for low and high EVM window position, for all measured list mode segments. The values
+		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
+		result listed below. \n
 		Suppressed linked return values: reliability \n
-			:return: psd: Comma-separated list of values, one per measured segment"""
+			:return: ph_error_peak_high: (float or boolean items) Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PSD:AVERage?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:PEAK:HIGH:AVERage?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Psd_/Current.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Psd/Minimum.py`

 * *Files 11% similar despite different names*

```diff
@@ -1,37 +1,38 @@
 from typing import List
 
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ......Internal.Types import DataType
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal import Conversions
+from .......Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .......Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class MinimumCls:
+	"""Minimum commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("minimum", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PSD:CURRent \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.psd.current.fetch() \n
-		Return RB power values (power spectral density) for all measured list mode segments. The values described below are
-		returned by FETCh commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PSD:MINimum \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.listPy.modulation.psd.minimum.fetch() \n
+		Return RB power values for all measured list mode segments. The values described below are returned by FETCh commands.
+		CALCulate commands return limit check results instead, one value for each result listed below. \n
 		Suppressed linked return values: reliability \n
 			:return: psd: Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PSD:CURRent?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PSD:MINimum?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PSD:CURRent \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.psd.current.calculate() \n
-		Return RB power values (power spectral density) for all measured list mode segments. The values described below are
-		returned by FETCh commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
+	def calculate(self) -> List[float or bool]:
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PSD:MINimum \n
+		Snippet: value: List[float or bool] = driver.lteMeas.multiEval.listPy.modulation.psd.minimum.calculate() \n
+		Return RB power values for all measured list mode segments. The values described below are returned by FETCh commands.
+		CALCulate commands return limit check results instead, one value for each result listed below. \n
 		Suppressed linked return values: reliability \n
-			:return: psd: Comma-separated list of values, one per measured segment"""
+			:return: psd: (float or boolean items) Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PSD:CURRent?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PSD:MINimum?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Psd_/Maximum.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Merror/Dmrs/High/Extreme.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,37 +1,40 @@
 from typing import List
 
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ......Internal.Types import DataType
+from .........Internal.Core import Core
+from .........Internal.CommandsGroup import CommandsGroup
+from .........Internal import Conversions
+from .........Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .........Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Maximum:
-	"""Maximum commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class ExtremeCls:
+	"""Extreme commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("maximum", core, parent)
+		self._cmd_group = CommandsGroup("extreme", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PSD:MAXimum \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.psd.maximum.fetch() \n
-		Return RB power values (power spectral density) for all measured list mode segments. The values described below are
-		returned by FETCh commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:DMRS:HIGH:EXTReme \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.listPy.modulation.merror.dmrs.high.extreme.fetch() \n
+		Return magnitude error DMRS values for low and high EVM window position, for all measured list mode segments. The values
+		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
+		result listed below. \n
 		Suppressed linked return values: reliability \n
-			:return: psd: Comma-separated list of values, one per measured segment"""
+			:return: mag_err_dmrs_high: Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PSD:MAXimum?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:DMRS:HIGH:EXTReme?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PSD:MAXimum \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.psd.maximum.calculate() \n
-		Return RB power values (power spectral density) for all measured list mode segments. The values described below are
-		returned by FETCh commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
+	def calculate(self) -> List[float or bool]:
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:DMRS:HIGH:EXTReme \n
+		Snippet: value: List[float or bool] = driver.lteMeas.multiEval.listPy.modulation.merror.dmrs.high.extreme.calculate() \n
+		Return magnitude error DMRS values for low and high EVM window position, for all measured list mode segments. The values
+		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
+		result listed below. \n
 		Suppressed linked return values: reliability \n
-			:return: psd: Comma-separated list of values, one per measured segment"""
+			:return: mag_err_dmrs_high: (float or boolean items) Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PSD:MAXimum?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:DMRS:HIGH:EXTReme?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Psd_/Minimum.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/SeMask/Obw/Extreme.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,37 +1,38 @@
 from typing import List
 
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ......Internal.Types import DataType
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal import Conversions
+from .......Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .......Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Minimum:
-	"""Minimum commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class ExtremeCls:
+	"""Extreme commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("minimum", core, parent)
+		self._cmd_group = CommandsGroup("extreme", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PSD:MINimum \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.psd.minimum.fetch() \n
-		Return RB power values (power spectral density) for all measured list mode segments. The values described below are
-		returned by FETCh commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEMask:OBW:EXTReme \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.listPy.seMask.obw.extreme.fetch() \n
+		Return the occupied bandwidth for all measured list mode segments. The values described below are returned by FETCh
+		commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 		Suppressed linked return values: reliability \n
-			:return: psd: Comma-separated list of values, one per measured segment"""
+			:return: obw: Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PSD:MINimum?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEMask:OBW:EXTReme?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PSD:MINimum \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.psd.minimum.calculate() \n
-		Return RB power values (power spectral density) for all measured list mode segments. The values described below are
-		returned by FETCh commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
+	def calculate(self) -> List[float or bool]:
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEMask:OBW:EXTReme \n
+		Snippet: value: List[float or bool] = driver.lteMeas.multiEval.listPy.seMask.obw.extreme.calculate() \n
+		Return the occupied bandwidth for all measured list mode segments. The values described below are returned by FETCh
+		commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 		Suppressed linked return values: reliability \n
-			:return: psd: Comma-separated list of values, one per measured segment"""
+			:return: obw: (float or boolean items) Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PSD:MINimum?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEMask:OBW:EXTReme?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Psd_/StandardDev.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Trace/Iemissions/Pcc.py`

 * *Files 19% similar despite different names*

```diff
@@ -3,24 +3,33 @@
 from ......Internal.Core import Core
 from ......Internal.CommandsGroup import CommandsGroup
 from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ......Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class StandardDev:
-	"""StandardDev commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class PccCls:
+	"""Pcc commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("standardDev", core, parent)
+		self._cmd_group = CommandsGroup("pcc", core, parent)
+
+	def read(self) -> List[float]:
+		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:TRACe:IEMissions[:PCC] \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.trace.iemissions.pcc.read() \n
+		No command help available \n
+		Suppressed linked return values: reliability \n
+			:return: power: No help available"""
+		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:LTE:MEASurement<Instance>:MEValuation:TRACe:IEMissions:PCC?', suppressed)
+		return response
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PSD:SDEViation \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.psd.standardDev.fetch() \n
-		Return RB power values (power spectral density) for all measured list mode segments. The values described below are
-		returned by FETCh commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:TRACe:IEMissions[:PCC] \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.trace.iemissions.pcc.fetch() \n
+		No command help available \n
 		Suppressed linked return values: reliability \n
-			:return: psd: Comma-separated list of values, one per measured segment"""
+			:return: power: No help available"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PSD:SDEViation?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:TRACe:IEMissions:PCC?', suppressed)
 		return response
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/SchType.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/SchType.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,28 +1,28 @@
 from typing import List
 
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
-from .....Internal import Conversions
-from .....Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from .....Internal.Types import DataType
-from ..... import enums
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal import Conversions
+from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from ......Internal.Types import DataType
+from ...... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class SchType:
-	"""SchType commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class SchTypeCls:
+	"""SchType commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("schType", core, parent)
+		self._cmd_group = CommandsGroup("schType", core, parent)
 
 	# noinspection PyTypeChecker
 	def fetch(self) -> List[enums.SidelinkChannelType]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:SCHType \n
-		Snippet: value: List[enums.SidelinkChannelType] = driver.multiEval.listPy.modulation.schType.fetch() \n
+		Snippet: value: List[enums.SidelinkChannelType] = driver.lteMeas.multiEval.listPy.modulation.schType.fetch() \n
 		Returns the sidelink channel type evaluated for modulation results, for all measured list mode segments. \n
 		Suppressed linked return values: reliability \n
 			:return: channel_type: Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_str_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:SCHType?', suppressed)
 		return Conversions.str_to_list_enum(response, enums.SidelinkChannelType)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Terror.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Merror/Dmrs/High/__init__.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,51 +1,51 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
+from .........Internal.Core import Core
+from .........Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Terror:
-	"""Terror commands group definition. 7 total commands, 4 Sub-groups, 0 group commands"""
+class HighCls:
+	"""High commands group definition. 7 total commands, 4 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("terror", core, parent)
+		self._cmd_group = CommandsGroup("high", core, parent)
 
 	@property
 	def current(self):
 		"""current commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_current'):
-			from .Terror_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
 	@property
 	def average(self):
 		"""average commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_average'):
-			from .Terror_.Average import Average
-			self._average = Average(self._core, self._base)
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
 		return self._average
 
 	@property
 	def extreme(self):
 		"""extreme commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_extreme'):
-			from .Terror_.Extreme import Extreme
-			self._extreme = Extreme(self._core, self._base)
+			from .Extreme import ExtremeCls
+			self._extreme = ExtremeCls(self._core, self._cmd_group)
 		return self._extreme
 
 	@property
 	def standardDev(self):
 		"""standardDev commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_standardDev'):
-			from .Terror_.StandardDev import StandardDev
-			self._standardDev = StandardDev(self._core, self._base)
+			from .StandardDev import StandardDevCls
+			self._standardDev = StandardDevCls(self._core, self._cmd_group)
 		return self._standardDev
 
-	def clone(self) -> 'Terror':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'HighCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Terror(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = HighCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Terror_/Average.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Terror/Average.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,37 +1,38 @@
 from typing import List
 
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ......Internal.Types import DataType
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal import Conversions
+from .......Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .......Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class AverageCls:
+	"""Average commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	def fetch(self) -> List[float]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:TERRor:AVERage \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.terror.average.fetch() \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.listPy.modulation.terror.average.fetch() \n
 		Return transmit time error values for all measured list mode segments. The values described below are returned by FETCh
 		commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 		Suppressed linked return values: reliability \n
 			:return: timing_error: Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:TERRor:AVERage?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
+	def calculate(self) -> List[float or bool]:
 		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:TERRor:AVERage \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.terror.average.calculate() \n
+		Snippet: value: List[float or bool] = driver.lteMeas.multiEval.listPy.modulation.terror.average.calculate() \n
 		Return transmit time error values for all measured list mode segments. The values described below are returned by FETCh
 		commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 		Suppressed linked return values: reliability \n
-			:return: timing_error: Comma-separated list of values, one per measured segment"""
+			:return: timing_error: (float or boolean items) Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:TERRor:AVERage?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:TERRor:AVERage?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Terror_/Current.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Tpower/Current.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,37 +1,38 @@
 from typing import List
 
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ......Internal.Types import DataType
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal import Conversions
+from .......Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .......Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:TERRor:CURRent \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.terror.current.fetch() \n
-		Return transmit time error values for all measured list mode segments. The values described below are returned by FETCh
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:TPOWer:CURRent \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.listPy.modulation.tpower.current.fetch() \n
+		Return user equipment power values for all measured list mode segments. The values described below are returned by FETCh
 		commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 		Suppressed linked return values: reliability \n
-			:return: timing_error: Comma-separated list of values, one per measured segment"""
+			:return: tx_power: Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:TERRor:CURRent?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:TPOWer:CURRent?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:TERRor:CURRent \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.terror.current.calculate() \n
-		Return transmit time error values for all measured list mode segments. The values described below are returned by FETCh
+	def calculate(self) -> List[float or bool]:
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:TPOWer:CURRent \n
+		Snippet: value: List[float or bool] = driver.lteMeas.multiEval.listPy.modulation.tpower.current.calculate() \n
+		Return user equipment power values for all measured list mode segments. The values described below are returned by FETCh
 		commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 		Suppressed linked return values: reliability \n
-			:return: timing_error: Comma-separated list of values, one per measured segment"""
+			:return: tx_power: (float or boolean items) Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:TERRor:CURRent?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:TPOWer:CURRent?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Terror_/Extreme.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Terror/Extreme.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,37 +1,38 @@
 from typing import List
 
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ......Internal.Types import DataType
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal import Conversions
+from .......Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .......Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Extreme:
-	"""Extreme commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class ExtremeCls:
+	"""Extreme commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("extreme", core, parent)
+		self._cmd_group = CommandsGroup("extreme", core, parent)
 
 	def fetch(self) -> List[float]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:TERRor:EXTReme \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.terror.extreme.fetch() \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.listPy.modulation.terror.extreme.fetch() \n
 		Return transmit time error values for all measured list mode segments. The values described below are returned by FETCh
 		commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 		Suppressed linked return values: reliability \n
 			:return: timing_error: Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:TERRor:EXTReme?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
+	def calculate(self) -> List[float or bool]:
 		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:TERRor:EXTReme \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.terror.extreme.calculate() \n
+		Snippet: value: List[float or bool] = driver.lteMeas.multiEval.listPy.modulation.terror.extreme.calculate() \n
 		Return transmit time error values for all measured list mode segments. The values described below are returned by FETCh
 		commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 		Suppressed linked return values: reliability \n
-			:return: timing_error: Comma-separated list of values, one per measured segment"""
+			:return: timing_error: (float or boolean items) Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:TERRor:EXTReme?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:TERRor:EXTReme?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Terror_/StandardDev.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Terror/StandardDev.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,26 +1,26 @@
 from typing import List
 
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ......Internal.Types import DataType
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .......Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class StandardDev:
-	"""StandardDev commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class StandardDevCls:
+	"""StandardDev commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("standardDev", core, parent)
+		self._cmd_group = CommandsGroup("standardDev", core, parent)
 
 	def fetch(self) -> List[float]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:TERRor:SDEViation \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.terror.standardDev.fetch() \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.listPy.modulation.terror.standardDev.fetch() \n
 		Return transmit time error values for all measured list mode segments. The values described below are returned by FETCh
 		commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 		Suppressed linked return values: reliability \n
 			:return: timing_error: Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:TERRor:SDEViation?', suppressed)
 		return response
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Tpower.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Ppower/__init__.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,59 +1,59 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Tpower:
-	"""Tpower commands group definition. 9 total commands, 5 Sub-groups, 0 group commands"""
+class PpowerCls:
+	"""Ppower commands group definition. 9 total commands, 5 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("tpower", core, parent)
+		self._cmd_group = CommandsGroup("ppower", core, parent)
 
 	@property
 	def current(self):
 		"""current commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_current'):
-			from .Tpower_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
 	@property
 	def average(self):
 		"""average commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_average'):
-			from .Tpower_.Average import Average
-			self._average = Average(self._core, self._base)
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
 		return self._average
 
 	@property
 	def minimum(self):
 		"""minimum commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_minimum'):
-			from .Tpower_.Minimum import Minimum
-			self._minimum = Minimum(self._core, self._base)
+			from .Minimum import MinimumCls
+			self._minimum = MinimumCls(self._core, self._cmd_group)
 		return self._minimum
 
 	@property
 	def maximum(self):
 		"""maximum commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_maximum'):
-			from .Tpower_.Maximum import Maximum
-			self._maximum = Maximum(self._core, self._base)
+			from .Maximum import MaximumCls
+			self._maximum = MaximumCls(self._core, self._cmd_group)
 		return self._maximum
 
 	@property
 	def standardDev(self):
 		"""standardDev commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_standardDev'):
-			from .Tpower_.StandardDev import StandardDev
-			self._standardDev = StandardDev(self._core, self._base)
+			from .StandardDev import StandardDevCls
+			self._standardDev = StandardDevCls(self._core, self._cmd_group)
 		return self._standardDev
 
-	def clone(self) -> 'Tpower':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'PpowerCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Tpower(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = PpowerCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Tpower_/Average.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Ppower/Current.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,37 +1,38 @@
 from typing import List
 
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ......Internal.Types import DataType
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal import Conversions
+from .......Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .......Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:TPOWer:AVERage \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.tpower.average.fetch() \n
-		Return user equipment power values for all measured list mode segments. The values described below are returned by FETCh
-		commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PPOWer:CURRent \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.listPy.modulation.ppower.current.fetch() \n
+		Return user equipment peak power values for all measured list mode segments. The values described below are returned by
+		FETCh commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 		Suppressed linked return values: reliability \n
-			:return: tx_power: Comma-separated list of values, one per measured segment"""
+			:return: peak_power: Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:TPOWer:AVERage?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PPOWer:CURRent?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:TPOWer:AVERage \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.tpower.average.calculate() \n
-		Return user equipment power values for all measured list mode segments. The values described below are returned by FETCh
-		commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
+	def calculate(self) -> List[float or bool]:
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PPOWer:CURRent \n
+		Snippet: value: List[float or bool] = driver.lteMeas.multiEval.listPy.modulation.ppower.current.calculate() \n
+		Return user equipment peak power values for all measured list mode segments. The values described below are returned by
+		FETCh commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 		Suppressed linked return values: reliability \n
-			:return: tx_power: Comma-separated list of values, one per measured segment"""
+			:return: peak_power: (float or boolean items) Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:TPOWer:AVERage?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PPOWer:CURRent?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Tpower_/Current.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/SeMask/TxPower/Current.py`

 * *Files 11% similar despite different names*

```diff
@@ -1,37 +1,38 @@
 from typing import List
 
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ......Internal.Types import DataType
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal import Conversions
+from .......Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .......Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:TPOWer:CURRent \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.tpower.current.fetch() \n
-		Return user equipment power values for all measured list mode segments. The values described below are returned by FETCh
-		commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEMask:TXPower:CURRent \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.listPy.seMask.txPower.current.fetch() \n
+		Return the total TX power in the slot for all measured list mode segments. The values described below are returned by
+		FETCh commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 		Suppressed linked return values: reliability \n
 			:return: tx_power: Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:TPOWer:CURRent?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEMask:TXPower:CURRent?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:TPOWer:CURRent \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.tpower.current.calculate() \n
-		Return user equipment power values for all measured list mode segments. The values described below are returned by FETCh
-		commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
+	def calculate(self) -> List[float or bool]:
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEMask:TXPower:CURRent \n
+		Snippet: value: List[float or bool] = driver.lteMeas.multiEval.listPy.seMask.txPower.current.calculate() \n
+		Return the total TX power in the slot for all measured list mode segments. The values described below are returned by
+		FETCh commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 		Suppressed linked return values: reliability \n
-			:return: tx_power: Comma-separated list of values, one per measured segment"""
+			:return: tx_power: (float or boolean items) Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:TPOWer:CURRent?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEMask:TXPower:CURRent?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Tpower_/Maximum.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/SeMask/TxPower/Maximum.py`

 * *Files 11% similar despite different names*

```diff
@@ -1,37 +1,38 @@
 from typing import List
 
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ......Internal.Types import DataType
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal import Conversions
+from .......Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .......Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Maximum:
-	"""Maximum commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class MaximumCls:
+	"""Maximum commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("maximum", core, parent)
+		self._cmd_group = CommandsGroup("maximum", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:TPOWer:MAXimum \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.tpower.maximum.fetch() \n
-		Return user equipment power values for all measured list mode segments. The values described below are returned by FETCh
-		commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEMask:TXPower:MAXimum \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.listPy.seMask.txPower.maximum.fetch() \n
+		Return the total TX power in the slot for all measured list mode segments. The values described below are returned by
+		FETCh commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 		Suppressed linked return values: reliability \n
 			:return: tx_power: Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:TPOWer:MAXimum?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEMask:TXPower:MAXimum?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:TPOWer:MAXimum \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.tpower.maximum.calculate() \n
-		Return user equipment power values for all measured list mode segments. The values described below are returned by FETCh
-		commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
+	def calculate(self) -> List[float or bool]:
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEMask:TXPower:MAXimum \n
+		Snippet: value: List[float or bool] = driver.lteMeas.multiEval.listPy.seMask.txPower.maximum.calculate() \n
+		Return the total TX power in the slot for all measured list mode segments. The values described below are returned by
+		FETCh commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 		Suppressed linked return values: reliability \n
-			:return: tx_power: Comma-separated list of values, one per measured segment"""
+			:return: tx_power: (float or boolean items) Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:TPOWer:MAXimum?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEMask:TXPower:MAXimum?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Tpower_/Minimum.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Psd/Maximum.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,37 +1,38 @@
 from typing import List
 
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ......Internal.Types import DataType
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal import Conversions
+from .......Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .......Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Minimum:
-	"""Minimum commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class MaximumCls:
+	"""Maximum commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("minimum", core, parent)
+		self._cmd_group = CommandsGroup("maximum", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:TPOWer:MINimum \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.tpower.minimum.fetch() \n
-		Return user equipment power values for all measured list mode segments. The values described below are returned by FETCh
-		commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PSD:MAXimum \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.listPy.modulation.psd.maximum.fetch() \n
+		Return RB power values for all measured list mode segments. The values described below are returned by FETCh commands.
+		CALCulate commands return limit check results instead, one value for each result listed below. \n
 		Suppressed linked return values: reliability \n
-			:return: tx_power: Comma-separated list of values, one per measured segment"""
+			:return: psd: Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:TPOWer:MINimum?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PSD:MAXimum?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:TPOWer:MINimum \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.tpower.minimum.calculate() \n
-		Return user equipment power values for all measured list mode segments. The values described below are returned by FETCh
-		commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
+	def calculate(self) -> List[float or bool]:
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PSD:MAXimum \n
+		Snippet: value: List[float or bool] = driver.lteMeas.multiEval.listPy.modulation.psd.maximum.calculate() \n
+		Return RB power values for all measured list mode segments. The values described below are returned by FETCh commands.
+		CALCulate commands return limit check results instead, one value for each result listed below. \n
 		Suppressed linked return values: reliability \n
-			:return: tx_power: Comma-separated list of values, one per measured segment"""
+			:return: psd: (float or boolean items) Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:TPOWer:MINimum?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PSD:MAXimum?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Modulation_/Tpower_/StandardDev.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/SeMask/TxPower/Minimum.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,26 +1,38 @@
 from typing import List
 
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ......Internal.Types import DataType
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal import Conversions
+from .......Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .......Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class StandardDev:
-	"""StandardDev commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class MinimumCls:
+	"""Minimum commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("standardDev", core, parent)
+		self._cmd_group = CommandsGroup("minimum", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:TPOWer:SDEViation \n
-		Snippet: value: List[float] = driver.multiEval.listPy.modulation.tpower.standardDev.fetch() \n
-		Return user equipment power values for all measured list mode segments. The values described below are returned by FETCh
-		commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEMask:TXPower:MINimum \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.listPy.seMask.txPower.minimum.fetch() \n
+		Return the total TX power in the slot for all measured list mode segments. The values described below are returned by
+		FETCh commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 		Suppressed linked return values: reliability \n
 			:return: tx_power: Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:TPOWer:SDEViation?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEMask:TXPower:MINimum?', suppressed)
 		return response
+
+	def calculate(self) -> List[float or bool]:
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEMask:TXPower:MINimum \n
+		Snippet: value: List[float or bool] = driver.lteMeas.multiEval.listPy.seMask.txPower.minimum.calculate() \n
+		Return the total TX power in the slot for all measured list mode segments. The values described below are returned by
+		FETCh commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
+		Suppressed linked return values: reliability \n
+			:return: tx_power: (float or boolean items) Comma-separated list of values, one per measured segment"""
+		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEMask:TXPower:MINimum?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Pmonitor.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Amarker/Pmonitor/__init__.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,35 +1,27 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Pmonitor:
-	"""Pmonitor commands group definition. 2 total commands, 2 Sub-groups, 0 group commands"""
+class PmonitorCls:
+	"""Pmonitor commands group definition. 1 total commands, 1 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("pmonitor", core, parent)
+		self._cmd_group = CommandsGroup("pmonitor", core, parent)
 
 	@property
-	def rms(self):
-		"""rms commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_rms'):
-			from .Pmonitor_.Rms import Rms
-			self._rms = Rms(self._core, self._base)
-		return self._rms
+	def cc(self):
+		"""cc commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_cc'):
+			from .Cc import CcCls
+			self._cc = CcCls(self._core, self._cmd_group)
+		return self._cc
 
-	@property
-	def peak(self):
-		"""peak commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_peak'):
-			from .Pmonitor_.Peak import Peak
-			self._peak = Peak(self._core, self._base)
-		return self._peak
-
-	def clone(self) -> 'Pmonitor':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'PmonitorCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Pmonitor(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = PmonitorCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Pmonitor_/Peak.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Pmonitor/Rms.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,30 +1,30 @@
 from typing import List
 
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
-from .....Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from .....Internal.Types import DataType
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from ......Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Peak:
-	"""Peak commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class RmsCls:
+	"""Rms commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("peak", core, parent)
+		self._cmd_group = CommandsGroup("rms", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:PMONitor:PEAK \n
-		Snippet: value: List[float] = driver.multiEval.listPy.pmonitor.peak.fetch() \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:PMONitor:RMS \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.listPy.pmonitor.rms.fetch() \n
 		Return the power monitor results for all measured segments in list mode. The commands return one power result per
 		subframe for the measured carrier. The power values are RMS averaged over the subframe or represent the peak value within
 		the subframe.
 			INTRO_CMD_HELP: Commands for querying the result list structure: \n
-			- method RsCMPX_LteMeas.MultiEval.ListPy.Segment.Pmonitor.Array.Start.fetch
-			- method RsCMPX_LteMeas.MultiEval.ListPy.Segment.Pmonitor.Array.Length.fetch  \n
+			- method RsCMPX_LteMeas.LteMeas.MultiEval.ListPy.Segment.Pmonitor.Array.Start.fetch
+			- method RsCMPX_LteMeas.LteMeas.MultiEval.ListPy.Segment.Pmonitor.Array.Length.fetch  \n
 		Suppressed linked return values: reliability \n
-			:return: step_peak_power: Comma-separated list of power values, one value per subframe, from first subframe of first measured segment to last subframe of last measured segment For an inactive segment only one INV is returned, independent of the number of configured subframes."""
+			:return: step_rms_power: Comma-separated list of power values, one value per subframe, from first subframe of first measured segment to last subframe of last measured segment For an inactive segment only one INV is returned, independent of the number of configured subframes."""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:PMONitor:PEAK?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:PMONitor:RMS?', suppressed)
 		return response
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Pmonitor_/Rms.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Pmonitor/Peak.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,30 +1,30 @@
 from typing import List
 
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
-from .....Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from .....Internal.Types import DataType
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from ......Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Rms:
-	"""Rms commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class PeakCls:
+	"""Peak commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("rms", core, parent)
+		self._cmd_group = CommandsGroup("peak", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:PMONitor:RMS \n
-		Snippet: value: List[float] = driver.multiEval.listPy.pmonitor.rms.fetch() \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:PMONitor:PEAK \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.listPy.pmonitor.peak.fetch() \n
 		Return the power monitor results for all measured segments in list mode. The commands return one power result per
 		subframe for the measured carrier. The power values are RMS averaged over the subframe or represent the peak value within
 		the subframe.
 			INTRO_CMD_HELP: Commands for querying the result list structure: \n
-			- method RsCMPX_LteMeas.MultiEval.ListPy.Segment.Pmonitor.Array.Start.fetch
-			- method RsCMPX_LteMeas.MultiEval.ListPy.Segment.Pmonitor.Array.Length.fetch  \n
+			- method RsCMPX_LteMeas.LteMeas.MultiEval.ListPy.Segment.Pmonitor.Array.Start.fetch
+			- method RsCMPX_LteMeas.LteMeas.MultiEval.ListPy.Segment.Pmonitor.Array.Length.fetch  \n
 		Suppressed linked return values: reliability \n
-			:return: step_rms_power: Comma-separated list of power values, one value per subframe, from first subframe of first measured segment to last subframe of last measured segment For an inactive segment only one INV is returned, independent of the number of configured subframes."""
+			:return: step_peak_power: Comma-separated list of power values, one value per subframe, from first subframe of first measured segment to last subframe of last measured segment For an inactive segment only one INV is returned, independent of the number of configured subframes."""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:PMONitor:RMS?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:PMONitor:PEAK?', suppressed)
 		return response
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Power.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Power/__init__.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,27 +1,27 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Power:
-	"""Power commands group definition. 9 total commands, 1 Sub-groups, 0 group commands"""
+class PowerCls:
+	"""Power commands group definition. 9 total commands, 1 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("power", core, parent)
+		self._cmd_group = CommandsGroup("power", core, parent)
 
 	@property
 	def txPower(self):
 		"""txPower commands group. 5 Sub-classes, 0 commands."""
 		if not hasattr(self, '_txPower'):
-			from .Power_.TxPower import TxPower
-			self._txPower = TxPower(self._core, self._base)
+			from .TxPower import TxPowerCls
+			self._txPower = TxPowerCls(self._core, self._cmd_group)
 		return self._txPower
 
-	def clone(self) -> 'Power':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'PowerCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Power(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = PowerCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Power_/TxPower.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Trace/Pdynamics/__init__.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,59 +1,43 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class TxPower:
-	"""TxPower commands group definition. 9 total commands, 5 Sub-groups, 0 group commands"""
+class PdynamicsCls:
+	"""Pdynamics commands group definition. 6 total commands, 3 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("txPower", core, parent)
+		self._cmd_group = CommandsGroup("pdynamics", core, parent)
 
 	@property
 	def current(self):
 		"""current commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_current'):
-			from .TxPower_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
 	@property
 	def average(self):
 		"""average commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_average'):
-			from .TxPower_.Average import Average
-			self._average = Average(self._core, self._base)
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
 		return self._average
 
 	@property
-	def minimum(self):
-		"""minimum commands group. 0 Sub-classes, 2 commands."""
-		if not hasattr(self, '_minimum'):
-			from .TxPower_.Minimum import Minimum
-			self._minimum = Minimum(self._core, self._base)
-		return self._minimum
-
-	@property
 	def maximum(self):
 		"""maximum commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_maximum'):
-			from .TxPower_.Maximum import Maximum
-			self._maximum = Maximum(self._core, self._base)
+			from .Maximum import MaximumCls
+			self._maximum = MaximumCls(self._core, self._cmd_group)
 		return self._maximum
 
-	@property
-	def standardDev(self):
-		"""standardDev commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_standardDev'):
-			from .TxPower_.StandardDev import StandardDev
-			self._standardDev = StandardDev(self._core, self._base)
-		return self._standardDev
-
-	def clone(self) -> 'TxPower':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'PdynamicsCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = TxPower(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = PdynamicsCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Power_/TxPower_/Average.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Power/TxPower/Average.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,35 +1,36 @@
 from typing import List
 
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ......Internal.Types import DataType
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal import Conversions
+from .......Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .......Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class AverageCls:
+	"""Average commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	def fetch(self) -> List[float]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:POWer:TXPower:AVERage \n
-		Snippet: value: List[float] = driver.multiEval.listPy.power.txPower.average.fetch() \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.listPy.power.txPower.average.fetch() \n
 		Return the total TX power of all component carriers, for all measured list mode segments. \n
 		Suppressed linked return values: reliability \n
 			:return: tx_power: Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:POWer:TXPower:AVERage?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
+	def calculate(self) -> List[float or bool]:
 		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:POWer:TXPower:AVERage \n
-		Snippet: value: List[float] = driver.multiEval.listPy.power.txPower.average.calculate() \n
+		Snippet: value: List[float or bool] = driver.lteMeas.multiEval.listPy.power.txPower.average.calculate() \n
 		No command help available \n
 		Suppressed linked return values: reliability \n
-			:return: tx_power: No help available"""
+			:return: tx_power: (float or boolean items) No help available"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:POWer:TXPower:AVERage?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:POWer:TXPower:AVERage?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Power_/TxPower_/Current.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Power/TxPower/Current.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,35 +1,36 @@
 from typing import List
 
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ......Internal.Types import DataType
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal import Conversions
+from .......Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .......Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	def fetch(self) -> List[float]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:POWer:TXPower:CURRent \n
-		Snippet: value: List[float] = driver.multiEval.listPy.power.txPower.current.fetch() \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.listPy.power.txPower.current.fetch() \n
 		Return the total TX power of all component carriers, for all measured list mode segments. \n
 		Suppressed linked return values: reliability \n
 			:return: tx_power: Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:POWer:TXPower:CURRent?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
+	def calculate(self) -> List[float or bool]:
 		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:POWer:TXPower:CURRent \n
-		Snippet: value: List[float] = driver.multiEval.listPy.power.txPower.current.calculate() \n
+		Snippet: value: List[float or bool] = driver.lteMeas.multiEval.listPy.power.txPower.current.calculate() \n
 		No command help available \n
 		Suppressed linked return values: reliability \n
-			:return: tx_power: No help available"""
+			:return: tx_power: (float or boolean items) No help available"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:POWer:TXPower:CURRent?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:POWer:TXPower:CURRent?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Power_/TxPower_/Maximum.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Power/TxPower/Maximum.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,35 +1,36 @@
 from typing import List
 
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ......Internal.Types import DataType
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal import Conversions
+from .......Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .......Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Maximum:
-	"""Maximum commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class MaximumCls:
+	"""Maximum commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("maximum", core, parent)
+		self._cmd_group = CommandsGroup("maximum", core, parent)
 
 	def fetch(self) -> List[float]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:POWer:TXPower:MAXimum \n
-		Snippet: value: List[float] = driver.multiEval.listPy.power.txPower.maximum.fetch() \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.listPy.power.txPower.maximum.fetch() \n
 		Return the total TX power of all component carriers, for all measured list mode segments. \n
 		Suppressed linked return values: reliability \n
 			:return: tx_power: Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:POWer:TXPower:MAXimum?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
+	def calculate(self) -> List[float or bool]:
 		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:POWer:TXPower:MAXimum \n
-		Snippet: value: List[float] = driver.multiEval.listPy.power.txPower.maximum.calculate() \n
+		Snippet: value: List[float or bool] = driver.lteMeas.multiEval.listPy.power.txPower.maximum.calculate() \n
 		No command help available \n
 		Suppressed linked return values: reliability \n
-			:return: tx_power: No help available"""
+			:return: tx_power: (float or boolean items) No help available"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:POWer:TXPower:MAXimum?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:POWer:TXPower:MAXimum?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Power_/TxPower_/Minimum.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/SeMask/TxPower/Average.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,35 +1,38 @@
 from typing import List
 
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ......Internal.Types import DataType
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal import Conversions
+from .......Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .......Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Minimum:
-	"""Minimum commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class AverageCls:
+	"""Average commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("minimum", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:POWer:TXPower:MINimum \n
-		Snippet: value: List[float] = driver.multiEval.listPy.power.txPower.minimum.fetch() \n
-		Return the total TX power of all component carriers, for all measured list mode segments. \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEMask:TXPower:AVERage \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.listPy.seMask.txPower.average.fetch() \n
+		Return the total TX power in the slot for all measured list mode segments. The values described below are returned by
+		FETCh commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 		Suppressed linked return values: reliability \n
 			:return: tx_power: Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:POWer:TXPower:MINimum?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEMask:TXPower:AVERage?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:POWer:TXPower:MINimum \n
-		Snippet: value: List[float] = driver.multiEval.listPy.power.txPower.minimum.calculate() \n
-		No command help available \n
+	def calculate(self) -> List[float or bool]:
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEMask:TXPower:AVERage \n
+		Snippet: value: List[float or bool] = driver.lteMeas.multiEval.listPy.seMask.txPower.average.calculate() \n
+		Return the total TX power in the slot for all measured list mode segments. The values described below are returned by
+		FETCh commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 		Suppressed linked return values: reliability \n
-			:return: tx_power: No help available"""
+			:return: tx_power: (float or boolean items) Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:POWer:TXPower:MINimum?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEMask:TXPower:AVERage?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Power_/TxPower_/StandardDev.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Power/TxPower/StandardDev.py`

 * *Files 11% similar despite different names*

```diff
@@ -1,25 +1,25 @@
 from typing import List
 
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ......Internal.Types import DataType
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .......Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class StandardDev:
-	"""StandardDev commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class StandardDevCls:
+	"""StandardDev commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("standardDev", core, parent)
+		self._cmd_group = CommandsGroup("standardDev", core, parent)
 
 	def fetch(self) -> List[float]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:POWer:TXPower:SDEViation \n
-		Snippet: value: List[float] = driver.multiEval.listPy.power.txPower.standardDev.fetch() \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.listPy.power.txPower.standardDev.fetch() \n
 		Return the total TX power of all component carriers, for all measured list mode segments. \n
 		Suppressed linked return values: reliability \n
 			:return: tx_power: Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:POWer:TXPower:SDEViation?', suppressed)
 		return response
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/SeMask.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/Prach/Trace/__init__.py`

 * *Files 21% similar despite different names*

```diff
@@ -1,59 +1,75 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class SeMask:
-	"""SeMask commands group definition. 24 total commands, 5 Sub-groups, 0 group commands"""
+class TraceCls:
+	"""Trace commands group definition. 29 total commands, 7 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("seMask", core, parent)
+		self._cmd_group = CommandsGroup("trace", core, parent)
 
 	@property
-	def obw(self):
-		"""obw commands group. 4 Sub-classes, 0 commands."""
-		if not hasattr(self, '_obw'):
-			from .SeMask_.Obw import Obw
-			self._obw = Obw(self._core, self._base)
-		return self._obw
-
-	@property
-	def txPower(self):
-		"""txPower commands group. 5 Sub-classes, 0 commands."""
-		if not hasattr(self, '_txPower'):
-			from .SeMask_.TxPower import TxPower
-			self._txPower = TxPower(self._core, self._base)
-		return self._txPower
-
-	@property
-	def margin(self):
-		"""margin commands group. 1 Sub-classes, 0 commands."""
-		if not hasattr(self, '_margin'):
-			from .SeMask_.Margin import Margin
-			self._margin = Margin(self._core, self._base)
-		return self._margin
-
-	@property
-	def dchType(self):
-		"""dchType commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_dchType'):
-			from .SeMask_.DchType import DchType
-			self._dchType = DchType(self._core, self._base)
-		return self._dchType
-
-	@property
-	def dallocation(self):
-		"""dallocation commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_dallocation'):
-			from .SeMask_.Dallocation import Dallocation
-			self._dallocation = Dallocation(self._core, self._base)
-		return self._dallocation
+	def evm(self):
+		"""evm commands group. 3 Sub-classes, 0 commands."""
+		if not hasattr(self, '_evm'):
+			from .Evm import EvmCls
+			self._evm = EvmCls(self._core, self._cmd_group)
+		return self._evm
 
-	def clone(self) -> 'SeMask':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	@property
+	def evPreamble(self):
+		"""evPreamble commands group. 0 Sub-classes, 2 commands."""
+		if not hasattr(self, '_evPreamble'):
+			from .EvPreamble import EvPreambleCls
+			self._evPreamble = EvPreambleCls(self._core, self._cmd_group)
+		return self._evPreamble
+
+	@property
+	def merror(self):
+		"""merror commands group. 3 Sub-classes, 0 commands."""
+		if not hasattr(self, '_merror'):
+			from .Merror import MerrorCls
+			self._merror = MerrorCls(self._core, self._cmd_group)
+		return self._merror
+
+	@property
+	def perror(self):
+		"""perror commands group. 3 Sub-classes, 0 commands."""
+		if not hasattr(self, '_perror'):
+			from .Perror import PerrorCls
+			self._perror = PerrorCls(self._core, self._cmd_group)
+		return self._perror
+
+	@property
+	def iq(self):
+		"""iq commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_iq'):
+			from .Iq import IqCls
+			self._iq = IqCls(self._core, self._cmd_group)
+		return self._iq
+
+	@property
+	def pdynamics(self):
+		"""pdynamics commands group. 3 Sub-classes, 0 commands."""
+		if not hasattr(self, '_pdynamics'):
+			from .Pdynamics import PdynamicsCls
+			self._pdynamics = PdynamicsCls(self._core, self._cmd_group)
+		return self._pdynamics
+
+	@property
+	def pvPreamble(self):
+		"""pvPreamble commands group. 0 Sub-classes, 2 commands."""
+		if not hasattr(self, '_pvPreamble'):
+			from .PvPreamble import PvPreambleCls
+			self._pvPreamble = PvPreambleCls(self._core, self._cmd_group)
+		return self._pvPreamble
+
+	def clone(self) -> 'TraceCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = SeMask(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = TraceCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/SeMask_/Dallocation.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/SeMask/Dallocation.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,28 +1,28 @@
 from typing import List
 
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
-from .....Internal.Types import DataType
-from .....Internal.StructBase import StructBase
-from .....Internal.ArgStruct import ArgStruct
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal.Types import DataType
+from ......Internal.StructBase import StructBase
+from ......Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Dallocation:
-	"""Dallocation commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class DallocationCls:
+	"""Dallocation commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("dallocation", core, parent)
+		self._cmd_group = CommandsGroup("dallocation", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
+			- Reliability: int: 'Reliability indicator'
 			- Nr_Res_Blocks: List[int]: Number of allocated resource blocks
 			- Offset_Res_Blocks: List[int]: Offset of the first allocated resource block from the edge of the allocated UL transmission bandwidth"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct('Nr_Res_Blocks', DataType.IntegerList, None, False, True, 1),
 			ArgStruct('Offset_Res_Blocks', DataType.IntegerList, None, False, True, 1)]
 
@@ -30,15 +30,15 @@
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Nr_Res_Blocks: List[int] = None
 			self.Offset_Res_Blocks: List[int] = None
 
 	def fetch(self) -> FetchStruct:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEMask:DALLocation \n
-		Snippet: value: FetchStruct = driver.multiEval.listPy.seMask.dallocation.fetch() \n
+		Snippet: value: FetchStruct = driver.lteMeas.multiEval.listPy.seMask.dallocation.fetch() \n
 		Return the detected allocation for all measured list mode segments. The result is determined from the last measured slot
-		of the statistical length of a segment. The individual measurements provide identical detected allocation results when
-		measuring the same slot. However different statistical lengths can be defined for the measurements so that the measured
-		slots and returned results can differ. The results are returned as pairs per segment: <Reliability>, {<NrResBlocks>,
-		<OffsetResBlocks>}Seg 1, {<NrResBlocks>, <OffsetResBlocks>}Seg 2, ... \n
+		of the statistical length of a segment. The individual measurements provide the same result when measuring the same slot.
+		However different statistical lengths can be defined for the measurements so that the measured slots and returned results
+		can differ. The results are returned as pairs per segment: <Reliability>, {<NrResBlocks>, <OffsetResBlocks>}Seg 1,
+		{<NrResBlocks>, <OffsetResBlocks>}Seg 2, ... \n
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
 		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEMask:DALLocation?', self.__class__.FetchStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/SeMask_/DchType.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/SeMask/DchType.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,31 +1,31 @@
 from typing import List
 
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
-from .....Internal import Conversions
-from .....Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from .....Internal.Types import DataType
-from ..... import enums
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal import Conversions
+from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from ......Internal.Types import DataType
+from ...... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class DchType:
-	"""DchType commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class DchTypeCls:
+	"""DchType commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("dchType", core, parent)
+		self._cmd_group = CommandsGroup("dchType", core, parent)
 
 	# noinspection PyTypeChecker
 	def fetch(self) -> List[enums.UplinkChannelType]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEMask:DCHType \n
-		Snippet: value: List[enums.UplinkChannelType] = driver.multiEval.listPy.seMask.dchType.fetch() \n
+		Snippet: value: List[enums.UplinkChannelType] = driver.lteMeas.multiEval.listPy.seMask.dchType.fetch() \n
 		Return the uplink channel type for all measured list mode segments. The result is determined from the last measured slot
-		of the statistical length of a segment. The individual measurements provide identical detected channel type results when
-		measuring the same slot. However different statistical lengths can be defined for the measurements so that the measured
-		slots and returned results can differ. \n
+		of the statistical length of a segment. The individual measurements provide the same result when measuring the same slot.
+		However different statistical lengths can be defined for the measurements so that the measured slots and returned results
+		can differ. \n
 		Suppressed linked return values: reliability \n
 			:return: channel_type: Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_str_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEMask:DCHType?', suppressed)
 		return Conversions.str_to_list_enum(response, enums.UplinkChannelType)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/SeMask_/Margin.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Trace/SeMask/__init__.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,27 +1,27 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Margin:
-	"""Margin commands group definition. 6 total commands, 1 Sub-groups, 0 group commands"""
+class SeMaskCls:
+	"""SeMask commands group definition. 6 total commands, 1 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("margin", core, parent)
+		self._cmd_group = CommandsGroup("seMask", core, parent)
 
 	@property
-	def area(self):
-		"""area commands group. 2 Sub-classes, 0 commands."""
-		if not hasattr(self, '_area'):
-			from .Margin_.Area import Area
-			self._area = Area(self._core, self._base)
-		return self._area
+	def rbw(self):
+		"""rbw commands group. 3 Sub-classes, 0 commands."""
+		if not hasattr(self, '_rbw'):
+			from .Rbw import RbwCls
+			self._rbw = RbwCls(self._core, self._cmd_group)
+		return self._rbw
 
-	def clone(self) -> 'Margin':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'SeMaskCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Margin(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = SeMaskCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/SeMask_/Margin_/Area.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Trace/SeMask/Rbw/__init__.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,50 +1,58 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.RepeatedCapability import RepeatedCapability
-from ...... import repcap
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal.RepeatedCapability import RepeatedCapability
+from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Area:
-	"""Area commands group definition. 6 total commands, 2 Sub-groups, 0 group commands
-	Repeated Capability: Area, default value after init: Area.Nr1"""
+class RbwCls:
+	"""Rbw commands group definition. 6 total commands, 3 Subgroups, 0 group commands
+	Repeated Capability: RBWkHz, default value after init: RBWkHz.Rbw30"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("area", core, parent)
-		self._base.rep_cap = RepeatedCapability(self._base.group_name, 'repcap_area_get', 'repcap_area_set', repcap.Area.Nr1)
+		self._cmd_group = CommandsGroup("rbw", core, parent)
+		self._cmd_group.rep_cap = RepeatedCapability(self._cmd_group.group_name, 'repcap_rBWkHz_get', 'repcap_rBWkHz_set', repcap.RBWkHz.Rbw30)
 
-	def repcap_area_set(self, enum_value: repcap.Area) -> None:
+	def repcap_rBWkHz_set(self, rBWkHz: repcap.RBWkHz) -> None:
 		"""Repeated Capability default value numeric suffix.
-		This value is used, if you do not explicitely set it in the child set/get methods, or if you leave it to Area.Default
-		Default value after init: Area.Nr1"""
-		self._base.set_repcap_enum_value(enum_value)
+		This value is used, if you do not explicitely set it in the child set/get methods, or if you leave it to RBWkHz.Default
+		Default value after init: RBWkHz.Rbw30"""
+		self._cmd_group.set_repcap_enum_value(rBWkHz)
 
-	def repcap_area_get(self) -> repcap.Area:
+	def repcap_rBWkHz_get(self) -> repcap.RBWkHz:
 		"""Returns the current default repeated capability for the child set/get methods"""
 		# noinspection PyTypeChecker
-		return self._base.get_repcap_enum_value()
+		return self._cmd_group.get_repcap_enum_value()
 
 	@property
-	def negativ(self):
-		"""negativ commands group. 3 Sub-classes, 0 commands."""
-		if not hasattr(self, '_negativ'):
-			from .Area_.Negativ import Negativ
-			self._negativ = Negativ(self._core, self._base)
-		return self._negativ
+	def current(self):
+		"""current commands group. 0 Sub-classes, 2 commands."""
+		if not hasattr(self, '_current'):
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
+		return self._current
 
 	@property
-	def positiv(self):
-		"""positiv commands group. 3 Sub-classes, 0 commands."""
-		if not hasattr(self, '_positiv'):
-			from .Area_.Positiv import Positiv
-			self._positiv = Positiv(self._core, self._base)
-		return self._positiv
+	def average(self):
+		"""average commands group. 0 Sub-classes, 2 commands."""
+		if not hasattr(self, '_average'):
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
+		return self._average
 
-	def clone(self) -> 'Area':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	@property
+	def maximum(self):
+		"""maximum commands group. 0 Sub-classes, 2 commands."""
+		if not hasattr(self, '_maximum'):
+			from .Maximum import MaximumCls
+			self._maximum = MaximumCls(self._core, self._cmd_group)
+		return self._maximum
+
+	def clone(self) -> 'RbwCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Area(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = RbwCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/SeMask_/Margin_/Area_/Negativ.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/EsFlatness/__init__.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,43 +1,59 @@
-from .......Internal.Core import Core
-from .......Internal.CommandsGroup import CommandsGroup
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Negativ:
-	"""Negativ commands group definition. 3 total commands, 3 Sub-groups, 0 group commands"""
+class EsFlatnessCls:
+	"""EsFlatness commands group definition. 30 total commands, 5 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("negativ", core, parent)
+		self._cmd_group = CommandsGroup("esFlatness", core, parent)
 
 	@property
-	def current(self):
-		"""current commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_current'):
-			from .Negativ_.Current import Current
-			self._current = Current(self._core, self._base)
-		return self._current
+	def ripple(self):
+		"""ripple commands group. 4 Sub-classes, 0 commands."""
+		if not hasattr(self, '_ripple'):
+			from .Ripple import RippleCls
+			self._ripple = RippleCls(self._core, self._cmd_group)
+		return self._ripple
 
 	@property
-	def average(self):
-		"""average commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_average'):
-			from .Negativ_.Average import Average
-			self._average = Average(self._core, self._base)
-		return self._average
+	def difference(self):
+		"""difference commands group. 4 Sub-classes, 0 commands."""
+		if not hasattr(self, '_difference'):
+			from .Difference import DifferenceCls
+			self._difference = DifferenceCls(self._core, self._cmd_group)
+		return self._difference
 
 	@property
-	def minimum(self):
-		"""minimum commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_minimum'):
-			from .Negativ_.Minimum import Minimum
-			self._minimum = Minimum(self._core, self._base)
-		return self._minimum
+	def minr(self):
+		"""minr commands group. 4 Sub-classes, 0 commands."""
+		if not hasattr(self, '_minr'):
+			from .Minr import MinrCls
+			self._minr = MinrCls(self._core, self._cmd_group)
+		return self._minr
 
-	def clone(self) -> 'Negativ':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	@property
+	def maxr(self):
+		"""maxr commands group. 4 Sub-classes, 0 commands."""
+		if not hasattr(self, '_maxr'):
+			from .Maxr import MaxrCls
+			self._maxr = MaxrCls(self._core, self._cmd_group)
+		return self._maxr
+
+	@property
+	def scIndex(self):
+		"""scIndex commands group. 2 Sub-classes, 0 commands."""
+		if not hasattr(self, '_scIndex'):
+			from .ScIndex import ScIndexCls
+			self._scIndex = ScIndexCls(self._core, self._cmd_group)
+		return self._scIndex
+
+	def clone(self) -> 'EsFlatnessCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Negativ(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = EsFlatnessCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/SeMask_/Margin_/Area_/Negativ_/Average.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/SeMask/Margin/Area/Negativ/Average.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,29 +1,29 @@
 from typing import List
 
-from ........Internal.Core import Core
-from ........Internal.CommandsGroup import CommandsGroup
-from ........Internal.Types import DataType
-from ........Internal.StructBase import StructBase
-from ........Internal.ArgStruct import ArgStruct
-from ........ import repcap
+from .........Internal.Core import Core
+from .........Internal.CommandsGroup import CommandsGroup
+from .........Internal.Types import DataType
+from .........Internal.StructBase import StructBase
+from .........Internal.ArgStruct import ArgStruct
+from ......... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class AverageCls:
+	"""Average commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
+			- Reliability: int: 'Reliability indicator'
 			- Margin_Avg_Neg_X: List[float]: No parameter help available
 			- Margin_Avg_Neg_Y: List[float]: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct('Margin_Avg_Neg_X', DataType.FloatList, None, False, True, 1),
 			ArgStruct('Margin_Avg_Neg_Y', DataType.FloatList, None, False, True, 1)]
 
@@ -31,16 +31,16 @@
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Margin_Avg_Neg_X: List[float] = None
 			self.Margin_Avg_Neg_Y: List[float] = None
 
 	def fetch(self, area=repcap.Area.Default) -> FetchStruct:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEMask:MARGin:AREA<nr>:NEGativ:AVERage \n
-		Snippet: value: FetchStruct = driver.multiEval.listPy.seMask.margin.area.negativ.average.fetch(area = repcap.Area.Default) \n
+		Snippet: value: FetchStruct = driver.lteMeas.multiEval.listPy.seMask.margin.area.negativ.average.fetch(area = repcap.Area.Default) \n
 		Return spectrum emission mask margin positions for all measured list mode segments. The individual commands provide
 		results for the CURRent, AVERage and maximum traces (resulting in MINimum margins) for NEGative and POSitive offset
 		frequencies. The results are returned as pairs per segment: <Reliability>, {<MarginPosX>, <MarginPosY>}Seg 1,
 		{<MarginPosX>, <MarginPosY>}Seg 2, ... \n
 			:param area: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Area')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		area_cmd_val = self._base.get_repcap_cmd_value(area, repcap.Area)
+		area_cmd_val = self._cmd_group.get_repcap_cmd_value(area, repcap.Area)
 		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEMask:MARGin:AREA{area_cmd_val}:NEGativ:AVERage?', self.__class__.FetchStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/SeMask_/Margin_/Area_/Negativ_/Current.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/SeMask/Margin/Area/Negativ/Current.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,29 +1,29 @@
 from typing import List
 
-from ........Internal.Core import Core
-from ........Internal.CommandsGroup import CommandsGroup
-from ........Internal.Types import DataType
-from ........Internal.StructBase import StructBase
-from ........Internal.ArgStruct import ArgStruct
-from ........ import repcap
+from .........Internal.Core import Core
+from .........Internal.CommandsGroup import CommandsGroup
+from .........Internal.Types import DataType
+from .........Internal.StructBase import StructBase
+from .........Internal.ArgStruct import ArgStruct
+from ......... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
+			- Reliability: int: 'Reliability indicator'
 			- Margin_Curr_Neg_X: List[float]: No parameter help available
 			- Margin_Curr_Neg_Y: List[float]: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct('Margin_Curr_Neg_X', DataType.FloatList, None, False, True, 1),
 			ArgStruct('Margin_Curr_Neg_Y', DataType.FloatList, None, False, True, 1)]
 
@@ -31,16 +31,16 @@
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Margin_Curr_Neg_X: List[float] = None
 			self.Margin_Curr_Neg_Y: List[float] = None
 
 	def fetch(self, area=repcap.Area.Default) -> FetchStruct:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEMask:MARGin:AREA<nr>:NEGativ:CURRent \n
-		Snippet: value: FetchStruct = driver.multiEval.listPy.seMask.margin.area.negativ.current.fetch(area = repcap.Area.Default) \n
+		Snippet: value: FetchStruct = driver.lteMeas.multiEval.listPy.seMask.margin.area.negativ.current.fetch(area = repcap.Area.Default) \n
 		Return spectrum emission mask margin positions for all measured list mode segments. The individual commands provide
 		results for the CURRent, AVERage and maximum traces (resulting in MINimum margins) for NEGative and POSitive offset
 		frequencies. The results are returned as pairs per segment: <Reliability>, {<MarginPosX>, <MarginPosY>}Seg 1,
 		{<MarginPosX>, <MarginPosY>}Seg 2, ... \n
 			:param area: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Area')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		area_cmd_val = self._base.get_repcap_cmd_value(area, repcap.Area)
+		area_cmd_val = self._cmd_group.get_repcap_cmd_value(area, repcap.Area)
 		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEMask:MARGin:AREA{area_cmd_val}:NEGativ:CURRent?', self.__class__.FetchStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/SeMask_/Margin_/Area_/Negativ_/Minimum.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/SeMask/Margin/Area/Negativ/Minimum.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,29 +1,29 @@
 from typing import List
 
-from ........Internal.Core import Core
-from ........Internal.CommandsGroup import CommandsGroup
-from ........Internal.Types import DataType
-from ........Internal.StructBase import StructBase
-from ........Internal.ArgStruct import ArgStruct
-from ........ import repcap
+from .........Internal.Core import Core
+from .........Internal.CommandsGroup import CommandsGroup
+from .........Internal.Types import DataType
+from .........Internal.StructBase import StructBase
+from .........Internal.ArgStruct import ArgStruct
+from ......... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Minimum:
-	"""Minimum commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class MinimumCls:
+	"""Minimum commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("minimum", core, parent)
+		self._cmd_group = CommandsGroup("minimum", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
+			- Reliability: int: 'Reliability indicator'
 			- Margin_Min_Neg_X: List[float]: No parameter help available
 			- Margin_Min_Neg_Y: List[float]: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct('Margin_Min_Neg_X', DataType.FloatList, None, False, True, 1),
 			ArgStruct('Margin_Min_Neg_Y', DataType.FloatList, None, False, True, 1)]
 
@@ -31,16 +31,16 @@
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Margin_Min_Neg_X: List[float] = None
 			self.Margin_Min_Neg_Y: List[float] = None
 
 	def fetch(self, area=repcap.Area.Default) -> FetchStruct:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEMask:MARGin:AREA<nr>:NEGativ:MINimum \n
-		Snippet: value: FetchStruct = driver.multiEval.listPy.seMask.margin.area.negativ.minimum.fetch(area = repcap.Area.Default) \n
+		Snippet: value: FetchStruct = driver.lteMeas.multiEval.listPy.seMask.margin.area.negativ.minimum.fetch(area = repcap.Area.Default) \n
 		Return spectrum emission mask margin positions for all measured list mode segments. The individual commands provide
 		results for the CURRent, AVERage and maximum traces (resulting in MINimum margins) for NEGative and POSitive offset
 		frequencies. The results are returned as pairs per segment: <Reliability>, {<MarginPosX>, <MarginPosY>}Seg 1,
 		{<MarginPosX>, <MarginPosY>}Seg 2, ... \n
 			:param area: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Area')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		area_cmd_val = self._base.get_repcap_cmd_value(area, repcap.Area)
+		area_cmd_val = self._cmd_group.get_repcap_cmd_value(area, repcap.Area)
 		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEMask:MARGin:AREA{area_cmd_val}:NEGativ:MINimum?', self.__class__.FetchStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/SeMask_/Margin_/Area_/Positiv.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/SeMask/Margin/Average/__init__.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,43 +1,35 @@
 from .......Internal.Core import Core
 from .......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Positiv:
-	"""Positiv commands group definition. 3 total commands, 3 Sub-groups, 0 group commands"""
+class AverageCls:
+	"""Average commands group definition. 2 total commands, 2 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("positiv", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	@property
-	def current(self):
-		"""current commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_current'):
-			from .Positiv_.Current import Current
-			self._current = Current(self._core, self._base)
-		return self._current
+	def negativ(self):
+		"""negativ commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_negativ'):
+			from .Negativ import NegativCls
+			self._negativ = NegativCls(self._core, self._cmd_group)
+		return self._negativ
 
 	@property
-	def average(self):
-		"""average commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_average'):
-			from .Positiv_.Average import Average
-			self._average = Average(self._core, self._base)
-		return self._average
+	def positiv(self):
+		"""positiv commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_positiv'):
+			from .Positiv import PositivCls
+			self._positiv = PositivCls(self._core, self._cmd_group)
+		return self._positiv
 
-	@property
-	def minimum(self):
-		"""minimum commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_minimum'):
-			from .Positiv_.Minimum import Minimum
-			self._minimum = Minimum(self._core, self._base)
-		return self._minimum
-
-	def clone(self) -> 'Positiv':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'AverageCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Positiv(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = AverageCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/SeMask_/Margin_/Area_/Positiv_/Average.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/SeMask/Margin/Area/Positiv/Minimum.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,46 +1,46 @@
 from typing import List
 
-from ........Internal.Core import Core
-from ........Internal.CommandsGroup import CommandsGroup
-from ........Internal.Types import DataType
-from ........Internal.StructBase import StructBase
-from ........Internal.ArgStruct import ArgStruct
-from ........ import repcap
+from .........Internal.Core import Core
+from .........Internal.CommandsGroup import CommandsGroup
+from .........Internal.Types import DataType
+from .........Internal.StructBase import StructBase
+from .........Internal.ArgStruct import ArgStruct
+from ......... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class MinimumCls:
+	"""Minimum commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("minimum", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Margin_Avg_Pos_X: List[float]: X-position of margin for selected area
-			- Margin_Avg_Pos_Y: List[float]: Y-position of margin for selected area"""
+			- Reliability: int: 'Reliability indicator'
+			- Margin_Min_Pos_X: List[float]: X-position of margin for selected area
+			- Margin_Min_Pos_Y: List[float]: Y-value of margin for selected area"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct('Margin_Avg_Pos_X', DataType.FloatList, None, False, True, 1),
-			ArgStruct('Margin_Avg_Pos_Y', DataType.FloatList, None, False, True, 1)]
+			ArgStruct('Margin_Min_Pos_X', DataType.FloatList, None, False, True, 1),
+			ArgStruct('Margin_Min_Pos_Y', DataType.FloatList, None, False, True, 1)]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
-			self.Margin_Avg_Pos_X: List[float] = None
-			self.Margin_Avg_Pos_Y: List[float] = None
+			self.Margin_Min_Pos_X: List[float] = None
+			self.Margin_Min_Pos_Y: List[float] = None
 
 	def fetch(self, area=repcap.Area.Default) -> FetchStruct:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEMask:MARGin:AREA<nr>:POSitiv:AVERage \n
-		Snippet: value: FetchStruct = driver.multiEval.listPy.seMask.margin.area.positiv.average.fetch(area = repcap.Area.Default) \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEMask:MARGin:AREA<nr>:POSitiv:MINimum \n
+		Snippet: value: FetchStruct = driver.lteMeas.multiEval.listPy.seMask.margin.area.positiv.minimum.fetch(area = repcap.Area.Default) \n
 		Return spectrum emission mask margin positions for all measured list mode segments. The individual commands provide
 		results for the CURRent, AVERage and maximum traces (resulting in MINimum margins) for NEGative and POSitive offset
 		frequencies. The results are returned as pairs per segment: <Reliability>, {<MarginPosX>, <MarginPosY>}Seg 1,
 		{<MarginPosX>, <MarginPosY>}Seg 2, ... \n
 			:param area: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Area')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		area_cmd_val = self._base.get_repcap_cmd_value(area, repcap.Area)
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEMask:MARGin:AREA{area_cmd_val}:POSitiv:AVERage?', self.__class__.FetchStruct())
+		area_cmd_val = self._cmd_group.get_repcap_cmd_value(area, repcap.Area)
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEMask:MARGin:AREA{area_cmd_val}:POSitiv:MINimum?', self.__class__.FetchStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/SeMask_/Margin_/Area_/Positiv_/Current.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/SeMask/Margin/Area/Positiv/Current.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,46 +1,46 @@
 from typing import List
 
-from ........Internal.Core import Core
-from ........Internal.CommandsGroup import CommandsGroup
-from ........Internal.Types import DataType
-from ........Internal.StructBase import StructBase
-from ........Internal.ArgStruct import ArgStruct
-from ........ import repcap
+from .........Internal.Core import Core
+from .........Internal.CommandsGroup import CommandsGroup
+from .........Internal.Types import DataType
+from .........Internal.StructBase import StructBase
+from .........Internal.ArgStruct import ArgStruct
+from ......... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
+			- Reliability: int: 'Reliability indicator'
 			- Margin_Curr_Pos_X: List[float]: X-position of margin for selected area
-			- Margin_Curr_Pos_Y: List[float]: Y-position of margin for selected area"""
+			- Margin_Curr_Pos_Y: List[float]: Y-value of margin for selected area"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct('Margin_Curr_Pos_X', DataType.FloatList, None, False, True, 1),
 			ArgStruct('Margin_Curr_Pos_Y', DataType.FloatList, None, False, True, 1)]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Margin_Curr_Pos_X: List[float] = None
 			self.Margin_Curr_Pos_Y: List[float] = None
 
 	def fetch(self, area=repcap.Area.Default) -> FetchStruct:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEMask:MARGin:AREA<nr>:POSitiv:CURRent \n
-		Snippet: value: FetchStruct = driver.multiEval.listPy.seMask.margin.area.positiv.current.fetch(area = repcap.Area.Default) \n
+		Snippet: value: FetchStruct = driver.lteMeas.multiEval.listPy.seMask.margin.area.positiv.current.fetch(area = repcap.Area.Default) \n
 		Return spectrum emission mask margin positions for all measured list mode segments. The individual commands provide
 		results for the CURRent, AVERage and maximum traces (resulting in MINimum margins) for NEGative and POSitive offset
 		frequencies. The results are returned as pairs per segment: <Reliability>, {<MarginPosX>, <MarginPosY>}Seg 1,
 		{<MarginPosX>, <MarginPosY>}Seg 2, ... \n
 			:param area: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Area')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		area_cmd_val = self._base.get_repcap_cmd_value(area, repcap.Area)
+		area_cmd_val = self._cmd_group.get_repcap_cmd_value(area, repcap.Area)
 		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEMask:MARGin:AREA{area_cmd_val}:POSitiv:CURRent?', self.__class__.FetchStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/SeMask_/Margin_/Area_/Positiv_/Minimum.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/SeMask/Margin/Current/Positiv.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,46 +1,47 @@
 from typing import List
 
-from ........Internal.Core import Core
-from ........Internal.CommandsGroup import CommandsGroup
-from ........Internal.Types import DataType
-from ........Internal.StructBase import StructBase
-from ........Internal.ArgStruct import ArgStruct
-from ........ import repcap
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal.Types import DataType
+from .......Internal.StructBase import StructBase
+from .......Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Minimum:
-	"""Minimum commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class PositivCls:
+	"""Positiv commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("minimum", core, parent)
+		self._cmd_group = CommandsGroup("positiv", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Margin_Min_Pos_X: List[float]: X-position of margin for selected area
-			- Margin_Min_Pos_Y: List[float]: Y-position of margin for selected area"""
+			- Reliability: int: 'Reliability indicator'
+			- Out_Of_Tolerance: int: Out of tolerance result, i.e. the percentage of measurement intervals of the statistic count for spectrum emission measurements exceeding the specified spectrum emission mask limits.
+			- Margin_Curr_Pos_X: List[float]: No parameter help available
+			- Margin_Curr_Pos_Y: List[float]: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct('Margin_Min_Pos_X', DataType.FloatList, None, False, True, 1),
-			ArgStruct('Margin_Min_Pos_Y', DataType.FloatList, None, False, True, 1)]
+			ArgStruct.scalar_int('Out_Of_Tolerance'),
+			ArgStruct('Margin_Curr_Pos_X', DataType.FloatList, None, False, True, 1),
+			ArgStruct('Margin_Curr_Pos_Y', DataType.FloatList, None, False, True, 1)]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
-			self.Margin_Min_Pos_X: List[float] = None
-			self.Margin_Min_Pos_Y: List[float] = None
-
-	def fetch(self, area=repcap.Area.Default) -> FetchStruct:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEMask:MARGin:AREA<nr>:POSitiv:MINimum \n
-		Snippet: value: FetchStruct = driver.multiEval.listPy.seMask.margin.area.positiv.minimum.fetch(area = repcap.Area.Default) \n
-		Return spectrum emission mask margin positions for all measured list mode segments. The individual commands provide
-		results for the CURRent, AVERage and maximum traces (resulting in MINimum margins) for NEGative and POSitive offset
-		frequencies. The results are returned as pairs per segment: <Reliability>, {<MarginPosX>, <MarginPosY>}Seg 1,
-		{<MarginPosX>, <MarginPosY>}Seg 2, ... \n
-			:param area: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Area')
+			self.Out_Of_Tolerance: int = None
+			self.Margin_Curr_Pos_X: List[float] = None
+			self.Margin_Curr_Pos_Y: List[float] = None
+
+	def fetch(self) -> FetchStruct:
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:SEMask:MARGin:CURRent:POSitiv \n
+		Snippet: value: FetchStruct = driver.lteMeas.multiEval.seMask.margin.current.positiv.fetch() \n
+		Returns spectrum emission mask margin results. A negative margin indicates that the trace is located above the limit line,
+		i.e. the limit is exceeded. The individual commands provide results for the CURRent, AVERage and maximum traces
+		(resulting in MINimum margins) . For each trace, the x- and y-values of the margins for emission mask areas 1 to 12 are
+		provided for NEGative and POSitive offset frequencies. For inactive areas, NCAP is returned.
+		Returned sequence: <Reliability>, <OutOfTolerance>, {<MarginX>, <MarginY>}area1, {...}area2, ..., {...}area12 \n
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		area_cmd_val = self._base.get_repcap_cmd_value(area, repcap.Area)
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEMask:MARGin:AREA{area_cmd_val}:POSitiv:MINimum?', self.__class__.FetchStruct())
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:SEMask:MARGin:CURRent:POSitiv?', self.__class__.FetchStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/SeMask_/Obw.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Evm/Rms/Low/__init__.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,51 +1,51 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
+from .........Internal.Core import Core
+from .........Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Obw:
-	"""Obw commands group definition. 7 total commands, 4 Sub-groups, 0 group commands"""
+class LowCls:
+	"""Low commands group definition. 7 total commands, 4 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("obw", core, parent)
+		self._cmd_group = CommandsGroup("low", core, parent)
 
 	@property
 	def current(self):
 		"""current commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_current'):
-			from .Obw_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
 	@property
 	def average(self):
 		"""average commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_average'):
-			from .Obw_.Average import Average
-			self._average = Average(self._core, self._base)
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
 		return self._average
 
 	@property
 	def extreme(self):
 		"""extreme commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_extreme'):
-			from .Obw_.Extreme import Extreme
-			self._extreme = Extreme(self._core, self._base)
+			from .Extreme import ExtremeCls
+			self._extreme = ExtremeCls(self._core, self._cmd_group)
 		return self._extreme
 
 	@property
 	def standardDev(self):
 		"""standardDev commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_standardDev'):
-			from .Obw_.StandardDev import StandardDev
-			self._standardDev = StandardDev(self._core, self._base)
+			from .StandardDev import StandardDevCls
+			self._standardDev = StandardDevCls(self._core, self._cmd_group)
 		return self._standardDev
 
-	def clone(self) -> 'Obw':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'LowCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Obw(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = LowCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/SeMask_/Obw_/Average.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Aclr/Eutra/Average.py`

 * *Files 11% similar despite different names*

```diff
@@ -1,37 +1,40 @@
 from typing import List
 
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ......Internal.Types import DataType
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal import Conversions
+from .......Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .......Internal.Types import DataType
+from ....... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class AverageCls:
+	"""Average commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEMask:OBW:AVERage \n
-		Snippet: value: List[float] = driver.multiEval.listPy.seMask.obw.average.fetch() \n
-		Return the occupied bandwidth for all measured list mode segments. The values described below are returned by FETCh
-		commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:ACLR:EUTRa:AVERage \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.listPy.aclr.eutra.average.fetch() \n
+		Return the power in the allocated E-UTRA channel for all measured list mode segments. The values described below are
+		returned by FETCh commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 		Suppressed linked return values: reliability \n
-			:return: obw: Comma-separated list of values, one per measured segment"""
+			:return: eutra: Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEMask:OBW:AVERage?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:ACLR:EUTRa:AVERage?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEMask:OBW:AVERage \n
-		Snippet: value: List[float] = driver.multiEval.listPy.seMask.obw.average.calculate() \n
-		Return the occupied bandwidth for all measured list mode segments. The values described below are returned by FETCh
-		commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
+	# noinspection PyTypeChecker
+	def calculate(self) -> List[enums.ResultStatus2]:
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:ACLR:EUTRa:AVERage \n
+		Snippet: value: List[enums.ResultStatus2] = driver.lteMeas.multiEval.listPy.aclr.eutra.average.calculate() \n
+		Return the power in the allocated E-UTRA channel for all measured list mode segments. The values described below are
+		returned by FETCh commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 		Suppressed linked return values: reliability \n
-			:return: obw: Comma-separated list of values, one per measured segment"""
+			:return: eutra: Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEMask:OBW:AVERage?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:ACLR:EUTRa:AVERage?', suppressed)
+		return Conversions.str_to_list_enum(response, enums.ResultStatus2)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/SeMask_/Obw_/Current.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/SeMask/Obw/Current.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,37 +1,38 @@
 from typing import List
 
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ......Internal.Types import DataType
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal import Conversions
+from .......Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .......Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	def fetch(self) -> List[float]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEMask:OBW:CURRent \n
-		Snippet: value: List[float] = driver.multiEval.listPy.seMask.obw.current.fetch() \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.listPy.seMask.obw.current.fetch() \n
 		Return the occupied bandwidth for all measured list mode segments. The values described below are returned by FETCh
 		commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 		Suppressed linked return values: reliability \n
 			:return: obw: Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEMask:OBW:CURRent?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
+	def calculate(self) -> List[float or bool]:
 		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEMask:OBW:CURRent \n
-		Snippet: value: List[float] = driver.multiEval.listPy.seMask.obw.current.calculate() \n
+		Snippet: value: List[float or bool] = driver.lteMeas.multiEval.listPy.seMask.obw.current.calculate() \n
 		Return the occupied bandwidth for all measured list mode segments. The values described below are returned by FETCh
 		commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 		Suppressed linked return values: reliability \n
-			:return: obw: Comma-separated list of values, one per measured segment"""
+			:return: obw: (float or boolean items) Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEMask:OBW:CURRent?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEMask:OBW:CURRent?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/SeMask_/Obw_/Extreme.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Perror/Rms/High/Current.py`

 * *Files 11% similar despite different names*

```diff
@@ -1,37 +1,40 @@
 from typing import List
 
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ......Internal.Types import DataType
+from .........Internal.Core import Core
+from .........Internal.CommandsGroup import CommandsGroup
+from .........Internal import Conversions
+from .........Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .........Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Extreme:
-	"""Extreme commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("extreme", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEMask:OBW:EXTReme \n
-		Snippet: value: List[float] = driver.multiEval.listPy.seMask.obw.extreme.fetch() \n
-		Return the occupied bandwidth for all measured list mode segments. The values described below are returned by FETCh
-		commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:RMS:HIGH:CURRent \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.listPy.modulation.perror.rms.high.current.fetch() \n
+		Return phase error RMS values for low and high EVM window position, for all measured list mode segments.
+		The values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one
+		value for each result listed below. \n
 		Suppressed linked return values: reliability \n
-			:return: obw: Comma-separated list of values, one per measured segment"""
+			:return: ph_error_rms_high: Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEMask:OBW:EXTReme?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:RMS:HIGH:CURRent?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEMask:OBW:EXTReme \n
-		Snippet: value: List[float] = driver.multiEval.listPy.seMask.obw.extreme.calculate() \n
-		Return the occupied bandwidth for all measured list mode segments. The values described below are returned by FETCh
-		commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
+	def calculate(self) -> List[float or bool]:
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:RMS:HIGH:CURRent \n
+		Snippet: value: List[float or bool] = driver.lteMeas.multiEval.listPy.modulation.perror.rms.high.current.calculate() \n
+		Return phase error RMS values for low and high EVM window position, for all measured list mode segments.
+		The values described below are returned by FETCh commands. CALCulate commands return limit check results instead, one
+		value for each result listed below. \n
 		Suppressed linked return values: reliability \n
-			:return: obw: Comma-separated list of values, one per measured segment"""
+			:return: ph_error_rms_high: (float or boolean items) Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEMask:OBW:EXTReme?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PERRor:RMS:HIGH:CURRent?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/SeMask_/Obw_/StandardDev.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/SeMask/Obw/StandardDev.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,26 +1,26 @@
 from typing import List
 
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ......Internal.Types import DataType
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .......Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class StandardDev:
-	"""StandardDev commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class StandardDevCls:
+	"""StandardDev commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("standardDev", core, parent)
+		self._cmd_group = CommandsGroup("standardDev", core, parent)
 
 	def fetch(self) -> List[float]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEMask:OBW:SDEViation \n
-		Snippet: value: List[float] = driver.multiEval.listPy.seMask.obw.standardDev.fetch() \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.listPy.seMask.obw.standardDev.fetch() \n
 		Return the occupied bandwidth for all measured list mode segments. The values described below are returned by FETCh
 		commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 		Suppressed linked return values: reliability \n
 			:return: obw: Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEMask:OBW:SDEViation?', suppressed)
 		return response
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/SeMask_/TxPower.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/Prach/Trace/Pdynamics/__init__.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,59 +1,43 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class TxPower:
-	"""TxPower commands group definition. 9 total commands, 5 Sub-groups, 0 group commands"""
+class PdynamicsCls:
+	"""Pdynamics commands group definition. 6 total commands, 3 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("txPower", core, parent)
+		self._cmd_group = CommandsGroup("pdynamics", core, parent)
 
 	@property
 	def current(self):
 		"""current commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_current'):
-			from .TxPower_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
 	@property
 	def average(self):
 		"""average commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_average'):
-			from .TxPower_.Average import Average
-			self._average = Average(self._core, self._base)
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
 		return self._average
 
 	@property
-	def minimum(self):
-		"""minimum commands group. 0 Sub-classes, 2 commands."""
-		if not hasattr(self, '_minimum'):
-			from .TxPower_.Minimum import Minimum
-			self._minimum = Minimum(self._core, self._base)
-		return self._minimum
-
-	@property
 	def maximum(self):
 		"""maximum commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_maximum'):
-			from .TxPower_.Maximum import Maximum
-			self._maximum = Maximum(self._core, self._base)
+			from .Maximum import MaximumCls
+			self._maximum = MaximumCls(self._core, self._cmd_group)
 		return self._maximum
 
-	@property
-	def standardDev(self):
-		"""standardDev commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_standardDev'):
-			from .TxPower_.StandardDev import StandardDev
-			self._standardDev = StandardDev(self._core, self._base)
-		return self._standardDev
-
-	def clone(self) -> 'TxPower':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'PdynamicsCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = TxPower(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = PdynamicsCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/SeMask_/TxPower_/Average.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Psd/Current.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,37 +1,38 @@
 from typing import List
 
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ......Internal.Types import DataType
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal import Conversions
+from .......Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .......Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEMask:TXPower:AVERage \n
-		Snippet: value: List[float] = driver.multiEval.listPy.seMask.txPower.average.fetch() \n
-		Return the total TX power in the slot for all measured list mode segments. The values described below are returned by
-		FETCh commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PSD:CURRent \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.listPy.modulation.psd.current.fetch() \n
+		Return RB power values for all measured list mode segments. The values described below are returned by FETCh commands.
+		CALCulate commands return limit check results instead, one value for each result listed below. \n
 		Suppressed linked return values: reliability \n
-			:return: tx_power: Comma-separated list of values, one per measured segment"""
+			:return: psd: Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEMask:TXPower:AVERage?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PSD:CURRent?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEMask:TXPower:AVERage \n
-		Snippet: value: List[float] = driver.multiEval.listPy.seMask.txPower.average.calculate() \n
-		Return the total TX power in the slot for all measured list mode segments. The values described below are returned by
-		FETCh commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
+	def calculate(self) -> List[float or bool]:
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PSD:CURRent \n
+		Snippet: value: List[float or bool] = driver.lteMeas.multiEval.listPy.modulation.psd.current.calculate() \n
+		Return RB power values for all measured list mode segments. The values described below are returned by FETCh commands.
+		CALCulate commands return limit check results instead, one value for each result listed below. \n
 		Suppressed linked return values: reliability \n
-			:return: tx_power: Comma-separated list of values, one per measured segment"""
+			:return: psd: (float or boolean items) Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEMask:TXPower:AVERage?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PSD:CURRent?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/SeMask_/TxPower_/Current.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Ppower/Average.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,37 +1,38 @@
 from typing import List
 
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ......Internal.Types import DataType
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal import Conversions
+from .......Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .......Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class AverageCls:
+	"""Average commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEMask:TXPower:CURRent \n
-		Snippet: value: List[float] = driver.multiEval.listPy.seMask.txPower.current.fetch() \n
-		Return the total TX power in the slot for all measured list mode segments. The values described below are returned by
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PPOWer:AVERage \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.listPy.modulation.ppower.average.fetch() \n
+		Return user equipment peak power values for all measured list mode segments. The values described below are returned by
 		FETCh commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 		Suppressed linked return values: reliability \n
-			:return: tx_power: Comma-separated list of values, one per measured segment"""
+			:return: peak_power: Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEMask:TXPower:CURRent?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PPOWer:AVERage?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEMask:TXPower:CURRent \n
-		Snippet: value: List[float] = driver.multiEval.listPy.seMask.txPower.current.calculate() \n
-		Return the total TX power in the slot for all measured list mode segments. The values described below are returned by
+	def calculate(self) -> List[float or bool]:
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PPOWer:AVERage \n
+		Snippet: value: List[float or bool] = driver.lteMeas.multiEval.listPy.modulation.ppower.average.calculate() \n
+		Return user equipment peak power values for all measured list mode segments. The values described below are returned by
 		FETCh commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 		Suppressed linked return values: reliability \n
-			:return: tx_power: Comma-separated list of values, one per measured segment"""
+			:return: peak_power: (float or boolean items) Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEMask:TXPower:CURRent?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:PPOWer:AVERage?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/SeMask_/TxPower_/Maximum.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Merror/Rms/High/Current.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,37 +1,40 @@
 from typing import List
 
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ......Internal.Types import DataType
+from .........Internal.Core import Core
+from .........Internal.CommandsGroup import CommandsGroup
+from .........Internal import Conversions
+from .........Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .........Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Maximum:
-	"""Maximum commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("maximum", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEMask:TXPower:MAXimum \n
-		Snippet: value: List[float] = driver.multiEval.listPy.seMask.txPower.maximum.fetch() \n
-		Return the total TX power in the slot for all measured list mode segments. The values described below are returned by
-		FETCh commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:RMS:HIGH:CURRent \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.listPy.modulation.merror.rms.high.current.fetch() \n
+		Return magnitude error RMS values for low and high EVM window position, for all measured list mode segments. The values
+		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
+		result listed below. \n
 		Suppressed linked return values: reliability \n
-			:return: tx_power: Comma-separated list of values, one per measured segment"""
+			:return: mag_error_rms_high: Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEMask:TXPower:MAXimum?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:RMS:HIGH:CURRent?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEMask:TXPower:MAXimum \n
-		Snippet: value: List[float] = driver.multiEval.listPy.seMask.txPower.maximum.calculate() \n
-		Return the total TX power in the slot for all measured list mode segments. The values described below are returned by
-		FETCh commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
+	def calculate(self) -> List[float or bool]:
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:RMS:HIGH:CURRent \n
+		Snippet: value: List[float or bool] = driver.lteMeas.multiEval.listPy.modulation.merror.rms.high.current.calculate() \n
+		Return magnitude error RMS values for low and high EVM window position, for all measured list mode segments. The values
+		described below are returned by FETCh commands. CALCulate commands return limit check results instead, one value for each
+		result listed below. \n
 		Suppressed linked return values: reliability \n
-			:return: tx_power: Comma-separated list of values, one per measured segment"""
+			:return: mag_error_rms_high: (float or boolean items) Comma-separated list of values, one per measured segment"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEMask:TXPower:MAXimum?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:MODulation:MERRor:RMS:HIGH:CURRent?', suppressed)
+		return Conversions.str_to_float_or_bool_list(response)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/SeMask_/TxPower_/Minimum.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Trace/EvmSymbol/Average.py`

 * *Files 18% similar despite different names*

```diff
@@ -3,35 +3,33 @@
 from ......Internal.Core import Core
 from ......Internal.CommandsGroup import CommandsGroup
 from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ......Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Minimum:
-	"""Minimum commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class AverageCls:
+	"""Average commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("minimum", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
-	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEMask:TXPower:MINimum \n
-		Snippet: value: List[float] = driver.multiEval.listPy.seMask.txPower.minimum.fetch() \n
-		Return the total TX power in the slot for all measured list mode segments. The values described below are returned by
-		FETCh commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
+	def read(self) -> List[float]:
+		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:TRACe:EVMSymbol:AVERage \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.trace.evmSymbol.average.read() \n
+		Returns the values of the EVM vs modulation symbol trace. See also 'Square EVM'. \n
 		Suppressed linked return values: reliability \n
-			:return: tx_power: Comma-separated list of values, one per measured segment"""
+			:return: ratio: Comma-separated list of EVM values, one value per modulation symbol"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEMask:TXPower:MINimum?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:LTE:MEASurement<Instance>:MEValuation:TRACe:EVMSymbol:AVERage?', suppressed)
 		return response
 
-	def calculate(self) -> List[float]:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEMask:TXPower:MINimum \n
-		Snippet: value: List[float] = driver.multiEval.listPy.seMask.txPower.minimum.calculate() \n
-		Return the total TX power in the slot for all measured list mode segments. The values described below are returned by
-		FETCh commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
+	def fetch(self) -> List[float]:
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:TRACe:EVMSymbol:AVERage \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.trace.evmSymbol.average.fetch() \n
+		Returns the values of the EVM vs modulation symbol trace. See also 'Square EVM'. \n
 		Suppressed linked return values: reliability \n
-			:return: tx_power: Comma-separated list of values, one per measured segment"""
+			:return: ratio: Comma-separated list of EVM values, one value per modulation symbol"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEMask:TXPower:MINimum?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:TRACe:EVMSymbol:AVERage?', suppressed)
 		return response
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/SeMask_/TxPower_/StandardDev.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Trace/Iemissions/Scc.py`

 * *Files 16% similar despite different names*

```diff
@@ -3,24 +3,33 @@
 from ......Internal.Core import Core
 from ......Internal.CommandsGroup import CommandsGroup
 from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ......Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class StandardDev:
-	"""StandardDev commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class SccCls:
+	"""Scc commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("standardDev", core, parent)
+		self._cmd_group = CommandsGroup("scc", core, parent)
+
+	def read(self) -> List[float]:
+		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:TRACe:IEMissions:SCC \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.trace.iemissions.scc.read() \n
+		No command help available \n
+		Suppressed linked return values: reliability \n
+			:return: power: No help available"""
+		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:LTE:MEASurement<Instance>:MEValuation:TRACe:IEMissions:SCC?', suppressed)
+		return response
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEMask:TXPower:SDEViation \n
-		Snippet: value: List[float] = driver.multiEval.listPy.seMask.txPower.standardDev.fetch() \n
-		Return the total TX power in the slot for all measured list mode segments. The values described below are returned by
-		FETCh commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:TRACe:IEMissions:SCC \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.trace.iemissions.scc.fetch() \n
+		No command help available \n
 		Suppressed linked return values: reliability \n
-			:return: tx_power: Comma-separated list of values, one per measured segment"""
+			:return: power: No help available"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEMask:TXPower:SDEViation?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:TRACe:IEMissions:SCC?', suppressed)
 		return response
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Pmonitor/__init__.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,90 +1,91 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
-from ....Internal.RepeatedCapability import RepeatedCapability
-from .... import repcap
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Segment:
-	"""Segment commands group definition. 83 total commands, 7 Sub-groups, 0 group commands
-	Repeated Capability: Segment, default value after init: Segment.Nr1"""
+class PmonitorCls:
+	"""Pmonitor commands group definition. 65 total commands, 9 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("segment", core, parent)
-		self._base.rep_cap = RepeatedCapability(self._base.group_name, 'repcap_segment_get', 'repcap_segment_set', repcap.Segment.Nr1)
+		self._cmd_group = CommandsGroup("pmonitor", core, parent)
 
-	def repcap_segment_set(self, enum_value: repcap.Segment) -> None:
-		"""Repeated Capability default value numeric suffix.
-		This value is used, if you do not explicitely set it in the child set/get methods, or if you leave it to Segment.Default
-		Default value after init: Segment.Nr1"""
-		self._base.set_repcap_enum_value(enum_value)
-
-	def repcap_segment_get(self) -> repcap.Segment:
-		"""Returns the current default repeated capability for the child set/get methods"""
-		# noinspection PyTypeChecker
-		return self._base.get_repcap_enum_value()
-
-	@property
-	def modulation(self):
-		"""modulation commands group. 8 Sub-classes, 0 commands."""
-		if not hasattr(self, '_modulation'):
-			from .Segment_.Modulation import Modulation
-			self._modulation = Modulation(self._core, self._base)
-		return self._modulation
-
-	@property
-	def inbandEmission(self):
-		"""inbandEmission commands group. 3 Sub-classes, 0 commands."""
-		if not hasattr(self, '_inbandEmission'):
-			from .Segment_.InbandEmission import InbandEmission
-			self._inbandEmission = InbandEmission(self._core, self._base)
-		return self._inbandEmission
-
-	@property
-	def esFlatness(self):
-		"""esFlatness commands group. 4 Sub-classes, 0 commands."""
-		if not hasattr(self, '_esFlatness'):
-			from .Segment_.EsFlatness import EsFlatness
-			self._esFlatness = EsFlatness(self._core, self._base)
-		return self._esFlatness
-
-	@property
-	def seMask(self):
-		"""seMask commands group. 8 Sub-classes, 0 commands."""
-		if not hasattr(self, '_seMask'):
-			from .Segment_.SeMask import SeMask
-			self._seMask = SeMask(self._core, self._base)
-		return self._seMask
-
-	@property
-	def aclr(self):
-		"""aclr commands group. 5 Sub-classes, 0 commands."""
-		if not hasattr(self, '_aclr'):
-			from .Segment_.Aclr import Aclr
-			self._aclr = Aclr(self._core, self._base)
-		return self._aclr
-
-	@property
-	def power(self):
-		"""power commands group. 5 Sub-classes, 0 commands."""
-		if not hasattr(self, '_power'):
-			from .Segment_.Power import Power
-			self._power = Power(self._core, self._base)
-		return self._power
-
-	@property
-	def pmonitor(self):
-		"""pmonitor commands group. 3 Sub-classes, 0 commands."""
-		if not hasattr(self, '_pmonitor'):
-			from .Segment_.Pmonitor import Pmonitor
-			self._pmonitor = Pmonitor(self._core, self._base)
-		return self._pmonitor
+	@property
+	def cc(self):
+		"""cc commands group. 5 Sub-classes, 0 commands."""
+		if not hasattr(self, '_cc'):
+			from .Cc import CcCls
+			self._cc = CcCls(self._core, self._cmd_group)
+		return self._cc
+
+	@property
+	def scc(self):
+		"""scc commands group. 5 Sub-classes, 0 commands."""
+		if not hasattr(self, '_scc'):
+			from .Scc import SccCls
+			self._scc = SccCls(self._core, self._cmd_group)
+		return self._scc
+
+	@property
+	def ulca(self):
+		"""ulca commands group. 2 Sub-classes, 0 commands."""
+		if not hasattr(self, '_ulca'):
+			from .Ulca import UlcaCls
+			self._ulca = UlcaCls(self._core, self._cmd_group)
+		return self._ulca
+
+	@property
+	def pcc(self):
+		"""pcc commands group. 5 Sub-classes, 0 commands."""
+		if not hasattr(self, '_pcc'):
+			from .Pcc import PccCls
+			self._pcc = PccCls(self._core, self._cmd_group)
+		return self._pcc
+
+	@property
+	def current(self):
+		"""current commands group. 0 Sub-classes, 3 commands."""
+		if not hasattr(self, '_current'):
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
+		return self._current
+
+	@property
+	def average(self):
+		"""average commands group. 0 Sub-classes, 3 commands."""
+		if not hasattr(self, '_average'):
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
+		return self._average
+
+	@property
+	def maximum(self):
+		"""maximum commands group. 0 Sub-classes, 3 commands."""
+		if not hasattr(self, '_maximum'):
+			from .Maximum import MaximumCls
+			self._maximum = MaximumCls(self._core, self._cmd_group)
+		return self._maximum
+
+	@property
+	def minimum(self):
+		"""minimum commands group. 0 Sub-classes, 3 commands."""
+		if not hasattr(self, '_minimum'):
+			from .Minimum import MinimumCls
+			self._minimum = MinimumCls(self._core, self._cmd_group)
+		return self._minimum
+
+	@property
+	def standardDev(self):
+		"""standardDev commands group. 0 Sub-classes, 3 commands."""
+		if not hasattr(self, '_standardDev'):
+			from .StandardDev import StandardDevCls
+			self._standardDev = StandardDevCls(self._core, self._cmd_group)
+		return self._standardDev
 
-	def clone(self) -> 'Segment':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'PmonitorCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Segment(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = PmonitorCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/Aclr.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/Aclr/__init__.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,59 +1,59 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Aclr:
-	"""Aclr commands group definition. 7 total commands, 5 Sub-groups, 0 group commands"""
+class AclrCls:
+	"""Aclr commands group definition. 7 total commands, 5 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("aclr", core, parent)
+		self._cmd_group = CommandsGroup("aclr", core, parent)
 
 	@property
 	def current(self):
 		"""current commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_current'):
-			from .Aclr_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
 	@property
 	def average(self):
 		"""average commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_average'):
-			from .Aclr_.Average import Average
-			self._average = Average(self._core, self._base)
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
 		return self._average
 
 	@property
 	def dmodulation(self):
 		"""dmodulation commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_dmodulation'):
-			from .Aclr_.Dmodulation import Dmodulation
-			self._dmodulation = Dmodulation(self._core, self._base)
+			from .Dmodulation import DmodulationCls
+			self._dmodulation = DmodulationCls(self._core, self._cmd_group)
 		return self._dmodulation
 
 	@property
 	def dchType(self):
 		"""dchType commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_dchType'):
-			from .Aclr_.DchType import DchType
-			self._dchType = DchType(self._core, self._base)
+			from .DchType import DchTypeCls
+			self._dchType = DchTypeCls(self._core, self._cmd_group)
 		return self._dchType
 
 	@property
 	def dallocation(self):
 		"""dallocation commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_dallocation'):
-			from .Aclr_.Dallocation import Dallocation
-			self._dallocation = Dallocation(self._core, self._base)
+			from .Dallocation import DallocationCls
+			self._dallocation = DallocationCls(self._core, self._cmd_group)
 		return self._dallocation
 
-	def clone(self) -> 'Aclr':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'AclrCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Aclr(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = AclrCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/Aclr_/Average.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/Aclr/Average.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,27 +1,27 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.StructBase import StructBase
-from ......Internal.ArgStruct import ArgStruct
-from ...... import enums
-from ...... import repcap
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal.StructBase import StructBase
+from .......Internal.ArgStruct import ArgStruct
+from ....... import enums
+from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class AverageCls:
+	"""Average commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
+			- Reliability: int: 'Reliability indicator'
 			- Seg_Reliability: int: Reliability indicator for the segment
 			- Statist_Expired: int: Reached statistical length in slots
 			- Out_Of_Tolerance: int: Percentage of measured subframes with failed limit check
 			- Utra_2_Neg: float: ACLR for the second UTRA channel with lower frequency
 			- Utra_1_Neg: float: ACLR for the first UTRA channel with lower frequency
 			- Eutra_Negativ: float: ACLR for the first E-UTRA channel below the carrier frequency
 			- Eutra: float: Power in the allocated E-UTRA channel
@@ -53,27 +53,27 @@
 			self.Eutra: float = None
 			self.Eutra_Positiv: float = None
 			self.Utra_1_Pos: float = None
 			self.Utra_2_Pos: float = None
 
 	def fetch(self, segment=repcap.Segment.Default) -> FetchStruct:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:ACLR:AVERage \n
-		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.aclr.average.fetch(segment = repcap.Segment.Default) \n
+		Snippet: value: FetchStruct = driver.lteMeas.multiEval.listPy.segment.aclr.average.fetch(segment = repcap.Segment.Default) \n
 		Return ACLR single value results for segment <no> in list mode. The values described below are returned by FETCh commands.
-		The first four values (reliability to out-of-tolerance result) are also returned by CALCulate commands. The remaining
+		The first four values (reliability to out of tolerance result) are also returned by CALCulate commands. The remaining
 		values returned by CALCulate commands are limit check results, one value for each result listed below. \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:ACLR:AVERage?', self.__class__.FetchStruct())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
+			- Reliability: int: 'Reliability indicator'
 			- Seg_Reliability: int: Reliability indicator for the segment
 			- Statist_Expired: int: Reached statistical length in slots
 			- Out_Of_Tolerance: int: Percentage of measured subframes with failed limit check
 			- Utra_2_Neg: enums.ResultStatus2: ACLR for the second UTRA channel with lower frequency
 			- Utra_1_Neg: enums.ResultStatus2: ACLR for the first UTRA channel with lower frequency
 			- Eutra_Negativ: enums.ResultStatus2: ACLR for the first E-UTRA channel below the carrier frequency
 			- Eutra: enums.ResultStatus2: Power in the allocated E-UTRA channel
@@ -105,15 +105,15 @@
 			self.Eutra: enums.ResultStatus2 = None
 			self.Eutra_Positiv: enums.ResultStatus2 = None
 			self.Utra_1_Pos: enums.ResultStatus2 = None
 			self.Utra_2_Pos: enums.ResultStatus2 = None
 
 	def calculate(self, segment=repcap.Segment.Default) -> CalculateStruct:
 		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:ACLR:AVERage \n
-		Snippet: value: CalculateStruct = driver.multiEval.listPy.segment.aclr.average.calculate(segment = repcap.Segment.Default) \n
+		Snippet: value: CalculateStruct = driver.lteMeas.multiEval.listPy.segment.aclr.average.calculate(segment = repcap.Segment.Default) \n
 		Return ACLR single value results for segment <no> in list mode. The values described below are returned by FETCh commands.
-		The first four values (reliability to out-of-tolerance result) are also returned by CALCulate commands. The remaining
+		The first four values (reliability to out of tolerance result) are also returned by CALCulate commands. The remaining
 		values returned by CALCulate commands are limit check results, one value for each result listed below. \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:ACLR:AVERage?', self.__class__.CalculateStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/Aclr_/Current.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/Aclr/Current.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,27 +1,27 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.StructBase import StructBase
-from ......Internal.ArgStruct import ArgStruct
-from ...... import enums
-from ...... import repcap
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal.StructBase import StructBase
+from .......Internal.ArgStruct import ArgStruct
+from ....... import enums
+from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
+			- Reliability: int: 'Reliability indicator'
 			- Seg_Reliability: int: Reliability indicator for the segment
 			- Statist_Expired: int: Reached statistical length in slots
 			- Out_Of_Tolerance: int: Percentage of measured subframes with failed limit check
 			- Utra_2_Neg: float: ACLR for the second UTRA channel with lower frequency
 			- Utra_1_Neg: float: ACLR for the first UTRA channel with lower frequency
 			- Eutra_Negativ: float: ACLR for the first E-UTRA channel below the carrier frequency
 			- Eutra: float: Power in the allocated E-UTRA channel
@@ -53,27 +53,27 @@
 			self.Eutra: float = None
 			self.Eutra_Positiv: float = None
 			self.Utra_1_Pos: float = None
 			self.Utra_2_Pos: float = None
 
 	def fetch(self, segment=repcap.Segment.Default) -> FetchStruct:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:ACLR:CURRent \n
-		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.aclr.current.fetch(segment = repcap.Segment.Default) \n
+		Snippet: value: FetchStruct = driver.lteMeas.multiEval.listPy.segment.aclr.current.fetch(segment = repcap.Segment.Default) \n
 		Return ACLR single value results for segment <no> in list mode. The values described below are returned by FETCh commands.
-		The first four values (reliability to out-of-tolerance result) are also returned by CALCulate commands. The remaining
+		The first four values (reliability to out of tolerance result) are also returned by CALCulate commands. The remaining
 		values returned by CALCulate commands are limit check results, one value for each result listed below. \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:ACLR:CURRent?', self.__class__.FetchStruct())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
+			- Reliability: int: 'Reliability indicator'
 			- Seg_Reliability: int: Reliability indicator for the segment
 			- Statist_Expired: int: Reached statistical length in slots
 			- Out_Of_Tolerance: int: Percentage of measured subframes with failed limit check
 			- Utra_2_Neg: enums.ResultStatus2: ACLR for the second UTRA channel with lower frequency
 			- Utra_1_Neg: enums.ResultStatus2: ACLR for the first UTRA channel with lower frequency
 			- Eutra_Negativ: enums.ResultStatus2: ACLR for the first E-UTRA channel below the carrier frequency
 			- Eutra: enums.ResultStatus2: Power in the allocated E-UTRA channel
@@ -105,15 +105,15 @@
 			self.Eutra: enums.ResultStatus2 = None
 			self.Eutra_Positiv: enums.ResultStatus2 = None
 			self.Utra_1_Pos: enums.ResultStatus2 = None
 			self.Utra_2_Pos: enums.ResultStatus2 = None
 
 	def calculate(self, segment=repcap.Segment.Default) -> CalculateStruct:
 		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:ACLR:CURRent \n
-		Snippet: value: CalculateStruct = driver.multiEval.listPy.segment.aclr.current.calculate(segment = repcap.Segment.Default) \n
+		Snippet: value: CalculateStruct = driver.lteMeas.multiEval.listPy.segment.aclr.current.calculate(segment = repcap.Segment.Default) \n
 		Return ACLR single value results for segment <no> in list mode. The values described below are returned by FETCh commands.
-		The first four values (reliability to out-of-tolerance result) are also returned by CALCulate commands. The remaining
+		The first four values (reliability to out of tolerance result) are also returned by CALCulate commands. The remaining
 		values returned by CALCulate commands are limit check results, one value for each result listed below. \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:ACLR:CURRent?', self.__class__.CalculateStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/Aclr_/Dallocation.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/Aclr/Dallocation.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,26 +1,26 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.StructBase import StructBase
-from ......Internal.ArgStruct import ArgStruct
-from ...... import repcap
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal.StructBase import StructBase
+from .......Internal.ArgStruct import ArgStruct
+from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Dallocation:
-	"""Dallocation commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class DallocationCls:
+	"""Dallocation commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("dallocation", core, parent)
+		self._cmd_group = CommandsGroup("dallocation", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
+			- Reliability: int: 'Reliability indicator'
 			- Seg_Reliability: int: Reliability indicator for the segment
 			- Nr_Res_Blocks: int: Number of allocated resource blocks
 			- Offset_Res_Blocks: int: Offset of the first allocated resource block from the edge of the allocated UL transmission bandwidth"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Seg_Reliability'),
 			ArgStruct.scalar_int('Nr_Res_Blocks'),
@@ -31,16 +31,15 @@
 			self.Reliability: int = None
 			self.Seg_Reliability: int = None
 			self.Nr_Res_Blocks: int = None
 			self.Offset_Res_Blocks: int = None
 
 	def fetch(self, segment=repcap.Segment.Default) -> FetchStruct:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:ACLR:DALLocation \n
-		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.aclr.dallocation.fetch(segment = repcap.Segment.Default) \n
+		Snippet: value: FetchStruct = driver.lteMeas.multiEval.listPy.segment.aclr.dallocation.fetch(segment = repcap.Segment.Default) \n
 		Return the detected allocation for segment <no> in list mode. The result is determined from the last measured slot of the
-		statistical length. The individual measurements provide identical detected allocation results when measuring the same
-		slot. However different statistical lengths can be defined for the measurements so that the measured slots and returned
-		results can differ. \n
+		statistical length. The individual measurements provide the same result when measuring the same slot. However different
+		statistical lengths can be defined for the measurements so that the measured slots and returned results can differ. \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:ACLR:DALLocation?', self.__class__.FetchStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/Aclr_/DchType.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/Modulation/DchType.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,44 +1,43 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.StructBase import StructBase
-from ......Internal.ArgStruct import ArgStruct
-from ...... import enums
-from ...... import repcap
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal.StructBase import StructBase
+from .......Internal.ArgStruct import ArgStruct
+from ....... import enums
+from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class DchType:
-	"""DchType commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class DchTypeCls:
+	"""DchType commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("dchType", core, parent)
+		self._cmd_group = CommandsGroup("dchType", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
+			- Reliability: int: 'Reliability indicator'
 			- Seg_Reliability: int: Reliability indicator for the segment
 			- Channel_Type: enums.UplinkChannelType: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Seg_Reliability'),
 			ArgStruct.scalar_enum('Channel_Type', enums.UplinkChannelType)]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Seg_Reliability: int = None
 			self.Channel_Type: enums.UplinkChannelType = None
 
 	def fetch(self, segment=repcap.Segment.Default) -> FetchStruct:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:ACLR:DCHType \n
-		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.aclr.dchType.fetch(segment = repcap.Segment.Default) \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:MODulation:DCHType \n
+		Snippet: value: FetchStruct = driver.lteMeas.multiEval.listPy.segment.modulation.dchType.fetch(segment = repcap.Segment.Default) \n
 		Return the uplink channel type for segment <no> in list mode. The result is determined from the last measured slot of the
-		statistical length. The individual measurements provide identical detected channel type results when measuring the same
-		slot. However different statistical lengths can be defined for the measurements so that the measured slots and returned
-		results can differ. \n
+		statistical length. The individual measurements provide the same result when measuring the same slot. However different
+		statistical lengths can be defined for the measurements so that the measured slots and returned results can differ. \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:ACLR:DCHType?', self.__class__.FetchStruct())
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:MODulation:DCHType?', self.__class__.FetchStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/Aclr_/Dmodulation.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/SeMask/Dmodulation.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,22 +1,22 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.StructBase import StructBase
-from ......Internal.ArgStruct import ArgStruct
-from ...... import enums
-from ...... import repcap
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal.StructBase import StructBase
+from .......Internal.ArgStruct import ArgStruct
+from ....... import enums
+from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Dmodulation:
-	"""Dmodulation commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class DmodulationCls:
+	"""Dmodulation commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("dmodulation", core, parent)
+		self._cmd_group = CommandsGroup("dmodulation", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
 			- Reliability: int: No parameter help available
 			- Seg_Reliability: int: No parameter help available
 			- Modulation: enums.Modulation: No parameter help available"""
@@ -28,14 +28,14 @@
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Seg_Reliability: int = None
 			self.Modulation: enums.Modulation = None
 
 	def fetch(self, segment=repcap.Segment.Default) -> FetchStruct:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:ACLR:DMODulation \n
-		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.aclr.dmodulation.fetch(segment = repcap.Segment.Default) \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:SEMask:DMODulation \n
+		Snippet: value: FetchStruct = driver.lteMeas.multiEval.listPy.segment.seMask.dmodulation.fetch(segment = repcap.Segment.Default) \n
 		No command help available \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:ACLR:DMODulation?', self.__class__.FetchStruct())
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:SEMask:DMODulation?', self.__class__.FetchStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/EsFlatness.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Merror/Dmrs/Low/__init__.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,51 +1,51 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
+from .........Internal.Core import Core
+from .........Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class EsFlatness:
-	"""EsFlatness commands group definition. 9 total commands, 4 Sub-groups, 0 group commands"""
+class LowCls:
+	"""Low commands group definition. 7 total commands, 4 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("esFlatness", core, parent)
+		self._cmd_group = CommandsGroup("low", core, parent)
 
 	@property
 	def current(self):
-		"""current commands group. 1 Sub-classes, 2 commands."""
+		"""current commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_current'):
-			from .EsFlatness_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
 	@property
 	def average(self):
 		"""average commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_average'):
-			from .EsFlatness_.Average import Average
-			self._average = Average(self._core, self._base)
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
 		return self._average
 
 	@property
 	def extreme(self):
 		"""extreme commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_extreme'):
-			from .EsFlatness_.Extreme import Extreme
-			self._extreme = Extreme(self._core, self._base)
+			from .Extreme import ExtremeCls
+			self._extreme = ExtremeCls(self._core, self._cmd_group)
 		return self._extreme
 
 	@property
 	def standardDev(self):
-		"""standardDev commands group. 0 Sub-classes, 2 commands."""
+		"""standardDev commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_standardDev'):
-			from .EsFlatness_.StandardDev import StandardDev
-			self._standardDev = StandardDev(self._core, self._base)
+			from .StandardDev import StandardDevCls
+			self._standardDev = StandardDevCls(self._core, self._cmd_group)
 		return self._standardDev
 
-	def clone(self) -> 'EsFlatness':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'LowCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = EsFlatness(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = LowCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/EsFlatness_/Average.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/EsFlatness/Average.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,21 +1,21 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.StructBase import StructBase
-from ......Internal.ArgStruct import ArgStruct
-from ...... import repcap
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal.StructBase import StructBase
+from .......Internal.ArgStruct import ArgStruct
+from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class AverageCls:
+	"""Average commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
 			- Seg_Reliability: int: Reliability indicator for the segment
 			- Statist_Expired: int: Reached statistical length in slots
 			- Out_Of_Tolerance: int: Percentage of measured subframes with failed limit check
@@ -52,55 +52,55 @@
 			self.Min_R_1: float = None
 			self.Max_R_1: float = None
 			self.Min_R_2: float = None
 			self.Max_R_2: float = None
 
 	def fetch(self, segment=repcap.Segment.Default) -> FetchStruct:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:ESFLatness:AVERage \n
-		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.esFlatness.average.fetch(segment = repcap.Segment.Default) \n
+		Snippet: value: FetchStruct = driver.lteMeas.multiEval.listPy.segment.esFlatness.average.fetch(segment = repcap.Segment.Default) \n
 		Return equalizer spectrum flatness single value results for segment <no> in list mode. \n
 		Suppressed linked return values: reliability \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:ESFLatness:AVERage?', self.__class__.FetchStruct())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
+			- Reliability: int: 'Reliability indicator'
 			- Seg_Reliability: int: Reliability indicator for the segment
 			- Statist_Expired: int: Reached statistical length in slots
 			- Out_Of_Tolerance: int: Percentage of measured subframes with failed limit check
-			- Ripple_1: float: Limit check result for max (range 1) - min (range 1)
-			- Ripple_2: float: Limit check result for max (range 2) - min (range 2)
-			- Max_R_1_Min_R_2: float: Limit check result for max (range 1) - min (range 2)
-			- Max_R_2_Min_R_1: float: Limit check result for max (range 2) - min (range 1)"""
+			- Ripple_1: float or bool: Limit check result for max (range 1) - min (range 1) .
+			- Ripple_2: float or bool: Limit check result for max (range 2) - min (range 2) .
+			- Max_R_1_Min_R_2: float or bool: Limit check result for max (range 1) - min (range 2) .
+			- Max_R_2_Min_R_1: float or bool: Limit check result for max (range 2) - min (range 1) ."""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Seg_Reliability'),
 			ArgStruct.scalar_int('Statist_Expired'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
-			ArgStruct.scalar_float('Ripple_1'),
-			ArgStruct.scalar_float('Ripple_2'),
-			ArgStruct.scalar_float('Max_R_1_Min_R_2'),
-			ArgStruct.scalar_float('Max_R_2_Min_R_1')]
+			ArgStruct.scalar_float_ext('Ripple_1'),
+			ArgStruct.scalar_float_ext('Ripple_2'),
+			ArgStruct.scalar_float_ext('Max_R_1_Min_R_2'),
+			ArgStruct.scalar_float_ext('Max_R_2_Min_R_1')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Seg_Reliability: int = None
 			self.Statist_Expired: int = None
 			self.Out_Of_Tolerance: int = None
-			self.Ripple_1: float = None
-			self.Ripple_2: float = None
-			self.Max_R_1_Min_R_2: float = None
-			self.Max_R_2_Min_R_1: float = None
+			self.Ripple_1: float or bool = None
+			self.Ripple_2: float or bool = None
+			self.Max_R_1_Min_R_2: float or bool = None
+			self.Max_R_2_Min_R_1: float or bool = None
 
 	def calculate(self, segment=repcap.Segment.Default) -> CalculateStruct:
 		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:ESFLatness:AVERage \n
-		Snippet: value: CalculateStruct = driver.multiEval.listPy.segment.esFlatness.average.calculate(segment = repcap.Segment.Default) \n
+		Snippet: value: CalculateStruct = driver.lteMeas.multiEval.listPy.segment.esFlatness.average.calculate(segment = repcap.Segment.Default) \n
 		Return equalizer spectrum flatness single value results for segment <no> in list mode. \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:ESFLatness:AVERage?', self.__class__.CalculateStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/EsFlatness_/Current.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/EsFlatness/Current/__init__.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,28 +1,28 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.StructBase import StructBase
-from ......Internal.ArgStruct import ArgStruct
-from ...... import repcap
+from ........Internal.Core import Core
+from ........Internal.CommandsGroup import CommandsGroup
+from ........Internal.StructBase import StructBase
+from ........Internal.ArgStruct import ArgStruct
+from ........ import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 3 total commands, 1 Sub-groups, 2 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 3 total commands, 1 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	@property
 	def scIndex(self):
 		"""scIndex commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_scIndex'):
-			from .Current_.ScIndex import ScIndex
-			self._scIndex = ScIndex(self._core, self._base)
+			from .ScIndex import ScIndexCls
+			self._scIndex = ScIndexCls(self._core, self._cmd_group)
 		return self._scIndex
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
 			- Seg_Reliability: int: Reliability indicator for the segment
 			- Statist_Expired: int: Reached statistical length in slots
@@ -60,63 +60,63 @@
 			self.Min_R_1: float = None
 			self.Max_R_1: float = None
 			self.Min_R_2: float = None
 			self.Max_R_2: float = None
 
 	def fetch(self, segment=repcap.Segment.Default) -> FetchStruct:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:ESFLatness:CURRent \n
-		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.esFlatness.current.fetch(segment = repcap.Segment.Default) \n
+		Snippet: value: FetchStruct = driver.lteMeas.multiEval.listPy.segment.esFlatness.current.fetch(segment = repcap.Segment.Default) \n
 		Return equalizer spectrum flatness single value results for segment <no> in list mode. \n
 		Suppressed linked return values: reliability \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:ESFLatness:CURRent?', self.__class__.FetchStruct())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
+			- Reliability: int: 'Reliability indicator'
 			- Seg_Reliability: int: Reliability indicator for the segment
 			- Statist_Expired: int: Reached statistical length in slots
 			- Out_Of_Tolerance: int: Percentage of measured subframes with failed limit check
-			- Ripple_1: float: Limit check result for max (range 1) - min (range 1)
-			- Ripple_2: float: Limit check result for max (range 2) - min (range 2)
-			- Max_R_1_Min_R_2: float: Limit check result for max (range 1) - min (range 2)
-			- Max_R_2_Min_R_1: float: Limit check result for max (range 2) - min (range 1)"""
+			- Ripple_1: float or bool: Limit check result for max (range 1) - min (range 1) .
+			- Ripple_2: float or bool: Limit check result for max (range 2) - min (range 2) .
+			- Max_R_1_Min_R_2: float or bool: Limit check result for max (range 1) - min (range 2) .
+			- Max_R_2_Min_R_1: float or bool: Limit check result for max (range 2) - min (range 1) ."""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Seg_Reliability'),
 			ArgStruct.scalar_int('Statist_Expired'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
-			ArgStruct.scalar_float('Ripple_1'),
-			ArgStruct.scalar_float('Ripple_2'),
-			ArgStruct.scalar_float('Max_R_1_Min_R_2'),
-			ArgStruct.scalar_float('Max_R_2_Min_R_1')]
+			ArgStruct.scalar_float_ext('Ripple_1'),
+			ArgStruct.scalar_float_ext('Ripple_2'),
+			ArgStruct.scalar_float_ext('Max_R_1_Min_R_2'),
+			ArgStruct.scalar_float_ext('Max_R_2_Min_R_1')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Seg_Reliability: int = None
 			self.Statist_Expired: int = None
 			self.Out_Of_Tolerance: int = None
-			self.Ripple_1: float = None
-			self.Ripple_2: float = None
-			self.Max_R_1_Min_R_2: float = None
-			self.Max_R_2_Min_R_1: float = None
+			self.Ripple_1: float or bool = None
+			self.Ripple_2: float or bool = None
+			self.Max_R_1_Min_R_2: float or bool = None
+			self.Max_R_2_Min_R_1: float or bool = None
 
 	def calculate(self, segment=repcap.Segment.Default) -> CalculateStruct:
 		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:ESFLatness:CURRent \n
-		Snippet: value: CalculateStruct = driver.multiEval.listPy.segment.esFlatness.current.calculate(segment = repcap.Segment.Default) \n
+		Snippet: value: CalculateStruct = driver.lteMeas.multiEval.listPy.segment.esFlatness.current.calculate(segment = repcap.Segment.Default) \n
 		Return equalizer spectrum flatness single value results for segment <no> in list mode. \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:ESFLatness:CURRent?', self.__class__.CalculateStruct())
 
-	def clone(self) -> 'Current':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'CurrentCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Current(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = CurrentCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/EsFlatness_/Current_/ScIndex.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/EsFlatness/Current/ScIndex.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,26 +1,26 @@
-from .......Internal.Core import Core
-from .......Internal.CommandsGroup import CommandsGroup
-from .......Internal.StructBase import StructBase
-from .......Internal.ArgStruct import ArgStruct
-from ....... import repcap
+from ........Internal.Core import Core
+from ........Internal.CommandsGroup import CommandsGroup
+from ........Internal.StructBase import StructBase
+from ........Internal.ArgStruct import ArgStruct
+from ........ import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class ScIndex:
-	"""ScIndex commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class ScIndexCls:
+	"""ScIndex commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("scIndex", core, parent)
+		self._cmd_group = CommandsGroup("scIndex", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
+			- Reliability: int: 'Reliability indicator'
 			- Seg_Reliability: int: Reliability indicator for the segment
 			- Statist_Expired: int: Reached statistical length in slots
 			- Out_Of_Tolerance: int: Percentage of measured subframes with failed limit check
 			- Maximum_1: int: SC index of max (range 1)
 			- Minimum_1: int: SC index of min (range 1)
 			- Maximum_2: int: SC index of max (range 2)
 			- Minimum_2: int: SC index of min (range 2)"""
@@ -43,15 +43,15 @@
 			self.Maximum_1: int = None
 			self.Minimum_1: int = None
 			self.Maximum_2: int = None
 			self.Minimum_2: int = None
 
 	def fetch(self, segment=repcap.Segment.Default) -> FetchStruct:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:ESFLatness:CURRent:SCINdex \n
-		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.esFlatness.current.scIndex.fetch(segment = repcap.Segment.Default) \n
+		Snippet: value: FetchStruct = driver.lteMeas.multiEval.listPy.segment.esFlatness.current.scIndex.fetch(segment = repcap.Segment.Default) \n
 		Return subcarrier indices of the equalizer spectrum flatness measurement for segment <no> in list mode. At these SC
 		indices, the current minimum and maximum power of the equalizer coefficients have been detected within range 1 and range
 		2. \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:ESFLatness:CURRent:SCINdex?', self.__class__.FetchStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/EsFlatness_/Extreme.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/EsFlatness/Extreme.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,21 +1,21 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.StructBase import StructBase
-from ......Internal.ArgStruct import ArgStruct
-from ...... import repcap
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal.StructBase import StructBase
+from .......Internal.ArgStruct import ArgStruct
+from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Extreme:
-	"""Extreme commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class ExtremeCls:
+	"""Extreme commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("extreme", core, parent)
+		self._cmd_group = CommandsGroup("extreme", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
 			- Seg_Reliability: int: Reliability indicator for the segment
 			- Statist_Expired: int: Reached statistical length in slots
 			- Out_Of_Tolerance: int: Percentage of measured subframes with failed limit check
@@ -52,55 +52,55 @@
 			self.Min_R_1: float = None
 			self.Max_R_1: float = None
 			self.Min_R_2: float = None
 			self.Max_R_2: float = None
 
 	def fetch(self, segment=repcap.Segment.Default) -> FetchStruct:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:ESFLatness:EXTReme \n
-		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.esFlatness.extreme.fetch(segment = repcap.Segment.Default) \n
+		Snippet: value: FetchStruct = driver.lteMeas.multiEval.listPy.segment.esFlatness.extreme.fetch(segment = repcap.Segment.Default) \n
 		Return equalizer spectrum flatness single value results for segment <no> in list mode. \n
 		Suppressed linked return values: reliability \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:ESFLatness:EXTReme?', self.__class__.FetchStruct())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
+			- Reliability: int: 'Reliability indicator'
 			- Seg_Reliability: int: Reliability indicator for the segment
 			- Statist_Expired: int: Reached statistical length in slots
 			- Out_Of_Tolerance: int: Percentage of measured subframes with failed limit check
-			- Ripple_1: float: Limit check result for max (range 1) - min (range 1)
-			- Ripple_2: float: Limit check result for max (range 2) - min (range 2)
-			- Max_R_1_Min_R_2: float: Limit check result for max (range 1) - min (range 2)
-			- Max_R_2_Min_R_1: float: Limit check result for max (range 2) - min (range 1)"""
+			- Ripple_1: float or bool: Limit check result for max (range 1) - min (range 1) .
+			- Ripple_2: float or bool: Limit check result for max (range 2) - min (range 2) .
+			- Max_R_1_Min_R_2: float or bool: Limit check result for max (range 1) - min (range 2) .
+			- Max_R_2_Min_R_1: float or bool: Limit check result for max (range 2) - min (range 1) ."""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Seg_Reliability'),
 			ArgStruct.scalar_int('Statist_Expired'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
-			ArgStruct.scalar_float('Ripple_1'),
-			ArgStruct.scalar_float('Ripple_2'),
-			ArgStruct.scalar_float('Max_R_1_Min_R_2'),
-			ArgStruct.scalar_float('Max_R_2_Min_R_1')]
+			ArgStruct.scalar_float_ext('Ripple_1'),
+			ArgStruct.scalar_float_ext('Ripple_2'),
+			ArgStruct.scalar_float_ext('Max_R_1_Min_R_2'),
+			ArgStruct.scalar_float_ext('Max_R_2_Min_R_1')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Seg_Reliability: int = None
 			self.Statist_Expired: int = None
 			self.Out_Of_Tolerance: int = None
-			self.Ripple_1: float = None
-			self.Ripple_2: float = None
-			self.Max_R_1_Min_R_2: float = None
-			self.Max_R_2_Min_R_1: float = None
+			self.Ripple_1: float or bool = None
+			self.Ripple_2: float or bool = None
+			self.Max_R_1_Min_R_2: float or bool = None
+			self.Max_R_2_Min_R_1: float or bool = None
 
 	def calculate(self, segment=repcap.Segment.Default) -> CalculateStruct:
 		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:ESFLatness:EXTReme \n
-		Snippet: value: CalculateStruct = driver.multiEval.listPy.segment.esFlatness.extreme.calculate(segment = repcap.Segment.Default) \n
+		Snippet: value: CalculateStruct = driver.lteMeas.multiEval.listPy.segment.esFlatness.extreme.calculate(segment = repcap.Segment.Default) \n
 		Return equalizer spectrum flatness single value results for segment <no> in list mode. \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:ESFLatness:EXTReme?', self.__class__.CalculateStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/EsFlatness_/StandardDev.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/EsFlatness/StandardDev.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,21 +1,21 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.StructBase import StructBase
-from ......Internal.ArgStruct import ArgStruct
-from ...... import repcap
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal.StructBase import StructBase
+from .......Internal.ArgStruct import ArgStruct
+from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class StandardDev:
-	"""StandardDev commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class StandardDevCls:
+	"""StandardDev commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("standardDev", core, parent)
+		self._cmd_group = CommandsGroup("standardDev", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
 			- Seg_Reliability: int: Reliability indicator for the segment
 			- Statist_Expired: int: Reached statistical length in slots
 			- Out_Of_Tolerance: int: Percentage of measured subframes with failed limit check
@@ -52,55 +52,55 @@
 			self.Min_R_1: float = None
 			self.Max_R_1: float = None
 			self.Min_R_2: float = None
 			self.Max_R_2: float = None
 
 	def fetch(self, segment=repcap.Segment.Default) -> FetchStruct:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:ESFLatness:SDEViation \n
-		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.esFlatness.standardDev.fetch(segment = repcap.Segment.Default) \n
+		Snippet: value: FetchStruct = driver.lteMeas.multiEval.listPy.segment.esFlatness.standardDev.fetch(segment = repcap.Segment.Default) \n
 		Return equalizer spectrum flatness single value results for segment <no> in list mode. \n
 		Suppressed linked return values: reliability \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:ESFLatness:SDEViation?', self.__class__.FetchStruct())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
 			- Reliability: int: No parameter help available
 			- Seg_Reliability: int: No parameter help available
 			- Statist_Expired: int: No parameter help available
 			- Out_Of_Tolerance: int: No parameter help available
-			- Ripple_1: float: No parameter help available
-			- Ripple_2: float: No parameter help available
-			- Max_R_1_Min_R_2: float: No parameter help available
-			- Max_R_2_Min_R_1: float: No parameter help available"""
+			- Ripple_1: float or bool: No parameter help available
+			- Ripple_2: float or bool: No parameter help available
+			- Max_R_1_Min_R_2: float or bool: No parameter help available
+			- Max_R_2_Min_R_1: float or bool: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Seg_Reliability'),
 			ArgStruct.scalar_int('Statist_Expired'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
-			ArgStruct.scalar_float('Ripple_1'),
-			ArgStruct.scalar_float('Ripple_2'),
-			ArgStruct.scalar_float('Max_R_1_Min_R_2'),
-			ArgStruct.scalar_float('Max_R_2_Min_R_1')]
+			ArgStruct.scalar_float_ext('Ripple_1'),
+			ArgStruct.scalar_float_ext('Ripple_2'),
+			ArgStruct.scalar_float_ext('Max_R_1_Min_R_2'),
+			ArgStruct.scalar_float_ext('Max_R_2_Min_R_1')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Seg_Reliability: int = None
 			self.Statist_Expired: int = None
 			self.Out_Of_Tolerance: int = None
-			self.Ripple_1: float = None
-			self.Ripple_2: float = None
-			self.Max_R_1_Min_R_2: float = None
-			self.Max_R_2_Min_R_1: float = None
+			self.Ripple_1: float or bool = None
+			self.Ripple_2: float or bool = None
+			self.Max_R_1_Min_R_2: float or bool = None
+			self.Max_R_2_Min_R_1: float or bool = None
 
 	def calculate(self, segment=repcap.Segment.Default) -> CalculateStruct:
 		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:ESFLatness:SDEViation \n
-		Snippet: value: CalculateStruct = driver.multiEval.listPy.segment.esFlatness.standardDev.calculate(segment = repcap.Segment.Default) \n
+		Snippet: value: CalculateStruct = driver.lteMeas.multiEval.listPy.segment.esFlatness.standardDev.calculate(segment = repcap.Segment.Default) \n
 		No command help available \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:ESFLatness:SDEViation?', self.__class__.CalculateStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Sense/LteMeas/MultiEval/Limit/Iemissions/Ulca/__init__.py`

 * *Files 27% similar despite different names*

```diff
@@ -1,43 +1,38 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
+from typing import List
+
+from ........Internal.Core import Core
+from ........Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class InbandEmission:
-	"""InbandEmission commands group definition. 18 total commands, 3 Sub-groups, 0 group commands"""
+class UlcaCls:
+	"""Ulca commands group definition. 2 total commands, 1 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("inbandEmission", core, parent)
+		self._cmd_group = CommandsGroup("ulca", core, parent)
 
 	@property
 	def scc(self):
-		"""scc commands group. 1 Sub-classes, 0 commands."""
+		"""scc commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_scc'):
-			from .InbandEmission_.Scc import Scc
-			self._scc = Scc(self._core, self._base)
+			from .Scc import SccCls
+			self._scc = SccCls(self._core, self._cmd_group)
 		return self._scc
 
-	@property
-	def cc(self):
-		"""cc commands group. 1 Sub-classes, 0 commands."""
-		if not hasattr(self, '_cc'):
-			from .InbandEmission_.Cc import Cc
-			self._cc = Cc(self._core, self._base)
-		return self._cc
-
-	@property
-	def margin(self):
-		"""margin commands group. 4 Sub-classes, 0 commands."""
-		if not hasattr(self, '_margin'):
-			from .InbandEmission_.Margin import Margin
-			self._margin = Margin(self._core, self._base)
-		return self._margin
+	def get_pcc(self) -> List[float]:
+		"""SCPI: SENSe:LTE:MEASurement<Instance>:MEValuation:LIMit:IEMissions:ULCA[:PCC] \n
+		Snippet: value: List[float] = driver.sense.lteMeas.multiEval.limit.iemissions.ulca.get_pcc() \n
+		No command help available \n
+			:return: power: No help available
+		"""
+		response = self._core.io.query_bin_or_ascii_float_list('SENSe:LTE:MEASurement<Instance>:MEValuation:LIMit:IEMissions:ULCA:PCC?')
+		return response
 
-	def clone(self) -> 'InbandEmission':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'UlcaCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = InbandEmission(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = UlcaCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Cc.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ReferenceMarker/Pmonitor/Cc.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,42 +1,51 @@
 from ......Internal.Core import Core
 from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal import Conversions
+from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from ......Internal.Types import DataType
 from ......Internal.RepeatedCapability import RepeatedCapability
 from ...... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Cc:
-	"""Cc commands group definition. 6 total commands, 1 Sub-groups, 0 group commands
+class CcCls:
+	"""Cc commands group definition. 1 total commands, 0 Subgroups, 1 group commands
 	Repeated Capability: CarrierComponent, default value after init: CarrierComponent.Nr1"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("cc", core, parent)
-		self._base.rep_cap = RepeatedCapability(self._base.group_name, 'repcap_carrierComponent_get', 'repcap_carrierComponent_set', repcap.CarrierComponent.Nr1)
+		self._cmd_group = CommandsGroup("cc", core, parent)
+		self._cmd_group.rep_cap = RepeatedCapability(self._cmd_group.group_name, 'repcap_carrierComponent_get', 'repcap_carrierComponent_set', repcap.CarrierComponent.Nr1)
 
-	def repcap_carrierComponent_set(self, enum_value: repcap.CarrierComponent) -> None:
+	def repcap_carrierComponent_set(self, carrierComponent: repcap.CarrierComponent) -> None:
 		"""Repeated Capability default value numeric suffix.
 		This value is used, if you do not explicitely set it in the child set/get methods, or if you leave it to CarrierComponent.Default
 		Default value after init: CarrierComponent.Nr1"""
-		self._base.set_repcap_enum_value(enum_value)
+		self._cmd_group.set_repcap_enum_value(carrierComponent)
 
 	def repcap_carrierComponent_get(self) -> repcap.CarrierComponent:
 		"""Returns the current default repeated capability for the child set/get methods"""
 		# noinspection PyTypeChecker
-		return self._base.get_repcap_enum_value()
+		return self._cmd_group.get_repcap_enum_value()
 
-	@property
-	def margin(self):
-		"""margin commands group. 4 Sub-classes, 0 commands."""
-		if not hasattr(self, '_margin'):
-			from .Cc_.Margin import Margin
-			self._margin = Margin(self._core, self._base)
-		return self._margin
+	def fetch(self, xvalue: int or bool, carrierComponent=repcap.CarrierComponent.Default) -> float:
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:REFMarker:PMONitor:CC<Nr> \n
+		Snippet: value: float = driver.lteMeas.multiEval.referenceMarker.pmonitor.cc.fetch(xvalue = 1, carrierComponent = repcap.CarrierComponent.Default) \n
+		Uses the reference marker on the power monitor trace. \n
+		Suppressed linked return values: reliability \n
+			:param xvalue: (integer or boolean) Absolute x-value of the marker position (subframe number)
+			:param carrierComponent: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Cc')
+			:return: yvalue: Absolute y-value of the marker position"""
+		param = Conversions.decimal_or_bool_value_to_str(xvalue)
+		carrierComponent_cmd_val = self._cmd_group.get_repcap_cmd_value(carrierComponent, repcap.CarrierComponent)
+		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
+		response = self._core.io.query_str_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:REFMarker:PMONitor:CC{carrierComponent_cmd_val}? {param}', suppressed)
+		return Conversions.str_to_float(response)
 
-	def clone(self) -> 'Cc':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'CcCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Cc(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = CcCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Cc_/Margin.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/InbandEmission/Ulca/Scc/Margin/__init__.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,51 +1,51 @@
-from .......Internal.Core import Core
-from .......Internal.CommandsGroup import CommandsGroup
+from ........Internal.Core import Core
+from ........Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Margin:
-	"""Margin commands group definition. 6 total commands, 4 Sub-groups, 0 group commands"""
+class MarginCls:
+	"""Margin commands group definition. 6 total commands, 4 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("margin", core, parent)
+		self._cmd_group = CommandsGroup("margin", core, parent)
 
 	@property
 	def current(self):
 		"""current commands group. 1 Sub-classes, 1 commands."""
 		if not hasattr(self, '_current'):
-			from .Margin_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
 	@property
 	def average(self):
 		"""average commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_average'):
-			from .Margin_.Average import Average
-			self._average = Average(self._core, self._base)
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
 		return self._average
 
 	@property
 	def extreme(self):
 		"""extreme commands group. 1 Sub-classes, 1 commands."""
 		if not hasattr(self, '_extreme'):
-			from .Margin_.Extreme import Extreme
-			self._extreme = Extreme(self._core, self._base)
+			from .Extreme import ExtremeCls
+			self._extreme = ExtremeCls(self._core, self._cmd_group)
 		return self._extreme
 
 	@property
 	def standardDev(self):
 		"""standardDev commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_standardDev'):
-			from .Margin_.StandardDev import StandardDev
-			self._standardDev = StandardDev(self._core, self._base)
+			from .StandardDev import StandardDevCls
+			self._standardDev = StandardDevCls(self._core, self._cmd_group)
 		return self._standardDev
 
-	def clone(self) -> 'Margin':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'MarginCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Margin(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = MarginCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Cc_/Margin_/Average.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/InbandEmission/Cc/Margin/StandardDev.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,26 +1,26 @@
-from ........Internal.Core import Core
-from ........Internal.CommandsGroup import CommandsGroup
-from ........Internal.StructBase import StructBase
-from ........Internal.ArgStruct import ArgStruct
-from ........ import repcap
+from .........Internal.Core import Core
+from .........Internal.CommandsGroup import CommandsGroup
+from .........Internal.StructBase import StructBase
+from .........Internal.ArgStruct import ArgStruct
+from ......... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class StandardDevCls:
+	"""StandardDev commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("standardDev", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
+			- Reliability: int: 'Reliability indicator'
 			- Seg_Reliability: int: Reliability indicator for the segment
 			- Statist_Expired: int: Reached statistical length in slots
 			- Out_Of_Tolerance: int: Percentage of measured subframes with failed limit check
 			- Margin: float: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Seg_Reliability'),
@@ -33,18 +33,18 @@
 			self.Reliability: int = None
 			self.Seg_Reliability: int = None
 			self.Statist_Expired: int = None
 			self.Out_Of_Tolerance: int = None
 			self.Margin: float = None
 
 	def fetch(self, segment=repcap.Segment.Default, carrierComponent=repcap.CarrierComponent.Default) -> FetchStruct:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:IEMission:CC<c>:MARGin:AVERage \n
-		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.inbandEmission.cc.margin.average.fetch(segment = repcap.Segment.Default, carrierComponent = repcap.CarrierComponent.Default) \n
-		Return the inband emission limit line margin results for component carrier CC<c>, segment <no> in list mode. The CURRent
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:IEMission:CC<c>:MARGin:SDEViation \n
+		Snippet: value: FetchStruct = driver.lteMeas.multiEval.listPy.segment.inbandEmission.cc.margin.standardDev.fetch(segment = repcap.Segment.Default, carrierComponent = repcap.CarrierComponent.Default) \n
+		Return the in-band emission limit line margin results for component carrier CC<c>, segment <no> in list mode. The CURRent
 		margins indicate the minimum (vertical) distance between the limit line and the current trace. A negative result
 		indicates that the limit is exceeded. The AVERage, EXTReme and SDEViation values are calculated from the current margins. \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
 			:param carrierComponent: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Cc')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
-		carrierComponent_cmd_val = self._base.get_repcap_cmd_value(carrierComponent, repcap.CarrierComponent)
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:IEMission:CC{carrierComponent_cmd_val}:MARGin:AVERage?', self.__class__.FetchStruct())
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
+		carrierComponent_cmd_val = self._cmd_group.get_repcap_cmd_value(carrierComponent, repcap.CarrierComponent)
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:IEMission:CC{carrierComponent_cmd_val}:MARGin:SDEViation?', self.__class__.FetchStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Cc_/Margin_/Current.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/InbandEmission/Cc/Margin/Current/__init__.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,34 +1,34 @@
-from ........Internal.Core import Core
-from ........Internal.CommandsGroup import CommandsGroup
-from ........Internal.StructBase import StructBase
-from ........Internal.ArgStruct import ArgStruct
-from ........ import repcap
+from ..........Internal.Core import Core
+from ..........Internal.CommandsGroup import CommandsGroup
+from ..........Internal.StructBase import StructBase
+from ..........Internal.ArgStruct import ArgStruct
+from .......... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 2 total commands, 1 Sub-groups, 1 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 2 total commands, 1 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	@property
 	def rbIndex(self):
 		"""rbIndex commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_rbIndex'):
-			from .Current_.RbIndex import RbIndex
-			self._rbIndex = RbIndex(self._core, self._base)
+			from .RbIndex import RbIndexCls
+			self._rbIndex = RbIndexCls(self._core, self._cmd_group)
 		return self._rbIndex
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
+			- Reliability: int: 'Reliability indicator'
 			- Seg_Reliability: int: Reliability indicator for the segment
 			- Statist_Expired: int: Reached statistical length in slots
 			- Out_Of_Tolerance: int: Percentage of measured subframes with failed limit check
 			- Margin: float: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Seg_Reliability'),
@@ -42,25 +42,25 @@
 			self.Seg_Reliability: int = None
 			self.Statist_Expired: int = None
 			self.Out_Of_Tolerance: int = None
 			self.Margin: float = None
 
 	def fetch(self, segment=repcap.Segment.Default, carrierComponent=repcap.CarrierComponent.Default) -> FetchStruct:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:IEMission:CC<c>:MARGin:CURRent \n
-		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.inbandEmission.cc.margin.current.fetch(segment = repcap.Segment.Default, carrierComponent = repcap.CarrierComponent.Default) \n
-		Return the inband emission limit line margin results for component carrier CC<c>, segment <no> in list mode. The CURRent
+		Snippet: value: FetchStruct = driver.lteMeas.multiEval.listPy.segment.inbandEmission.cc.margin.current.fetch(segment = repcap.Segment.Default, carrierComponent = repcap.CarrierComponent.Default) \n
+		Return the in-band emission limit line margin results for component carrier CC<c>, segment <no> in list mode. The CURRent
 		margins indicate the minimum (vertical) distance between the limit line and the current trace. A negative result
 		indicates that the limit is exceeded. The AVERage, EXTReme and SDEViation values are calculated from the current margins. \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
 			:param carrierComponent: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Cc')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
-		carrierComponent_cmd_val = self._base.get_repcap_cmd_value(carrierComponent, repcap.CarrierComponent)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
+		carrierComponent_cmd_val = self._cmd_group.get_repcap_cmd_value(carrierComponent, repcap.CarrierComponent)
 		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:IEMission:CC{carrierComponent_cmd_val}:MARGin:CURRent?', self.__class__.FetchStruct())
 
-	def clone(self) -> 'Current':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'CurrentCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Current(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = CurrentCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Cc_/Margin_/Current_/RbIndex.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/InbandEmission/Cc/Margin/Current/RbIndex.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,26 +1,26 @@
-from .........Internal.Core import Core
-from .........Internal.CommandsGroup import CommandsGroup
-from .........Internal.StructBase import StructBase
-from .........Internal.ArgStruct import ArgStruct
-from ......... import repcap
+from ..........Internal.Core import Core
+from ..........Internal.CommandsGroup import CommandsGroup
+from ..........Internal.StructBase import StructBase
+from ..........Internal.ArgStruct import ArgStruct
+from .......... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class RbIndex:
-	"""RbIndex commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class RbIndexCls:
+	"""RbIndex commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("rbIndex", core, parent)
+		self._cmd_group = CommandsGroup("rbIndex", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
+			- Reliability: int: 'Reliability indicator'
 			- Seg_Reliability: int: Reliability indicator for the segment
 			- Statist_Expired: int: Reached statistical length in slots
 			- Out_Of_Tolerance: int: Percentage of measured subframes with failed limit check
 			- Rb_Index: int: Resource block index of margin"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Seg_Reliability'),
@@ -34,16 +34,16 @@
 			self.Seg_Reliability: int = None
 			self.Statist_Expired: int = None
 			self.Out_Of_Tolerance: int = None
 			self.Rb_Index: int = None
 
 	def fetch(self, segment=repcap.Segment.Default, carrierComponent=repcap.CarrierComponent.Default) -> FetchStruct:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:IEMission:CC<c>:MARGin:CURRent:RBINdex \n
-		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.inbandEmission.cc.margin.current.rbIndex.fetch(segment = repcap.Segment.Default, carrierComponent = repcap.CarrierComponent.Default) \n
-		Return resource block indices of the component carrier CC<c> inband emission measurement for segment <no> in list mode.
+		Snippet: value: FetchStruct = driver.lteMeas.multiEval.listPy.segment.inbandEmission.cc.margin.current.rbIndex.fetch(segment = repcap.Segment.Default, carrierComponent = repcap.CarrierComponent.Default) \n
+		Return resource block indices of the component carrier CC<c> in-band emission measurement for segment <no> in list mode.
 		At these RB indices, the CURRent and EXTReme margins have been detected. \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
 			:param carrierComponent: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Cc')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
-		carrierComponent_cmd_val = self._base.get_repcap_cmd_value(carrierComponent, repcap.CarrierComponent)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
+		carrierComponent_cmd_val = self._cmd_group.get_repcap_cmd_value(carrierComponent, repcap.CarrierComponent)
 		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:IEMission:CC{carrierComponent_cmd_val}:MARGin:CURRent:RBINdex?', self.__class__.FetchStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Cc_/Margin_/Extreme.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/InbandEmission/Cc/Margin/Extreme/__init__.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,34 +1,34 @@
-from ........Internal.Core import Core
-from ........Internal.CommandsGroup import CommandsGroup
-from ........Internal.StructBase import StructBase
-from ........Internal.ArgStruct import ArgStruct
-from ........ import repcap
+from ..........Internal.Core import Core
+from ..........Internal.CommandsGroup import CommandsGroup
+from ..........Internal.StructBase import StructBase
+from ..........Internal.ArgStruct import ArgStruct
+from .......... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Extreme:
-	"""Extreme commands group definition. 2 total commands, 1 Sub-groups, 1 group commands"""
+class ExtremeCls:
+	"""Extreme commands group definition. 2 total commands, 1 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("extreme", core, parent)
+		self._cmd_group = CommandsGroup("extreme", core, parent)
 
 	@property
 	def rbIndex(self):
 		"""rbIndex commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_rbIndex'):
-			from .Extreme_.RbIndex import RbIndex
-			self._rbIndex = RbIndex(self._core, self._base)
+			from .RbIndex import RbIndexCls
+			self._rbIndex = RbIndexCls(self._core, self._cmd_group)
 		return self._rbIndex
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
+			- Reliability: int: 'Reliability indicator'
 			- Seg_Reliability: int: Reliability indicator for the segment
 			- Statist_Expired: int: Reached statistical length in slots
 			- Out_Of_Tolerance: int: Percentage of measured subframes with failed limit check
 			- Margin: float: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Seg_Reliability'),
@@ -42,25 +42,25 @@
 			self.Seg_Reliability: int = None
 			self.Statist_Expired: int = None
 			self.Out_Of_Tolerance: int = None
 			self.Margin: float = None
 
 	def fetch(self, segment=repcap.Segment.Default, carrierComponent=repcap.CarrierComponent.Default) -> FetchStruct:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:IEMission:CC<c>:MARGin:EXTReme \n
-		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.inbandEmission.cc.margin.extreme.fetch(segment = repcap.Segment.Default, carrierComponent = repcap.CarrierComponent.Default) \n
-		Return the inband emission limit line margin results for component carrier CC<c>, segment <no> in list mode. The CURRent
+		Snippet: value: FetchStruct = driver.lteMeas.multiEval.listPy.segment.inbandEmission.cc.margin.extreme.fetch(segment = repcap.Segment.Default, carrierComponent = repcap.CarrierComponent.Default) \n
+		Return the in-band emission limit line margin results for component carrier CC<c>, segment <no> in list mode. The CURRent
 		margins indicate the minimum (vertical) distance between the limit line and the current trace. A negative result
 		indicates that the limit is exceeded. The AVERage, EXTReme and SDEViation values are calculated from the current margins. \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
 			:param carrierComponent: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Cc')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
-		carrierComponent_cmd_val = self._base.get_repcap_cmd_value(carrierComponent, repcap.CarrierComponent)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
+		carrierComponent_cmd_val = self._cmd_group.get_repcap_cmd_value(carrierComponent, repcap.CarrierComponent)
 		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:IEMission:CC{carrierComponent_cmd_val}:MARGin:EXTReme?', self.__class__.FetchStruct())
 
-	def clone(self) -> 'Extreme':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'ExtremeCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Extreme(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = ExtremeCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Cc_/Margin_/Extreme_/RbIndex.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/Power/Cc/StandardDev.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,49 +1,48 @@
-from .........Internal.Core import Core
-from .........Internal.CommandsGroup import CommandsGroup
-from .........Internal.StructBase import StructBase
-from .........Internal.ArgStruct import ArgStruct
-from ......... import repcap
+from ........Internal.Core import Core
+from ........Internal.CommandsGroup import CommandsGroup
+from ........Internal.StructBase import StructBase
+from ........Internal.ArgStruct import ArgStruct
+from ........ import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class RbIndex:
-	"""RbIndex commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class StandardDevCls:
+	"""StandardDev commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("rbIndex", core, parent)
+		self._cmd_group = CommandsGroup("standardDev", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
+			- Reliability: int: 'Reliability indicator'
 			- Seg_Reliability: int: Reliability indicator for the segment
-			- Statist_Expired: int: Reached statistical length in slots
+			- Statist_Expired: int: Reached statistical length in subframes
 			- Out_Of_Tolerance: int: Percentage of measured subframes with failed limit check
-			- Rb_Index: int: Resource block index of margin"""
+			- Tx_Power: float: TX power of the component carrier"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Seg_Reliability'),
 			ArgStruct.scalar_int('Statist_Expired'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
-			ArgStruct.scalar_int('Rb_Index')]
+			ArgStruct.scalar_float('Tx_Power')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Seg_Reliability: int = None
 			self.Statist_Expired: int = None
 			self.Out_Of_Tolerance: int = None
-			self.Rb_Index: int = None
+			self.Tx_Power: float = None
 
-	def fetch(self, segment=repcap.Segment.Default, carrierComponent=repcap.CarrierComponent.Default) -> FetchStruct:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:IEMission:CC<c>:MARGin:EXTReme:RBINdex \n
-		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.inbandEmission.cc.margin.extreme.rbIndex.fetch(segment = repcap.Segment.Default, carrierComponent = repcap.CarrierComponent.Default) \n
-		Return resource block indices of the component carrier CC<c> inband emission measurement for segment <no> in list mode.
-		At these RB indices, the CURRent and EXTReme margins have been detected. \n
+	def fetch(self, segment=repcap.Segment.Default, carrierComponentB=repcap.CarrierComponentB.Default) -> FetchStruct:
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:POWer:CC<no>:SDEViation \n
+		Snippet: value: FetchStruct = driver.lteMeas.multiEval.listPy.segment.power.cc.standardDev.fetch(segment = repcap.Segment.Default, carrierComponentB = repcap.CarrierComponentB.Default) \n
+		Return TX power results for component carrier CC<no> and a single segment in list mode. \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
-			:param carrierComponent: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Cc')
+			:param carrierComponentB: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Cc')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
-		carrierComponent_cmd_val = self._base.get_repcap_cmd_value(carrierComponent, repcap.CarrierComponent)
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:IEMission:CC{carrierComponent_cmd_val}:MARGin:EXTReme:RBINdex?', self.__class__.FetchStruct())
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
+		carrierComponentB_cmd_val = self._cmd_group.get_repcap_cmd_value(carrierComponentB, repcap.CarrierComponentB)
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:POWer:CC{carrierComponentB_cmd_val}:SDEViation?', self.__class__.FetchStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Cc_/Margin_/StandardDev.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/InbandEmission/Cc/Margin/Average.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,26 +1,26 @@
-from ........Internal.Core import Core
-from ........Internal.CommandsGroup import CommandsGroup
-from ........Internal.StructBase import StructBase
-from ........Internal.ArgStruct import ArgStruct
-from ........ import repcap
+from .........Internal.Core import Core
+from .........Internal.CommandsGroup import CommandsGroup
+from .........Internal.StructBase import StructBase
+from .........Internal.ArgStruct import ArgStruct
+from ......... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class StandardDev:
-	"""StandardDev commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class AverageCls:
+	"""Average commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("standardDev", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
+			- Reliability: int: 'Reliability indicator'
 			- Seg_Reliability: int: Reliability indicator for the segment
 			- Statist_Expired: int: Reached statistical length in slots
 			- Out_Of_Tolerance: int: Percentage of measured subframes with failed limit check
 			- Margin: float: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Seg_Reliability'),
@@ -33,18 +33,18 @@
 			self.Reliability: int = None
 			self.Seg_Reliability: int = None
 			self.Statist_Expired: int = None
 			self.Out_Of_Tolerance: int = None
 			self.Margin: float = None
 
 	def fetch(self, segment=repcap.Segment.Default, carrierComponent=repcap.CarrierComponent.Default) -> FetchStruct:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:IEMission:CC<c>:MARGin:SDEViation \n
-		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.inbandEmission.cc.margin.standardDev.fetch(segment = repcap.Segment.Default, carrierComponent = repcap.CarrierComponent.Default) \n
-		Return the inband emission limit line margin results for component carrier CC<c>, segment <no> in list mode. The CURRent
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:IEMission:CC<c>:MARGin:AVERage \n
+		Snippet: value: FetchStruct = driver.lteMeas.multiEval.listPy.segment.inbandEmission.cc.margin.average.fetch(segment = repcap.Segment.Default, carrierComponent = repcap.CarrierComponent.Default) \n
+		Return the in-band emission limit line margin results for component carrier CC<c>, segment <no> in list mode. The CURRent
 		margins indicate the minimum (vertical) distance between the limit line and the current trace. A negative result
 		indicates that the limit is exceeded. The AVERage, EXTReme and SDEViation values are calculated from the current margins. \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
 			:param carrierComponent: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Cc')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
-		carrierComponent_cmd_val = self._base.get_repcap_cmd_value(carrierComponent, repcap.CarrierComponent)
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:IEMission:CC{carrierComponent_cmd_val}:MARGin:SDEViation?', self.__class__.FetchStruct())
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
+		carrierComponent_cmd_val = self._cmd_group.get_repcap_cmd_value(carrierComponent, repcap.CarrierComponent)
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:IEMission:CC{carrierComponent_cmd_val}:MARGin:AVERage?', self.__class__.FetchStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Margin.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/InbandEmission/Margin/__init__.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,51 +1,51 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
+from ........Internal.Core import Core
+from ........Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Margin:
-	"""Margin commands group definition. 6 total commands, 4 Sub-groups, 0 group commands"""
+class MarginCls:
+	"""Margin commands group definition. 6 total commands, 4 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("margin", core, parent)
+		self._cmd_group = CommandsGroup("margin", core, parent)
 
 	@property
 	def current(self):
 		"""current commands group. 1 Sub-classes, 1 commands."""
 		if not hasattr(self, '_current'):
-			from .Margin_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
 	@property
 	def average(self):
 		"""average commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_average'):
-			from .Margin_.Average import Average
-			self._average = Average(self._core, self._base)
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
 		return self._average
 
 	@property
 	def extreme(self):
 		"""extreme commands group. 1 Sub-classes, 1 commands."""
 		if not hasattr(self, '_extreme'):
-			from .Margin_.Extreme import Extreme
-			self._extreme = Extreme(self._core, self._base)
+			from .Extreme import ExtremeCls
+			self._extreme = ExtremeCls(self._core, self._cmd_group)
 		return self._extreme
 
 	@property
 	def standardDev(self):
 		"""standardDev commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_standardDev'):
-			from .Margin_.StandardDev import StandardDev
-			self._standardDev = StandardDev(self._core, self._base)
+			from .StandardDev import StandardDevCls
+			self._standardDev = StandardDevCls(self._core, self._cmd_group)
 		return self._standardDev
 
-	def clone(self) -> 'Margin':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'MarginCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Margin(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = MarginCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Margin_/Average.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/InbandEmission/Margin/Current/RbIndex.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,46 +1,46 @@
-from .......Internal.Core import Core
-from .......Internal.CommandsGroup import CommandsGroup
-from .......Internal.StructBase import StructBase
-from .......Internal.ArgStruct import ArgStruct
-from ....... import repcap
+from .........Internal.Core import Core
+from .........Internal.CommandsGroup import CommandsGroup
+from .........Internal.StructBase import StructBase
+from .........Internal.ArgStruct import ArgStruct
+from ......... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class RbIndexCls:
+	"""RbIndex commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("rbIndex", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
 			- Reliability: int: No parameter help available
 			- Seg_Reliability: int: No parameter help available
 			- Statist_Expired: int: No parameter help available
 			- Out_Of_Tolerance: int: No parameter help available
-			- Margin: float: No parameter help available"""
+			- Rb_Index: int: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Seg_Reliability'),
 			ArgStruct.scalar_int('Statist_Expired'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
-			ArgStruct.scalar_float('Margin')]
+			ArgStruct.scalar_int('Rb_Index')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Seg_Reliability: int = None
 			self.Statist_Expired: int = None
 			self.Out_Of_Tolerance: int = None
-			self.Margin: float = None
+			self.Rb_Index: int = None
 
 	def fetch(self, segment=repcap.Segment.Default) -> FetchStruct:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:IEMission:MARGin:AVERage \n
-		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.inbandEmission.margin.average.fetch(segment = repcap.Segment.Default) \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:IEMission:MARGin:CURRent:RBINdex \n
+		Snippet: value: FetchStruct = driver.lteMeas.multiEval.listPy.segment.inbandEmission.margin.current.rbIndex.fetch(segment = repcap.Segment.Default) \n
 		No command help available \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:IEMission:MARGin:AVERage?', self.__class__.FetchStruct())
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:IEMission:MARGin:CURRent:RBINdex?', self.__class__.FetchStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Margin_/Current.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/InbandEmission/Margin/Extreme/RbIndex.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,62 +1,46 @@
-from .......Internal.Core import Core
-from .......Internal.CommandsGroup import CommandsGroup
-from .......Internal.StructBase import StructBase
-from .......Internal.ArgStruct import ArgStruct
-from ....... import repcap
+from .........Internal.Core import Core
+from .........Internal.CommandsGroup import CommandsGroup
+from .........Internal.StructBase import StructBase
+from .........Internal.ArgStruct import ArgStruct
+from ......... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 2 total commands, 1 Sub-groups, 1 group commands"""
+class RbIndexCls:
+	"""RbIndex commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
-
-	@property
-	def rbIndex(self):
-		"""rbIndex commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_rbIndex'):
-			from .Current_.RbIndex import RbIndex
-			self._rbIndex = RbIndex(self._core, self._base)
-		return self._rbIndex
+		self._cmd_group = CommandsGroup("rbIndex", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
 			- Reliability: int: No parameter help available
 			- Seg_Reliability: int: No parameter help available
 			- Statist_Expired: int: No parameter help available
 			- Out_Of_Tolerance: int: No parameter help available
-			- Margin: float: No parameter help available"""
+			- Rb_Index: int: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Seg_Reliability'),
 			ArgStruct.scalar_int('Statist_Expired'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
-			ArgStruct.scalar_float('Margin')]
+			ArgStruct.scalar_int('Rb_Index')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Seg_Reliability: int = None
 			self.Statist_Expired: int = None
 			self.Out_Of_Tolerance: int = None
-			self.Margin: float = None
+			self.Rb_Index: int = None
 
 	def fetch(self, segment=repcap.Segment.Default) -> FetchStruct:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:IEMission:MARGin:CURRent \n
-		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.inbandEmission.margin.current.fetch(segment = repcap.Segment.Default) \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:IEMission:MARGin:EXTReme:RBINdex \n
+		Snippet: value: FetchStruct = driver.lteMeas.multiEval.listPy.segment.inbandEmission.margin.extreme.rbIndex.fetch(segment = repcap.Segment.Default) \n
 		No command help available \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:IEMission:MARGin:CURRent?', self.__class__.FetchStruct())
-
-	def clone(self) -> 'Current':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
-		Also copies all the existing default Repeated Capabilities setting,
-		which you can change independently without affecting the original group"""
-		new_group = Current(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
-		return new_group
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:IEMission:MARGin:EXTReme:RBINdex?', self.__class__.FetchStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Margin_/Current_/RbIndex.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/InbandEmission/Margin/StandardDev.py`

 * *Files 11% similar despite different names*

```diff
@@ -2,45 +2,45 @@
 from ........Internal.CommandsGroup import CommandsGroup
 from ........Internal.StructBase import StructBase
 from ........Internal.ArgStruct import ArgStruct
 from ........ import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class RbIndex:
-	"""RbIndex commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class StandardDevCls:
+	"""StandardDev commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("rbIndex", core, parent)
+		self._cmd_group = CommandsGroup("standardDev", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
 			- Reliability: int: No parameter help available
 			- Seg_Reliability: int: No parameter help available
 			- Statist_Expired: int: No parameter help available
 			- Out_Of_Tolerance: int: No parameter help available
-			- Rb_Index: int: No parameter help available"""
+			- Margin: float: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Seg_Reliability'),
 			ArgStruct.scalar_int('Statist_Expired'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
-			ArgStruct.scalar_int('Rb_Index')]
+			ArgStruct.scalar_float('Margin')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Seg_Reliability: int = None
 			self.Statist_Expired: int = None
 			self.Out_Of_Tolerance: int = None
-			self.Rb_Index: int = None
+			self.Margin: float = None
 
 	def fetch(self, segment=repcap.Segment.Default) -> FetchStruct:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:IEMission:MARGin:CURRent:RBINdex \n
-		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.inbandEmission.margin.current.rbIndex.fetch(segment = repcap.Segment.Default) \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:IEMission:MARGin:SDEViation \n
+		Snippet: value: FetchStruct = driver.lteMeas.multiEval.listPy.segment.inbandEmission.margin.standardDev.fetch(segment = repcap.Segment.Default) \n
 		No command help available \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:IEMission:MARGin:CURRent:RBINdex?', self.__class__.FetchStruct())
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:IEMission:MARGin:SDEViation?', self.__class__.FetchStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Margin_/Extreme.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/InbandEmission/Margin/Extreme/__init__.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,28 +1,28 @@
-from .......Internal.Core import Core
-from .......Internal.CommandsGroup import CommandsGroup
-from .......Internal.StructBase import StructBase
-from .......Internal.ArgStruct import ArgStruct
-from ....... import repcap
+from .........Internal.Core import Core
+from .........Internal.CommandsGroup import CommandsGroup
+from .........Internal.StructBase import StructBase
+from .........Internal.ArgStruct import ArgStruct
+from ......... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Extreme:
-	"""Extreme commands group definition. 2 total commands, 1 Sub-groups, 1 group commands"""
+class ExtremeCls:
+	"""Extreme commands group definition. 2 total commands, 1 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("extreme", core, parent)
+		self._cmd_group = CommandsGroup("extreme", core, parent)
 
 	@property
 	def rbIndex(self):
 		"""rbIndex commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_rbIndex'):
-			from .Extreme_.RbIndex import RbIndex
-			self._rbIndex = RbIndex(self._core, self._base)
+			from .RbIndex import RbIndexCls
+			self._rbIndex = RbIndexCls(self._core, self._cmd_group)
 		return self._rbIndex
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
 			- Reliability: int: No parameter help available
 			- Seg_Reliability: int: No parameter help available
@@ -42,21 +42,21 @@
 			self.Seg_Reliability: int = None
 			self.Statist_Expired: int = None
 			self.Out_Of_Tolerance: int = None
 			self.Margin: float = None
 
 	def fetch(self, segment=repcap.Segment.Default) -> FetchStruct:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:IEMission:MARGin:EXTReme \n
-		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.inbandEmission.margin.extreme.fetch(segment = repcap.Segment.Default) \n
+		Snippet: value: FetchStruct = driver.lteMeas.multiEval.listPy.segment.inbandEmission.margin.extreme.fetch(segment = repcap.Segment.Default) \n
 		No command help available \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:IEMission:MARGin:EXTReme?', self.__class__.FetchStruct())
 
-	def clone(self) -> 'Extreme':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'ExtremeCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Extreme(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = ExtremeCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Margin_/Extreme_/RbIndex.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/Power/StandardDev.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,46 +1,46 @@
-from ........Internal.Core import Core
-from ........Internal.CommandsGroup import CommandsGroup
-from ........Internal.StructBase import StructBase
-from ........Internal.ArgStruct import ArgStruct
-from ........ import repcap
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal.StructBase import StructBase
+from .......Internal.ArgStruct import ArgStruct
+from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class RbIndex:
-	"""RbIndex commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class StandardDevCls:
+	"""StandardDev commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("rbIndex", core, parent)
+		self._cmd_group = CommandsGroup("standardDev", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: No parameter help available
-			- Seg_Reliability: int: No parameter help available
-			- Statist_Expired: int: No parameter help available
-			- Out_Of_Tolerance: int: No parameter help available
-			- Rb_Index: int: No parameter help available"""
+			- Reliability: int: 'Reliability indicator'
+			- Seg_Reliability: int: Reliability indicator for the segment
+			- Statist_Expired: int: Reached statistical length in subframes
+			- Out_Of_Tolerance: int: Percentage of measured subframes with failed limit check
+			- Tx_Power: float: Total TX power of all component carriers"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Seg_Reliability'),
 			ArgStruct.scalar_int('Statist_Expired'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
-			ArgStruct.scalar_int('Rb_Index')]
+			ArgStruct.scalar_float('Tx_Power')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Seg_Reliability: int = None
 			self.Statist_Expired: int = None
 			self.Out_Of_Tolerance: int = None
-			self.Rb_Index: int = None
+			self.Tx_Power: float = None
 
 	def fetch(self, segment=repcap.Segment.Default) -> FetchStruct:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:IEMission:MARGin:EXTReme:RBINdex \n
-		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.inbandEmission.margin.extreme.rbIndex.fetch(segment = repcap.Segment.Default) \n
-		No command help available \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:POWer:SDEViation \n
+		Snippet: value: FetchStruct = driver.lteMeas.multiEval.listPy.segment.power.standardDev.fetch(segment = repcap.Segment.Default) \n
+		Return total TX power results for segment <no> in list mode. \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:IEMission:MARGin:EXTReme:RBINdex?', self.__class__.FetchStruct())
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:POWer:SDEViation?', self.__class__.FetchStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Margin_/StandardDev.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/InbandEmission/Scc/Margin/Current/__init__.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,21 +1,29 @@
-from .......Internal.Core import Core
-from .......Internal.CommandsGroup import CommandsGroup
-from .......Internal.StructBase import StructBase
-from .......Internal.ArgStruct import ArgStruct
-from ....... import repcap
+from ..........Internal.Core import Core
+from ..........Internal.CommandsGroup import CommandsGroup
+from ..........Internal.StructBase import StructBase
+from ..........Internal.ArgStruct import ArgStruct
+from .......... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class StandardDev:
-	"""StandardDev commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 2 total commands, 1 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("standardDev", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
+
+	@property
+	def rbIndex(self):
+		"""rbIndex commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_rbIndex'):
+			from .RbIndex import RbIndexCls
+			self._rbIndex = RbIndexCls(self._core, self._cmd_group)
+		return self._rbIndex
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
 			- Reliability: int: No parameter help available
 			- Seg_Reliability: int: No parameter help available
 			- Statist_Expired: int: No parameter help available
@@ -32,15 +40,25 @@
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Seg_Reliability: int = None
 			self.Statist_Expired: int = None
 			self.Out_Of_Tolerance: int = None
 			self.Margin: float = None
 
-	def fetch(self, segment=repcap.Segment.Default) -> FetchStruct:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:IEMission:MARGin:SDEViation \n
-		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.inbandEmission.margin.standardDev.fetch(segment = repcap.Segment.Default) \n
+	def fetch(self, segment=repcap.Segment.Default, secondaryCC=repcap.SecondaryCC.Default) -> FetchStruct:
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:IEMission:SCC<c>:MARGin:CURRent \n
+		Snippet: value: FetchStruct = driver.lteMeas.multiEval.listPy.segment.inbandEmission.scc.margin.current.fetch(segment = repcap.Segment.Default, secondaryCC = repcap.SecondaryCC.Default) \n
 		No command help available \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
+			:param secondaryCC: optional repeated capability selector. Default value: CC1 (settable in the interface 'Scc')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:IEMission:MARGin:SDEViation?', self.__class__.FetchStruct())
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
+		secondaryCC_cmd_val = self._cmd_group.get_repcap_cmd_value(secondaryCC, repcap.SecondaryCC)
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:IEMission:SCC{secondaryCC_cmd_val}:MARGin:CURRent?', self.__class__.FetchStruct())
+
+	def clone(self) -> 'CurrentCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
+		Also copies all the existing default Repeated Capabilities setting,
+		which you can change independently without affecting the original group"""
+		new_group = CurrentCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
+		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Scc_/Margin.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/InbandEmission/Cc/Margin/__init__.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,51 +1,51 @@
-from .......Internal.Core import Core
-from .......Internal.CommandsGroup import CommandsGroup
+from .........Internal.Core import Core
+from .........Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Margin:
-	"""Margin commands group definition. 6 total commands, 4 Sub-groups, 0 group commands"""
+class MarginCls:
+	"""Margin commands group definition. 6 total commands, 4 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("margin", core, parent)
+		self._cmd_group = CommandsGroup("margin", core, parent)
 
 	@property
 	def current(self):
 		"""current commands group. 1 Sub-classes, 1 commands."""
 		if not hasattr(self, '_current'):
-			from .Margin_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
 	@property
 	def average(self):
 		"""average commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_average'):
-			from .Margin_.Average import Average
-			self._average = Average(self._core, self._base)
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
 		return self._average
 
 	@property
 	def extreme(self):
 		"""extreme commands group. 1 Sub-classes, 1 commands."""
 		if not hasattr(self, '_extreme'):
-			from .Margin_.Extreme import Extreme
-			self._extreme = Extreme(self._core, self._base)
+			from .Extreme import ExtremeCls
+			self._extreme = ExtremeCls(self._core, self._cmd_group)
 		return self._extreme
 
 	@property
 	def standardDev(self):
 		"""standardDev commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_standardDev'):
-			from .Margin_.StandardDev import StandardDev
-			self._standardDev = StandardDev(self._core, self._base)
+			from .StandardDev import StandardDevCls
+			self._standardDev = StandardDevCls(self._core, self._cmd_group)
 		return self._standardDev
 
-	def clone(self) -> 'Margin':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'MarginCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Margin(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = MarginCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Scc_/Margin_/Average.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/SeMask/Margin/Current/Positiv.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,48 +1,55 @@
-from ........Internal.Core import Core
-from ........Internal.CommandsGroup import CommandsGroup
-from ........Internal.StructBase import StructBase
-from ........Internal.ArgStruct import ArgStruct
-from ........ import repcap
+from typing import List
+
+from .........Internal.Core import Core
+from .........Internal.CommandsGroup import CommandsGroup
+from .........Internal.Types import DataType
+from .........Internal.StructBase import StructBase
+from .........Internal.ArgStruct import ArgStruct
+from ......... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class PositivCls:
+	"""Positiv commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("positiv", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: No parameter help available
-			- Seg_Reliability: int: No parameter help available
-			- Statist_Expired: int: No parameter help available
-			- Out_Of_Tolerance: int: No parameter help available
-			- Margin: float: No parameter help available"""
+			- Reliability: int: 'Reliability indicator'
+			- Seg_Reliability: int: Reliability indicator for the segment
+			- Statist_Expired: int: Reached statistical length in slots
+			- Out_Of_Tolerance: int: Percentage of measured subframes with failed limit check
+			- Margin_Curr_Pos_X: List[float]: No parameter help available
+			- Margin_Curr_Pos_Y: List[float]: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Seg_Reliability'),
 			ArgStruct.scalar_int('Statist_Expired'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
-			ArgStruct.scalar_float('Margin')]
+			ArgStruct('Margin_Curr_Pos_X', DataType.FloatList, None, False, True, 1),
+			ArgStruct('Margin_Curr_Pos_Y', DataType.FloatList, None, False, True, 1)]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Seg_Reliability: int = None
 			self.Statist_Expired: int = None
 			self.Out_Of_Tolerance: int = None
-			self.Margin: float = None
+			self.Margin_Curr_Pos_X: List[float] = None
+			self.Margin_Curr_Pos_Y: List[float] = None
 
-	def fetch(self, segment=repcap.Segment.Default, secondaryCC=repcap.SecondaryCC.Default) -> FetchStruct:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:IEMission:SCC<c>:MARGin:AVERage \n
-		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.inbandEmission.scc.margin.average.fetch(segment = repcap.Segment.Default, secondaryCC = repcap.SecondaryCC.Default) \n
-		No command help available \n
+	def fetch(self, segment=repcap.Segment.Default) -> FetchStruct:
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:SEMask:MARGin:CURRent:POSitiv \n
+		Snippet: value: FetchStruct = driver.lteMeas.multiEval.listPy.segment.seMask.margin.current.positiv.fetch(segment = repcap.Segment.Default) \n
+		Return spectrum emission mask margin results for segment <no> in list mode. The individual commands provide results for
+		the CURRent, AVERage and maximum traces (resulting in MINimum margins) for NEGative and POSitive offset frequencies.
+		Returned sequence: <Reliability>, <SegReliability>, <StatistExpired>, <OutOfTolerance>, {<MarginX>, <MarginY>}area1, {...
+		}area2, ..., {...}area12 \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
-			:param secondaryCC: optional repeated capability selector. Default value: CC1 (settable in the interface 'Scc')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
-		secondaryCC_cmd_val = self._base.get_repcap_cmd_value(secondaryCC, repcap.SecondaryCC)
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:IEMission:SCC{secondaryCC_cmd_val}:MARGin:AVERage?', self.__class__.FetchStruct())
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:SEMask:MARGin:CURRent:POSitiv?', self.__class__.FetchStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Scc_/Margin_/Current.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/InbandEmission/Scc/Margin/Current/RbIndex.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,64 +1,48 @@
-from ........Internal.Core import Core
-from ........Internal.CommandsGroup import CommandsGroup
-from ........Internal.StructBase import StructBase
-from ........Internal.ArgStruct import ArgStruct
-from ........ import repcap
+from ..........Internal.Core import Core
+from ..........Internal.CommandsGroup import CommandsGroup
+from ..........Internal.StructBase import StructBase
+from ..........Internal.ArgStruct import ArgStruct
+from .......... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 2 total commands, 1 Sub-groups, 1 group commands"""
+class RbIndexCls:
+	"""RbIndex commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
-
-	@property
-	def rbIndex(self):
-		"""rbIndex commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_rbIndex'):
-			from .Current_.RbIndex import RbIndex
-			self._rbIndex = RbIndex(self._core, self._base)
-		return self._rbIndex
+		self._cmd_group = CommandsGroup("rbIndex", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
 			- Reliability: int: No parameter help available
 			- Seg_Reliability: int: No parameter help available
 			- Statist_Expired: int: No parameter help available
 			- Out_Of_Tolerance: int: No parameter help available
-			- Margin: float: No parameter help available"""
+			- Rb_Index: int: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Seg_Reliability'),
 			ArgStruct.scalar_int('Statist_Expired'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
-			ArgStruct.scalar_float('Margin')]
+			ArgStruct.scalar_int('Rb_Index')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Seg_Reliability: int = None
 			self.Statist_Expired: int = None
 			self.Out_Of_Tolerance: int = None
-			self.Margin: float = None
+			self.Rb_Index: int = None
 
 	def fetch(self, segment=repcap.Segment.Default, secondaryCC=repcap.SecondaryCC.Default) -> FetchStruct:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:IEMission:SCC<c>:MARGin:CURRent \n
-		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.inbandEmission.scc.margin.current.fetch(segment = repcap.Segment.Default, secondaryCC = repcap.SecondaryCC.Default) \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:IEMission:SCC<c>:MARGin:CURRent:RBINdex \n
+		Snippet: value: FetchStruct = driver.lteMeas.multiEval.listPy.segment.inbandEmission.scc.margin.current.rbIndex.fetch(segment = repcap.Segment.Default, secondaryCC = repcap.SecondaryCC.Default) \n
 		No command help available \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
 			:param secondaryCC: optional repeated capability selector. Default value: CC1 (settable in the interface 'Scc')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
-		secondaryCC_cmd_val = self._base.get_repcap_cmd_value(secondaryCC, repcap.SecondaryCC)
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:IEMission:SCC{secondaryCC_cmd_val}:MARGin:CURRent?', self.__class__.FetchStruct())
-
-	def clone(self) -> 'Current':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
-		Also copies all the existing default Repeated Capabilities setting,
-		which you can change independently without affecting the original group"""
-		new_group = Current(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
-		return new_group
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
+		secondaryCC_cmd_val = self._cmd_group.get_repcap_cmd_value(secondaryCC, repcap.SecondaryCC)
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:IEMission:SCC{secondaryCC_cmd_val}:MARGin:CURRent:RBINdex?', self.__class__.FetchStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Scc_/Margin_/Current_/RbIndex.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/Modulation/Average/Globale.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,48 +1,43 @@
-from .........Internal.Core import Core
-from .........Internal.CommandsGroup import CommandsGroup
-from .........Internal.StructBase import StructBase
-from .........Internal.ArgStruct import ArgStruct
-from ......... import repcap
+from ........Internal.Core import Core
+from ........Internal.CommandsGroup import CommandsGroup
+from ........Internal.StructBase import StructBase
+from ........Internal.ArgStruct import ArgStruct
+from ........ import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class RbIndex:
-	"""RbIndex commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class GlobaleCls:
+	"""Globale commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("rbIndex", core, parent)
+		self._cmd_group = CommandsGroup("globale", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
 			- Reliability: int: No parameter help available
 			- Seg_Reliability: int: No parameter help available
 			- Statist_Expired: int: No parameter help available
-			- Out_Of_Tolerance: int: No parameter help available
-			- Rb_Index: int: No parameter help available"""
+			- Out_Of_Tolerance: int: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Seg_Reliability'),
 			ArgStruct.scalar_int('Statist_Expired'),
-			ArgStruct.scalar_int('Out_Of_Tolerance'),
-			ArgStruct.scalar_int('Rb_Index')]
+			ArgStruct.scalar_int('Out_Of_Tolerance')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Seg_Reliability: int = None
 			self.Statist_Expired: int = None
 			self.Out_Of_Tolerance: int = None
-			self.Rb_Index: int = None
 
-	def fetch(self, segment=repcap.Segment.Default, secondaryCC=repcap.SecondaryCC.Default) -> FetchStruct:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:IEMission:SCC<c>:MARGin:CURRent:RBINdex \n
-		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.inbandEmission.scc.margin.current.rbIndex.fetch(segment = repcap.Segment.Default, secondaryCC = repcap.SecondaryCC.Default) \n
+	def fetch(self, segment=repcap.Segment.Default) -> FetchStruct:
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:MODulation:AVERage:GLOBal \n
+		Snippet: value: FetchStruct = driver.lteMeas.multiEval.listPy.segment.modulation.average.globale.fetch(segment = repcap.Segment.Default) \n
 		No command help available \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
-			:param secondaryCC: optional repeated capability selector. Default value: CC1 (settable in the interface 'Scc')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
-		secondaryCC_cmd_val = self._base.get_repcap_cmd_value(secondaryCC, repcap.SecondaryCC)
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:IEMission:SCC{secondaryCC_cmd_val}:MARGin:CURRent:RBINdex?', self.__class__.FetchStruct())
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:MODulation:AVERage:GLOBal?', self.__class__.FetchStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Scc_/Margin_/Extreme.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/SeMask/Margin/Average/Negativ.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,64 +1,55 @@
-from ........Internal.Core import Core
-from ........Internal.CommandsGroup import CommandsGroup
-from ........Internal.StructBase import StructBase
-from ........Internal.ArgStruct import ArgStruct
-from ........ import repcap
+from typing import List
+
+from .........Internal.Core import Core
+from .........Internal.CommandsGroup import CommandsGroup
+from .........Internal.Types import DataType
+from .........Internal.StructBase import StructBase
+from .........Internal.ArgStruct import ArgStruct
+from ......... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Extreme:
-	"""Extreme commands group definition. 2 total commands, 1 Sub-groups, 1 group commands"""
+class NegativCls:
+	"""Negativ commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("extreme", core, parent)
-
-	@property
-	def rbIndex(self):
-		"""rbIndex commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_rbIndex'):
-			from .Extreme_.RbIndex import RbIndex
-			self._rbIndex = RbIndex(self._core, self._base)
-		return self._rbIndex
+		self._cmd_group = CommandsGroup("negativ", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: No parameter help available
-			- Seg_Reliability: int: No parameter help available
-			- Statist_Expired: int: No parameter help available
-			- Out_Of_Tolerance: int: No parameter help available
-			- Margin: float: No parameter help available"""
+			- Reliability: int: 'Reliability indicator'
+			- Seg_Reliability: int: Reliability indicator for the segment
+			- Statist_Expired: int: Reached statistical length in slots
+			- Out_Of_Tolerance: int: Percentage of measured subframes with failed limit check
+			- Margin_Avg_Neg_X: List[float]: No parameter help available
+			- Margin_Avg_Neg_Y: List[float]: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Seg_Reliability'),
 			ArgStruct.scalar_int('Statist_Expired'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
-			ArgStruct.scalar_float('Margin')]
+			ArgStruct('Margin_Avg_Neg_X', DataType.FloatList, None, False, True, 1),
+			ArgStruct('Margin_Avg_Neg_Y', DataType.FloatList, None, False, True, 1)]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Seg_Reliability: int = None
 			self.Statist_Expired: int = None
 			self.Out_Of_Tolerance: int = None
-			self.Margin: float = None
+			self.Margin_Avg_Neg_X: List[float] = None
+			self.Margin_Avg_Neg_Y: List[float] = None
 
-	def fetch(self, segment=repcap.Segment.Default, secondaryCC=repcap.SecondaryCC.Default) -> FetchStruct:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:IEMission:SCC<c>:MARGin:EXTReme \n
-		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.inbandEmission.scc.margin.extreme.fetch(segment = repcap.Segment.Default, secondaryCC = repcap.SecondaryCC.Default) \n
-		No command help available \n
+	def fetch(self, segment=repcap.Segment.Default) -> FetchStruct:
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:SEMask:MARGin:AVERage:NEGativ \n
+		Snippet: value: FetchStruct = driver.lteMeas.multiEval.listPy.segment.seMask.margin.average.negativ.fetch(segment = repcap.Segment.Default) \n
+		Return spectrum emission mask margin results for segment <no> in list mode. The individual commands provide results for
+		the CURRent, AVERage and maximum traces (resulting in MINimum margins) for NEGative and POSitive offset frequencies.
+		Returned sequence: <Reliability>, <SegReliability>, <StatistExpired>, <OutOfTolerance>, {<MarginX>, <MarginY>}area1, {...
+		}area2, ..., {...}area12 \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
-			:param secondaryCC: optional repeated capability selector. Default value: CC1 (settable in the interface 'Scc')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
-		secondaryCC_cmd_val = self._base.get_repcap_cmd_value(secondaryCC, repcap.SecondaryCC)
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:IEMission:SCC{secondaryCC_cmd_val}:MARGin:EXTReme?', self.__class__.FetchStruct())
-
-	def clone(self) -> 'Extreme':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
-		Also copies all the existing default Repeated Capabilities setting,
-		which you can change independently without affecting the original group"""
-		new_group = Extreme(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
-		return new_group
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:SEMask:MARGin:AVERage:NEGativ?', self.__class__.FetchStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Scc_/Margin_/Extreme_/RbIndex.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/SeMask/Margin/Current/Negativ.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,48 +1,55 @@
+from typing import List
+
 from .........Internal.Core import Core
 from .........Internal.CommandsGroup import CommandsGroup
+from .........Internal.Types import DataType
 from .........Internal.StructBase import StructBase
 from .........Internal.ArgStruct import ArgStruct
 from ......... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class RbIndex:
-	"""RbIndex commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class NegativCls:
+	"""Negativ commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("rbIndex", core, parent)
+		self._cmd_group = CommandsGroup("negativ", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: No parameter help available
-			- Seg_Reliability: int: No parameter help available
-			- Statist_Expired: int: No parameter help available
-			- Out_Of_Tolerance: int: No parameter help available
-			- Rb_Index: int: No parameter help available"""
+			- Reliability: int: 'Reliability indicator'
+			- Seg_Reliability: int: Reliability indicator for the segment
+			- Statist_Expired: int: Reached statistical length in slots
+			- Out_Of_Tolerance: int: Percentage of measured subframes with failed limit check
+			- Margin_Curr_Neg_X: List[float]: No parameter help available
+			- Margin_Curr_Neg_Y: List[float]: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Seg_Reliability'),
 			ArgStruct.scalar_int('Statist_Expired'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
-			ArgStruct.scalar_int('Rb_Index')]
+			ArgStruct('Margin_Curr_Neg_X', DataType.FloatList, None, False, True, 1),
+			ArgStruct('Margin_Curr_Neg_Y', DataType.FloatList, None, False, True, 1)]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Seg_Reliability: int = None
 			self.Statist_Expired: int = None
 			self.Out_Of_Tolerance: int = None
-			self.Rb_Index: int = None
+			self.Margin_Curr_Neg_X: List[float] = None
+			self.Margin_Curr_Neg_Y: List[float] = None
 
-	def fetch(self, segment=repcap.Segment.Default, secondaryCC=repcap.SecondaryCC.Default) -> FetchStruct:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:IEMission:SCC<c>:MARGin:EXTReme:RBINdex \n
-		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.inbandEmission.scc.margin.extreme.rbIndex.fetch(segment = repcap.Segment.Default, secondaryCC = repcap.SecondaryCC.Default) \n
-		No command help available \n
+	def fetch(self, segment=repcap.Segment.Default) -> FetchStruct:
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:SEMask:MARGin:CURRent:NEGativ \n
+		Snippet: value: FetchStruct = driver.lteMeas.multiEval.listPy.segment.seMask.margin.current.negativ.fetch(segment = repcap.Segment.Default) \n
+		Return spectrum emission mask margin results for segment <no> in list mode. The individual commands provide results for
+		the CURRent, AVERage and maximum traces (resulting in MINimum margins) for NEGative and POSitive offset frequencies.
+		Returned sequence: <Reliability>, <SegReliability>, <StatistExpired>, <OutOfTolerance>, {<MarginX>, <MarginY>}area1, {...
+		}area2, ..., {...}area12 \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
-			:param secondaryCC: optional repeated capability selector. Default value: CC1 (settable in the interface 'Scc')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
-		secondaryCC_cmd_val = self._base.get_repcap_cmd_value(secondaryCC, repcap.SecondaryCC)
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:IEMission:SCC{secondaryCC_cmd_val}:MARGin:EXTReme:RBINdex?', self.__class__.FetchStruct())
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:SEMask:MARGin:CURRent:NEGativ?', self.__class__.FetchStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/InbandEmission_/Scc_/Margin_/StandardDev.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Pmonitor/Scc/StandardDev.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,48 +1,44 @@
-from ........Internal.Core import Core
-from ........Internal.CommandsGroup import CommandsGroup
-from ........Internal.StructBase import StructBase
-from ........Internal.ArgStruct import ArgStruct
-from ........ import repcap
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal.StructBase import StructBase
+from ......Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class StandardDev:
-	"""StandardDev commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class StandardDevCls:
+	"""StandardDev commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("standardDev", core, parent)
+		self._cmd_group = CommandsGroup("standardDev", core, parent)
 
 	# noinspection PyTypeChecker
-	class FetchStruct(StructBase):
+	class ResultData(StructBase):
 		"""Response structure. Fields: \n
 			- Reliability: int: No parameter help available
-			- Seg_Reliability: int: No parameter help available
-			- Statist_Expired: int: No parameter help available
 			- Out_Of_Tolerance: int: No parameter help available
-			- Margin: float: No parameter help available"""
+			- Tx_Power: float: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_int('Seg_Reliability'),
-			ArgStruct.scalar_int('Statist_Expired'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
-			ArgStruct.scalar_float('Margin')]
+			ArgStruct.scalar_float('Tx_Power')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
-			self.Seg_Reliability: int = None
-			self.Statist_Expired: int = None
 			self.Out_Of_Tolerance: int = None
-			self.Margin: float = None
+			self.Tx_Power: float = None
 
-	def fetch(self, segment=repcap.Segment.Default, secondaryCC=repcap.SecondaryCC.Default) -> FetchStruct:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:IEMission:SCC<c>:MARGin:SDEViation \n
-		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.inbandEmission.scc.margin.standardDev.fetch(segment = repcap.Segment.Default, secondaryCC = repcap.SecondaryCC.Default) \n
+	def read(self) -> ResultData:
+		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:PMONitor:SCC:SDEViation \n
+		Snippet: value: ResultData = driver.lteMeas.multiEval.pmonitor.scc.standardDev.read() \n
 		No command help available \n
-			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
-			:param secondaryCC: optional repeated capability selector. Default value: CC1 (settable in the interface 'Scc')
-			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
-		secondaryCC_cmd_val = self._base.get_repcap_cmd_value(secondaryCC, repcap.SecondaryCC)
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:IEMission:SCC{secondaryCC_cmd_val}:MARGin:SDEViation?', self.__class__.FetchStruct())
+			:return: structure: for return value, see the help for ResultData structure arguments."""
+		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:PMONitor:SCC:SDEViation?', self.__class__.ResultData())
+
+	def fetch(self) -> ResultData:
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:PMONitor:SCC:SDEViation \n
+		Snippet: value: ResultData = driver.lteMeas.multiEval.pmonitor.scc.standardDev.fetch() \n
+		No command help available \n
+			:return: structure: for return value, see the help for ResultData structure arguments."""
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:PMONitor:SCC:SDEViation?', self.__class__.ResultData())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/Modulation.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/Modulation/__init__.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,83 +1,83 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Modulation:
-	"""Modulation commands group definition. 17 total commands, 8 Sub-groups, 0 group commands"""
+class ModulationCls:
+	"""Modulation commands group definition. 17 total commands, 8 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("modulation", core, parent)
+		self._cmd_group = CommandsGroup("modulation", core, parent)
 
 	@property
 	def average(self):
 		"""average commands group. 5 Sub-classes, 2 commands."""
 		if not hasattr(self, '_average'):
-			from .Modulation_.Average import Average
-			self._average = Average(self._core, self._base)
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
 		return self._average
 
 	@property
 	def current(self):
 		"""current commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_current'):
-			from .Modulation_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
 	@property
 	def extreme(self):
 		"""extreme commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_extreme'):
-			from .Modulation_.Extreme import Extreme
-			self._extreme = Extreme(self._core, self._base)
+			from .Extreme import ExtremeCls
+			self._extreme = ExtremeCls(self._core, self._cmd_group)
 		return self._extreme
 
 	@property
 	def standardDev(self):
 		"""standardDev commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_standardDev'):
-			from .Modulation_.StandardDev import StandardDev
-			self._standardDev = StandardDev(self._core, self._base)
+			from .StandardDev import StandardDevCls
+			self._standardDev = StandardDevCls(self._core, self._cmd_group)
 		return self._standardDev
 
 	@property
 	def dmodulation(self):
 		"""dmodulation commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_dmodulation'):
-			from .Modulation_.Dmodulation import Dmodulation
-			self._dmodulation = Dmodulation(self._core, self._base)
+			from .Dmodulation import DmodulationCls
+			self._dmodulation = DmodulationCls(self._core, self._cmd_group)
 		return self._dmodulation
 
 	@property
 	def dchType(self):
 		"""dchType commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_dchType'):
-			from .Modulation_.DchType import DchType
-			self._dchType = DchType(self._core, self._base)
+			from .DchType import DchTypeCls
+			self._dchType = DchTypeCls(self._core, self._cmd_group)
 		return self._dchType
 
 	@property
 	def schType(self):
 		"""schType commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_schType'):
-			from .Modulation_.SchType import SchType
-			self._schType = SchType(self._core, self._base)
+			from .SchType import SchTypeCls
+			self._schType = SchTypeCls(self._core, self._cmd_group)
 		return self._schType
 
 	@property
 	def dallocation(self):
 		"""dallocation commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_dallocation'):
-			from .Modulation_.Dallocation import Dallocation
-			self._dallocation = Dallocation(self._core, self._base)
+			from .Dallocation import DallocationCls
+			self._dallocation = DallocationCls(self._core, self._cmd_group)
 		return self._dallocation
 
-	def clone(self) -> 'Modulation':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'ModulationCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Modulation(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = ModulationCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/Modulation_/Average.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Modulation/Extreme.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,97 +1,56 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.StructBase import StructBase
-from ......Internal.ArgStruct import ArgStruct
-from ...... import repcap
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
+from .....Internal.StructBase import StructBase
+from .....Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 7 total commands, 5 Sub-groups, 2 group commands"""
+class ExtremeCls:
+	"""Extreme commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
-
-	@property
-	def mod(self):
-		"""mod commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_mod'):
-			from .Average_.Mod import Mod
-			self._mod = Mod(self._core, self._base)
-		return self._mod
-
-	@property
-	def pow(self):
-		"""pow commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_pow'):
-			from .Average_.Pow import Pow
-			self._pow = Pow(self._core, self._base)
-		return self._pow
-
-	@property
-	def dmrs(self):
-		"""dmrs commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_dmrs'):
-			from .Average_.Dmrs import Dmrs
-			self._dmrs = Dmrs(self._core, self._base)
-		return self._dmrs
-
-	@property
-	def emph(self):
-		"""emph commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_emph'):
-			from .Average_.Emph import Emph
-			self._emph = Emph(self._core, self._base)
-		return self._emph
-
-	@property
-	def globale(self):
-		"""globale commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_globale'):
-			from .Average_.Globale import Globale
-			self._globale = Globale(self._core, self._base)
-		return self._globale
+		self._cmd_group = CommandsGroup("extreme", core, parent)
 
 	# noinspection PyTypeChecker
-	class FetchStruct(StructBase):
+	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Seg_Reliability: int: Reliability indicator for the segment
-			- Statist_Expired: int: Reached statistical length in slots
-			- Out_Of_Tolerance: int: Percentage of measured subframes with failed limit check
+			- Out_Of_Tolerance: int: Out of tolerance result, i.e. the percentage of measurement intervals of the statistic count for modulation measurements exceeding the specified modulation limits.
 			- Evm_Rms_Low: float: EVM RMS value, low EVM window position
 			- Evm_Rms_High: float: EVM RMS value, high EVM window position
 			- Evm_Peak_Low: float: EVM peak value, low EVM window position
 			- Evm_Peak_High: float: EVM peak value, high EVM window position
 			- Mag_Error_Rms_Low: float: Magnitude error RMS value, low EVM window position
 			- Mag_Error_Rms_High: float: Magnitude error RMS value, low EVM window position
 			- Mag_Error_Peak_Low: float: Magnitude error peak value, low EVM window position
 			- Mag_Err_Peak_High: float: Magnitude error peak value, high EVM window position
 			- Ph_Error_Rms_Low: float: Phase error RMS value, low EVM window position
 			- Ph_Error_Rms_High: float: Phase error RMS value, high EVM window position
 			- Ph_Error_Peak_Low: float: Phase error peak value, low EVM window position
 			- Ph_Error_Peak_High: float: Phase error peak value, high EVM window position
 			- Iq_Offset: float: I/Q origin offset
 			- Frequency_Error: float: Carrier frequency error
-			- Timing_Error: float: Transmit time error
-			- Tx_Power: float: User equipment power
-			- Peak_Power: float: User equipment peak power
-			- Psd: float: No parameter help available
+			- Timing_Error: float: Time error
+			- Tx_Power_Minimum: float: Minimum user equipment power
+			- Tx_Power_Maximum: float: Maximum user equipment power
+			- Peak_Power_Min: float: Minimum user equipment peak power
+			- Peak_Power_Max: float: Maximum user equipment peak power
+			- Psd_Minimum: float: No parameter help available
+			- Psd_Maximum: float: No parameter help available
 			- Evm_Dmrs_Low: float: EVM DMRS value, low EVM window position
 			- Evm_Dmrs_High: float: EVM DMRS value, high EVM window position
 			- Mag_Err_Dmrs_Low: float: Magnitude error DMRS value, low EVM window position
 			- Mag_Err_Dmrs_High: float: Magnitude error DMRS value, high EVM window position
 			- Ph_Error_Dmrs_Low: float: Phase error DMRS value, low EVM window position
-			- Ph_Error_Dmrs_High: float: Phase error DMRS value, high EVM window position"""
+			- Ph_Error_Dmrs_High: float: Phase error DMRS value, high EVM window position
+			- Iq_Gain_Imbalance: float: Gain imbalance
+			- Iq_Quadrature_Err: float: Quadrature error
+			- Evm_Srs: float: Error vector magnitude for SRS signals"""
 		__meta_args_list = [
-			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_int('Seg_Reliability'),
-			ArgStruct.scalar_int('Statist_Expired'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
 			ArgStruct.scalar_float('Evm_Rms_Low'),
 			ArgStruct.scalar_float('Evm_Rms_High'),
 			ArgStruct.scalar_float('Evm_Peak_Low'),
 			ArgStruct.scalar_float('Evm_Peak_High'),
 			ArgStruct.scalar_float('Mag_Error_Rms_Low'),
 			ArgStruct.scalar_float('Mag_Error_Rms_High'),
@@ -100,29 +59,32 @@
 			ArgStruct.scalar_float('Ph_Error_Rms_Low'),
 			ArgStruct.scalar_float('Ph_Error_Rms_High'),
 			ArgStruct.scalar_float('Ph_Error_Peak_Low'),
 			ArgStruct.scalar_float('Ph_Error_Peak_High'),
 			ArgStruct.scalar_float('Iq_Offset'),
 			ArgStruct.scalar_float('Frequency_Error'),
 			ArgStruct.scalar_float('Timing_Error'),
-			ArgStruct.scalar_float('Tx_Power'),
-			ArgStruct.scalar_float('Peak_Power'),
-			ArgStruct.scalar_float('Psd'),
+			ArgStruct.scalar_float('Tx_Power_Minimum'),
+			ArgStruct.scalar_float('Tx_Power_Maximum'),
+			ArgStruct.scalar_float('Peak_Power_Min'),
+			ArgStruct.scalar_float('Peak_Power_Max'),
+			ArgStruct.scalar_float('Psd_Minimum'),
+			ArgStruct.scalar_float('Psd_Maximum'),
 			ArgStruct.scalar_float('Evm_Dmrs_Low'),
 			ArgStruct.scalar_float('Evm_Dmrs_High'),
 			ArgStruct.scalar_float('Mag_Err_Dmrs_Low'),
 			ArgStruct.scalar_float('Mag_Err_Dmrs_High'),
 			ArgStruct.scalar_float('Ph_Error_Dmrs_Low'),
-			ArgStruct.scalar_float('Ph_Error_Dmrs_High')]
+			ArgStruct.scalar_float('Ph_Error_Dmrs_High'),
+			ArgStruct.scalar_float('Iq_Gain_Imbalance'),
+			ArgStruct.scalar_float('Iq_Quadrature_Err'),
+			ArgStruct.scalar_float('Evm_Srs')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
-			self.Reliability: int = None
-			self.Seg_Reliability: int = None
-			self.Statist_Expired: int = None
 			self.Out_Of_Tolerance: int = None
 			self.Evm_Rms_Low: float = None
 			self.Evm_Rms_High: float = None
 			self.Evm_Peak_Low: float = None
 			self.Evm_Peak_High: float = None
 			self.Mag_Error_Rms_Low: float = None
 			self.Mag_Error_Rms_High: float = None
@@ -131,138 +93,150 @@
 			self.Ph_Error_Rms_Low: float = None
 			self.Ph_Error_Rms_High: float = None
 			self.Ph_Error_Peak_Low: float = None
 			self.Ph_Error_Peak_High: float = None
 			self.Iq_Offset: float = None
 			self.Frequency_Error: float = None
 			self.Timing_Error: float = None
-			self.Tx_Power: float = None
-			self.Peak_Power: float = None
-			self.Psd: float = None
+			self.Tx_Power_Minimum: float = None
+			self.Tx_Power_Maximum: float = None
+			self.Peak_Power_Min: float = None
+			self.Peak_Power_Max: float = None
+			self.Psd_Minimum: float = None
+			self.Psd_Maximum: float = None
 			self.Evm_Dmrs_Low: float = None
 			self.Evm_Dmrs_High: float = None
 			self.Mag_Err_Dmrs_Low: float = None
 			self.Mag_Err_Dmrs_High: float = None
 			self.Ph_Error_Dmrs_Low: float = None
 			self.Ph_Error_Dmrs_High: float = None
-
-	def fetch(self, segment=repcap.Segment.Default) -> FetchStruct:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:MODulation:AVERage \n
-		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.modulation.average.fetch(segment = repcap.Segment.Default) \n
-		Returns modulation single value results for segment <no> in list mode. The values described below are returned by FETCh
-		commands. The first four values (reliability to out-of-tolerance result) are also returned by CALCulate commands.
-		The remaining values returned by CALCulate commands are limit check results, one value for each result listed below. \n
-			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
-			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:MODulation:AVERage?', self.__class__.FetchStruct())
+			self.Iq_Gain_Imbalance: float = None
+			self.Iq_Quadrature_Err: float = None
+			self.Evm_Srs: float = None
+
+	def read(self) -> ResultData:
+		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:MODulation:EXTReme \n
+		Snippet: value: ResultData = driver.lteMeas.multiEval.modulation.extreme.read() \n
+		Return the extreme single value results. The values described below are returned by FETCh and READ commands. CALCulate
+		commands return limit check results instead, one value for each result listed below. \n
+		Suppressed linked return values: reliability \n
+			:return: structure: for return value, see the help for ResultData structure arguments."""
+		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:MODulation:EXTReme?', self.__class__.ResultData())
+
+	def fetch(self) -> ResultData:
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:MODulation:EXTReme \n
+		Snippet: value: ResultData = driver.lteMeas.multiEval.modulation.extreme.fetch() \n
+		Return the extreme single value results. The values described below are returned by FETCh and READ commands. CALCulate
+		commands return limit check results instead, one value for each result listed below. \n
+		Suppressed linked return values: reliability \n
+			:return: structure: for return value, see the help for ResultData structure arguments."""
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:MODulation:EXTReme?', self.__class__.ResultData())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Seg_Reliability: int: Reliability indicator for the segment
-			- Statist_Expired: int: Reached statistical length in slots
-			- Out_Of_Tolerance: int: Percentage of measured subframes with failed limit check
-			- Evm_Rms_Low: float: EVM RMS value, low EVM window position
-			- Evm_Rms_High: float: EVM RMS value, high EVM window position
-			- Evm_Peak_Low: float: EVM peak value, low EVM window position
-			- Evm_Peak_High: float: EVM peak value, high EVM window position
-			- Mag_Error_Rms_Low: float: Magnitude error RMS value, low EVM window position
-			- Mag_Error_Rms_High: float: Magnitude error RMS value, low EVM window position
-			- Mag_Error_Peak_Low: float: Magnitude error peak value, low EVM window position
-			- Mag_Err_Peak_High: float: Magnitude error peak value, high EVM window position
-			- Ph_Error_Rms_Low: float: Phase error RMS value, low EVM window position
-			- Ph_Error_Rms_High: float: Phase error RMS value, high EVM window position
-			- Ph_Error_Peak_Low: float: Phase error peak value, low EVM window position
-			- Ph_Error_Peak_High: float: Phase error peak value, high EVM window position
-			- Iq_Offset: float: I/Q origin offset
-			- Frequency_Error: float: Carrier frequency error
-			- Timing_Error: float: Transmit time error
-			- Tx_Power: float: User equipment power
-			- Peak_Power: float: User equipment peak power
-			- Psd: float: No parameter help available
-			- Evm_Dmrs_Low: float: EVM DMRS value, low EVM window position
-			- Evm_Dmrs_High: float: EVM DMRS value, high EVM window position
-			- Mag_Err_Dmrs_Low: float: Magnitude error DMRS value, low EVM window position
-			- Mag_Err_Dmrs_High: float: Magnitude error DMRS value, high EVM window position
-			- Ph_Error_Dmrs_Low: float: Phase error DMRS value, low EVM window position
-			- Ph_Error_Dmrs_High: float: Phase error DMRS value, high EVM window position"""
+			- Out_Of_Tolerance: int: Out of tolerance result, i.e. the percentage of measurement intervals of the statistic count for modulation measurements exceeding the specified modulation limits.
+			- Evm_Rms_Low: float or bool: EVM RMS value, low EVM window position
+			- Evm_Rms_High: float or bool: EVM RMS value, high EVM window position
+			- Evm_Peak_Low: float or bool: EVM peak value, low EVM window position
+			- Evm_Peak_High: float or bool: EVM peak value, high EVM window position
+			- Mag_Error_Rms_Low: float or bool: Magnitude error RMS value, low EVM window position
+			- Mag_Error_Rms_High: float or bool: Magnitude error RMS value, low EVM window position
+			- Mag_Error_Peak_Low: float or bool: Magnitude error peak value, low EVM window position
+			- Mag_Err_Peak_High: float or bool: Magnitude error peak value, high EVM window position
+			- Ph_Error_Rms_Low: float or bool: Phase error RMS value, low EVM window position
+			- Ph_Error_Rms_High: float or bool: Phase error RMS value, high EVM window position
+			- Ph_Error_Peak_Low: float or bool: Phase error peak value, low EVM window position
+			- Ph_Error_Peak_High: float or bool: Phase error peak value, high EVM window position
+			- Iq_Offset: float or bool: I/Q origin offset
+			- Frequency_Error: float or bool: Carrier frequency error
+			- Timing_Error: float or bool: Time error
+			- Tx_Power_Minimum: float or bool: Minimum user equipment power
+			- Tx_Power_Maximum: float or bool: Maximum user equipment power
+			- Peak_Power_Min: float or bool: Minimum user equipment peak power
+			- Peak_Power_Max: float or bool: Maximum user equipment peak power
+			- Psd_Minimum: float or bool: No parameter help available
+			- Psd_Maximum: float or bool: No parameter help available
+			- Evm_Dmrs_Low: float or bool: EVM DMRS value, low EVM window position
+			- Evm_Dmrs_High: float or bool: EVM DMRS value, high EVM window position
+			- Mag_Err_Dmrs_Low: float or bool: Magnitude error DMRS value, low EVM window position
+			- Mag_Err_Dmrs_High: float or bool: Magnitude error DMRS value, high EVM window position
+			- Ph_Error_Dmrs_Low: float or bool: Phase error DMRS value, low EVM window position
+			- Ph_Error_Dmrs_High: float or bool: Phase error DMRS value, high EVM window position
+			- Iq_Gain_Imbalance: float or bool: Gain imbalance
+			- Iq_Quadrature_Err: float or bool: Quadrature error
+			- Evm_Srs: float: Error vector magnitude for SRS signals"""
 		__meta_args_list = [
-			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_int('Seg_Reliability'),
-			ArgStruct.scalar_int('Statist_Expired'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
-			ArgStruct.scalar_float('Evm_Rms_Low'),
-			ArgStruct.scalar_float('Evm_Rms_High'),
-			ArgStruct.scalar_float('Evm_Peak_Low'),
-			ArgStruct.scalar_float('Evm_Peak_High'),
-			ArgStruct.scalar_float('Mag_Error_Rms_Low'),
-			ArgStruct.scalar_float('Mag_Error_Rms_High'),
-			ArgStruct.scalar_float('Mag_Error_Peak_Low'),
-			ArgStruct.scalar_float('Mag_Err_Peak_High'),
-			ArgStruct.scalar_float('Ph_Error_Rms_Low'),
-			ArgStruct.scalar_float('Ph_Error_Rms_High'),
-			ArgStruct.scalar_float('Ph_Error_Peak_Low'),
-			ArgStruct.scalar_float('Ph_Error_Peak_High'),
-			ArgStruct.scalar_float('Iq_Offset'),
-			ArgStruct.scalar_float('Frequency_Error'),
-			ArgStruct.scalar_float('Timing_Error'),
-			ArgStruct.scalar_float('Tx_Power'),
-			ArgStruct.scalar_float('Peak_Power'),
-			ArgStruct.scalar_float('Psd'),
-			ArgStruct.scalar_float('Evm_Dmrs_Low'),
-			ArgStruct.scalar_float('Evm_Dmrs_High'),
-			ArgStruct.scalar_float('Mag_Err_Dmrs_Low'),
-			ArgStruct.scalar_float('Mag_Err_Dmrs_High'),
-			ArgStruct.scalar_float('Ph_Error_Dmrs_Low'),
-			ArgStruct.scalar_float('Ph_Error_Dmrs_High')]
+			ArgStruct.scalar_float_ext('Evm_Rms_Low'),
+			ArgStruct.scalar_float_ext('Evm_Rms_High'),
+			ArgStruct.scalar_float_ext('Evm_Peak_Low'),
+			ArgStruct.scalar_float_ext('Evm_Peak_High'),
+			ArgStruct.scalar_float_ext('Mag_Error_Rms_Low'),
+			ArgStruct.scalar_float_ext('Mag_Error_Rms_High'),
+			ArgStruct.scalar_float_ext('Mag_Error_Peak_Low'),
+			ArgStruct.scalar_float_ext('Mag_Err_Peak_High'),
+			ArgStruct.scalar_float_ext('Ph_Error_Rms_Low'),
+			ArgStruct.scalar_float_ext('Ph_Error_Rms_High'),
+			ArgStruct.scalar_float_ext('Ph_Error_Peak_Low'),
+			ArgStruct.scalar_float_ext('Ph_Error_Peak_High'),
+			ArgStruct.scalar_float_ext('Iq_Offset'),
+			ArgStruct.scalar_float_ext('Frequency_Error'),
+			ArgStruct.scalar_float_ext('Timing_Error'),
+			ArgStruct.scalar_float_ext('Tx_Power_Minimum'),
+			ArgStruct.scalar_float_ext('Tx_Power_Maximum'),
+			ArgStruct.scalar_float_ext('Peak_Power_Min'),
+			ArgStruct.scalar_float_ext('Peak_Power_Max'),
+			ArgStruct.scalar_float_ext('Psd_Minimum'),
+			ArgStruct.scalar_float_ext('Psd_Maximum'),
+			ArgStruct.scalar_float_ext('Evm_Dmrs_Low'),
+			ArgStruct.scalar_float_ext('Evm_Dmrs_High'),
+			ArgStruct.scalar_float_ext('Mag_Err_Dmrs_Low'),
+			ArgStruct.scalar_float_ext('Mag_Err_Dmrs_High'),
+			ArgStruct.scalar_float_ext('Ph_Error_Dmrs_Low'),
+			ArgStruct.scalar_float_ext('Ph_Error_Dmrs_High'),
+			ArgStruct.scalar_float_ext('Iq_Gain_Imbalance'),
+			ArgStruct.scalar_float_ext('Iq_Quadrature_Err'),
+			ArgStruct.scalar_float('Evm_Srs')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
-			self.Reliability: int = None
-			self.Seg_Reliability: int = None
-			self.Statist_Expired: int = None
 			self.Out_Of_Tolerance: int = None
-			self.Evm_Rms_Low: float = None
-			self.Evm_Rms_High: float = None
-			self.Evm_Peak_Low: float = None
-			self.Evm_Peak_High: float = None
-			self.Mag_Error_Rms_Low: float = None
-			self.Mag_Error_Rms_High: float = None
-			self.Mag_Error_Peak_Low: float = None
-			self.Mag_Err_Peak_High: float = None
-			self.Ph_Error_Rms_Low: float = None
-			self.Ph_Error_Rms_High: float = None
-			self.Ph_Error_Peak_Low: float = None
-			self.Ph_Error_Peak_High: float = None
-			self.Iq_Offset: float = None
-			self.Frequency_Error: float = None
-			self.Timing_Error: float = None
-			self.Tx_Power: float = None
-			self.Peak_Power: float = None
-			self.Psd: float = None
-			self.Evm_Dmrs_Low: float = None
-			self.Evm_Dmrs_High: float = None
-			self.Mag_Err_Dmrs_Low: float = None
-			self.Mag_Err_Dmrs_High: float = None
-			self.Ph_Error_Dmrs_Low: float = None
-			self.Ph_Error_Dmrs_High: float = None
-
-	def calculate(self, segment=repcap.Segment.Default) -> CalculateStruct:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:MODulation:AVERage \n
-		Snippet: value: CalculateStruct = driver.multiEval.listPy.segment.modulation.average.calculate(segment = repcap.Segment.Default) \n
-		Returns modulation single value results for segment <no> in list mode. The values described below are returned by FETCh
-		commands. The first four values (reliability to out-of-tolerance result) are also returned by CALCulate commands.
-		The remaining values returned by CALCulate commands are limit check results, one value for each result listed below. \n
-			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
+			self.Evm_Rms_Low: float or bool = None
+			self.Evm_Rms_High: float or bool = None
+			self.Evm_Peak_Low: float or bool = None
+			self.Evm_Peak_High: float or bool = None
+			self.Mag_Error_Rms_Low: float or bool = None
+			self.Mag_Error_Rms_High: float or bool = None
+			self.Mag_Error_Peak_Low: float or bool = None
+			self.Mag_Err_Peak_High: float or bool = None
+			self.Ph_Error_Rms_Low: float or bool = None
+			self.Ph_Error_Rms_High: float or bool = None
+			self.Ph_Error_Peak_Low: float or bool = None
+			self.Ph_Error_Peak_High: float or bool = None
+			self.Iq_Offset: float or bool = None
+			self.Frequency_Error: float or bool = None
+			self.Timing_Error: float or bool = None
+			self.Tx_Power_Minimum: float or bool = None
+			self.Tx_Power_Maximum: float or bool = None
+			self.Peak_Power_Min: float or bool = None
+			self.Peak_Power_Max: float or bool = None
+			self.Psd_Minimum: float or bool = None
+			self.Psd_Maximum: float or bool = None
+			self.Evm_Dmrs_Low: float or bool = None
+			self.Evm_Dmrs_High: float or bool = None
+			self.Mag_Err_Dmrs_Low: float or bool = None
+			self.Mag_Err_Dmrs_High: float or bool = None
+			self.Ph_Error_Dmrs_Low: float or bool = None
+			self.Ph_Error_Dmrs_High: float or bool = None
+			self.Iq_Gain_Imbalance: float or bool = None
+			self.Iq_Quadrature_Err: float or bool = None
+			self.Evm_Srs: float = None
+
+	def calculate(self) -> CalculateStruct:
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:MODulation:EXTReme \n
+		Snippet: value: CalculateStruct = driver.lteMeas.multiEval.modulation.extreme.calculate() \n
+		Return the extreme single value results. The values described below are returned by FETCh and READ commands. CALCulate
+		commands return limit check results instead, one value for each result listed below. \n
+		Suppressed linked return values: reliability \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
-		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:MODulation:AVERage?', self.__class__.CalculateStruct())
-
-	def clone(self) -> 'Average':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
-		Also copies all the existing default Repeated Capabilities setting,
-		which you can change independently without affecting the original group"""
-		new_group = Average(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
-		return new_group
+		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:MODulation:EXTReme?', self.__class__.CalculateStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/Modulation_/Average_/Dmrs.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/Modulation/Average/Dmrs.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,21 +1,21 @@
-from .......Internal.Core import Core
-from .......Internal.CommandsGroup import CommandsGroup
-from .......Internal.StructBase import StructBase
-from .......Internal.ArgStruct import ArgStruct
-from ....... import repcap
+from ........Internal.Core import Core
+from ........Internal.CommandsGroup import CommandsGroup
+from ........Internal.StructBase import StructBase
+from ........Internal.ArgStruct import ArgStruct
+from ........ import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Dmrs:
-	"""Dmrs commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class DmrsCls:
+	"""Dmrs commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("dmrs", core, parent)
+		self._cmd_group = CommandsGroup("dmrs", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
 			- Reliability: int: No parameter help available
 			- Evm_Dmrs_Low: float: No parameter help available
 			- Evm_Dmrs_High: float: No parameter help available
@@ -40,13 +40,13 @@
 			self.Mag_Err_Dmrs_Low: float = None
 			self.Mag_Err_Dmrs_High: float = None
 			self.Ph_Error_Dmrs_Low: float = None
 			self.Ph_Error_Dmrs_High: float = None
 
 	def fetch(self, segment=repcap.Segment.Default) -> FetchStruct:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:MODulation:AVERage:DMRS \n
-		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.modulation.average.dmrs.fetch(segment = repcap.Segment.Default) \n
+		Snippet: value: FetchStruct = driver.lteMeas.multiEval.listPy.segment.modulation.average.dmrs.fetch(segment = repcap.Segment.Default) \n
 		No command help available \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:MODulation:AVERage:DMRS?', self.__class__.FetchStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/Modulation_/Average_/Emph.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/Modulation/Average/Emph.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,21 +1,21 @@
-from .......Internal.Core import Core
-from .......Internal.CommandsGroup import CommandsGroup
-from .......Internal.StructBase import StructBase
-from .......Internal.ArgStruct import ArgStruct
-from ....... import repcap
+from ........Internal.Core import Core
+from ........Internal.CommandsGroup import CommandsGroup
+from ........Internal.StructBase import StructBase
+from ........Internal.ArgStruct import ArgStruct
+from ........ import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Emph:
-	"""Emph commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class EmphCls:
+	"""Emph commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("emph", core, parent)
+		self._cmd_group = CommandsGroup("emph", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
 			- Reliability: int: No parameter help available
 			- Evm_Rms_Low: float: No parameter help available
 			- Evm_Rms_High: float: No parameter help available
@@ -58,13 +58,13 @@
 			self.Ph_Error_Rms_Low: float = None
 			self.Ph_Error_Rms_High: float = None
 			self.Ph_Error_Peak_Low: float = None
 			self.Ph_Error_Peak_High: float = None
 
 	def fetch(self, segment=repcap.Segment.Default) -> FetchStruct:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:MODulation:AVERage:EMPH \n
-		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.modulation.average.emph.fetch(segment = repcap.Segment.Default) \n
+		Snippet: value: FetchStruct = driver.lteMeas.multiEval.listPy.segment.modulation.average.emph.fetch(segment = repcap.Segment.Default) \n
 		No command help available \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:MODulation:AVERage:EMPH?', self.__class__.FetchStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/Modulation_/Average_/Globale.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/Modulation/Dallocation.py`

 * *Files 18% similar despite different names*

```diff
@@ -2,42 +2,44 @@
 from .......Internal.CommandsGroup import CommandsGroup
 from .......Internal.StructBase import StructBase
 from .......Internal.ArgStruct import ArgStruct
 from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Globale:
-	"""Globale commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class DallocationCls:
+	"""Dallocation commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("globale", core, parent)
+		self._cmd_group = CommandsGroup("dallocation", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: No parameter help available
-			- Seg_Reliability: int: No parameter help available
-			- Statist_Expired: int: No parameter help available
-			- Out_Of_Tolerance: int: No parameter help available"""
+			- Reliability: int: 'Reliability indicator'
+			- Seg_Reliability: int: Reliability indicator for the segment
+			- Nr_Res_Blocks: int: Number of allocated resource blocks
+			- Offset_Res_Blocks: int: Offset of the first allocated resource block from the edge of the allocated UL transmission bandwidth"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Seg_Reliability'),
-			ArgStruct.scalar_int('Statist_Expired'),
-			ArgStruct.scalar_int('Out_Of_Tolerance')]
+			ArgStruct.scalar_int('Nr_Res_Blocks'),
+			ArgStruct.scalar_int('Offset_Res_Blocks')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Seg_Reliability: int = None
-			self.Statist_Expired: int = None
-			self.Out_Of_Tolerance: int = None
+			self.Nr_Res_Blocks: int = None
+			self.Offset_Res_Blocks: int = None
 
 	def fetch(self, segment=repcap.Segment.Default) -> FetchStruct:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:MODulation:AVERage:GLOBal \n
-		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.modulation.average.globale.fetch(segment = repcap.Segment.Default) \n
-		No command help available \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:MODulation:DALLocation \n
+		Snippet: value: FetchStruct = driver.lteMeas.multiEval.listPy.segment.modulation.dallocation.fetch(segment = repcap.Segment.Default) \n
+		Return the detected allocation for segment <no> in list mode. The result is determined from the last measured slot of the
+		statistical length. The individual measurements provide the same result when measuring the same slot. However different
+		statistical lengths can be defined for the measurements so that the measured slots and returned results can differ. \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:MODulation:AVERage:GLOBal?', self.__class__.FetchStruct())
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:MODulation:DALLocation?', self.__class__.FetchStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/Modulation_/Average_/Mod.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Pmonitor/Ulca/Pcc/StandardDev.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,43 +1,44 @@
 from .......Internal.Core import Core
 from .......Internal.CommandsGroup import CommandsGroup
 from .......Internal.StructBase import StructBase
 from .......Internal.ArgStruct import ArgStruct
-from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Mod:
-	"""Mod commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class StandardDevCls:
+	"""StandardDev commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("mod", core, parent)
+		self._cmd_group = CommandsGroup("standardDev", core, parent)
 
 	# noinspection PyTypeChecker
-	class FetchStruct(StructBase):
+	class ResultData(StructBase):
 		"""Response structure. Fields: \n
 			- Reliability: int: No parameter help available
-			- Iq_Offset: float: No parameter help available
-			- Frequency_Error: float: No parameter help available
-			- Timing_Error: float: No parameter help available"""
+			- Out_Of_Tolerance: int: No parameter help available
+			- Tx_Power: float: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_float('Iq_Offset'),
-			ArgStruct.scalar_float('Frequency_Error'),
-			ArgStruct.scalar_float('Timing_Error')]
+			ArgStruct.scalar_int('Out_Of_Tolerance'),
+			ArgStruct.scalar_float('Tx_Power')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
-			self.Iq_Offset: float = None
-			self.Frequency_Error: float = None
-			self.Timing_Error: float = None
-
-	def fetch(self, segment=repcap.Segment.Default) -> FetchStruct:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:MODulation:AVERage:MOD \n
-		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.modulation.average.mod.fetch(segment = repcap.Segment.Default) \n
+			self.Out_Of_Tolerance: int = None
+			self.Tx_Power: float = None
+
+	def read(self) -> ResultData:
+		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:PMONitor:ULCA:PCC:SDEViation \n
+		Snippet: value: ResultData = driver.lteMeas.multiEval.pmonitor.ulca.pcc.standardDev.read() \n
+		No command help available \n
+			:return: structure: for return value, see the help for ResultData structure arguments."""
+		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:PMONitor:ULCA:PCC:SDEViation?', self.__class__.ResultData())
+
+	def fetch(self) -> ResultData:
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:PMONitor:ULCA:PCC:SDEViation \n
+		Snippet: value: ResultData = driver.lteMeas.multiEval.pmonitor.ulca.pcc.standardDev.fetch() \n
 		No command help available \n
-			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
-			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:MODulation:AVERage:MOD?', self.__class__.FetchStruct())
+			:return: structure: for return value, see the help for ResultData structure arguments."""
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:PMONitor:ULCA:PCC:SDEViation?', self.__class__.ResultData())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/Modulation_/Average_/Pow.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Pmonitor/Ulca/Scc/Minimum.py`

 * *Files 23% similar despite different names*

```diff
@@ -2,42 +2,48 @@
 from .......Internal.CommandsGroup import CommandsGroup
 from .......Internal.StructBase import StructBase
 from .......Internal.ArgStruct import ArgStruct
 from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Pow:
-	"""Pow commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class MinimumCls:
+	"""Minimum commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("pow", core, parent)
+		self._cmd_group = CommandsGroup("minimum", core, parent)
 
 	# noinspection PyTypeChecker
-	class FetchStruct(StructBase):
+	class ResultData(StructBase):
 		"""Response structure. Fields: \n
 			- Reliability: int: No parameter help available
-			- Tx_Power: float: No parameter help available
-			- Peak_Power: float: No parameter help available
-			- Psd: float: No parameter help available"""
+			- Out_Of_Tolerance: int: No parameter help available
+			- Tx_Power: float: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_float('Tx_Power'),
-			ArgStruct.scalar_float('Peak_Power'),
-			ArgStruct.scalar_float('Psd')]
+			ArgStruct.scalar_int('Out_Of_Tolerance'),
+			ArgStruct.scalar_float('Tx_Power')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
+			self.Out_Of_Tolerance: int = None
 			self.Tx_Power: float = None
-			self.Peak_Power: float = None
-			self.Psd: float = None
 
-	def fetch(self, segment=repcap.Segment.Default) -> FetchStruct:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:MODulation:AVERage:POW \n
-		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.modulation.average.pow.fetch(segment = repcap.Segment.Default) \n
+	def read(self, secondaryCC=repcap.SecondaryCC.Default) -> ResultData:
+		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:PMONitor:ULCA:SCC<Nr>:MINimum \n
+		Snippet: value: ResultData = driver.lteMeas.multiEval.pmonitor.ulca.scc.minimum.read(secondaryCC = repcap.SecondaryCC.Default) \n
 		No command help available \n
-			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
-			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:MODulation:AVERage:POW?', self.__class__.FetchStruct())
+			:param secondaryCC: optional repeated capability selector. Default value: CC1 (settable in the interface 'Scc')
+			:return: structure: for return value, see the help for ResultData structure arguments."""
+		secondaryCC_cmd_val = self._cmd_group.get_repcap_cmd_value(secondaryCC, repcap.SecondaryCC)
+		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:PMONitor:ULCA:SCC{secondaryCC_cmd_val}:MINimum?', self.__class__.ResultData())
+
+	def fetch(self, secondaryCC=repcap.SecondaryCC.Default) -> ResultData:
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:PMONitor:ULCA:SCC<Nr>:MINimum \n
+		Snippet: value: ResultData = driver.lteMeas.multiEval.pmonitor.ulca.scc.minimum.fetch(secondaryCC = repcap.SecondaryCC.Default) \n
+		No command help available \n
+			:param secondaryCC: optional repeated capability selector. Default value: CC1 (settable in the interface 'Scc')
+			:return: structure: for return value, see the help for ResultData structure arguments."""
+		secondaryCC_cmd_val = self._cmd_group.get_repcap_cmd_value(secondaryCC, repcap.SecondaryCC)
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:PMONitor:ULCA:SCC{secondaryCC_cmd_val}:MINimum?', self.__class__.ResultData())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/Modulation_/Current.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/Modulation/Current.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,26 +1,26 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.StructBase import StructBase
-from ......Internal.ArgStruct import ArgStruct
-from ...... import repcap
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal.StructBase import StructBase
+from .......Internal.ArgStruct import ArgStruct
+from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
+			- Reliability: int: 'Reliability indicator'
 			- Seg_Reliability: int: Reliability indicator for the segment
 			- Statist_Expired: int: Reached statistical length in slots
 			- Out_Of_Tolerance: int: Percentage of measured subframes with failed limit check
 			- Evm_Rms_Low: float: EVM RMS value, low EVM window position
 			- Evm_Rms_High: float: EVM RMS value, high EVM window position
 			- Evm_Peak_Low: float: EVM peak value, low EVM window position
 			- Evm_Peak_High: float: EVM peak value, high EVM window position
@@ -30,15 +30,15 @@
 			- Mag_Err_Peak_High: float: Magnitude error peak value, high EVM window position
 			- Ph_Error_Rms_Low: float: Phase error RMS value, low EVM window position
 			- Ph_Error_Rms_High: float: Phase error RMS value, high EVM window position
 			- Ph_Error_Peak_Low: float: Phase error peak value, low EVM window position
 			- Ph_Error_Peak_High: float: Phase error peak value, high EVM window position
 			- Iq_Offset: float: I/Q origin offset
 			- Frequency_Error: float: Carrier frequency error
-			- Timing_Error: float: Transmit time error
+			- Timing_Error: float: Time error
 			- Tx_Power: float: User equipment power
 			- Peak_Power: float: User equipment peak power
 			- Psd: float: No parameter help available
 			- Evm_Dmrs_Low: float: EVM DMRS value, low EVM window position
 			- Evm_Dmrs_High: float: EVM DMRS value, high EVM window position
 			- Mag_Err_Dmrs_Low: float: Magnitude error DMRS value, low EVM window position
 			- Mag_Err_Dmrs_High: float: Magnitude error DMRS value, high EVM window position
@@ -103,118 +103,118 @@
 			self.Mag_Err_Dmrs_Low: float = None
 			self.Mag_Err_Dmrs_High: float = None
 			self.Ph_Error_Dmrs_Low: float = None
 			self.Ph_Error_Dmrs_High: float = None
 
 	def fetch(self, segment=repcap.Segment.Default) -> FetchStruct:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:MODulation:CURRent \n
-		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.modulation.current.fetch(segment = repcap.Segment.Default) \n
-		Returns modulation single value results for segment <no> in list mode. The values described below are returned by FETCh
-		commands. The first four values (reliability to out-of-tolerance result) are also returned by CALCulate commands.
+		Snippet: value: FetchStruct = driver.lteMeas.multiEval.listPy.segment.modulation.current.fetch(segment = repcap.Segment.Default) \n
+		Returns modulation single-value results for segment <no> in list mode. The values described below are returned by FETCh
+		commands. The first four values (reliability to out of tolerance result) are also returned by CALCulate commands.
 		The remaining values returned by CALCulate commands are limit check results, one value for each result listed below. \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:MODulation:CURRent?', self.__class__.FetchStruct())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
+			- Reliability: int: 'Reliability indicator'
 			- Seg_Reliability: int: Reliability indicator for the segment
 			- Statist_Expired: int: Reached statistical length in slots
 			- Out_Of_Tolerance: int: Percentage of measured subframes with failed limit check
-			- Evm_Rms_Low: float: EVM RMS value, low EVM window position
-			- Evm_Rms_High: float: EVM RMS value, high EVM window position
-			- Evm_Peak_Low: float: EVM peak value, low EVM window position
-			- Evm_Peak_High: float: EVM peak value, high EVM window position
-			- Mag_Error_Rms_Low: float: Magnitude error RMS value, low EVM window position
-			- Mag_Error_Rms_High: float: Magnitude error RMS value, low EVM window position
-			- Mag_Error_Peak_Low: float: Magnitude error peak value, low EVM window position
-			- Mag_Err_Peak_High: float: Magnitude error peak value, high EVM window position
-			- Ph_Error_Rms_Low: float: Phase error RMS value, low EVM window position
-			- Ph_Error_Rms_High: float: Phase error RMS value, high EVM window position
-			- Ph_Error_Peak_Low: float: Phase error peak value, low EVM window position
-			- Ph_Error_Peak_High: float: Phase error peak value, high EVM window position
-			- Iq_Offset: float: I/Q origin offset
-			- Frequency_Error: float: Carrier frequency error
-			- Timing_Error: float: Transmit time error
-			- Tx_Power: float: User equipment power
-			- Peak_Power: float: User equipment peak power
-			- Psd: float: No parameter help available
-			- Evm_Dmrs_Low: float: EVM DMRS value, low EVM window position
-			- Evm_Dmrs_High: float: EVM DMRS value, high EVM window position
-			- Mag_Err_Dmrs_Low: float: Magnitude error DMRS value, low EVM window position
-			- Mag_Err_Dmrs_High: float: Magnitude error DMRS value, high EVM window position
-			- Ph_Error_Dmrs_Low: float: Phase error DMRS value, low EVM window position
-			- Ph_Error_Dmrs_High: float: Phase error DMRS value, high EVM window position"""
+			- Evm_Rms_Low: float or bool: EVM RMS value, low EVM window position
+			- Evm_Rms_High: float or bool: EVM RMS value, high EVM window position
+			- Evm_Peak_Low: float or bool: EVM peak value, low EVM window position
+			- Evm_Peak_High: float or bool: EVM peak value, high EVM window position
+			- Mag_Error_Rms_Low: float or bool: Magnitude error RMS value, low EVM window position
+			- Mag_Error_Rms_High: float or bool: Magnitude error RMS value, low EVM window position
+			- Mag_Error_Peak_Low: float or bool: Magnitude error peak value, low EVM window position
+			- Mag_Err_Peak_High: float or bool: Magnitude error peak value, high EVM window position
+			- Ph_Error_Rms_Low: float or bool: Phase error RMS value, low EVM window position
+			- Ph_Error_Rms_High: float or bool: Phase error RMS value, high EVM window position
+			- Ph_Error_Peak_Low: float or bool: Phase error peak value, low EVM window position
+			- Ph_Error_Peak_High: float or bool: Phase error peak value, high EVM window position
+			- Iq_Offset: float or bool: I/Q origin offset
+			- Frequency_Error: float or bool: Carrier frequency error
+			- Timing_Error: float or bool: Time error
+			- Tx_Power: float or bool: User equipment power
+			- Peak_Power: float or bool: User equipment peak power
+			- Psd: float or bool: No parameter help available
+			- Evm_Dmrs_Low: float or bool: EVM DMRS value, low EVM window position
+			- Evm_Dmrs_High: float or bool: EVM DMRS value, high EVM window position
+			- Mag_Err_Dmrs_Low: float or bool: Magnitude error DMRS value, low EVM window position
+			- Mag_Err_Dmrs_High: float or bool: Magnitude error DMRS value, high EVM window position
+			- Ph_Error_Dmrs_Low: float or bool: Phase error DMRS value, low EVM window position
+			- Ph_Error_Dmrs_High: float or bool: Phase error DMRS value, high EVM window position"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Seg_Reliability'),
 			ArgStruct.scalar_int('Statist_Expired'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
-			ArgStruct.scalar_float('Evm_Rms_Low'),
-			ArgStruct.scalar_float('Evm_Rms_High'),
-			ArgStruct.scalar_float('Evm_Peak_Low'),
-			ArgStruct.scalar_float('Evm_Peak_High'),
-			ArgStruct.scalar_float('Mag_Error_Rms_Low'),
-			ArgStruct.scalar_float('Mag_Error_Rms_High'),
-			ArgStruct.scalar_float('Mag_Error_Peak_Low'),
-			ArgStruct.scalar_float('Mag_Err_Peak_High'),
-			ArgStruct.scalar_float('Ph_Error_Rms_Low'),
-			ArgStruct.scalar_float('Ph_Error_Rms_High'),
-			ArgStruct.scalar_float('Ph_Error_Peak_Low'),
-			ArgStruct.scalar_float('Ph_Error_Peak_High'),
-			ArgStruct.scalar_float('Iq_Offset'),
-			ArgStruct.scalar_float('Frequency_Error'),
-			ArgStruct.scalar_float('Timing_Error'),
-			ArgStruct.scalar_float('Tx_Power'),
-			ArgStruct.scalar_float('Peak_Power'),
-			ArgStruct.scalar_float('Psd'),
-			ArgStruct.scalar_float('Evm_Dmrs_Low'),
-			ArgStruct.scalar_float('Evm_Dmrs_High'),
-			ArgStruct.scalar_float('Mag_Err_Dmrs_Low'),
-			ArgStruct.scalar_float('Mag_Err_Dmrs_High'),
-			ArgStruct.scalar_float('Ph_Error_Dmrs_Low'),
-			ArgStruct.scalar_float('Ph_Error_Dmrs_High')]
+			ArgStruct.scalar_float_ext('Evm_Rms_Low'),
+			ArgStruct.scalar_float_ext('Evm_Rms_High'),
+			ArgStruct.scalar_float_ext('Evm_Peak_Low'),
+			ArgStruct.scalar_float_ext('Evm_Peak_High'),
+			ArgStruct.scalar_float_ext('Mag_Error_Rms_Low'),
+			ArgStruct.scalar_float_ext('Mag_Error_Rms_High'),
+			ArgStruct.scalar_float_ext('Mag_Error_Peak_Low'),
+			ArgStruct.scalar_float_ext('Mag_Err_Peak_High'),
+			ArgStruct.scalar_float_ext('Ph_Error_Rms_Low'),
+			ArgStruct.scalar_float_ext('Ph_Error_Rms_High'),
+			ArgStruct.scalar_float_ext('Ph_Error_Peak_Low'),
+			ArgStruct.scalar_float_ext('Ph_Error_Peak_High'),
+			ArgStruct.scalar_float_ext('Iq_Offset'),
+			ArgStruct.scalar_float_ext('Frequency_Error'),
+			ArgStruct.scalar_float_ext('Timing_Error'),
+			ArgStruct.scalar_float_ext('Tx_Power'),
+			ArgStruct.scalar_float_ext('Peak_Power'),
+			ArgStruct.scalar_float_ext('Psd'),
+			ArgStruct.scalar_float_ext('Evm_Dmrs_Low'),
+			ArgStruct.scalar_float_ext('Evm_Dmrs_High'),
+			ArgStruct.scalar_float_ext('Mag_Err_Dmrs_Low'),
+			ArgStruct.scalar_float_ext('Mag_Err_Dmrs_High'),
+			ArgStruct.scalar_float_ext('Ph_Error_Dmrs_Low'),
+			ArgStruct.scalar_float_ext('Ph_Error_Dmrs_High')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Seg_Reliability: int = None
 			self.Statist_Expired: int = None
 			self.Out_Of_Tolerance: int = None
-			self.Evm_Rms_Low: float = None
-			self.Evm_Rms_High: float = None
-			self.Evm_Peak_Low: float = None
-			self.Evm_Peak_High: float = None
-			self.Mag_Error_Rms_Low: float = None
-			self.Mag_Error_Rms_High: float = None
-			self.Mag_Error_Peak_Low: float = None
-			self.Mag_Err_Peak_High: float = None
-			self.Ph_Error_Rms_Low: float = None
-			self.Ph_Error_Rms_High: float = None
-			self.Ph_Error_Peak_Low: float = None
-			self.Ph_Error_Peak_High: float = None
-			self.Iq_Offset: float = None
-			self.Frequency_Error: float = None
-			self.Timing_Error: float = None
-			self.Tx_Power: float = None
-			self.Peak_Power: float = None
-			self.Psd: float = None
-			self.Evm_Dmrs_Low: float = None
-			self.Evm_Dmrs_High: float = None
-			self.Mag_Err_Dmrs_Low: float = None
-			self.Mag_Err_Dmrs_High: float = None
-			self.Ph_Error_Dmrs_Low: float = None
-			self.Ph_Error_Dmrs_High: float = None
+			self.Evm_Rms_Low: float or bool = None
+			self.Evm_Rms_High: float or bool = None
+			self.Evm_Peak_Low: float or bool = None
+			self.Evm_Peak_High: float or bool = None
+			self.Mag_Error_Rms_Low: float or bool = None
+			self.Mag_Error_Rms_High: float or bool = None
+			self.Mag_Error_Peak_Low: float or bool = None
+			self.Mag_Err_Peak_High: float or bool = None
+			self.Ph_Error_Rms_Low: float or bool = None
+			self.Ph_Error_Rms_High: float or bool = None
+			self.Ph_Error_Peak_Low: float or bool = None
+			self.Ph_Error_Peak_High: float or bool = None
+			self.Iq_Offset: float or bool = None
+			self.Frequency_Error: float or bool = None
+			self.Timing_Error: float or bool = None
+			self.Tx_Power: float or bool = None
+			self.Peak_Power: float or bool = None
+			self.Psd: float or bool = None
+			self.Evm_Dmrs_Low: float or bool = None
+			self.Evm_Dmrs_High: float or bool = None
+			self.Mag_Err_Dmrs_Low: float or bool = None
+			self.Mag_Err_Dmrs_High: float or bool = None
+			self.Ph_Error_Dmrs_Low: float or bool = None
+			self.Ph_Error_Dmrs_High: float or bool = None
 
 	def calculate(self, segment=repcap.Segment.Default) -> CalculateStruct:
 		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:MODulation:CURRent \n
-		Snippet: value: CalculateStruct = driver.multiEval.listPy.segment.modulation.current.calculate(segment = repcap.Segment.Default) \n
-		Returns modulation single value results for segment <no> in list mode. The values described below are returned by FETCh
-		commands. The first four values (reliability to out-of-tolerance result) are also returned by CALCulate commands.
+		Snippet: value: CalculateStruct = driver.lteMeas.multiEval.listPy.segment.modulation.current.calculate(segment = repcap.Segment.Default) \n
+		Returns modulation single-value results for segment <no> in list mode. The values described below are returned by FETCh
+		commands. The first four values (reliability to out of tolerance result) are also returned by CALCulate commands.
 		The remaining values returned by CALCulate commands are limit check results, one value for each result listed below. \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:MODulation:CURRent?', self.__class__.CalculateStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/Modulation_/Dallocation.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/SeMask/Dallocation.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,26 +1,26 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.StructBase import StructBase
-from ......Internal.ArgStruct import ArgStruct
-from ...... import repcap
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal.StructBase import StructBase
+from .......Internal.ArgStruct import ArgStruct
+from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Dallocation:
-	"""Dallocation commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class DallocationCls:
+	"""Dallocation commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("dallocation", core, parent)
+		self._cmd_group = CommandsGroup("dallocation", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
+			- Reliability: int: 'Reliability indicator'
 			- Seg_Reliability: int: Reliability indicator for the segment
 			- Nr_Res_Blocks: int: Number of allocated resource blocks
 			- Offset_Res_Blocks: int: Offset of the first allocated resource block from the edge of the allocated UL transmission bandwidth"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Seg_Reliability'),
 			ArgStruct.scalar_int('Nr_Res_Blocks'),
@@ -30,17 +30,16 @@
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Seg_Reliability: int = None
 			self.Nr_Res_Blocks: int = None
 			self.Offset_Res_Blocks: int = None
 
 	def fetch(self, segment=repcap.Segment.Default) -> FetchStruct:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:MODulation:DALLocation \n
-		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.modulation.dallocation.fetch(segment = repcap.Segment.Default) \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:SEMask:DALLocation \n
+		Snippet: value: FetchStruct = driver.lteMeas.multiEval.listPy.segment.seMask.dallocation.fetch(segment = repcap.Segment.Default) \n
 		Return the detected allocation for segment <no> in list mode. The result is determined from the last measured slot of the
-		statistical length. The individual measurements provide identical detected allocation results when measuring the same
-		slot. However different statistical lengths can be defined for the measurements so that the measured slots and returned
-		results can differ. \n
+		statistical length. The individual measurements provide the same result when measuring the same slot. However different
+		statistical lengths can be defined for the measurements so that the measured slots and returned results can differ. \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:MODulation:DALLocation?', self.__class__.FetchStruct())
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:SEMask:DALLocation?', self.__class__.FetchStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/Modulation_/DchType.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/SeMask/DchType.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,44 +1,43 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.StructBase import StructBase
-from ......Internal.ArgStruct import ArgStruct
-from ...... import enums
-from ...... import repcap
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal.StructBase import StructBase
+from .......Internal.ArgStruct import ArgStruct
+from ....... import enums
+from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class DchType:
-	"""DchType commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class DchTypeCls:
+	"""DchType commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("dchType", core, parent)
+		self._cmd_group = CommandsGroup("dchType", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
+			- Reliability: int: 'Reliability indicator'
 			- Seg_Reliability: int: Reliability indicator for the segment
 			- Channel_Type: enums.UplinkChannelType: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Seg_Reliability'),
 			ArgStruct.scalar_enum('Channel_Type', enums.UplinkChannelType)]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Seg_Reliability: int = None
 			self.Channel_Type: enums.UplinkChannelType = None
 
 	def fetch(self, segment=repcap.Segment.Default) -> FetchStruct:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:MODulation:DCHType \n
-		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.modulation.dchType.fetch(segment = repcap.Segment.Default) \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:SEMask:DCHType \n
+		Snippet: value: FetchStruct = driver.lteMeas.multiEval.listPy.segment.seMask.dchType.fetch(segment = repcap.Segment.Default) \n
 		Return the uplink channel type for segment <no> in list mode. The result is determined from the last measured slot of the
-		statistical length. The individual measurements provide identical detected channel type results when measuring the same
-		slot. However different statistical lengths can be defined for the measurements so that the measured slots and returned
-		results can differ. \n
+		statistical length. The individual measurements provide the same result when measuring the same slot. However different
+		statistical lengths can be defined for the measurements so that the measured slots and returned results can differ. \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:MODulation:DCHType?', self.__class__.FetchStruct())
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:SEMask:DCHType?', self.__class__.FetchStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/Modulation_/Dmodulation.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/Modulation/Dmodulation.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,43 +1,43 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.StructBase import StructBase
-from ......Internal.ArgStruct import ArgStruct
-from ...... import enums
-from ...... import repcap
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal.StructBase import StructBase
+from .......Internal.ArgStruct import ArgStruct
+from ....... import enums
+from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Dmodulation:
-	"""Dmodulation commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class DmodulationCls:
+	"""Dmodulation commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("dmodulation", core, parent)
+		self._cmd_group = CommandsGroup("dmodulation", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
+			- Reliability: int: 'Reliability indicator'
 			- Seg_Reliability: int: Reliability indicator for the segment
-			- Modulation: enums.Modulation: QPSK, 16-QAM, 64-QAM, 256-QAM"""
+			- Modulation: enums.Modulation: QPSK, 16QAM, 64QAM, 256QAM"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Seg_Reliability'),
 			ArgStruct.scalar_enum('Modulation', enums.Modulation)]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Seg_Reliability: int = None
 			self.Modulation: enums.Modulation = None
 
 	def fetch(self, segment=repcap.Segment.Default) -> FetchStruct:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:MODulation:DMODulation \n
-		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.modulation.dmodulation.fetch(segment = repcap.Segment.Default) \n
+		Snippet: value: FetchStruct = driver.lteMeas.multiEval.listPy.segment.modulation.dmodulation.fetch(segment = repcap.Segment.Default) \n
 		Return the detected modulation scheme for segment <no> in list mode. The result is determined from the last measured slot
-		of the statistical length. If channel type PUCCH is detected, QPSK is returned as modulation type because the QPSK limits
-		are applied in that case. \n
+		of the statistical length. If channel type PUCCH is detected, QPSK is returned for the modulation scheme because the QPSK
+		limits are applied in that case. \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:MODulation:DMODulation?', self.__class__.FetchStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/Modulation_/Extreme.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/Modulation/Extreme.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,26 +1,26 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.StructBase import StructBase
-from ......Internal.ArgStruct import ArgStruct
-from ...... import repcap
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal.StructBase import StructBase
+from .......Internal.ArgStruct import ArgStruct
+from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Extreme:
-	"""Extreme commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class ExtremeCls:
+	"""Extreme commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("extreme", core, parent)
+		self._cmd_group = CommandsGroup("extreme", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
+			- Reliability: int: 'Reliability indicator'
 			- Seg_Reliability: int: Reliability indicator for the segment
 			- Statist_Expired: int: Reached statistical length in slots
 			- Out_Of_Tolerance: int: Percentage of measured subframes with failed limit check
 			- Evm_Rms_Low: float: EVM RMS value, low EVM window position
 			- Evm_Rms_High: float: EVM RMS value, high EVM window position
 			- Evm_Peak_Low: float: EVM peak value, low EVM window position
 			- Evm_Peak_High: float: EVM peak value, high EVM window position
@@ -30,18 +30,18 @@
 			- Mag_Err_Peak_High: float: Magnitude error peak value, high EVM window position
 			- Ph_Error_Rms_Low: float: Phase error RMS value, low EVM window position
 			- Ph_Error_Rms_High: float: Phase error RMS value, high EVM window position
 			- Ph_Error_Peak_Low: float: Phase error peak value, low EVM window position
 			- Ph_Error_Peak_High: float: Phase error peak value, high EVM window position
 			- Iq_Offset: float: I/Q origin offset
 			- Frequency_Error: float: Carrier frequency error
-			- Timing_Error: float: Transmit time error
+			- Timing_Error: float: Time error
 			- Tx_Power_Minimum: float: Minimum user equipment power
-			- Tx_Power_Maximum: float: No parameter help available
-			- Peak_Power_Min: float: No parameter help available
+			- Tx_Power_Maximum: float: Maximum user equipment power
+			- Peak_Power_Min: float: Minimum user equipment peak power
 			- Peak_Power_Max: float: Maximum user equipment peak power
 			- Psd_Minimum: float: No parameter help available
 			- Psd_Maximum: float: No parameter help available
 			- Evm_Dmrs_Low: float: EVM DMRS value, low EVM window position
 			- Evm_Dmrs_High: float: EVM DMRS value, high EVM window position
 			- Mag_Err_Dmrs_Low: float: Magnitude error DMRS value, low EVM window position
 			- Mag_Err_Dmrs_High: float: Magnitude error DMRS value, high EVM window position
@@ -112,127 +112,127 @@
 			self.Mag_Err_Dmrs_Low: float = None
 			self.Mag_Err_Dmrs_High: float = None
 			self.Ph_Error_Dmrs_Low: float = None
 			self.Ph_Error_Dmrs_High: float = None
 
 	def fetch(self, segment=repcap.Segment.Default) -> FetchStruct:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:MODulation:EXTReme \n
-		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.modulation.extreme.fetch(segment = repcap.Segment.Default) \n
-		Return modulation single value results for segment <no> in list mode. The values described below are returned by FETCh
-		commands. The first four values (reliability to out-of-tolerance result) are also returned by CALCulate commands.
+		Snippet: value: FetchStruct = driver.lteMeas.multiEval.listPy.segment.modulation.extreme.fetch(segment = repcap.Segment.Default) \n
+		Return modulation single-value results for segment <no> in list mode. The values described below are returned by FETCh
+		commands. The first four values (reliability to out of tolerance result) are also returned by CALCulate commands.
 		The remaining values returned by CALCulate commands are limit check results, one value for each result listed below. \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:MODulation:EXTReme?', self.__class__.FetchStruct())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
+			- Reliability: int: 'Reliability indicator'
 			- Seg_Reliability: int: Reliability indicator for the segment
 			- Statist_Expired: int: Reached statistical length in slots
 			- Out_Of_Tolerance: int: Percentage of measured subframes with failed limit check
-			- Evm_Rms_Low: float: EVM RMS value, low EVM window position
-			- Evm_Rms_High: float: EVM RMS value, high EVM window position
-			- Evm_Peak_Low: float: EVM peak value, low EVM window position
-			- Evm_Peak_High: float: EVM peak value, high EVM window position
-			- Mag_Error_Rms_Low: float: Magnitude error RMS value, low EVM window position
-			- Mag_Error_Rms_High: float: Magnitude error RMS value, low EVM window position
-			- Mag_Error_Peak_Low: float: Magnitude error peak value, low EVM window position
-			- Mag_Err_Peak_High: float: Magnitude error peak value, high EVM window position
-			- Ph_Error_Rms_Low: float: Phase error RMS value, low EVM window position
-			- Ph_Error_Rms_High: float: Phase error RMS value, high EVM window position
-			- Ph_Error_Peak_Low: float: Phase error peak value, low EVM window position
-			- Ph_Error_Peak_High: float: Phase error peak value, high EVM window position
-			- Iq_Offset: float: I/Q origin offset
-			- Frequency_Error: float: Carrier frequency error
-			- Timing_Error: float: Transmit time error
-			- Tx_Power_Minimum: float: Minimum user equipment power
-			- Tx_Power_Maximum: float: No parameter help available
-			- Peak_Power_Min: float: No parameter help available
-			- Peak_Power_Max: float: Maximum user equipment peak power
-			- Psd_Minimum: float: No parameter help available
-			- Psd_Maximum: float: No parameter help available
-			- Evm_Dmrs_Low: float: EVM DMRS value, low EVM window position
-			- Evm_Dmrs_High: float: EVM DMRS value, high EVM window position
-			- Mag_Err_Dmrs_Low: float: Magnitude error DMRS value, low EVM window position
-			- Mag_Err_Dmrs_High: float: Magnitude error DMRS value, high EVM window position
-			- Ph_Error_Dmrs_Low: float: Phase error DMRS value, low EVM window position
-			- Ph_Error_Dmrs_High: float: Phase error DMRS value, high EVM window position"""
+			- Evm_Rms_Low: float or bool: EVM RMS value, low EVM window position
+			- Evm_Rms_High: float or bool: EVM RMS value, high EVM window position
+			- Evm_Peak_Low: float or bool: EVM peak value, low EVM window position
+			- Evm_Peak_High: float or bool: EVM peak value, high EVM window position
+			- Mag_Error_Rms_Low: float or bool: Magnitude error RMS value, low EVM window position
+			- Mag_Error_Rms_High: float or bool: Magnitude error RMS value, low EVM window position
+			- Mag_Error_Peak_Low: float or bool: Magnitude error peak value, low EVM window position
+			- Mag_Err_Peak_High: float or bool: Magnitude error peak value, high EVM window position
+			- Ph_Error_Rms_Low: float or bool: Phase error RMS value, low EVM window position
+			- Ph_Error_Rms_High: float or bool: Phase error RMS value, high EVM window position
+			- Ph_Error_Peak_Low: float or bool: Phase error peak value, low EVM window position
+			- Ph_Error_Peak_High: float or bool: Phase error peak value, high EVM window position
+			- Iq_Offset: float or bool: I/Q origin offset
+			- Frequency_Error: float or bool: Carrier frequency error
+			- Timing_Error: float or bool: Time error
+			- Tx_Power_Minimum: float or bool: Minimum user equipment power
+			- Tx_Power_Maximum: float or bool: Maximum user equipment power
+			- Peak_Power_Min: float or bool: Minimum user equipment peak power
+			- Peak_Power_Max: float or bool: Maximum user equipment peak power
+			- Psd_Minimum: float or bool: No parameter help available
+			- Psd_Maximum: float or bool: No parameter help available
+			- Evm_Dmrs_Low: float or bool: EVM DMRS value, low EVM window position
+			- Evm_Dmrs_High: float or bool: EVM DMRS value, high EVM window position
+			- Mag_Err_Dmrs_Low: float or bool: Magnitude error DMRS value, low EVM window position
+			- Mag_Err_Dmrs_High: float or bool: Magnitude error DMRS value, high EVM window position
+			- Ph_Error_Dmrs_Low: float or bool: Phase error DMRS value, low EVM window position
+			- Ph_Error_Dmrs_High: float or bool: Phase error DMRS value, high EVM window position"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Seg_Reliability'),
 			ArgStruct.scalar_int('Statist_Expired'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
-			ArgStruct.scalar_float('Evm_Rms_Low'),
-			ArgStruct.scalar_float('Evm_Rms_High'),
-			ArgStruct.scalar_float('Evm_Peak_Low'),
-			ArgStruct.scalar_float('Evm_Peak_High'),
-			ArgStruct.scalar_float('Mag_Error_Rms_Low'),
-			ArgStruct.scalar_float('Mag_Error_Rms_High'),
-			ArgStruct.scalar_float('Mag_Error_Peak_Low'),
-			ArgStruct.scalar_float('Mag_Err_Peak_High'),
-			ArgStruct.scalar_float('Ph_Error_Rms_Low'),
-			ArgStruct.scalar_float('Ph_Error_Rms_High'),
-			ArgStruct.scalar_float('Ph_Error_Peak_Low'),
-			ArgStruct.scalar_float('Ph_Error_Peak_High'),
-			ArgStruct.scalar_float('Iq_Offset'),
-			ArgStruct.scalar_float('Frequency_Error'),
-			ArgStruct.scalar_float('Timing_Error'),
-			ArgStruct.scalar_float('Tx_Power_Minimum'),
-			ArgStruct.scalar_float('Tx_Power_Maximum'),
-			ArgStruct.scalar_float('Peak_Power_Min'),
-			ArgStruct.scalar_float('Peak_Power_Max'),
-			ArgStruct.scalar_float('Psd_Minimum'),
-			ArgStruct.scalar_float('Psd_Maximum'),
-			ArgStruct.scalar_float('Evm_Dmrs_Low'),
-			ArgStruct.scalar_float('Evm_Dmrs_High'),
-			ArgStruct.scalar_float('Mag_Err_Dmrs_Low'),
-			ArgStruct.scalar_float('Mag_Err_Dmrs_High'),
-			ArgStruct.scalar_float('Ph_Error_Dmrs_Low'),
-			ArgStruct.scalar_float('Ph_Error_Dmrs_High')]
+			ArgStruct.scalar_float_ext('Evm_Rms_Low'),
+			ArgStruct.scalar_float_ext('Evm_Rms_High'),
+			ArgStruct.scalar_float_ext('Evm_Peak_Low'),
+			ArgStruct.scalar_float_ext('Evm_Peak_High'),
+			ArgStruct.scalar_float_ext('Mag_Error_Rms_Low'),
+			ArgStruct.scalar_float_ext('Mag_Error_Rms_High'),
+			ArgStruct.scalar_float_ext('Mag_Error_Peak_Low'),
+			ArgStruct.scalar_float_ext('Mag_Err_Peak_High'),
+			ArgStruct.scalar_float_ext('Ph_Error_Rms_Low'),
+			ArgStruct.scalar_float_ext('Ph_Error_Rms_High'),
+			ArgStruct.scalar_float_ext('Ph_Error_Peak_Low'),
+			ArgStruct.scalar_float_ext('Ph_Error_Peak_High'),
+			ArgStruct.scalar_float_ext('Iq_Offset'),
+			ArgStruct.scalar_float_ext('Frequency_Error'),
+			ArgStruct.scalar_float_ext('Timing_Error'),
+			ArgStruct.scalar_float_ext('Tx_Power_Minimum'),
+			ArgStruct.scalar_float_ext('Tx_Power_Maximum'),
+			ArgStruct.scalar_float_ext('Peak_Power_Min'),
+			ArgStruct.scalar_float_ext('Peak_Power_Max'),
+			ArgStruct.scalar_float_ext('Psd_Minimum'),
+			ArgStruct.scalar_float_ext('Psd_Maximum'),
+			ArgStruct.scalar_float_ext('Evm_Dmrs_Low'),
+			ArgStruct.scalar_float_ext('Evm_Dmrs_High'),
+			ArgStruct.scalar_float_ext('Mag_Err_Dmrs_Low'),
+			ArgStruct.scalar_float_ext('Mag_Err_Dmrs_High'),
+			ArgStruct.scalar_float_ext('Ph_Error_Dmrs_Low'),
+			ArgStruct.scalar_float_ext('Ph_Error_Dmrs_High')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Seg_Reliability: int = None
 			self.Statist_Expired: int = None
 			self.Out_Of_Tolerance: int = None
-			self.Evm_Rms_Low: float = None
-			self.Evm_Rms_High: float = None
-			self.Evm_Peak_Low: float = None
-			self.Evm_Peak_High: float = None
-			self.Mag_Error_Rms_Low: float = None
-			self.Mag_Error_Rms_High: float = None
-			self.Mag_Error_Peak_Low: float = None
-			self.Mag_Err_Peak_High: float = None
-			self.Ph_Error_Rms_Low: float = None
-			self.Ph_Error_Rms_High: float = None
-			self.Ph_Error_Peak_Low: float = None
-			self.Ph_Error_Peak_High: float = None
-			self.Iq_Offset: float = None
-			self.Frequency_Error: float = None
-			self.Timing_Error: float = None
-			self.Tx_Power_Minimum: float = None
-			self.Tx_Power_Maximum: float = None
-			self.Peak_Power_Min: float = None
-			self.Peak_Power_Max: float = None
-			self.Psd_Minimum: float = None
-			self.Psd_Maximum: float = None
-			self.Evm_Dmrs_Low: float = None
-			self.Evm_Dmrs_High: float = None
-			self.Mag_Err_Dmrs_Low: float = None
-			self.Mag_Err_Dmrs_High: float = None
-			self.Ph_Error_Dmrs_Low: float = None
-			self.Ph_Error_Dmrs_High: float = None
+			self.Evm_Rms_Low: float or bool = None
+			self.Evm_Rms_High: float or bool = None
+			self.Evm_Peak_Low: float or bool = None
+			self.Evm_Peak_High: float or bool = None
+			self.Mag_Error_Rms_Low: float or bool = None
+			self.Mag_Error_Rms_High: float or bool = None
+			self.Mag_Error_Peak_Low: float or bool = None
+			self.Mag_Err_Peak_High: float or bool = None
+			self.Ph_Error_Rms_Low: float or bool = None
+			self.Ph_Error_Rms_High: float or bool = None
+			self.Ph_Error_Peak_Low: float or bool = None
+			self.Ph_Error_Peak_High: float or bool = None
+			self.Iq_Offset: float or bool = None
+			self.Frequency_Error: float or bool = None
+			self.Timing_Error: float or bool = None
+			self.Tx_Power_Minimum: float or bool = None
+			self.Tx_Power_Maximum: float or bool = None
+			self.Peak_Power_Min: float or bool = None
+			self.Peak_Power_Max: float or bool = None
+			self.Psd_Minimum: float or bool = None
+			self.Psd_Maximum: float or bool = None
+			self.Evm_Dmrs_Low: float or bool = None
+			self.Evm_Dmrs_High: float or bool = None
+			self.Mag_Err_Dmrs_Low: float or bool = None
+			self.Mag_Err_Dmrs_High: float or bool = None
+			self.Ph_Error_Dmrs_Low: float or bool = None
+			self.Ph_Error_Dmrs_High: float or bool = None
 
 	def calculate(self, segment=repcap.Segment.Default) -> CalculateStruct:
 		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:MODulation:EXTReme \n
-		Snippet: value: CalculateStruct = driver.multiEval.listPy.segment.modulation.extreme.calculate(segment = repcap.Segment.Default) \n
-		Return modulation single value results for segment <no> in list mode. The values described below are returned by FETCh
-		commands. The first four values (reliability to out-of-tolerance result) are also returned by CALCulate commands.
+		Snippet: value: CalculateStruct = driver.lteMeas.multiEval.listPy.segment.modulation.extreme.calculate(segment = repcap.Segment.Default) \n
+		Return modulation single-value results for segment <no> in list mode. The values described below are returned by FETCh
+		commands. The first four values (reliability to out of tolerance result) are also returned by CALCulate commands.
 		The remaining values returned by CALCulate commands are limit check results, one value for each result listed below. \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:MODulation:EXTReme?', self.__class__.CalculateStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/Modulation_/SchType.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/Modulation/SchType.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,27 +1,27 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.StructBase import StructBase
-from ......Internal.ArgStruct import ArgStruct
-from ...... import enums
-from ...... import repcap
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal.StructBase import StructBase
+from .......Internal.ArgStruct import ArgStruct
+from ....... import enums
+from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class SchType:
-	"""SchType commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class SchTypeCls:
+	"""SchType commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("schType", core, parent)
+		self._cmd_group = CommandsGroup("schType", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
+			- Reliability: int: 'Reliability indicator'
 			- Seg_Reliability: int: Reliability indicator for the segment
 			- Channel_Type: enums.SidelinkChannelType: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Seg_Reliability'),
 			ArgStruct.scalar_enum('Channel_Type', enums.SidelinkChannelType)]
 
@@ -29,13 +29,13 @@
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Seg_Reliability: int = None
 			self.Channel_Type: enums.SidelinkChannelType = None
 
 	def fetch(self, segment=repcap.Segment.Default) -> FetchStruct:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:MODulation:SCHType \n
-		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.modulation.schType.fetch(segment = repcap.Segment.Default) \n
+		Snippet: value: FetchStruct = driver.lteMeas.multiEval.listPy.segment.modulation.schType.fetch(segment = repcap.Segment.Default) \n
 		Returns the sidelink channel type evaluated for modulation results, for segment <no> in list mode. \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:MODulation:SCHType?', self.__class__.FetchStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/Modulation_/StandardDev.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/Modulation/StandardDev.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,26 +1,26 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.StructBase import StructBase
-from ......Internal.ArgStruct import ArgStruct
-from ...... import repcap
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal.StructBase import StructBase
+from .......Internal.ArgStruct import ArgStruct
+from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class StandardDev:
-	"""StandardDev commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class StandardDevCls:
+	"""StandardDev commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("standardDev", core, parent)
+		self._cmd_group = CommandsGroup("standardDev", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
+			- Reliability: int: 'Reliability indicator'
 			- Seg_Reliability: int: Reliability indicator for the segment
 			- Statist_Expired: int: Reached statistical length in slots
 			- Out_Of_Tolerance: int: Percentage of measured subframes with failed limit check
 			- Evm_Rms_Low: float: EVM RMS value, low EVM window position
 			- Evm_Rms_High: float: EVM RMS value, high EVM window position
 			- Evm_Peak_Low: float: EVM peak value, low EVM window position
 			- Evm_Peak_High: float: EVM peak value, high EVM window position
@@ -30,15 +30,15 @@
 			- Mag_Err_Peak_High: float: Magnitude error peak value, high EVM window position
 			- Ph_Error_Rms_Low: float: Phase error RMS value, low EVM window position
 			- Ph_Error_Rms_High: float: Phase error RMS value, high EVM window position
 			- Ph_Error_Peak_Low: float: Phase error peak value, low EVM window position
 			- Ph_Error_Peak_High: float: Phase error peak value, high EVM window position
 			- Iq_Offset: float: I/Q origin offset
 			- Frequency_Error: float: Carrier frequency error
-			- Timing_Error: float: Transmit time error
+			- Timing_Error: float: Time error
 			- Tx_Power: float: User equipment power
 			- Peak_Power: float: User equipment peak power
 			- Psd: float: No parameter help available
 			- Evm_Dmrs_Low: float: EVM DMRS value, low EVM window position
 			- Evm_Dmrs_High: float: EVM DMRS value, high EVM window position
 			- Mag_Err_Dmrs_Low: float: Magnitude error DMRS value, low EVM window position
 			- Mag_Err_Dmrs_High: float: Magnitude error DMRS value, high EVM window position
@@ -103,116 +103,116 @@
 			self.Mag_Err_Dmrs_Low: float = None
 			self.Mag_Err_Dmrs_High: float = None
 			self.Ph_Error_Dmrs_Low: float = None
 			self.Ph_Error_Dmrs_High: float = None
 
 	def fetch(self, segment=repcap.Segment.Default) -> FetchStruct:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:MODulation:SDEViation \n
-		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.modulation.standardDev.fetch(segment = repcap.Segment.Default) \n
-		Returns modulation single value results for segment <no> in list mode. The values described below are returned by FETCh
-		commands. The first four values (reliability to out-of-tolerance result) are also returned by CALCulate commands.
+		Snippet: value: FetchStruct = driver.lteMeas.multiEval.listPy.segment.modulation.standardDev.fetch(segment = repcap.Segment.Default) \n
+		Returns modulation single-value results for segment <no> in list mode. The values described below are returned by FETCh
+		commands. The first four values (reliability to out of tolerance result) are also returned by CALCulate commands.
 		The remaining values returned by CALCulate commands are limit check results, one value for each result listed below. \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:MODulation:SDEViation?', self.__class__.FetchStruct())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
 			- Reliability: int: No parameter help available
 			- Seg_Reliability: int: No parameter help available
 			- Statist_Expired: int: No parameter help available
 			- Out_Of_Tolerance: int: No parameter help available
-			- Evm_Rms_Low: float: No parameter help available
-			- Evm_Rms_High: float: No parameter help available
-			- Evm_Peak_Low: float: No parameter help available
-			- Evm_Peak_High: float: No parameter help available
-			- Mag_Error_Rms_Low: float: No parameter help available
-			- Mag_Error_Rms_High: float: No parameter help available
-			- Mag_Error_Peak_Low: float: No parameter help available
-			- Mag_Err_Peak_High: float: No parameter help available
-			- Ph_Error_Rms_Low: float: No parameter help available
-			- Ph_Error_Rms_High: float: No parameter help available
-			- Ph_Error_Peak_Low: float: No parameter help available
-			- Ph_Error_Peak_High: float: No parameter help available
-			- Iq_Offset: float: No parameter help available
-			- Frequency_Error: float: No parameter help available
-			- Timing_Error: float: No parameter help available
-			- Tx_Power: float: No parameter help available
-			- Peak_Power: float: No parameter help available
-			- Psd: float: No parameter help available
-			- Evm_Dmrs_Low: float: No parameter help available
-			- Evm_Dmrs_High: float: No parameter help available
-			- Mag_Err_Dmrs_Low: float: No parameter help available
-			- Mag_Err_Dmrs_High: float: No parameter help available
-			- Ph_Error_Dmrs_Low: float: No parameter help available
-			- Ph_Error_Dmrs_High: float: No parameter help available"""
+			- Evm_Rms_Low: float or bool: No parameter help available
+			- Evm_Rms_High: float or bool: No parameter help available
+			- Evm_Peak_Low: float or bool: No parameter help available
+			- Evm_Peak_High: float or bool: No parameter help available
+			- Mag_Error_Rms_Low: float or bool: No parameter help available
+			- Mag_Error_Rms_High: float or bool: No parameter help available
+			- Mag_Error_Peak_Low: float or bool: No parameter help available
+			- Mag_Err_Peak_High: float or bool: No parameter help available
+			- Ph_Error_Rms_Low: float or bool: No parameter help available
+			- Ph_Error_Rms_High: float or bool: No parameter help available
+			- Ph_Error_Peak_Low: float or bool: No parameter help available
+			- Ph_Error_Peak_High: float or bool: No parameter help available
+			- Iq_Offset: float or bool: No parameter help available
+			- Frequency_Error: float or bool: No parameter help available
+			- Timing_Error: float or bool: No parameter help available
+			- Tx_Power: float or bool: No parameter help available
+			- Peak_Power: float or bool: No parameter help available
+			- Psd: float or bool: No parameter help available
+			- Evm_Dmrs_Low: float or bool: No parameter help available
+			- Evm_Dmrs_High: float or bool: No parameter help available
+			- Mag_Err_Dmrs_Low: float or bool: No parameter help available
+			- Mag_Err_Dmrs_High: float or bool: No parameter help available
+			- Ph_Error_Dmrs_Low: float or bool: No parameter help available
+			- Ph_Error_Dmrs_High: float or bool: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Seg_Reliability'),
 			ArgStruct.scalar_int('Statist_Expired'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
-			ArgStruct.scalar_float('Evm_Rms_Low'),
-			ArgStruct.scalar_float('Evm_Rms_High'),
-			ArgStruct.scalar_float('Evm_Peak_Low'),
-			ArgStruct.scalar_float('Evm_Peak_High'),
-			ArgStruct.scalar_float('Mag_Error_Rms_Low'),
-			ArgStruct.scalar_float('Mag_Error_Rms_High'),
-			ArgStruct.scalar_float('Mag_Error_Peak_Low'),
-			ArgStruct.scalar_float('Mag_Err_Peak_High'),
-			ArgStruct.scalar_float('Ph_Error_Rms_Low'),
-			ArgStruct.scalar_float('Ph_Error_Rms_High'),
-			ArgStruct.scalar_float('Ph_Error_Peak_Low'),
-			ArgStruct.scalar_float('Ph_Error_Peak_High'),
-			ArgStruct.scalar_float('Iq_Offset'),
-			ArgStruct.scalar_float('Frequency_Error'),
-			ArgStruct.scalar_float('Timing_Error'),
-			ArgStruct.scalar_float('Tx_Power'),
-			ArgStruct.scalar_float('Peak_Power'),
-			ArgStruct.scalar_float('Psd'),
-			ArgStruct.scalar_float('Evm_Dmrs_Low'),
-			ArgStruct.scalar_float('Evm_Dmrs_High'),
-			ArgStruct.scalar_float('Mag_Err_Dmrs_Low'),
-			ArgStruct.scalar_float('Mag_Err_Dmrs_High'),
-			ArgStruct.scalar_float('Ph_Error_Dmrs_Low'),
-			ArgStruct.scalar_float('Ph_Error_Dmrs_High')]
+			ArgStruct.scalar_float_ext('Evm_Rms_Low'),
+			ArgStruct.scalar_float_ext('Evm_Rms_High'),
+			ArgStruct.scalar_float_ext('Evm_Peak_Low'),
+			ArgStruct.scalar_float_ext('Evm_Peak_High'),
+			ArgStruct.scalar_float_ext('Mag_Error_Rms_Low'),
+			ArgStruct.scalar_float_ext('Mag_Error_Rms_High'),
+			ArgStruct.scalar_float_ext('Mag_Error_Peak_Low'),
+			ArgStruct.scalar_float_ext('Mag_Err_Peak_High'),
+			ArgStruct.scalar_float_ext('Ph_Error_Rms_Low'),
+			ArgStruct.scalar_float_ext('Ph_Error_Rms_High'),
+			ArgStruct.scalar_float_ext('Ph_Error_Peak_Low'),
+			ArgStruct.scalar_float_ext('Ph_Error_Peak_High'),
+			ArgStruct.scalar_float_ext('Iq_Offset'),
+			ArgStruct.scalar_float_ext('Frequency_Error'),
+			ArgStruct.scalar_float_ext('Timing_Error'),
+			ArgStruct.scalar_float_ext('Tx_Power'),
+			ArgStruct.scalar_float_ext('Peak_Power'),
+			ArgStruct.scalar_float_ext('Psd'),
+			ArgStruct.scalar_float_ext('Evm_Dmrs_Low'),
+			ArgStruct.scalar_float_ext('Evm_Dmrs_High'),
+			ArgStruct.scalar_float_ext('Mag_Err_Dmrs_Low'),
+			ArgStruct.scalar_float_ext('Mag_Err_Dmrs_High'),
+			ArgStruct.scalar_float_ext('Ph_Error_Dmrs_Low'),
+			ArgStruct.scalar_float_ext('Ph_Error_Dmrs_High')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Seg_Reliability: int = None
 			self.Statist_Expired: int = None
 			self.Out_Of_Tolerance: int = None
-			self.Evm_Rms_Low: float = None
-			self.Evm_Rms_High: float = None
-			self.Evm_Peak_Low: float = None
-			self.Evm_Peak_High: float = None
-			self.Mag_Error_Rms_Low: float = None
-			self.Mag_Error_Rms_High: float = None
-			self.Mag_Error_Peak_Low: float = None
-			self.Mag_Err_Peak_High: float = None
-			self.Ph_Error_Rms_Low: float = None
-			self.Ph_Error_Rms_High: float = None
-			self.Ph_Error_Peak_Low: float = None
-			self.Ph_Error_Peak_High: float = None
-			self.Iq_Offset: float = None
-			self.Frequency_Error: float = None
-			self.Timing_Error: float = None
-			self.Tx_Power: float = None
-			self.Peak_Power: float = None
-			self.Psd: float = None
-			self.Evm_Dmrs_Low: float = None
-			self.Evm_Dmrs_High: float = None
-			self.Mag_Err_Dmrs_Low: float = None
-			self.Mag_Err_Dmrs_High: float = None
-			self.Ph_Error_Dmrs_Low: float = None
-			self.Ph_Error_Dmrs_High: float = None
+			self.Evm_Rms_Low: float or bool = None
+			self.Evm_Rms_High: float or bool = None
+			self.Evm_Peak_Low: float or bool = None
+			self.Evm_Peak_High: float or bool = None
+			self.Mag_Error_Rms_Low: float or bool = None
+			self.Mag_Error_Rms_High: float or bool = None
+			self.Mag_Error_Peak_Low: float or bool = None
+			self.Mag_Err_Peak_High: float or bool = None
+			self.Ph_Error_Rms_Low: float or bool = None
+			self.Ph_Error_Rms_High: float or bool = None
+			self.Ph_Error_Peak_Low: float or bool = None
+			self.Ph_Error_Peak_High: float or bool = None
+			self.Iq_Offset: float or bool = None
+			self.Frequency_Error: float or bool = None
+			self.Timing_Error: float or bool = None
+			self.Tx_Power: float or bool = None
+			self.Peak_Power: float or bool = None
+			self.Psd: float or bool = None
+			self.Evm_Dmrs_Low: float or bool = None
+			self.Evm_Dmrs_High: float or bool = None
+			self.Mag_Err_Dmrs_Low: float or bool = None
+			self.Mag_Err_Dmrs_High: float or bool = None
+			self.Ph_Error_Dmrs_Low: float or bool = None
+			self.Ph_Error_Dmrs_High: float or bool = None
 
 	def calculate(self, segment=repcap.Segment.Default) -> CalculateStruct:
 		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:MODulation:SDEViation \n
-		Snippet: value: CalculateStruct = driver.multiEval.listPy.segment.modulation.standardDev.calculate(segment = repcap.Segment.Default) \n
+		Snippet: value: CalculateStruct = driver.lteMeas.multiEval.listPy.segment.modulation.standardDev.calculate(segment = repcap.Segment.Default) \n
 		No command help available \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:MODulation:SDEViation?', self.__class__.CalculateStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/Pmonitor.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Dmarker/Pmonitor/__init__.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,43 +1,27 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Pmonitor:
-	"""Pmonitor commands group definition. 4 total commands, 3 Sub-groups, 0 group commands"""
+class PmonitorCls:
+	"""Pmonitor commands group definition. 1 total commands, 1 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("pmonitor", core, parent)
+		self._cmd_group = CommandsGroup("pmonitor", core, parent)
 
 	@property
-	def rms(self):
-		"""rms commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_rms'):
-			from .Pmonitor_.Rms import Rms
-			self._rms = Rms(self._core, self._base)
-		return self._rms
+	def cc(self):
+		"""cc commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_cc'):
+			from .Cc import CcCls
+			self._cc = CcCls(self._core, self._cmd_group)
+		return self._cc
 
-	@property
-	def peak(self):
-		"""peak commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_peak'):
-			from .Pmonitor_.Peak import Peak
-			self._peak = Peak(self._core, self._base)
-		return self._peak
-
-	@property
-	def array(self):
-		"""array commands group. 2 Sub-classes, 0 commands."""
-		if not hasattr(self, '_array'):
-			from .Pmonitor_.Array import Array
-			self._array = Array(self._core, self._base)
-		return self._array
-
-	def clone(self) -> 'Pmonitor':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'PmonitorCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Pmonitor(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = PmonitorCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/Pmonitor_/Array.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ReferenceMarker/Pmonitor/__init__.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,35 +1,27 @@
 from ......Internal.Core import Core
 from ......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Array:
-	"""Array commands group definition. 2 total commands, 2 Sub-groups, 0 group commands"""
+class PmonitorCls:
+	"""Pmonitor commands group definition. 1 total commands, 1 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("array", core, parent)
+		self._cmd_group = CommandsGroup("pmonitor", core, parent)
 
 	@property
-	def start(self):
-		"""start commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_start'):
-			from .Array_.Start import Start
-			self._start = Start(self._core, self._base)
-		return self._start
+	def cc(self):
+		"""cc commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_cc'):
+			from .Cc import CcCls
+			self._cc = CcCls(self._core, self._cmd_group)
+		return self._cc
 
-	@property
-	def length(self):
-		"""length commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_length'):
-			from .Array_.Length import Length
-			self._length = Length(self._core, self._base)
-		return self._length
-
-	def clone(self) -> 'Array':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'PmonitorCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Array(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = PmonitorCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/Pmonitor_/Array_/Length.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/Pmonitor/Array/Length.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,28 +1,28 @@
-from .......Internal.Core import Core
-from .......Internal.CommandsGroup import CommandsGroup
-from .......Internal import Conversions
-from .......Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from .......Internal.Types import DataType
-from ....... import repcap
+from ........Internal.Core import Core
+from ........Internal.CommandsGroup import CommandsGroup
+from ........Internal import Conversions
+from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from ........Internal.Types import DataType
+from ........ import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Length:
-	"""Length commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class LengthCls:
+	"""Length commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("length", core, parent)
+		self._cmd_group = CommandsGroup("length", core, parent)
 
 	def fetch(self, segment=repcap.Segment.Default) -> int:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:PMONitor:ARRay:LENGth \n
-		Snippet: value: int = driver.multiEval.listPy.segment.pmonitor.array.length.fetch(segment = repcap.Segment.Default) \n
+		Snippet: value: int = driver.lteMeas.multiEval.listPy.segment.pmonitor.array.length.fetch(segment = repcap.Segment.Default) \n
 		Returns the number of power monitor results for segment <no> contained in a result list for all measured segments. Such a
-		result list is, for example, returned by the command method RsCMPX_LteMeas.MultiEval.ListPy.Pmonitor.Rms.fetch. \n
+		result list is, for example, returned by the command method RsCMPX_LteMeas.LteMeas.MultiEval.ListPy.Pmonitor.Rms.fetch. \n
 		Suppressed linked return values: reliability \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
 			:return: length: Number of power monitor results"""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_str_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:PMONitor:ARRay:LENGth?', suppressed)
 		return Conversions.str_to_int(response)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/Pmonitor_/Array_/Start.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/Pmonitor/Array/Start.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,30 +1,30 @@
-from .......Internal.Core import Core
-from .......Internal.CommandsGroup import CommandsGroup
-from .......Internal import Conversions
-from .......Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from .......Internal.Types import DataType
-from ....... import repcap
+from ........Internal.Core import Core
+from ........Internal.CommandsGroup import CommandsGroup
+from ........Internal import Conversions
+from ........Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from ........Internal.Types import DataType
+from ........ import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Start:
-	"""Start commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class StartCls:
+	"""Start commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("start", core, parent)
+		self._cmd_group = CommandsGroup("start", core, parent)
 
 	def fetch(self, segment=repcap.Segment.Default) -> int:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:PMONitor:ARRay:STARt \n
-		Snippet: value: int = driver.multiEval.listPy.segment.pmonitor.array.start.fetch(segment = repcap.Segment.Default) \n
+		Snippet: value: int = driver.lteMeas.multiEval.listPy.segment.pmonitor.array.start.fetch(segment = repcap.Segment.Default) \n
 		Returns the offset of the first power monitor result for segment <no> within a result list for all measured segments.
-		Such a result list is, for example, returned by the command method RsCMPX_LteMeas.MultiEval.ListPy.Pmonitor.Rms.fetch. A
-		returned <Start> value n indicates that the result for the first subframe of the segment is the (n+1) th result in the
-		power result list over all segments. \n
+		Such a result list is, for example, returned by the command method RsCMPX_LteMeas.LteMeas.MultiEval.ListPy.Pmonitor.Rms.
+		fetch. A returned <Start> value n indicates that the result for the first subframe of the segment is the (n+1) th result
+		in the power result list over all segments. \n
 		Suppressed linked return values: reliability \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
 			:return: start: Offset of the first power monitor result"""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_str_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:PMONitor:ARRay:STARt?', suppressed)
 		return Conversions.str_to_int(response)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/Pmonitor_/Peak.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/Pmonitor/Peak.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,29 +1,29 @@
 from typing import List
 
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.Types import DataType
-from ......Internal.StructBase import StructBase
-from ......Internal.ArgStruct import ArgStruct
-from ...... import repcap
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal.Types import DataType
+from .......Internal.StructBase import StructBase
+from .......Internal.ArgStruct import ArgStruct
+from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Peak:
-	"""Peak commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class PeakCls:
+	"""Peak commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("peak", core, parent)
+		self._cmd_group = CommandsGroup("peak", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
+			- Reliability: int: 'Reliability indicator'
 			- Seg_Reliability: int: Reliability indicator for the segment
 			- Step_Peak_Power: List[float]: Comma-separated list of power values, one value per subframe, from first to last subframe of the segment. For an inactive segment, only one INV is returned, independent of the number of configured subframes."""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Seg_Reliability'),
 			ArgStruct('Step_Peak_Power', DataType.FloatList, None, False, True, 1)]
 
@@ -31,15 +31,15 @@
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Seg_Reliability: int = None
 			self.Step_Peak_Power: List[float] = None
 
 	def fetch(self, segment=repcap.Segment.Default) -> FetchStruct:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:PMONitor:PEAK \n
-		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.pmonitor.peak.fetch(segment = repcap.Segment.Default) \n
+		Snippet: value: FetchStruct = driver.lteMeas.multiEval.listPy.segment.pmonitor.peak.fetch(segment = repcap.Segment.Default) \n
 		Return the power monitor results for segment <no> in list mode. The commands return one power result for each subframe of
 		the segment for the measured carrier. The power values are RMS averaged over the subframe or represent the peak value
 		within the subframe. \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:PMONitor:PEAK?', self.__class__.FetchStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/Pmonitor_/Rms.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/Pmonitor/Rms.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,29 +1,29 @@
 from typing import List
 
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.Types import DataType
-from ......Internal.StructBase import StructBase
-from ......Internal.ArgStruct import ArgStruct
-from ...... import repcap
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal.Types import DataType
+from .......Internal.StructBase import StructBase
+from .......Internal.ArgStruct import ArgStruct
+from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Rms:
-	"""Rms commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class RmsCls:
+	"""Rms commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("rms", core, parent)
+		self._cmd_group = CommandsGroup("rms", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
+			- Reliability: int: 'Reliability indicator'
 			- Seg_Reliability: int: Reliability indicator for the segment
 			- Step_Rms_Power: List[float]: Comma-separated list of power values, one value per subframe, from first to last subframe of the segment. For an inactive segment, only one INV is returned, independent of the number of configured subframes."""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Seg_Reliability'),
 			ArgStruct('Step_Rms_Power', DataType.FloatList, None, False, True, 1)]
 
@@ -31,15 +31,15 @@
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Seg_Reliability: int = None
 			self.Step_Rms_Power: List[float] = None
 
 	def fetch(self, segment=repcap.Segment.Default) -> FetchStruct:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:PMONitor:RMS \n
-		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.pmonitor.rms.fetch(segment = repcap.Segment.Default) \n
+		Snippet: value: FetchStruct = driver.lteMeas.multiEval.listPy.segment.pmonitor.rms.fetch(segment = repcap.Segment.Default) \n
 		Return the power monitor results for segment <no> in list mode. The commands return one power result for each subframe of
 		the segment for the measured carrier. The power values are RMS averaged over the subframe or represent the peak value
 		within the subframe. \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:PMONitor:RMS?', self.__class__.FetchStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/Power.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/Srs/Trace/Pdynamics/__init__.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,59 +1,43 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Power:
-	"""Power commands group definition. 9 total commands, 5 Sub-groups, 0 group commands"""
+class PdynamicsCls:
+	"""Pdynamics commands group definition. 6 total commands, 3 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("power", core, parent)
+		self._cmd_group = CommandsGroup("pdynamics", core, parent)
 
 	@property
 	def current(self):
 		"""current commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_current'):
-			from .Power_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
 	@property
 	def average(self):
 		"""average commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_average'):
-			from .Power_.Average import Average
-			self._average = Average(self._core, self._base)
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
 		return self._average
 
 	@property
-	def minimum(self):
-		"""minimum commands group. 0 Sub-classes, 2 commands."""
-		if not hasattr(self, '_minimum'):
-			from .Power_.Minimum import Minimum
-			self._minimum = Minimum(self._core, self._base)
-		return self._minimum
-
-	@property
 	def maximum(self):
 		"""maximum commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_maximum'):
-			from .Power_.Maximum import Maximum
-			self._maximum = Maximum(self._core, self._base)
+			from .Maximum import MaximumCls
+			self._maximum = MaximumCls(self._core, self._cmd_group)
 		return self._maximum
 
-	@property
-	def standardDev(self):
-		"""standardDev commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_standardDev'):
-			from .Power_.StandardDev import StandardDev
-			self._standardDev = StandardDev(self._core, self._base)
-		return self._standardDev
-
-	def clone(self) -> 'Power':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'PdynamicsCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Power(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = PdynamicsCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/Power_/Average.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/Power/Minimum.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,78 +1,78 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.StructBase import StructBase
-from ......Internal.ArgStruct import ArgStruct
-from ...... import repcap
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal.StructBase import StructBase
+from .......Internal.ArgStruct import ArgStruct
+from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class MinimumCls:
+	"""Minimum commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("minimum", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
+			- Reliability: int: 'Reliability indicator'
 			- Seg_Reliability: int: Reliability indicator for the segment
 			- Statist_Expired: int: Reached statistical length in subframes
 			- Out_Of_Tolerance: int: Percentage of measured subframes with failed limit check
-			- Tx_Power: float: Total TX power of all component carriers"""
+			- Tx_Power_Min: float: Total TX power of all component carriers"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Seg_Reliability'),
 			ArgStruct.scalar_int('Statist_Expired'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
-			ArgStruct.scalar_float('Tx_Power')]
+			ArgStruct.scalar_float('Tx_Power_Min')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Seg_Reliability: int = None
 			self.Statist_Expired: int = None
 			self.Out_Of_Tolerance: int = None
-			self.Tx_Power: float = None
+			self.Tx_Power_Min: float = None
 
 	def fetch(self, segment=repcap.Segment.Default) -> FetchStruct:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:POWer:AVERage \n
-		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.power.average.fetch(segment = repcap.Segment.Default) \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:POWer:MINimum \n
+		Snippet: value: FetchStruct = driver.lteMeas.multiEval.listPy.segment.power.minimum.fetch(segment = repcap.Segment.Default) \n
 		Return total TX power results for segment <no> in list mode. \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:POWer:AVERage?', self.__class__.FetchStruct())
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:POWer:MINimum?', self.__class__.FetchStruct())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
 			- Reliability: int: No parameter help available
 			- Seg_Reliability: int: No parameter help available
 			- Statist_Expired: int: No parameter help available
 			- Out_Of_Tolerance: int: No parameter help available
-			- Tx_Power: float: No parameter help available"""
+			- Tx_Power_Min: float or bool: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Seg_Reliability'),
 			ArgStruct.scalar_int('Statist_Expired'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
-			ArgStruct.scalar_float('Tx_Power')]
+			ArgStruct.scalar_float_ext('Tx_Power_Min')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Seg_Reliability: int = None
 			self.Statist_Expired: int = None
 			self.Out_Of_Tolerance: int = None
-			self.Tx_Power: float = None
+			self.Tx_Power_Min: float or bool = None
 
 	def calculate(self, segment=repcap.Segment.Default) -> CalculateStruct:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:POWer:AVERage \n
-		Snippet: value: CalculateStruct = driver.multiEval.listPy.segment.power.average.calculate(segment = repcap.Segment.Default) \n
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:POWer:MINimum \n
+		Snippet: value: CalculateStruct = driver.lteMeas.multiEval.listPy.segment.power.minimum.calculate(segment = repcap.Segment.Default) \n
 		No command help available \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
-		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:POWer:AVERage?', self.__class__.CalculateStruct())
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
+		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:POWer:MINimum?', self.__class__.CalculateStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/Power_/Current.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/Power/Current.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,26 +1,26 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.StructBase import StructBase
-from ......Internal.ArgStruct import ArgStruct
-from ...... import repcap
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal.StructBase import StructBase
+from .......Internal.ArgStruct import ArgStruct
+from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
+			- Reliability: int: 'Reliability indicator'
 			- Seg_Reliability: int: Reliability indicator for the segment
 			- Statist_Expired: int: Reached statistical length in subframes
 			- Out_Of_Tolerance: int: Percentage of measured subframes with failed limit check
 			- Tx_Power: float: Total TX power of all component carriers"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Seg_Reliability'),
@@ -34,45 +34,45 @@
 			self.Seg_Reliability: int = None
 			self.Statist_Expired: int = None
 			self.Out_Of_Tolerance: int = None
 			self.Tx_Power: float = None
 
 	def fetch(self, segment=repcap.Segment.Default) -> FetchStruct:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:POWer:CURRent \n
-		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.power.current.fetch(segment = repcap.Segment.Default) \n
+		Snippet: value: FetchStruct = driver.lteMeas.multiEval.listPy.segment.power.current.fetch(segment = repcap.Segment.Default) \n
 		Return total TX power results for segment <no> in list mode. \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:POWer:CURRent?', self.__class__.FetchStruct())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
 			- Reliability: int: No parameter help available
 			- Seg_Reliability: int: No parameter help available
 			- Statist_Expired: int: No parameter help available
 			- Out_Of_Tolerance: int: No parameter help available
-			- Tx_Power: float: No parameter help available"""
+			- Tx_Power: float or bool: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Seg_Reliability'),
 			ArgStruct.scalar_int('Statist_Expired'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
-			ArgStruct.scalar_float('Tx_Power')]
+			ArgStruct.scalar_float_ext('Tx_Power')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Seg_Reliability: int = None
 			self.Statist_Expired: int = None
 			self.Out_Of_Tolerance: int = None
-			self.Tx_Power: float = None
+			self.Tx_Power: float or bool = None
 
 	def calculate(self, segment=repcap.Segment.Default) -> CalculateStruct:
 		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:POWer:CURRent \n
-		Snippet: value: CalculateStruct = driver.multiEval.listPy.segment.power.current.calculate(segment = repcap.Segment.Default) \n
+		Snippet: value: CalculateStruct = driver.lteMeas.multiEval.listPy.segment.power.current.calculate(segment = repcap.Segment.Default) \n
 		No command help available \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:POWer:CURRent?', self.__class__.CalculateStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/Power_/Maximum.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/SeMask/StandardDev.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,78 +1,86 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.StructBase import StructBase
-from ......Internal.ArgStruct import ArgStruct
-from ...... import repcap
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal.StructBase import StructBase
+from .......Internal.ArgStruct import ArgStruct
+from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Maximum:
-	"""Maximum commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class StandardDevCls:
+	"""StandardDev commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("maximum", core, parent)
+		self._cmd_group = CommandsGroup("standardDev", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
+			- Reliability: int: 'Reliability indicator'
 			- Seg_Reliability: int: Reliability indicator for the segment
-			- Statist_Expired: int: Reached statistical length in subframes
+			- Statist_Expired: int: Reached statistical length in slots
 			- Out_Of_Tolerance: int: Percentage of measured subframes with failed limit check
-			- Tx_Power_Max: float: Total TX power of all component carriers"""
+			- Obw: float: Occupied bandwidth
+			- Tx_Power: float: Total TX power in the slot"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Seg_Reliability'),
 			ArgStruct.scalar_int('Statist_Expired'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
-			ArgStruct.scalar_float('Tx_Power_Max')]
+			ArgStruct.scalar_float('Obw'),
+			ArgStruct.scalar_float('Tx_Power')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Seg_Reliability: int = None
 			self.Statist_Expired: int = None
 			self.Out_Of_Tolerance: int = None
-			self.Tx_Power_Max: float = None
+			self.Obw: float = None
+			self.Tx_Power: float = None
 
 	def fetch(self, segment=repcap.Segment.Default) -> FetchStruct:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:POWer:MAXimum \n
-		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.power.maximum.fetch(segment = repcap.Segment.Default) \n
-		Return total TX power results for segment <no> in list mode. \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:SEMask:SDEViation \n
+		Snippet: value: FetchStruct = driver.lteMeas.multiEval.listPy.segment.seMask.standardDev.fetch(segment = repcap.Segment.Default) \n
+		Return spectrum emission single value results for segment <no> in list mode. The values described below are returned by
+		FETCh commands. The first four values (reliability to out of tolerance result) are also returned by CALCulate commands.
+		The remaining values returned by CALCulate commands are limit check results, one value for each result listed below. \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:POWer:MAXimum?', self.__class__.FetchStruct())
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:SEMask:SDEViation?', self.__class__.FetchStruct())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
 			- Reliability: int: No parameter help available
 			- Seg_Reliability: int: No parameter help available
 			- Statist_Expired: int: No parameter help available
 			- Out_Of_Tolerance: int: No parameter help available
-			- Tx_Power_Max: float: No parameter help available"""
+			- Obw: float or bool: No parameter help available
+			- Tx_Power: float or bool: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Seg_Reliability'),
 			ArgStruct.scalar_int('Statist_Expired'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
-			ArgStruct.scalar_float('Tx_Power_Max')]
+			ArgStruct.scalar_float_ext('Obw'),
+			ArgStruct.scalar_float_ext('Tx_Power')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Seg_Reliability: int = None
 			self.Statist_Expired: int = None
 			self.Out_Of_Tolerance: int = None
-			self.Tx_Power_Max: float = None
+			self.Obw: float or bool = None
+			self.Tx_Power: float or bool = None
 
 	def calculate(self, segment=repcap.Segment.Default) -> CalculateStruct:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:POWer:MAXimum \n
-		Snippet: value: CalculateStruct = driver.multiEval.listPy.segment.power.maximum.calculate(segment = repcap.Segment.Default) \n
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:SEMask:SDEViation \n
+		Snippet: value: CalculateStruct = driver.lteMeas.multiEval.listPy.segment.seMask.standardDev.calculate(segment = repcap.Segment.Default) \n
 		No command help available \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
-		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:POWer:MAXimum?', self.__class__.CalculateStruct())
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
+		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:SEMask:SDEViation?', self.__class__.CalculateStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/Power_/Minimum.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/Power/Cc/Maximum.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,78 +1,82 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.StructBase import StructBase
-from ......Internal.ArgStruct import ArgStruct
-from ...... import repcap
+from ........Internal.Core import Core
+from ........Internal.CommandsGroup import CommandsGroup
+from ........Internal.StructBase import StructBase
+from ........Internal.ArgStruct import ArgStruct
+from ........ import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Minimum:
-	"""Minimum commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class MaximumCls:
+	"""Maximum commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("minimum", core, parent)
+		self._cmd_group = CommandsGroup("maximum", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
+			- Reliability: int: 'Reliability indicator'
 			- Seg_Reliability: int: Reliability indicator for the segment
 			- Statist_Expired: int: Reached statistical length in subframes
 			- Out_Of_Tolerance: int: Percentage of measured subframes with failed limit check
-			- Tx_Power_Min: float: Total TX power of all component carriers"""
+			- Tx_Power_Max: float: TX power of the component carrier"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Seg_Reliability'),
 			ArgStruct.scalar_int('Statist_Expired'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
-			ArgStruct.scalar_float('Tx_Power_Min')]
+			ArgStruct.scalar_float('Tx_Power_Max')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Seg_Reliability: int = None
 			self.Statist_Expired: int = None
 			self.Out_Of_Tolerance: int = None
-			self.Tx_Power_Min: float = None
+			self.Tx_Power_Max: float = None
 
-	def fetch(self, segment=repcap.Segment.Default) -> FetchStruct:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:POWer:MINimum \n
-		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.power.minimum.fetch(segment = repcap.Segment.Default) \n
-		Return total TX power results for segment <no> in list mode. \n
+	def fetch(self, segment=repcap.Segment.Default, carrierComponentB=repcap.CarrierComponentB.Default) -> FetchStruct:
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:POWer:CC<no>:MAXimum \n
+		Snippet: value: FetchStruct = driver.lteMeas.multiEval.listPy.segment.power.cc.maximum.fetch(segment = repcap.Segment.Default, carrierComponentB = repcap.CarrierComponentB.Default) \n
+		Return TX power results for component carrier CC<no> and a single segment in list mode. \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
+			:param carrierComponentB: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Cc')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:POWer:MINimum?', self.__class__.FetchStruct())
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
+		carrierComponentB_cmd_val = self._cmd_group.get_repcap_cmd_value(carrierComponentB, repcap.CarrierComponentB)
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:POWer:CC{carrierComponentB_cmd_val}:MAXimum?', self.__class__.FetchStruct())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
 			- Reliability: int: No parameter help available
 			- Seg_Reliability: int: No parameter help available
 			- Statist_Expired: int: No parameter help available
 			- Out_Of_Tolerance: int: No parameter help available
-			- Tx_Power_Min: float: No parameter help available"""
+			- Tx_Power_Max: float or bool: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Seg_Reliability'),
 			ArgStruct.scalar_int('Statist_Expired'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
-			ArgStruct.scalar_float('Tx_Power_Min')]
+			ArgStruct.scalar_float_ext('Tx_Power_Max')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Seg_Reliability: int = None
 			self.Statist_Expired: int = None
 			self.Out_Of_Tolerance: int = None
-			self.Tx_Power_Min: float = None
+			self.Tx_Power_Max: float or bool = None
 
-	def calculate(self, segment=repcap.Segment.Default) -> CalculateStruct:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:POWer:MINimum \n
-		Snippet: value: CalculateStruct = driver.multiEval.listPy.segment.power.minimum.calculate(segment = repcap.Segment.Default) \n
+	def calculate(self, segment=repcap.Segment.Default, carrierComponentB=repcap.CarrierComponentB.Default) -> CalculateStruct:
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:POWer:CC<no>:MAXimum \n
+		Snippet: value: CalculateStruct = driver.lteMeas.multiEval.listPy.segment.power.cc.maximum.calculate(segment = repcap.Segment.Default, carrierComponentB = repcap.CarrierComponentB.Default) \n
 		No command help available \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
+			:param carrierComponentB: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Cc')
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
-		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:POWer:MINimum?', self.__class__.CalculateStruct())
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
+		carrierComponentB_cmd_val = self._cmd_group.get_repcap_cmd_value(carrierComponentB, repcap.CarrierComponentB)
+		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:POWer:CC{carrierComponentB_cmd_val}:MAXimum?', self.__class__.CalculateStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/Power_/StandardDev.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/Power/Average.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,26 +1,26 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.StructBase import StructBase
-from ......Internal.ArgStruct import ArgStruct
-from ...... import repcap
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal.StructBase import StructBase
+from .......Internal.ArgStruct import ArgStruct
+from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class StandardDev:
-	"""StandardDev commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class AverageCls:
+	"""Average commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("standardDev", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
+			- Reliability: int: 'Reliability indicator'
 			- Seg_Reliability: int: Reliability indicator for the segment
 			- Statist_Expired: int: Reached statistical length in subframes
 			- Out_Of_Tolerance: int: Percentage of measured subframes with failed limit check
 			- Tx_Power: float: Total TX power of all component carriers"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Seg_Reliability'),
@@ -33,14 +33,46 @@
 			self.Reliability: int = None
 			self.Seg_Reliability: int = None
 			self.Statist_Expired: int = None
 			self.Out_Of_Tolerance: int = None
 			self.Tx_Power: float = None
 
 	def fetch(self, segment=repcap.Segment.Default) -> FetchStruct:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:POWer:SDEViation \n
-		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.power.standardDev.fetch(segment = repcap.Segment.Default) \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:POWer:AVERage \n
+		Snippet: value: FetchStruct = driver.lteMeas.multiEval.listPy.segment.power.average.fetch(segment = repcap.Segment.Default) \n
 		Return total TX power results for segment <no> in list mode. \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:POWer:SDEViation?', self.__class__.FetchStruct())
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:POWer:AVERage?', self.__class__.FetchStruct())
+
+	# noinspection PyTypeChecker
+	class CalculateStruct(StructBase):
+		"""Response structure. Fields: \n
+			- Reliability: int: No parameter help available
+			- Seg_Reliability: int: No parameter help available
+			- Statist_Expired: int: No parameter help available
+			- Out_Of_Tolerance: int: No parameter help available
+			- Tx_Power: float or bool: No parameter help available"""
+		__meta_args_list = [
+			ArgStruct.scalar_int('Reliability', 'Reliability'),
+			ArgStruct.scalar_int('Seg_Reliability'),
+			ArgStruct.scalar_int('Statist_Expired'),
+			ArgStruct.scalar_int('Out_Of_Tolerance'),
+			ArgStruct.scalar_float_ext('Tx_Power')]
+
+		def __init__(self):
+			StructBase.__init__(self, self)
+			self.Reliability: int = None
+			self.Seg_Reliability: int = None
+			self.Statist_Expired: int = None
+			self.Out_Of_Tolerance: int = None
+			self.Tx_Power: float or bool = None
+
+	def calculate(self, segment=repcap.Segment.Default) -> CalculateStruct:
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:POWer:AVERage \n
+		Snippet: value: CalculateStruct = driver.lteMeas.multiEval.listPy.segment.power.average.calculate(segment = repcap.Segment.Default) \n
+		No command help available \n
+			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
+			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
+		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:POWer:AVERage?', self.__class__.CalculateStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/SeMask.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/SeMask/__init__.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,83 +1,91 @@
 from .....Internal.Core import Core
 from .....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class SeMask:
-	"""SeMask commands group definition. 19 total commands, 8 Sub-groups, 0 group commands"""
+class SeMaskCls:
+	"""SeMask commands group definition. 28 total commands, 9 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("seMask", core, parent)
+		self._cmd_group = CommandsGroup("seMask", core, parent)
 
 	@property
 	def current(self):
-		"""current commands group. 0 Sub-classes, 2 commands."""
+		"""current commands group. 0 Sub-classes, 3 commands."""
 		if not hasattr(self, '_current'):
-			from .SeMask_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
 	@property
 	def average(self):
-		"""average commands group. 0 Sub-classes, 2 commands."""
+		"""average commands group. 0 Sub-classes, 3 commands."""
 		if not hasattr(self, '_average'):
-			from .SeMask_.Average import Average
-			self._average = Average(self._core, self._base)
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
 		return self._average
 
 	@property
+	def minimum(self):
+		"""minimum commands group. 0 Sub-classes, 3 commands."""
+		if not hasattr(self, '_minimum'):
+			from .Minimum import MinimumCls
+			self._minimum = MinimumCls(self._core, self._cmd_group)
+		return self._minimum
+
+	@property
+	def maximum(self):
+		"""maximum commands group. 0 Sub-classes, 3 commands."""
+		if not hasattr(self, '_maximum'):
+			from .Maximum import MaximumCls
+			self._maximum = MaximumCls(self._core, self._cmd_group)
+		return self._maximum
+
+	@property
 	def extreme(self):
-		"""extreme commands group. 0 Sub-classes, 2 commands."""
+		"""extreme commands group. 0 Sub-classes, 3 commands."""
 		if not hasattr(self, '_extreme'):
-			from .SeMask_.Extreme import Extreme
-			self._extreme = Extreme(self._core, self._base)
+			from .Extreme import ExtremeCls
+			self._extreme = ExtremeCls(self._core, self._cmd_group)
 		return self._extreme
 
 	@property
 	def standardDev(self):
-		"""standardDev commands group. 0 Sub-classes, 2 commands."""
+		"""standardDev commands group. 0 Sub-classes, 3 commands."""
 		if not hasattr(self, '_standardDev'):
-			from .SeMask_.StandardDev import StandardDev
-			self._standardDev = StandardDev(self._core, self._base)
+			from .StandardDev import StandardDevCls
+			self._standardDev = StandardDevCls(self._core, self._cmd_group)
 		return self._standardDev
 
 	@property
 	def margin(self):
 		"""margin commands group. 4 Sub-classes, 1 commands."""
 		if not hasattr(self, '_margin'):
-			from .SeMask_.Margin import Margin
-			self._margin = Margin(self._core, self._base)
+			from .Margin import MarginCls
+			self._margin = MarginCls(self._core, self._cmd_group)
 		return self._margin
 
 	@property
-	def dmodulation(self):
-		"""dmodulation commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_dmodulation'):
-			from .SeMask_.Dmodulation import Dmodulation
-			self._dmodulation = Dmodulation(self._core, self._base)
-		return self._dmodulation
-
-	@property
 	def dchType(self):
 		"""dchType commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_dchType'):
-			from .SeMask_.DchType import DchType
-			self._dchType = DchType(self._core, self._base)
+			from .DchType import DchTypeCls
+			self._dchType = DchTypeCls(self._core, self._cmd_group)
 		return self._dchType
 
 	@property
 	def dallocation(self):
 		"""dallocation commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_dallocation'):
-			from .SeMask_.Dallocation import Dallocation
-			self._dallocation = Dallocation(self._core, self._base)
+			from .Dallocation import DallocationCls
+			self._dallocation = DallocationCls(self._core, self._cmd_group)
 		return self._dallocation
 
-	def clone(self) -> 'SeMask':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'SeMaskCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = SeMask(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = SeMaskCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/SeMask_/Average.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/SeMask/Current.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,26 +1,26 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.StructBase import StructBase
-from ......Internal.ArgStruct import ArgStruct
-from ...... import repcap
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal.StructBase import StructBase
+from .......Internal.ArgStruct import ArgStruct
+from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
+			- Reliability: int: 'Reliability indicator'
 			- Seg_Reliability: int: Reliability indicator for the segment
 			- Statist_Expired: int: Reached statistical length in slots
 			- Out_Of_Tolerance: int: Percentage of measured subframes with failed limit check
 			- Obw: float: Occupied bandwidth
 			- Tx_Power: float: Total TX power in the slot"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
@@ -36,53 +36,53 @@
 			self.Seg_Reliability: int = None
 			self.Statist_Expired: int = None
 			self.Out_Of_Tolerance: int = None
 			self.Obw: float = None
 			self.Tx_Power: float = None
 
 	def fetch(self, segment=repcap.Segment.Default) -> FetchStruct:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:SEMask:AVERage \n
-		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.seMask.average.fetch(segment = repcap.Segment.Default) \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:SEMask:CURRent \n
+		Snippet: value: FetchStruct = driver.lteMeas.multiEval.listPy.segment.seMask.current.fetch(segment = repcap.Segment.Default) \n
 		Return spectrum emission single value results for segment <no> in list mode. The values described below are returned by
-		FETCh commands. The first four values (reliability to out-of-tolerance result) are also returned by CALCulate commands.
+		FETCh commands. The first four values (reliability to out of tolerance result) are also returned by CALCulate commands.
 		The remaining values returned by CALCulate commands are limit check results, one value for each result listed below. \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:SEMask:AVERage?', self.__class__.FetchStruct())
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:SEMask:CURRent?', self.__class__.FetchStruct())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
+			- Reliability: int: 'Reliability indicator'
 			- Seg_Reliability: int: Reliability indicator for the segment
 			- Statist_Expired: int: Reached statistical length in slots
 			- Out_Of_Tolerance: int: Percentage of measured subframes with failed limit check
-			- Obw: float: Occupied bandwidth
-			- Tx_Power: float: Total TX power in the slot"""
+			- Obw: float or bool: Occupied bandwidth
+			- Tx_Power: float or bool: Total TX power in the slot"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Seg_Reliability'),
 			ArgStruct.scalar_int('Statist_Expired'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
-			ArgStruct.scalar_float('Obw'),
-			ArgStruct.scalar_float('Tx_Power')]
+			ArgStruct.scalar_float_ext('Obw'),
+			ArgStruct.scalar_float_ext('Tx_Power')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Seg_Reliability: int = None
 			self.Statist_Expired: int = None
 			self.Out_Of_Tolerance: int = None
-			self.Obw: float = None
-			self.Tx_Power: float = None
+			self.Obw: float or bool = None
+			self.Tx_Power: float or bool = None
 
 	def calculate(self, segment=repcap.Segment.Default) -> CalculateStruct:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:SEMask:AVERage \n
-		Snippet: value: CalculateStruct = driver.multiEval.listPy.segment.seMask.average.calculate(segment = repcap.Segment.Default) \n
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:SEMask:CURRent \n
+		Snippet: value: CalculateStruct = driver.lteMeas.multiEval.listPy.segment.seMask.current.calculate(segment = repcap.Segment.Default) \n
 		Return spectrum emission single value results for segment <no> in list mode. The values described below are returned by
-		FETCh commands. The first four values (reliability to out-of-tolerance result) are also returned by CALCulate commands.
+		FETCh commands. The first four values (reliability to out of tolerance result) are also returned by CALCulate commands.
 		The remaining values returned by CALCulate commands are limit check results, one value for each result listed below. \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
-		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:SEMask:AVERage?', self.__class__.CalculateStruct())
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
+		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:SEMask:CURRent?', self.__class__.CalculateStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/SeMask_/Current.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/SeMask/Average.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,26 +1,26 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.StructBase import StructBase
-from ......Internal.ArgStruct import ArgStruct
-from ...... import repcap
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal.StructBase import StructBase
+from .......Internal.ArgStruct import ArgStruct
+from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class AverageCls:
+	"""Average commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
+			- Reliability: int: 'Reliability indicator'
 			- Seg_Reliability: int: Reliability indicator for the segment
 			- Statist_Expired: int: Reached statistical length in slots
 			- Out_Of_Tolerance: int: Percentage of measured subframes with failed limit check
 			- Obw: float: Occupied bandwidth
 			- Tx_Power: float: Total TX power in the slot"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
@@ -36,53 +36,53 @@
 			self.Seg_Reliability: int = None
 			self.Statist_Expired: int = None
 			self.Out_Of_Tolerance: int = None
 			self.Obw: float = None
 			self.Tx_Power: float = None
 
 	def fetch(self, segment=repcap.Segment.Default) -> FetchStruct:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:SEMask:CURRent \n
-		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.seMask.current.fetch(segment = repcap.Segment.Default) \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:SEMask:AVERage \n
+		Snippet: value: FetchStruct = driver.lteMeas.multiEval.listPy.segment.seMask.average.fetch(segment = repcap.Segment.Default) \n
 		Return spectrum emission single value results for segment <no> in list mode. The values described below are returned by
-		FETCh commands. The first four values (reliability to out-of-tolerance result) are also returned by CALCulate commands.
+		FETCh commands. The first four values (reliability to out of tolerance result) are also returned by CALCulate commands.
 		The remaining values returned by CALCulate commands are limit check results, one value for each result listed below. \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:SEMask:CURRent?', self.__class__.FetchStruct())
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:SEMask:AVERage?', self.__class__.FetchStruct())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
+			- Reliability: int: 'Reliability indicator'
 			- Seg_Reliability: int: Reliability indicator for the segment
 			- Statist_Expired: int: Reached statistical length in slots
 			- Out_Of_Tolerance: int: Percentage of measured subframes with failed limit check
-			- Obw: float: Occupied bandwidth
-			- Tx_Power: float: Total TX power in the slot"""
+			- Obw: float or bool: Occupied bandwidth
+			- Tx_Power: float or bool: Total TX power in the slot"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Seg_Reliability'),
 			ArgStruct.scalar_int('Statist_Expired'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
-			ArgStruct.scalar_float('Obw'),
-			ArgStruct.scalar_float('Tx_Power')]
+			ArgStruct.scalar_float_ext('Obw'),
+			ArgStruct.scalar_float_ext('Tx_Power')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Seg_Reliability: int = None
 			self.Statist_Expired: int = None
 			self.Out_Of_Tolerance: int = None
-			self.Obw: float = None
-			self.Tx_Power: float = None
+			self.Obw: float or bool = None
+			self.Tx_Power: float or bool = None
 
 	def calculate(self, segment=repcap.Segment.Default) -> CalculateStruct:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:SEMask:CURRent \n
-		Snippet: value: CalculateStruct = driver.multiEval.listPy.segment.seMask.current.calculate(segment = repcap.Segment.Default) \n
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:SEMask:AVERage \n
+		Snippet: value: CalculateStruct = driver.lteMeas.multiEval.listPy.segment.seMask.average.calculate(segment = repcap.Segment.Default) \n
 		Return spectrum emission single value results for segment <no> in list mode. The values described below are returned by
-		FETCh commands. The first four values (reliability to out-of-tolerance result) are also returned by CALCulate commands.
+		FETCh commands. The first four values (reliability to out of tolerance result) are also returned by CALCulate commands.
 		The remaining values returned by CALCulate commands are limit check results, one value for each result listed below. \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
-		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:SEMask:CURRent?', self.__class__.CalculateStruct())
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
+		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:SEMask:AVERage?', self.__class__.CalculateStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/SeMask_/Dallocation.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/SeMask/Dallocation.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,46 +1,39 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.StructBase import StructBase
-from ......Internal.ArgStruct import ArgStruct
-from ...... import repcap
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
+from .....Internal.StructBase import StructBase
+from .....Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Dallocation:
-	"""Dallocation commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class DallocationCls:
+	"""Dallocation commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("dallocation", core, parent)
+		self._cmd_group = CommandsGroup("dallocation", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Seg_Reliability: int: Reliability indicator for the segment
+			- Reliability: int: 'Reliability indicator'
 			- Nr_Res_Blocks: int: Number of allocated resource blocks
 			- Offset_Res_Blocks: int: Offset of the first allocated resource block from the edge of the allocated UL transmission bandwidth"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_int('Seg_Reliability'),
 			ArgStruct.scalar_int('Nr_Res_Blocks'),
 			ArgStruct.scalar_int('Offset_Res_Blocks')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
-			self.Seg_Reliability: int = None
 			self.Nr_Res_Blocks: int = None
 			self.Offset_Res_Blocks: int = None
 
-	def fetch(self, segment=repcap.Segment.Default) -> FetchStruct:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:SEMask:DALLocation \n
-		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.seMask.dallocation.fetch(segment = repcap.Segment.Default) \n
-		Return the detected allocation for segment <no> in list mode. The result is determined from the last measured slot of the
-		statistical length. The individual measurements provide identical detected allocation results when measuring the same
-		slot. However different statistical lengths can be defined for the measurements so that the measured slots and returned
-		results can differ. \n
-			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
+	def fetch(self) -> FetchStruct:
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:SEMask:DALLocation \n
+		Snippet: value: FetchStruct = driver.lteMeas.multiEval.seMask.dallocation.fetch() \n
+		Returns the detected allocation for the measured slot. If the same slot is measured by the individual measurements, all
+		commands yield the same result. If different statistic counts are defined for the modulation, ACLR and spectrum emission
+		mask measurements, different slots can be measured and different results can be returned by the individual commands. \n
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:SEMask:DALLocation?', self.__class__.FetchStruct())
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:SEMask:DALLocation?', self.__class__.FetchStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/SeMask_/DchType.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/Aclr/DchType.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,44 +1,43 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.StructBase import StructBase
-from ......Internal.ArgStruct import ArgStruct
-from ...... import enums
-from ...... import repcap
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal.StructBase import StructBase
+from .......Internal.ArgStruct import ArgStruct
+from ....... import enums
+from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class DchType:
-	"""DchType commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class DchTypeCls:
+	"""DchType commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("dchType", core, parent)
+		self._cmd_group = CommandsGroup("dchType", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
+			- Reliability: int: 'Reliability indicator'
 			- Seg_Reliability: int: Reliability indicator for the segment
 			- Channel_Type: enums.UplinkChannelType: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Seg_Reliability'),
 			ArgStruct.scalar_enum('Channel_Type', enums.UplinkChannelType)]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Seg_Reliability: int = None
 			self.Channel_Type: enums.UplinkChannelType = None
 
 	def fetch(self, segment=repcap.Segment.Default) -> FetchStruct:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:SEMask:DCHType \n
-		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.seMask.dchType.fetch(segment = repcap.Segment.Default) \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:ACLR:DCHType \n
+		Snippet: value: FetchStruct = driver.lteMeas.multiEval.listPy.segment.aclr.dchType.fetch(segment = repcap.Segment.Default) \n
 		Return the uplink channel type for segment <no> in list mode. The result is determined from the last measured slot of the
-		statistical length. The individual measurements provide identical detected channel type results when measuring the same
-		slot. However different statistical lengths can be defined for the measurements so that the measured slots and returned
-		results can differ. \n
+		statistical length. The individual measurements provide the same result when measuring the same slot. However different
+		statistical lengths can be defined for the measurements so that the measured slots and returned results can differ. \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:SEMask:DCHType?', self.__class__.FetchStruct())
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:ACLR:DCHType?', self.__class__.FetchStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/SeMask_/Dmodulation.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/Aclr/Dmodulation.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,22 +1,22 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.StructBase import StructBase
-from ......Internal.ArgStruct import ArgStruct
-from ...... import enums
-from ...... import repcap
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal.StructBase import StructBase
+from .......Internal.ArgStruct import ArgStruct
+from ....... import enums
+from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Dmodulation:
-	"""Dmodulation commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class DmodulationCls:
+	"""Dmodulation commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("dmodulation", core, parent)
+		self._cmd_group = CommandsGroup("dmodulation", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
 			- Reliability: int: No parameter help available
 			- Seg_Reliability: int: No parameter help available
 			- Modulation: enums.Modulation: No parameter help available"""
@@ -28,14 +28,14 @@
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Seg_Reliability: int = None
 			self.Modulation: enums.Modulation = None
 
 	def fetch(self, segment=repcap.Segment.Default) -> FetchStruct:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:SEMask:DMODulation \n
-		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.seMask.dmodulation.fetch(segment = repcap.Segment.Default) \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:ACLR:DMODulation \n
+		Snippet: value: FetchStruct = driver.lteMeas.multiEval.listPy.segment.aclr.dmodulation.fetch(segment = repcap.Segment.Default) \n
 		No command help available \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:SEMask:DMODulation?', self.__class__.FetchStruct())
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:ACLR:DMODulation?', self.__class__.FetchStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/SeMask_/Extreme.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/SeMask/Extreme.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,26 +1,26 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.StructBase import StructBase
-from ......Internal.ArgStruct import ArgStruct
-from ...... import repcap
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal.StructBase import StructBase
+from .......Internal.ArgStruct import ArgStruct
+from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Extreme:
-	"""Extreme commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class ExtremeCls:
+	"""Extreme commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("extreme", core, parent)
+		self._cmd_group = CommandsGroup("extreme", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
+			- Reliability: int: 'Reliability indicator'
 			- Seg_Reliability: int: Reliability indicator for the segment
 			- Statist_Expired: int: Reached statistical length in slots
 			- Out_Of_Tolerance: int: Percentage of measured subframes with failed limit check
 			- Obw: float: Occupied bandwidth
 			- Tx_Power_Min: float: Minimum total TX power in the slot
 			- Tx_Power_Max: float: Maximum total TX power in the slot"""
 		__meta_args_list = [
@@ -40,55 +40,55 @@
 			self.Out_Of_Tolerance: int = None
 			self.Obw: float = None
 			self.Tx_Power_Min: float = None
 			self.Tx_Power_Max: float = None
 
 	def fetch(self, segment=repcap.Segment.Default) -> FetchStruct:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:SEMask:EXTReme \n
-		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.seMask.extreme.fetch(segment = repcap.Segment.Default) \n
+		Snippet: value: FetchStruct = driver.lteMeas.multiEval.listPy.segment.seMask.extreme.fetch(segment = repcap.Segment.Default) \n
 		Return spectrum emission extreme results for segment <no> in list mode. The values described below are returned by FETCh
-		commands. The first four values (reliability to out-of-tolerance result) are also returned by CALCulate commands.
+		commands. The first four values (reliability to out of tolerance result) are also returned by CALCulate commands.
 		The remaining values returned by CALCulate commands are limit check results, one value for each result listed below. \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:SEMask:EXTReme?', self.__class__.FetchStruct())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
+			- Reliability: int: 'Reliability indicator'
 			- Seg_Reliability: int: Reliability indicator for the segment
 			- Statist_Expired: int: Reached statistical length in slots
 			- Out_Of_Tolerance: int: Percentage of measured subframes with failed limit check
-			- Obw: float: Occupied bandwidth
-			- Tx_Power_Min: float: Minimum total TX power in the slot
-			- Tx_Power_Max: float: Maximum total TX power in the slot"""
+			- Obw: float or bool: Occupied bandwidth
+			- Tx_Power_Min: float or bool: Minimum total TX power in the slot
+			- Tx_Power_Max: float or bool: Maximum total TX power in the slot"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Seg_Reliability'),
 			ArgStruct.scalar_int('Statist_Expired'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
-			ArgStruct.scalar_float('Obw'),
-			ArgStruct.scalar_float('Tx_Power_Min'),
-			ArgStruct.scalar_float('Tx_Power_Max')]
+			ArgStruct.scalar_float_ext('Obw'),
+			ArgStruct.scalar_float_ext('Tx_Power_Min'),
+			ArgStruct.scalar_float_ext('Tx_Power_Max')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Seg_Reliability: int = None
 			self.Statist_Expired: int = None
 			self.Out_Of_Tolerance: int = None
-			self.Obw: float = None
-			self.Tx_Power_Min: float = None
-			self.Tx_Power_Max: float = None
+			self.Obw: float or bool = None
+			self.Tx_Power_Min: float or bool = None
+			self.Tx_Power_Max: float or bool = None
 
 	def calculate(self, segment=repcap.Segment.Default) -> CalculateStruct:
 		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:SEMask:EXTReme \n
-		Snippet: value: CalculateStruct = driver.multiEval.listPy.segment.seMask.extreme.calculate(segment = repcap.Segment.Default) \n
+		Snippet: value: CalculateStruct = driver.lteMeas.multiEval.listPy.segment.seMask.extreme.calculate(segment = repcap.Segment.Default) \n
 		Return spectrum emission extreme results for segment <no> in list mode. The values described below are returned by FETCh
-		commands. The first four values (reliability to out-of-tolerance result) are also returned by CALCulate commands.
+		commands. The first four values (reliability to out of tolerance result) are also returned by CALCulate commands.
 		The remaining values returned by CALCulate commands are limit check results, one value for each result listed below. \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:SEMask:EXTReme?', self.__class__.CalculateStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/SeMask_/Margin.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/SeMask/Margin/__init__.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,104 +1,95 @@
 from typing import List
 
 from ......Internal.Core import Core
 from ......Internal.CommandsGroup import CommandsGroup
 from ......Internal.Types import DataType
 from ......Internal.StructBase import StructBase
 from ......Internal.ArgStruct import ArgStruct
-from ...... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Margin:
-	"""Margin commands group definition. 8 total commands, 4 Sub-groups, 1 group commands"""
+class MarginCls:
+	"""Margin commands group definition. 8 total commands, 4 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("margin", core, parent)
+		self._cmd_group = CommandsGroup("margin", core, parent)
 
 	@property
 	def all(self):
 		"""all commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_all'):
-			from .Margin_.All import All
-			self._all = All(self._core, self._base)
+			from .All import AllCls
+			self._all = AllCls(self._core, self._cmd_group)
 		return self._all
 
 	@property
 	def current(self):
 		"""current commands group. 2 Sub-classes, 0 commands."""
 		if not hasattr(self, '_current'):
-			from .Margin_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
 	@property
 	def average(self):
 		"""average commands group. 2 Sub-classes, 0 commands."""
 		if not hasattr(self, '_average'):
-			from .Margin_.Average import Average
-			self._average = Average(self._core, self._base)
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
 		return self._average
 
 	@property
 	def minimum(self):
 		"""minimum commands group. 2 Sub-classes, 0 commands."""
 		if not hasattr(self, '_minimum'):
-			from .Margin_.Minimum import Minimum
-			self._minimum = Minimum(self._core, self._base)
+			from .Minimum import MinimumCls
+			self._minimum = MinimumCls(self._core, self._cmd_group)
 		return self._minimum
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
 			- Reliability: int: No parameter help available
-			- Seg_Reliability: int: No parameter help available
-			- Statist_Expired: int: No parameter help available
 			- Out_Of_Tolerance: int: No parameter help available
 			- Margin_Curr_Neg: List[float]: No parameter help available
 			- Margin_Curr_Pos: List[float]: No parameter help available
 			- Margin_Avg_Neg: List[float]: No parameter help available
 			- Margin_Avg_Pos: List[float]: No parameter help available
 			- Margin_Min_Neg: List[float]: No parameter help available
 			- Margin_Min_Pos: List[float]: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_int('Seg_Reliability'),
-			ArgStruct.scalar_int('Statist_Expired'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
 			ArgStruct('Margin_Curr_Neg', DataType.FloatList, None, False, False, 10),
 			ArgStruct('Margin_Curr_Pos', DataType.FloatList, None, False, False, 10),
 			ArgStruct('Margin_Avg_Neg', DataType.FloatList, None, False, False, 10),
 			ArgStruct('Margin_Avg_Pos', DataType.FloatList, None, False, False, 10),
 			ArgStruct('Margin_Min_Neg', DataType.FloatList, None, False, False, 10),
 			ArgStruct('Margin_Min_Pos', DataType.FloatList, None, False, False, 10)]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
-			self.Seg_Reliability: int = None
-			self.Statist_Expired: int = None
 			self.Out_Of_Tolerance: int = None
 			self.Margin_Curr_Neg: List[float] = None
 			self.Margin_Curr_Pos: List[float] = None
 			self.Margin_Avg_Neg: List[float] = None
 			self.Margin_Avg_Pos: List[float] = None
 			self.Margin_Min_Neg: List[float] = None
 			self.Margin_Min_Pos: List[float] = None
 
-	def fetch(self, segment=repcap.Segment.Default) -> FetchStruct:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:SEMask:MARGin \n
-		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.seMask.margin.fetch(segment = repcap.Segment.Default) \n
+	def fetch(self) -> FetchStruct:
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:SEMask:MARGin \n
+		Snippet: value: FetchStruct = driver.lteMeas.multiEval.seMask.margin.fetch() \n
 		No command help available \n
-			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:SEMask:MARGin?', self.__class__.FetchStruct())
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:SEMask:MARGin?', self.__class__.FetchStruct())
 
-	def clone(self) -> 'Margin':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'MarginCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Margin(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = MarginCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/SeMask_/Margin_/All.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/SeMask/Margin/All.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,29 +1,29 @@
 from typing import List
 
-from .......Internal.Core import Core
-from .......Internal.CommandsGroup import CommandsGroup
-from .......Internal.Types import DataType
-from .......Internal.StructBase import StructBase
-from .......Internal.ArgStruct import ArgStruct
-from ....... import repcap
+from ........Internal.Core import Core
+from ........Internal.CommandsGroup import CommandsGroup
+from ........Internal.Types import DataType
+from ........Internal.StructBase import StructBase
+from ........Internal.ArgStruct import ArgStruct
+from ........ import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class All:
-	"""All commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class AllCls:
+	"""All commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("all", core, parent)
+		self._cmd_group = CommandsGroup("all", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
+			- Reliability: int: 'Reliability indicator'
 			- Seg_Reliability: int: Reliability indicator for the segment
 			- Statist_Expired: int: Reached statistical length in slots
 			- Out_Of_Tolerance: int: Percentage of measured subframes with failed limit check
 			- Margin_Curr_Neg: List[float]: No parameter help available
 			- Margin_Curr_Pos: List[float]: No parameter help available
 			- Margin_Avg_Neg: List[float]: No parameter help available
 			- Margin_Avg_Pos: List[float]: No parameter help available
@@ -52,14 +52,14 @@
 			self.Margin_Avg_Neg: List[float] = None
 			self.Margin_Avg_Pos: List[float] = None
 			self.Margin_Min_Neg: List[float] = None
 			self.Margin_Min_Pos: List[float] = None
 
 	def fetch(self, segment=repcap.Segment.Default) -> FetchStruct:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:SEMask:MARGin:ALL \n
-		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.seMask.margin.all.fetch(segment = repcap.Segment.Default) \n
-		Return limit line margin values, i.e. vertical distances between the spectrum emission mask limit line and a trace, for
-		segment <no> in list mode. \n
+		Snippet: value: FetchStruct = driver.lteMeas.multiEval.listPy.segment.seMask.margin.all.fetch(segment = repcap.Segment.Default) \n
+		Return limit line margin values, i.e. vertical distances between the spectrum emission mask and a trace, for segment <no>
+		in list mode. \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:SEMask:MARGin:ALL?', self.__class__.FetchStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/SeMask_/Margin_/Average.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/SeMask/Margin/Average/__init__.py`

 * *Files 11% similar despite different names*

```diff
@@ -1,35 +1,35 @@
-from .......Internal.Core import Core
-from .......Internal.CommandsGroup import CommandsGroup
+from .........Internal.Core import Core
+from .........Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 2 total commands, 2 Sub-groups, 0 group commands"""
+class AverageCls:
+	"""Average commands group definition. 2 total commands, 2 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	@property
 	def negativ(self):
 		"""negativ commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_negativ'):
-			from .Average_.Negativ import Negativ
-			self._negativ = Negativ(self._core, self._base)
+			from .Negativ import NegativCls
+			self._negativ = NegativCls(self._core, self._cmd_group)
 		return self._negativ
 
 	@property
 	def positiv(self):
 		"""positiv commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_positiv'):
-			from .Average_.Positiv import Positiv
-			self._positiv = Positiv(self._core, self._base)
+			from .Positiv import PositivCls
+			self._positiv = PositivCls(self._core, self._cmd_group)
 		return self._positiv
 
-	def clone(self) -> 'Average':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'AverageCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Average(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = AverageCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/SeMask_/Margin_/Average_/Negativ.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/SeMask/Margin/Minimum/Negativ.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,55 +1,55 @@
 from typing import List
 
-from ........Internal.Core import Core
-from ........Internal.CommandsGroup import CommandsGroup
-from ........Internal.Types import DataType
-from ........Internal.StructBase import StructBase
-from ........Internal.ArgStruct import ArgStruct
-from ........ import repcap
+from .........Internal.Core import Core
+from .........Internal.CommandsGroup import CommandsGroup
+from .........Internal.Types import DataType
+from .........Internal.StructBase import StructBase
+from .........Internal.ArgStruct import ArgStruct
+from ......... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Negativ:
-	"""Negativ commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class NegativCls:
+	"""Negativ commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("negativ", core, parent)
+		self._cmd_group = CommandsGroup("negativ", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
+			- Reliability: int: 'Reliability indicator'
 			- Seg_Reliability: int: Reliability indicator for the segment
 			- Statist_Expired: int: Reached statistical length in slots
 			- Out_Of_Tolerance: int: Percentage of measured subframes with failed limit check
-			- Margin_Avg_Neg_X: List[float]: No parameter help available
-			- Margin_Avg_Neg_Y: List[float]: No parameter help available"""
+			- Margin_Min_Neg_X: List[float]: No parameter help available
+			- Margin_Min_Neg_Y: List[float]: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Seg_Reliability'),
 			ArgStruct.scalar_int('Statist_Expired'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
-			ArgStruct('Margin_Avg_Neg_X', DataType.FloatList, None, False, True, 1),
-			ArgStruct('Margin_Avg_Neg_Y', DataType.FloatList, None, False, True, 1)]
+			ArgStruct('Margin_Min_Neg_X', DataType.FloatList, None, False, True, 1),
+			ArgStruct('Margin_Min_Neg_Y', DataType.FloatList, None, False, True, 1)]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Seg_Reliability: int = None
 			self.Statist_Expired: int = None
 			self.Out_Of_Tolerance: int = None
-			self.Margin_Avg_Neg_X: List[float] = None
-			self.Margin_Avg_Neg_Y: List[float] = None
+			self.Margin_Min_Neg_X: List[float] = None
+			self.Margin_Min_Neg_Y: List[float] = None
 
 	def fetch(self, segment=repcap.Segment.Default) -> FetchStruct:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:SEMask:MARGin:AVERage:NEGativ \n
-		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.seMask.margin.average.negativ.fetch(segment = repcap.Segment.Default) \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:SEMask:MARGin:MINimum:NEGativ \n
+		Snippet: value: FetchStruct = driver.lteMeas.multiEval.listPy.segment.seMask.margin.minimum.negativ.fetch(segment = repcap.Segment.Default) \n
 		Return spectrum emission mask margin results for segment <no> in list mode. The individual commands provide results for
 		the CURRent, AVERage and maximum traces (resulting in MINimum margins) for NEGative and POSitive offset frequencies.
 		Returned sequence: <Reliability>, <SegReliability>, <StatistExpired>, <OutOfTolerance>, {<MarginX>, <MarginY>}area1, {...
 		}area2, ..., {...}area12 \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:SEMask:MARGin:AVERage:NEGativ?', self.__class__.FetchStruct())
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:SEMask:MARGin:MINimum:NEGativ?', self.__class__.FetchStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/SeMask_/Margin_/Average_/Positiv.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/SeMask/Margin/Average/Positiv.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,29 +1,29 @@
 from typing import List
 
-from ........Internal.Core import Core
-from ........Internal.CommandsGroup import CommandsGroup
-from ........Internal.Types import DataType
-from ........Internal.StructBase import StructBase
-from ........Internal.ArgStruct import ArgStruct
-from ........ import repcap
+from .........Internal.Core import Core
+from .........Internal.CommandsGroup import CommandsGroup
+from .........Internal.Types import DataType
+from .........Internal.StructBase import StructBase
+from .........Internal.ArgStruct import ArgStruct
+from ......... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Positiv:
-	"""Positiv commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class PositivCls:
+	"""Positiv commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("positiv", core, parent)
+		self._cmd_group = CommandsGroup("positiv", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
+			- Reliability: int: 'Reliability indicator'
 			- Seg_Reliability: int: Reliability indicator for the segment
 			- Statist_Expired: int: Reached statistical length in slots
 			- Out_Of_Tolerance: int: Percentage of measured subframes with failed limit check
 			- Margin_Avg_Pos_X: List[float]: No parameter help available
 			- Margin_Avg_Pos_Y: List[float]: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
@@ -40,16 +40,16 @@
 			self.Statist_Expired: int = None
 			self.Out_Of_Tolerance: int = None
 			self.Margin_Avg_Pos_X: List[float] = None
 			self.Margin_Avg_Pos_Y: List[float] = None
 
 	def fetch(self, segment=repcap.Segment.Default) -> FetchStruct:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:SEMask:MARGin:AVERage:POSitiv \n
-		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.seMask.margin.average.positiv.fetch(segment = repcap.Segment.Default) \n
+		Snippet: value: FetchStruct = driver.lteMeas.multiEval.listPy.segment.seMask.margin.average.positiv.fetch(segment = repcap.Segment.Default) \n
 		Return spectrum emission mask margin results for segment <no> in list mode. The individual commands provide results for
 		the CURRent, AVERage and maximum traces (resulting in MINimum margins) for NEGative and POSitive offset frequencies.
 		Returned sequence: <Reliability>, <SegReliability>, <StatistExpired>, <OutOfTolerance>, {<MarginX>, <MarginY>}area1, {...
 		}area2, ..., {...}area12 \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
 		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:SEMask:MARGin:AVERage:POSitiv?', self.__class__.FetchStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/SeMask_/Margin_/Current.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Sense/LteMeas/MultiEval/Spectrum/SeMask/__init__.py`

 * *Files 21% similar despite different names*

```diff
@@ -1,35 +1,27 @@
 from .......Internal.Core import Core
 from .......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 2 total commands, 2 Sub-groups, 0 group commands"""
+class SeMaskCls:
+	"""SeMask commands group definition. 1 total commands, 1 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("seMask", core, parent)
 
 	@property
-	def negativ(self):
-		"""negativ commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_negativ'):
-			from .Current_.Negativ import Negativ
-			self._negativ = Negativ(self._core, self._base)
-		return self._negativ
+	def rbw(self):
+		"""rbw commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_rbw'):
+			from .Rbw import RbwCls
+			self._rbw = RbwCls(self._core, self._cmd_group)
+		return self._rbw
 
-	@property
-	def positiv(self):
-		"""positiv commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_positiv'):
-			from .Current_.Positiv import Positiv
-			self._positiv = Positiv(self._core, self._base)
-		return self._positiv
-
-	def clone(self) -> 'Current':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'SeMaskCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Current(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = SeMaskCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/SeMask_/Margin_/Current_/Negativ.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/SeMask/Margin/Minimum/Positiv.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,55 +1,55 @@
 from typing import List
 
-from ........Internal.Core import Core
-from ........Internal.CommandsGroup import CommandsGroup
-from ........Internal.Types import DataType
-from ........Internal.StructBase import StructBase
-from ........Internal.ArgStruct import ArgStruct
-from ........ import repcap
+from .........Internal.Core import Core
+from .........Internal.CommandsGroup import CommandsGroup
+from .........Internal.Types import DataType
+from .........Internal.StructBase import StructBase
+from .........Internal.ArgStruct import ArgStruct
+from ......... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Negativ:
-	"""Negativ commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class PositivCls:
+	"""Positiv commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("negativ", core, parent)
+		self._cmd_group = CommandsGroup("positiv", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
+			- Reliability: int: 'Reliability indicator'
 			- Seg_Reliability: int: Reliability indicator for the segment
 			- Statist_Expired: int: Reached statistical length in slots
 			- Out_Of_Tolerance: int: Percentage of measured subframes with failed limit check
-			- Margin_Curr_Neg_X: List[float]: No parameter help available
-			- Margin_Curr_Neg_Y: List[float]: No parameter help available"""
+			- Margin_Min_Pos_X: List[float]: No parameter help available
+			- Margin_Min_Pos_Y: List[float]: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Seg_Reliability'),
 			ArgStruct.scalar_int('Statist_Expired'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
-			ArgStruct('Margin_Curr_Neg_X', DataType.FloatList, None, False, True, 1),
-			ArgStruct('Margin_Curr_Neg_Y', DataType.FloatList, None, False, True, 1)]
+			ArgStruct('Margin_Min_Pos_X', DataType.FloatList, None, False, True, 1),
+			ArgStruct('Margin_Min_Pos_Y', DataType.FloatList, None, False, True, 1)]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Seg_Reliability: int = None
 			self.Statist_Expired: int = None
 			self.Out_Of_Tolerance: int = None
-			self.Margin_Curr_Neg_X: List[float] = None
-			self.Margin_Curr_Neg_Y: List[float] = None
+			self.Margin_Min_Pos_X: List[float] = None
+			self.Margin_Min_Pos_Y: List[float] = None
 
 	def fetch(self, segment=repcap.Segment.Default) -> FetchStruct:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:SEMask:MARGin:CURRent:NEGativ \n
-		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.seMask.margin.current.negativ.fetch(segment = repcap.Segment.Default) \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:SEMask:MARGin:MINimum:POSitiv \n
+		Snippet: value: FetchStruct = driver.lteMeas.multiEval.listPy.segment.seMask.margin.minimum.positiv.fetch(segment = repcap.Segment.Default) \n
 		Return spectrum emission mask margin results for segment <no> in list mode. The individual commands provide results for
 		the CURRent, AVERage and maximum traces (resulting in MINimum margins) for NEGative and POSitive offset frequencies.
 		Returned sequence: <Reliability>, <SegReliability>, <StatistExpired>, <OutOfTolerance>, {<MarginX>, <MarginY>}area1, {...
 		}area2, ..., {...}area12 \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:SEMask:MARGin:CURRent:NEGativ?', self.__class__.FetchStruct())
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:SEMask:MARGin:MINimum:POSitiv?', self.__class__.FetchStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/SeMask_/Margin_/Current_/Positiv.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/SeMask/Margin/Current/Negativ.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,55 +1,47 @@
 from typing import List
 
-from ........Internal.Core import Core
-from ........Internal.CommandsGroup import CommandsGroup
-from ........Internal.Types import DataType
-from ........Internal.StructBase import StructBase
-from ........Internal.ArgStruct import ArgStruct
-from ........ import repcap
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal.Types import DataType
+from .......Internal.StructBase import StructBase
+from .......Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Positiv:
-	"""Positiv commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class NegativCls:
+	"""Negativ commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("positiv", core, parent)
+		self._cmd_group = CommandsGroup("negativ", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Seg_Reliability: int: Reliability indicator for the segment
-			- Statist_Expired: int: Reached statistical length in slots
-			- Out_Of_Tolerance: int: Percentage of measured subframes with failed limit check
-			- Margin_Curr_Pos_X: List[float]: No parameter help available
-			- Margin_Curr_Pos_Y: List[float]: No parameter help available"""
+			- Reliability: int: 'Reliability indicator'
+			- Out_Of_Tolerance: int: Out of tolerance result, i.e. the percentage of measurement intervals of the statistic count for spectrum emission measurements exceeding the specified spectrum emission mask limits.
+			- Margin_Curr_Neg_X: List[float]: No parameter help available
+			- Margin_Curr_Neg_Y: List[float]: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_int('Seg_Reliability'),
-			ArgStruct.scalar_int('Statist_Expired'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
-			ArgStruct('Margin_Curr_Pos_X', DataType.FloatList, None, False, True, 1),
-			ArgStruct('Margin_Curr_Pos_Y', DataType.FloatList, None, False, True, 1)]
+			ArgStruct('Margin_Curr_Neg_X', DataType.FloatList, None, False, True, 1),
+			ArgStruct('Margin_Curr_Neg_Y', DataType.FloatList, None, False, True, 1)]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
-			self.Seg_Reliability: int = None
-			self.Statist_Expired: int = None
 			self.Out_Of_Tolerance: int = None
-			self.Margin_Curr_Pos_X: List[float] = None
-			self.Margin_Curr_Pos_Y: List[float] = None
+			self.Margin_Curr_Neg_X: List[float] = None
+			self.Margin_Curr_Neg_Y: List[float] = None
 
-	def fetch(self, segment=repcap.Segment.Default) -> FetchStruct:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:SEMask:MARGin:CURRent:POSitiv \n
-		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.seMask.margin.current.positiv.fetch(segment = repcap.Segment.Default) \n
-		Return spectrum emission mask margin results for segment <no> in list mode. The individual commands provide results for
-		the CURRent, AVERage and maximum traces (resulting in MINimum margins) for NEGative and POSitive offset frequencies.
-		Returned sequence: <Reliability>, <SegReliability>, <StatistExpired>, <OutOfTolerance>, {<MarginX>, <MarginY>}area1, {...
-		}area2, ..., {...}area12 \n
-			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
+	def fetch(self) -> FetchStruct:
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:SEMask:MARGin:CURRent:NEGativ \n
+		Snippet: value: FetchStruct = driver.lteMeas.multiEval.seMask.margin.current.negativ.fetch() \n
+		Returns spectrum emission mask margin results. A negative margin indicates that the trace is located above the limit line,
+		i.e. the limit is exceeded. The individual commands provide results for the CURRent, AVERage and maximum traces
+		(resulting in MINimum margins) . For each trace, the x- and y-values of the margins for emission mask areas 1 to 12 are
+		provided for NEGative and POSitive offset frequencies. For inactive areas, NCAP is returned.
+		Returned sequence: <Reliability>, <OutOfTolerance>, {<MarginX>, <MarginY>}area1, {...}area2, ..., {...}area12 \n
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:SEMask:MARGin:CURRent:POSitiv?', self.__class__.FetchStruct())
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:SEMask:MARGin:CURRent:NEGativ?', self.__class__.FetchStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/SeMask_/Margin_/Minimum.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/Srs/Trace/__init__.py`

 * *Files 23% similar despite different names*

```diff
@@ -1,35 +1,27 @@
-from .......Internal.Core import Core
-from .......Internal.CommandsGroup import CommandsGroup
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Minimum:
-	"""Minimum commands group definition. 2 total commands, 2 Sub-groups, 0 group commands"""
+class TraceCls:
+	"""Trace commands group definition. 6 total commands, 1 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("minimum", core, parent)
+		self._cmd_group = CommandsGroup("trace", core, parent)
 
 	@property
-	def negativ(self):
-		"""negativ commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_negativ'):
-			from .Minimum_.Negativ import Negativ
-			self._negativ = Negativ(self._core, self._base)
-		return self._negativ
+	def pdynamics(self):
+		"""pdynamics commands group. 3 Sub-classes, 0 commands."""
+		if not hasattr(self, '_pdynamics'):
+			from .Pdynamics import PdynamicsCls
+			self._pdynamics = PdynamicsCls(self._core, self._cmd_group)
+		return self._pdynamics
 
-	@property
-	def positiv(self):
-		"""positiv commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_positiv'):
-			from .Minimum_.Positiv import Positiv
-			self._positiv = Positiv(self._core, self._base)
-		return self._positiv
-
-	def clone(self) -> 'Minimum':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'TraceCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Minimum(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = TraceCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/SeMask_/Margin_/Minimum_/Negativ.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/Prach/Trace/Iq.py`

 * *Files 21% similar despite different names*

```diff
@@ -1,55 +1,43 @@
 from typing import List
 
-from ........Internal.Core import Core
-from ........Internal.CommandsGroup import CommandsGroup
-from ........Internal.Types import DataType
-from ........Internal.StructBase import StructBase
-from ........Internal.ArgStruct import ArgStruct
-from ........ import repcap
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
+from .....Internal.Types import DataType
+from .....Internal.StructBase import StructBase
+from .....Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Negativ:
-	"""Negativ commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class IqCls:
+	"""Iq commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("negativ", core, parent)
+		self._cmd_group = CommandsGroup("iq", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Seg_Reliability: int: Reliability indicator for the segment
-			- Statist_Expired: int: Reached statistical length in slots
-			- Out_Of_Tolerance: int: Percentage of measured subframes with failed limit check
-			- Margin_Min_Neg_X: List[float]: No parameter help available
-			- Margin_Min_Neg_Y: List[float]: No parameter help available"""
+			- Reliability: int: 'Reliability indicator'
+			- Iphase: List[float]: Normalized I amplitude
+			- Qphase: List[float]: Normalized Q amplitude"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_int('Seg_Reliability'),
-			ArgStruct.scalar_int('Statist_Expired'),
-			ArgStruct.scalar_int('Out_Of_Tolerance'),
-			ArgStruct('Margin_Min_Neg_X', DataType.FloatList, None, False, True, 1),
-			ArgStruct('Margin_Min_Neg_Y', DataType.FloatList, None, False, True, 1)]
+			ArgStruct('Iphase', DataType.FloatList, None, False, True, 1),
+			ArgStruct('Qphase', DataType.FloatList, None, False, True, 1)]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
-			self.Seg_Reliability: int = None
-			self.Statist_Expired: int = None
-			self.Out_Of_Tolerance: int = None
-			self.Margin_Min_Neg_X: List[float] = None
-			self.Margin_Min_Neg_Y: List[float] = None
-
-	def fetch(self, segment=repcap.Segment.Default) -> FetchStruct:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:SEMask:MARGin:MINimum:NEGativ \n
-		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.seMask.margin.minimum.negativ.fetch(segment = repcap.Segment.Default) \n
-		Return spectrum emission mask margin results for segment <no> in list mode. The individual commands provide results for
-		the CURRent, AVERage and maximum traces (resulting in MINimum margins) for NEGative and POSitive offset frequencies.
-		Returned sequence: <Reliability>, <SegReliability>, <StatistExpired>, <OutOfTolerance>, {<MarginX>, <MarginY>}area1, {...
-		}area2, ..., {...}area12 \n
-			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
+			self.Iphase: List[float] = None
+			self.Qphase: List[float] = None
+
+	def fetch(self) -> FetchStruct:
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:PRACh:TRACe:IQ \n
+		Snippet: value: FetchStruct = driver.lteMeas.prach.trace.iq.fetch() \n
+		Returns the results in the I/Q constellation diagram. There is one pair of values per modulation symbol. For preamble
+		format 4, there are 139 symbols. For preamble format 0 to 3, there are 839 symbols. The results are returned in the
+		following order: <Reliability>, {<IPhase>, <QPhase>}symbol 1, ..., {<IPhase>, <QPhase>}symbol n See also 'Square I/Q
+		Constellation'. \n
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:SEMask:MARGin:MINimum:NEGativ?', self.__class__.FetchStruct())
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:PRACh:TRACe:IQ?', self.__class__.FetchStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/SeMask_/Margin_/Minimum_/Positiv.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Pmonitor/Minimum.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,55 +1,68 @@
-from typing import List
-
-from ........Internal.Core import Core
-from ........Internal.CommandsGroup import CommandsGroup
-from ........Internal.Types import DataType
-from ........Internal.StructBase import StructBase
-from ........Internal.ArgStruct import ArgStruct
-from ........ import repcap
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
+from .....Internal.StructBase import StructBase
+from .....Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Positiv:
-	"""Positiv commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class MinimumCls:
+	"""Minimum commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("positiv", core, parent)
+		self._cmd_group = CommandsGroup("minimum", core, parent)
+
+	# noinspection PyTypeChecker
+	class ResultData(StructBase):
+		"""Response structure. Fields: \n
+			- Reliability: int: 'Reliability indicator'
+			- Out_Of_Tolerance: int: Out of tolerance result, i.e. the percentage of measurement intervals of the statistic count for power measurements exceeding the specified power limits.
+			- Tx_Power: float: No parameter help available"""
+		__meta_args_list = [
+			ArgStruct.scalar_int('Reliability', 'Reliability'),
+			ArgStruct.scalar_int('Out_Of_Tolerance'),
+			ArgStruct.scalar_float('Tx_Power')]
+
+		def __init__(self):
+			StructBase.__init__(self, self)
+			self.Reliability: int = None
+			self.Out_Of_Tolerance: int = None
+			self.Tx_Power: float = None
+
+	def read(self) -> ResultData:
+		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:PMONitor:MINimum \n
+		Snippet: value: ResultData = driver.lteMeas.multiEval.pmonitor.minimum.read() \n
+		Returns the total TX power of all carriers. \n
+			:return: structure: for return value, see the help for ResultData structure arguments."""
+		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:PMONitor:MINimum?', self.__class__.ResultData())
+
+	def fetch(self) -> ResultData:
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:PMONitor:MINimum \n
+		Snippet: value: ResultData = driver.lteMeas.multiEval.pmonitor.minimum.fetch() \n
+		Returns the total TX power of all carriers. \n
+			:return: structure: for return value, see the help for ResultData structure arguments."""
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:PMONitor:MINimum?', self.__class__.ResultData())
 
 	# noinspection PyTypeChecker
-	class FetchStruct(StructBase):
+	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Seg_Reliability: int: Reliability indicator for the segment
-			- Statist_Expired: int: Reached statistical length in slots
-			- Out_Of_Tolerance: int: Percentage of measured subframes with failed limit check
-			- Margin_Min_Pos_X: List[float]: No parameter help available
-			- Margin_Min_Pos_Y: List[float]: No parameter help available"""
+			- Reliability: int: No parameter help available
+			- Out_Of_Tolerance: int: No parameter help available
+			- Tx_Power: float or bool: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_int('Seg_Reliability'),
-			ArgStruct.scalar_int('Statist_Expired'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
-			ArgStruct('Margin_Min_Pos_X', DataType.FloatList, None, False, True, 1),
-			ArgStruct('Margin_Min_Pos_Y', DataType.FloatList, None, False, True, 1)]
+			ArgStruct.scalar_float_ext('Tx_Power')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
-			self.Seg_Reliability: int = None
-			self.Statist_Expired: int = None
 			self.Out_Of_Tolerance: int = None
-			self.Margin_Min_Pos_X: List[float] = None
-			self.Margin_Min_Pos_Y: List[float] = None
+			self.Tx_Power: float or bool = None
 
-	def fetch(self, segment=repcap.Segment.Default) -> FetchStruct:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:SEMask:MARGin:MINimum:POSitiv \n
-		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.seMask.margin.minimum.positiv.fetch(segment = repcap.Segment.Default) \n
-		Return spectrum emission mask margin results for segment <no> in list mode. The individual commands provide results for
-		the CURRent, AVERage and maximum traces (resulting in MINimum margins) for NEGative and POSitive offset frequencies.
-		Returned sequence: <Reliability>, <SegReliability>, <StatistExpired>, <OutOfTolerance>, {<MarginX>, <MarginY>}area1, {...
-		}area2, ..., {...}area12 \n
-			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
-			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:SEMask:MARGin:MINimum:POSitiv?', self.__class__.FetchStruct())
+	def calculate(self) -> CalculateStruct:
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:PMONitor:MINimum \n
+		Snippet: value: CalculateStruct = driver.lteMeas.multiEval.pmonitor.minimum.calculate() \n
+		No command help available \n
+			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
+		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:PMONitor:MINimum?', self.__class__.CalculateStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Segment_/SeMask_/StandardDev.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/Power/Maximum.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,86 +1,78 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.StructBase import StructBase
-from ......Internal.ArgStruct import ArgStruct
-from ...... import repcap
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal.StructBase import StructBase
+from .......Internal.ArgStruct import ArgStruct
+from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class StandardDev:
-	"""StandardDev commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class MaximumCls:
+	"""Maximum commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("standardDev", core, parent)
+		self._cmd_group = CommandsGroup("maximum", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
+			- Reliability: int: 'Reliability indicator'
 			- Seg_Reliability: int: Reliability indicator for the segment
-			- Statist_Expired: int: Reached statistical length in slots
+			- Statist_Expired: int: Reached statistical length in subframes
 			- Out_Of_Tolerance: int: Percentage of measured subframes with failed limit check
-			- Obw: float: Occupied bandwidth
-			- Tx_Power: float: Total TX power in the slot"""
+			- Tx_Power_Max: float: Total TX power of all component carriers"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Seg_Reliability'),
 			ArgStruct.scalar_int('Statist_Expired'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
-			ArgStruct.scalar_float('Obw'),
-			ArgStruct.scalar_float('Tx_Power')]
+			ArgStruct.scalar_float('Tx_Power_Max')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Seg_Reliability: int = None
 			self.Statist_Expired: int = None
 			self.Out_Of_Tolerance: int = None
-			self.Obw: float = None
-			self.Tx_Power: float = None
+			self.Tx_Power_Max: float = None
 
 	def fetch(self, segment=repcap.Segment.Default) -> FetchStruct:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:SEMask:SDEViation \n
-		Snippet: value: FetchStruct = driver.multiEval.listPy.segment.seMask.standardDev.fetch(segment = repcap.Segment.Default) \n
-		Return spectrum emission single value results for segment <no> in list mode. The values described below are returned by
-		FETCh commands. The first four values (reliability to out-of-tolerance result) are also returned by CALCulate commands.
-		The remaining values returned by CALCulate commands are limit check results, one value for each result listed below. \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:POWer:MAXimum \n
+		Snippet: value: FetchStruct = driver.lteMeas.multiEval.listPy.segment.power.maximum.fetch(segment = repcap.Segment.Default) \n
+		Return total TX power results for segment <no> in list mode. \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:SEMask:SDEViation?', self.__class__.FetchStruct())
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:POWer:MAXimum?', self.__class__.FetchStruct())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
 			- Reliability: int: No parameter help available
 			- Seg_Reliability: int: No parameter help available
 			- Statist_Expired: int: No parameter help available
 			- Out_Of_Tolerance: int: No parameter help available
-			- Obw: float: No parameter help available
-			- Tx_Power: float: No parameter help available"""
+			- Tx_Power_Max: float or bool: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Seg_Reliability'),
 			ArgStruct.scalar_int('Statist_Expired'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
-			ArgStruct.scalar_float('Obw'),
-			ArgStruct.scalar_float('Tx_Power')]
+			ArgStruct.scalar_float_ext('Tx_Power_Max')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Seg_Reliability: int = None
 			self.Statist_Expired: int = None
 			self.Out_Of_Tolerance: int = None
-			self.Obw: float = None
-			self.Tx_Power: float = None
+			self.Tx_Power_Max: float or bool = None
 
 	def calculate(self, segment=repcap.Segment.Default) -> CalculateStruct:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:SEMask:SDEViation \n
-		Snippet: value: CalculateStruct = driver.multiEval.listPy.segment.seMask.standardDev.calculate(segment = repcap.Segment.Default) \n
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:POWer:MAXimum \n
+		Snippet: value: CalculateStruct = driver.lteMeas.multiEval.listPy.segment.power.maximum.calculate(segment = repcap.Segment.Default) \n
 		No command help available \n
 			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		segment_cmd_val = self._base.get_repcap_cmd_value(segment, repcap.Segment)
-		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:SEMask:SDEViation?', self.__class__.CalculateStruct())
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
+		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:POWer:MAXimum?', self.__class__.CalculateStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/ListPy_/Sreliability.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Sreliability.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,26 +1,26 @@
 from typing import List
 
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
-from ....Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ....Internal.Types import DataType
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
+from .....Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .....Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Sreliability:
-	"""Sreliability commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class SreliabilityCls:
+	"""Sreliability commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("sreliability", core, parent)
+		self._cmd_group = CommandsGroup("sreliability", core, parent)
 
 	def fetch(self) -> List[int]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SRELiability \n
-		Snippet: value: List[int] = driver.multiEval.listPy.sreliability.fetch() \n
+		Snippet: value: List[int] = driver.lteMeas.multiEval.listPy.sreliability.fetch() \n
 		Returns the segment reliability for all measured list mode segments. A common reliability indicator of zero indicates
 		that the results in all measured segments are valid. A non-zero value indicates that an error occurred in at least one of
 		the measured segments. If you get a non-zero common reliability indicator, you can use this command to retrieve the
 		individual reliability values of all measured segments for further analysis. \n
 		Suppressed linked return values: reliability \n
 			:return: seg_reliability: Comma-separated list of values, one per measured segment The meaning of the returned values is the same as for the common reliability indicator, see previous parameter."""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Merror.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Perror/__init__.py`

 * *Files 23% similar despite different names*

```diff
@@ -1,43 +1,43 @@
-from ...Internal.Core import Core
-from ...Internal.CommandsGroup import CommandsGroup
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Merror:
-	"""Merror commands group definition. 15 total commands, 3 Sub-groups, 0 group commands"""
+class PerrorCls:
+	"""Perror commands group definition. 15 total commands, 3 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("merror", core, parent)
+		self._cmd_group = CommandsGroup("perror", core, parent)
 
 	@property
 	def current(self):
 		"""current commands group. 1 Sub-classes, 3 commands."""
 		if not hasattr(self, '_current'):
-			from .Merror_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
 	@property
 	def average(self):
 		"""average commands group. 1 Sub-classes, 3 commands."""
 		if not hasattr(self, '_average'):
-			from .Merror_.Average import Average
-			self._average = Average(self._core, self._base)
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
 		return self._average
 
 	@property
 	def maximum(self):
 		"""maximum commands group. 1 Sub-classes, 3 commands."""
 		if not hasattr(self, '_maximum'):
-			from .Merror_.Maximum import Maximum
-			self._maximum = Maximum(self._core, self._base)
+			from .Maximum import MaximumCls
+			self._maximum = MaximumCls(self._core, self._cmd_group)
 		return self._maximum
 
-	def clone(self) -> 'Merror':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'PerrorCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Merror(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = PerrorCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Merror_/Average.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Merror/Average/__init__.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,37 +1,37 @@
 from typing import List
 
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
-from ....Internal.Types import DataType
-from ....Internal.StructBase import StructBase
-from ....Internal.ArgStruct import ArgStruct
-from .... import enums
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal.Types import DataType
+from ......Internal.StructBase import StructBase
+from ......Internal.ArgStruct import ArgStruct
+from ...... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 5 total commands, 1 Sub-groups, 3 group commands"""
+class AverageCls:
+	"""Average commands group definition. 5 total commands, 1 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	@property
 	def nref(self):
 		"""nref commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_nref'):
-			from .Average_.Nref import Nref
-			self._nref = Nref(self._core, self._base)
+			from .Nref import NrefCls
+			self._nref = NrefCls(self._core, self._cmd_group)
 		return self._nref
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
+			- Reliability: int: 'Reliability indicator'
 			- Low: List[float]: Magnitude error value for low EVM window position
 			- High: List[float]: Magnitude error value for high EVM window position"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct('Low', DataType.FloatList, None, False, True, 1),
 			ArgStruct('High', DataType.FloatList, None, False, True, 1)]
 
@@ -39,27 +39,27 @@
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Low: List[float] = None
 			self.High: List[float] = None
 
 	def read(self) -> ResultData:
 		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:MERRor:AVERage \n
-		Snippet: value: ResultData = driver.multiEval.merror.average.read() \n
-		Returns the values of the magnitude error bar graphs for the SC-FDMA symbols in the measured slot. The results of the
-		current, average and maximum bar graphs can be retrieved. There is one pair of magnitude error values per SC-FDMA symbol,
+		Snippet: value: ResultData = driver.lteMeas.multiEval.merror.average.read() \n
+		Returns the values of the magnitude error diagrams for the SC-FDMA symbols in the measured slot. The results of the
+		current, average and maximum diagrams can be retrieved. There is one pair of magnitude error values per SC-FDMA symbol,
 		returned in the following order: <Reliability>, {<Low>, <High>}symbol 0, {<Low>, <High>}symbol 1, ... See also 'Square
 		Magnitude Error, Phase Error'. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
 		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:MERRor:AVERage?', self.__class__.ResultData())
 
 	def fetch(self) -> ResultData:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:MERRor:AVERage \n
-		Snippet: value: ResultData = driver.multiEval.merror.average.fetch() \n
-		Returns the values of the magnitude error bar graphs for the SC-FDMA symbols in the measured slot. The results of the
-		current, average and maximum bar graphs can be retrieved. There is one pair of magnitude error values per SC-FDMA symbol,
+		Snippet: value: ResultData = driver.lteMeas.multiEval.merror.average.fetch() \n
+		Returns the values of the magnitude error diagrams for the SC-FDMA symbols in the measured slot. The results of the
+		current, average and maximum diagrams can be retrieved. There is one pair of magnitude error values per SC-FDMA symbol,
 		returned in the following order: <Reliability>, {<Low>, <High>}symbol 0, {<Low>, <High>}symbol 1, ... See also 'Square
 		Magnitude Error, Phase Error'. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
 		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:MERRor:AVERage?', self.__class__.ResultData())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
@@ -76,19 +76,19 @@
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Low: List[enums.ResultStatus2] = None
 			self.High: List[enums.ResultStatus2] = None
 
 	def calculate(self) -> CalculateStruct:
 		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:MERRor:AVERage \n
-		Snippet: value: CalculateStruct = driver.multiEval.merror.average.calculate() \n
+		Snippet: value: CalculateStruct = driver.lteMeas.multiEval.merror.average.calculate() \n
 		No command help available \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
 		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:MERRor:AVERage?', self.__class__.CalculateStruct())
 
-	def clone(self) -> 'Average':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'AverageCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Average(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = AverageCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Merror_/Average_/Nref.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Perror/Average/Nref.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,20 +1,20 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
-from .....Internal.StructBase import StructBase
-from .....Internal.ArgStruct import ArgStruct
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal.StructBase import StructBase
+from ......Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Nref:
-	"""Nref commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class NrefCls:
+	"""Nref commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("nref", core, parent)
+		self._cmd_group = CommandsGroup("nref", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
 			- Reliability: int: No parameter help available
 			- Sym_1_L: float: No parameter help available
 			- Sym_1_H: float: No parameter help available
@@ -56,19 +56,19 @@
 			self.Sym_5_H: float = None
 			self.Sym_6_L: float = None
 			self.Sym_6_H: float = None
 			self.Sym_7_L: float = None
 			self.Sym_7_H: float = None
 
 	def read(self) -> ResultData:
-		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:MERRor:AVERage:NREF \n
-		Snippet: value: ResultData = driver.multiEval.merror.average.nref.read() \n
+		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:PERRor:AVERage:NREF \n
+		Snippet: value: ResultData = driver.lteMeas.multiEval.perror.average.nref.read() \n
 		No command help available \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:MERRor:AVERage:NREF?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:PERRor:AVERage:NREF?', self.__class__.ResultData())
 
 	def fetch(self) -> ResultData:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:MERRor:AVERage:NREF \n
-		Snippet: value: ResultData = driver.multiEval.merror.average.nref.fetch() \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:PERRor:AVERage:NREF \n
+		Snippet: value: ResultData = driver.lteMeas.multiEval.perror.average.nref.fetch() \n
 		No command help available \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:MERRor:AVERage:NREF?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:PERRor:AVERage:NREF?', self.__class__.ResultData())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Merror_/Current.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Merror/Current/__init__.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,37 +1,37 @@
 from typing import List
 
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
-from ....Internal.Types import DataType
-from ....Internal.StructBase import StructBase
-from ....Internal.ArgStruct import ArgStruct
-from .... import enums
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal.Types import DataType
+from ......Internal.StructBase import StructBase
+from ......Internal.ArgStruct import ArgStruct
+from ...... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 5 total commands, 1 Sub-groups, 3 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 5 total commands, 1 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	@property
 	def nref(self):
 		"""nref commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_nref'):
-			from .Current_.Nref import Nref
-			self._nref = Nref(self._core, self._base)
+			from .Nref import NrefCls
+			self._nref = NrefCls(self._core, self._cmd_group)
 		return self._nref
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
+			- Reliability: int: 'Reliability indicator'
 			- Low: List[float]: Magnitude error value for low EVM window position
 			- High: List[float]: Magnitude error value for high EVM window position"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct('Low', DataType.FloatList, None, False, True, 1),
 			ArgStruct('High', DataType.FloatList, None, False, True, 1)]
 
@@ -39,27 +39,27 @@
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Low: List[float] = None
 			self.High: List[float] = None
 
 	def read(self) -> ResultData:
 		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:MERRor:CURRent \n
-		Snippet: value: ResultData = driver.multiEval.merror.current.read() \n
-		Returns the values of the magnitude error bar graphs for the SC-FDMA symbols in the measured slot. The results of the
-		current, average and maximum bar graphs can be retrieved. There is one pair of magnitude error values per SC-FDMA symbol,
+		Snippet: value: ResultData = driver.lteMeas.multiEval.merror.current.read() \n
+		Returns the values of the magnitude error diagrams for the SC-FDMA symbols in the measured slot. The results of the
+		current, average and maximum diagrams can be retrieved. There is one pair of magnitude error values per SC-FDMA symbol,
 		returned in the following order: <Reliability>, {<Low>, <High>}symbol 0, {<Low>, <High>}symbol 1, ... See also 'Square
 		Magnitude Error, Phase Error'. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
 		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:MERRor:CURRent?', self.__class__.ResultData())
 
 	def fetch(self) -> ResultData:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:MERRor:CURRent \n
-		Snippet: value: ResultData = driver.multiEval.merror.current.fetch() \n
-		Returns the values of the magnitude error bar graphs for the SC-FDMA symbols in the measured slot. The results of the
-		current, average and maximum bar graphs can be retrieved. There is one pair of magnitude error values per SC-FDMA symbol,
+		Snippet: value: ResultData = driver.lteMeas.multiEval.merror.current.fetch() \n
+		Returns the values of the magnitude error diagrams for the SC-FDMA symbols in the measured slot. The results of the
+		current, average and maximum diagrams can be retrieved. There is one pair of magnitude error values per SC-FDMA symbol,
 		returned in the following order: <Reliability>, {<Low>, <High>}symbol 0, {<Low>, <High>}symbol 1, ... See also 'Square
 		Magnitude Error, Phase Error'. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
 		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:MERRor:CURRent?', self.__class__.ResultData())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
@@ -76,19 +76,19 @@
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Low: List[enums.ResultStatus2] = None
 			self.High: List[enums.ResultStatus2] = None
 
 	def calculate(self) -> CalculateStruct:
 		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:MERRor:CURRent \n
-		Snippet: value: CalculateStruct = driver.multiEval.merror.current.calculate() \n
+		Snippet: value: CalculateStruct = driver.lteMeas.multiEval.merror.current.calculate() \n
 		No command help available \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
 		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:MERRor:CURRent?', self.__class__.CalculateStruct())
 
-	def clone(self) -> 'Current':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'CurrentCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Current(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = CurrentCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Merror_/Current_/Nref.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Perror/Current/Nref.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,20 +1,20 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
-from .....Internal.StructBase import StructBase
-from .....Internal.ArgStruct import ArgStruct
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal.StructBase import StructBase
+from ......Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Nref:
-	"""Nref commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class NrefCls:
+	"""Nref commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("nref", core, parent)
+		self._cmd_group = CommandsGroup("nref", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
 			- Reliability: int: No parameter help available
 			- Sym_1_L: float: No parameter help available
 			- Sym_1_H: float: No parameter help available
@@ -56,19 +56,19 @@
 			self.Sym_5_H: float = None
 			self.Sym_6_L: float = None
 			self.Sym_6_H: float = None
 			self.Sym_7_L: float = None
 			self.Sym_7_H: float = None
 
 	def read(self) -> ResultData:
-		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:MERRor:CURRent:NREF \n
-		Snippet: value: ResultData = driver.multiEval.merror.current.nref.read() \n
+		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:PERRor:CURRent:NREF \n
+		Snippet: value: ResultData = driver.lteMeas.multiEval.perror.current.nref.read() \n
 		No command help available \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:MERRor:CURRent:NREF?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:PERRor:CURRent:NREF?', self.__class__.ResultData())
 
 	def fetch(self) -> ResultData:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:MERRor:CURRent:NREF \n
-		Snippet: value: ResultData = driver.multiEval.merror.current.nref.fetch() \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:PERRor:CURRent:NREF \n
+		Snippet: value: ResultData = driver.lteMeas.multiEval.perror.current.nref.fetch() \n
 		No command help available \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:MERRor:CURRent:NREF?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:PERRor:CURRent:NREF?', self.__class__.ResultData())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Merror_/Maximum.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/EvMagnitude/Average/__init__.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,69 +1,67 @@
 from typing import List
 
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
-from ....Internal.Types import DataType
-from ....Internal.StructBase import StructBase
-from ....Internal.ArgStruct import ArgStruct
-from .... import enums
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal.Types import DataType
+from ......Internal.StructBase import StructBase
+from ......Internal.ArgStruct import ArgStruct
+from ...... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Maximum:
-	"""Maximum commands group definition. 5 total commands, 1 Sub-groups, 3 group commands"""
+class AverageCls:
+	"""Average commands group definition. 5 total commands, 1 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("maximum", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	@property
 	def nref(self):
 		"""nref commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_nref'):
-			from .Maximum_.Nref import Nref
-			self._nref = Nref(self._core, self._base)
+			from .Nref import NrefCls
+			self._nref = NrefCls(self._core, self._cmd_group)
 		return self._nref
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Low: List[float]: Magnitude error value for low EVM window position
-			- High: List[float]: Magnitude error value for high EVM window position"""
+			- Reliability: int: 'Reliability indicator'
+			- Low: List[float]: EVM value for low EVM window position
+			- High: List[float]: EVM value for high EVM window position"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct('Low', DataType.FloatList, None, False, True, 1),
 			ArgStruct('High', DataType.FloatList, None, False, True, 1)]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Low: List[float] = None
 			self.High: List[float] = None
 
 	def read(self) -> ResultData:
-		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:MERRor:MAXimum \n
-		Snippet: value: ResultData = driver.multiEval.merror.maximum.read() \n
-		Returns the values of the magnitude error bar graphs for the SC-FDMA symbols in the measured slot. The results of the
-		current, average and maximum bar graphs can be retrieved. There is one pair of magnitude error values per SC-FDMA symbol,
-		returned in the following order: <Reliability>, {<Low>, <High>}symbol 0, {<Low>, <High>}symbol 1, ... See also 'Square
-		Magnitude Error, Phase Error'. \n
+		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:EVMagnitude:AVERage \n
+		Snippet: value: ResultData = driver.lteMeas.multiEval.evMagnitude.average.read() \n
+		Returns the values of the EVM RMS diagrams for the SC-FDMA symbols in the measured slot. The results of the current,
+		average and maximum diagrams can be retrieved. There is one pair of EVM values per SC-FDMA symbol, returned in the
+		following order: <Reliability>, {<Low>, <High>}symbol 0, {<Low>, <High>}symbol 1, ... See also 'Square EVM'. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:MERRor:MAXimum?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:EVMagnitude:AVERage?', self.__class__.ResultData())
 
 	def fetch(self) -> ResultData:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:MERRor:MAXimum \n
-		Snippet: value: ResultData = driver.multiEval.merror.maximum.fetch() \n
-		Returns the values of the magnitude error bar graphs for the SC-FDMA symbols in the measured slot. The results of the
-		current, average and maximum bar graphs can be retrieved. There is one pair of magnitude error values per SC-FDMA symbol,
-		returned in the following order: <Reliability>, {<Low>, <High>}symbol 0, {<Low>, <High>}symbol 1, ... See also 'Square
-		Magnitude Error, Phase Error'. \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:EVMagnitude:AVERage \n
+		Snippet: value: ResultData = driver.lteMeas.multiEval.evMagnitude.average.fetch() \n
+		Returns the values of the EVM RMS diagrams for the SC-FDMA symbols in the measured slot. The results of the current,
+		average and maximum diagrams can be retrieved. There is one pair of EVM values per SC-FDMA symbol, returned in the
+		following order: <Reliability>, {<Low>, <High>}symbol 0, {<Low>, <High>}symbol 1, ... See also 'Square EVM'. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:MERRor:MAXimum?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:EVMagnitude:AVERage?', self.__class__.ResultData())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
 			- Reliability: int: No parameter help available
 			- Low: List[enums.ResultStatus2]: No parameter help available
 			- High: List[enums.ResultStatus2]: No parameter help available"""
@@ -75,20 +73,20 @@
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Low: List[enums.ResultStatus2] = None
 			self.High: List[enums.ResultStatus2] = None
 
 	def calculate(self) -> CalculateStruct:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:MERRor:MAXimum \n
-		Snippet: value: CalculateStruct = driver.multiEval.merror.maximum.calculate() \n
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:EVMagnitude:AVERage \n
+		Snippet: value: CalculateStruct = driver.lteMeas.multiEval.evMagnitude.average.calculate() \n
 		No command help available \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:MERRor:MAXimum?', self.__class__.CalculateStruct())
+		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:EVMagnitude:AVERage?', self.__class__.CalculateStruct())
 
-	def clone(self) -> 'Maximum':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'AverageCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Maximum(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = AverageCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Merror_/Maximum_/Nref.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Merror/Maximum/Nref.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,20 +1,20 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
-from .....Internal.StructBase import StructBase
-from .....Internal.ArgStruct import ArgStruct
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal.StructBase import StructBase
+from ......Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Nref:
-	"""Nref commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class NrefCls:
+	"""Nref commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("nref", core, parent)
+		self._cmd_group = CommandsGroup("nref", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
 			- Reliability: int: No parameter help available
 			- Sym_1_L: float: No parameter help available
 			- Sym_1_H: float: No parameter help available
@@ -57,18 +57,18 @@
 			self.Sym_6_L: float = None
 			self.Sym_6_H: float = None
 			self.Sym_7_L: float = None
 			self.Sym_7_H: float = None
 
 	def read(self) -> ResultData:
 		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:MERRor:MAXimum:NREF \n
-		Snippet: value: ResultData = driver.multiEval.merror.maximum.nref.read() \n
+		Snippet: value: ResultData = driver.lteMeas.multiEval.merror.maximum.nref.read() \n
 		No command help available \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
 		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:MERRor:MAXimum:NREF?', self.__class__.ResultData())
 
 	def fetch(self) -> ResultData:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:MERRor:MAXimum:NREF \n
-		Snippet: value: ResultData = driver.multiEval.merror.maximum.nref.fetch() \n
+		Snippet: value: ResultData = driver.lteMeas.multiEval.merror.maximum.nref.fetch() \n
 		No command help available \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
 		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:MERRor:MAXimum:NREF?', self.__class__.ResultData())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Modulation.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Modulation/__init__.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,83 +1,83 @@
-from ...Internal.Core import Core
-from ...Internal.CommandsGroup import CommandsGroup
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Modulation:
-	"""Modulation commands group definition. 16 total commands, 8 Sub-groups, 0 group commands"""
+class ModulationCls:
+	"""Modulation commands group definition. 16 total commands, 8 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("modulation", core, parent)
+		self._cmd_group = CommandsGroup("modulation", core, parent)
 
 	@property
 	def current(self):
 		"""current commands group. 0 Sub-classes, 3 commands."""
 		if not hasattr(self, '_current'):
-			from .Modulation_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
 	@property
 	def average(self):
 		"""average commands group. 0 Sub-classes, 3 commands."""
 		if not hasattr(self, '_average'):
-			from .Modulation_.Average import Average
-			self._average = Average(self._core, self._base)
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
 		return self._average
 
 	@property
 	def extreme(self):
 		"""extreme commands group. 0 Sub-classes, 3 commands."""
 		if not hasattr(self, '_extreme'):
-			from .Modulation_.Extreme import Extreme
-			self._extreme = Extreme(self._core, self._base)
+			from .Extreme import ExtremeCls
+			self._extreme = ExtremeCls(self._core, self._cmd_group)
 		return self._extreme
 
 	@property
 	def standardDev(self):
 		"""standardDev commands group. 0 Sub-classes, 3 commands."""
 		if not hasattr(self, '_standardDev'):
-			from .Modulation_.StandardDev import StandardDev
-			self._standardDev = StandardDev(self._core, self._base)
+			from .StandardDev import StandardDevCls
+			self._standardDev = StandardDevCls(self._core, self._cmd_group)
 		return self._standardDev
 
 	@property
 	def dmodulation(self):
 		"""dmodulation commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_dmodulation'):
-			from .Modulation_.Dmodulation import Dmodulation
-			self._dmodulation = Dmodulation(self._core, self._base)
+			from .Dmodulation import DmodulationCls
+			self._dmodulation = DmodulationCls(self._core, self._cmd_group)
 		return self._dmodulation
 
 	@property
 	def dchType(self):
 		"""dchType commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_dchType'):
-			from .Modulation_.DchType import DchType
-			self._dchType = DchType(self._core, self._base)
+			from .DchType import DchTypeCls
+			self._dchType = DchTypeCls(self._core, self._cmd_group)
 		return self._dchType
 
 	@property
 	def schType(self):
 		"""schType commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_schType'):
-			from .Modulation_.SchType import SchType
-			self._schType = SchType(self._core, self._base)
+			from .SchType import SchTypeCls
+			self._schType = SchTypeCls(self._core, self._cmd_group)
 		return self._schType
 
 	@property
 	def dallocation(self):
 		"""dallocation commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_dallocation'):
-			from .Modulation_.Dallocation import Dallocation
-			self._dallocation = Dallocation(self._core, self._base)
+			from .Dallocation import DallocationCls
+			self._dallocation = DallocationCls(self._core, self._cmd_group)
 		return self._dallocation
 
-	def clone(self) -> 'Modulation':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'ModulationCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Modulation(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = ModulationCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Modulation_/Average.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Modulation/StandardDev.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,53 +1,53 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
-from ....Internal.StructBase import StructBase
-from ....Internal.ArgStruct import ArgStruct
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
+from .....Internal.StructBase import StructBase
+from .....Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class StandardDevCls:
+	"""StandardDev commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("standardDev", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Out_Of_Tolerance: int: Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for modulation measurements exceeding the specified modulation limits.
+			- Reliability: int: 'Reliability indicator'
+			- Out_Of_Tolerance: int: Out of tolerance result, i.e. the percentage of measurement intervals of the statistic count for modulation measurements exceeding the specified modulation limits.
 			- Evm_Rms_Low: float: EVM RMS value, low EVM window position
 			- Evm_Rms_High: float: EVM RMS value, high EVM window position
 			- Evm_Peak_Low: float: EVM peak value, low EVM window position
 			- Evm_Peak_High: float: EVM peak value, high EVM window position
 			- Mag_Error_Rms_Low: float: Magnitude error RMS value, low EVM window position
 			- Mag_Error_Rms_High: float: Magnitude error RMS value, low EVM window position
 			- Mag_Error_Peak_Low: float: Magnitude error peak value, low EVM window position
 			- Mag_Err_Peak_High: float: Magnitude error peak value, high EVM window position
 			- Ph_Error_Rms_Low: float: Phase error RMS value, low EVM window position
 			- Ph_Error_Rms_High: float: Phase error RMS value, high EVM window position
 			- Ph_Error_Peak_Low: float: Phase error peak value, low EVM window position
 			- Ph_Error_Peak_High: float: Phase error peak value, high EVM window position
 			- Iq_Offset: float: I/Q origin offset
 			- Frequency_Error: float: Carrier frequency error
-			- Timing_Error: float: Transmit time error
+			- Timing_Error: float: Time error
 			- Tx_Power: float: User equipment power
 			- Peak_Power: float: User equipment peak power
 			- Psd: float: No parameter help available
 			- Evm_Dmrs_Low: float: EVM DMRS value, low EVM window position
 			- Evm_Dmrs_High: float: EVM DMRS value, high EVM window position
 			- Mag_Err_Dmrs_Low: float: Magnitude error DMRS value, low EVM window position
 			- Mag_Err_Dmrs_High: float: Magnitude error DMRS value, high EVM window position
 			- Ph_Error_Dmrs_Low: float: Phase error DMRS value, low EVM window position
 			- Ph_Error_Dmrs_High: float: Phase error DMRS value, high EVM window position
 			- Iq_Gain_Imbalance: float: Gain imbalance
 			- Iq_Quadrature_Err: float: Quadrature error
-			- Evm_Srs: float: Error vector magnitude result for SRS signals"""
+			- Evm_Srs: float: Error vector magnitude for SRS signals"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
 			ArgStruct.scalar_float('Evm_Rms_Low'),
 			ArgStruct.scalar_float('Evm_Rms_High'),
 			ArgStruct.scalar_float('Evm_Peak_Low'),
 			ArgStruct.scalar_float('Evm_Peak_High'),
@@ -104,124 +104,122 @@
 			self.Ph_Error_Dmrs_Low: float = None
 			self.Ph_Error_Dmrs_High: float = None
 			self.Iq_Gain_Imbalance: float = None
 			self.Iq_Quadrature_Err: float = None
 			self.Evm_Srs: float = None
 
 	def read(self) -> ResultData:
-		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:MODulation:AVERage \n
-		Snippet: value: ResultData = driver.multiEval.modulation.average.read() \n
-		Return the current, average and standard deviation single value results. The values described below are returned by FETCh
+		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:MODulation:SDEViation \n
+		Snippet: value: ResultData = driver.lteMeas.multiEval.modulation.standardDev.read() \n
+		Return the current, average and standard deviation single-value results. The values described below are returned by FETCh
 		and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:MODulation:AVERage?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:MODulation:SDEViation?', self.__class__.ResultData())
 
 	def fetch(self) -> ResultData:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:MODulation:AVERage \n
-		Snippet: value: ResultData = driver.multiEval.modulation.average.fetch() \n
-		Return the current, average and standard deviation single value results. The values described below are returned by FETCh
-		and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:MODulation:SDEViation \n
+		Snippet: value: ResultData = driver.lteMeas.multiEval.modulation.standardDev.fetch() \n
+		No command help available \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:MODulation:AVERage?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:MODulation:SDEViation?', self.__class__.ResultData())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Out_Of_Tolerance: int: Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for modulation measurements exceeding the specified modulation limits.
-			- Evm_Rms_Low: float: EVM RMS value, low EVM window position
-			- Evm_Rms_High: float: EVM RMS value, high EVM window position
-			- Evm_Peak_Low: float: EVM peak value, low EVM window position
-			- Evm_Peak_High: float: EVM peak value, high EVM window position
-			- Mag_Error_Rms_Low: float: Magnitude error RMS value, low EVM window position
-			- Mag_Error_Rms_High: float: Magnitude error RMS value, low EVM window position
-			- Mag_Error_Peak_Low: float: Magnitude error peak value, low EVM window position
-			- Mag_Err_Peak_High: float: Magnitude error peak value, high EVM window position
-			- Ph_Error_Rms_Low: float: Phase error RMS value, low EVM window position
-			- Ph_Error_Rms_High: float: Phase error RMS value, high EVM window position
-			- Ph_Error_Peak_Low: float: Phase error peak value, low EVM window position
-			- Ph_Error_Peak_High: float: Phase error peak value, high EVM window position
-			- Iq_Offset: float: I/Q origin offset
-			- Frequency_Error: float: Carrier frequency error
-			- Timing_Error: float: Transmit time error
-			- Tx_Power: float: User equipment power
-			- Peak_Power: float: User equipment peak power
-			- Psd: float: No parameter help available
-			- Evm_Dmrs_Low: float: EVM DMRS value, low EVM window position
-			- Evm_Dmrs_High: float: EVM DMRS value, high EVM window position
-			- Mag_Err_Dmrs_Low: float: Magnitude error DMRS value, low EVM window position
-			- Mag_Err_Dmrs_High: float: Magnitude error DMRS value, high EVM window position
-			- Ph_Error_Dmrs_Low: float: Phase error DMRS value, low EVM window position
-			- Ph_Error_Dmrs_High: float: Phase error DMRS value, high EVM window position
-			- Iq_Gain_Imbalance: float: Gain imbalance
-			- Iq_Quadrature_Err: float: Quadrature error
-			- Evm_Srs: float: Error vector magnitude result for SRS signals"""
+			- Reliability: int: No parameter help available
+			- Out_Of_Tolerance: int: No parameter help available
+			- Evm_Rms_Low: float or bool: No parameter help available
+			- Evm_Rms_High: float or bool: No parameter help available
+			- Evm_Peak_Low: float or bool: No parameter help available
+			- Evm_Peak_High: float or bool: No parameter help available
+			- Mag_Error_Rms_Low: float or bool: No parameter help available
+			- Mag_Error_Rms_High: float or bool: No parameter help available
+			- Mag_Error_Peak_Low: float or bool: No parameter help available
+			- Mag_Err_Peak_High: float or bool: No parameter help available
+			- Ph_Error_Rms_Low: float or bool: No parameter help available
+			- Ph_Error_Rms_High: float or bool: No parameter help available
+			- Ph_Error_Peak_Low: float or bool: No parameter help available
+			- Ph_Error_Peak_High: float or bool: No parameter help available
+			- Iq_Offset: float or bool: No parameter help available
+			- Frequency_Error: float or bool: No parameter help available
+			- Timing_Error: float or bool: No parameter help available
+			- Tx_Power: float or bool: No parameter help available
+			- Peak_Power: float or bool: No parameter help available
+			- Psd: float or bool: No parameter help available
+			- Evm_Dmrs_Low: float or bool: No parameter help available
+			- Evm_Dmrs_High: float or bool: No parameter help available
+			- Mag_Err_Dmrs_Low: float or bool: No parameter help available
+			- Mag_Err_Dmrs_High: float or bool: No parameter help available
+			- Ph_Error_Dmrs_Low: float or bool: No parameter help available
+			- Ph_Error_Dmrs_High: float or bool: No parameter help available
+			- Iq_Gain_Imbalance: float or bool: No parameter help available
+			- Iq_Quadrature_Err: float or bool: No parameter help available
+			- Evm_Srs: float: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
-			ArgStruct.scalar_float('Evm_Rms_Low'),
-			ArgStruct.scalar_float('Evm_Rms_High'),
-			ArgStruct.scalar_float('Evm_Peak_Low'),
-			ArgStruct.scalar_float('Evm_Peak_High'),
-			ArgStruct.scalar_float('Mag_Error_Rms_Low'),
-			ArgStruct.scalar_float('Mag_Error_Rms_High'),
-			ArgStruct.scalar_float('Mag_Error_Peak_Low'),
-			ArgStruct.scalar_float('Mag_Err_Peak_High'),
-			ArgStruct.scalar_float('Ph_Error_Rms_Low'),
-			ArgStruct.scalar_float('Ph_Error_Rms_High'),
-			ArgStruct.scalar_float('Ph_Error_Peak_Low'),
-			ArgStruct.scalar_float('Ph_Error_Peak_High'),
-			ArgStruct.scalar_float('Iq_Offset'),
-			ArgStruct.scalar_float('Frequency_Error'),
-			ArgStruct.scalar_float('Timing_Error'),
-			ArgStruct.scalar_float('Tx_Power'),
-			ArgStruct.scalar_float('Peak_Power'),
-			ArgStruct.scalar_float('Psd'),
-			ArgStruct.scalar_float('Evm_Dmrs_Low'),
-			ArgStruct.scalar_float('Evm_Dmrs_High'),
-			ArgStruct.scalar_float('Mag_Err_Dmrs_Low'),
-			ArgStruct.scalar_float('Mag_Err_Dmrs_High'),
-			ArgStruct.scalar_float('Ph_Error_Dmrs_Low'),
-			ArgStruct.scalar_float('Ph_Error_Dmrs_High'),
-			ArgStruct.scalar_float('Iq_Gain_Imbalance'),
-			ArgStruct.scalar_float('Iq_Quadrature_Err'),
+			ArgStruct.scalar_float_ext('Evm_Rms_Low'),
+			ArgStruct.scalar_float_ext('Evm_Rms_High'),
+			ArgStruct.scalar_float_ext('Evm_Peak_Low'),
+			ArgStruct.scalar_float_ext('Evm_Peak_High'),
+			ArgStruct.scalar_float_ext('Mag_Error_Rms_Low'),
+			ArgStruct.scalar_float_ext('Mag_Error_Rms_High'),
+			ArgStruct.scalar_float_ext('Mag_Error_Peak_Low'),
+			ArgStruct.scalar_float_ext('Mag_Err_Peak_High'),
+			ArgStruct.scalar_float_ext('Ph_Error_Rms_Low'),
+			ArgStruct.scalar_float_ext('Ph_Error_Rms_High'),
+			ArgStruct.scalar_float_ext('Ph_Error_Peak_Low'),
+			ArgStruct.scalar_float_ext('Ph_Error_Peak_High'),
+			ArgStruct.scalar_float_ext('Iq_Offset'),
+			ArgStruct.scalar_float_ext('Frequency_Error'),
+			ArgStruct.scalar_float_ext('Timing_Error'),
+			ArgStruct.scalar_float_ext('Tx_Power'),
+			ArgStruct.scalar_float_ext('Peak_Power'),
+			ArgStruct.scalar_float_ext('Psd'),
+			ArgStruct.scalar_float_ext('Evm_Dmrs_Low'),
+			ArgStruct.scalar_float_ext('Evm_Dmrs_High'),
+			ArgStruct.scalar_float_ext('Mag_Err_Dmrs_Low'),
+			ArgStruct.scalar_float_ext('Mag_Err_Dmrs_High'),
+			ArgStruct.scalar_float_ext('Ph_Error_Dmrs_Low'),
+			ArgStruct.scalar_float_ext('Ph_Error_Dmrs_High'),
+			ArgStruct.scalar_float_ext('Iq_Gain_Imbalance'),
+			ArgStruct.scalar_float_ext('Iq_Quadrature_Err'),
 			ArgStruct.scalar_float('Evm_Srs')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tolerance: int = None
-			self.Evm_Rms_Low: float = None
-			self.Evm_Rms_High: float = None
-			self.Evm_Peak_Low: float = None
-			self.Evm_Peak_High: float = None
-			self.Mag_Error_Rms_Low: float = None
-			self.Mag_Error_Rms_High: float = None
-			self.Mag_Error_Peak_Low: float = None
-			self.Mag_Err_Peak_High: float = None
-			self.Ph_Error_Rms_Low: float = None
-			self.Ph_Error_Rms_High: float = None
-			self.Ph_Error_Peak_Low: float = None
-			self.Ph_Error_Peak_High: float = None
-			self.Iq_Offset: float = None
-			self.Frequency_Error: float = None
-			self.Timing_Error: float = None
-			self.Tx_Power: float = None
-			self.Peak_Power: float = None
-			self.Psd: float = None
-			self.Evm_Dmrs_Low: float = None
-			self.Evm_Dmrs_High: float = None
-			self.Mag_Err_Dmrs_Low: float = None
-			self.Mag_Err_Dmrs_High: float = None
-			self.Ph_Error_Dmrs_Low: float = None
-			self.Ph_Error_Dmrs_High: float = None
-			self.Iq_Gain_Imbalance: float = None
-			self.Iq_Quadrature_Err: float = None
+			self.Evm_Rms_Low: float or bool = None
+			self.Evm_Rms_High: float or bool = None
+			self.Evm_Peak_Low: float or bool = None
+			self.Evm_Peak_High: float or bool = None
+			self.Mag_Error_Rms_Low: float or bool = None
+			self.Mag_Error_Rms_High: float or bool = None
+			self.Mag_Error_Peak_Low: float or bool = None
+			self.Mag_Err_Peak_High: float or bool = None
+			self.Ph_Error_Rms_Low: float or bool = None
+			self.Ph_Error_Rms_High: float or bool = None
+			self.Ph_Error_Peak_Low: float or bool = None
+			self.Ph_Error_Peak_High: float or bool = None
+			self.Iq_Offset: float or bool = None
+			self.Frequency_Error: float or bool = None
+			self.Timing_Error: float or bool = None
+			self.Tx_Power: float or bool = None
+			self.Peak_Power: float or bool = None
+			self.Psd: float or bool = None
+			self.Evm_Dmrs_Low: float or bool = None
+			self.Evm_Dmrs_High: float or bool = None
+			self.Mag_Err_Dmrs_Low: float or bool = None
+			self.Mag_Err_Dmrs_High: float or bool = None
+			self.Ph_Error_Dmrs_Low: float or bool = None
+			self.Ph_Error_Dmrs_High: float or bool = None
+			self.Iq_Gain_Imbalance: float or bool = None
+			self.Iq_Quadrature_Err: float or bool = None
 			self.Evm_Srs: float = None
 
 	def calculate(self) -> CalculateStruct:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:MODulation:AVERage \n
-		Snippet: value: CalculateStruct = driver.multiEval.modulation.average.calculate() \n
-		Return the current, average and standard deviation single value results. The values described below are returned by FETCh
-		and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:MODulation:SDEViation \n
+		Snippet: value: CalculateStruct = driver.lteMeas.multiEval.modulation.standardDev.calculate() \n
+		No command help available \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:MODulation:AVERage?', self.__class__.CalculateStruct())
+		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:MODulation:SDEViation?', self.__class__.CalculateStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Modulation_/Current.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Modulation/Current.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,53 +1,53 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
-from ....Internal.StructBase import StructBase
-from ....Internal.ArgStruct import ArgStruct
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
+from .....Internal.StructBase import StructBase
+from .....Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Out_Of_Tolerance: int: Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for modulation measurements exceeding the specified modulation limits.
+			- Reliability: int: 'Reliability indicator'
+			- Out_Of_Tolerance: int: Out of tolerance result, i.e. the percentage of measurement intervals of the statistic count for modulation measurements exceeding the specified modulation limits.
 			- Evm_Rms_Low: float: EVM RMS value, low EVM window position
 			- Evm_Rms_High: float: EVM RMS value, high EVM window position
 			- Evm_Peak_Low: float: EVM peak value, low EVM window position
 			- Evm_Peak_High: float: EVM peak value, high EVM window position
 			- Mag_Error_Rms_Low: float: Magnitude error RMS value, low EVM window position
 			- Mag_Error_Rms_High: float: Magnitude error RMS value, low EVM window position
 			- Mag_Error_Peak_Low: float: Magnitude error peak value, low EVM window position
 			- Mag_Err_Peak_High: float: Magnitude error peak value, high EVM window position
 			- Ph_Error_Rms_Low: float: Phase error RMS value, low EVM window position
 			- Ph_Error_Rms_High: float: Phase error RMS value, high EVM window position
 			- Ph_Error_Peak_Low: float: Phase error peak value, low EVM window position
 			- Ph_Error_Peak_High: float: Phase error peak value, high EVM window position
 			- Iq_Offset: float: I/Q origin offset
 			- Frequency_Error: float: Carrier frequency error
-			- Timing_Error: float: Transmit time error
+			- Timing_Error: float: Time error
 			- Tx_Power: float: User equipment power
 			- Peak_Power: float: User equipment peak power
 			- Psd: float: No parameter help available
 			- Evm_Dmrs_Low: float: EVM DMRS value, low EVM window position
 			- Evm_Dmrs_High: float: EVM DMRS value, high EVM window position
 			- Mag_Err_Dmrs_Low: float: Magnitude error DMRS value, low EVM window position
 			- Mag_Err_Dmrs_High: float: Magnitude error DMRS value, high EVM window position
 			- Ph_Error_Dmrs_Low: float: Phase error DMRS value, low EVM window position
 			- Ph_Error_Dmrs_High: float: Phase error DMRS value, high EVM window position
 			- Iq_Gain_Imbalance: float: Gain imbalance
 			- Iq_Quadrature_Err: float: Quadrature error
-			- Evm_Srs: float: Error vector magnitude result for SRS signals"""
+			- Evm_Srs: float: Error vector magnitude for SRS signals"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
 			ArgStruct.scalar_float('Evm_Rms_Low'),
 			ArgStruct.scalar_float('Evm_Rms_High'),
 			ArgStruct.scalar_float('Evm_Peak_Low'),
 			ArgStruct.scalar_float('Evm_Peak_High'),
@@ -105,123 +105,123 @@
 			self.Ph_Error_Dmrs_High: float = None
 			self.Iq_Gain_Imbalance: float = None
 			self.Iq_Quadrature_Err: float = None
 			self.Evm_Srs: float = None
 
 	def read(self) -> ResultData:
 		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:MODulation:CURRent \n
-		Snippet: value: ResultData = driver.multiEval.modulation.current.read() \n
-		Return the current, average and standard deviation single value results. The values described below are returned by FETCh
+		Snippet: value: ResultData = driver.lteMeas.multiEval.modulation.current.read() \n
+		Return the current, average and standard deviation single-value results. The values described below are returned by FETCh
 		and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
 		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:MODulation:CURRent?', self.__class__.ResultData())
 
 	def fetch(self) -> ResultData:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:MODulation:CURRent \n
-		Snippet: value: ResultData = driver.multiEval.modulation.current.fetch() \n
-		Return the current, average and standard deviation single value results. The values described below are returned by FETCh
+		Snippet: value: ResultData = driver.lteMeas.multiEval.modulation.current.fetch() \n
+		Return the current, average and standard deviation single-value results. The values described below are returned by FETCh
 		and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
 		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:MODulation:CURRent?', self.__class__.ResultData())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Out_Of_Tolerance: int: Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for modulation measurements exceeding the specified modulation limits.
-			- Evm_Rms_Low: float: EVM RMS value, low EVM window position
-			- Evm_Rms_High: float: EVM RMS value, high EVM window position
-			- Evm_Peak_Low: float: EVM peak value, low EVM window position
-			- Evm_Peak_High: float: EVM peak value, high EVM window position
-			- Mag_Error_Rms_Low: float: Magnitude error RMS value, low EVM window position
-			- Mag_Error_Rms_High: float: Magnitude error RMS value, low EVM window position
-			- Mag_Error_Peak_Low: float: Magnitude error peak value, low EVM window position
-			- Mag_Err_Peak_High: float: Magnitude error peak value, high EVM window position
-			- Ph_Error_Rms_Low: float: Phase error RMS value, low EVM window position
-			- Ph_Error_Rms_High: float: Phase error RMS value, high EVM window position
-			- Ph_Error_Peak_Low: float: Phase error peak value, low EVM window position
-			- Ph_Error_Peak_High: float: Phase error peak value, high EVM window position
-			- Iq_Offset: float: I/Q origin offset
-			- Frequency_Error: float: Carrier frequency error
-			- Timing_Error: float: Transmit time error
-			- Tx_Power: float: User equipment power
-			- Peak_Power: float: User equipment peak power
-			- Psd: float: No parameter help available
-			- Evm_Dmrs_Low: float: EVM DMRS value, low EVM window position
-			- Evm_Dmrs_High: float: EVM DMRS value, high EVM window position
-			- Mag_Err_Dmrs_Low: float: Magnitude error DMRS value, low EVM window position
-			- Mag_Err_Dmrs_High: float: Magnitude error DMRS value, high EVM window position
-			- Ph_Error_Dmrs_Low: float: Phase error DMRS value, low EVM window position
-			- Ph_Error_Dmrs_High: float: Phase error DMRS value, high EVM window position
-			- Iq_Gain_Imbalance: float: Gain imbalance
-			- Iq_Quadrature_Err: float: Quadrature error
-			- Evm_Srs: float: Error vector magnitude result for SRS signals"""
+			- Reliability: int: 'Reliability indicator'
+			- Out_Of_Tolerance: int: Out of tolerance result, i.e. the percentage of measurement intervals of the statistic count for modulation measurements exceeding the specified modulation limits.
+			- Evm_Rms_Low: float or bool: EVM RMS value, low EVM window position
+			- Evm_Rms_High: float or bool: EVM RMS value, high EVM window position
+			- Evm_Peak_Low: float or bool: EVM peak value, low EVM window position
+			- Evm_Peak_High: float or bool: EVM peak value, high EVM window position
+			- Mag_Error_Rms_Low: float or bool: Magnitude error RMS value, low EVM window position
+			- Mag_Error_Rms_High: float or bool: Magnitude error RMS value, low EVM window position
+			- Mag_Error_Peak_Low: float or bool: Magnitude error peak value, low EVM window position
+			- Mag_Err_Peak_High: float or bool: Magnitude error peak value, high EVM window position
+			- Ph_Error_Rms_Low: float or bool: Phase error RMS value, low EVM window position
+			- Ph_Error_Rms_High: float or bool: Phase error RMS value, high EVM window position
+			- Ph_Error_Peak_Low: float or bool: Phase error peak value, low EVM window position
+			- Ph_Error_Peak_High: float or bool: Phase error peak value, high EVM window position
+			- Iq_Offset: float or bool: I/Q origin offset
+			- Frequency_Error: float or bool: Carrier frequency error
+			- Timing_Error: float or bool: Time error
+			- Tx_Power: float or bool: User equipment power
+			- Peak_Power: float or bool: User equipment peak power
+			- Psd: float or bool: No parameter help available
+			- Evm_Dmrs_Low: float or bool: EVM DMRS value, low EVM window position
+			- Evm_Dmrs_High: float or bool: EVM DMRS value, high EVM window position
+			- Mag_Err_Dmrs_Low: float or bool: Magnitude error DMRS value, low EVM window position
+			- Mag_Err_Dmrs_High: float or bool: Magnitude error DMRS value, high EVM window position
+			- Ph_Error_Dmrs_Low: float or bool: Phase error DMRS value, low EVM window position
+			- Ph_Error_Dmrs_High: float or bool: Phase error DMRS value, high EVM window position
+			- Iq_Gain_Imbalance: float or bool: Gain imbalance
+			- Iq_Quadrature_Err: float or bool: Quadrature error
+			- Evm_Srs: float: Error vector magnitude for SRS signals"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
-			ArgStruct.scalar_float('Evm_Rms_Low'),
-			ArgStruct.scalar_float('Evm_Rms_High'),
-			ArgStruct.scalar_float('Evm_Peak_Low'),
-			ArgStruct.scalar_float('Evm_Peak_High'),
-			ArgStruct.scalar_float('Mag_Error_Rms_Low'),
-			ArgStruct.scalar_float('Mag_Error_Rms_High'),
-			ArgStruct.scalar_float('Mag_Error_Peak_Low'),
-			ArgStruct.scalar_float('Mag_Err_Peak_High'),
-			ArgStruct.scalar_float('Ph_Error_Rms_Low'),
-			ArgStruct.scalar_float('Ph_Error_Rms_High'),
-			ArgStruct.scalar_float('Ph_Error_Peak_Low'),
-			ArgStruct.scalar_float('Ph_Error_Peak_High'),
-			ArgStruct.scalar_float('Iq_Offset'),
-			ArgStruct.scalar_float('Frequency_Error'),
-			ArgStruct.scalar_float('Timing_Error'),
-			ArgStruct.scalar_float('Tx_Power'),
-			ArgStruct.scalar_float('Peak_Power'),
-			ArgStruct.scalar_float('Psd'),
-			ArgStruct.scalar_float('Evm_Dmrs_Low'),
-			ArgStruct.scalar_float('Evm_Dmrs_High'),
-			ArgStruct.scalar_float('Mag_Err_Dmrs_Low'),
-			ArgStruct.scalar_float('Mag_Err_Dmrs_High'),
-			ArgStruct.scalar_float('Ph_Error_Dmrs_Low'),
-			ArgStruct.scalar_float('Ph_Error_Dmrs_High'),
-			ArgStruct.scalar_float('Iq_Gain_Imbalance'),
-			ArgStruct.scalar_float('Iq_Quadrature_Err'),
+			ArgStruct.scalar_float_ext('Evm_Rms_Low'),
+			ArgStruct.scalar_float_ext('Evm_Rms_High'),
+			ArgStruct.scalar_float_ext('Evm_Peak_Low'),
+			ArgStruct.scalar_float_ext('Evm_Peak_High'),
+			ArgStruct.scalar_float_ext('Mag_Error_Rms_Low'),
+			ArgStruct.scalar_float_ext('Mag_Error_Rms_High'),
+			ArgStruct.scalar_float_ext('Mag_Error_Peak_Low'),
+			ArgStruct.scalar_float_ext('Mag_Err_Peak_High'),
+			ArgStruct.scalar_float_ext('Ph_Error_Rms_Low'),
+			ArgStruct.scalar_float_ext('Ph_Error_Rms_High'),
+			ArgStruct.scalar_float_ext('Ph_Error_Peak_Low'),
+			ArgStruct.scalar_float_ext('Ph_Error_Peak_High'),
+			ArgStruct.scalar_float_ext('Iq_Offset'),
+			ArgStruct.scalar_float_ext('Frequency_Error'),
+			ArgStruct.scalar_float_ext('Timing_Error'),
+			ArgStruct.scalar_float_ext('Tx_Power'),
+			ArgStruct.scalar_float_ext('Peak_Power'),
+			ArgStruct.scalar_float_ext('Psd'),
+			ArgStruct.scalar_float_ext('Evm_Dmrs_Low'),
+			ArgStruct.scalar_float_ext('Evm_Dmrs_High'),
+			ArgStruct.scalar_float_ext('Mag_Err_Dmrs_Low'),
+			ArgStruct.scalar_float_ext('Mag_Err_Dmrs_High'),
+			ArgStruct.scalar_float_ext('Ph_Error_Dmrs_Low'),
+			ArgStruct.scalar_float_ext('Ph_Error_Dmrs_High'),
+			ArgStruct.scalar_float_ext('Iq_Gain_Imbalance'),
+			ArgStruct.scalar_float_ext('Iq_Quadrature_Err'),
 			ArgStruct.scalar_float('Evm_Srs')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tolerance: int = None
-			self.Evm_Rms_Low: float = None
-			self.Evm_Rms_High: float = None
-			self.Evm_Peak_Low: float = None
-			self.Evm_Peak_High: float = None
-			self.Mag_Error_Rms_Low: float = None
-			self.Mag_Error_Rms_High: float = None
-			self.Mag_Error_Peak_Low: float = None
-			self.Mag_Err_Peak_High: float = None
-			self.Ph_Error_Rms_Low: float = None
-			self.Ph_Error_Rms_High: float = None
-			self.Ph_Error_Peak_Low: float = None
-			self.Ph_Error_Peak_High: float = None
-			self.Iq_Offset: float = None
-			self.Frequency_Error: float = None
-			self.Timing_Error: float = None
-			self.Tx_Power: float = None
-			self.Peak_Power: float = None
-			self.Psd: float = None
-			self.Evm_Dmrs_Low: float = None
-			self.Evm_Dmrs_High: float = None
-			self.Mag_Err_Dmrs_Low: float = None
-			self.Mag_Err_Dmrs_High: float = None
-			self.Ph_Error_Dmrs_Low: float = None
-			self.Ph_Error_Dmrs_High: float = None
-			self.Iq_Gain_Imbalance: float = None
-			self.Iq_Quadrature_Err: float = None
+			self.Evm_Rms_Low: float or bool = None
+			self.Evm_Rms_High: float or bool = None
+			self.Evm_Peak_Low: float or bool = None
+			self.Evm_Peak_High: float or bool = None
+			self.Mag_Error_Rms_Low: float or bool = None
+			self.Mag_Error_Rms_High: float or bool = None
+			self.Mag_Error_Peak_Low: float or bool = None
+			self.Mag_Err_Peak_High: float or bool = None
+			self.Ph_Error_Rms_Low: float or bool = None
+			self.Ph_Error_Rms_High: float or bool = None
+			self.Ph_Error_Peak_Low: float or bool = None
+			self.Ph_Error_Peak_High: float or bool = None
+			self.Iq_Offset: float or bool = None
+			self.Frequency_Error: float or bool = None
+			self.Timing_Error: float or bool = None
+			self.Tx_Power: float or bool = None
+			self.Peak_Power: float or bool = None
+			self.Psd: float or bool = None
+			self.Evm_Dmrs_Low: float or bool = None
+			self.Evm_Dmrs_High: float or bool = None
+			self.Mag_Err_Dmrs_Low: float or bool = None
+			self.Mag_Err_Dmrs_High: float or bool = None
+			self.Ph_Error_Dmrs_Low: float or bool = None
+			self.Ph_Error_Dmrs_High: float or bool = None
+			self.Iq_Gain_Imbalance: float or bool = None
+			self.Iq_Quadrature_Err: float or bool = None
 			self.Evm_Srs: float = None
 
 	def calculate(self) -> CalculateStruct:
 		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:MODulation:CURRent \n
-		Snippet: value: CalculateStruct = driver.multiEval.modulation.current.calculate() \n
-		Return the current, average and standard deviation single value results. The values described below are returned by FETCh
+		Snippet: value: CalculateStruct = driver.lteMeas.multiEval.modulation.current.calculate() \n
+		Return the current, average and standard deviation single-value results. The values described below are returned by FETCh
 		and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
 		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:MODulation:CURRent?', self.__class__.CalculateStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Modulation_/Dallocation.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Modulation/Dallocation.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,25 +1,25 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
-from ....Internal.StructBase import StructBase
-from ....Internal.ArgStruct import ArgStruct
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
+from .....Internal.StructBase import StructBase
+from .....Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Dallocation:
-	"""Dallocation commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class DallocationCls:
+	"""Dallocation commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("dallocation", core, parent)
+		self._cmd_group = CommandsGroup("dallocation", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
+			- Reliability: int: 'Reliability indicator'
 			- Nr_Res_Blocks: int: Number of allocated resource blocks
 			- Offset_Res_Blocks: int: Offset of the first allocated resource block from the edge of the allocated UL transmission bandwidth"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Nr_Res_Blocks'),
 			ArgStruct.scalar_int('Offset_Res_Blocks')]
 
@@ -27,13 +27,13 @@
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Nr_Res_Blocks: int = None
 			self.Offset_Res_Blocks: int = None
 
 	def fetch(self) -> FetchStruct:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:MODulation:DALLocation \n
-		Snippet: value: FetchStruct = driver.multiEval.modulation.dallocation.fetch() \n
+		Snippet: value: FetchStruct = driver.lteMeas.multiEval.modulation.dallocation.fetch() \n
 		Returns the detected allocation for the measured slot. If the same slot is measured by the individual measurements, all
 		commands yield the same result. If different statistic counts are defined for the modulation, ACLR and spectrum emission
 		mask measurements, different slots can be measured and different results can be returned by the individual commands. \n
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
 		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:MODulation:DALLocation?', self.__class__.FetchStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Modulation_/DchType.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Aclr/DchType.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,28 +1,28 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
-from ....Internal import Conversions
-from ....Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ....Internal.Types import DataType
-from .... import enums
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
+from .....Internal import Conversions
+from .....Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .....Internal.Types import DataType
+from ..... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class DchType:
-	"""DchType commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class DchTypeCls:
+	"""DchType commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("dchType", core, parent)
+		self._cmd_group = CommandsGroup("dchType", core, parent)
 
 	# noinspection PyTypeChecker
 	def fetch(self) -> enums.UplinkChannelType:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:MODulation:DCHType \n
-		Snippet: value: enums.UplinkChannelType = driver.multiEval.modulation.dchType.fetch() \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:ACLR:DCHType \n
+		Snippet: value: enums.UplinkChannelType = driver.lteMeas.multiEval.aclr.dchType.fetch() \n
 		Returns the uplink channel type for the measured slot. If the same slot is measured by the individual measurements, all
 		commands yield the same result. If different statistic counts are defined for the modulation, ACLR and spectrum emission
 		mask measurements, different slots can be measured and different results can be returned by the individual commands. \n
 		Suppressed linked return values: reliability \n
 			:return: channel_type: No help available"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_str_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:MODulation:DCHType?', suppressed)
+		response = self._core.io.query_str_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:ACLR:DCHType?', suppressed)
 		return Conversions.str_to_scalar_enum(response, enums.UplinkChannelType)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Modulation_/Dmodulation.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Modulation/SchType.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,27 +1,26 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
-from ....Internal import Conversions
-from ....Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ....Internal.Types import DataType
-from .... import enums
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
+from .....Internal import Conversions
+from .....Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .....Internal.Types import DataType
+from ..... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Dmodulation:
-	"""Dmodulation commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class SchTypeCls:
+	"""SchType commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("dmodulation", core, parent)
+		self._cmd_group = CommandsGroup("schType", core, parent)
 
 	# noinspection PyTypeChecker
-	def fetch(self) -> enums.Modulation:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:MODulation:DMODulation \n
-		Snippet: value: enums.Modulation = driver.multiEval.modulation.dmodulation.fetch() \n
-		Returns the detected modulation scheme in the measured slot. If channel type PUCCH is detected, QPSK is returned as
-		modulation type because the QPSK limits are applied in that case. \n
+	def fetch(self) -> enums.SidelinkChannelType:
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:MODulation:SCHType \n
+		Snippet: value: enums.SidelinkChannelType = driver.lteMeas.multiEval.modulation.schType.fetch() \n
+		Returns the sidelink channel type evaluated for modulation results. \n
 		Suppressed linked return values: reliability \n
-			:return: modulation: QPSK, 16-QAM, 64-QAM, 256-QAM"""
+			:return: channel_type: No help available"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_str_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:MODulation:DMODulation?', suppressed)
-		return Conversions.str_to_scalar_enum(response, enums.Modulation)
+		response = self._core.io.query_str_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:MODulation:SCHType?', suppressed)
+		return Conversions.str_to_scalar_enum(response, enums.SidelinkChannelType)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Modulation_/Extreme.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/Prach/Modulation/Extreme.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,242 +1,173 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
-from ....Internal.StructBase import StructBase
-from ....Internal.ArgStruct import ArgStruct
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
+from .....Internal.StructBase import StructBase
+from .....Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Extreme:
-	"""Extreme commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class ExtremeCls:
+	"""Extreme commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("extreme", core, parent)
+		self._cmd_group = CommandsGroup("extreme", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Out_Of_Tolerance: int: Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for modulation measurements exceeding the specified modulation limits.
+			- Reliability: int: 'Reliability indicator'
+			- Out_Of_Tolerance: int: Out of tolerance result, i.e. the percentage of measurement intervals of the statistic count for modulation measurements exceeding the specified modulation limits.
 			- Evm_Rms_Low: float: EVM RMS value, low EVM window position
 			- Evm_Rms_High: float: EVM RMS value, high EVM window position
 			- Evm_Peak_Low: float: EVM peak value, low EVM window position
 			- Evm_Peak_High: float: EVM peak value, high EVM window position
 			- Mag_Error_Rms_Low: float: Magnitude error RMS value, low EVM window position
 			- Mag_Error_Rms_High: float: Magnitude error RMS value, low EVM window position
 			- Mag_Error_Peak_Low: float: Magnitude error peak value, low EVM window position
 			- Mag_Err_Peak_High: float: Magnitude error peak value, high EVM window position
 			- Ph_Error_Rms_Low: float: Phase error RMS value, low EVM window position
 			- Ph_Error_Rms_High: float: Phase error RMS value, high EVM window position
 			- Ph_Error_Peak_Low: float: Phase error peak value, low EVM window position
 			- Ph_Error_Peak_High: float: Phase error peak value, high EVM window position
-			- Iq_Offset: float: I/Q origin offset
 			- Frequency_Error: float: Carrier frequency error
-			- Timing_Error: float: Transmit time error
-			- Tx_Power_Minimum: float: Minimum user equipment power
-			- Tx_Power_Maximum: float: Maximum user equipment power
-			- Peak_Power_Min: float: Minimum user equipment peak power
-			- Peak_Power_Max: float: Maximum user equipment peak power
-			- Psd_Minimum: float: No parameter help available
-			- Psd_Maximum: float: No parameter help available
-			- Evm_Dmrs_Low: float: EVM DMRS value, low EVM window position
-			- Evm_Dmrs_High: float: EVM DMRS value, high EVM window position
-			- Mag_Err_Dmrs_Low: float: Magnitude error DMRS value, low EVM window position
-			- Mag_Err_Dmrs_High: float: Magnitude error DMRS value, high EVM window position
-			- Ph_Error_Dmrs_Low: float: Phase error DMRS value, low EVM window position
-			- Ph_Error_Dmrs_High: float: Phase error DMRS value, high EVM window position
-			- Iq_Gain_Imbalance: float: Gain imbalance
-			- Iq_Quadrature_Err: float: Quadrature error
-			- Evm_Srs: float: Error vector magnitude result for SRS signals"""
+			- Timing_Error: float: Time error
+			- Tx_Power_Minimum: float: Minimum UE RMS power
+			- Tx_Power_Maximum: float: Maximum UE RMS power
+			- Peak_Power_Min: float: Minimum UE peak power
+			- Peak_Power_Max: float: Maximum UE peak power"""
 		__meta_args_list = [
+			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
 			ArgStruct.scalar_float('Evm_Rms_Low'),
 			ArgStruct.scalar_float('Evm_Rms_High'),
 			ArgStruct.scalar_float('Evm_Peak_Low'),
 			ArgStruct.scalar_float('Evm_Peak_High'),
 			ArgStruct.scalar_float('Mag_Error_Rms_Low'),
 			ArgStruct.scalar_float('Mag_Error_Rms_High'),
 			ArgStruct.scalar_float('Mag_Error_Peak_Low'),
 			ArgStruct.scalar_float('Mag_Err_Peak_High'),
 			ArgStruct.scalar_float('Ph_Error_Rms_Low'),
 			ArgStruct.scalar_float('Ph_Error_Rms_High'),
 			ArgStruct.scalar_float('Ph_Error_Peak_Low'),
 			ArgStruct.scalar_float('Ph_Error_Peak_High'),
-			ArgStruct.scalar_float('Iq_Offset'),
 			ArgStruct.scalar_float('Frequency_Error'),
 			ArgStruct.scalar_float('Timing_Error'),
 			ArgStruct.scalar_float('Tx_Power_Minimum'),
 			ArgStruct.scalar_float('Tx_Power_Maximum'),
 			ArgStruct.scalar_float('Peak_Power_Min'),
-			ArgStruct.scalar_float('Peak_Power_Max'),
-			ArgStruct.scalar_float('Psd_Minimum'),
-			ArgStruct.scalar_float('Psd_Maximum'),
-			ArgStruct.scalar_float('Evm_Dmrs_Low'),
-			ArgStruct.scalar_float('Evm_Dmrs_High'),
-			ArgStruct.scalar_float('Mag_Err_Dmrs_Low'),
-			ArgStruct.scalar_float('Mag_Err_Dmrs_High'),
-			ArgStruct.scalar_float('Ph_Error_Dmrs_Low'),
-			ArgStruct.scalar_float('Ph_Error_Dmrs_High'),
-			ArgStruct.scalar_float('Iq_Gain_Imbalance'),
-			ArgStruct.scalar_float('Iq_Quadrature_Err'),
-			ArgStruct.scalar_float('Evm_Srs')]
+			ArgStruct.scalar_float('Peak_Power_Max')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
+			self.Reliability: int = None
 			self.Out_Of_Tolerance: int = None
 			self.Evm_Rms_Low: float = None
 			self.Evm_Rms_High: float = None
 			self.Evm_Peak_Low: float = None
 			self.Evm_Peak_High: float = None
 			self.Mag_Error_Rms_Low: float = None
 			self.Mag_Error_Rms_High: float = None
 			self.Mag_Error_Peak_Low: float = None
 			self.Mag_Err_Peak_High: float = None
 			self.Ph_Error_Rms_Low: float = None
 			self.Ph_Error_Rms_High: float = None
 			self.Ph_Error_Peak_Low: float = None
 			self.Ph_Error_Peak_High: float = None
-			self.Iq_Offset: float = None
 			self.Frequency_Error: float = None
 			self.Timing_Error: float = None
 			self.Tx_Power_Minimum: float = None
 			self.Tx_Power_Maximum: float = None
 			self.Peak_Power_Min: float = None
 			self.Peak_Power_Max: float = None
-			self.Psd_Minimum: float = None
-			self.Psd_Maximum: float = None
-			self.Evm_Dmrs_Low: float = None
-			self.Evm_Dmrs_High: float = None
-			self.Mag_Err_Dmrs_Low: float = None
-			self.Mag_Err_Dmrs_High: float = None
-			self.Ph_Error_Dmrs_Low: float = None
-			self.Ph_Error_Dmrs_High: float = None
-			self.Iq_Gain_Imbalance: float = None
-			self.Iq_Quadrature_Err: float = None
-			self.Evm_Srs: float = None
 
 	def read(self) -> ResultData:
-		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:MODulation:EXTReme \n
-		Snippet: value: ResultData = driver.multiEval.modulation.extreme.read() \n
-		Return the extreme single value results. The values described below are returned by FETCh and READ commands. CALCulate
+		"""SCPI: READ:LTE:MEASurement<Instance>:PRACh:MODulation:EXTReme \n
+		Snippet: value: ResultData = driver.lteMeas.prach.modulation.extreme.read() \n
+		Returns the extreme single value results. The values described below are returned by FETCh and READ commands. CALCulate
 		commands return limit check results instead, one value for each result listed below. \n
-		Suppressed linked return values: reliability \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:MODulation:EXTReme?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:PRACh:MODulation:EXTReme?', self.__class__.ResultData())
 
 	def fetch(self) -> ResultData:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:MODulation:EXTReme \n
-		Snippet: value: ResultData = driver.multiEval.modulation.extreme.fetch() \n
-		Return the extreme single value results. The values described below are returned by FETCh and READ commands. CALCulate
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:PRACh:MODulation:EXTReme \n
+		Snippet: value: ResultData = driver.lteMeas.prach.modulation.extreme.fetch() \n
+		Returns the extreme single value results. The values described below are returned by FETCh and READ commands. CALCulate
 		commands return limit check results instead, one value for each result listed below. \n
-		Suppressed linked return values: reliability \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:MODulation:EXTReme?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:PRACh:MODulation:EXTReme?', self.__class__.ResultData())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Out_Of_Tolerance: int: Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for modulation measurements exceeding the specified modulation limits.
-			- Evm_Rms_Low: float: EVM RMS value, low EVM window position
-			- Evm_Rms_High: float: EVM RMS value, high EVM window position
-			- Evm_Peak_Low: float: EVM peak value, low EVM window position
-			- Evm_Peak_High: float: EVM peak value, high EVM window position
-			- Mag_Error_Rms_Low: float: Magnitude error RMS value, low EVM window position
-			- Mag_Error_Rms_High: float: Magnitude error RMS value, low EVM window position
-			- Mag_Error_Peak_Low: float: Magnitude error peak value, low EVM window position
-			- Mag_Err_Peak_High: float: Magnitude error peak value, high EVM window position
-			- Ph_Error_Rms_Low: float: Phase error RMS value, low EVM window position
-			- Ph_Error_Rms_High: float: Phase error RMS value, high EVM window position
-			- Ph_Error_Peak_Low: float: Phase error peak value, low EVM window position
-			- Ph_Error_Peak_High: float: Phase error peak value, high EVM window position
-			- Iq_Offset: float: I/Q origin offset
-			- Frequency_Error: float: Carrier frequency error
-			- Timing_Error: float: Transmit time error
-			- Tx_Power_Minimum: float: Minimum user equipment power
-			- Tx_Power_Maximum: float: Maximum user equipment power
-			- Peak_Power_Min: float: Minimum user equipment peak power
-			- Peak_Power_Max: float: Maximum user equipment peak power
-			- Psd_Minimum: float: No parameter help available
-			- Psd_Maximum: float: No parameter help available
-			- Evm_Dmrs_Low: float: EVM DMRS value, low EVM window position
-			- Evm_Dmrs_High: float: EVM DMRS value, high EVM window position
-			- Mag_Err_Dmrs_Low: float: Magnitude error DMRS value, low EVM window position
-			- Mag_Err_Dmrs_High: float: Magnitude error DMRS value, high EVM window position
-			- Ph_Error_Dmrs_Low: float: Phase error DMRS value, low EVM window position
-			- Ph_Error_Dmrs_High: float: Phase error DMRS value, high EVM window position
-			- Iq_Gain_Imbalance: float: Gain imbalance
-			- Iq_Quadrature_Err: float: Quadrature error
-			- Evm_Srs: float: Error vector magnitude result for SRS signals"""
+			- Reliability: int: 'Reliability indicator'
+			- Out_Of_Tolerance: int: Out of tolerance result, i.e. the percentage of measurement intervals of the statistic count for modulation measurements exceeding the specified modulation limits.
+			- Evm_Rms_Low: float or bool: EVM RMS value, low EVM window position
+			- Evm_Rms_High: float or bool: EVM RMS value, high EVM window position
+			- Evm_Peak_Low: float or bool: EVM peak value, low EVM window position
+			- Evm_Peak_High: float or bool: EVM peak value, high EVM window position
+			- Mag_Error_Rms_Low: float or bool: Magnitude error RMS value, low EVM window position
+			- Mag_Error_Rms_High: float or bool: Magnitude error RMS value, low EVM window position
+			- Mag_Error_Peak_Low: float or bool: Magnitude error peak value, low EVM window position
+			- Mag_Err_Peak_High: float or bool: Magnitude error peak value, high EVM window position
+			- Ph_Error_Rms_Low: float or bool: Phase error RMS value, low EVM window position
+			- Ph_Error_Rms_High: float or bool: Phase error RMS value, high EVM window position
+			- Ph_Error_Peak_Low: float or bool: Phase error peak value, low EVM window position
+			- Ph_Error_Peak_High: float or bool: Phase error peak value, high EVM window position
+			- Frequency_Error: float or bool: Carrier frequency error
+			- Timing_Error: float or bool: Time error
+			- Tx_Power_Minimum: float or bool: Minimum UE RMS power
+			- Tx_Power_Maximum: float or bool: Maximum UE RMS power
+			- Peak_Power_Min: float or bool: Minimum UE peak power
+			- Peak_Power_Max: float or bool: Maximum UE peak power"""
 		__meta_args_list = [
+			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
-			ArgStruct.scalar_float('Evm_Rms_Low'),
-			ArgStruct.scalar_float('Evm_Rms_High'),
-			ArgStruct.scalar_float('Evm_Peak_Low'),
-			ArgStruct.scalar_float('Evm_Peak_High'),
-			ArgStruct.scalar_float('Mag_Error_Rms_Low'),
-			ArgStruct.scalar_float('Mag_Error_Rms_High'),
-			ArgStruct.scalar_float('Mag_Error_Peak_Low'),
-			ArgStruct.scalar_float('Mag_Err_Peak_High'),
-			ArgStruct.scalar_float('Ph_Error_Rms_Low'),
-			ArgStruct.scalar_float('Ph_Error_Rms_High'),
-			ArgStruct.scalar_float('Ph_Error_Peak_Low'),
-			ArgStruct.scalar_float('Ph_Error_Peak_High'),
-			ArgStruct.scalar_float('Iq_Offset'),
-			ArgStruct.scalar_float('Frequency_Error'),
-			ArgStruct.scalar_float('Timing_Error'),
-			ArgStruct.scalar_float('Tx_Power_Minimum'),
-			ArgStruct.scalar_float('Tx_Power_Maximum'),
-			ArgStruct.scalar_float('Peak_Power_Min'),
-			ArgStruct.scalar_float('Peak_Power_Max'),
-			ArgStruct.scalar_float('Psd_Minimum'),
-			ArgStruct.scalar_float('Psd_Maximum'),
-			ArgStruct.scalar_float('Evm_Dmrs_Low'),
-			ArgStruct.scalar_float('Evm_Dmrs_High'),
-			ArgStruct.scalar_float('Mag_Err_Dmrs_Low'),
-			ArgStruct.scalar_float('Mag_Err_Dmrs_High'),
-			ArgStruct.scalar_float('Ph_Error_Dmrs_Low'),
-			ArgStruct.scalar_float('Ph_Error_Dmrs_High'),
-			ArgStruct.scalar_float('Iq_Gain_Imbalance'),
-			ArgStruct.scalar_float('Iq_Quadrature_Err'),
-			ArgStruct.scalar_float('Evm_Srs')]
+			ArgStruct.scalar_float_ext('Evm_Rms_Low'),
+			ArgStruct.scalar_float_ext('Evm_Rms_High'),
+			ArgStruct.scalar_float_ext('Evm_Peak_Low'),
+			ArgStruct.scalar_float_ext('Evm_Peak_High'),
+			ArgStruct.scalar_float_ext('Mag_Error_Rms_Low'),
+			ArgStruct.scalar_float_ext('Mag_Error_Rms_High'),
+			ArgStruct.scalar_float_ext('Mag_Error_Peak_Low'),
+			ArgStruct.scalar_float_ext('Mag_Err_Peak_High'),
+			ArgStruct.scalar_float_ext('Ph_Error_Rms_Low'),
+			ArgStruct.scalar_float_ext('Ph_Error_Rms_High'),
+			ArgStruct.scalar_float_ext('Ph_Error_Peak_Low'),
+			ArgStruct.scalar_float_ext('Ph_Error_Peak_High'),
+			ArgStruct.scalar_float_ext('Frequency_Error'),
+			ArgStruct.scalar_float_ext('Timing_Error'),
+			ArgStruct.scalar_float_ext('Tx_Power_Minimum'),
+			ArgStruct.scalar_float_ext('Tx_Power_Maximum'),
+			ArgStruct.scalar_float_ext('Peak_Power_Min'),
+			ArgStruct.scalar_float_ext('Peak_Power_Max')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
+			self.Reliability: int = None
 			self.Out_Of_Tolerance: int = None
-			self.Evm_Rms_Low: float = None
-			self.Evm_Rms_High: float = None
-			self.Evm_Peak_Low: float = None
-			self.Evm_Peak_High: float = None
-			self.Mag_Error_Rms_Low: float = None
-			self.Mag_Error_Rms_High: float = None
-			self.Mag_Error_Peak_Low: float = None
-			self.Mag_Err_Peak_High: float = None
-			self.Ph_Error_Rms_Low: float = None
-			self.Ph_Error_Rms_High: float = None
-			self.Ph_Error_Peak_Low: float = None
-			self.Ph_Error_Peak_High: float = None
-			self.Iq_Offset: float = None
-			self.Frequency_Error: float = None
-			self.Timing_Error: float = None
-			self.Tx_Power_Minimum: float = None
-			self.Tx_Power_Maximum: float = None
-			self.Peak_Power_Min: float = None
-			self.Peak_Power_Max: float = None
-			self.Psd_Minimum: float = None
-			self.Psd_Maximum: float = None
-			self.Evm_Dmrs_Low: float = None
-			self.Evm_Dmrs_High: float = None
-			self.Mag_Err_Dmrs_Low: float = None
-			self.Mag_Err_Dmrs_High: float = None
-			self.Ph_Error_Dmrs_Low: float = None
-			self.Ph_Error_Dmrs_High: float = None
-			self.Iq_Gain_Imbalance: float = None
-			self.Iq_Quadrature_Err: float = None
-			self.Evm_Srs: float = None
+			self.Evm_Rms_Low: float or bool = None
+			self.Evm_Rms_High: float or bool = None
+			self.Evm_Peak_Low: float or bool = None
+			self.Evm_Peak_High: float or bool = None
+			self.Mag_Error_Rms_Low: float or bool = None
+			self.Mag_Error_Rms_High: float or bool = None
+			self.Mag_Error_Peak_Low: float or bool = None
+			self.Mag_Err_Peak_High: float or bool = None
+			self.Ph_Error_Rms_Low: float or bool = None
+			self.Ph_Error_Rms_High: float or bool = None
+			self.Ph_Error_Peak_Low: float or bool = None
+			self.Ph_Error_Peak_High: float or bool = None
+			self.Frequency_Error: float or bool = None
+			self.Timing_Error: float or bool = None
+			self.Tx_Power_Minimum: float or bool = None
+			self.Tx_Power_Maximum: float or bool = None
+			self.Peak_Power_Min: float or bool = None
+			self.Peak_Power_Max: float or bool = None
 
 	def calculate(self) -> CalculateStruct:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:MODulation:EXTReme \n
-		Snippet: value: CalculateStruct = driver.multiEval.modulation.extreme.calculate() \n
-		Return the extreme single value results. The values described below are returned by FETCh and READ commands. CALCulate
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:PRACh:MODulation:EXTReme \n
+		Snippet: value: CalculateStruct = driver.lteMeas.prach.modulation.extreme.calculate() \n
+		Returns the extreme single value results. The values described below are returned by FETCh and READ commands. CALCulate
 		commands return limit check results instead, one value for each result listed below. \n
-		Suppressed linked return values: reliability \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:MODulation:EXTReme?', self.__class__.CalculateStruct())
+		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:PRACh:MODulation:EXTReme?', self.__class__.CalculateStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Modulation_/SchType.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/VfThroughput.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,26 +1,24 @@
 from ....Internal.Core import Core
 from ....Internal.CommandsGroup import CommandsGroup
 from ....Internal import Conversions
 from ....Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ....Internal.Types import DataType
-from .... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class SchType:
-	"""SchType commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class VfThroughputCls:
+	"""VfThroughput commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("schType", core, parent)
+		self._cmd_group = CommandsGroup("vfThroughput", core, parent)
 
-	# noinspection PyTypeChecker
-	def fetch(self) -> enums.SidelinkChannelType:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:MODulation:SCHType \n
-		Snippet: value: enums.SidelinkChannelType = driver.multiEval.modulation.schType.fetch() \n
-		Returns the sidelink channel type evaluated for modulation results. \n
+	def fetch(self) -> float:
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:VFTHroughput \n
+		Snippet: value: float = driver.lteMeas.multiEval.vfThroughput.fetch() \n
+		Queries the View Filter Throughput. \n
 		Suppressed linked return values: reliability \n
-			:return: channel_type: No help available"""
+			:return: vf_throughput: No help available"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_str_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:MODulation:SCHType?', suppressed)
-		return Conversions.str_to_scalar_enum(response, enums.SidelinkChannelType)
+		response = self._core.io.query_str_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:VFTHroughput?', suppressed)
+		return Conversions.str_to_float(response)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Modulation_/StandardDev.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/Modulation/Average/__init__.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,55 +1,97 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
-from ....Internal.StructBase import StructBase
-from ....Internal.ArgStruct import ArgStruct
+from ........Internal.Core import Core
+from ........Internal.CommandsGroup import CommandsGroup
+from ........Internal.StructBase import StructBase
+from ........Internal.ArgStruct import ArgStruct
+from ........ import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class StandardDev:
-	"""StandardDev commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class AverageCls:
+	"""Average commands group definition. 7 total commands, 5 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("standardDev", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
+
+	@property
+	def mod(self):
+		"""mod commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_mod'):
+			from .Mod import ModCls
+			self._mod = ModCls(self._core, self._cmd_group)
+		return self._mod
+
+	@property
+	def pow(self):
+		"""pow commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_pow'):
+			from .Pow import PowCls
+			self._pow = PowCls(self._core, self._cmd_group)
+		return self._pow
+
+	@property
+	def dmrs(self):
+		"""dmrs commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_dmrs'):
+			from .Dmrs import DmrsCls
+			self._dmrs = DmrsCls(self._core, self._cmd_group)
+		return self._dmrs
+
+	@property
+	def emph(self):
+		"""emph commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_emph'):
+			from .Emph import EmphCls
+			self._emph = EmphCls(self._core, self._cmd_group)
+		return self._emph
+
+	@property
+	def globale(self):
+		"""globale commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_globale'):
+			from .Globale import GlobaleCls
+			self._globale = GlobaleCls(self._core, self._cmd_group)
+		return self._globale
 
 	# noinspection PyTypeChecker
-	class ResultData(StructBase):
+	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Out_Of_Tolerance: int: Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for modulation measurements exceeding the specified modulation limits.
+			- Reliability: int: 'Reliability indicator'
+			- Seg_Reliability: int: Reliability indicator for the segment
+			- Statist_Expired: int: Reached statistical length in slots
+			- Out_Of_Tolerance: int: Percentage of measured subframes with failed limit check
 			- Evm_Rms_Low: float: EVM RMS value, low EVM window position
 			- Evm_Rms_High: float: EVM RMS value, high EVM window position
 			- Evm_Peak_Low: float: EVM peak value, low EVM window position
 			- Evm_Peak_High: float: EVM peak value, high EVM window position
 			- Mag_Error_Rms_Low: float: Magnitude error RMS value, low EVM window position
 			- Mag_Error_Rms_High: float: Magnitude error RMS value, low EVM window position
 			- Mag_Error_Peak_Low: float: Magnitude error peak value, low EVM window position
 			- Mag_Err_Peak_High: float: Magnitude error peak value, high EVM window position
 			- Ph_Error_Rms_Low: float: Phase error RMS value, low EVM window position
 			- Ph_Error_Rms_High: float: Phase error RMS value, high EVM window position
 			- Ph_Error_Peak_Low: float: Phase error peak value, low EVM window position
 			- Ph_Error_Peak_High: float: Phase error peak value, high EVM window position
 			- Iq_Offset: float: I/Q origin offset
 			- Frequency_Error: float: Carrier frequency error
-			- Timing_Error: float: Transmit time error
+			- Timing_Error: float: Time error
 			- Tx_Power: float: User equipment power
 			- Peak_Power: float: User equipment peak power
 			- Psd: float: No parameter help available
 			- Evm_Dmrs_Low: float: EVM DMRS value, low EVM window position
 			- Evm_Dmrs_High: float: EVM DMRS value, high EVM window position
 			- Mag_Err_Dmrs_Low: float: Magnitude error DMRS value, low EVM window position
 			- Mag_Err_Dmrs_High: float: Magnitude error DMRS value, high EVM window position
 			- Ph_Error_Dmrs_Low: float: Phase error DMRS value, low EVM window position
-			- Ph_Error_Dmrs_High: float: Phase error DMRS value, high EVM window position
-			- Iq_Gain_Imbalance: float: Gain imbalance
-			- Iq_Quadrature_Err: float: Quadrature error
-			- Evm_Srs: float: Error vector magnitude result for SRS signals"""
+			- Ph_Error_Dmrs_High: float: Phase error DMRS value, high EVM window position"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
+			ArgStruct.scalar_int('Seg_Reliability'),
+			ArgStruct.scalar_int('Statist_Expired'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
 			ArgStruct.scalar_float('Evm_Rms_Low'),
 			ArgStruct.scalar_float('Evm_Rms_High'),
 			ArgStruct.scalar_float('Evm_Peak_Low'),
 			ArgStruct.scalar_float('Evm_Peak_High'),
 			ArgStruct.scalar_float('Mag_Error_Rms_Low'),
 			ArgStruct.scalar_float('Mag_Error_Rms_High'),
@@ -66,22 +108,21 @@
 			ArgStruct.scalar_float('Peak_Power'),
 			ArgStruct.scalar_float('Psd'),
 			ArgStruct.scalar_float('Evm_Dmrs_Low'),
 			ArgStruct.scalar_float('Evm_Dmrs_High'),
 			ArgStruct.scalar_float('Mag_Err_Dmrs_Low'),
 			ArgStruct.scalar_float('Mag_Err_Dmrs_High'),
 			ArgStruct.scalar_float('Ph_Error_Dmrs_Low'),
-			ArgStruct.scalar_float('Ph_Error_Dmrs_High'),
-			ArgStruct.scalar_float('Iq_Gain_Imbalance'),
-			ArgStruct.scalar_float('Iq_Quadrature_Err'),
-			ArgStruct.scalar_float('Evm_Srs')]
+			ArgStruct.scalar_float('Ph_Error_Dmrs_High')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
+			self.Seg_Reliability: int = None
+			self.Statist_Expired: int = None
 			self.Out_Of_Tolerance: int = None
 			self.Evm_Rms_Low: float = None
 			self.Evm_Rms_High: float = None
 			self.Evm_Peak_Low: float = None
 			self.Evm_Peak_High: float = None
 			self.Mag_Error_Rms_Low: float = None
 			self.Mag_Error_Rms_High: float = None
@@ -99,127 +140,129 @@
 			self.Psd: float = None
 			self.Evm_Dmrs_Low: float = None
 			self.Evm_Dmrs_High: float = None
 			self.Mag_Err_Dmrs_Low: float = None
 			self.Mag_Err_Dmrs_High: float = None
 			self.Ph_Error_Dmrs_Low: float = None
 			self.Ph_Error_Dmrs_High: float = None
-			self.Iq_Gain_Imbalance: float = None
-			self.Iq_Quadrature_Err: float = None
-			self.Evm_Srs: float = None
-
-	def read(self) -> ResultData:
-		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:MODulation:SDEViation \n
-		Snippet: value: ResultData = driver.multiEval.modulation.standardDev.read() \n
-		Return the current, average and standard deviation single value results. The values described below are returned by FETCh
-		and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
-			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:MODulation:SDEViation?', self.__class__.ResultData())
-
-	def fetch(self) -> ResultData:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:MODulation:SDEViation \n
-		Snippet: value: ResultData = driver.multiEval.modulation.standardDev.fetch() \n
-		No command help available \n
-			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:MODulation:SDEViation?', self.__class__.ResultData())
+
+	def fetch(self, segment=repcap.Segment.Default) -> FetchStruct:
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:MODulation:AVERage \n
+		Snippet: value: FetchStruct = driver.lteMeas.multiEval.listPy.segment.modulation.average.fetch(segment = repcap.Segment.Default) \n
+		Returns modulation single-value results for segment <no> in list mode. The values described below are returned by FETCh
+		commands. The first four values (reliability to out of tolerance result) are also returned by CALCulate commands.
+		The remaining values returned by CALCulate commands are limit check results, one value for each result listed below. \n
+			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
+			:return: structure: for return value, see the help for FetchStruct structure arguments."""
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:MODulation:AVERage?', self.__class__.FetchStruct())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: No parameter help available
-			- Out_Of_Tolerance: int: No parameter help available
-			- Evm_Rms_Low: float: No parameter help available
-			- Evm_Rms_High: float: No parameter help available
-			- Evm_Peak_Low: float: No parameter help available
-			- Evm_Peak_High: float: No parameter help available
-			- Mag_Error_Rms_Low: float: No parameter help available
-			- Mag_Error_Rms_High: float: No parameter help available
-			- Mag_Error_Peak_Low: float: No parameter help available
-			- Mag_Err_Peak_High: float: No parameter help available
-			- Ph_Error_Rms_Low: float: No parameter help available
-			- Ph_Error_Rms_High: float: No parameter help available
-			- Ph_Error_Peak_Low: float: No parameter help available
-			- Ph_Error_Peak_High: float: No parameter help available
-			- Iq_Offset: float: No parameter help available
-			- Frequency_Error: float: No parameter help available
-			- Timing_Error: float: No parameter help available
-			- Tx_Power: float: No parameter help available
-			- Peak_Power: float: No parameter help available
-			- Psd: float: No parameter help available
-			- Evm_Dmrs_Low: float: No parameter help available
-			- Evm_Dmrs_High: float: No parameter help available
-			- Mag_Err_Dmrs_Low: float: No parameter help available
-			- Mag_Err_Dmrs_High: float: No parameter help available
-			- Ph_Error_Dmrs_Low: float: No parameter help available
-			- Ph_Error_Dmrs_High: float: No parameter help available
-			- Iq_Gain_Imbalance: float: No parameter help available
-			- Iq_Quadrature_Err: float: No parameter help available
-			- Evm_Srs: float: No parameter help available"""
+			- Reliability: int: 'Reliability indicator'
+			- Seg_Reliability: int: Reliability indicator for the segment
+			- Statist_Expired: int: Reached statistical length in slots
+			- Out_Of_Tolerance: int: Percentage of measured subframes with failed limit check
+			- Evm_Rms_Low: float or bool: EVM RMS value, low EVM window position
+			- Evm_Rms_High: float or bool: EVM RMS value, high EVM window position
+			- Evm_Peak_Low: float or bool: EVM peak value, low EVM window position
+			- Evm_Peak_High: float or bool: EVM peak value, high EVM window position
+			- Mag_Error_Rms_Low: float or bool: Magnitude error RMS value, low EVM window position
+			- Mag_Error_Rms_High: float or bool: Magnitude error RMS value, low EVM window position
+			- Mag_Error_Peak_Low: float or bool: Magnitude error peak value, low EVM window position
+			- Mag_Err_Peak_High: float or bool: Magnitude error peak value, high EVM window position
+			- Ph_Error_Rms_Low: float or bool: Phase error RMS value, low EVM window position
+			- Ph_Error_Rms_High: float or bool: Phase error RMS value, high EVM window position
+			- Ph_Error_Peak_Low: float or bool: Phase error peak value, low EVM window position
+			- Ph_Error_Peak_High: float or bool: Phase error peak value, high EVM window position
+			- Iq_Offset: float or bool: I/Q origin offset
+			- Frequency_Error: float or bool: Carrier frequency error
+			- Timing_Error: float or bool: Time error
+			- Tx_Power: float or bool: User equipment power
+			- Peak_Power: float or bool: User equipment peak power
+			- Psd: float or bool: No parameter help available
+			- Evm_Dmrs_Low: float or bool: EVM DMRS value, low EVM window position
+			- Evm_Dmrs_High: float or bool: EVM DMRS value, high EVM window position
+			- Mag_Err_Dmrs_Low: float or bool: Magnitude error DMRS value, low EVM window position
+			- Mag_Err_Dmrs_High: float or bool: Magnitude error DMRS value, high EVM window position
+			- Ph_Error_Dmrs_Low: float or bool: Phase error DMRS value, low EVM window position
+			- Ph_Error_Dmrs_High: float or bool: Phase error DMRS value, high EVM window position"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
+			ArgStruct.scalar_int('Seg_Reliability'),
+			ArgStruct.scalar_int('Statist_Expired'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
-			ArgStruct.scalar_float('Evm_Rms_Low'),
-			ArgStruct.scalar_float('Evm_Rms_High'),
-			ArgStruct.scalar_float('Evm_Peak_Low'),
-			ArgStruct.scalar_float('Evm_Peak_High'),
-			ArgStruct.scalar_float('Mag_Error_Rms_Low'),
-			ArgStruct.scalar_float('Mag_Error_Rms_High'),
-			ArgStruct.scalar_float('Mag_Error_Peak_Low'),
-			ArgStruct.scalar_float('Mag_Err_Peak_High'),
-			ArgStruct.scalar_float('Ph_Error_Rms_Low'),
-			ArgStruct.scalar_float('Ph_Error_Rms_High'),
-			ArgStruct.scalar_float('Ph_Error_Peak_Low'),
-			ArgStruct.scalar_float('Ph_Error_Peak_High'),
-			ArgStruct.scalar_float('Iq_Offset'),
-			ArgStruct.scalar_float('Frequency_Error'),
-			ArgStruct.scalar_float('Timing_Error'),
-			ArgStruct.scalar_float('Tx_Power'),
-			ArgStruct.scalar_float('Peak_Power'),
-			ArgStruct.scalar_float('Psd'),
-			ArgStruct.scalar_float('Evm_Dmrs_Low'),
-			ArgStruct.scalar_float('Evm_Dmrs_High'),
-			ArgStruct.scalar_float('Mag_Err_Dmrs_Low'),
-			ArgStruct.scalar_float('Mag_Err_Dmrs_High'),
-			ArgStruct.scalar_float('Ph_Error_Dmrs_Low'),
-			ArgStruct.scalar_float('Ph_Error_Dmrs_High'),
-			ArgStruct.scalar_float('Iq_Gain_Imbalance'),
-			ArgStruct.scalar_float('Iq_Quadrature_Err'),
-			ArgStruct.scalar_float('Evm_Srs')]
+			ArgStruct.scalar_float_ext('Evm_Rms_Low'),
+			ArgStruct.scalar_float_ext('Evm_Rms_High'),
+			ArgStruct.scalar_float_ext('Evm_Peak_Low'),
+			ArgStruct.scalar_float_ext('Evm_Peak_High'),
+			ArgStruct.scalar_float_ext('Mag_Error_Rms_Low'),
+			ArgStruct.scalar_float_ext('Mag_Error_Rms_High'),
+			ArgStruct.scalar_float_ext('Mag_Error_Peak_Low'),
+			ArgStruct.scalar_float_ext('Mag_Err_Peak_High'),
+			ArgStruct.scalar_float_ext('Ph_Error_Rms_Low'),
+			ArgStruct.scalar_float_ext('Ph_Error_Rms_High'),
+			ArgStruct.scalar_float_ext('Ph_Error_Peak_Low'),
+			ArgStruct.scalar_float_ext('Ph_Error_Peak_High'),
+			ArgStruct.scalar_float_ext('Iq_Offset'),
+			ArgStruct.scalar_float_ext('Frequency_Error'),
+			ArgStruct.scalar_float_ext('Timing_Error'),
+			ArgStruct.scalar_float_ext('Tx_Power'),
+			ArgStruct.scalar_float_ext('Peak_Power'),
+			ArgStruct.scalar_float_ext('Psd'),
+			ArgStruct.scalar_float_ext('Evm_Dmrs_Low'),
+			ArgStruct.scalar_float_ext('Evm_Dmrs_High'),
+			ArgStruct.scalar_float_ext('Mag_Err_Dmrs_Low'),
+			ArgStruct.scalar_float_ext('Mag_Err_Dmrs_High'),
+			ArgStruct.scalar_float_ext('Ph_Error_Dmrs_Low'),
+			ArgStruct.scalar_float_ext('Ph_Error_Dmrs_High')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
+			self.Seg_Reliability: int = None
+			self.Statist_Expired: int = None
 			self.Out_Of_Tolerance: int = None
-			self.Evm_Rms_Low: float = None
-			self.Evm_Rms_High: float = None
-			self.Evm_Peak_Low: float = None
-			self.Evm_Peak_High: float = None
-			self.Mag_Error_Rms_Low: float = None
-			self.Mag_Error_Rms_High: float = None
-			self.Mag_Error_Peak_Low: float = None
-			self.Mag_Err_Peak_High: float = None
-			self.Ph_Error_Rms_Low: float = None
-			self.Ph_Error_Rms_High: float = None
-			self.Ph_Error_Peak_Low: float = None
-			self.Ph_Error_Peak_High: float = None
-			self.Iq_Offset: float = None
-			self.Frequency_Error: float = None
-			self.Timing_Error: float = None
-			self.Tx_Power: float = None
-			self.Peak_Power: float = None
-			self.Psd: float = None
-			self.Evm_Dmrs_Low: float = None
-			self.Evm_Dmrs_High: float = None
-			self.Mag_Err_Dmrs_Low: float = None
-			self.Mag_Err_Dmrs_High: float = None
-			self.Ph_Error_Dmrs_Low: float = None
-			self.Ph_Error_Dmrs_High: float = None
-			self.Iq_Gain_Imbalance: float = None
-			self.Iq_Quadrature_Err: float = None
-			self.Evm_Srs: float = None
-
-	def calculate(self) -> CalculateStruct:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:MODulation:SDEViation \n
-		Snippet: value: CalculateStruct = driver.multiEval.modulation.standardDev.calculate() \n
-		No command help available \n
+			self.Evm_Rms_Low: float or bool = None
+			self.Evm_Rms_High: float or bool = None
+			self.Evm_Peak_Low: float or bool = None
+			self.Evm_Peak_High: float or bool = None
+			self.Mag_Error_Rms_Low: float or bool = None
+			self.Mag_Error_Rms_High: float or bool = None
+			self.Mag_Error_Peak_Low: float or bool = None
+			self.Mag_Err_Peak_High: float or bool = None
+			self.Ph_Error_Rms_Low: float or bool = None
+			self.Ph_Error_Rms_High: float or bool = None
+			self.Ph_Error_Peak_Low: float or bool = None
+			self.Ph_Error_Peak_High: float or bool = None
+			self.Iq_Offset: float or bool = None
+			self.Frequency_Error: float or bool = None
+			self.Timing_Error: float or bool = None
+			self.Tx_Power: float or bool = None
+			self.Peak_Power: float or bool = None
+			self.Psd: float or bool = None
+			self.Evm_Dmrs_Low: float or bool = None
+			self.Evm_Dmrs_High: float or bool = None
+			self.Mag_Err_Dmrs_Low: float or bool = None
+			self.Mag_Err_Dmrs_High: float or bool = None
+			self.Ph_Error_Dmrs_Low: float or bool = None
+			self.Ph_Error_Dmrs_High: float or bool = None
+
+	def calculate(self, segment=repcap.Segment.Default) -> CalculateStruct:
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:MODulation:AVERage \n
+		Snippet: value: CalculateStruct = driver.lteMeas.multiEval.listPy.segment.modulation.average.calculate(segment = repcap.Segment.Default) \n
+		Returns modulation single-value results for segment <no> in list mode. The values described below are returned by FETCh
+		commands. The first four values (reliability to out of tolerance result) are also returned by CALCulate commands.
+		The remaining values returned by CALCulate commands are limit check results, one value for each result listed below. \n
+			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:MODulation:SDEViation?', self.__class__.CalculateStruct())
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
+		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:MODulation:AVERage?', self.__class__.CalculateStruct())
+
+	def clone(self) -> 'AverageCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
+		Also copies all the existing default Repeated Capabilities setting,
+		which you can change independently without affecting the original group"""
+		new_group = AverageCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
+		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Pdynamics.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Pmonitor/Ulca/Pcc/__init__.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,59 +1,59 @@
-from ...Internal.Core import Core
-from ...Internal.CommandsGroup import CommandsGroup
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Pdynamics:
-	"""Pdynamics commands group definition. 15 total commands, 5 Sub-groups, 0 group commands"""
+class PccCls:
+	"""Pcc commands group definition. 10 total commands, 5 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("pdynamics", core, parent)
+		self._cmd_group = CommandsGroup("pcc", core, parent)
 
 	@property
 	def current(self):
-		"""current commands group. 0 Sub-classes, 3 commands."""
+		"""current commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_current'):
-			from .Pdynamics_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
 	@property
 	def average(self):
-		"""average commands group. 0 Sub-classes, 3 commands."""
+		"""average commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_average'):
-			from .Pdynamics_.Average import Average
-			self._average = Average(self._core, self._base)
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
 		return self._average
 
 	@property
 	def maximum(self):
-		"""maximum commands group. 0 Sub-classes, 3 commands."""
+		"""maximum commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_maximum'):
-			from .Pdynamics_.Maximum import Maximum
-			self._maximum = Maximum(self._core, self._base)
+			from .Maximum import MaximumCls
+			self._maximum = MaximumCls(self._core, self._cmd_group)
 		return self._maximum
 
 	@property
 	def minimum(self):
-		"""minimum commands group. 0 Sub-classes, 3 commands."""
+		"""minimum commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_minimum'):
-			from .Pdynamics_.Minimum import Minimum
-			self._minimum = Minimum(self._core, self._base)
+			from .Minimum import MinimumCls
+			self._minimum = MinimumCls(self._core, self._cmd_group)
 		return self._minimum
 
 	@property
 	def standardDev(self):
-		"""standardDev commands group. 0 Sub-classes, 3 commands."""
+		"""standardDev commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_standardDev'):
-			from .Pdynamics_.StandardDev import StandardDev
-			self._standardDev = StandardDev(self._core, self._base)
+			from .StandardDev import StandardDevCls
+			self._standardDev = StandardDevCls(self._core, self._cmd_group)
 		return self._standardDev
 
-	def clone(self) -> 'Pdynamics':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'PccCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Pdynamics(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = PccCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Pdynamics_/Average.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Pdynamics/Minimum.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,26 +1,26 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
-from ....Internal.StructBase import StructBase
-from ....Internal.ArgStruct import ArgStruct
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
+from .....Internal.StructBase import StructBase
+from .....Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class MinimumCls:
+	"""Minimum commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("minimum", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Out_Of_Tolerance: int: Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for power measurements exceeding the specified power limits.
+			- Reliability: int: 'Reliability indicator'
+			- Out_Of_Tolerance: int: Out of tolerance result, i.e. the percentage of measurement intervals of the statistic count for power measurements exceeding the specified power limits.
 			- Off_Power_Before: float: No parameter help available
 			- On_Power_Rms: float: No parameter help available
 			- On_Power_Peak: float: No parameter help available
 			- Off_Power_After: float: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
@@ -35,76 +35,76 @@
 			self.Out_Of_Tolerance: int = None
 			self.Off_Power_Before: float = None
 			self.On_Power_Rms: float = None
 			self.On_Power_Peak: float = None
 			self.Off_Power_After: float = None
 
 	def read(self) -> ResultData:
-		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:PDYNamics:AVERage \n
-		Snippet: value: ResultData = driver.multiEval.pdynamics.average.read() \n
-		Return the current, average, minimum, maximum and standard deviation single value results of the power dynamics
+		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:PDYNamics:MINimum \n
+		Snippet: value: ResultData = driver.lteMeas.multiEval.pdynamics.minimum.read() \n
+		Return the current, average, minimum, maximum and standard deviation single-value results of the power dynamics
 		measurement. A single result table row is returned, from left to right. The meaning of the values depends on the selected
 		time mask, as follows:
-			Table Header: Time mask / Power1 / Power2 / Power3 / Power4 \n
+			Table Header: Time mask / <Power1> / <Power2> / <Power3> / <Power4> \n
 			- General on / off / OFF power (before) / ON power RMS / ON power peak / OFF power (after)
 			- PUCCH / PUSCH / SRS / SRS ON / ON power RMS / ON power peak / ON power (after)
 			- SRS blanking / SRS OFF / ON power RMS / ON power peak / ON power (after)
 		The values described below are returned by FETCh and READ commands. CALCulate commands return limit check results instead,
 		one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:PDYNamics:AVERage?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:PDYNamics:MINimum?', self.__class__.ResultData())
 
 	def fetch(self) -> ResultData:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:PDYNamics:AVERage \n
-		Snippet: value: ResultData = driver.multiEval.pdynamics.average.fetch() \n
-		Return the current, average, minimum, maximum and standard deviation single value results of the power dynamics
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:PDYNamics:MINimum \n
+		Snippet: value: ResultData = driver.lteMeas.multiEval.pdynamics.minimum.fetch() \n
+		Return the current, average, minimum, maximum and standard deviation single-value results of the power dynamics
 		measurement. A single result table row is returned, from left to right. The meaning of the values depends on the selected
 		time mask, as follows:
-			Table Header: Time mask / Power1 / Power2 / Power3 / Power4 \n
+			Table Header: Time mask / <Power1> / <Power2> / <Power3> / <Power4> \n
 			- General on / off / OFF power (before) / ON power RMS / ON power peak / OFF power (after)
 			- PUCCH / PUSCH / SRS / SRS ON / ON power RMS / ON power peak / ON power (after)
 			- SRS blanking / SRS OFF / ON power RMS / ON power peak / ON power (after)
 		The values described below are returned by FETCh and READ commands. CALCulate commands return limit check results instead,
 		one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:PDYNamics:AVERage?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:PDYNamics:MINimum?', self.__class__.ResultData())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Out_Of_Tolerance: int: Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for power measurements exceeding the specified power limits.
-			- Off_Power_Before: float: No parameter help available
-			- On_Power_Rms: float: No parameter help available
-			- On_Power_Peak: float: No parameter help available
-			- Off_Power_After: float: No parameter help available"""
+			- Reliability: int: 'Reliability indicator'
+			- Out_Of_Tolerance: int: Out of tolerance result, i.e. the percentage of measurement intervals of the statistic count for power measurements exceeding the specified power limits.
+			- Off_Power_Before: float or bool: No parameter help available
+			- On_Power_Rms: float or bool: No parameter help available
+			- On_Power_Peak: float or bool: No parameter help available
+			- Off_Power_After: float or bool: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
-			ArgStruct.scalar_float('Off_Power_Before'),
-			ArgStruct.scalar_float('On_Power_Rms'),
-			ArgStruct.scalar_float('On_Power_Peak'),
-			ArgStruct.scalar_float('Off_Power_After')]
+			ArgStruct.scalar_float_ext('Off_Power_Before'),
+			ArgStruct.scalar_float_ext('On_Power_Rms'),
+			ArgStruct.scalar_float_ext('On_Power_Peak'),
+			ArgStruct.scalar_float_ext('Off_Power_After')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tolerance: int = None
-			self.Off_Power_Before: float = None
-			self.On_Power_Rms: float = None
-			self.On_Power_Peak: float = None
-			self.Off_Power_After: float = None
+			self.Off_Power_Before: float or bool = None
+			self.On_Power_Rms: float or bool = None
+			self.On_Power_Peak: float or bool = None
+			self.Off_Power_After: float or bool = None
 
 	def calculate(self) -> CalculateStruct:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:PDYNamics:AVERage \n
-		Snippet: value: CalculateStruct = driver.multiEval.pdynamics.average.calculate() \n
-		Return the current, average, minimum, maximum and standard deviation single value results of the power dynamics
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:PDYNamics:MINimum \n
+		Snippet: value: CalculateStruct = driver.lteMeas.multiEval.pdynamics.minimum.calculate() \n
+		Return the current, average, minimum, maximum and standard deviation single-value results of the power dynamics
 		measurement. A single result table row is returned, from left to right. The meaning of the values depends on the selected
 		time mask, as follows:
-			Table Header: Time mask / Power1 / Power2 / Power3 / Power4 \n
+			Table Header: Time mask / <Power1> / <Power2> / <Power3> / <Power4> \n
 			- General on / off / OFF power (before) / ON power RMS / ON power peak / OFF power (after)
 			- PUCCH / PUSCH / SRS / SRS ON / ON power RMS / ON power peak / ON power (after)
 			- SRS blanking / SRS OFF / ON power RMS / ON power peak / ON power (after)
 		The values described below are returned by FETCh and READ commands. CALCulate commands return limit check results instead,
 		one value for each result listed below. \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:PDYNamics:AVERage?', self.__class__.CalculateStruct())
+		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:PDYNamics:MINimum?', self.__class__.CalculateStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Pdynamics_/Current.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Pdynamics/Current.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,26 +1,26 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
-from ....Internal.StructBase import StructBase
-from ....Internal.ArgStruct import ArgStruct
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
+from .....Internal.StructBase import StructBase
+from .....Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Out_Of_Tolerance: int: Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for power measurements exceeding the specified power limits.
+			- Reliability: int: 'Reliability indicator'
+			- Out_Of_Tolerance: int: Out of tolerance result, i.e. the percentage of measurement intervals of the statistic count for power measurements exceeding the specified power limits.
 			- Off_Power_Before: float: No parameter help available
 			- On_Power_Rms: float: No parameter help available
 			- On_Power_Peak: float: No parameter help available
 			- Off_Power_After: float: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
@@ -36,75 +36,75 @@
 			self.Off_Power_Before: float = None
 			self.On_Power_Rms: float = None
 			self.On_Power_Peak: float = None
 			self.Off_Power_After: float = None
 
 	def read(self) -> ResultData:
 		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:PDYNamics:CURRent \n
-		Snippet: value: ResultData = driver.multiEval.pdynamics.current.read() \n
-		Return the current, average, minimum, maximum and standard deviation single value results of the power dynamics
+		Snippet: value: ResultData = driver.lteMeas.multiEval.pdynamics.current.read() \n
+		Return the current, average, minimum, maximum and standard deviation single-value results of the power dynamics
 		measurement. A single result table row is returned, from left to right. The meaning of the values depends on the selected
 		time mask, as follows:
-			Table Header: Time mask / Power1 / Power2 / Power3 / Power4 \n
+			Table Header: Time mask / <Power1> / <Power2> / <Power3> / <Power4> \n
 			- General on / off / OFF power (before) / ON power RMS / ON power peak / OFF power (after)
 			- PUCCH / PUSCH / SRS / SRS ON / ON power RMS / ON power peak / ON power (after)
 			- SRS blanking / SRS OFF / ON power RMS / ON power peak / ON power (after)
 		The values described below are returned by FETCh and READ commands. CALCulate commands return limit check results instead,
 		one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
 		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:PDYNamics:CURRent?', self.__class__.ResultData())
 
 	def fetch(self) -> ResultData:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:PDYNamics:CURRent \n
-		Snippet: value: ResultData = driver.multiEval.pdynamics.current.fetch() \n
-		Return the current, average, minimum, maximum and standard deviation single value results of the power dynamics
+		Snippet: value: ResultData = driver.lteMeas.multiEval.pdynamics.current.fetch() \n
+		Return the current, average, minimum, maximum and standard deviation single-value results of the power dynamics
 		measurement. A single result table row is returned, from left to right. The meaning of the values depends on the selected
 		time mask, as follows:
-			Table Header: Time mask / Power1 / Power2 / Power3 / Power4 \n
+			Table Header: Time mask / <Power1> / <Power2> / <Power3> / <Power4> \n
 			- General on / off / OFF power (before) / ON power RMS / ON power peak / OFF power (after)
 			- PUCCH / PUSCH / SRS / SRS ON / ON power RMS / ON power peak / ON power (after)
 			- SRS blanking / SRS OFF / ON power RMS / ON power peak / ON power (after)
 		The values described below are returned by FETCh and READ commands. CALCulate commands return limit check results instead,
 		one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
 		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:PDYNamics:CURRent?', self.__class__.ResultData())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Out_Of_Tolerance: int: Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for power measurements exceeding the specified power limits.
-			- Off_Power_Before: float: No parameter help available
-			- On_Power_Rms: float: No parameter help available
-			- On_Power_Peak: float: No parameter help available
-			- Off_Power_After: float: No parameter help available"""
+			- Reliability: int: 'Reliability indicator'
+			- Out_Of_Tolerance: int: Out of tolerance result, i.e. the percentage of measurement intervals of the statistic count for power measurements exceeding the specified power limits.
+			- Off_Power_Before: float or bool: No parameter help available
+			- On_Power_Rms: float or bool: No parameter help available
+			- On_Power_Peak: float or bool: No parameter help available
+			- Off_Power_After: float or bool: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
-			ArgStruct.scalar_float('Off_Power_Before'),
-			ArgStruct.scalar_float('On_Power_Rms'),
-			ArgStruct.scalar_float('On_Power_Peak'),
-			ArgStruct.scalar_float('Off_Power_After')]
+			ArgStruct.scalar_float_ext('Off_Power_Before'),
+			ArgStruct.scalar_float_ext('On_Power_Rms'),
+			ArgStruct.scalar_float_ext('On_Power_Peak'),
+			ArgStruct.scalar_float_ext('Off_Power_After')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tolerance: int = None
-			self.Off_Power_Before: float = None
-			self.On_Power_Rms: float = None
-			self.On_Power_Peak: float = None
-			self.Off_Power_After: float = None
+			self.Off_Power_Before: float or bool = None
+			self.On_Power_Rms: float or bool = None
+			self.On_Power_Peak: float or bool = None
+			self.Off_Power_After: float or bool = None
 
 	def calculate(self) -> CalculateStruct:
 		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:PDYNamics:CURRent \n
-		Snippet: value: CalculateStruct = driver.multiEval.pdynamics.current.calculate() \n
-		Return the current, average, minimum, maximum and standard deviation single value results of the power dynamics
+		Snippet: value: CalculateStruct = driver.lteMeas.multiEval.pdynamics.current.calculate() \n
+		Return the current, average, minimum, maximum and standard deviation single-value results of the power dynamics
 		measurement. A single result table row is returned, from left to right. The meaning of the values depends on the selected
 		time mask, as follows:
-			Table Header: Time mask / Power1 / Power2 / Power3 / Power4 \n
+			Table Header: Time mask / <Power1> / <Power2> / <Power3> / <Power4> \n
 			- General on / off / OFF power (before) / ON power RMS / ON power peak / OFF power (after)
 			- PUCCH / PUSCH / SRS / SRS ON / ON power RMS / ON power peak / ON power (after)
 			- SRS blanking / SRS OFF / ON power RMS / ON power peak / ON power (after)
 		The values described below are returned by FETCh and READ commands. CALCulate commands return limit check results instead,
 		one value for each result listed below. \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
 		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:PDYNamics:CURRent?', self.__class__.CalculateStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Pdynamics_/Maximum.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Pdynamics/Average.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,26 +1,26 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
-from ....Internal.StructBase import StructBase
-from ....Internal.ArgStruct import ArgStruct
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
+from .....Internal.StructBase import StructBase
+from .....Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Maximum:
-	"""Maximum commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class AverageCls:
+	"""Average commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("maximum", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Out_Of_Tolerance: int: Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for power measurements exceeding the specified power limits.
+			- Reliability: int: 'Reliability indicator'
+			- Out_Of_Tolerance: int: Out of tolerance result, i.e. the percentage of measurement intervals of the statistic count for power measurements exceeding the specified power limits.
 			- Off_Power_Before: float: No parameter help available
 			- On_Power_Rms: float: No parameter help available
 			- On_Power_Peak: float: No parameter help available
 			- Off_Power_After: float: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
@@ -35,76 +35,76 @@
 			self.Out_Of_Tolerance: int = None
 			self.Off_Power_Before: float = None
 			self.On_Power_Rms: float = None
 			self.On_Power_Peak: float = None
 			self.Off_Power_After: float = None
 
 	def read(self) -> ResultData:
-		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:PDYNamics:MAXimum \n
-		Snippet: value: ResultData = driver.multiEval.pdynamics.maximum.read() \n
-		Return the current, average, minimum, maximum and standard deviation single value results of the power dynamics
+		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:PDYNamics:AVERage \n
+		Snippet: value: ResultData = driver.lteMeas.multiEval.pdynamics.average.read() \n
+		Return the current, average, minimum, maximum and standard deviation single-value results of the power dynamics
 		measurement. A single result table row is returned, from left to right. The meaning of the values depends on the selected
 		time mask, as follows:
-			Table Header: Time mask / Power1 / Power2 / Power3 / Power4 \n
+			Table Header: Time mask / <Power1> / <Power2> / <Power3> / <Power4> \n
 			- General on / off / OFF power (before) / ON power RMS / ON power peak / OFF power (after)
 			- PUCCH / PUSCH / SRS / SRS ON / ON power RMS / ON power peak / ON power (after)
 			- SRS blanking / SRS OFF / ON power RMS / ON power peak / ON power (after)
 		The values described below are returned by FETCh and READ commands. CALCulate commands return limit check results instead,
 		one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:PDYNamics:MAXimum?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:PDYNamics:AVERage?', self.__class__.ResultData())
 
 	def fetch(self) -> ResultData:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:PDYNamics:MAXimum \n
-		Snippet: value: ResultData = driver.multiEval.pdynamics.maximum.fetch() \n
-		Return the current, average, minimum, maximum and standard deviation single value results of the power dynamics
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:PDYNamics:AVERage \n
+		Snippet: value: ResultData = driver.lteMeas.multiEval.pdynamics.average.fetch() \n
+		Return the current, average, minimum, maximum and standard deviation single-value results of the power dynamics
 		measurement. A single result table row is returned, from left to right. The meaning of the values depends on the selected
 		time mask, as follows:
-			Table Header: Time mask / Power1 / Power2 / Power3 / Power4 \n
+			Table Header: Time mask / <Power1> / <Power2> / <Power3> / <Power4> \n
 			- General on / off / OFF power (before) / ON power RMS / ON power peak / OFF power (after)
 			- PUCCH / PUSCH / SRS / SRS ON / ON power RMS / ON power peak / ON power (after)
 			- SRS blanking / SRS OFF / ON power RMS / ON power peak / ON power (after)
 		The values described below are returned by FETCh and READ commands. CALCulate commands return limit check results instead,
 		one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:PDYNamics:MAXimum?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:PDYNamics:AVERage?', self.__class__.ResultData())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Out_Of_Tolerance: int: Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for power measurements exceeding the specified power limits.
-			- Off_Power_Before: float: No parameter help available
-			- On_Power_Rms: float: No parameter help available
-			- On_Power_Peak: float: No parameter help available
-			- Off_Power_After: float: No parameter help available"""
+			- Reliability: int: 'Reliability indicator'
+			- Out_Of_Tolerance: int: Out of tolerance result, i.e. the percentage of measurement intervals of the statistic count for power measurements exceeding the specified power limits.
+			- Off_Power_Before: float or bool: No parameter help available
+			- On_Power_Rms: float or bool: No parameter help available
+			- On_Power_Peak: float or bool: No parameter help available
+			- Off_Power_After: float or bool: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
-			ArgStruct.scalar_float('Off_Power_Before'),
-			ArgStruct.scalar_float('On_Power_Rms'),
-			ArgStruct.scalar_float('On_Power_Peak'),
-			ArgStruct.scalar_float('Off_Power_After')]
+			ArgStruct.scalar_float_ext('Off_Power_Before'),
+			ArgStruct.scalar_float_ext('On_Power_Rms'),
+			ArgStruct.scalar_float_ext('On_Power_Peak'),
+			ArgStruct.scalar_float_ext('Off_Power_After')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tolerance: int = None
-			self.Off_Power_Before: float = None
-			self.On_Power_Rms: float = None
-			self.On_Power_Peak: float = None
-			self.Off_Power_After: float = None
+			self.Off_Power_Before: float or bool = None
+			self.On_Power_Rms: float or bool = None
+			self.On_Power_Peak: float or bool = None
+			self.Off_Power_After: float or bool = None
 
 	def calculate(self) -> CalculateStruct:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:PDYNamics:MAXimum \n
-		Snippet: value: CalculateStruct = driver.multiEval.pdynamics.maximum.calculate() \n
-		Return the current, average, minimum, maximum and standard deviation single value results of the power dynamics
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:PDYNamics:AVERage \n
+		Snippet: value: CalculateStruct = driver.lteMeas.multiEval.pdynamics.average.calculate() \n
+		Return the current, average, minimum, maximum and standard deviation single-value results of the power dynamics
 		measurement. A single result table row is returned, from left to right. The meaning of the values depends on the selected
 		time mask, as follows:
-			Table Header: Time mask / Power1 / Power2 / Power3 / Power4 \n
+			Table Header: Time mask / <Power1> / <Power2> / <Power3> / <Power4> \n
 			- General on / off / OFF power (before) / ON power RMS / ON power peak / OFF power (after)
 			- PUCCH / PUSCH / SRS / SRS ON / ON power RMS / ON power peak / ON power (after)
 			- SRS blanking / SRS OFF / ON power RMS / ON power peak / ON power (after)
 		The values described below are returned by FETCh and READ commands. CALCulate commands return limit check results instead,
 		one value for each result listed below. \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:PDYNamics:MAXimum?', self.__class__.CalculateStruct())
+		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:PDYNamics:AVERage?', self.__class__.CalculateStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Pdynamics_/Minimum.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Pdynamics/StandardDev.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,26 +1,26 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
-from ....Internal.StructBase import StructBase
-from ....Internal.ArgStruct import ArgStruct
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
+from .....Internal.StructBase import StructBase
+from .....Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Minimum:
-	"""Minimum commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class StandardDevCls:
+	"""StandardDev commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("minimum", core, parent)
+		self._cmd_group = CommandsGroup("standardDev", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Out_Of_Tolerance: int: Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for power measurements exceeding the specified power limits.
+			- Reliability: int: 'Reliability indicator'
+			- Out_Of_Tolerance: int: Out of tolerance result, i.e. the percentage of measurement intervals of the statistic count for power measurements exceeding the specified power limits.
 			- Off_Power_Before: float: No parameter help available
 			- On_Power_Rms: float: No parameter help available
 			- On_Power_Peak: float: No parameter help available
 			- Off_Power_After: float: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
@@ -35,76 +35,68 @@
 			self.Out_Of_Tolerance: int = None
 			self.Off_Power_Before: float = None
 			self.On_Power_Rms: float = None
 			self.On_Power_Peak: float = None
 			self.Off_Power_After: float = None
 
 	def read(self) -> ResultData:
-		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:PDYNamics:MINimum \n
-		Snippet: value: ResultData = driver.multiEval.pdynamics.minimum.read() \n
-		Return the current, average, minimum, maximum and standard deviation single value results of the power dynamics
+		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:PDYNamics:SDEViation \n
+		Snippet: value: ResultData = driver.lteMeas.multiEval.pdynamics.standardDev.read() \n
+		Return the current, average, minimum, maximum and standard deviation single-value results of the power dynamics
 		measurement. A single result table row is returned, from left to right. The meaning of the values depends on the selected
 		time mask, as follows:
-			Table Header: Time mask / Power1 / Power2 / Power3 / Power4 \n
+			Table Header: Time mask / <Power1> / <Power2> / <Power3> / <Power4> \n
 			- General on / off / OFF power (before) / ON power RMS / ON power peak / OFF power (after)
 			- PUCCH / PUSCH / SRS / SRS ON / ON power RMS / ON power peak / ON power (after)
 			- SRS blanking / SRS OFF / ON power RMS / ON power peak / ON power (after)
 		The values described below are returned by FETCh and READ commands. CALCulate commands return limit check results instead,
 		one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:PDYNamics:MINimum?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:PDYNamics:SDEViation?', self.__class__.ResultData())
 
 	def fetch(self) -> ResultData:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:PDYNamics:MINimum \n
-		Snippet: value: ResultData = driver.multiEval.pdynamics.minimum.fetch() \n
-		Return the current, average, minimum, maximum and standard deviation single value results of the power dynamics
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:PDYNamics:SDEViation \n
+		Snippet: value: ResultData = driver.lteMeas.multiEval.pdynamics.standardDev.fetch() \n
+		Return the current, average, minimum, maximum and standard deviation single-value results of the power dynamics
 		measurement. A single result table row is returned, from left to right. The meaning of the values depends on the selected
 		time mask, as follows:
-			Table Header: Time mask / Power1 / Power2 / Power3 / Power4 \n
+			Table Header: Time mask / <Power1> / <Power2> / <Power3> / <Power4> \n
 			- General on / off / OFF power (before) / ON power RMS / ON power peak / OFF power (after)
 			- PUCCH / PUSCH / SRS / SRS ON / ON power RMS / ON power peak / ON power (after)
 			- SRS blanking / SRS OFF / ON power RMS / ON power peak / ON power (after)
 		The values described below are returned by FETCh and READ commands. CALCulate commands return limit check results instead,
 		one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:PDYNamics:MINimum?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:PDYNamics:SDEViation?', self.__class__.ResultData())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Out_Of_Tolerance: int: Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for power measurements exceeding the specified power limits.
-			- Off_Power_Before: float: No parameter help available
-			- On_Power_Rms: float: No parameter help available
-			- On_Power_Peak: float: No parameter help available
-			- Off_Power_After: float: No parameter help available"""
+			- Reliability: int: No parameter help available
+			- Out_Of_Tolerance: int: No parameter help available
+			- Off_Power_Before: float or bool: No parameter help available
+			- On_Power_Rms: float or bool: No parameter help available
+			- On_Power_Peak: float or bool: No parameter help available
+			- Off_Power_After: float or bool: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
-			ArgStruct.scalar_float('Off_Power_Before'),
-			ArgStruct.scalar_float('On_Power_Rms'),
-			ArgStruct.scalar_float('On_Power_Peak'),
-			ArgStruct.scalar_float('Off_Power_After')]
+			ArgStruct.scalar_float_ext('Off_Power_Before'),
+			ArgStruct.scalar_float_ext('On_Power_Rms'),
+			ArgStruct.scalar_float_ext('On_Power_Peak'),
+			ArgStruct.scalar_float_ext('Off_Power_After')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tolerance: int = None
-			self.Off_Power_Before: float = None
-			self.On_Power_Rms: float = None
-			self.On_Power_Peak: float = None
-			self.Off_Power_After: float = None
+			self.Off_Power_Before: float or bool = None
+			self.On_Power_Rms: float or bool = None
+			self.On_Power_Peak: float or bool = None
+			self.Off_Power_After: float or bool = None
 
 	def calculate(self) -> CalculateStruct:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:PDYNamics:MINimum \n
-		Snippet: value: CalculateStruct = driver.multiEval.pdynamics.minimum.calculate() \n
-		Return the current, average, minimum, maximum and standard deviation single value results of the power dynamics
-		measurement. A single result table row is returned, from left to right. The meaning of the values depends on the selected
-		time mask, as follows:
-			Table Header: Time mask / Power1 / Power2 / Power3 / Power4 \n
-			- General on / off / OFF power (before) / ON power RMS / ON power peak / OFF power (after)
-			- PUCCH / PUSCH / SRS / SRS ON / ON power RMS / ON power peak / ON power (after)
-			- SRS blanking / SRS OFF / ON power RMS / ON power peak / ON power (after)
-		The values described below are returned by FETCh and READ commands. CALCulate commands return limit check results instead,
-		one value for each result listed below. \n
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:PDYNamics:SDEViation \n
+		Snippet: value: CalculateStruct = driver.lteMeas.multiEval.pdynamics.standardDev.calculate() \n
+		No command help available \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:PDYNamics:MINimum?', self.__class__.CalculateStruct())
+		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:PDYNamics:SDEViation?', self.__class__.CalculateStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Pdynamics_/StandardDev.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/Prach/Pdynamics/Current.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,30 +1,30 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
-from ....Internal.StructBase import StructBase
-from ....Internal.ArgStruct import ArgStruct
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
+from .....Internal.StructBase import StructBase
+from .....Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class StandardDev:
-	"""StandardDev commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("standardDev", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Out_Of_Tolerance: int: Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for power measurements exceeding the specified power limits.
-			- Off_Power_Before: float: No parameter help available
-			- On_Power_Rms: float: No parameter help available
-			- On_Power_Peak: float: No parameter help available
-			- Off_Power_After: float: No parameter help available"""
+			- Reliability: int: 'Reliability indicator'
+			- Out_Of_Tolerance: int: Out of tolerance result, i.e. the percentage of measurement intervals of the statistic count for power dynamics measurements exceeding the specified power dynamics limits.
+			- Off_Power_Before: float: OFF power mean value for subframe before preamble without transient period.
+			- On_Power_Rms: float: ON power mean value over preamble.
+			- On_Power_Peak: float: ON power peak value within preamble.
+			- Off_Power_After: float: OFF power mean value for subframe after preamble without transient period."""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
 			ArgStruct.scalar_float('Off_Power_Before'),
 			ArgStruct.scalar_float('On_Power_Rms'),
 			ArgStruct.scalar_float('On_Power_Peak'),
 			ArgStruct.scalar_float('Off_Power_After')]
@@ -35,68 +35,58 @@
 			self.Out_Of_Tolerance: int = None
 			self.Off_Power_Before: float = None
 			self.On_Power_Rms: float = None
 			self.On_Power_Peak: float = None
 			self.Off_Power_After: float = None
 
 	def read(self) -> ResultData:
-		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:PDYNamics:SDEViation \n
-		Snippet: value: ResultData = driver.multiEval.pdynamics.standardDev.read() \n
-		Return the current, average, minimum, maximum and standard deviation single value results of the power dynamics
-		measurement. A single result table row is returned, from left to right. The meaning of the values depends on the selected
-		time mask, as follows:
-			Table Header: Time mask / Power1 / Power2 / Power3 / Power4 \n
-			- General on / off / OFF power (before) / ON power RMS / ON power peak / OFF power (after)
-			- PUCCH / PUSCH / SRS / SRS ON / ON power RMS / ON power peak / ON power (after)
-			- SRS blanking / SRS OFF / ON power RMS / ON power peak / ON power (after)
-		The values described below are returned by FETCh and READ commands. CALCulate commands return limit check results instead,
-		one value for each result listed below. \n
+		"""SCPI: READ:LTE:MEASurement<Instance>:PRACh:PDYNamics:CURRent \n
+		Snippet: value: ResultData = driver.lteMeas.prach.pdynamics.current.read() \n
+		Return the current, average, minimum, maximum and standard deviation single-value results of the power dynamics
+		measurement. The values described below are returned by FETCh and READ commands. CALCulate commands return limit check
+		results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:PDYNamics:SDEViation?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:PRACh:PDYNamics:CURRent?', self.__class__.ResultData())
 
 	def fetch(self) -> ResultData:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:PDYNamics:SDEViation \n
-		Snippet: value: ResultData = driver.multiEval.pdynamics.standardDev.fetch() \n
-		Return the current, average, minimum, maximum and standard deviation single value results of the power dynamics
-		measurement. A single result table row is returned, from left to right. The meaning of the values depends on the selected
-		time mask, as follows:
-			Table Header: Time mask / Power1 / Power2 / Power3 / Power4 \n
-			- General on / off / OFF power (before) / ON power RMS / ON power peak / OFF power (after)
-			- PUCCH / PUSCH / SRS / SRS ON / ON power RMS / ON power peak / ON power (after)
-			- SRS blanking / SRS OFF / ON power RMS / ON power peak / ON power (after)
-		The values described below are returned by FETCh and READ commands. CALCulate commands return limit check results instead,
-		one value for each result listed below. \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:PRACh:PDYNamics:CURRent \n
+		Snippet: value: ResultData = driver.lteMeas.prach.pdynamics.current.fetch() \n
+		Return the current, average, minimum, maximum and standard deviation single-value results of the power dynamics
+		measurement. The values described below are returned by FETCh and READ commands. CALCulate commands return limit check
+		results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:PDYNamics:SDEViation?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:PRACh:PDYNamics:CURRent?', self.__class__.ResultData())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: No parameter help available
-			- Out_Of_Tolerance: int: No parameter help available
-			- Off_Power_Before: float: No parameter help available
-			- On_Power_Rms: float: No parameter help available
-			- On_Power_Peak: float: No parameter help available
-			- Off_Power_After: float: No parameter help available"""
+			- Reliability: int: 'Reliability indicator'
+			- Out_Of_Tolerance: int: Out of tolerance result, i.e. the percentage of measurement intervals of the statistic count for power dynamics measurements exceeding the specified power dynamics limits.
+			- Off_Power_Before: float or bool: OFF power mean value for subframe before preamble without transient period.
+			- On_Power_Rms: float or bool: ON power mean value over preamble.
+			- On_Power_Peak: float or bool: ON power peak value within preamble.
+			- Off_Power_After: float or bool: OFF power mean value for subframe after preamble without transient period."""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
-			ArgStruct.scalar_float('Off_Power_Before'),
-			ArgStruct.scalar_float('On_Power_Rms'),
-			ArgStruct.scalar_float('On_Power_Peak'),
-			ArgStruct.scalar_float('Off_Power_After')]
+			ArgStruct.scalar_float_ext('Off_Power_Before'),
+			ArgStruct.scalar_float_ext('On_Power_Rms'),
+			ArgStruct.scalar_float_ext('On_Power_Peak'),
+			ArgStruct.scalar_float_ext('Off_Power_After')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tolerance: int = None
-			self.Off_Power_Before: float = None
-			self.On_Power_Rms: float = None
-			self.On_Power_Peak: float = None
-			self.Off_Power_After: float = None
+			self.Off_Power_Before: float or bool = None
+			self.On_Power_Rms: float or bool = None
+			self.On_Power_Peak: float or bool = None
+			self.Off_Power_After: float or bool = None
 
 	def calculate(self) -> CalculateStruct:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:PDYNamics:SDEViation \n
-		Snippet: value: CalculateStruct = driver.multiEval.pdynamics.standardDev.calculate() \n
-		No command help available \n
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:PRACh:PDYNamics:CURRent \n
+		Snippet: value: CalculateStruct = driver.lteMeas.prach.pdynamics.current.calculate() \n
+		Return the current, average, minimum, maximum and standard deviation single-value results of the power dynamics
+		measurement. The values described below are returned by FETCh and READ commands. CALCulate commands return limit check
+		results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:PDYNamics:SDEViation?', self.__class__.CalculateStruct())
+		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:PRACh:PDYNamics:CURRent?', self.__class__.CalculateStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Perror.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Tpower/__init__.py`

 * *Files 23% similar despite different names*

```diff
@@ -1,43 +1,59 @@
-from ...Internal.Core import Core
-from ...Internal.CommandsGroup import CommandsGroup
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Perror:
-	"""Perror commands group definition. 15 total commands, 3 Sub-groups, 0 group commands"""
+class TpowerCls:
+	"""Tpower commands group definition. 9 total commands, 5 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("perror", core, parent)
+		self._cmd_group = CommandsGroup("tpower", core, parent)
 
 	@property
 	def current(self):
-		"""current commands group. 1 Sub-classes, 3 commands."""
+		"""current commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_current'):
-			from .Perror_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
 	@property
 	def average(self):
-		"""average commands group. 1 Sub-classes, 3 commands."""
+		"""average commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_average'):
-			from .Perror_.Average import Average
-			self._average = Average(self._core, self._base)
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
 		return self._average
 
 	@property
+	def minimum(self):
+		"""minimum commands group. 0 Sub-classes, 2 commands."""
+		if not hasattr(self, '_minimum'):
+			from .Minimum import MinimumCls
+			self._minimum = MinimumCls(self._core, self._cmd_group)
+		return self._minimum
+
+	@property
 	def maximum(self):
-		"""maximum commands group. 1 Sub-classes, 3 commands."""
+		"""maximum commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_maximum'):
-			from .Perror_.Maximum import Maximum
-			self._maximum = Maximum(self._core, self._base)
+			from .Maximum import MaximumCls
+			self._maximum = MaximumCls(self._core, self._cmd_group)
 		return self._maximum
 
-	def clone(self) -> 'Perror':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	@property
+	def standardDev(self):
+		"""standardDev commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_standardDev'):
+			from .StandardDev import StandardDevCls
+			self._standardDev = StandardDevCls(self._core, self._cmd_group)
+		return self._standardDev
+
+	def clone(self) -> 'TpowerCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Perror(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = TpowerCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Perror_/Average.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Perror/Average/__init__.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,37 +1,37 @@
 from typing import List
 
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
-from ....Internal.Types import DataType
-from ....Internal.StructBase import StructBase
-from ....Internal.ArgStruct import ArgStruct
-from .... import enums
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal.Types import DataType
+from ......Internal.StructBase import StructBase
+from ......Internal.ArgStruct import ArgStruct
+from ...... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 5 total commands, 1 Sub-groups, 3 group commands"""
+class AverageCls:
+	"""Average commands group definition. 5 total commands, 1 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	@property
 	def nref(self):
 		"""nref commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_nref'):
-			from .Average_.Nref import Nref
-			self._nref = Nref(self._core, self._base)
+			from .Nref import NrefCls
+			self._nref = NrefCls(self._core, self._cmd_group)
 		return self._nref
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
+			- Reliability: int: 'Reliability indicator'
 			- Low: List[float]: Phase error value for low EVM window position
 			- High: List[float]: Phase error value for high EVM window position"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct('Low', DataType.FloatList, None, False, True, 1),
 			ArgStruct('High', DataType.FloatList, None, False, True, 1)]
 
@@ -39,27 +39,27 @@
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Low: List[float] = None
 			self.High: List[float] = None
 
 	def read(self) -> ResultData:
 		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:PERRor:AVERage \n
-		Snippet: value: ResultData = driver.multiEval.perror.average.read() \n
-		Returns the values of the phase error bar graphs for the SC-FDMA symbols in the measured slot. The results of the current,
-		average and maximum bar graphs can be retrieved. There is one pair of phase error values per SC-FDMA symbol, returned in
+		Snippet: value: ResultData = driver.lteMeas.multiEval.perror.average.read() \n
+		Returns the values of the phase error diagrams for the SC-FDMA symbols in the measured slot. The results of the current,
+		average and maximum diagrams can be retrieved. There is one pair of phase error values per SC-FDMA symbol, returned in
 		the following order: <Reliability>, {<Low>, <High>}symbol 0, {<Low>, <High>}symbol 1, ... See also 'Square Magnitude
 		Error, Phase Error'. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
 		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:PERRor:AVERage?', self.__class__.ResultData())
 
 	def fetch(self) -> ResultData:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:PERRor:AVERage \n
-		Snippet: value: ResultData = driver.multiEval.perror.average.fetch() \n
-		Returns the values of the phase error bar graphs for the SC-FDMA symbols in the measured slot. The results of the current,
-		average and maximum bar graphs can be retrieved. There is one pair of phase error values per SC-FDMA symbol, returned in
+		Snippet: value: ResultData = driver.lteMeas.multiEval.perror.average.fetch() \n
+		Returns the values of the phase error diagrams for the SC-FDMA symbols in the measured slot. The results of the current,
+		average and maximum diagrams can be retrieved. There is one pair of phase error values per SC-FDMA symbol, returned in
 		the following order: <Reliability>, {<Low>, <High>}symbol 0, {<Low>, <High>}symbol 1, ... See also 'Square Magnitude
 		Error, Phase Error'. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
 		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:PERRor:AVERage?', self.__class__.ResultData())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
@@ -76,19 +76,19 @@
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Low: List[enums.ResultStatus2] = None
 			self.High: List[enums.ResultStatus2] = None
 
 	def calculate(self) -> CalculateStruct:
 		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:PERRor:AVERage \n
-		Snippet: value: CalculateStruct = driver.multiEval.perror.average.calculate() \n
+		Snippet: value: CalculateStruct = driver.lteMeas.multiEval.perror.average.calculate() \n
 		No command help available \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
 		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:PERRor:AVERage?', self.__class__.CalculateStruct())
 
-	def clone(self) -> 'Average':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'AverageCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Average(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = AverageCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Perror_/Average_/Nref.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/EvMagnitude/Current/Nref.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,20 +1,20 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
-from .....Internal.StructBase import StructBase
-from .....Internal.ArgStruct import ArgStruct
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal.StructBase import StructBase
+from ......Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Nref:
-	"""Nref commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class NrefCls:
+	"""Nref commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("nref", core, parent)
+		self._cmd_group = CommandsGroup("nref", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
 			- Reliability: int: No parameter help available
 			- Sym_1_L: float: No parameter help available
 			- Sym_1_H: float: No parameter help available
@@ -56,19 +56,19 @@
 			self.Sym_5_H: float = None
 			self.Sym_6_L: float = None
 			self.Sym_6_H: float = None
 			self.Sym_7_L: float = None
 			self.Sym_7_H: float = None
 
 	def read(self) -> ResultData:
-		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:PERRor:AVERage:NREF \n
-		Snippet: value: ResultData = driver.multiEval.perror.average.nref.read() \n
+		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:EVMagnitude:CURRent:NREF \n
+		Snippet: value: ResultData = driver.lteMeas.multiEval.evMagnitude.current.nref.read() \n
 		No command help available \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:PERRor:AVERage:NREF?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:EVMagnitude:CURRent:NREF?', self.__class__.ResultData())
 
 	def fetch(self) -> ResultData:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:PERRor:AVERage:NREF \n
-		Snippet: value: ResultData = driver.multiEval.perror.average.nref.fetch() \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:EVMagnitude:CURRent:NREF \n
+		Snippet: value: ResultData = driver.lteMeas.multiEval.evMagnitude.current.nref.fetch() \n
 		No command help available \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:PERRor:AVERage:NREF?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:EVMagnitude:CURRent:NREF?', self.__class__.ResultData())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Perror_/Current.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Perror/Current/__init__.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,37 +1,37 @@
 from typing import List
 
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
-from ....Internal.Types import DataType
-from ....Internal.StructBase import StructBase
-from ....Internal.ArgStruct import ArgStruct
-from .... import enums
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal.Types import DataType
+from ......Internal.StructBase import StructBase
+from ......Internal.ArgStruct import ArgStruct
+from ...... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 5 total commands, 1 Sub-groups, 3 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 5 total commands, 1 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	@property
 	def nref(self):
 		"""nref commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_nref'):
-			from .Current_.Nref import Nref
-			self._nref = Nref(self._core, self._base)
+			from .Nref import NrefCls
+			self._nref = NrefCls(self._core, self._cmd_group)
 		return self._nref
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
+			- Reliability: int: 'Reliability indicator'
 			- Low: List[float]: Phase error value for low EVM window position
 			- High: List[float]: Phase error value for high EVM window position"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct('Low', DataType.FloatList, None, False, True, 1),
 			ArgStruct('High', DataType.FloatList, None, False, True, 1)]
 
@@ -39,27 +39,27 @@
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Low: List[float] = None
 			self.High: List[float] = None
 
 	def read(self) -> ResultData:
 		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:PERRor:CURRent \n
-		Snippet: value: ResultData = driver.multiEval.perror.current.read() \n
-		Returns the values of the phase error bar graphs for the SC-FDMA symbols in the measured slot. The results of the current,
-		average and maximum bar graphs can be retrieved. There is one pair of phase error values per SC-FDMA symbol, returned in
+		Snippet: value: ResultData = driver.lteMeas.multiEval.perror.current.read() \n
+		Returns the values of the phase error diagrams for the SC-FDMA symbols in the measured slot. The results of the current,
+		average and maximum diagrams can be retrieved. There is one pair of phase error values per SC-FDMA symbol, returned in
 		the following order: <Reliability>, {<Low>, <High>}symbol 0, {<Low>, <High>}symbol 1, ... See also 'Square Magnitude
 		Error, Phase Error'. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
 		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:PERRor:CURRent?', self.__class__.ResultData())
 
 	def fetch(self) -> ResultData:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:PERRor:CURRent \n
-		Snippet: value: ResultData = driver.multiEval.perror.current.fetch() \n
-		Returns the values of the phase error bar graphs for the SC-FDMA symbols in the measured slot. The results of the current,
-		average and maximum bar graphs can be retrieved. There is one pair of phase error values per SC-FDMA symbol, returned in
+		Snippet: value: ResultData = driver.lteMeas.multiEval.perror.current.fetch() \n
+		Returns the values of the phase error diagrams for the SC-FDMA symbols in the measured slot. The results of the current,
+		average and maximum diagrams can be retrieved. There is one pair of phase error values per SC-FDMA symbol, returned in
 		the following order: <Reliability>, {<Low>, <High>}symbol 0, {<Low>, <High>}symbol 1, ... See also 'Square Magnitude
 		Error, Phase Error'. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
 		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:PERRor:CURRent?', self.__class__.ResultData())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
@@ -76,19 +76,19 @@
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Low: List[enums.ResultStatus2] = None
 			self.High: List[enums.ResultStatus2] = None
 
 	def calculate(self) -> CalculateStruct:
 		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:PERRor:CURRent \n
-		Snippet: value: CalculateStruct = driver.multiEval.perror.current.calculate() \n
+		Snippet: value: CalculateStruct = driver.lteMeas.multiEval.perror.current.calculate() \n
 		No command help available \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
 		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:PERRor:CURRent?', self.__class__.CalculateStruct())
 
-	def clone(self) -> 'Current':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'CurrentCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Current(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = CurrentCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Perror_/Current_/Nref.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/EvMagnitude/Maximum/Nref.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,20 +1,20 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
-from .....Internal.StructBase import StructBase
-from .....Internal.ArgStruct import ArgStruct
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal.StructBase import StructBase
+from ......Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Nref:
-	"""Nref commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class NrefCls:
+	"""Nref commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("nref", core, parent)
+		self._cmd_group = CommandsGroup("nref", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
 			- Reliability: int: No parameter help available
 			- Sym_1_L: float: No parameter help available
 			- Sym_1_H: float: No parameter help available
@@ -56,19 +56,19 @@
 			self.Sym_5_H: float = None
 			self.Sym_6_L: float = None
 			self.Sym_6_H: float = None
 			self.Sym_7_L: float = None
 			self.Sym_7_H: float = None
 
 	def read(self) -> ResultData:
-		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:PERRor:CURRent:NREF \n
-		Snippet: value: ResultData = driver.multiEval.perror.current.nref.read() \n
+		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:EVMagnitude:MAXimum:NREF \n
+		Snippet: value: ResultData = driver.lteMeas.multiEval.evMagnitude.maximum.nref.read() \n
 		No command help available \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:PERRor:CURRent:NREF?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:EVMagnitude:MAXimum:NREF?', self.__class__.ResultData())
 
 	def fetch(self) -> ResultData:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:PERRor:CURRent:NREF \n
-		Snippet: value: ResultData = driver.multiEval.perror.current.nref.fetch() \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:EVMagnitude:MAXimum:NREF \n
+		Snippet: value: ResultData = driver.lteMeas.multiEval.evMagnitude.maximum.nref.fetch() \n
 		No command help available \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:PERRor:CURRent:NREF?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:EVMagnitude:MAXimum:NREF?', self.__class__.ResultData())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Perror_/Maximum.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Merror/Maximum/__init__.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,69 +1,69 @@
 from typing import List
 
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
-from ....Internal.Types import DataType
-from ....Internal.StructBase import StructBase
-from ....Internal.ArgStruct import ArgStruct
-from .... import enums
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal.Types import DataType
+from ......Internal.StructBase import StructBase
+from ......Internal.ArgStruct import ArgStruct
+from ...... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Maximum:
-	"""Maximum commands group definition. 5 total commands, 1 Sub-groups, 3 group commands"""
+class MaximumCls:
+	"""Maximum commands group definition. 5 total commands, 1 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("maximum", core, parent)
+		self._cmd_group = CommandsGroup("maximum", core, parent)
 
 	@property
 	def nref(self):
 		"""nref commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_nref'):
-			from .Maximum_.Nref import Nref
-			self._nref = Nref(self._core, self._base)
+			from .Nref import NrefCls
+			self._nref = NrefCls(self._core, self._cmd_group)
 		return self._nref
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Low: List[float]: Phase error value for low EVM window position
-			- High: List[float]: Phase error value for high EVM window position"""
+			- Reliability: int: 'Reliability indicator'
+			- Low: List[float]: Magnitude error value for low EVM window position
+			- High: List[float]: Magnitude error value for high EVM window position"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct('Low', DataType.FloatList, None, False, True, 1),
 			ArgStruct('High', DataType.FloatList, None, False, True, 1)]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Low: List[float] = None
 			self.High: List[float] = None
 
 	def read(self) -> ResultData:
-		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:PERRor:MAXimum \n
-		Snippet: value: ResultData = driver.multiEval.perror.maximum.read() \n
-		Returns the values of the phase error bar graphs for the SC-FDMA symbols in the measured slot. The results of the current,
-		average and maximum bar graphs can be retrieved. There is one pair of phase error values per SC-FDMA symbol, returned in
-		the following order: <Reliability>, {<Low>, <High>}symbol 0, {<Low>, <High>}symbol 1, ... See also 'Square Magnitude
-		Error, Phase Error'. \n
+		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:MERRor:MAXimum \n
+		Snippet: value: ResultData = driver.lteMeas.multiEval.merror.maximum.read() \n
+		Returns the values of the magnitude error diagrams for the SC-FDMA symbols in the measured slot. The results of the
+		current, average and maximum diagrams can be retrieved. There is one pair of magnitude error values per SC-FDMA symbol,
+		returned in the following order: <Reliability>, {<Low>, <High>}symbol 0, {<Low>, <High>}symbol 1, ... See also 'Square
+		Magnitude Error, Phase Error'. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:PERRor:MAXimum?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:MERRor:MAXimum?', self.__class__.ResultData())
 
 	def fetch(self) -> ResultData:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:PERRor:MAXimum \n
-		Snippet: value: ResultData = driver.multiEval.perror.maximum.fetch() \n
-		Returns the values of the phase error bar graphs for the SC-FDMA symbols in the measured slot. The results of the current,
-		average and maximum bar graphs can be retrieved. There is one pair of phase error values per SC-FDMA symbol, returned in
-		the following order: <Reliability>, {<Low>, <High>}symbol 0, {<Low>, <High>}symbol 1, ... See also 'Square Magnitude
-		Error, Phase Error'. \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:MERRor:MAXimum \n
+		Snippet: value: ResultData = driver.lteMeas.multiEval.merror.maximum.fetch() \n
+		Returns the values of the magnitude error diagrams for the SC-FDMA symbols in the measured slot. The results of the
+		current, average and maximum diagrams can be retrieved. There is one pair of magnitude error values per SC-FDMA symbol,
+		returned in the following order: <Reliability>, {<Low>, <High>}symbol 0, {<Low>, <High>}symbol 1, ... See also 'Square
+		Magnitude Error, Phase Error'. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:PERRor:MAXimum?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:MERRor:MAXimum?', self.__class__.ResultData())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
 			- Reliability: int: No parameter help available
 			- Low: List[enums.ResultStatus2]: No parameter help available
 			- High: List[enums.ResultStatus2]: No parameter help available"""
@@ -75,20 +75,20 @@
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Low: List[enums.ResultStatus2] = None
 			self.High: List[enums.ResultStatus2] = None
 
 	def calculate(self) -> CalculateStruct:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:PERRor:MAXimum \n
-		Snippet: value: CalculateStruct = driver.multiEval.perror.maximum.calculate() \n
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:MERRor:MAXimum \n
+		Snippet: value: CalculateStruct = driver.lteMeas.multiEval.merror.maximum.calculate() \n
 		No command help available \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:PERRor:MAXimum?', self.__class__.CalculateStruct())
+		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:MERRor:MAXimum?', self.__class__.CalculateStruct())
 
-	def clone(self) -> 'Maximum':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'MaximumCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Maximum(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = MaximumCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Perror_/Maximum_/Nref.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Perror/Maximum/Nref.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,20 +1,20 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
-from .....Internal.StructBase import StructBase
-from .....Internal.ArgStruct import ArgStruct
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal.StructBase import StructBase
+from ......Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Nref:
-	"""Nref commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class NrefCls:
+	"""Nref commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("nref", core, parent)
+		self._cmd_group = CommandsGroup("nref", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
 			- Reliability: int: No parameter help available
 			- Sym_1_L: float: No parameter help available
 			- Sym_1_H: float: No parameter help available
@@ -57,18 +57,18 @@
 			self.Sym_6_L: float = None
 			self.Sym_6_H: float = None
 			self.Sym_7_L: float = None
 			self.Sym_7_H: float = None
 
 	def read(self) -> ResultData:
 		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:PERRor:MAXimum:NREF \n
-		Snippet: value: ResultData = driver.multiEval.perror.maximum.nref.read() \n
+		Snippet: value: ResultData = driver.lteMeas.multiEval.perror.maximum.nref.read() \n
 		No command help available \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
 		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:PERRor:MAXimum:NREF?', self.__class__.ResultData())
 
 	def fetch(self) -> ResultData:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:PERRor:MAXimum:NREF \n
-		Snippet: value: ResultData = driver.multiEval.perror.maximum.nref.fetch() \n
+		Snippet: value: ResultData = driver.lteMeas.multiEval.perror.maximum.nref.fetch() \n
 		No command help available \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
 		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:PERRor:MAXimum:NREF?', self.__class__.ResultData())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Pmonitor.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Power/TxPower/__init__.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,91 +1,59 @@
-from ...Internal.Core import Core
-from ...Internal.CommandsGroup import CommandsGroup
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Pmonitor:
-	"""Pmonitor commands group definition. 65 total commands, 9 Sub-groups, 0 group commands"""
+class TxPowerCls:
+	"""TxPower commands group definition. 9 total commands, 5 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("pmonitor", core, parent)
-
-	@property
-	def cc(self):
-		"""cc commands group. 5 Sub-classes, 0 commands."""
-		if not hasattr(self, '_cc'):
-			from .Pmonitor_.Cc import Cc
-			self._cc = Cc(self._core, self._base)
-		return self._cc
-
-	@property
-	def scc(self):
-		"""scc commands group. 5 Sub-classes, 0 commands."""
-		if not hasattr(self, '_scc'):
-			from .Pmonitor_.Scc import Scc
-			self._scc = Scc(self._core, self._base)
-		return self._scc
-
-	@property
-	def ulca(self):
-		"""ulca commands group. 2 Sub-classes, 0 commands."""
-		if not hasattr(self, '_ulca'):
-			from .Pmonitor_.Ulca import Ulca
-			self._ulca = Ulca(self._core, self._base)
-		return self._ulca
-
-	@property
-	def pcc(self):
-		"""pcc commands group. 5 Sub-classes, 0 commands."""
-		if not hasattr(self, '_pcc'):
-			from .Pmonitor_.Pcc import Pcc
-			self._pcc = Pcc(self._core, self._base)
-		return self._pcc
+		self._cmd_group = CommandsGroup("txPower", core, parent)
 
 	@property
 	def current(self):
-		"""current commands group. 0 Sub-classes, 3 commands."""
+		"""current commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_current'):
-			from .Pmonitor_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
 	@property
 	def average(self):
-		"""average commands group. 0 Sub-classes, 3 commands."""
+		"""average commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_average'):
-			from .Pmonitor_.Average import Average
-			self._average = Average(self._core, self._base)
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
 		return self._average
 
 	@property
-	def maximum(self):
-		"""maximum commands group. 0 Sub-classes, 3 commands."""
-		if not hasattr(self, '_maximum'):
-			from .Pmonitor_.Maximum import Maximum
-			self._maximum = Maximum(self._core, self._base)
-		return self._maximum
-
-	@property
 	def minimum(self):
-		"""minimum commands group. 0 Sub-classes, 3 commands."""
+		"""minimum commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_minimum'):
-			from .Pmonitor_.Minimum import Minimum
-			self._minimum = Minimum(self._core, self._base)
+			from .Minimum import MinimumCls
+			self._minimum = MinimumCls(self._core, self._cmd_group)
 		return self._minimum
 
 	@property
+	def maximum(self):
+		"""maximum commands group. 0 Sub-classes, 2 commands."""
+		if not hasattr(self, '_maximum'):
+			from .Maximum import MaximumCls
+			self._maximum = MaximumCls(self._core, self._cmd_group)
+		return self._maximum
+
+	@property
 	def standardDev(self):
-		"""standardDev commands group. 0 Sub-classes, 3 commands."""
+		"""standardDev commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_standardDev'):
-			from .Pmonitor_.StandardDev import StandardDev
-			self._standardDev = StandardDev(self._core, self._base)
+			from .StandardDev import StandardDevCls
+			self._standardDev = StandardDevCls(self._core, self._cmd_group)
 		return self._standardDev
 
-	def clone(self) -> 'Pmonitor':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'TxPowerCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Pmonitor(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = TxPowerCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Pmonitor_/Average.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Pmonitor/Average.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,68 +1,68 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
-from ....Internal.StructBase import StructBase
-from ....Internal.ArgStruct import ArgStruct
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
+from .....Internal.StructBase import StructBase
+from .....Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class AverageCls:
+	"""Average commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Out_Of_Tolerance: int: Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for power measurements exceeding the specified power limits.
+			- Reliability: int: 'Reliability indicator'
+			- Out_Of_Tolerance: int: Out of tolerance result, i.e. the percentage of measurement intervals of the statistic count for power measurements exceeding the specified power limits.
 			- Tx_Power: float: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
 			ArgStruct.scalar_float('Tx_Power')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tolerance: int = None
 			self.Tx_Power: float = None
 
 	def read(self) -> ResultData:
 		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:PMONitor:AVERage \n
-		Snippet: value: ResultData = driver.multiEval.pmonitor.average.read() \n
+		Snippet: value: ResultData = driver.lteMeas.multiEval.pmonitor.average.read() \n
 		Returns the total TX power of all carriers. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
 		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:PMONitor:AVERage?', self.__class__.ResultData())
 
 	def fetch(self) -> ResultData:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:PMONitor:AVERage \n
-		Snippet: value: ResultData = driver.multiEval.pmonitor.average.fetch() \n
+		Snippet: value: ResultData = driver.lteMeas.multiEval.pmonitor.average.fetch() \n
 		Returns the total TX power of all carriers. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
 		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:PMONitor:AVERage?', self.__class__.ResultData())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
 			- Reliability: int: No parameter help available
 			- Out_Of_Tolerance: int: No parameter help available
-			- Tx_Power: float: No parameter help available"""
+			- Tx_Power: float or bool: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
-			ArgStruct.scalar_float('Tx_Power')]
+			ArgStruct.scalar_float_ext('Tx_Power')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tolerance: int = None
-			self.Tx_Power: float = None
+			self.Tx_Power: float or bool = None
 
 	def calculate(self) -> CalculateStruct:
 		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:PMONitor:AVERage \n
-		Snippet: value: CalculateStruct = driver.multiEval.pmonitor.average.calculate() \n
+		Snippet: value: CalculateStruct = driver.lteMeas.multiEval.pmonitor.average.calculate() \n
 		No command help available \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
 		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:PMONitor:AVERage?', self.__class__.CalculateStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Pmonitor_/Cc.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/Power/Cc/__init__.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,74 +1,74 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
-from ....Internal.RepeatedCapability import RepeatedCapability
-from .... import repcap
+from ........Internal.Core import Core
+from ........Internal.CommandsGroup import CommandsGroup
+from ........Internal.RepeatedCapability import RepeatedCapability
+from ........ import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Cc:
-	"""Cc commands group definition. 10 total commands, 5 Sub-groups, 0 group commands
-	Repeated Capability: CarrierComponent, default value after init: CarrierComponent.Nr1"""
+class CcCls:
+	"""Cc commands group definition. 9 total commands, 5 Subgroups, 0 group commands
+	Repeated Capability: CarrierComponentB, default value after init: CarrierComponentB.Nr1"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("cc", core, parent)
-		self._base.rep_cap = RepeatedCapability(self._base.group_name, 'repcap_carrierComponent_get', 'repcap_carrierComponent_set', repcap.CarrierComponent.Nr1)
+		self._cmd_group = CommandsGroup("cc", core, parent)
+		self._cmd_group.rep_cap = RepeatedCapability(self._cmd_group.group_name, 'repcap_carrierComponentB_get', 'repcap_carrierComponentB_set', repcap.CarrierComponentB.Nr1)
 
-	def repcap_carrierComponent_set(self, enum_value: repcap.CarrierComponent) -> None:
+	def repcap_carrierComponentB_set(self, carrierComponentB: repcap.CarrierComponentB) -> None:
 		"""Repeated Capability default value numeric suffix.
-		This value is used, if you do not explicitely set it in the child set/get methods, or if you leave it to CarrierComponent.Default
-		Default value after init: CarrierComponent.Nr1"""
-		self._base.set_repcap_enum_value(enum_value)
+		This value is used, if you do not explicitely set it in the child set/get methods, or if you leave it to CarrierComponentB.Default
+		Default value after init: CarrierComponentB.Nr1"""
+		self._cmd_group.set_repcap_enum_value(carrierComponentB)
 
-	def repcap_carrierComponent_get(self) -> repcap.CarrierComponent:
+	def repcap_carrierComponentB_get(self) -> repcap.CarrierComponentB:
 		"""Returns the current default repeated capability for the child set/get methods"""
 		# noinspection PyTypeChecker
-		return self._base.get_repcap_enum_value()
+		return self._cmd_group.get_repcap_enum_value()
 
 	@property
 	def current(self):
 		"""current commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_current'):
-			from .Cc_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
 	@property
 	def average(self):
 		"""average commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_average'):
-			from .Cc_.Average import Average
-			self._average = Average(self._core, self._base)
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
 		return self._average
 
 	@property
-	def maximum(self):
-		"""maximum commands group. 0 Sub-classes, 2 commands."""
-		if not hasattr(self, '_maximum'):
-			from .Cc_.Maximum import Maximum
-			self._maximum = Maximum(self._core, self._base)
-		return self._maximum
-
-	@property
 	def minimum(self):
 		"""minimum commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_minimum'):
-			from .Cc_.Minimum import Minimum
-			self._minimum = Minimum(self._core, self._base)
+			from .Minimum import MinimumCls
+			self._minimum = MinimumCls(self._core, self._cmd_group)
 		return self._minimum
 
 	@property
+	def maximum(self):
+		"""maximum commands group. 0 Sub-classes, 2 commands."""
+		if not hasattr(self, '_maximum'):
+			from .Maximum import MaximumCls
+			self._maximum = MaximumCls(self._core, self._cmd_group)
+		return self._maximum
+
+	@property
 	def standardDev(self):
-		"""standardDev commands group. 0 Sub-classes, 2 commands."""
+		"""standardDev commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_standardDev'):
-			from .Cc_.StandardDev import StandardDev
-			self._standardDev = StandardDev(self._core, self._base)
+			from .StandardDev import StandardDevCls
+			self._standardDev = StandardDevCls(self._core, self._cmd_group)
 		return self._standardDev
 
-	def clone(self) -> 'Cc':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'CcCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Cc(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = CcCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Pmonitor_/Cc_/Average.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Pmonitor/Cc/Current.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,49 +1,49 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
-from .....Internal.StructBase import StructBase
-from .....Internal.ArgStruct import ArgStruct
-from ..... import repcap
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal.StructBase import StructBase
+from ......Internal.ArgStruct import ArgStruct
+from ...... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Out_Of_Tolerance: int: Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for power measurements exceeding the specified power limits.
+			- Reliability: int: 'Reliability indicator'
+			- Out_Of_Tolerance: int: Out of tolerance result, i.e. the percentage of measurement intervals of the statistic count for power measurements exceeding the specified power limits.
 			- Tx_Power: float: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
 			ArgStruct.scalar_float('Tx_Power')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tolerance: int = None
 			self.Tx_Power: float = None
 
 	def read(self, carrierComponent=repcap.CarrierComponent.Default) -> ResultData:
-		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:PMONitor:CC<Nr>:AVERage \n
-		Snippet: value: ResultData = driver.multiEval.pmonitor.cc.average.read(carrierComponent = repcap.CarrierComponent.Default) \n
+		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:PMONitor:CC<Nr>:CURRent \n
+		Snippet: value: ResultData = driver.lteMeas.multiEval.pmonitor.cc.current.read(carrierComponent = repcap.CarrierComponent.Default) \n
 		Returns the TX power of carrier CC<no>. \n
 			:param carrierComponent: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Cc')
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		carrierComponent_cmd_val = self._base.get_repcap_cmd_value(carrierComponent, repcap.CarrierComponent)
-		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:PMONitor:CC{carrierComponent_cmd_val}:AVERage?', self.__class__.ResultData())
+		carrierComponent_cmd_val = self._cmd_group.get_repcap_cmd_value(carrierComponent, repcap.CarrierComponent)
+		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:PMONitor:CC{carrierComponent_cmd_val}:CURRent?', self.__class__.ResultData())
 
 	def fetch(self, carrierComponent=repcap.CarrierComponent.Default) -> ResultData:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:PMONitor:CC<Nr>:AVERage \n
-		Snippet: value: ResultData = driver.multiEval.pmonitor.cc.average.fetch(carrierComponent = repcap.CarrierComponent.Default) \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:PMONitor:CC<Nr>:CURRent \n
+		Snippet: value: ResultData = driver.lteMeas.multiEval.pmonitor.cc.current.fetch(carrierComponent = repcap.CarrierComponent.Default) \n
 		Returns the TX power of carrier CC<no>. \n
 			:param carrierComponent: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Cc')
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		carrierComponent_cmd_val = self._base.get_repcap_cmd_value(carrierComponent, repcap.CarrierComponent)
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:PMONitor:CC{carrierComponent_cmd_val}:AVERage?', self.__class__.ResultData())
+		carrierComponent_cmd_val = self._cmd_group.get_repcap_cmd_value(carrierComponent, repcap.CarrierComponent)
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:PMONitor:CC{carrierComponent_cmd_val}:CURRent?', self.__class__.ResultData())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Pmonitor_/Cc_/Current.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Pmonitor/Cc/StandardDev.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,49 +1,49 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
-from .....Internal.StructBase import StructBase
-from .....Internal.ArgStruct import ArgStruct
-from ..... import repcap
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal.StructBase import StructBase
+from ......Internal.ArgStruct import ArgStruct
+from ...... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class StandardDevCls:
+	"""StandardDev commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("standardDev", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Out_Of_Tolerance: int: Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for power measurements exceeding the specified power limits.
+			- Reliability: int: 'Reliability indicator'
+			- Out_Of_Tolerance: int: Out of tolerance result, i.e. the percentage of measurement intervals of the statistic count for power measurements exceeding the specified power limits.
 			- Tx_Power: float: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
 			ArgStruct.scalar_float('Tx_Power')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tolerance: int = None
 			self.Tx_Power: float = None
 
 	def read(self, carrierComponent=repcap.CarrierComponent.Default) -> ResultData:
-		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:PMONitor:CC<Nr>:CURRent \n
-		Snippet: value: ResultData = driver.multiEval.pmonitor.cc.current.read(carrierComponent = repcap.CarrierComponent.Default) \n
+		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:PMONitor:CC<Nr>:SDEViation \n
+		Snippet: value: ResultData = driver.lteMeas.multiEval.pmonitor.cc.standardDev.read(carrierComponent = repcap.CarrierComponent.Default) \n
 		Returns the TX power of carrier CC<no>. \n
 			:param carrierComponent: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Cc')
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		carrierComponent_cmd_val = self._base.get_repcap_cmd_value(carrierComponent, repcap.CarrierComponent)
-		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:PMONitor:CC{carrierComponent_cmd_val}:CURRent?', self.__class__.ResultData())
+		carrierComponent_cmd_val = self._cmd_group.get_repcap_cmd_value(carrierComponent, repcap.CarrierComponent)
+		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:PMONitor:CC{carrierComponent_cmd_val}:SDEViation?', self.__class__.ResultData())
 
 	def fetch(self, carrierComponent=repcap.CarrierComponent.Default) -> ResultData:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:PMONitor:CC<Nr>:CURRent \n
-		Snippet: value: ResultData = driver.multiEval.pmonitor.cc.current.fetch(carrierComponent = repcap.CarrierComponent.Default) \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:PMONitor:CC<Nr>:SDEViation \n
+		Snippet: value: ResultData = driver.lteMeas.multiEval.pmonitor.cc.standardDev.fetch(carrierComponent = repcap.CarrierComponent.Default) \n
 		Returns the TX power of carrier CC<no>. \n
 			:param carrierComponent: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Cc')
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		carrierComponent_cmd_val = self._base.get_repcap_cmd_value(carrierComponent, repcap.CarrierComponent)
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:PMONitor:CC{carrierComponent_cmd_val}:CURRent?', self.__class__.ResultData())
+		carrierComponent_cmd_val = self._cmd_group.get_repcap_cmd_value(carrierComponent, repcap.CarrierComponent)
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:PMONitor:CC{carrierComponent_cmd_val}:SDEViation?', self.__class__.ResultData())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Pmonitor_/Cc_/Maximum.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Pmonitor/Cc/Minimum.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,49 +1,49 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
-from .....Internal.StructBase import StructBase
-from .....Internal.ArgStruct import ArgStruct
-from ..... import repcap
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal.StructBase import StructBase
+from ......Internal.ArgStruct import ArgStruct
+from ...... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Maximum:
-	"""Maximum commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class MinimumCls:
+	"""Minimum commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("maximum", core, parent)
+		self._cmd_group = CommandsGroup("minimum", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Out_Of_Tolerance: int: Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for power measurements exceeding the specified power limits.
+			- Reliability: int: 'Reliability indicator'
+			- Out_Of_Tolerance: int: Out of tolerance result, i.e. the percentage of measurement intervals of the statistic count for power measurements exceeding the specified power limits.
 			- Tx_Power: float: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
 			ArgStruct.scalar_float('Tx_Power')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tolerance: int = None
 			self.Tx_Power: float = None
 
 	def read(self, carrierComponent=repcap.CarrierComponent.Default) -> ResultData:
-		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:PMONitor:CC<Nr>:MAXimum \n
-		Snippet: value: ResultData = driver.multiEval.pmonitor.cc.maximum.read(carrierComponent = repcap.CarrierComponent.Default) \n
+		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:PMONitor:CC<Nr>:MINimum \n
+		Snippet: value: ResultData = driver.lteMeas.multiEval.pmonitor.cc.minimum.read(carrierComponent = repcap.CarrierComponent.Default) \n
 		Returns the TX power of carrier CC<no>. \n
 			:param carrierComponent: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Cc')
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		carrierComponent_cmd_val = self._base.get_repcap_cmd_value(carrierComponent, repcap.CarrierComponent)
-		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:PMONitor:CC{carrierComponent_cmd_val}:MAXimum?', self.__class__.ResultData())
+		carrierComponent_cmd_val = self._cmd_group.get_repcap_cmd_value(carrierComponent, repcap.CarrierComponent)
+		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:PMONitor:CC{carrierComponent_cmd_val}:MINimum?', self.__class__.ResultData())
 
 	def fetch(self, carrierComponent=repcap.CarrierComponent.Default) -> ResultData:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:PMONitor:CC<Nr>:MAXimum \n
-		Snippet: value: ResultData = driver.multiEval.pmonitor.cc.maximum.fetch(carrierComponent = repcap.CarrierComponent.Default) \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:PMONitor:CC<Nr>:MINimum \n
+		Snippet: value: ResultData = driver.lteMeas.multiEval.pmonitor.cc.minimum.fetch(carrierComponent = repcap.CarrierComponent.Default) \n
 		Returns the TX power of carrier CC<no>. \n
 			:param carrierComponent: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Cc')
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		carrierComponent_cmd_val = self._base.get_repcap_cmd_value(carrierComponent, repcap.CarrierComponent)
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:PMONitor:CC{carrierComponent_cmd_val}:MAXimum?', self.__class__.ResultData())
+		carrierComponent_cmd_val = self._cmd_group.get_repcap_cmd_value(carrierComponent, repcap.CarrierComponent)
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:PMONitor:CC{carrierComponent_cmd_val}:MINimum?', self.__class__.ResultData())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Pmonitor_/Cc_/Minimum.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Pmonitor/Cc/Maximum.py`

 * *Files 11% similar despite different names*

```diff
@@ -1,49 +1,49 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
-from .....Internal.StructBase import StructBase
-from .....Internal.ArgStruct import ArgStruct
-from ..... import repcap
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal.StructBase import StructBase
+from ......Internal.ArgStruct import ArgStruct
+from ...... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Minimum:
-	"""Minimum commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class MaximumCls:
+	"""Maximum commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("minimum", core, parent)
+		self._cmd_group = CommandsGroup("maximum", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Out_Of_Tolerance: int: Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for power measurements exceeding the specified power limits.
+			- Reliability: int: 'Reliability indicator'
+			- Out_Of_Tolerance: int: Out of tolerance result, i.e. the percentage of measurement intervals of the statistic count for power measurements exceeding the specified power limits.
 			- Tx_Power: float: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
 			ArgStruct.scalar_float('Tx_Power')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tolerance: int = None
 			self.Tx_Power: float = None
 
 	def read(self, carrierComponent=repcap.CarrierComponent.Default) -> ResultData:
-		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:PMONitor:CC<Nr>:MINimum \n
-		Snippet: value: ResultData = driver.multiEval.pmonitor.cc.minimum.read(carrierComponent = repcap.CarrierComponent.Default) \n
+		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:PMONitor:CC<Nr>:MAXimum \n
+		Snippet: value: ResultData = driver.lteMeas.multiEval.pmonitor.cc.maximum.read(carrierComponent = repcap.CarrierComponent.Default) \n
 		Returns the TX power of carrier CC<no>. \n
 			:param carrierComponent: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Cc')
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		carrierComponent_cmd_val = self._base.get_repcap_cmd_value(carrierComponent, repcap.CarrierComponent)
-		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:PMONitor:CC{carrierComponent_cmd_val}:MINimum?', self.__class__.ResultData())
+		carrierComponent_cmd_val = self._cmd_group.get_repcap_cmd_value(carrierComponent, repcap.CarrierComponent)
+		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:PMONitor:CC{carrierComponent_cmd_val}:MAXimum?', self.__class__.ResultData())
 
 	def fetch(self, carrierComponent=repcap.CarrierComponent.Default) -> ResultData:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:PMONitor:CC<Nr>:MINimum \n
-		Snippet: value: ResultData = driver.multiEval.pmonitor.cc.minimum.fetch(carrierComponent = repcap.CarrierComponent.Default) \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:PMONitor:CC<Nr>:MAXimum \n
+		Snippet: value: ResultData = driver.lteMeas.multiEval.pmonitor.cc.maximum.fetch(carrierComponent = repcap.CarrierComponent.Default) \n
 		Returns the TX power of carrier CC<no>. \n
 			:param carrierComponent: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Cc')
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		carrierComponent_cmd_val = self._base.get_repcap_cmd_value(carrierComponent, repcap.CarrierComponent)
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:PMONitor:CC{carrierComponent_cmd_val}:MINimum?', self.__class__.ResultData())
+		carrierComponent_cmd_val = self._cmd_group.get_repcap_cmd_value(carrierComponent, repcap.CarrierComponent)
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:PMONitor:CC{carrierComponent_cmd_val}:MAXimum?', self.__class__.ResultData())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Pmonitor_/Cc_/StandardDev.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Pmonitor/Cc/Average.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,49 +1,49 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
-from .....Internal.StructBase import StructBase
-from .....Internal.ArgStruct import ArgStruct
-from ..... import repcap
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal.StructBase import StructBase
+from ......Internal.ArgStruct import ArgStruct
+from ...... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class StandardDev:
-	"""StandardDev commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class AverageCls:
+	"""Average commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("standardDev", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Out_Of_Tolerance: int: Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for power measurements exceeding the specified power limits.
+			- Reliability: int: 'Reliability indicator'
+			- Out_Of_Tolerance: int: Out of tolerance result, i.e. the percentage of measurement intervals of the statistic count for power measurements exceeding the specified power limits.
 			- Tx_Power: float: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
 			ArgStruct.scalar_float('Tx_Power')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tolerance: int = None
 			self.Tx_Power: float = None
 
 	def read(self, carrierComponent=repcap.CarrierComponent.Default) -> ResultData:
-		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:PMONitor:CC<Nr>:SDEViation \n
-		Snippet: value: ResultData = driver.multiEval.pmonitor.cc.standardDev.read(carrierComponent = repcap.CarrierComponent.Default) \n
+		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:PMONitor:CC<Nr>:AVERage \n
+		Snippet: value: ResultData = driver.lteMeas.multiEval.pmonitor.cc.average.read(carrierComponent = repcap.CarrierComponent.Default) \n
 		Returns the TX power of carrier CC<no>. \n
 			:param carrierComponent: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Cc')
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		carrierComponent_cmd_val = self._base.get_repcap_cmd_value(carrierComponent, repcap.CarrierComponent)
-		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:PMONitor:CC{carrierComponent_cmd_val}:SDEViation?', self.__class__.ResultData())
+		carrierComponent_cmd_val = self._cmd_group.get_repcap_cmd_value(carrierComponent, repcap.CarrierComponent)
+		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:PMONitor:CC{carrierComponent_cmd_val}:AVERage?', self.__class__.ResultData())
 
 	def fetch(self, carrierComponent=repcap.CarrierComponent.Default) -> ResultData:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:PMONitor:CC<Nr>:SDEViation \n
-		Snippet: value: ResultData = driver.multiEval.pmonitor.cc.standardDev.fetch(carrierComponent = repcap.CarrierComponent.Default) \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:PMONitor:CC<Nr>:AVERage \n
+		Snippet: value: ResultData = driver.lteMeas.multiEval.pmonitor.cc.average.fetch(carrierComponent = repcap.CarrierComponent.Default) \n
 		Returns the TX power of carrier CC<no>. \n
 			:param carrierComponent: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Cc')
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		carrierComponent_cmd_val = self._base.get_repcap_cmd_value(carrierComponent, repcap.CarrierComponent)
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:PMONitor:CC{carrierComponent_cmd_val}:SDEViation?', self.__class__.ResultData())
+		carrierComponent_cmd_val = self._cmd_group.get_repcap_cmd_value(carrierComponent, repcap.CarrierComponent)
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:PMONitor:CC{carrierComponent_cmd_val}:AVERage?', self.__class__.ResultData())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Pmonitor_/Current.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Pmonitor/Current.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,68 +1,68 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
-from ....Internal.StructBase import StructBase
-from ....Internal.ArgStruct import ArgStruct
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
+from .....Internal.StructBase import StructBase
+from .....Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Out_Of_Tolerance: int: Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for power measurements exceeding the specified power limits.
+			- Reliability: int: 'Reliability indicator'
+			- Out_Of_Tolerance: int: Out of tolerance result, i.e. the percentage of measurement intervals of the statistic count for power measurements exceeding the specified power limits.
 			- Tx_Power: float: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
 			ArgStruct.scalar_float('Tx_Power')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tolerance: int = None
 			self.Tx_Power: float = None
 
 	def read(self) -> ResultData:
 		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:PMONitor:CURRent \n
-		Snippet: value: ResultData = driver.multiEval.pmonitor.current.read() \n
+		Snippet: value: ResultData = driver.lteMeas.multiEval.pmonitor.current.read() \n
 		Returns the total TX power of all carriers. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
 		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:PMONitor:CURRent?', self.__class__.ResultData())
 
 	def fetch(self) -> ResultData:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:PMONitor:CURRent \n
-		Snippet: value: ResultData = driver.multiEval.pmonitor.current.fetch() \n
+		Snippet: value: ResultData = driver.lteMeas.multiEval.pmonitor.current.fetch() \n
 		Returns the total TX power of all carriers. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
 		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:PMONitor:CURRent?', self.__class__.ResultData())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
 			- Reliability: int: No parameter help available
 			- Out_Of_Tolerance: int: No parameter help available
-			- Tx_Power: float: No parameter help available"""
+			- Tx_Power: float or bool: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
-			ArgStruct.scalar_float('Tx_Power')]
+			ArgStruct.scalar_float_ext('Tx_Power')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tolerance: int = None
-			self.Tx_Power: float = None
+			self.Tx_Power: float or bool = None
 
 	def calculate(self) -> CalculateStruct:
 		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:PMONitor:CURRent \n
-		Snippet: value: CalculateStruct = driver.multiEval.pmonitor.current.calculate() \n
+		Snippet: value: CalculateStruct = driver.lteMeas.multiEval.pmonitor.current.calculate() \n
 		No command help available \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
 		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:PMONitor:CURRent?', self.__class__.CalculateStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Pmonitor_/Maximum.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Pmonitor/Maximum.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,68 +1,68 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
-from ....Internal.StructBase import StructBase
-from ....Internal.ArgStruct import ArgStruct
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
+from .....Internal.StructBase import StructBase
+from .....Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Maximum:
-	"""Maximum commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class MaximumCls:
+	"""Maximum commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("maximum", core, parent)
+		self._cmd_group = CommandsGroup("maximum", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Out_Of_Tolerance: int: Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for power measurements exceeding the specified power limits.
+			- Reliability: int: 'Reliability indicator'
+			- Out_Of_Tolerance: int: Out of tolerance result, i.e. the percentage of measurement intervals of the statistic count for power measurements exceeding the specified power limits.
 			- Tx_Power: float: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
 			ArgStruct.scalar_float('Tx_Power')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tolerance: int = None
 			self.Tx_Power: float = None
 
 	def read(self) -> ResultData:
 		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:PMONitor:MAXimum \n
-		Snippet: value: ResultData = driver.multiEval.pmonitor.maximum.read() \n
+		Snippet: value: ResultData = driver.lteMeas.multiEval.pmonitor.maximum.read() \n
 		Returns the total TX power of all carriers. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
 		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:PMONitor:MAXimum?', self.__class__.ResultData())
 
 	def fetch(self) -> ResultData:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:PMONitor:MAXimum \n
-		Snippet: value: ResultData = driver.multiEval.pmonitor.maximum.fetch() \n
+		Snippet: value: ResultData = driver.lteMeas.multiEval.pmonitor.maximum.fetch() \n
 		Returns the total TX power of all carriers. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
 		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:PMONitor:MAXimum?', self.__class__.ResultData())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
 			- Reliability: int: No parameter help available
 			- Out_Of_Tolerance: int: No parameter help available
-			- Tx_Power: float: No parameter help available"""
+			- Tx_Power: float or bool: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
-			ArgStruct.scalar_float('Tx_Power')]
+			ArgStruct.scalar_float_ext('Tx_Power')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tolerance: int = None
-			self.Tx_Power: float = None
+			self.Tx_Power: float or bool = None
 
 	def calculate(self) -> CalculateStruct:
 		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:PMONitor:MAXimum \n
-		Snippet: value: CalculateStruct = driver.multiEval.pmonitor.maximum.calculate() \n
+		Snippet: value: CalculateStruct = driver.lteMeas.multiEval.pmonitor.maximum.calculate() \n
 		No command help available \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
 		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:PMONitor:MAXimum?', self.__class__.CalculateStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Pmonitor_/Minimum.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Pmonitor/StandardDev.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,68 +1,68 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
-from ....Internal.StructBase import StructBase
-from ....Internal.ArgStruct import ArgStruct
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
+from .....Internal.StructBase import StructBase
+from .....Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Minimum:
-	"""Minimum commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class StandardDevCls:
+	"""StandardDev commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("minimum", core, parent)
+		self._cmd_group = CommandsGroup("standardDev", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Out_Of_Tolerance: int: Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for power measurements exceeding the specified power limits.
+			- Reliability: int: 'Reliability indicator'
+			- Out_Of_Tolerance: int: Out of tolerance result, i.e. the percentage of measurement intervals of the statistic count for power measurements exceeding the specified power limits.
 			- Tx_Power: float: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
 			ArgStruct.scalar_float('Tx_Power')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tolerance: int = None
 			self.Tx_Power: float = None
 
 	def read(self) -> ResultData:
-		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:PMONitor:MINimum \n
-		Snippet: value: ResultData = driver.multiEval.pmonitor.minimum.read() \n
+		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:PMONitor:SDEViation \n
+		Snippet: value: ResultData = driver.lteMeas.multiEval.pmonitor.standardDev.read() \n
 		Returns the total TX power of all carriers. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:PMONitor:MINimum?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:PMONitor:SDEViation?', self.__class__.ResultData())
 
 	def fetch(self) -> ResultData:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:PMONitor:MINimum \n
-		Snippet: value: ResultData = driver.multiEval.pmonitor.minimum.fetch() \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:PMONitor:SDEViation \n
+		Snippet: value: ResultData = driver.lteMeas.multiEval.pmonitor.standardDev.fetch() \n
 		Returns the total TX power of all carriers. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:PMONitor:MINimum?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:PMONitor:SDEViation?', self.__class__.ResultData())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
 			- Reliability: int: No parameter help available
 			- Out_Of_Tolerance: int: No parameter help available
-			- Tx_Power: float: No parameter help available"""
+			- Tx_Power: float or bool: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
-			ArgStruct.scalar_float('Tx_Power')]
+			ArgStruct.scalar_float_ext('Tx_Power')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tolerance: int = None
-			self.Tx_Power: float = None
+			self.Tx_Power: float or bool = None
 
 	def calculate(self) -> CalculateStruct:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:PMONitor:MINimum \n
-		Snippet: value: CalculateStruct = driver.multiEval.pmonitor.minimum.calculate() \n
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:PMONitor:SDEViation \n
+		Snippet: value: CalculateStruct = driver.lteMeas.multiEval.pmonitor.standardDev.calculate() \n
 		No command help available \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:PMONitor:MINimum?', self.__class__.CalculateStruct())
+		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:PMONitor:SDEViation?', self.__class__.CalculateStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Pmonitor_/Pcc.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/SeMask/TxPower/__init__.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,59 +1,59 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Pcc:
-	"""Pcc commands group definition. 10 total commands, 5 Sub-groups, 0 group commands"""
+class TxPowerCls:
+	"""TxPower commands group definition. 9 total commands, 5 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("pcc", core, parent)
+		self._cmd_group = CommandsGroup("txPower", core, parent)
 
 	@property
 	def current(self):
 		"""current commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_current'):
-			from .Pcc_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
 	@property
 	def average(self):
 		"""average commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_average'):
-			from .Pcc_.Average import Average
-			self._average = Average(self._core, self._base)
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
 		return self._average
 
 	@property
-	def maximum(self):
-		"""maximum commands group. 0 Sub-classes, 2 commands."""
-		if not hasattr(self, '_maximum'):
-			from .Pcc_.Maximum import Maximum
-			self._maximum = Maximum(self._core, self._base)
-		return self._maximum
-
-	@property
 	def minimum(self):
 		"""minimum commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_minimum'):
-			from .Pcc_.Minimum import Minimum
-			self._minimum = Minimum(self._core, self._base)
+			from .Minimum import MinimumCls
+			self._minimum = MinimumCls(self._core, self._cmd_group)
 		return self._minimum
 
 	@property
+	def maximum(self):
+		"""maximum commands group. 0 Sub-classes, 2 commands."""
+		if not hasattr(self, '_maximum'):
+			from .Maximum import MaximumCls
+			self._maximum = MaximumCls(self._core, self._cmd_group)
+		return self._maximum
+
+	@property
 	def standardDev(self):
-		"""standardDev commands group. 0 Sub-classes, 2 commands."""
+		"""standardDev commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_standardDev'):
-			from .Pcc_.StandardDev import StandardDev
-			self._standardDev = StandardDev(self._core, self._base)
+			from .StandardDev import StandardDevCls
+			self._standardDev = StandardDevCls(self._core, self._cmd_group)
 		return self._standardDev
 
-	def clone(self) -> 'Pcc':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'TxPowerCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Pcc(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = TxPowerCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Pmonitor_/Pcc_/Average.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Pmonitor/Pcc/Average.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,20 +1,20 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
-from .....Internal.StructBase import StructBase
-from .....Internal.ArgStruct import ArgStruct
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal.StructBase import StructBase
+from ......Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class AverageCls:
+	"""Average commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
 			- Reliability: int: No parameter help available
 			- Out_Of_Tolerance: int: No parameter help available
 			- Tx_Power: float: No parameter help available"""
@@ -27,18 +27,18 @@
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tolerance: int = None
 			self.Tx_Power: float = None
 
 	def read(self) -> ResultData:
 		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:PMONitor:PCC:AVERage \n
-		Snippet: value: ResultData = driver.multiEval.pmonitor.pcc.average.read() \n
+		Snippet: value: ResultData = driver.lteMeas.multiEval.pmonitor.pcc.average.read() \n
 		No command help available \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
 		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:PMONitor:PCC:AVERage?', self.__class__.ResultData())
 
 	def fetch(self) -> ResultData:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:PMONitor:PCC:AVERage \n
-		Snippet: value: ResultData = driver.multiEval.pmonitor.pcc.average.fetch() \n
+		Snippet: value: ResultData = driver.lteMeas.multiEval.pmonitor.pcc.average.fetch() \n
 		No command help available \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
 		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:PMONitor:PCC:AVERage?', self.__class__.ResultData())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Pmonitor_/Pcc_/Current.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Pmonitor/Pcc/Current.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,20 +1,20 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
-from .....Internal.StructBase import StructBase
-from .....Internal.ArgStruct import ArgStruct
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal.StructBase import StructBase
+from ......Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
 			- Reliability: int: No parameter help available
 			- Out_Of_Tolerance: int: No parameter help available
 			- Tx_Power: float: No parameter help available"""
@@ -27,18 +27,18 @@
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tolerance: int = None
 			self.Tx_Power: float = None
 
 	def read(self) -> ResultData:
 		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:PMONitor:PCC:CURRent \n
-		Snippet: value: ResultData = driver.multiEval.pmonitor.pcc.current.read() \n
+		Snippet: value: ResultData = driver.lteMeas.multiEval.pmonitor.pcc.current.read() \n
 		No command help available \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
 		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:PMONitor:PCC:CURRent?', self.__class__.ResultData())
 
 	def fetch(self) -> ResultData:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:PMONitor:PCC:CURRent \n
-		Snippet: value: ResultData = driver.multiEval.pmonitor.pcc.current.fetch() \n
+		Snippet: value: ResultData = driver.lteMeas.multiEval.pmonitor.pcc.current.fetch() \n
 		No command help available \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
 		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:PMONitor:PCC:CURRent?', self.__class__.ResultData())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Pmonitor_/Pcc_/Maximum.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Pmonitor/Pcc/Maximum.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,20 +1,20 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
-from .....Internal.StructBase import StructBase
-from .....Internal.ArgStruct import ArgStruct
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal.StructBase import StructBase
+from ......Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Maximum:
-	"""Maximum commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class MaximumCls:
+	"""Maximum commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("maximum", core, parent)
+		self._cmd_group = CommandsGroup("maximum", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
 			- Reliability: int: No parameter help available
 			- Out_Of_Tolerance: int: No parameter help available
 			- Tx_Power: float: No parameter help available"""
@@ -27,18 +27,18 @@
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tolerance: int = None
 			self.Tx_Power: float = None
 
 	def read(self) -> ResultData:
 		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:PMONitor:PCC:MAXimum \n
-		Snippet: value: ResultData = driver.multiEval.pmonitor.pcc.maximum.read() \n
+		Snippet: value: ResultData = driver.lteMeas.multiEval.pmonitor.pcc.maximum.read() \n
 		No command help available \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
 		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:PMONitor:PCC:MAXimum?', self.__class__.ResultData())
 
 	def fetch(self) -> ResultData:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:PMONitor:PCC:MAXimum \n
-		Snippet: value: ResultData = driver.multiEval.pmonitor.pcc.maximum.fetch() \n
+		Snippet: value: ResultData = driver.lteMeas.multiEval.pmonitor.pcc.maximum.fetch() \n
 		No command help available \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
 		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:PMONitor:PCC:MAXimum?', self.__class__.ResultData())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Pmonitor_/Pcc_/Minimum.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Pmonitor/Ulca/Pcc/Minimum.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,20 +1,20 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
-from .....Internal.StructBase import StructBase
-from .....Internal.ArgStruct import ArgStruct
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal.StructBase import StructBase
+from .......Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Minimum:
-	"""Minimum commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class MinimumCls:
+	"""Minimum commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("minimum", core, parent)
+		self._cmd_group = CommandsGroup("minimum", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
 			- Reliability: int: No parameter help available
 			- Out_Of_Tolerance: int: No parameter help available
 			- Tx_Power: float: No parameter help available"""
@@ -26,19 +26,19 @@
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tolerance: int = None
 			self.Tx_Power: float = None
 
 	def read(self) -> ResultData:
-		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:PMONitor:PCC:MINimum \n
-		Snippet: value: ResultData = driver.multiEval.pmonitor.pcc.minimum.read() \n
+		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:PMONitor:ULCA:PCC:MINimum \n
+		Snippet: value: ResultData = driver.lteMeas.multiEval.pmonitor.ulca.pcc.minimum.read() \n
 		No command help available \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:PMONitor:PCC:MINimum?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:PMONitor:ULCA:PCC:MINimum?', self.__class__.ResultData())
 
 	def fetch(self) -> ResultData:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:PMONitor:PCC:MINimum \n
-		Snippet: value: ResultData = driver.multiEval.pmonitor.pcc.minimum.fetch() \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:PMONitor:ULCA:PCC:MINimum \n
+		Snippet: value: ResultData = driver.lteMeas.multiEval.pmonitor.ulca.pcc.minimum.fetch() \n
 		No command help available \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:PMONitor:PCC:MINimum?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:PMONitor:ULCA:PCC:MINimum?', self.__class__.ResultData())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Pmonitor_/Pcc_/StandardDev.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Pmonitor/Scc/Average.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,20 +1,20 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
-from .....Internal.StructBase import StructBase
-from .....Internal.ArgStruct import ArgStruct
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal.StructBase import StructBase
+from ......Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class StandardDev:
-	"""StandardDev commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class AverageCls:
+	"""Average commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("standardDev", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
 			- Reliability: int: No parameter help available
 			- Out_Of_Tolerance: int: No parameter help available
 			- Tx_Power: float: No parameter help available"""
@@ -26,19 +26,19 @@
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tolerance: int = None
 			self.Tx_Power: float = None
 
 	def read(self) -> ResultData:
-		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:PMONitor:PCC:SDEViation \n
-		Snippet: value: ResultData = driver.multiEval.pmonitor.pcc.standardDev.read() \n
+		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:PMONitor:SCC:AVERage \n
+		Snippet: value: ResultData = driver.lteMeas.multiEval.pmonitor.scc.average.read() \n
 		No command help available \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:PMONitor:PCC:SDEViation?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:PMONitor:SCC:AVERage?', self.__class__.ResultData())
 
 	def fetch(self) -> ResultData:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:PMONitor:PCC:SDEViation \n
-		Snippet: value: ResultData = driver.multiEval.pmonitor.pcc.standardDev.fetch() \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:PMONitor:SCC:AVERage \n
+		Snippet: value: ResultData = driver.lteMeas.multiEval.pmonitor.scc.average.fetch() \n
 		No command help available \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:PMONitor:PCC:SDEViation?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:PMONitor:SCC:AVERage?', self.__class__.ResultData())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Pmonitor_/Scc.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Evmc/Peak/__init__.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,59 +1,51 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Scc:
-	"""Scc commands group definition. 10 total commands, 5 Sub-groups, 0 group commands"""
+class PeakCls:
+	"""Peak commands group definition. 8 total commands, 4 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("scc", core, parent)
+		self._cmd_group = CommandsGroup("peak", core, parent)
 
 	@property
 	def current(self):
 		"""current commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_current'):
-			from .Scc_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
 	@property
 	def average(self):
 		"""average commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_average'):
-			from .Scc_.Average import Average
-			self._average = Average(self._core, self._base)
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
 		return self._average
 
 	@property
 	def maximum(self):
 		"""maximum commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_maximum'):
-			from .Scc_.Maximum import Maximum
-			self._maximum = Maximum(self._core, self._base)
+			from .Maximum import MaximumCls
+			self._maximum = MaximumCls(self._core, self._cmd_group)
 		return self._maximum
 
 	@property
-	def minimum(self):
-		"""minimum commands group. 0 Sub-classes, 2 commands."""
-		if not hasattr(self, '_minimum'):
-			from .Scc_.Minimum import Minimum
-			self._minimum = Minimum(self._core, self._base)
-		return self._minimum
-
-	@property
 	def standardDev(self):
 		"""standardDev commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_standardDev'):
-			from .Scc_.StandardDev import StandardDev
-			self._standardDev = StandardDev(self._core, self._base)
+			from .StandardDev import StandardDevCls
+			self._standardDev = StandardDevCls(self._core, self._cmd_group)
 		return self._standardDev
 
-	def clone(self) -> 'Scc':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'PeakCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Scc(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = PeakCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Pmonitor_/Scc_/Average.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Pmonitor/Scc/Current.py`

 * *Files 11% similar despite different names*

```diff
@@ -1,20 +1,20 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
-from .....Internal.StructBase import StructBase
-from .....Internal.ArgStruct import ArgStruct
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal.StructBase import StructBase
+from ......Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
 			- Reliability: int: No parameter help available
 			- Out_Of_Tolerance: int: No parameter help available
 			- Tx_Power: float: No parameter help available"""
@@ -26,19 +26,19 @@
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tolerance: int = None
 			self.Tx_Power: float = None
 
 	def read(self) -> ResultData:
-		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:PMONitor:SCC:AVERage \n
-		Snippet: value: ResultData = driver.multiEval.pmonitor.scc.average.read() \n
+		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:PMONitor:SCC:CURRent \n
+		Snippet: value: ResultData = driver.lteMeas.multiEval.pmonitor.scc.current.read() \n
 		No command help available \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:PMONitor:SCC:AVERage?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:PMONitor:SCC:CURRent?', self.__class__.ResultData())
 
 	def fetch(self) -> ResultData:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:PMONitor:SCC:AVERage \n
-		Snippet: value: ResultData = driver.multiEval.pmonitor.scc.average.fetch() \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:PMONitor:SCC:CURRent \n
+		Snippet: value: ResultData = driver.lteMeas.multiEval.pmonitor.scc.current.fetch() \n
 		No command help available \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:PMONitor:SCC:AVERage?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:PMONitor:SCC:CURRent?', self.__class__.ResultData())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Pmonitor_/Scc_/Current.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Pmonitor/Ulca/Pcc/Current.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,20 +1,20 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
-from .....Internal.StructBase import StructBase
-from .....Internal.ArgStruct import ArgStruct
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal.StructBase import StructBase
+from .......Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
 			- Reliability: int: No parameter help available
 			- Out_Of_Tolerance: int: No parameter help available
 			- Tx_Power: float: No parameter help available"""
@@ -26,19 +26,19 @@
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tolerance: int = None
 			self.Tx_Power: float = None
 
 	def read(self) -> ResultData:
-		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:PMONitor:SCC:CURRent \n
-		Snippet: value: ResultData = driver.multiEval.pmonitor.scc.current.read() \n
+		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:PMONitor:ULCA:PCC:CURRent \n
+		Snippet: value: ResultData = driver.lteMeas.multiEval.pmonitor.ulca.pcc.current.read() \n
 		No command help available \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:PMONitor:SCC:CURRent?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:PMONitor:ULCA:PCC:CURRent?', self.__class__.ResultData())
 
 	def fetch(self) -> ResultData:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:PMONitor:SCC:CURRent \n
-		Snippet: value: ResultData = driver.multiEval.pmonitor.scc.current.fetch() \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:PMONitor:ULCA:PCC:CURRent \n
+		Snippet: value: ResultData = driver.lteMeas.multiEval.pmonitor.ulca.pcc.current.fetch() \n
 		No command help available \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:PMONitor:SCC:CURRent?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:PMONitor:ULCA:PCC:CURRent?', self.__class__.ResultData())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Pmonitor_/Scc_/Maximum.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Pmonitor/Scc/Maximum.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,20 +1,20 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
-from .....Internal.StructBase import StructBase
-from .....Internal.ArgStruct import ArgStruct
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal.StructBase import StructBase
+from ......Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Maximum:
-	"""Maximum commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class MaximumCls:
+	"""Maximum commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("maximum", core, parent)
+		self._cmd_group = CommandsGroup("maximum", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
 			- Reliability: int: No parameter help available
 			- Out_Of_Tolerance: int: No parameter help available
 			- Tx_Power: float: No parameter help available"""
@@ -27,18 +27,18 @@
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tolerance: int = None
 			self.Tx_Power: float = None
 
 	def read(self) -> ResultData:
 		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:PMONitor:SCC:MAXimum \n
-		Snippet: value: ResultData = driver.multiEval.pmonitor.scc.maximum.read() \n
+		Snippet: value: ResultData = driver.lteMeas.multiEval.pmonitor.scc.maximum.read() \n
 		No command help available \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
 		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:PMONitor:SCC:MAXimum?', self.__class__.ResultData())
 
 	def fetch(self) -> ResultData:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:PMONitor:SCC:MAXimum \n
-		Snippet: value: ResultData = driver.multiEval.pmonitor.scc.maximum.fetch() \n
+		Snippet: value: ResultData = driver.lteMeas.multiEval.pmonitor.scc.maximum.fetch() \n
 		No command help available \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
 		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:PMONitor:SCC:MAXimum?', self.__class__.ResultData())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Pmonitor_/Scc_/Minimum.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Pmonitor/Scc/Minimum.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,20 +1,20 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
-from .....Internal.StructBase import StructBase
-from .....Internal.ArgStruct import ArgStruct
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal.StructBase import StructBase
+from ......Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Minimum:
-	"""Minimum commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class MinimumCls:
+	"""Minimum commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("minimum", core, parent)
+		self._cmd_group = CommandsGroup("minimum", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
 			- Reliability: int: No parameter help available
 			- Out_Of_Tolerance: int: No parameter help available
 			- Tx_Power: float: No parameter help available"""
@@ -27,18 +27,18 @@
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tolerance: int = None
 			self.Tx_Power: float = None
 
 	def read(self) -> ResultData:
 		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:PMONitor:SCC:MINimum \n
-		Snippet: value: ResultData = driver.multiEval.pmonitor.scc.minimum.read() \n
+		Snippet: value: ResultData = driver.lteMeas.multiEval.pmonitor.scc.minimum.read() \n
 		No command help available \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
 		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:PMONitor:SCC:MINimum?', self.__class__.ResultData())
 
 	def fetch(self) -> ResultData:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:PMONitor:SCC:MINimum \n
-		Snippet: value: ResultData = driver.multiEval.pmonitor.scc.minimum.fetch() \n
+		Snippet: value: ResultData = driver.lteMeas.multiEval.pmonitor.scc.minimum.fetch() \n
 		No command help available \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
 		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:PMONitor:SCC:MINimum?', self.__class__.ResultData())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Pmonitor_/Scc_/StandardDev.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Pmonitor/Ulca/Pcc/Average.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,20 +1,20 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
-from .....Internal.StructBase import StructBase
-from .....Internal.ArgStruct import ArgStruct
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal.StructBase import StructBase
+from .......Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class StandardDev:
-	"""StandardDev commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class AverageCls:
+	"""Average commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("standardDev", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
 			- Reliability: int: No parameter help available
 			- Out_Of_Tolerance: int: No parameter help available
 			- Tx_Power: float: No parameter help available"""
@@ -26,19 +26,19 @@
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tolerance: int = None
 			self.Tx_Power: float = None
 
 	def read(self) -> ResultData:
-		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:PMONitor:SCC:SDEViation \n
-		Snippet: value: ResultData = driver.multiEval.pmonitor.scc.standardDev.read() \n
+		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:PMONitor:ULCA:PCC:AVERage \n
+		Snippet: value: ResultData = driver.lteMeas.multiEval.pmonitor.ulca.pcc.average.read() \n
 		No command help available \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:PMONitor:SCC:SDEViation?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:PMONitor:ULCA:PCC:AVERage?', self.__class__.ResultData())
 
 	def fetch(self) -> ResultData:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:PMONitor:SCC:SDEViation \n
-		Snippet: value: ResultData = driver.multiEval.pmonitor.scc.standardDev.fetch() \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:PMONitor:ULCA:PCC:AVERage \n
+		Snippet: value: ResultData = driver.lteMeas.multiEval.pmonitor.ulca.pcc.average.fetch() \n
 		No command help available \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:PMONitor:SCC:SDEViation?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:PMONitor:ULCA:PCC:AVERage?', self.__class__.ResultData())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Pmonitor_/StandardDev.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/SeMask/Minimum.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,68 +1,68 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
-from ....Internal.StructBase import StructBase
-from ....Internal.ArgStruct import ArgStruct
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
+from .....Internal.StructBase import StructBase
+from .....Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class StandardDev:
-	"""StandardDev commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class MinimumCls:
+	"""Minimum commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("standardDev", core, parent)
+		self._cmd_group = CommandsGroup("minimum", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Out_Of_Tolerance: int: Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for power measurements exceeding the specified power limits.
+			- Reliability: int: No parameter help available
+			- Out_Of_Tolerance: int: No parameter help available
 			- Tx_Power: float: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
 			ArgStruct.scalar_float('Tx_Power')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tolerance: int = None
 			self.Tx_Power: float = None
 
 	def read(self) -> ResultData:
-		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:PMONitor:SDEViation \n
-		Snippet: value: ResultData = driver.multiEval.pmonitor.standardDev.read() \n
-		Returns the total TX power of all carriers. \n
+		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:SEMask:MINimum \n
+		Snippet: value: ResultData = driver.lteMeas.multiEval.seMask.minimum.read() \n
+		No command help available \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:PMONitor:SDEViation?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:SEMask:MINimum?', self.__class__.ResultData())
 
 	def fetch(self) -> ResultData:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:PMONitor:SDEViation \n
-		Snippet: value: ResultData = driver.multiEval.pmonitor.standardDev.fetch() \n
-		Returns the total TX power of all carriers. \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:SEMask:MINimum \n
+		Snippet: value: ResultData = driver.lteMeas.multiEval.seMask.minimum.fetch() \n
+		No command help available \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:PMONitor:SDEViation?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:SEMask:MINimum?', self.__class__.ResultData())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
 			- Reliability: int: No parameter help available
 			- Out_Of_Tolerance: int: No parameter help available
-			- Tx_Power: float: No parameter help available"""
+			- Tx_Power: float or bool: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
-			ArgStruct.scalar_float('Tx_Power')]
+			ArgStruct.scalar_float_ext('Tx_Power')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tolerance: int = None
-			self.Tx_Power: float = None
+			self.Tx_Power: float or bool = None
 
 	def calculate(self) -> CalculateStruct:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:PMONitor:SDEViation \n
-		Snippet: value: CalculateStruct = driver.multiEval.pmonitor.standardDev.calculate() \n
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:SEMask:MINimum \n
+		Snippet: value: CalculateStruct = driver.lteMeas.multiEval.seMask.minimum.calculate() \n
 		No command help available \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:PMONitor:SDEViation?', self.__class__.CalculateStruct())
+		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:SEMask:MINimum?', self.__class__.CalculateStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Pmonitor_/Ulca.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/ListPy/Segment/Emtc/__init__.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,35 +1,27 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
+from ........Internal.Core import Core
+from ........Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Ulca:
-	"""Ulca commands group definition. 20 total commands, 2 Sub-groups, 0 group commands"""
+class EmtcCls:
+	"""Emtc commands group definition. 1 total commands, 1 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("ulca", core, parent)
+		self._cmd_group = CommandsGroup("emtc", core, parent)
 
 	@property
-	def scc(self):
-		"""scc commands group. 5 Sub-classes, 0 commands."""
-		if not hasattr(self, '_scc'):
-			from .Ulca_.Scc import Scc
-			self._scc = Scc(self._core, self._base)
-		return self._scc
+	def nband(self):
+		"""nband commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_nband'):
+			from .Nband import NbandCls
+			self._nband = NbandCls(self._core, self._cmd_group)
+		return self._nband
 
-	@property
-	def pcc(self):
-		"""pcc commands group. 5 Sub-classes, 0 commands."""
-		if not hasattr(self, '_pcc'):
-			from .Ulca_.Pcc import Pcc
-			self._pcc = Pcc(self._core, self._base)
-		return self._pcc
-
-	def clone(self) -> 'Ulca':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'EmtcCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Ulca(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = EmtcCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Pmonitor_/Ulca_/Pcc.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/Prach/EvmSymbol/Peak/__init__.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,59 +1,43 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Pcc:
-	"""Pcc commands group definition. 10 total commands, 5 Sub-groups, 0 group commands"""
+class PeakCls:
+	"""Peak commands group definition. 6 total commands, 3 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("pcc", core, parent)
+		self._cmd_group = CommandsGroup("peak", core, parent)
 
 	@property
 	def current(self):
 		"""current commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_current'):
-			from .Pcc_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
 	@property
 	def average(self):
 		"""average commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_average'):
-			from .Pcc_.Average import Average
-			self._average = Average(self._core, self._base)
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
 		return self._average
 
 	@property
 	def maximum(self):
 		"""maximum commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_maximum'):
-			from .Pcc_.Maximum import Maximum
-			self._maximum = Maximum(self._core, self._base)
+			from .Maximum import MaximumCls
+			self._maximum = MaximumCls(self._core, self._cmd_group)
 		return self._maximum
 
-	@property
-	def minimum(self):
-		"""minimum commands group. 0 Sub-classes, 2 commands."""
-		if not hasattr(self, '_minimum'):
-			from .Pcc_.Minimum import Minimum
-			self._minimum = Minimum(self._core, self._base)
-		return self._minimum
-
-	@property
-	def standardDev(self):
-		"""standardDev commands group. 0 Sub-classes, 2 commands."""
-		if not hasattr(self, '_standardDev'):
-			from .Pcc_.StandardDev import StandardDev
-			self._standardDev = StandardDev(self._core, self._base)
-		return self._standardDev
-
-	def clone(self) -> 'Pcc':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'PeakCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Pcc(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = PeakCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Pmonitor_/Ulca_/Pcc_/Average.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Pmonitor/Ulca/Pcc/Maximum.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,20 +1,20 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.StructBase import StructBase
-from ......Internal.ArgStruct import ArgStruct
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal.StructBase import StructBase
+from .......Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class MaximumCls:
+	"""Maximum commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("maximum", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
 			- Reliability: int: No parameter help available
 			- Out_Of_Tolerance: int: No parameter help available
 			- Tx_Power: float: No parameter help available"""
@@ -26,19 +26,19 @@
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tolerance: int = None
 			self.Tx_Power: float = None
 
 	def read(self) -> ResultData:
-		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:PMONitor:ULCA:PCC:AVERage \n
-		Snippet: value: ResultData = driver.multiEval.pmonitor.ulca.pcc.average.read() \n
+		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:PMONitor:ULCA:PCC:MAXimum \n
+		Snippet: value: ResultData = driver.lteMeas.multiEval.pmonitor.ulca.pcc.maximum.read() \n
 		No command help available \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:PMONitor:ULCA:PCC:AVERage?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:PMONitor:ULCA:PCC:MAXimum?', self.__class__.ResultData())
 
 	def fetch(self) -> ResultData:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:PMONitor:ULCA:PCC:AVERage \n
-		Snippet: value: ResultData = driver.multiEval.pmonitor.ulca.pcc.average.fetch() \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:PMONitor:ULCA:PCC:MAXimum \n
+		Snippet: value: ResultData = driver.lteMeas.multiEval.pmonitor.ulca.pcc.maximum.fetch() \n
 		No command help available \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:PMONitor:ULCA:PCC:AVERage?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:PMONitor:ULCA:PCC:MAXimum?', self.__class__.ResultData())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Pmonitor_/Ulca_/Pcc_/Current.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Pmonitor/Ulca/Scc/Current.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,20 +1,21 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.StructBase import StructBase
-from ......Internal.ArgStruct import ArgStruct
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal.StructBase import StructBase
+from .......Internal.ArgStruct import ArgStruct
+from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
 			- Reliability: int: No parameter help available
 			- Out_Of_Tolerance: int: No parameter help available
 			- Tx_Power: float: No parameter help available"""
@@ -25,20 +26,24 @@
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tolerance: int = None
 			self.Tx_Power: float = None
 
-	def read(self) -> ResultData:
-		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:PMONitor:ULCA:PCC:CURRent \n
-		Snippet: value: ResultData = driver.multiEval.pmonitor.ulca.pcc.current.read() \n
+	def read(self, secondaryCC=repcap.SecondaryCC.Default) -> ResultData:
+		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:PMONitor:ULCA:SCC<Nr>:CURRent \n
+		Snippet: value: ResultData = driver.lteMeas.multiEval.pmonitor.ulca.scc.current.read(secondaryCC = repcap.SecondaryCC.Default) \n
 		No command help available \n
+			:param secondaryCC: optional repeated capability selector. Default value: CC1 (settable in the interface 'Scc')
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:PMONitor:ULCA:PCC:CURRent?', self.__class__.ResultData())
+		secondaryCC_cmd_val = self._cmd_group.get_repcap_cmd_value(secondaryCC, repcap.SecondaryCC)
+		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:PMONitor:ULCA:SCC{secondaryCC_cmd_val}:CURRent?', self.__class__.ResultData())
 
-	def fetch(self) -> ResultData:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:PMONitor:ULCA:PCC:CURRent \n
-		Snippet: value: ResultData = driver.multiEval.pmonitor.ulca.pcc.current.fetch() \n
+	def fetch(self, secondaryCC=repcap.SecondaryCC.Default) -> ResultData:
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:PMONitor:ULCA:SCC<Nr>:CURRent \n
+		Snippet: value: ResultData = driver.lteMeas.multiEval.pmonitor.ulca.scc.current.fetch(secondaryCC = repcap.SecondaryCC.Default) \n
 		No command help available \n
+			:param secondaryCC: optional repeated capability selector. Default value: CC1 (settable in the interface 'Scc')
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:PMONitor:ULCA:PCC:CURRent?', self.__class__.ResultData())
+		secondaryCC_cmd_val = self._cmd_group.get_repcap_cmd_value(secondaryCC, repcap.SecondaryCC)
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:PMONitor:ULCA:SCC{secondaryCC_cmd_val}:CURRent?', self.__class__.ResultData())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Pmonitor_/Ulca_/Pcc_/Maximum.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Pmonitor/Pcc/Minimum.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,20 +1,20 @@
 from ......Internal.Core import Core
 from ......Internal.CommandsGroup import CommandsGroup
 from ......Internal.StructBase import StructBase
 from ......Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Maximum:
-	"""Maximum commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class MinimumCls:
+	"""Minimum commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("maximum", core, parent)
+		self._cmd_group = CommandsGroup("minimum", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
 			- Reliability: int: No parameter help available
 			- Out_Of_Tolerance: int: No parameter help available
 			- Tx_Power: float: No parameter help available"""
@@ -26,19 +26,19 @@
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tolerance: int = None
 			self.Tx_Power: float = None
 
 	def read(self) -> ResultData:
-		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:PMONitor:ULCA:PCC:MAXimum \n
-		Snippet: value: ResultData = driver.multiEval.pmonitor.ulca.pcc.maximum.read() \n
+		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:PMONitor:PCC:MINimum \n
+		Snippet: value: ResultData = driver.lteMeas.multiEval.pmonitor.pcc.minimum.read() \n
 		No command help available \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:PMONitor:ULCA:PCC:MAXimum?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:PMONitor:PCC:MINimum?', self.__class__.ResultData())
 
 	def fetch(self) -> ResultData:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:PMONitor:ULCA:PCC:MAXimum \n
-		Snippet: value: ResultData = driver.multiEval.pmonitor.ulca.pcc.maximum.fetch() \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:PMONitor:PCC:MINimum \n
+		Snippet: value: ResultData = driver.lteMeas.multiEval.pmonitor.pcc.minimum.fetch() \n
 		No command help available \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:PMONitor:ULCA:PCC:MAXimum?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:PMONitor:PCC:MINimum?', self.__class__.ResultData())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Pmonitor_/Ulca_/Pcc_/Minimum.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Trace/RbaTable/Scc.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,44 +1,51 @@
+from typing import List
+
 from ......Internal.Core import Core
 from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal.Types import DataType
 from ......Internal.StructBase import StructBase
 from ......Internal.ArgStruct import ArgStruct
+from ...... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Minimum:
-	"""Minimum commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class SccCls:
+	"""Scc commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("minimum", core, parent)
+		self._cmd_group = CommandsGroup("scc", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
 			- Reliability: int: No parameter help available
-			- Out_Of_Tolerance: int: No parameter help available
-			- Tx_Power: float: No parameter help available"""
+			- Channel_Type: List[enums.RbTableChannelType]: No parameter help available
+			- Offset_Rb: List[int]: No parameter help available
+			- No_Rb: List[int]: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_int('Out_Of_Tolerance'),
-			ArgStruct.scalar_float('Tx_Power')]
+			ArgStruct('Channel_Type', DataType.EnumList, enums.RbTableChannelType, False, True, 1),
+			ArgStruct('Offset_Rb', DataType.IntegerList, None, False, True, 1),
+			ArgStruct('No_Rb', DataType.IntegerList, None, False, True, 1)]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
-			self.Out_Of_Tolerance: int = None
-			self.Tx_Power: float = None
+			self.Channel_Type: List[enums.RbTableChannelType] = None
+			self.Offset_Rb: List[int] = None
+			self.No_Rb: List[int] = None
 
 	def read(self) -> ResultData:
-		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:PMONitor:ULCA:PCC:MINimum \n
-		Snippet: value: ResultData = driver.multiEval.pmonitor.ulca.pcc.minimum.read() \n
+		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:TRACe:RBATable:SCC \n
+		Snippet: value: ResultData = driver.lteMeas.multiEval.trace.rbaTable.scc.read() \n
 		No command help available \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:PMONitor:ULCA:PCC:MINimum?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:TRACe:RBATable:SCC?', self.__class__.ResultData())
 
 	def fetch(self) -> ResultData:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:PMONitor:ULCA:PCC:MINimum \n
-		Snippet: value: ResultData = driver.multiEval.pmonitor.ulca.pcc.minimum.fetch() \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:TRACe:RBATable:SCC \n
+		Snippet: value: ResultData = driver.lteMeas.multiEval.trace.rbaTable.scc.fetch() \n
 		No command help available \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:PMONitor:ULCA:PCC:MINimum?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:TRACe:RBATable:SCC?', self.__class__.ResultData())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Pmonitor_/Ulca_/Pcc_/StandardDev.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Pmonitor/Ulca/Scc/StandardDev.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,20 +1,21 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.StructBase import StructBase
-from ......Internal.ArgStruct import ArgStruct
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal.StructBase import StructBase
+from .......Internal.ArgStruct import ArgStruct
+from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class StandardDev:
-	"""StandardDev commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class StandardDevCls:
+	"""StandardDev commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("standardDev", core, parent)
+		self._cmd_group = CommandsGroup("standardDev", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
 			- Reliability: int: No parameter help available
 			- Out_Of_Tolerance: int: No parameter help available
 			- Tx_Power: float: No parameter help available"""
@@ -25,20 +26,24 @@
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tolerance: int = None
 			self.Tx_Power: float = None
 
-	def read(self) -> ResultData:
-		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:PMONitor:ULCA:PCC:SDEViation \n
-		Snippet: value: ResultData = driver.multiEval.pmonitor.ulca.pcc.standardDev.read() \n
+	def read(self, secondaryCC=repcap.SecondaryCC.Default) -> ResultData:
+		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:PMONitor:ULCA:SCC<Nr>:SDEViation \n
+		Snippet: value: ResultData = driver.lteMeas.multiEval.pmonitor.ulca.scc.standardDev.read(secondaryCC = repcap.SecondaryCC.Default) \n
 		No command help available \n
+			:param secondaryCC: optional repeated capability selector. Default value: CC1 (settable in the interface 'Scc')
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:PMONitor:ULCA:PCC:SDEViation?', self.__class__.ResultData())
+		secondaryCC_cmd_val = self._cmd_group.get_repcap_cmd_value(secondaryCC, repcap.SecondaryCC)
+		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:PMONitor:ULCA:SCC{secondaryCC_cmd_val}:SDEViation?', self.__class__.ResultData())
 
-	def fetch(self) -> ResultData:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:PMONitor:ULCA:PCC:SDEViation \n
-		Snippet: value: ResultData = driver.multiEval.pmonitor.ulca.pcc.standardDev.fetch() \n
+	def fetch(self, secondaryCC=repcap.SecondaryCC.Default) -> ResultData:
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:PMONitor:ULCA:SCC<Nr>:SDEViation \n
+		Snippet: value: ResultData = driver.lteMeas.multiEval.pmonitor.ulca.scc.standardDev.fetch(secondaryCC = repcap.SecondaryCC.Default) \n
 		No command help available \n
+			:param secondaryCC: optional repeated capability selector. Default value: CC1 (settable in the interface 'Scc')
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:PMONitor:ULCA:PCC:SDEViation?', self.__class__.ResultData())
+		secondaryCC_cmd_val = self._cmd_group.get_repcap_cmd_value(secondaryCC, repcap.SecondaryCC)
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:PMONitor:ULCA:SCC{secondaryCC_cmd_val}:SDEViation?', self.__class__.ResultData())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Pmonitor_/Ulca_/Scc.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Pmonitor/Cc/__init__.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,74 +1,74 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
-from .....Internal.RepeatedCapability import RepeatedCapability
-from ..... import repcap
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal.RepeatedCapability import RepeatedCapability
+from ...... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Scc:
-	"""Scc commands group definition. 10 total commands, 5 Sub-groups, 0 group commands
-	Repeated Capability: SecondaryCC, default value after init: SecondaryCC.CC1"""
+class CcCls:
+	"""Cc commands group definition. 10 total commands, 5 Subgroups, 0 group commands
+	Repeated Capability: CarrierComponent, default value after init: CarrierComponent.Nr1"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("scc", core, parent)
-		self._base.rep_cap = RepeatedCapability(self._base.group_name, 'repcap_secondaryCC_get', 'repcap_secondaryCC_set', repcap.SecondaryCC.CC1)
+		self._cmd_group = CommandsGroup("cc", core, parent)
+		self._cmd_group.rep_cap = RepeatedCapability(self._cmd_group.group_name, 'repcap_carrierComponent_get', 'repcap_carrierComponent_set', repcap.CarrierComponent.Nr1)
 
-	def repcap_secondaryCC_set(self, enum_value: repcap.SecondaryCC) -> None:
+	def repcap_carrierComponent_set(self, carrierComponent: repcap.CarrierComponent) -> None:
 		"""Repeated Capability default value numeric suffix.
-		This value is used, if you do not explicitely set it in the child set/get methods, or if you leave it to SecondaryCC.Default
-		Default value after init: SecondaryCC.CC1"""
-		self._base.set_repcap_enum_value(enum_value)
+		This value is used, if you do not explicitely set it in the child set/get methods, or if you leave it to CarrierComponent.Default
+		Default value after init: CarrierComponent.Nr1"""
+		self._cmd_group.set_repcap_enum_value(carrierComponent)
 
-	def repcap_secondaryCC_get(self) -> repcap.SecondaryCC:
+	def repcap_carrierComponent_get(self) -> repcap.CarrierComponent:
 		"""Returns the current default repeated capability for the child set/get methods"""
 		# noinspection PyTypeChecker
-		return self._base.get_repcap_enum_value()
+		return self._cmd_group.get_repcap_enum_value()
 
 	@property
 	def current(self):
 		"""current commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_current'):
-			from .Scc_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
 	@property
 	def average(self):
 		"""average commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_average'):
-			from .Scc_.Average import Average
-			self._average = Average(self._core, self._base)
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
 		return self._average
 
 	@property
 	def maximum(self):
 		"""maximum commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_maximum'):
-			from .Scc_.Maximum import Maximum
-			self._maximum = Maximum(self._core, self._base)
+			from .Maximum import MaximumCls
+			self._maximum = MaximumCls(self._core, self._cmd_group)
 		return self._maximum
 
 	@property
 	def minimum(self):
 		"""minimum commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_minimum'):
-			from .Scc_.Minimum import Minimum
-			self._minimum = Minimum(self._core, self._base)
+			from .Minimum import MinimumCls
+			self._minimum = MinimumCls(self._core, self._cmd_group)
 		return self._minimum
 
 	@property
 	def standardDev(self):
 		"""standardDev commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_standardDev'):
-			from .Scc_.StandardDev import StandardDev
-			self._standardDev = StandardDev(self._core, self._base)
+			from .StandardDev import StandardDevCls
+			self._standardDev = StandardDevCls(self._core, self._cmd_group)
 		return self._standardDev
 
-	def clone(self) -> 'Scc':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'CcCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Scc(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = CcCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Pmonitor_/Ulca_/Scc_/Average.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Pmonitor/Ulca/Scc/Maximum.py`

 * *Files 11% similar despite different names*

```diff
@@ -1,21 +1,21 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.StructBase import StructBase
-from ......Internal.ArgStruct import ArgStruct
-from ...... import repcap
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal.StructBase import StructBase
+from .......Internal.ArgStruct import ArgStruct
+from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class MaximumCls:
+	"""Maximum commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("maximum", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
 			- Reliability: int: No parameter help available
 			- Out_Of_Tolerance: int: No parameter help available
 			- Tx_Power: float: No parameter help available"""
@@ -27,23 +27,23 @@
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tolerance: int = None
 			self.Tx_Power: float = None
 
 	def read(self, secondaryCC=repcap.SecondaryCC.Default) -> ResultData:
-		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:PMONitor:ULCA:SCC<Nr>:AVERage \n
-		Snippet: value: ResultData = driver.multiEval.pmonitor.ulca.scc.average.read(secondaryCC = repcap.SecondaryCC.Default) \n
+		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:PMONitor:ULCA:SCC<Nr>:MAXimum \n
+		Snippet: value: ResultData = driver.lteMeas.multiEval.pmonitor.ulca.scc.maximum.read(secondaryCC = repcap.SecondaryCC.Default) \n
 		No command help available \n
 			:param secondaryCC: optional repeated capability selector. Default value: CC1 (settable in the interface 'Scc')
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		secondaryCC_cmd_val = self._base.get_repcap_cmd_value(secondaryCC, repcap.SecondaryCC)
-		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:PMONitor:ULCA:SCC{secondaryCC_cmd_val}:AVERage?', self.__class__.ResultData())
+		secondaryCC_cmd_val = self._cmd_group.get_repcap_cmd_value(secondaryCC, repcap.SecondaryCC)
+		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:PMONitor:ULCA:SCC{secondaryCC_cmd_val}:MAXimum?', self.__class__.ResultData())
 
 	def fetch(self, secondaryCC=repcap.SecondaryCC.Default) -> ResultData:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:PMONitor:ULCA:SCC<Nr>:AVERage \n
-		Snippet: value: ResultData = driver.multiEval.pmonitor.ulca.scc.average.fetch(secondaryCC = repcap.SecondaryCC.Default) \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:PMONitor:ULCA:SCC<Nr>:MAXimum \n
+		Snippet: value: ResultData = driver.lteMeas.multiEval.pmonitor.ulca.scc.maximum.fetch(secondaryCC = repcap.SecondaryCC.Default) \n
 		No command help available \n
 			:param secondaryCC: optional repeated capability selector. Default value: CC1 (settable in the interface 'Scc')
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		secondaryCC_cmd_val = self._base.get_repcap_cmd_value(secondaryCC, repcap.SecondaryCC)
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:PMONitor:ULCA:SCC{secondaryCC_cmd_val}:AVERage?', self.__class__.ResultData())
+		secondaryCC_cmd_val = self._cmd_group.get_repcap_cmd_value(secondaryCC, repcap.SecondaryCC)
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:PMONitor:ULCA:SCC{secondaryCC_cmd_val}:MAXimum?', self.__class__.ResultData())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Pmonitor_/Ulca_/Scc_/Current.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Sense/LteMeas/MultiEval/Limit/Iemissions/Ulca/Scc.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,49 +1,46 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.StructBase import StructBase
-from ......Internal.ArgStruct import ArgStruct
-from ...... import repcap
+from typing import List
+
+from ........Internal.Core import Core
+from ........Internal.CommandsGroup import CommandsGroup
+from ........Internal.RepeatedCapability import RepeatedCapability
+from ........ import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class SccCls:
+	"""Scc commands group definition. 1 total commands, 0 Subgroups, 1 group commands
+	Repeated Capability: SecondaryCC, default value after init: SecondaryCC.CC1"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("scc", core, parent)
+		self._cmd_group.rep_cap = RepeatedCapability(self._cmd_group.group_name, 'repcap_secondaryCC_get', 'repcap_secondaryCC_set', repcap.SecondaryCC.CC1)
 
-	# noinspection PyTypeChecker
-	class ResultData(StructBase):
-		"""Response structure. Fields: \n
-			- Reliability: int: No parameter help available
-			- Out_Of_Tolerance: int: No parameter help available
-			- Tx_Power: float: No parameter help available"""
-		__meta_args_list = [
-			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_int('Out_Of_Tolerance'),
-			ArgStruct.scalar_float('Tx_Power')]
-
-		def __init__(self):
-			StructBase.__init__(self, self)
-			self.Reliability: int = None
-			self.Out_Of_Tolerance: int = None
-			self.Tx_Power: float = None
-
-	def read(self, secondaryCC=repcap.SecondaryCC.Default) -> ResultData:
-		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:PMONitor:ULCA:SCC<Nr>:CURRent \n
-		Snippet: value: ResultData = driver.multiEval.pmonitor.ulca.scc.current.read(secondaryCC = repcap.SecondaryCC.Default) \n
-		No command help available \n
-			:param secondaryCC: optional repeated capability selector. Default value: CC1 (settable in the interface 'Scc')
-			:return: structure: for return value, see the help for ResultData structure arguments."""
-		secondaryCC_cmd_val = self._base.get_repcap_cmd_value(secondaryCC, repcap.SecondaryCC)
-		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:PMONitor:ULCA:SCC{secondaryCC_cmd_val}:CURRent?', self.__class__.ResultData())
-
-	def fetch(self, secondaryCC=repcap.SecondaryCC.Default) -> ResultData:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:PMONitor:ULCA:SCC<Nr>:CURRent \n
-		Snippet: value: ResultData = driver.multiEval.pmonitor.ulca.scc.current.fetch(secondaryCC = repcap.SecondaryCC.Default) \n
+	def repcap_secondaryCC_set(self, secondaryCC: repcap.SecondaryCC) -> None:
+		"""Repeated Capability default value numeric suffix.
+		This value is used, if you do not explicitely set it in the child set/get methods, or if you leave it to SecondaryCC.Default
+		Default value after init: SecondaryCC.CC1"""
+		self._cmd_group.set_repcap_enum_value(secondaryCC)
+
+	def repcap_secondaryCC_get(self) -> repcap.SecondaryCC:
+		"""Returns the current default repeated capability for the child set/get methods"""
+		# noinspection PyTypeChecker
+		return self._cmd_group.get_repcap_enum_value()
+
+	def get(self, secondaryCC=repcap.SecondaryCC.Default) -> List[float]:
+		"""SCPI: SENSe:LTE:MEASurement<Instance>:MEValuation:LIMit:IEMissions:ULCA:SCC<Nr> \n
+		Snippet: value: List[float] = driver.sense.lteMeas.multiEval.limit.iemissions.ulca.scc.get(secondaryCC = repcap.SecondaryCC.Default) \n
 		No command help available \n
 			:param secondaryCC: optional repeated capability selector. Default value: CC1 (settable in the interface 'Scc')
-			:return: structure: for return value, see the help for ResultData structure arguments."""
-		secondaryCC_cmd_val = self._base.get_repcap_cmd_value(secondaryCC, repcap.SecondaryCC)
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:PMONitor:ULCA:SCC{secondaryCC_cmd_val}:CURRent?', self.__class__.ResultData())
+			:return: power: No help available"""
+		secondaryCC_cmd_val = self._cmd_group.get_repcap_cmd_value(secondaryCC, repcap.SecondaryCC)
+		response = self._core.io.query_bin_or_ascii_float_list(f'SENSe:LTE:MEASurement<Instance>:MEValuation:LIMit:IEMissions:ULCA:SCC{secondaryCC_cmd_val}?')
+		return response
+
+	def clone(self) -> 'SccCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
+		Also copies all the existing default Repeated Capabilities setting,
+		which you can change independently without affecting the original group"""
+		new_group = SccCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
+		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Pmonitor_/Ulca_/Scc_/Maximum.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/CarrierAggregation/Maping/Scc.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,49 +1,45 @@
 from ......Internal.Core import Core
 from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.StructBase import StructBase
-from ......Internal.ArgStruct import ArgStruct
+from ......Internal.Utilities import trim_str_response
+from ......Internal.RepeatedCapability import RepeatedCapability
 from ...... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Maximum:
-	"""Maximum commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class SccCls:
+	"""Scc commands group definition. 1 total commands, 0 Subgroups, 1 group commands
+	Repeated Capability: SecondaryCC, default value after init: SecondaryCC.CC1"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("maximum", core, parent)
+		self._cmd_group = CommandsGroup("scc", core, parent)
+		self._cmd_group.rep_cap = RepeatedCapability(self._cmd_group.group_name, 'repcap_secondaryCC_get', 'repcap_secondaryCC_set', repcap.SecondaryCC.CC1)
 
-	# noinspection PyTypeChecker
-	class ResultData(StructBase):
-		"""Response structure. Fields: \n
-			- Reliability: int: No parameter help available
-			- Out_Of_Tolerance: int: No parameter help available
-			- Tx_Power: float: No parameter help available"""
-		__meta_args_list = [
-			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_int('Out_Of_Tolerance'),
-			ArgStruct.scalar_float('Tx_Power')]
-
-		def __init__(self):
-			StructBase.__init__(self, self)
-			self.Reliability: int = None
-			self.Out_Of_Tolerance: int = None
-			self.Tx_Power: float = None
-
-	def read(self, secondaryCC=repcap.SecondaryCC.Default) -> ResultData:
-		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:PMONitor:ULCA:SCC<Nr>:MAXimum \n
-		Snippet: value: ResultData = driver.multiEval.pmonitor.ulca.scc.maximum.read(secondaryCC = repcap.SecondaryCC.Default) \n
+	def repcap_secondaryCC_set(self, secondaryCC: repcap.SecondaryCC) -> None:
+		"""Repeated Capability default value numeric suffix.
+		This value is used, if you do not explicitely set it in the child set/get methods, or if you leave it to SecondaryCC.Default
+		Default value after init: SecondaryCC.CC1"""
+		self._cmd_group.set_repcap_enum_value(secondaryCC)
+
+	def repcap_secondaryCC_get(self) -> repcap.SecondaryCC:
+		"""Returns the current default repeated capability for the child set/get methods"""
+		# noinspection PyTypeChecker
+		return self._cmd_group.get_repcap_enum_value()
+
+	def get(self, secondaryCC=repcap.SecondaryCC.Default) -> str:
+		"""SCPI: CONFigure:LTE:MEASurement<Instance>:CAGGregation:MAPing:SCC<Carrier> \n
+		Snippet: value: str = driver.configure.lteMeas.carrierAggregation.maping.scc.get(secondaryCC = repcap.SecondaryCC.Default) \n
 		No command help available \n
 			:param secondaryCC: optional repeated capability selector. Default value: CC1 (settable in the interface 'Scc')
-			:return: structure: for return value, see the help for ResultData structure arguments."""
-		secondaryCC_cmd_val = self._base.get_repcap_cmd_value(secondaryCC, repcap.SecondaryCC)
-		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:PMONitor:ULCA:SCC{secondaryCC_cmd_val}:MAXimum?', self.__class__.ResultData())
-
-	def fetch(self, secondaryCC=repcap.SecondaryCC.Default) -> ResultData:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:PMONitor:ULCA:SCC<Nr>:MAXimum \n
-		Snippet: value: ResultData = driver.multiEval.pmonitor.ulca.scc.maximum.fetch(secondaryCC = repcap.SecondaryCC.Default) \n
-		No command help available \n
-			:param secondaryCC: optional repeated capability selector. Default value: CC1 (settable in the interface 'Scc')
-			:return: structure: for return value, see the help for ResultData structure arguments."""
-		secondaryCC_cmd_val = self._base.get_repcap_cmd_value(secondaryCC, repcap.SecondaryCC)
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:PMONitor:ULCA:SCC{secondaryCC_cmd_val}:MAXimum?', self.__class__.ResultData())
+			:return: cc: No help available"""
+		secondaryCC_cmd_val = self._cmd_group.get_repcap_cmd_value(secondaryCC, repcap.SecondaryCC)
+		response = self._core.io.query_str(f'CONFigure:LTE:MEASurement<Instance>:CAGGregation:MAPing:SCC{secondaryCC_cmd_val}?')
+		return trim_str_response(response)
+
+	def clone(self) -> 'SccCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
+		Also copies all the existing default Repeated Capabilities setting,
+		which you can change independently without affecting the original group"""
+		new_group = SccCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
+		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Pmonitor_/Ulca_/Scc_/Minimum.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/RfSettings/Scc/__init__.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,49 +1,42 @@
 from ......Internal.Core import Core
 from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.StructBase import StructBase
-from ......Internal.ArgStruct import ArgStruct
+from ......Internal.RepeatedCapability import RepeatedCapability
 from ...... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Minimum:
-	"""Minimum commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class SccCls:
+	"""Scc commands group definition. 1 total commands, 1 Subgroups, 0 group commands
+	Repeated Capability: SecondaryCC, default value after init: SecondaryCC.CC1"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("minimum", core, parent)
+		self._cmd_group = CommandsGroup("scc", core, parent)
+		self._cmd_group.rep_cap = RepeatedCapability(self._cmd_group.group_name, 'repcap_secondaryCC_get', 'repcap_secondaryCC_set', repcap.SecondaryCC.CC1)
 
-	# noinspection PyTypeChecker
-	class ResultData(StructBase):
-		"""Response structure. Fields: \n
-			- Reliability: int: No parameter help available
-			- Out_Of_Tolerance: int: No parameter help available
-			- Tx_Power: float: No parameter help available"""
-		__meta_args_list = [
-			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_int('Out_Of_Tolerance'),
-			ArgStruct.scalar_float('Tx_Power')]
-
-		def __init__(self):
-			StructBase.__init__(self, self)
-			self.Reliability: int = None
-			self.Out_Of_Tolerance: int = None
-			self.Tx_Power: float = None
-
-	def read(self, secondaryCC=repcap.SecondaryCC.Default) -> ResultData:
-		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:PMONitor:ULCA:SCC<Nr>:MINimum \n
-		Snippet: value: ResultData = driver.multiEval.pmonitor.ulca.scc.minimum.read(secondaryCC = repcap.SecondaryCC.Default) \n
-		No command help available \n
-			:param secondaryCC: optional repeated capability selector. Default value: CC1 (settable in the interface 'Scc')
-			:return: structure: for return value, see the help for ResultData structure arguments."""
-		secondaryCC_cmd_val = self._base.get_repcap_cmd_value(secondaryCC, repcap.SecondaryCC)
-		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:PMONitor:ULCA:SCC{secondaryCC_cmd_val}:MINimum?', self.__class__.ResultData())
-
-	def fetch(self, secondaryCC=repcap.SecondaryCC.Default) -> ResultData:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:PMONitor:ULCA:SCC<Nr>:MINimum \n
-		Snippet: value: ResultData = driver.multiEval.pmonitor.ulca.scc.minimum.fetch(secondaryCC = repcap.SecondaryCC.Default) \n
-		No command help available \n
-			:param secondaryCC: optional repeated capability selector. Default value: CC1 (settable in the interface 'Scc')
-			:return: structure: for return value, see the help for ResultData structure arguments."""
-		secondaryCC_cmd_val = self._base.get_repcap_cmd_value(secondaryCC, repcap.SecondaryCC)
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:PMONitor:ULCA:SCC{secondaryCC_cmd_val}:MINimum?', self.__class__.ResultData())
+	def repcap_secondaryCC_set(self, secondaryCC: repcap.SecondaryCC) -> None:
+		"""Repeated Capability default value numeric suffix.
+		This value is used, if you do not explicitely set it in the child set/get methods, or if you leave it to SecondaryCC.Default
+		Default value after init: SecondaryCC.CC1"""
+		self._cmd_group.set_repcap_enum_value(secondaryCC)
+
+	def repcap_secondaryCC_get(self) -> repcap.SecondaryCC:
+		"""Returns the current default repeated capability for the child set/get methods"""
+		# noinspection PyTypeChecker
+		return self._cmd_group.get_repcap_enum_value()
+
+	@property
+	def frequency(self):
+		"""frequency commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_frequency'):
+			from .Frequency import FrequencyCls
+			self._frequency = FrequencyCls(self._core, self._cmd_group)
+		return self._frequency
+
+	def clone(self) -> 'SccCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
+		Also copies all the existing default Repeated Capabilities setting,
+		which you can change independently without affecting the original group"""
+		new_group = SccCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
+		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/SeMask.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/Prach/Modulation/__init__.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,91 +1,91 @@
-from ...Internal.Core import Core
-from ...Internal.CommandsGroup import CommandsGroup
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class SeMask:
-	"""SeMask commands group definition. 28 total commands, 9 Sub-groups, 0 group commands"""
+class ModulationCls:
+	"""Modulation commands group definition. 21 total commands, 9 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("seMask", core, parent)
+		self._cmd_group = CommandsGroup("modulation", core, parent)
 
 	@property
 	def current(self):
 		"""current commands group. 0 Sub-classes, 3 commands."""
 		if not hasattr(self, '_current'):
-			from .SeMask_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
 	@property
+	def preamble(self):
+		"""preamble commands group. 0 Sub-classes, 2 commands."""
+		if not hasattr(self, '_preamble'):
+			from .Preamble import PreambleCls
+			self._preamble = PreambleCls(self._core, self._cmd_group)
+		return self._preamble
+
+	@property
 	def average(self):
 		"""average commands group. 0 Sub-classes, 3 commands."""
 		if not hasattr(self, '_average'):
-			from .SeMask_.Average import Average
-			self._average = Average(self._core, self._base)
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
 		return self._average
 
 	@property
-	def minimum(self):
-		"""minimum commands group. 0 Sub-classes, 3 commands."""
-		if not hasattr(self, '_minimum'):
-			from .SeMask_.Minimum import Minimum
-			self._minimum = Minimum(self._core, self._base)
-		return self._minimum
-
-	@property
-	def maximum(self):
-		"""maximum commands group. 0 Sub-classes, 3 commands."""
-		if not hasattr(self, '_maximum'):
-			from .SeMask_.Maximum import Maximum
-			self._maximum = Maximum(self._core, self._base)
-		return self._maximum
-
-	@property
 	def extreme(self):
 		"""extreme commands group. 0 Sub-classes, 3 commands."""
 		if not hasattr(self, '_extreme'):
-			from .SeMask_.Extreme import Extreme
-			self._extreme = Extreme(self._core, self._base)
+			from .Extreme import ExtremeCls
+			self._extreme = ExtremeCls(self._core, self._cmd_group)
 		return self._extreme
 
 	@property
 	def standardDev(self):
 		"""standardDev commands group. 0 Sub-classes, 3 commands."""
 		if not hasattr(self, '_standardDev'):
-			from .SeMask_.StandardDev import StandardDev
-			self._standardDev = StandardDev(self._core, self._base)
+			from .StandardDev import StandardDevCls
+			self._standardDev = StandardDevCls(self._core, self._cmd_group)
 		return self._standardDev
 
 	@property
-	def margin(self):
-		"""margin commands group. 4 Sub-classes, 1 commands."""
-		if not hasattr(self, '_margin'):
-			from .SeMask_.Margin import Margin
-			self._margin = Margin(self._core, self._base)
-		return self._margin
-
-	@property
-	def dchType(self):
-		"""dchType commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_dchType'):
-			from .SeMask_.DchType import DchType
-			self._dchType = DchType(self._core, self._base)
-		return self._dchType
-
-	@property
-	def dallocation(self):
-		"""dallocation commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_dallocation'):
-			from .SeMask_.Dallocation import Dallocation
-			self._dallocation = Dallocation(self._core, self._base)
-		return self._dallocation
+	def dpfOffset(self):
+		"""dpfOffset commands group. 1 Sub-classes, 1 commands."""
+		if not hasattr(self, '_dpfOffset'):
+			from .DpfOffset import DpfOffsetCls
+			self._dpfOffset = DpfOffsetCls(self._core, self._cmd_group)
+		return self._dpfOffset
+
+	@property
+	def dsIndex(self):
+		"""dsIndex commands group. 1 Sub-classes, 1 commands."""
+		if not hasattr(self, '_dsIndex'):
+			from .DsIndex import DsIndexCls
+			self._dsIndex = DsIndexCls(self._core, self._cmd_group)
+		return self._dsIndex
+
+	@property
+	def scorrelation(self):
+		"""scorrelation commands group. 1 Sub-classes, 1 commands."""
+		if not hasattr(self, '_scorrelation'):
+			from .Scorrelation import ScorrelationCls
+			self._scorrelation = ScorrelationCls(self._core, self._cmd_group)
+		return self._scorrelation
+
+	@property
+	def nsymbol(self):
+		"""nsymbol commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_nsymbol'):
+			from .Nsymbol import NsymbolCls
+			self._nsymbol = NsymbolCls(self._core, self._cmd_group)
+		return self._nsymbol
 
-	def clone(self) -> 'SeMask':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'ModulationCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = SeMask(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = ModulationCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/SeMask_/Average.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/SeMask/Average.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,26 +1,26 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
-from ....Internal.StructBase import StructBase
-from ....Internal.ArgStruct import ArgStruct
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
+from .....Internal.StructBase import StructBase
+from .....Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class AverageCls:
+	"""Average commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Out_Of_Tolerance: int: Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for spectrum emission measurements exceeding the specified spectrum emission mask limits.
+			- Reliability: int: 'Reliability indicator'
+			- Out_Of_Tolerance: int: Out of tolerance result, i.e. the percentage of measurement intervals of the statistic count for spectrum emission measurements exceeding the specified spectrum emission mask limits.
 			- Obw: float: Occupied bandwidth
 			- Tx_Power: float: Total TX power in the slot over all component carriers"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
 			ArgStruct.scalar_float('Obw'),
 			ArgStruct.scalar_float('Tx_Power')]
@@ -30,51 +30,51 @@
 			self.Reliability: int = None
 			self.Out_Of_Tolerance: int = None
 			self.Obw: float = None
 			self.Tx_Power: float = None
 
 	def read(self) -> ResultData:
 		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:SEMask:AVERage \n
-		Snippet: value: ResultData = driver.multiEval.seMask.average.read() \n
-		Return the current, average and standard deviation single value results of the spectrum emission measurement. The values
+		Snippet: value: ResultData = driver.lteMeas.multiEval.seMask.average.read() \n
+		Return the current, average and standard deviation single-value results of the spectrum emission measurement. The values
 		described below are returned by FETCh and READ commands. CALCulate commands return limit check results instead, one value
 		for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
 		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:SEMask:AVERage?', self.__class__.ResultData())
 
 	def fetch(self) -> ResultData:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:SEMask:AVERage \n
-		Snippet: value: ResultData = driver.multiEval.seMask.average.fetch() \n
-		Return the current, average and standard deviation single value results of the spectrum emission measurement. The values
+		Snippet: value: ResultData = driver.lteMeas.multiEval.seMask.average.fetch() \n
+		Return the current, average and standard deviation single-value results of the spectrum emission measurement. The values
 		described below are returned by FETCh and READ commands. CALCulate commands return limit check results instead, one value
 		for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
 		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:SEMask:AVERage?', self.__class__.ResultData())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Out_Of_Tolerance: int: Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for spectrum emission measurements exceeding the specified spectrum emission mask limits.
-			- Obw: float: Occupied bandwidth
-			- Tx_Power: float: Total TX power in the slot over all component carriers"""
+			- Reliability: int: 'Reliability indicator'
+			- Out_Of_Tolerance: int: Out of tolerance result, i.e. the percentage of measurement intervals of the statistic count for spectrum emission measurements exceeding the specified spectrum emission mask limits.
+			- Obw: float or bool: Occupied bandwidth
+			- Tx_Power: float or bool: Total TX power in the slot over all component carriers"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
-			ArgStruct.scalar_float('Obw'),
-			ArgStruct.scalar_float('Tx_Power')]
+			ArgStruct.scalar_float_ext('Obw'),
+			ArgStruct.scalar_float_ext('Tx_Power')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tolerance: int = None
-			self.Obw: float = None
-			self.Tx_Power: float = None
+			self.Obw: float or bool = None
+			self.Tx_Power: float or bool = None
 
 	def calculate(self) -> CalculateStruct:
 		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:SEMask:AVERage \n
-		Snippet: value: CalculateStruct = driver.multiEval.seMask.average.calculate() \n
-		Return the current, average and standard deviation single value results of the spectrum emission measurement. The values
+		Snippet: value: CalculateStruct = driver.lteMeas.multiEval.seMask.average.calculate() \n
+		Return the current, average and standard deviation single-value results of the spectrum emission measurement. The values
 		described below are returned by FETCh and READ commands. CALCulate commands return limit check results instead, one value
 		for each result listed below. \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
 		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:SEMask:AVERage?', self.__class__.CalculateStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/SeMask_/Current.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/SeMask/StandardDev.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,26 +1,26 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
-from ....Internal.StructBase import StructBase
-from ....Internal.ArgStruct import ArgStruct
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
+from .....Internal.StructBase import StructBase
+from .....Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class StandardDevCls:
+	"""StandardDev commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("standardDev", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Out_Of_Tolerance: int: Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for spectrum emission measurements exceeding the specified spectrum emission mask limits.
+			- Reliability: int: 'Reliability indicator'
+			- Out_Of_Tolerance: int: Out of tolerance result, i.e. the percentage of measurement intervals of the statistic count for spectrum emission measurements exceeding the specified spectrum emission mask limits.
 			- Obw: float: Occupied bandwidth
 			- Tx_Power: float: Total TX power in the slot over all component carriers"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
 			ArgStruct.scalar_float('Obw'),
 			ArgStruct.scalar_float('Tx_Power')]
@@ -29,52 +29,50 @@
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tolerance: int = None
 			self.Obw: float = None
 			self.Tx_Power: float = None
 
 	def read(self) -> ResultData:
-		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:SEMask:CURRent \n
-		Snippet: value: ResultData = driver.multiEval.seMask.current.read() \n
-		Return the current, average and standard deviation single value results of the spectrum emission measurement. The values
+		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:SEMask:SDEViation \n
+		Snippet: value: ResultData = driver.lteMeas.multiEval.seMask.standardDev.read() \n
+		Return the current, average and standard deviation single-value results of the spectrum emission measurement. The values
 		described below are returned by FETCh and READ commands. CALCulate commands return limit check results instead, one value
 		for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:SEMask:CURRent?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:SEMask:SDEViation?', self.__class__.ResultData())
 
 	def fetch(self) -> ResultData:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:SEMask:CURRent \n
-		Snippet: value: ResultData = driver.multiEval.seMask.current.fetch() \n
-		Return the current, average and standard deviation single value results of the spectrum emission measurement. The values
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:SEMask:SDEViation \n
+		Snippet: value: ResultData = driver.lteMeas.multiEval.seMask.standardDev.fetch() \n
+		Return the current, average and standard deviation single-value results of the spectrum emission measurement. The values
 		described below are returned by FETCh and READ commands. CALCulate commands return limit check results instead, one value
 		for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:SEMask:CURRent?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:SEMask:SDEViation?', self.__class__.ResultData())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Out_Of_Tolerance: int: Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for spectrum emission measurements exceeding the specified spectrum emission mask limits.
-			- Obw: float: Occupied bandwidth
-			- Tx_Power: float: Total TX power in the slot over all component carriers"""
+			- Reliability: int: No parameter help available
+			- Out_Of_Tolerance: int: No parameter help available
+			- Obw: float or bool: No parameter help available
+			- Tx_Power: float or bool: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
-			ArgStruct.scalar_float('Obw'),
-			ArgStruct.scalar_float('Tx_Power')]
+			ArgStruct.scalar_float_ext('Obw'),
+			ArgStruct.scalar_float_ext('Tx_Power')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tolerance: int = None
-			self.Obw: float = None
-			self.Tx_Power: float = None
+			self.Obw: float or bool = None
+			self.Tx_Power: float or bool = None
 
 	def calculate(self) -> CalculateStruct:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:SEMask:CURRent \n
-		Snippet: value: CalculateStruct = driver.multiEval.seMask.current.calculate() \n
-		Return the current, average and standard deviation single value results of the spectrum emission measurement. The values
-		described below are returned by FETCh and READ commands. CALCulate commands return limit check results instead, one value
-		for each result listed below. \n
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:SEMask:SDEViation \n
+		Snippet: value: CalculateStruct = driver.lteMeas.multiEval.seMask.standardDev.calculate() \n
+		No command help available \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:SEMask:CURRent?', self.__class__.CalculateStruct())
+		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:SEMask:SDEViation?', self.__class__.CalculateStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/SeMask_/Dallocation.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/InbandEmission/Scc/Margin/Current/RbIndex.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,39 +1,37 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
-from ....Internal.StructBase import StructBase
-from ....Internal.ArgStruct import ArgStruct
+from ........Internal.Core import Core
+from ........Internal.CommandsGroup import CommandsGroup
+from ........Internal.StructBase import StructBase
+from ........Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Dallocation:
-	"""Dallocation commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class RbIndexCls:
+	"""RbIndex commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("dallocation", core, parent)
+		self._cmd_group = CommandsGroup("rbIndex", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Nr_Res_Blocks: int: Number of allocated resource blocks
-			- Offset_Res_Blocks: int: Offset of the first allocated resource block from the edge of the allocated UL transmission bandwidth"""
+			- Reliability: int: No parameter help available
+			- Out_Of_Tolerance: int: No parameter help available
+			- Rb_Index: int: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_int('Nr_Res_Blocks'),
-			ArgStruct.scalar_int('Offset_Res_Blocks')]
+			ArgStruct.scalar_int('Out_Of_Tolerance'),
+			ArgStruct.scalar_int('Rb_Index')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
-			self.Nr_Res_Blocks: int = None
-			self.Offset_Res_Blocks: int = None
+			self.Out_Of_Tolerance: int = None
+			self.Rb_Index: int = None
 
 	def fetch(self) -> FetchStruct:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:SEMask:DALLocation \n
-		Snippet: value: FetchStruct = driver.multiEval.seMask.dallocation.fetch() \n
-		Returns the detected allocation for the measured slot. If the same slot is measured by the individual measurements, all
-		commands yield the same result. If different statistic counts are defined for the modulation, ACLR and spectrum emission
-		mask measurements, different slots can be measured and different results can be returned by the individual commands. \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:IEMission:SCC:MARGin:CURRent:RBINdex \n
+		Snippet: value: FetchStruct = driver.lteMeas.multiEval.inbandEmission.scc.margin.current.rbIndex.fetch() \n
+		No command help available \n
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:SEMask:DALLocation?', self.__class__.FetchStruct())
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:IEMission:SCC:MARGin:CURRent:RBINdex?', self.__class__.FetchStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/SeMask_/DchType.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Modulation/DchType.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,28 +1,28 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
-from ....Internal import Conversions
-from ....Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ....Internal.Types import DataType
-from .... import enums
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
+from .....Internal import Conversions
+from .....Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .....Internal.Types import DataType
+from ..... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class DchType:
-	"""DchType commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class DchTypeCls:
+	"""DchType commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("dchType", core, parent)
+		self._cmd_group = CommandsGroup("dchType", core, parent)
 
 	# noinspection PyTypeChecker
 	def fetch(self) -> enums.UplinkChannelType:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:SEMask:DCHType \n
-		Snippet: value: enums.UplinkChannelType = driver.multiEval.seMask.dchType.fetch() \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:MODulation:DCHType \n
+		Snippet: value: enums.UplinkChannelType = driver.lteMeas.multiEval.modulation.dchType.fetch() \n
 		Returns the uplink channel type for the measured slot. If the same slot is measured by the individual measurements, all
 		commands yield the same result. If different statistic counts are defined for the modulation, ACLR and spectrum emission
 		mask measurements, different slots can be measured and different results can be returned by the individual commands. \n
 		Suppressed linked return values: reliability \n
 			:return: channel_type: No help available"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_str_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:SEMask:DCHType?', suppressed)
+		response = self._core.io.query_str_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:MODulation:DCHType?', suppressed)
 		return Conversions.str_to_scalar_enum(response, enums.UplinkChannelType)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/SeMask_/Extreme.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/SeMask/Extreme.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,26 +1,26 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
-from ....Internal.StructBase import StructBase
-from ....Internal.ArgStruct import ArgStruct
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
+from .....Internal.StructBase import StructBase
+from .....Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Extreme:
-	"""Extreme commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class ExtremeCls:
+	"""Extreme commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("extreme", core, parent)
+		self._cmd_group = CommandsGroup("extreme", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Out_Of_Tolerance: int: Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for spectrum emission measurements exceeding the specified spectrum emission mask limits.
+			- Reliability: int: 'Reliability indicator'
+			- Out_Of_Tolerance: int: Out of tolerance result, i.e. the percentage of measurement intervals of the statistic count for spectrum emission measurements exceeding the specified spectrum emission mask limits.
 			- Obw: float: Occupied bandwidth
 			- Tx_Power_Min: float: Minimum total TX power in the slot
 			- Tx_Power_Max: float: Maximum total TX power in the slot"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
 			ArgStruct.scalar_float('Obw'),
@@ -33,51 +33,51 @@
 			self.Out_Of_Tolerance: int = None
 			self.Obw: float = None
 			self.Tx_Power_Min: float = None
 			self.Tx_Power_Max: float = None
 
 	def read(self) -> ResultData:
 		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:SEMask:EXTReme \n
-		Snippet: value: ResultData = driver.multiEval.seMask.extreme.read() \n
-		Return the extreme single value results of the spectrum emission measurement. The values described below are returned by
+		Snippet: value: ResultData = driver.lteMeas.multiEval.seMask.extreme.read() \n
+		Return the extreme single-value results of the spectrum emission measurement. The values described below are returned by
 		FETCh and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
 		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:SEMask:EXTReme?', self.__class__.ResultData())
 
 	def fetch(self) -> ResultData:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:SEMask:EXTReme \n
-		Snippet: value: ResultData = driver.multiEval.seMask.extreme.fetch() \n
-		Return the extreme single value results of the spectrum emission measurement. The values described below are returned by
+		Snippet: value: ResultData = driver.lteMeas.multiEval.seMask.extreme.fetch() \n
+		Return the extreme single-value results of the spectrum emission measurement. The values described below are returned by
 		FETCh and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
 		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:SEMask:EXTReme?', self.__class__.ResultData())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Out_Of_Tolerance: int: Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for spectrum emission measurements exceeding the specified spectrum emission mask limits.
-			- Obw: float: Occupied bandwidth
-			- Tx_Power_Min: float: Minimum total TX power in the slot
-			- Tx_Power_Max: float: Maximum total TX power in the slot"""
+			- Reliability: int: 'Reliability indicator'
+			- Out_Of_Tolerance: int: Out of tolerance result, i.e. the percentage of measurement intervals of the statistic count for spectrum emission measurements exceeding the specified spectrum emission mask limits.
+			- Obw: float or bool: Occupied bandwidth
+			- Tx_Power_Min: float or bool: Minimum total TX power in the slot
+			- Tx_Power_Max: float or bool: Maximum total TX power in the slot"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
-			ArgStruct.scalar_float('Obw'),
-			ArgStruct.scalar_float('Tx_Power_Min'),
-			ArgStruct.scalar_float('Tx_Power_Max')]
+			ArgStruct.scalar_float_ext('Obw'),
+			ArgStruct.scalar_float_ext('Tx_Power_Min'),
+			ArgStruct.scalar_float_ext('Tx_Power_Max')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tolerance: int = None
-			self.Obw: float = None
-			self.Tx_Power_Min: float = None
-			self.Tx_Power_Max: float = None
+			self.Obw: float or bool = None
+			self.Tx_Power_Min: float or bool = None
+			self.Tx_Power_Max: float or bool = None
 
 	def calculate(self) -> CalculateStruct:
 		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:SEMask:EXTReme \n
-		Snippet: value: CalculateStruct = driver.multiEval.seMask.extreme.calculate() \n
-		Return the extreme single value results of the spectrum emission measurement. The values described below are returned by
+		Snippet: value: CalculateStruct = driver.lteMeas.multiEval.seMask.extreme.calculate() \n
+		Return the extreme single-value results of the spectrum emission measurement. The values described below are returned by
 		FETCh and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
 		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:SEMask:EXTReme?', self.__class__.CalculateStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/SeMask_/Margin.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Segment/SeMask/Margin/__init__.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,95 +1,104 @@
 from typing import List
 
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
-from ....Internal.Types import DataType
-from ....Internal.StructBase import StructBase
-from ....Internal.ArgStruct import ArgStruct
+from ........Internal.Core import Core
+from ........Internal.CommandsGroup import CommandsGroup
+from ........Internal.Types import DataType
+from ........Internal.StructBase import StructBase
+from ........Internal.ArgStruct import ArgStruct
+from ........ import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Margin:
-	"""Margin commands group definition. 8 total commands, 4 Sub-groups, 1 group commands"""
+class MarginCls:
+	"""Margin commands group definition. 8 total commands, 4 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("margin", core, parent)
+		self._cmd_group = CommandsGroup("margin", core, parent)
 
 	@property
 	def all(self):
 		"""all commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_all'):
-			from .Margin_.All import All
-			self._all = All(self._core, self._base)
+			from .All import AllCls
+			self._all = AllCls(self._core, self._cmd_group)
 		return self._all
 
 	@property
 	def current(self):
 		"""current commands group. 2 Sub-classes, 0 commands."""
 		if not hasattr(self, '_current'):
-			from .Margin_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
 	@property
 	def average(self):
 		"""average commands group. 2 Sub-classes, 0 commands."""
 		if not hasattr(self, '_average'):
-			from .Margin_.Average import Average
-			self._average = Average(self._core, self._base)
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
 		return self._average
 
 	@property
 	def minimum(self):
 		"""minimum commands group. 2 Sub-classes, 0 commands."""
 		if not hasattr(self, '_minimum'):
-			from .Margin_.Minimum import Minimum
-			self._minimum = Minimum(self._core, self._base)
+			from .Minimum import MinimumCls
+			self._minimum = MinimumCls(self._core, self._cmd_group)
 		return self._minimum
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
 			- Reliability: int: No parameter help available
+			- Seg_Reliability: int: No parameter help available
+			- Statist_Expired: int: No parameter help available
 			- Out_Of_Tolerance: int: No parameter help available
 			- Margin_Curr_Neg: List[float]: No parameter help available
 			- Margin_Curr_Pos: List[float]: No parameter help available
 			- Margin_Avg_Neg: List[float]: No parameter help available
 			- Margin_Avg_Pos: List[float]: No parameter help available
 			- Margin_Min_Neg: List[float]: No parameter help available
 			- Margin_Min_Pos: List[float]: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
+			ArgStruct.scalar_int('Seg_Reliability'),
+			ArgStruct.scalar_int('Statist_Expired'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
 			ArgStruct('Margin_Curr_Neg', DataType.FloatList, None, False, False, 10),
 			ArgStruct('Margin_Curr_Pos', DataType.FloatList, None, False, False, 10),
 			ArgStruct('Margin_Avg_Neg', DataType.FloatList, None, False, False, 10),
 			ArgStruct('Margin_Avg_Pos', DataType.FloatList, None, False, False, 10),
 			ArgStruct('Margin_Min_Neg', DataType.FloatList, None, False, False, 10),
 			ArgStruct('Margin_Min_Pos', DataType.FloatList, None, False, False, 10)]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
+			self.Seg_Reliability: int = None
+			self.Statist_Expired: int = None
 			self.Out_Of_Tolerance: int = None
 			self.Margin_Curr_Neg: List[float] = None
 			self.Margin_Curr_Pos: List[float] = None
 			self.Margin_Avg_Neg: List[float] = None
 			self.Margin_Avg_Pos: List[float] = None
 			self.Margin_Min_Neg: List[float] = None
 			self.Margin_Min_Pos: List[float] = None
 
-	def fetch(self) -> FetchStruct:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:SEMask:MARGin \n
-		Snippet: value: FetchStruct = driver.multiEval.seMask.margin.fetch() \n
+	def fetch(self, segment=repcap.Segment.Default) -> FetchStruct:
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent<nr>:SEMask:MARGin \n
+		Snippet: value: FetchStruct = driver.lteMeas.multiEval.listPy.segment.seMask.margin.fetch(segment = repcap.Segment.Default) \n
 		No command help available \n
+			:param segment: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Segment')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:SEMask:MARGin?', self.__class__.FetchStruct())
+		segment_cmd_val = self._cmd_group.get_repcap_cmd_value(segment, repcap.Segment)
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:LIST:SEGMent{segment_cmd_val}:SEMask:MARGin?', self.__class__.FetchStruct())
 
-	def clone(self) -> 'Margin':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'MarginCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Margin(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = MarginCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/SeMask_/Margin_/All.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/SeMask/Margin/All.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,29 +1,29 @@
 from typing import List
 
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
-from .....Internal.Types import DataType
-from .....Internal.StructBase import StructBase
-from .....Internal.ArgStruct import ArgStruct
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal.Types import DataType
+from ......Internal.StructBase import StructBase
+from ......Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class All:
-	"""All commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class AllCls:
+	"""All commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("all", core, parent)
+		self._cmd_group = CommandsGroup("all", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Out_Of_Tolerance: int: Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for spectrum emission measurements exceeding the specified spectrum emission mask limits.
+			- Reliability: int: 'Reliability indicator'
+			- Out_Of_Tolerance: int: Out of tolerance result, i.e. the percentage of measurement intervals of the statistic count for spectrum emission measurements exceeding the specified spectrum emission mask limits.
 			- Margin_Curr_Neg: List[float]: No parameter help available
 			- Margin_Curr_Pos: List[float]: No parameter help available
 			- Margin_Avg_Neg: List[float]: No parameter help available
 			- Margin_Avg_Pos: List[float]: No parameter help available
 			- Margin_Min_Neg: List[float]: No parameter help available
 			- Margin_Min_Pos: List[float]: No parameter help available"""
 		__meta_args_list = [
@@ -45,14 +45,14 @@
 			self.Margin_Avg_Neg: List[float] = None
 			self.Margin_Avg_Pos: List[float] = None
 			self.Margin_Min_Neg: List[float] = None
 			self.Margin_Min_Pos: List[float] = None
 
 	def fetch(self) -> FetchStruct:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:SEMask:MARGin:ALL \n
-		Snippet: value: FetchStruct = driver.multiEval.seMask.margin.all.fetch() \n
+		Snippet: value: FetchStruct = driver.lteMeas.multiEval.seMask.margin.all.fetch() \n
 		Returns spectrum emission mask margin results. A negative margin indicates that the trace is located above the limit line,
 		i.e. the limit is exceeded. Results are provided for the current, average and maximum traces. For each trace, 24 values
 		related to the negative (Neg) and positive (Pos) offset frequencies of emission mask areas 1 to 12 are provided.
 		For inactive areas, NCAP is returned. \n
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
 		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:SEMask:MARGin:ALL?', self.__class__.FetchStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/SeMask_/Margin_/Average.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Merror/Dmrs/__init__.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,35 +1,35 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
+from ........Internal.Core import Core
+from ........Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 2 total commands, 2 Sub-groups, 0 group commands"""
+class DmrsCls:
+	"""Dmrs commands group definition. 14 total commands, 2 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("dmrs", core, parent)
 
 	@property
-	def negativ(self):
-		"""negativ commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_negativ'):
-			from .Average_.Negativ import Negativ
-			self._negativ = Negativ(self._core, self._base)
-		return self._negativ
+	def low(self):
+		"""low commands group. 4 Sub-classes, 0 commands."""
+		if not hasattr(self, '_low'):
+			from .Low import LowCls
+			self._low = LowCls(self._core, self._cmd_group)
+		return self._low
 
 	@property
-	def positiv(self):
-		"""positiv commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_positiv'):
-			from .Average_.Positiv import Positiv
-			self._positiv = Positiv(self._core, self._base)
-		return self._positiv
+	def high(self):
+		"""high commands group. 4 Sub-classes, 0 commands."""
+		if not hasattr(self, '_high'):
+			from .High import HighCls
+			self._high = HighCls(self._core, self._cmd_group)
+		return self._high
 
-	def clone(self) -> 'Average':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'DmrsCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Average(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = DmrsCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/SeMask_/Margin_/Average_/Negativ.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/SeMask/Margin/Average/Negativ.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,29 +1,29 @@
 from typing import List
 
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.Types import DataType
-from ......Internal.StructBase import StructBase
-from ......Internal.ArgStruct import ArgStruct
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal.Types import DataType
+from .......Internal.StructBase import StructBase
+from .......Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Negativ:
-	"""Negativ commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class NegativCls:
+	"""Negativ commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("negativ", core, parent)
+		self._cmd_group = CommandsGroup("negativ", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Out_Of_Tolerance: int: Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for spectrum emission measurements exceeding the specified spectrum emission mask limits.
+			- Reliability: int: 'Reliability indicator'
+			- Out_Of_Tolerance: int: Out of tolerance result, i.e. the percentage of measurement intervals of the statistic count for spectrum emission measurements exceeding the specified spectrum emission mask limits.
 			- Margin_Avg_Neg_X: List[float]: No parameter help available
 			- Margin_Avg_Neg_Y: List[float]: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
 			ArgStruct('Margin_Avg_Neg_X', DataType.FloatList, None, False, True, 1),
 			ArgStruct('Margin_Avg_Neg_Y', DataType.FloatList, None, False, True, 1)]
@@ -33,15 +33,15 @@
 			self.Reliability: int = None
 			self.Out_Of_Tolerance: int = None
 			self.Margin_Avg_Neg_X: List[float] = None
 			self.Margin_Avg_Neg_Y: List[float] = None
 
 	def fetch(self) -> FetchStruct:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:SEMask:MARGin:AVERage:NEGativ \n
-		Snippet: value: FetchStruct = driver.multiEval.seMask.margin.average.negativ.fetch() \n
+		Snippet: value: FetchStruct = driver.lteMeas.multiEval.seMask.margin.average.negativ.fetch() \n
 		Returns spectrum emission mask margin results. A negative margin indicates that the trace is located above the limit line,
 		i.e. the limit is exceeded. The individual commands provide results for the CURRent, AVERage and maximum traces
-		(resulting in MINimum margins) . For each trace, the X and Y values of the margins for emission mask areas 1 to 12 are
+		(resulting in MINimum margins) . For each trace, the x- and y-values of the margins for emission mask areas 1 to 12 are
 		provided for NEGative and POSitive offset frequencies. For inactive areas, NCAP is returned.
 		Returned sequence: <Reliability>, <OutOfTolerance>, {<MarginX>, <MarginY>}area1, {...}area2, ..., {...}area12 \n
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
 		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:SEMask:MARGin:AVERage:NEGativ?', self.__class__.FetchStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/SeMask_/Margin_/Average_/Positiv.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/SeMask/Margin/Average/Positiv.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,29 +1,29 @@
 from typing import List
 
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.Types import DataType
-from ......Internal.StructBase import StructBase
-from ......Internal.ArgStruct import ArgStruct
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal.Types import DataType
+from .......Internal.StructBase import StructBase
+from .......Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Positiv:
-	"""Positiv commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class PositivCls:
+	"""Positiv commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("positiv", core, parent)
+		self._cmd_group = CommandsGroup("positiv", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Out_Of_Tolerance: int: Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for spectrum emission measurements exceeding the specified spectrum emission mask limits.
+			- Reliability: int: 'Reliability indicator'
+			- Out_Of_Tolerance: int: Out of tolerance result, i.e. the percentage of measurement intervals of the statistic count for spectrum emission measurements exceeding the specified spectrum emission mask limits.
 			- Margin_Avg_Pos_X: List[float]: No parameter help available
 			- Margin_Avg_Pos_Y: List[float]: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
 			ArgStruct('Margin_Avg_Pos_X', DataType.FloatList, None, False, True, 1),
 			ArgStruct('Margin_Avg_Pos_Y', DataType.FloatList, None, False, True, 1)]
@@ -33,15 +33,15 @@
 			self.Reliability: int = None
 			self.Out_Of_Tolerance: int = None
 			self.Margin_Avg_Pos_X: List[float] = None
 			self.Margin_Avg_Pos_Y: List[float] = None
 
 	def fetch(self) -> FetchStruct:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:SEMask:MARGin:AVERage:POSitiv \n
-		Snippet: value: FetchStruct = driver.multiEval.seMask.margin.average.positiv.fetch() \n
+		Snippet: value: FetchStruct = driver.lteMeas.multiEval.seMask.margin.average.positiv.fetch() \n
 		Returns spectrum emission mask margin results. A negative margin indicates that the trace is located above the limit line,
 		i.e. the limit is exceeded. The individual commands provide results for the CURRent, AVERage and maximum traces
-		(resulting in MINimum margins) . For each trace, the X and Y values of the margins for emission mask areas 1 to 12 are
+		(resulting in MINimum margins) . For each trace, the x- and y-values of the margins for emission mask areas 1 to 12 are
 		provided for NEGative and POSitive offset frequencies. For inactive areas, NCAP is returned.
 		Returned sequence: <Reliability>, <OutOfTolerance>, {<MarginX>, <MarginY>}area1, {...}area2, ..., {...}area12 \n
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
 		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:SEMask:MARGin:AVERage:POSitiv?', self.__class__.FetchStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/SeMask_/Margin_/Current.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/EsFlatness/ScIndex/__init__.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,35 +1,35 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 2 total commands, 2 Sub-groups, 0 group commands"""
+class ScIndexCls:
+	"""ScIndex commands group definition. 2 total commands, 2 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("scIndex", core, parent)
 
 	@property
-	def negativ(self):
-		"""negativ commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_negativ'):
-			from .Current_.Negativ import Negativ
-			self._negativ = Negativ(self._core, self._base)
-		return self._negativ
+	def minimum(self):
+		"""minimum commands group. 1 Sub-classes, 0 commands."""
+		if not hasattr(self, '_minimum'):
+			from .Minimum import MinimumCls
+			self._minimum = MinimumCls(self._core, self._cmd_group)
+		return self._minimum
 
 	@property
-	def positiv(self):
-		"""positiv commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_positiv'):
-			from .Current_.Positiv import Positiv
-			self._positiv = Positiv(self._core, self._base)
-		return self._positiv
+	def maximum(self):
+		"""maximum commands group. 1 Sub-classes, 0 commands."""
+		if not hasattr(self, '_maximum'):
+			from .Maximum import MaximumCls
+			self._maximum = MaximumCls(self._core, self._cmd_group)
+		return self._maximum
 
-	def clone(self) -> 'Current':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'ScIndexCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Current(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = ScIndexCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/SeMask_/Margin_/Current_/Negativ.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Trace/Iq/High.py`

 * *Files 26% similar despite different names*

```diff
@@ -4,44 +4,39 @@
 from ......Internal.CommandsGroup import CommandsGroup
 from ......Internal.Types import DataType
 from ......Internal.StructBase import StructBase
 from ......Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Negativ:
-	"""Negativ commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class HighCls:
+	"""High commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("negativ", core, parent)
+		self._cmd_group = CommandsGroup("high", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Out_Of_Tolerance: int: Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for spectrum emission measurements exceeding the specified spectrum emission mask limits.
-			- Margin_Curr_Neg_X: List[float]: No parameter help available
-			- Margin_Curr_Neg_Y: List[float]: No parameter help available"""
+			- Reliability: int: 'Reliability indicator'
+			- Iphase: List[float]: Normalized I amplitude
+			- Qphase: List[float]: Normalized Q amplitude"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_int('Out_Of_Tolerance'),
-			ArgStruct('Margin_Curr_Neg_X', DataType.FloatList, None, False, True, 1),
-			ArgStruct('Margin_Curr_Neg_Y', DataType.FloatList, None, False, True, 1)]
+			ArgStruct('Iphase', DataType.FloatList, None, False, True, 1),
+			ArgStruct('Qphase', DataType.FloatList, None, False, True, 1)]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
-			self.Out_Of_Tolerance: int = None
-			self.Margin_Curr_Neg_X: List[float] = None
-			self.Margin_Curr_Neg_Y: List[float] = None
+			self.Iphase: List[float] = None
+			self.Qphase: List[float] = None
 
 	def fetch(self) -> FetchStruct:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:SEMask:MARGin:CURRent:NEGativ \n
-		Snippet: value: FetchStruct = driver.multiEval.seMask.margin.current.negativ.fetch() \n
-		Returns spectrum emission mask margin results. A negative margin indicates that the trace is located above the limit line,
-		i.e. the limit is exceeded. The individual commands provide results for the CURRent, AVERage and maximum traces
-		(resulting in MINimum margins) . For each trace, the X and Y values of the margins for emission mask areas 1 to 12 are
-		provided for NEGative and POSitive offset frequencies. For inactive areas, NCAP is returned.
-		Returned sequence: <Reliability>, <OutOfTolerance>, {<MarginX>, <MarginY>}area1, {...}area2, ..., {...}area12 \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:TRACe:IQ:HIGH \n
+		Snippet: value: FetchStruct = driver.lteMeas.multiEval.trace.iq.high.fetch() \n
+		Returns the results in the I/Q constellation diagram for low and high EVM window position. There is one pair of values
+		per modulation symbol. The results are returned in the following order: <Reliability>, {<IPhase>, <QPhase>}symbol 1, ...,
+		{<IPhase>, <QPhase>}symbol n See also 'Square I/Q Constellation' \n
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:SEMask:MARGin:CURRent:NEGativ?', self.__class__.FetchStruct())
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:TRACe:IQ:HIGH?', self.__class__.FetchStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/SeMask_/Margin_/Current_/Positiv.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/SeMask/Margin/Minimum/Positiv.py`

 * *Files 23% similar despite different names*

```diff
@@ -1,47 +1,47 @@
 from typing import List
 
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.Types import DataType
-from ......Internal.StructBase import StructBase
-from ......Internal.ArgStruct import ArgStruct
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal.Types import DataType
+from .......Internal.StructBase import StructBase
+from .......Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Positiv:
-	"""Positiv commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class PositivCls:
+	"""Positiv commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("positiv", core, parent)
+		self._cmd_group = CommandsGroup("positiv", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Out_Of_Tolerance: int: Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for spectrum emission measurements exceeding the specified spectrum emission mask limits.
-			- Margin_Curr_Pos_X: List[float]: No parameter help available
-			- Margin_Curr_Pos_Y: List[float]: No parameter help available"""
+			- Reliability: int: 'Reliability indicator'
+			- Out_Of_Tolerance: int: Out of tolerance result, i.e. the percentage of measurement intervals of the statistic count for spectrum emission measurements exceeding the specified spectrum emission mask limits.
+			- Margin_Min_Pos_X: List[float]: No parameter help available
+			- Margin_Min_Pos_Y: List[float]: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
-			ArgStruct('Margin_Curr_Pos_X', DataType.FloatList, None, False, True, 1),
-			ArgStruct('Margin_Curr_Pos_Y', DataType.FloatList, None, False, True, 1)]
+			ArgStruct('Margin_Min_Pos_X', DataType.FloatList, None, False, True, 1),
+			ArgStruct('Margin_Min_Pos_Y', DataType.FloatList, None, False, True, 1)]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tolerance: int = None
-			self.Margin_Curr_Pos_X: List[float] = None
-			self.Margin_Curr_Pos_Y: List[float] = None
+			self.Margin_Min_Pos_X: List[float] = None
+			self.Margin_Min_Pos_Y: List[float] = None
 
 	def fetch(self) -> FetchStruct:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:SEMask:MARGin:CURRent:POSitiv \n
-		Snippet: value: FetchStruct = driver.multiEval.seMask.margin.current.positiv.fetch() \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:SEMask:MARGin:MINimum:POSitiv \n
+		Snippet: value: FetchStruct = driver.lteMeas.multiEval.seMask.margin.minimum.positiv.fetch() \n
 		Returns spectrum emission mask margin results. A negative margin indicates that the trace is located above the limit line,
 		i.e. the limit is exceeded. The individual commands provide results for the CURRent, AVERage and maximum traces
-		(resulting in MINimum margins) . For each trace, the X and Y values of the margins for emission mask areas 1 to 12 are
+		(resulting in MINimum margins) . For each trace, the x- and y-values of the margins for emission mask areas 1 to 12 are
 		provided for NEGative and POSitive offset frequencies. For inactive areas, NCAP is returned.
 		Returned sequence: <Reliability>, <OutOfTolerance>, {<MarginX>, <MarginY>}area1, {...}area2, ..., {...}area12 \n
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:SEMask:MARGin:CURRent:POSitiv?', self.__class__.FetchStruct())
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:SEMask:MARGin:MINimum:POSitiv?', self.__class__.FetchStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/SeMask_/Margin_/Minimum.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Perror/Dmrs/__init__.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,35 +1,35 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
+from ........Internal.Core import Core
+from ........Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Minimum:
-	"""Minimum commands group definition. 2 total commands, 2 Sub-groups, 0 group commands"""
+class DmrsCls:
+	"""Dmrs commands group definition. 14 total commands, 2 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("minimum", core, parent)
+		self._cmd_group = CommandsGroup("dmrs", core, parent)
 
 	@property
-	def negativ(self):
-		"""negativ commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_negativ'):
-			from .Minimum_.Negativ import Negativ
-			self._negativ = Negativ(self._core, self._base)
-		return self._negativ
+	def low(self):
+		"""low commands group. 4 Sub-classes, 0 commands."""
+		if not hasattr(self, '_low'):
+			from .Low import LowCls
+			self._low = LowCls(self._core, self._cmd_group)
+		return self._low
 
 	@property
-	def positiv(self):
-		"""positiv commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_positiv'):
-			from .Minimum_.Positiv import Positiv
-			self._positiv = Positiv(self._core, self._base)
-		return self._positiv
+	def high(self):
+		"""high commands group. 4 Sub-classes, 0 commands."""
+		if not hasattr(self, '_high'):
+			from .High import HighCls
+			self._high = HighCls(self._core, self._cmd_group)
+		return self._high
 
-	def clone(self) -> 'Minimum':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'DmrsCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Minimum(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = DmrsCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/SeMask_/Margin_/Minimum_/Negativ.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/SeMask/Margin/Minimum/Negativ.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,29 +1,29 @@
 from typing import List
 
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.Types import DataType
-from ......Internal.StructBase import StructBase
-from ......Internal.ArgStruct import ArgStruct
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal.Types import DataType
+from .......Internal.StructBase import StructBase
+from .......Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Negativ:
-	"""Negativ commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class NegativCls:
+	"""Negativ commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("negativ", core, parent)
+		self._cmd_group = CommandsGroup("negativ", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Out_Of_Tolerance: int: Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for spectrum emission measurements exceeding the specified spectrum emission mask limits.
+			- Reliability: int: 'Reliability indicator'
+			- Out_Of_Tolerance: int: Out of tolerance result, i.e. the percentage of measurement intervals of the statistic count for spectrum emission measurements exceeding the specified spectrum emission mask limits.
 			- Margin_Min_Neg_X: List[float]: No parameter help available
 			- Margin_Min_Neg_Y: List[float]: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
 			ArgStruct('Margin_Min_Neg_X', DataType.FloatList, None, False, True, 1),
 			ArgStruct('Margin_Min_Neg_Y', DataType.FloatList, None, False, True, 1)]
@@ -33,15 +33,15 @@
 			self.Reliability: int = None
 			self.Out_Of_Tolerance: int = None
 			self.Margin_Min_Neg_X: List[float] = None
 			self.Margin_Min_Neg_Y: List[float] = None
 
 	def fetch(self) -> FetchStruct:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:SEMask:MARGin:MINimum:NEGativ \n
-		Snippet: value: FetchStruct = driver.multiEval.seMask.margin.minimum.negativ.fetch() \n
+		Snippet: value: FetchStruct = driver.lteMeas.multiEval.seMask.margin.minimum.negativ.fetch() \n
 		Returns spectrum emission mask margin results. A negative margin indicates that the trace is located above the limit line,
 		i.e. the limit is exceeded. The individual commands provide results for the CURRent, AVERage and maximum traces
-		(resulting in MINimum margins) . For each trace, the X and Y values of the margins for emission mask areas 1 to 12 are
+		(resulting in MINimum margins) . For each trace, the x- and y-values of the margins for emission mask areas 1 to 12 are
 		provided for NEGative and POSitive offset frequencies. For inactive areas, NCAP is returned.
 		Returned sequence: <Reliability>, <OutOfTolerance>, {<MarginX>, <MarginY>}area1, {...}area2, ..., {...}area12 \n
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
 		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:SEMask:MARGin:MINimum:NEGativ?', self.__class__.FetchStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/SeMask_/Maximum.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/SeMask/Maximum.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,20 +1,20 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
-from ....Internal.StructBase import StructBase
-from ....Internal.ArgStruct import ArgStruct
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
+from .....Internal.StructBase import StructBase
+from .....Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Maximum:
-	"""Maximum commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class MaximumCls:
+	"""Maximum commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("maximum", core, parent)
+		self._cmd_group = CommandsGroup("maximum", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
 			- Reliability: int: No parameter help available
 			- Out_Of_Tolerance: int: No parameter help available
 			- Obw: float: No parameter help available
@@ -30,45 +30,45 @@
 			self.Reliability: int = None
 			self.Out_Of_Tolerance: int = None
 			self.Obw: float = None
 			self.Tx_Power: float = None
 
 	def read(self) -> ResultData:
 		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:SEMask:MAXimum \n
-		Snippet: value: ResultData = driver.multiEval.seMask.maximum.read() \n
+		Snippet: value: ResultData = driver.lteMeas.multiEval.seMask.maximum.read() \n
 		No command help available \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
 		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:SEMask:MAXimum?', self.__class__.ResultData())
 
 	def fetch(self) -> ResultData:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:SEMask:MAXimum \n
-		Snippet: value: ResultData = driver.multiEval.seMask.maximum.fetch() \n
+		Snippet: value: ResultData = driver.lteMeas.multiEval.seMask.maximum.fetch() \n
 		No command help available \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
 		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:SEMask:MAXimum?', self.__class__.ResultData())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
 			- Reliability: int: No parameter help available
 			- Out_Of_Tolerance: int: No parameter help available
-			- Obw: float: No parameter help available
-			- Tx_Power: float: No parameter help available"""
+			- Obw: float or bool: No parameter help available
+			- Tx_Power: float or bool: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
-			ArgStruct.scalar_float('Obw'),
-			ArgStruct.scalar_float('Tx_Power')]
+			ArgStruct.scalar_float_ext('Obw'),
+			ArgStruct.scalar_float_ext('Tx_Power')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tolerance: int = None
-			self.Obw: float = None
-			self.Tx_Power: float = None
+			self.Obw: float or bool = None
+			self.Tx_Power: float or bool = None
 
 	def calculate(self) -> CalculateStruct:
 		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:SEMask:MAXimum \n
-		Snippet: value: CalculateStruct = driver.multiEval.seMask.maximum.calculate() \n
+		Snippet: value: CalculateStruct = driver.lteMeas.multiEval.seMask.maximum.calculate() \n
 		No command help available \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
 		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:SEMask:MAXimum?', self.__class__.CalculateStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/SeMask_/Minimum.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Trace/RbaTable/Ulca/Pcc.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,68 +1,51 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
-from ....Internal.StructBase import StructBase
-from ....Internal.ArgStruct import ArgStruct
+from typing import List
+
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal.Types import DataType
+from .......Internal.StructBase import StructBase
+from .......Internal.ArgStruct import ArgStruct
+from ....... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Minimum:
-	"""Minimum commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class PccCls:
+	"""Pcc commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("minimum", core, parent)
+		self._cmd_group = CommandsGroup("pcc", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
 			- Reliability: int: No parameter help available
-			- Out_Of_Tolerance: int: No parameter help available
-			- Tx_Power: float: No parameter help available"""
+			- Channel_Type: List[enums.RbTableChannelType]: No parameter help available
+			- Offset_Rb: List[int]: No parameter help available
+			- No_Rb: List[int]: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_int('Out_Of_Tolerance'),
-			ArgStruct.scalar_float('Tx_Power')]
+			ArgStruct('Channel_Type', DataType.EnumList, enums.RbTableChannelType, False, True, 1),
+			ArgStruct('Offset_Rb', DataType.IntegerList, None, False, True, 1),
+			ArgStruct('No_Rb', DataType.IntegerList, None, False, True, 1)]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
-			self.Out_Of_Tolerance: int = None
-			self.Tx_Power: float = None
+			self.Channel_Type: List[enums.RbTableChannelType] = None
+			self.Offset_Rb: List[int] = None
+			self.No_Rb: List[int] = None
 
 	def read(self) -> ResultData:
-		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:SEMask:MINimum \n
-		Snippet: value: ResultData = driver.multiEval.seMask.minimum.read() \n
+		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:TRACe:RBATable:ULCA[:PCC] \n
+		Snippet: value: ResultData = driver.lteMeas.multiEval.trace.rbaTable.ulca.pcc.read() \n
 		No command help available \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:SEMask:MINimum?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:TRACe:RBATable:ULCA:PCC?', self.__class__.ResultData())
 
 	def fetch(self) -> ResultData:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:SEMask:MINimum \n
-		Snippet: value: ResultData = driver.multiEval.seMask.minimum.fetch() \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:TRACe:RBATable:ULCA[:PCC] \n
+		Snippet: value: ResultData = driver.lteMeas.multiEval.trace.rbaTable.ulca.pcc.fetch() \n
 		No command help available \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:SEMask:MINimum?', self.__class__.ResultData())
-
-	# noinspection PyTypeChecker
-	class CalculateStruct(StructBase):
-		"""Response structure. Fields: \n
-			- Reliability: int: No parameter help available
-			- Out_Of_Tolerance: int: No parameter help available
-			- Tx_Power: float: No parameter help available"""
-		__meta_args_list = [
-			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_int('Out_Of_Tolerance'),
-			ArgStruct.scalar_float('Tx_Power')]
-
-		def __init__(self):
-			StructBase.__init__(self, self)
-			self.Reliability: int = None
-			self.Out_Of_Tolerance: int = None
-			self.Tx_Power: float = None
-
-	def calculate(self) -> CalculateStruct:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:SEMask:MINimum \n
-		Snippet: value: CalculateStruct = driver.multiEval.seMask.minimum.calculate() \n
-		No command help available \n
-			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:SEMask:MINimum?', self.__class__.CalculateStruct())
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:TRACe:RBATable:ULCA:PCC?', self.__class__.ResultData())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/SeMask_/StandardDev.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/Prach/EvmSymbol/Maximum.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,78 +1,78 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
-from ....Internal.StructBase import StructBase
-from ....Internal.ArgStruct import ArgStruct
+from typing import List
+
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
+from .....Internal.Types import DataType
+from .....Internal.StructBase import StructBase
+from .....Internal.ArgStruct import ArgStruct
+from ..... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class StandardDev:
-	"""StandardDev commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class MaximumCls:
+	"""Maximum commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("standardDev", core, parent)
+		self._cmd_group = CommandsGroup("maximum", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Out_Of_Tolerance: int: Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for spectrum emission measurements exceeding the specified spectrum emission mask limits.
-			- Obw: float: Occupied bandwidth
-			- Tx_Power: float: Total TX power in the slot over all component carriers"""
+			- Reliability: int: 'Reliability indicator'
+			- Low: List[float]: EVM value for low EVM window position.
+			- High: List[float]: EVM value for high EVM window position."""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_int('Out_Of_Tolerance'),
-			ArgStruct.scalar_float('Obw'),
-			ArgStruct.scalar_float('Tx_Power')]
+			ArgStruct('Low', DataType.FloatList, None, False, True, 1),
+			ArgStruct('High', DataType.FloatList, None, False, True, 1)]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
-			self.Out_Of_Tolerance: int = None
-			self.Obw: float = None
-			self.Tx_Power: float = None
+			self.Low: List[float] = None
+			self.High: List[float] = None
 
 	def read(self) -> ResultData:
-		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:SEMask:SDEViation \n
-		Snippet: value: ResultData = driver.multiEval.seMask.standardDev.read() \n
-		Return the current, average and standard deviation single value results of the spectrum emission measurement. The values
-		described below are returned by FETCh and READ commands. CALCulate commands return limit check results instead, one value
-		for each result listed below. \n
+		"""SCPI: READ:LTE:MEASurement<Instance>:PRACh:EVMSymbol:MAXimum \n
+		Snippet: value: ResultData = driver.lteMeas.prach.evmSymbol.maximum.read() \n
+		Returns the values of the EVM RMS diagrams for the OFDM symbols in the measured preamble. The results of the current,
+		average and maximum diagrams can be retrieved. There is one pair of EVM values per OFDM symbol, returned in the following
+		order: <Reliability>, {<Low>, <High>}symbol 0, {<Low>, <High>}symbol 1 If the preamble contains only one symbol, NCAPs
+		are returned for the remaining symbol. See also 'Square EVM vs Symbol'. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:SEMask:SDEViation?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:PRACh:EVMSymbol:MAXimum?', self.__class__.ResultData())
 
 	def fetch(self) -> ResultData:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:SEMask:SDEViation \n
-		Snippet: value: ResultData = driver.multiEval.seMask.standardDev.fetch() \n
-		Return the current, average and standard deviation single value results of the spectrum emission measurement. The values
-		described below are returned by FETCh and READ commands. CALCulate commands return limit check results instead, one value
-		for each result listed below. \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:PRACh:EVMSymbol:MAXimum \n
+		Snippet: value: ResultData = driver.lteMeas.prach.evmSymbol.maximum.fetch() \n
+		Returns the values of the EVM RMS diagrams for the OFDM symbols in the measured preamble. The results of the current,
+		average and maximum diagrams can be retrieved. There is one pair of EVM values per OFDM symbol, returned in the following
+		order: <Reliability>, {<Low>, <High>}symbol 0, {<Low>, <High>}symbol 1 If the preamble contains only one symbol, NCAPs
+		are returned for the remaining symbol. See also 'Square EVM vs Symbol'. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:SEMask:SDEViation?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:PRACh:EVMSymbol:MAXimum?', self.__class__.ResultData())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
 			- Reliability: int: No parameter help available
-			- Out_Of_Tolerance: int: No parameter help available
-			- Obw: float: No parameter help available
-			- Tx_Power: float: No parameter help available"""
+			- Low: List[enums.ResultStatus2]: No parameter help available
+			- High: List[enums.ResultStatus2]: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_int('Out_Of_Tolerance'),
-			ArgStruct.scalar_float('Obw'),
-			ArgStruct.scalar_float('Tx_Power')]
+			ArgStruct('Low', DataType.EnumList, enums.ResultStatus2, False, True, 1),
+			ArgStruct('High', DataType.EnumList, enums.ResultStatus2, False, True, 1)]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
-			self.Out_Of_Tolerance: int = None
-			self.Obw: float = None
-			self.Tx_Power: float = None
+			self.Low: List[enums.ResultStatus2] = None
+			self.High: List[enums.ResultStatus2] = None
 
 	def calculate(self) -> CalculateStruct:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:MEValuation:SEMask:SDEViation \n
-		Snippet: value: CalculateStruct = driver.multiEval.seMask.standardDev.calculate() \n
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:PRACh:EVMSymbol:MAXimum \n
+		Snippet: value: CalculateStruct = driver.lteMeas.prach.evmSymbol.maximum.calculate() \n
 		No command help available \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:MEValuation:SEMask:SDEViation?', self.__class__.CalculateStruct())
+		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:PRACh:EVMSymbol:MAXimum?', self.__class__.CalculateStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/State.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/Prach/Modulation/DsIndex/__init__.py`

 * *Files 27% similar despite different names*

```diff
@@ -1,39 +1,40 @@
-from ...Internal.Core import Core
-from ...Internal.CommandsGroup import CommandsGroup
-from ...Internal import Conversions
-from ... import enums
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal import Conversions
+from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from ......Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class State:
-	"""State commands group definition. 2 total commands, 1 Sub-groups, 1 group commands"""
+class DsIndexCls:
+	"""DsIndex commands group definition. 2 total commands, 1 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("state", core, parent)
+		self._cmd_group = CommandsGroup("dsIndex", core, parent)
 
 	@property
-	def all(self):
-		"""all commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_all'):
-			from .State_.All import All
-			self._all = All(self._core, self._base)
-		return self._all
-
-	# noinspection PyTypeChecker
-	def fetch(self) -> enums.ResourceState:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:STATe \n
-		Snippet: value: enums.ResourceState = driver.multiEval.state.fetch() \n
-		Queries the main measurement state. Use FETCh:...:STATe:ALL? to query the measurement state including the substates. Use
-		INITiate..., STOP..., ABORt... to change the measurement state. \n
-			:return: meas_status: OFF: measurement off, no resources allocated, no results RUN: measurement running, synchronization pending or adjusted, resources active or queued RDY: measurement terminated, valid results can be available"""
-		response = self._core.io.query_str(f'FETCh:LTE:MEASurement<Instance>:MEValuation:STATe?')
-		return Conversions.str_to_scalar_enum(response, enums.ResourceState)
+	def preamble(self):
+		"""preamble commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_preamble'):
+			from .Preamble import PreambleCls
+			self._preamble = PreambleCls(self._core, self._cmd_group)
+		return self._preamble
+
+	def fetch(self) -> int:
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:PRACh:MODulation:DSINdex \n
+		Snippet: value: int = driver.lteMeas.prach.modulation.dsIndex.fetch() \n
+		Returns the automatically detected or manually configured sequence index for single-preamble measurements. \n
+		Suppressed linked return values: reliability \n
+			:return: sequence_index: Sequence index"""
+		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
+		response = self._core.io.query_str_suppressed(f'FETCh:LTE:MEASurement<Instance>:PRACh:MODulation:DSINdex?', suppressed)
+		return Conversions.str_to_int(response)
 
-	def clone(self) -> 'State':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'DsIndexCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = State(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = DsIndexCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/State_/All.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/Prach/State/__init__.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,40 +1,46 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
-from ....Internal.StructBase import StructBase
-from ....Internal.ArgStruct import ArgStruct
-from .... import enums
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
+from .....Internal import Conversions
+from .....Internal.Types import DataType
+from .....Internal.ArgSingleList import ArgSingleList
+from .....Internal.ArgSingle import ArgSingle
+from ..... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class All:
-	"""All commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class StateCls:
+	"""State commands group definition. 2 total commands, 1 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("all", core, parent)
+		self._cmd_group = CommandsGroup("state", core, parent)
+
+	@property
+	def all(self):
+		"""all commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_all'):
+			from .All import AllCls
+			self._all = AllCls(self._core, self._cmd_group)
+		return self._all
 
 	# noinspection PyTypeChecker
-	class FetchStruct(StructBase):
-		"""Response structure. Fields: \n
-			- Main_State: enums.ResourceState: OFF: measurement off, no resources allocated, no results RUN: measurement running, synchronization pending or adjusted, resources active or queued RDY: measurement terminated, valid results can be available
-			- Sync_State: enums.ResourceState: PEND: waiting for resource allocation, adjustment, hardware switching ('pending') ADJ: adjustments finished, measurement running ('adjusted') INV: not applicable, MainState OFF or RDY ('invalid')
-			- Resource_State: enums.ResourceState: QUE: measurement without resources, no results available ('queued') ACT: resources allocated, acquisition of results in progress but not complete ('active') INV: not applicable, MainState OFF or RDY ('invalid')"""
-		__meta_args_list = [
-			ArgStruct.scalar_enum('Main_State', enums.ResourceState),
-			ArgStruct.scalar_enum('Sync_State', enums.ResourceState),
-			ArgStruct.scalar_enum('Resource_State', enums.ResourceState)]
-
-		def __init__(self):
-			StructBase.__init__(self, self)
-			self.Main_State: enums.ResourceState = None
-			self.Sync_State: enums.ResourceState = None
-			self.Resource_State: enums.ResourceState = None
-
-	def fetch(self) -> FetchStruct:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:STATe:ALL \n
-		Snippet: value: FetchStruct = driver.multiEval.state.all.fetch() \n
-		Queries the main measurement state and the measurement substates. Both measurement substates are relevant for running
-		measurements only. Use FETCh:...:STATe? to query the main measurement state only. Use INITiate..., STOP..., ABORt...
-		to change the measurement state. \n
-			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:STATe:ALL?', self.__class__.FetchStruct())
+	def fetch(self, timeout: float = None, target_main_state: enums.TargetStateA = None, target_sync_state: enums.TargetSyncState = None) -> enums.ResourceState:
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:PRACh:STATe \n
+		Snippet: value: enums.ResourceState = driver.lteMeas.prach.state.fetch(timeout = 1.0, target_main_state = enums.TargetStateA.OFF, target_sync_state = enums.TargetSyncState.ADJusted) \n
+		Queries the main measurement state. Without query parameters, the state is returned immediately. With query parameters,
+		the state is returned when the <TargetMainState> and the <TargetSyncState> are reached or when the <Timeout> expires. \n
+			:param timeout: No help available
+			:param target_main_state: Target MainState for the query Default is RUN.
+			:param target_sync_state: Target SyncState for the query Default is ADJ.
+			:return: meas_status: Current state or target state of ongoing state transition OFF: measurement off RUN: measurement running RDY: measurement completed"""
+		param = ArgSingleList().compose_cmd_string(ArgSingle('timeout', timeout, DataType.Float, None, is_optional=True), ArgSingle('target_main_state', target_main_state, DataType.Enum, enums.TargetStateA, is_optional=True), ArgSingle('target_sync_state', target_sync_state, DataType.Enum, enums.TargetSyncState, is_optional=True))
+		response = self._core.io.query_str(f'FETCh:LTE:MEASurement<Instance>:PRACh:STATe? {param}'.rstrip())
+		return Conversions.str_to_scalar_enum(response, enums.ResourceState)
+
+	def clone(self) -> 'StateCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
+		Also copies all the existing default Repeated Capabilities setting,
+		which you can change independently without affecting the original group"""
+		new_group = StateCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
+		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Trace.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Aclr/__init__.py`

 * *Files 23% similar despite different names*

```diff
@@ -1,99 +1,51 @@
-from ...Internal.Core import Core
-from ...Internal.CommandsGroup import CommandsGroup
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Trace:
-	"""Trace commands group definition. 60 total commands, 10 Sub-groups, 0 group commands"""
+class AclrCls:
+	"""Aclr commands group definition. 8 total commands, 4 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("trace", core, parent)
+		self._cmd_group = CommandsGroup("aclr", core, parent)
 
 	@property
-	def rbaTable(self):
-		"""rbaTable commands group. 4 Sub-classes, 0 commands."""
-		if not hasattr(self, '_rbaTable'):
-			from .Trace_.RbaTable import RbaTable
-			self._rbaTable = RbaTable(self._core, self._base)
-		return self._rbaTable
+	def current(self):
+		"""current commands group. 0 Sub-classes, 3 commands."""
+		if not hasattr(self, '_current'):
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
+		return self._current
+
+	@property
+	def average(self):
+		"""average commands group. 0 Sub-classes, 3 commands."""
+		if not hasattr(self, '_average'):
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
+		return self._average
+
+	@property
+	def dchType(self):
+		"""dchType commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_dchType'):
+			from .DchType import DchTypeCls
+			self._dchType = DchTypeCls(self._core, self._cmd_group)
+		return self._dchType
+
+	@property
+	def dallocation(self):
+		"""dallocation commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_dallocation'):
+			from .Dallocation import DallocationCls
+			self._dallocation = DallocationCls(self._core, self._cmd_group)
+		return self._dallocation
 
-	@property
-	def iq(self):
-		"""iq commands group. 2 Sub-classes, 0 commands."""
-		if not hasattr(self, '_iq'):
-			from .Trace_.Iq import Iq
-			self._iq = Iq(self._core, self._base)
-		return self._iq
-
-	@property
-	def iemissions(self):
-		"""iemissions commands group. 4 Sub-classes, 0 commands."""
-		if not hasattr(self, '_iemissions'):
-			from .Trace_.Iemissions import Iemissions
-			self._iemissions = Iemissions(self._core, self._base)
-		return self._iemissions
-
-	@property
-	def evmc(self):
-		"""evmc commands group. 0 Sub-classes, 2 commands."""
-		if not hasattr(self, '_evmc'):
-			from .Trace_.Evmc import Evmc
-			self._evmc = Evmc(self._core, self._base)
-		return self._evmc
-
-	@property
-	def evmSymbol(self):
-		"""evmSymbol commands group. 3 Sub-classes, 0 commands."""
-		if not hasattr(self, '_evmSymbol'):
-			from .Trace_.EvmSymbol import EvmSymbol
-			self._evmSymbol = EvmSymbol(self._core, self._base)
-		return self._evmSymbol
-
-	@property
-	def esFlatness(self):
-		"""esFlatness commands group. 1 Sub-classes, 2 commands."""
-		if not hasattr(self, '_esFlatness'):
-			from .Trace_.EsFlatness import EsFlatness
-			self._esFlatness = EsFlatness(self._core, self._base)
-		return self._esFlatness
-
-	@property
-	def seMask(self):
-		"""seMask commands group. 1 Sub-classes, 0 commands."""
-		if not hasattr(self, '_seMask'):
-			from .Trace_.SeMask import SeMask
-			self._seMask = SeMask(self._core, self._base)
-		return self._seMask
-
-	@property
-	def aclr(self):
-		"""aclr commands group. 2 Sub-classes, 0 commands."""
-		if not hasattr(self, '_aclr'):
-			from .Trace_.Aclr import Aclr
-			self._aclr = Aclr(self._core, self._base)
-		return self._aclr
-
-	@property
-	def pmonitor(self):
-		"""pmonitor commands group. 4 Sub-classes, 0 commands."""
-		if not hasattr(self, '_pmonitor'):
-			from .Trace_.Pmonitor import Pmonitor
-			self._pmonitor = Pmonitor(self._core, self._base)
-		return self._pmonitor
-
-	@property
-	def pdynamics(self):
-		"""pdynamics commands group. 3 Sub-classes, 0 commands."""
-		if not hasattr(self, '_pdynamics'):
-			from .Trace_.Pdynamics import Pdynamics
-			self._pdynamics = Pdynamics(self._core, self._base)
-		return self._pdynamics
-
-	def clone(self) -> 'Trace':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'AclrCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Trace(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = AclrCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Trace_/Aclr.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/Prach/Trace/Evm/__init__.py`

 * *Files 21% similar despite different names*

```diff
@@ -1,35 +1,43 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Aclr:
-	"""Aclr commands group definition. 4 total commands, 2 Sub-groups, 0 group commands"""
+class EvmCls:
+	"""Evm commands group definition. 6 total commands, 3 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("aclr", core, parent)
+		self._cmd_group = CommandsGroup("evm", core, parent)
 
 	@property
 	def current(self):
 		"""current commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_current'):
-			from .Aclr_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
 	@property
 	def average(self):
 		"""average commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_average'):
-			from .Aclr_.Average import Average
-			self._average = Average(self._core, self._base)
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
 		return self._average
 
-	def clone(self) -> 'Aclr':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	@property
+	def maximum(self):
+		"""maximum commands group. 0 Sub-classes, 2 commands."""
+		if not hasattr(self, '_maximum'):
+			from .Maximum import MaximumCls
+			self._maximum = MaximumCls(self._core, self._cmd_group)
+		return self._maximum
+
+	def clone(self) -> 'EvmCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Aclr(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = EvmCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Trace_/Aclr_/Average.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Trace/Aclr/Average.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,25 +1,25 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
-from .....Internal.StructBase import StructBase
-from .....Internal.ArgStruct import ArgStruct
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal.StructBase import StructBase
+from ......Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class AverageCls:
+	"""Average commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
+			- Reliability: int: 'Reliability indicator'
 			- Utra_2_Neg: float: Power in the second UTRA channel with lower frequency
 			- Utra_1_Neg: float: Power in the first UTRA channel with lower frequency
 			- Eutra_Negativ: float: Power in the first E-UTRA channel with lower frequency
 			- Eutra: float: Power in the allocated E-UTRA channel
 			- Eutra_Positiv: float: Power in the first E-UTRA channel with higher frequency
 			- Utra_1_Pos: float: Power in the first UTRA channel with higher frequency
 			- Utra_2_Pos: float: Power in the second UTRA channel with higher frequency"""
@@ -42,20 +42,20 @@
 			self.Eutra: float = None
 			self.Eutra_Positiv: float = None
 			self.Utra_1_Pos: float = None
 			self.Utra_2_Pos: float = None
 
 	def read(self) -> ResultData:
 		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:TRACe:ACLR:AVERage \n
-		Snippet: value: ResultData = driver.multiEval.trace.aclr.average.read() \n
+		Snippet: value: ResultData = driver.lteMeas.multiEval.trace.aclr.average.read() \n
 		Returns the absolute powers as displayed in the ACLR diagram. The current and average values can be retrieved. See also
 		'Square Spectrum ACLR'. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
 		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:TRACe:ACLR:AVERage?', self.__class__.ResultData())
 
 	def fetch(self) -> ResultData:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:TRACe:ACLR:AVERage \n
-		Snippet: value: ResultData = driver.multiEval.trace.aclr.average.fetch() \n
+		Snippet: value: ResultData = driver.lteMeas.multiEval.trace.aclr.average.fetch() \n
 		Returns the absolute powers as displayed in the ACLR diagram. The current and average values can be retrieved. See also
 		'Square Spectrum ACLR'. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
 		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:TRACe:ACLR:AVERage?', self.__class__.ResultData())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Trace_/Aclr_/Current.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Trace/Aclr/Current.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,25 +1,25 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
-from .....Internal.StructBase import StructBase
-from .....Internal.ArgStruct import ArgStruct
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal.StructBase import StructBase
+from ......Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
+			- Reliability: int: 'Reliability indicator'
 			- Utra_2_Neg: float: Power in the second UTRA channel with lower frequency
 			- Utra_1_Neg: float: Power in the first UTRA channel with lower frequency
 			- Eutra_Negativ: float: Power in the first E-UTRA channel with lower frequency
 			- Eutra: float: Power in the allocated E-UTRA channel
 			- Eutra_Positiv: float: Power in the first E-UTRA channel with higher frequency
 			- Utra_1_Pos: float: Power in the first UTRA channel with higher frequency
 			- Utra_2_Pos: float: Power in the second UTRA channel with higher frequency"""
@@ -42,20 +42,20 @@
 			self.Eutra: float = None
 			self.Eutra_Positiv: float = None
 			self.Utra_1_Pos: float = None
 			self.Utra_2_Pos: float = None
 
 	def read(self) -> ResultData:
 		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:TRACe:ACLR:CURRent \n
-		Snippet: value: ResultData = driver.multiEval.trace.aclr.current.read() \n
+		Snippet: value: ResultData = driver.lteMeas.multiEval.trace.aclr.current.read() \n
 		Returns the absolute powers as displayed in the ACLR diagram. The current and average values can be retrieved. See also
 		'Square Spectrum ACLR'. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
 		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:TRACe:ACLR:CURRent?', self.__class__.ResultData())
 
 	def fetch(self) -> ResultData:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:TRACe:ACLR:CURRent \n
-		Snippet: value: ResultData = driver.multiEval.trace.aclr.current.fetch() \n
+		Snippet: value: ResultData = driver.lteMeas.multiEval.trace.aclr.current.fetch() \n
 		Returns the absolute powers as displayed in the ACLR diagram. The current and average values can be retrieved. See also
 		'Square Spectrum ACLR'. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
 		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:TRACe:ACLR:CURRent?', self.__class__.ResultData())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Trace_/EsFlatness.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Trace/EsFlatness/__init__.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,51 +1,51 @@
 from typing import List
 
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
-from ....Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ....Internal.Types import DataType
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from ......Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class EsFlatness:
-	"""EsFlatness commands group definition. 4 total commands, 1 Sub-groups, 2 group commands"""
+class EsFlatnessCls:
+	"""EsFlatness commands group definition. 4 total commands, 1 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("esFlatness", core, parent)
+		self._cmd_group = CommandsGroup("esFlatness", core, parent)
 
 	@property
 	def phase(self):
 		"""phase commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_phase'):
-			from .EsFlatness_.Phase import Phase
-			self._phase = Phase(self._core, self._base)
+			from .Phase import PhaseCls
+			self._phase = PhaseCls(self._core, self._cmd_group)
 		return self._phase
 
 	def read(self) -> List[float]:
 		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:TRACe:ESFLatness \n
-		Snippet: value: List[float] = driver.multiEval.trace.esFlatness.read() \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.trace.esFlatness.read() \n
 		Returns the values of the equalizer spectrum flatness trace. See also 'Square Equalizer Spectrum Flatness'. \n
 		Suppressed linked return values: reliability \n
 			:return: power: Comma-separated list of power values, one value per subcarrier For not allocated subcarriers, NCAP is returned."""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:LTE:MEASurement<Instance>:MEValuation:TRACe:ESFLatness?', suppressed)
 		return response
 
 	def fetch(self) -> List[float]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:TRACe:ESFLatness \n
-		Snippet: value: List[float] = driver.multiEval.trace.esFlatness.fetch() \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.trace.esFlatness.fetch() \n
 		Returns the values of the equalizer spectrum flatness trace. See also 'Square Equalizer Spectrum Flatness'. \n
 		Suppressed linked return values: reliability \n
 			:return: power: Comma-separated list of power values, one value per subcarrier For not allocated subcarriers, NCAP is returned."""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:TRACe:ESFLatness?', suppressed)
 		return response
 
-	def clone(self) -> 'EsFlatness':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'EsFlatnessCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = EsFlatness(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = EsFlatnessCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Trace_/EsFlatness_/Phase.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Trace/EsFlatness/Phase.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,35 +1,35 @@
 from typing import List
 
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
-from .....Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from .....Internal.Types import DataType
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from ......Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Phase:
-	"""Phase commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class PhaseCls:
+	"""Phase commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("phase", core, parent)
+		self._cmd_group = CommandsGroup("phase", core, parent)
 
 	def read(self) -> List[float]:
 		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:TRACe:ESFLatness:PHASe \n
-		Snippet: value: List[float] = driver.multiEval.trace.esFlatness.phase.read() \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.trace.esFlatness.phase.read() \n
 		Returns the phase values of the equalizer spectrum flatness trace. The GUI shows only the magnitude values. \n
 		Suppressed linked return values: reliability \n
 			:return: phase: Comma-separated list of phase values, one value per subcarrier For not allocated subcarriers, NCAP is returned."""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:LTE:MEASurement<Instance>:MEValuation:TRACe:ESFLatness:PHASe?', suppressed)
 		return response
 
 	def fetch(self) -> List[float]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:TRACe:ESFLatness:PHASe \n
-		Snippet: value: List[float] = driver.multiEval.trace.esFlatness.phase.fetch() \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.trace.esFlatness.phase.fetch() \n
 		Returns the phase values of the equalizer spectrum flatness trace. The GUI shows only the magnitude values. \n
 		Suppressed linked return values: reliability \n
 			:return: phase: Comma-separated list of phase values, one value per subcarrier For not allocated subcarriers, NCAP is returned."""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:TRACe:ESFLatness:PHASe?', suppressed)
 		return response
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Trace_/EvmSymbol.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/EvMagnitude/__init__.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,43 +1,51 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class EvmSymbol:
-	"""EvmSymbol commands group definition. 6 total commands, 3 Sub-groups, 0 group commands"""
+class EvMagnitudeCls:
+	"""EvMagnitude commands group definition. 21 total commands, 4 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("evmSymbol", core, parent)
+		self._cmd_group = CommandsGroup("evMagnitude", core, parent)
 
 	@property
 	def current(self):
-		"""current commands group. 0 Sub-classes, 2 commands."""
+		"""current commands group. 1 Sub-classes, 3 commands."""
 		if not hasattr(self, '_current'):
-			from .EvmSymbol_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
 	@property
 	def average(self):
-		"""average commands group. 0 Sub-classes, 2 commands."""
+		"""average commands group. 1 Sub-classes, 3 commands."""
 		if not hasattr(self, '_average'):
-			from .EvmSymbol_.Average import Average
-			self._average = Average(self._core, self._base)
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
 		return self._average
 
 	@property
 	def maximum(self):
-		"""maximum commands group. 0 Sub-classes, 2 commands."""
+		"""maximum commands group. 1 Sub-classes, 3 commands."""
 		if not hasattr(self, '_maximum'):
-			from .EvmSymbol_.Maximum import Maximum
-			self._maximum = Maximum(self._core, self._base)
+			from .Maximum import MaximumCls
+			self._maximum = MaximumCls(self._core, self._cmd_group)
 		return self._maximum
 
-	def clone(self) -> 'EvmSymbol':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	@property
+	def peak(self):
+		"""peak commands group. 3 Sub-classes, 0 commands."""
+		if not hasattr(self, '_peak'):
+			from .Peak import PeakCls
+			self._peak = PeakCls(self._core, self._cmd_group)
+		return self._peak
+
+	def clone(self) -> 'EvMagnitudeCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = EvmSymbol(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = EvMagnitudeCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Trace_/EvmSymbol_/Average.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Trace/EvmSymbol/Current.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,35 +1,35 @@
 from typing import List
 
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
-from .....Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from .....Internal.Types import DataType
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from ......Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	def read(self) -> List[float]:
-		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:TRACe:EVMSymbol:AVERage \n
-		Snippet: value: List[float] = driver.multiEval.trace.evmSymbol.average.read() \n
+		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:TRACe:EVMSymbol:CURRent \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.trace.evmSymbol.current.read() \n
 		Returns the values of the EVM vs modulation symbol trace. See also 'Square EVM'. \n
 		Suppressed linked return values: reliability \n
 			:return: ratio: Comma-separated list of EVM values, one value per modulation symbol"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:LTE:MEASurement<Instance>:MEValuation:TRACe:EVMSymbol:AVERage?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:LTE:MEASurement<Instance>:MEValuation:TRACe:EVMSymbol:CURRent?', suppressed)
 		return response
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:TRACe:EVMSymbol:AVERage \n
-		Snippet: value: List[float] = driver.multiEval.trace.evmSymbol.average.fetch() \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:TRACe:EVMSymbol:CURRent \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.trace.evmSymbol.current.fetch() \n
 		Returns the values of the EVM vs modulation symbol trace. See also 'Square EVM'. \n
 		Suppressed linked return values: reliability \n
 			:return: ratio: Comma-separated list of EVM values, one value per modulation symbol"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:TRACe:EVMSymbol:AVERage?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:TRACe:EVMSymbol:CURRent?', suppressed)
 		return response
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Trace_/EvmSymbol_/Current.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Trace/EvmSymbol/Maximum.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,35 +1,35 @@
 from typing import List
 
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
-from .....Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from .....Internal.Types import DataType
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from ......Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class MaximumCls:
+	"""Maximum commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("maximum", core, parent)
 
 	def read(self) -> List[float]:
-		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:TRACe:EVMSymbol:CURRent \n
-		Snippet: value: List[float] = driver.multiEval.trace.evmSymbol.current.read() \n
+		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:TRACe:EVMSymbol:MAXimum \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.trace.evmSymbol.maximum.read() \n
 		Returns the values of the EVM vs modulation symbol trace. See also 'Square EVM'. \n
 		Suppressed linked return values: reliability \n
 			:return: ratio: Comma-separated list of EVM values, one value per modulation symbol"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:LTE:MEASurement<Instance>:MEValuation:TRACe:EVMSymbol:CURRent?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:LTE:MEASurement<Instance>:MEValuation:TRACe:EVMSymbol:MAXimum?', suppressed)
 		return response
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:TRACe:EVMSymbol:CURRent \n
-		Snippet: value: List[float] = driver.multiEval.trace.evmSymbol.current.fetch() \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:TRACe:EVMSymbol:MAXimum \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.trace.evmSymbol.maximum.fetch() \n
 		Returns the values of the EVM vs modulation symbol trace. See also 'Square EVM'. \n
 		Suppressed linked return values: reliability \n
 			:return: ratio: Comma-separated list of EVM values, one value per modulation symbol"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:TRACe:EVMSymbol:CURRent?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:TRACe:EVMSymbol:MAXimum?', suppressed)
 		return response
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Trace_/EvmSymbol_/Maximum.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Trace/Evmc.py`

 * *Files 16% similar despite different names*

```diff
@@ -3,33 +3,33 @@
 from .....Internal.Core import Core
 from .....Internal.CommandsGroup import CommandsGroup
 from .....Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from .....Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Maximum:
-	"""Maximum commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class EvmcCls:
+	"""Evmc commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("maximum", core, parent)
+		self._cmd_group = CommandsGroup("evmc", core, parent)
 
 	def read(self) -> List[float]:
-		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:TRACe:EVMSymbol:MAXimum \n
-		Snippet: value: List[float] = driver.multiEval.trace.evmSymbol.maximum.read() \n
-		Returns the values of the EVM vs modulation symbol trace. See also 'Square EVM'. \n
+		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:TRACe:EVMC \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.trace.evmc.read() \n
+		Returns the values of the EVM vs subcarrier trace. See also 'Square EVM vs Subcarrier'. \n
 		Suppressed linked return values: reliability \n
-			:return: ratio: Comma-separated list of EVM values, one value per modulation symbol"""
+			:return: ratio: Comma-separated list of EVM values, one value per subcarrier For not allocated subcarriers, NCAP is returned."""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:LTE:MEASurement<Instance>:MEValuation:TRACe:EVMSymbol:MAXimum?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:LTE:MEASurement<Instance>:MEValuation:TRACe:EVMC?', suppressed)
 		return response
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:TRACe:EVMSymbol:MAXimum \n
-		Snippet: value: List[float] = driver.multiEval.trace.evmSymbol.maximum.fetch() \n
-		Returns the values of the EVM vs modulation symbol trace. See also 'Square EVM'. \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:TRACe:EVMC \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.trace.evmc.fetch() \n
+		Returns the values of the EVM vs subcarrier trace. See also 'Square EVM vs Subcarrier'. \n
 		Suppressed linked return values: reliability \n
-			:return: ratio: Comma-separated list of EVM values, one value per modulation symbol"""
+			:return: ratio: Comma-separated list of EVM values, one value per subcarrier For not allocated subcarriers, NCAP is returned."""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:TRACe:EVMSymbol:MAXimum?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:TRACe:EVMC?', suppressed)
 		return response
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Trace_/Evmc.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/Prach/Modulation/DpfOffset/__init__.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,35 +1,40 @@
-from typing import List
-
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
-from ....Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ....Internal.Types import DataType
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal import Conversions
+from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from ......Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Evmc:
-	"""Evmc commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class DpfOffsetCls:
+	"""DpfOffset commands group definition. 2 total commands, 1 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("evmc", core, parent)
+		self._cmd_group = CommandsGroup("dpfOffset", core, parent)
 
-	def read(self) -> List[float]:
-		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:TRACe:EVMC \n
-		Snippet: value: List[float] = driver.multiEval.trace.evmc.read() \n
-		Returns the values of the EVM vs subcarrier trace. See also 'Square EVM vs Subcarrier'. \n
+	@property
+	def preamble(self):
+		"""preamble commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_preamble'):
+			from .Preamble import PreambleCls
+			self._preamble = PreambleCls(self._core, self._cmd_group)
+		return self._preamble
+
+	def fetch(self) -> int:
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:PRACh:MODulation:DPFoffset \n
+		Snippet: value: int = driver.lteMeas.prach.modulation.dpfOffset.fetch() \n
+		Returns the automatically detected or manually configured PRACH frequency offset for single-preamble measurements. \n
 		Suppressed linked return values: reliability \n
-			:return: ratio: Comma-separated list of EVM values, one value per subcarrier For not allocated subcarriers, NCAP is returned."""
+			:return: prach_freq_offset: PRACH frequency offset"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:LTE:MEASurement<Instance>:MEValuation:TRACe:EVMC?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'FETCh:LTE:MEASurement<Instance>:PRACh:MODulation:DPFoffset?', suppressed)
+		return Conversions.str_to_int(response)
 
-	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:TRACe:EVMC \n
-		Snippet: value: List[float] = driver.multiEval.trace.evmc.fetch() \n
-		Returns the values of the EVM vs subcarrier trace. See also 'Square EVM vs Subcarrier'. \n
-		Suppressed linked return values: reliability \n
-			:return: ratio: Comma-separated list of EVM values, one value per subcarrier For not allocated subcarriers, NCAP is returned."""
-		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:TRACe:EVMC?', suppressed)
-		return response
+	def clone(self) -> 'DpfOffsetCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
+		Also copies all the existing default Repeated Capabilities setting,
+		which you can change independently without affecting the original group"""
+		new_group = DpfOffsetCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
+		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Trace_/Iemissions_/Cc.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Trace/Iemissions/Cc.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,62 +1,62 @@
 from typing import List
 
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
-from .....Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from .....Internal.Types import DataType
-from .....Internal.RepeatedCapability import RepeatedCapability
-from ..... import repcap
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from ......Internal.Types import DataType
+from ......Internal.RepeatedCapability import RepeatedCapability
+from ...... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Cc:
-	"""Cc commands group definition. 2 total commands, 0 Sub-groups, 2 group commands
+class CcCls:
+	"""Cc commands group definition. 2 total commands, 0 Subgroups, 2 group commands
 	Repeated Capability: CarrierComponent, default value after init: CarrierComponent.Nr1"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("cc", core, parent)
-		self._base.rep_cap = RepeatedCapability(self._base.group_name, 'repcap_carrierComponent_get', 'repcap_carrierComponent_set', repcap.CarrierComponent.Nr1)
+		self._cmd_group = CommandsGroup("cc", core, parent)
+		self._cmd_group.rep_cap = RepeatedCapability(self._cmd_group.group_name, 'repcap_carrierComponent_get', 'repcap_carrierComponent_set', repcap.CarrierComponent.Nr1)
 
-	def repcap_carrierComponent_set(self, enum_value: repcap.CarrierComponent) -> None:
+	def repcap_carrierComponent_set(self, carrierComponent: repcap.CarrierComponent) -> None:
 		"""Repeated Capability default value numeric suffix.
 		This value is used, if you do not explicitely set it in the child set/get methods, or if you leave it to CarrierComponent.Default
 		Default value after init: CarrierComponent.Nr1"""
-		self._base.set_repcap_enum_value(enum_value)
+		self._cmd_group.set_repcap_enum_value(carrierComponent)
 
 	def repcap_carrierComponent_get(self) -> repcap.CarrierComponent:
 		"""Returns the current default repeated capability for the child set/get methods"""
 		# noinspection PyTypeChecker
-		return self._base.get_repcap_enum_value()
+		return self._cmd_group.get_repcap_enum_value()
 
 	def read(self, carrierComponent=repcap.CarrierComponent.Default) -> List[float]:
 		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:TRACe:IEMissions:CC<Nr> \n
-		Snippet: value: List[float] = driver.multiEval.trace.iemissions.cc.read(carrierComponent = repcap.CarrierComponent.Default) \n
-		Returns the values of the inband emissions trace for carrier CC<no>. See also 'Square Inband Emissions'. \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.trace.iemissions.cc.read(carrierComponent = repcap.CarrierComponent.Default) \n
+		Returns the values of the in-band emissions trace for carrier CC<no>. See also 'Square Inband Emissions'. \n
 		Suppressed linked return values: reliability \n
 			:param carrierComponent: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Cc')
 			:return: power: Comma-separated list of power values, one value per resource block"""
-		carrierComponent_cmd_val = self._base.get_repcap_cmd_value(carrierComponent, repcap.CarrierComponent)
+		carrierComponent_cmd_val = self._cmd_group.get_repcap_cmd_value(carrierComponent, repcap.CarrierComponent)
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:LTE:MEASurement<Instance>:MEValuation:TRACe:IEMissions:CC{carrierComponent_cmd_val}?', suppressed)
 		return response
 
 	def fetch(self, carrierComponent=repcap.CarrierComponent.Default) -> List[float]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:TRACe:IEMissions:CC<Nr> \n
-		Snippet: value: List[float] = driver.multiEval.trace.iemissions.cc.fetch(carrierComponent = repcap.CarrierComponent.Default) \n
-		Returns the values of the inband emissions trace for carrier CC<no>. See also 'Square Inband Emissions'. \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.trace.iemissions.cc.fetch(carrierComponent = repcap.CarrierComponent.Default) \n
+		Returns the values of the in-band emissions trace for carrier CC<no>. See also 'Square Inband Emissions'. \n
 		Suppressed linked return values: reliability \n
 			:param carrierComponent: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Cc')
 			:return: power: Comma-separated list of power values, one value per resource block"""
-		carrierComponent_cmd_val = self._base.get_repcap_cmd_value(carrierComponent, repcap.CarrierComponent)
+		carrierComponent_cmd_val = self._cmd_group.get_repcap_cmd_value(carrierComponent, repcap.CarrierComponent)
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:TRACe:IEMissions:CC{carrierComponent_cmd_val}?', suppressed)
 		return response
 
-	def clone(self) -> 'Cc':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'CcCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Cc(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = CcCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Trace_/Iemissions_/Pcc.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Trace/Pmonitor/Scc.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,35 +1,35 @@
 from typing import List
 
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
-from .....Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from .....Internal.Types import DataType
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from ......Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Pcc:
-	"""Pcc commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class SccCls:
+	"""Scc commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("pcc", core, parent)
+		self._cmd_group = CommandsGroup("scc", core, parent)
 
 	def read(self) -> List[float]:
-		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:TRACe:IEMissions[:PCC] \n
-		Snippet: value: List[float] = driver.multiEval.trace.iemissions.pcc.read() \n
+		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:TRACe:PMONitor:SCC \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.trace.pmonitor.scc.read() \n
 		No command help available \n
 		Suppressed linked return values: reliability \n
 			:return: power: No help available"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:LTE:MEASurement<Instance>:MEValuation:TRACe:IEMissions:PCC?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:LTE:MEASurement<Instance>:MEValuation:TRACe:PMONitor:SCC?', suppressed)
 		return response
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:TRACe:IEMissions[:PCC] \n
-		Snippet: value: List[float] = driver.multiEval.trace.iemissions.pcc.fetch() \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:TRACe:PMONitor:SCC \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.trace.pmonitor.scc.fetch() \n
 		No command help available \n
 		Suppressed linked return values: reliability \n
 			:return: power: No help available"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:TRACe:IEMissions:PCC?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:TRACe:PMONitor:SCC?', suppressed)
 		return response
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Trace_/Iemissions_/Scc.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Trace/Iemissions/Ulca/Pcc.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,35 +1,35 @@
 from typing import List
 
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
-from .....Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from .....Internal.Types import DataType
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .......Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Scc:
-	"""Scc commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class PccCls:
+	"""Pcc commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("scc", core, parent)
+		self._cmd_group = CommandsGroup("pcc", core, parent)
 
 	def read(self) -> List[float]:
-		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:TRACe:IEMissions:SCC \n
-		Snippet: value: List[float] = driver.multiEval.trace.iemissions.scc.read() \n
+		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:TRACe:IEMissions:ULCA[:PCC] \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.trace.iemissions.ulca.pcc.read() \n
 		No command help available \n
 		Suppressed linked return values: reliability \n
 			:return: power: No help available"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:LTE:MEASurement<Instance>:MEValuation:TRACe:IEMissions:SCC?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:LTE:MEASurement<Instance>:MEValuation:TRACe:IEMissions:ULCA:PCC?', suppressed)
 		return response
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:TRACe:IEMissions:SCC \n
-		Snippet: value: List[float] = driver.multiEval.trace.iemissions.scc.fetch() \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:TRACe:IEMissions:ULCA[:PCC] \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.trace.iemissions.ulca.pcc.fetch() \n
 		No command help available \n
 		Suppressed linked return values: reliability \n
 			:return: power: No help available"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:TRACe:IEMissions:SCC?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:TRACe:IEMissions:ULCA:PCC?', suppressed)
 		return response
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Trace_/Iemissions_/Ulca.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Sense/LteMeas/MultiEval/Limit/__init__.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,35 +1,27 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Ulca:
-	"""Ulca commands group definition. 4 total commands, 2 Sub-groups, 0 group commands"""
+class LimitCls:
+	"""Limit commands group definition. 4 total commands, 1 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("ulca", core, parent)
+		self._cmd_group = CommandsGroup("limit", core, parent)
 
 	@property
-	def scc(self):
-		"""scc commands group. 0 Sub-classes, 2 commands."""
-		if not hasattr(self, '_scc'):
-			from .Ulca_.Scc import Scc
-			self._scc = Scc(self._core, self._base)
-		return self._scc
+	def iemissions(self):
+		"""iemissions commands group. 1 Sub-classes, 2 commands."""
+		if not hasattr(self, '_iemissions'):
+			from .Iemissions import IemissionsCls
+			self._iemissions = IemissionsCls(self._core, self._cmd_group)
+		return self._iemissions
 
-	@property
-	def pcc(self):
-		"""pcc commands group. 0 Sub-classes, 2 commands."""
-		if not hasattr(self, '_pcc'):
-			from .Ulca_.Pcc import Pcc
-			self._pcc = Pcc(self._core, self._base)
-		return self._pcc
-
-	def clone(self) -> 'Ulca':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'LimitCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Ulca(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = LimitCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Trace_/Iemissions_/Ulca_/Pcc.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Trace/Pmonitor/Pcc.py`

 * *Files 21% similar despite different names*

```diff
@@ -3,33 +3,33 @@
 from ......Internal.Core import Core
 from ......Internal.CommandsGroup import CommandsGroup
 from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ......Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Pcc:
-	"""Pcc commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class PccCls:
+	"""Pcc commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("pcc", core, parent)
+		self._cmd_group = CommandsGroup("pcc", core, parent)
 
-	def read(self) -> List[float]:
-		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:TRACe:IEMissions:ULCA[:PCC] \n
-		Snippet: value: List[float] = driver.multiEval.trace.iemissions.ulca.pcc.read() \n
+	def fetch(self) -> List[float]:
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:TRACe:PMONitor[:PCC] \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.trace.pmonitor.pcc.fetch() \n
 		No command help available \n
 		Suppressed linked return values: reliability \n
 			:return: power: No help available"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:LTE:MEASurement<Instance>:MEValuation:TRACe:IEMissions:ULCA:PCC?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:TRACe:PMONitor:PCC?', suppressed)
 		return response
 
-	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:TRACe:IEMissions:ULCA[:PCC] \n
-		Snippet: value: List[float] = driver.multiEval.trace.iemissions.ulca.pcc.fetch() \n
+	def read(self) -> List[float]:
+		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:TRACe:PMONitor[:PCC] \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.trace.pmonitor.pcc.read() \n
 		No command help available \n
 		Suppressed linked return values: reliability \n
 			:return: power: No help available"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:TRACe:IEMissions:ULCA:PCC?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:LTE:MEASurement<Instance>:MEValuation:TRACe:PMONitor:PCC?', suppressed)
 		return response
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Trace_/Iemissions_/Ulca_/Scc.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Trace/Pmonitor/Ulca/Scc.py`

 * *Files 11% similar despite different names*

```diff
@@ -1,62 +1,62 @@
 from typing import List
 
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ......Internal.Types import DataType
-from ......Internal.RepeatedCapability import RepeatedCapability
-from ...... import repcap
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .......Internal.Types import DataType
+from .......Internal.RepeatedCapability import RepeatedCapability
+from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Scc:
-	"""Scc commands group definition. 2 total commands, 0 Sub-groups, 2 group commands
+class SccCls:
+	"""Scc commands group definition. 2 total commands, 0 Subgroups, 2 group commands
 	Repeated Capability: SecondaryCC, default value after init: SecondaryCC.CC1"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("scc", core, parent)
-		self._base.rep_cap = RepeatedCapability(self._base.group_name, 'repcap_secondaryCC_get', 'repcap_secondaryCC_set', repcap.SecondaryCC.CC1)
+		self._cmd_group = CommandsGroup("scc", core, parent)
+		self._cmd_group.rep_cap = RepeatedCapability(self._cmd_group.group_name, 'repcap_secondaryCC_get', 'repcap_secondaryCC_set', repcap.SecondaryCC.CC1)
 
-	def repcap_secondaryCC_set(self, enum_value: repcap.SecondaryCC) -> None:
+	def repcap_secondaryCC_set(self, secondaryCC: repcap.SecondaryCC) -> None:
 		"""Repeated Capability default value numeric suffix.
 		This value is used, if you do not explicitely set it in the child set/get methods, or if you leave it to SecondaryCC.Default
 		Default value after init: SecondaryCC.CC1"""
-		self._base.set_repcap_enum_value(enum_value)
+		self._cmd_group.set_repcap_enum_value(secondaryCC)
 
 	def repcap_secondaryCC_get(self) -> repcap.SecondaryCC:
 		"""Returns the current default repeated capability for the child set/get methods"""
 		# noinspection PyTypeChecker
-		return self._base.get_repcap_enum_value()
+		return self._cmd_group.get_repcap_enum_value()
 
 	def read(self, secondaryCC=repcap.SecondaryCC.Default) -> List[float]:
-		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:TRACe:IEMissions:ULCA:SCC<Nr> \n
-		Snippet: value: List[float] = driver.multiEval.trace.iemissions.ulca.scc.read(secondaryCC = repcap.SecondaryCC.Default) \n
+		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:TRACe:PMONitor:ULCA:SCC<Nr> \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.trace.pmonitor.ulca.scc.read(secondaryCC = repcap.SecondaryCC.Default) \n
 		No command help available \n
 		Suppressed linked return values: reliability \n
 			:param secondaryCC: optional repeated capability selector. Default value: CC1 (settable in the interface 'Scc')
 			:return: power: No help available"""
-		secondaryCC_cmd_val = self._base.get_repcap_cmd_value(secondaryCC, repcap.SecondaryCC)
+		secondaryCC_cmd_val = self._cmd_group.get_repcap_cmd_value(secondaryCC, repcap.SecondaryCC)
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:LTE:MEASurement<Instance>:MEValuation:TRACe:IEMissions:ULCA:SCC{secondaryCC_cmd_val}?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:LTE:MEASurement<Instance>:MEValuation:TRACe:PMONitor:ULCA:SCC{secondaryCC_cmd_val}?', suppressed)
 		return response
 
 	def fetch(self, secondaryCC=repcap.SecondaryCC.Default) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:TRACe:IEMissions:ULCA:SCC<Nr> \n
-		Snippet: value: List[float] = driver.multiEval.trace.iemissions.ulca.scc.fetch(secondaryCC = repcap.SecondaryCC.Default) \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:TRACe:PMONitor:ULCA:SCC<Nr> \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.trace.pmonitor.ulca.scc.fetch(secondaryCC = repcap.SecondaryCC.Default) \n
 		No command help available \n
 		Suppressed linked return values: reliability \n
 			:param secondaryCC: optional repeated capability selector. Default value: CC1 (settable in the interface 'Scc')
 			:return: power: No help available"""
-		secondaryCC_cmd_val = self._base.get_repcap_cmd_value(secondaryCC, repcap.SecondaryCC)
+		secondaryCC_cmd_val = self._cmd_group.get_repcap_cmd_value(secondaryCC, repcap.SecondaryCC)
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:TRACe:IEMissions:ULCA:SCC{secondaryCC_cmd_val}?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:TRACe:PMONitor:ULCA:SCC{secondaryCC_cmd_val}?', suppressed)
 		return response
 
-	def clone(self) -> 'Scc':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'SccCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Scc(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = SccCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Trace_/Iq.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Merror/Peak/High/__init__.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,35 +1,51 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
+from .........Internal.Core import Core
+from .........Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Iq:
-	"""Iq commands group definition. 2 total commands, 2 Sub-groups, 0 group commands"""
+class HighCls:
+	"""High commands group definition. 7 total commands, 4 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("iq", core, parent)
+		self._cmd_group = CommandsGroup("high", core, parent)
 
 	@property
-	def low(self):
-		"""low commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_low'):
-			from .Iq_.Low import Low
-			self._low = Low(self._core, self._base)
-		return self._low
+	def current(self):
+		"""current commands group. 0 Sub-classes, 2 commands."""
+		if not hasattr(self, '_current'):
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
+		return self._current
 
 	@property
-	def high(self):
-		"""high commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_high'):
-			from .Iq_.High import High
-			self._high = High(self._core, self._base)
-		return self._high
+	def average(self):
+		"""average commands group. 0 Sub-classes, 2 commands."""
+		if not hasattr(self, '_average'):
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
+		return self._average
 
-	def clone(self) -> 'Iq':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	@property
+	def extreme(self):
+		"""extreme commands group. 0 Sub-classes, 2 commands."""
+		if not hasattr(self, '_extreme'):
+			from .Extreme import ExtremeCls
+			self._extreme = ExtremeCls(self._core, self._cmd_group)
+		return self._extreme
+
+	@property
+	def standardDev(self):
+		"""standardDev commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_standardDev'):
+			from .StandardDev import StandardDevCls
+			self._standardDev = StandardDevCls(self._core, self._cmd_group)
+		return self._standardDev
+
+	def clone(self) -> 'HighCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Iq(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = HighCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Trace_/Iq_/High.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Trace/Iq/Low.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,42 +1,42 @@
 from typing import List
 
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
-from .....Internal.Types import DataType
-from .....Internal.StructBase import StructBase
-from .....Internal.ArgStruct import ArgStruct
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal.Types import DataType
+from ......Internal.StructBase import StructBase
+from ......Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class High:
-	"""High commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class LowCls:
+	"""Low commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("high", core, parent)
+		self._cmd_group = CommandsGroup("low", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
+			- Reliability: int: 'Reliability indicator'
 			- Iphase: List[float]: Normalized I amplitude
 			- Qphase: List[float]: Normalized Q amplitude"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct('Iphase', DataType.FloatList, None, False, True, 1),
 			ArgStruct('Qphase', DataType.FloatList, None, False, True, 1)]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Iphase: List[float] = None
 			self.Qphase: List[float] = None
 
 	def fetch(self) -> FetchStruct:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:TRACe:IQ:HIGH \n
-		Snippet: value: FetchStruct = driver.multiEval.trace.iq.high.fetch() \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:TRACe:IQ:LOW \n
+		Snippet: value: FetchStruct = driver.lteMeas.multiEval.trace.iq.low.fetch() \n
 		Returns the results in the I/Q constellation diagram for low and high EVM window position. There is one pair of values
 		per modulation symbol. The results are returned in the following order: <Reliability>, {<IPhase>, <QPhase>}symbol 1, ...,
 		{<IPhase>, <QPhase>}symbol n See also 'Square I/Q Constellation' \n
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:TRACe:IQ:HIGH?', self.__class__.FetchStruct())
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:TRACe:IQ:LOW?', self.__class__.FetchStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Trace_/Iq_/Low.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Trace/RbaTable/Pcc.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,42 +1,51 @@
 from typing import List
 
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
-from .....Internal.Types import DataType
-from .....Internal.StructBase import StructBase
-from .....Internal.ArgStruct import ArgStruct
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal.Types import DataType
+from ......Internal.StructBase import StructBase
+from ......Internal.ArgStruct import ArgStruct
+from ...... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Low:
-	"""Low commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class PccCls:
+	"""Pcc commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("low", core, parent)
+		self._cmd_group = CommandsGroup("pcc", core, parent)
 
 	# noinspection PyTypeChecker
-	class FetchStruct(StructBase):
+	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Iphase: List[float]: Normalized I amplitude
-			- Qphase: List[float]: Normalized Q amplitude"""
+			- Reliability: int: No parameter help available
+			- Channel_Type: List[enums.RbTableChannelType]: No parameter help available
+			- Offset_Rb: List[int]: No parameter help available
+			- No_Rb: List[int]: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct('Iphase', DataType.FloatList, None, False, True, 1),
-			ArgStruct('Qphase', DataType.FloatList, None, False, True, 1)]
+			ArgStruct('Channel_Type', DataType.EnumList, enums.RbTableChannelType, False, True, 1),
+			ArgStruct('Offset_Rb', DataType.IntegerList, None, False, True, 1),
+			ArgStruct('No_Rb', DataType.IntegerList, None, False, True, 1)]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
-			self.Iphase: List[float] = None
-			self.Qphase: List[float] = None
-
-	def fetch(self) -> FetchStruct:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:TRACe:IQ:LOW \n
-		Snippet: value: FetchStruct = driver.multiEval.trace.iq.low.fetch() \n
-		Returns the results in the I/Q constellation diagram for low and high EVM window position. There is one pair of values
-		per modulation symbol. The results are returned in the following order: <Reliability>, {<IPhase>, <QPhase>}symbol 1, ...,
-		{<IPhase>, <QPhase>}symbol n See also 'Square I/Q Constellation' \n
-			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:TRACe:IQ:LOW?', self.__class__.FetchStruct())
+			self.Channel_Type: List[enums.RbTableChannelType] = None
+			self.Offset_Rb: List[int] = None
+			self.No_Rb: List[int] = None
+
+	def read(self) -> ResultData:
+		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:TRACe:RBATable[:PCC] \n
+		Snippet: value: ResultData = driver.lteMeas.multiEval.trace.rbaTable.pcc.read() \n
+		No command help available \n
+			:return: structure: for return value, see the help for ResultData structure arguments."""
+		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:TRACe:RBATable:PCC?', self.__class__.ResultData())
+
+	def fetch(self) -> ResultData:
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:TRACe:RBATable[:PCC] \n
+		Snippet: value: ResultData = driver.lteMeas.multiEval.trace.rbaTable.pcc.fetch() \n
+		No command help available \n
+			:return: structure: for return value, see the help for ResultData structure arguments."""
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:TRACe:RBATable:PCC?', self.__class__.ResultData())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Trace_/Pdynamics.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/Prach/Trace/Merror/__init__.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,43 +1,43 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Pdynamics:
-	"""Pdynamics commands group definition. 6 total commands, 3 Sub-groups, 0 group commands"""
+class MerrorCls:
+	"""Merror commands group definition. 6 total commands, 3 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("pdynamics", core, parent)
+		self._cmd_group = CommandsGroup("merror", core, parent)
 
 	@property
 	def current(self):
 		"""current commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_current'):
-			from .Pdynamics_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
 	@property
 	def average(self):
 		"""average commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_average'):
-			from .Pdynamics_.Average import Average
-			self._average = Average(self._core, self._base)
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
 		return self._average
 
 	@property
 	def maximum(self):
 		"""maximum commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_maximum'):
-			from .Pdynamics_.Maximum import Maximum
-			self._maximum = Maximum(self._core, self._base)
+			from .Maximum import MaximumCls
+			self._maximum = MaximumCls(self._core, self._cmd_group)
 		return self._maximum
 
-	def clone(self) -> 'Pdynamics':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'MerrorCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Pdynamics(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = MerrorCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Trace_/Pdynamics_/Average.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Trace/Pdynamics/Current.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,37 +1,37 @@
 from typing import List
 
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
-from .....Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from .....Internal.Types import DataType
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from ......Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	def read(self) -> List[float]:
-		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:TRACe:PDYNamics:AVERage \n
-		Snippet: value: List[float] = driver.multiEval.trace.pdynamics.average.read() \n
+		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:TRACe:PDYNamics:CURRent \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.trace.pdynamics.current.read() \n
 		Return the values of the power dynamics traces. Each value is sampled with 48 Ts, corresponding to 1.5625 s. The results
 		of the current, average and maximum traces can be retrieved. See also 'Square Power Dynamics'. \n
 		Suppressed linked return values: reliability \n
 			:return: power: 2048 power values, from -1100 s to +2098.4375 s relative to the start of the measure subframe. The values have a spacing of 1.5625 s. The 705th value is at the start of the Measure Subframe (0 s) . The diagram in the GUI shows only a subsection of this trace."""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:LTE:MEASurement<Instance>:MEValuation:TRACe:PDYNamics:AVERage?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:LTE:MEASurement<Instance>:MEValuation:TRACe:PDYNamics:CURRent?', suppressed)
 		return response
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:TRACe:PDYNamics:AVERage \n
-		Snippet: value: List[float] = driver.multiEval.trace.pdynamics.average.fetch() \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:TRACe:PDYNamics:CURRent \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.trace.pdynamics.current.fetch() \n
 		Return the values of the power dynamics traces. Each value is sampled with 48 Ts, corresponding to 1.5625 s. The results
 		of the current, average and maximum traces can be retrieved. See also 'Square Power Dynamics'. \n
 		Suppressed linked return values: reliability \n
 			:return: power: 2048 power values, from -1100 s to +2098.4375 s relative to the start of the measure subframe. The values have a spacing of 1.5625 s. The 705th value is at the start of the Measure Subframe (0 s) . The diagram in the GUI shows only a subsection of this trace."""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:TRACe:PDYNamics:AVERage?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:TRACe:PDYNamics:CURRent?', suppressed)
 		return response
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Trace_/Pdynamics_/Current.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Trace/Pdynamics/Average.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,37 +1,37 @@
 from typing import List
 
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
-from .....Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from .....Internal.Types import DataType
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from ......Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class AverageCls:
+	"""Average commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	def read(self) -> List[float]:
-		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:TRACe:PDYNamics:CURRent \n
-		Snippet: value: List[float] = driver.multiEval.trace.pdynamics.current.read() \n
+		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:TRACe:PDYNamics:AVERage \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.trace.pdynamics.average.read() \n
 		Return the values of the power dynamics traces. Each value is sampled with 48 Ts, corresponding to 1.5625 s. The results
 		of the current, average and maximum traces can be retrieved. See also 'Square Power Dynamics'. \n
 		Suppressed linked return values: reliability \n
 			:return: power: 2048 power values, from -1100 s to +2098.4375 s relative to the start of the measure subframe. The values have a spacing of 1.5625 s. The 705th value is at the start of the Measure Subframe (0 s) . The diagram in the GUI shows only a subsection of this trace."""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:LTE:MEASurement<Instance>:MEValuation:TRACe:PDYNamics:CURRent?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:LTE:MEASurement<Instance>:MEValuation:TRACe:PDYNamics:AVERage?', suppressed)
 		return response
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:TRACe:PDYNamics:CURRent \n
-		Snippet: value: List[float] = driver.multiEval.trace.pdynamics.current.fetch() \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:TRACe:PDYNamics:AVERage \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.trace.pdynamics.average.fetch() \n
 		Return the values of the power dynamics traces. Each value is sampled with 48 Ts, corresponding to 1.5625 s. The results
 		of the current, average and maximum traces can be retrieved. See also 'Square Power Dynamics'. \n
 		Suppressed linked return values: reliability \n
 			:return: power: 2048 power values, from -1100 s to +2098.4375 s relative to the start of the measure subframe. The values have a spacing of 1.5625 s. The 705th value is at the start of the Measure Subframe (0 s) . The diagram in the GUI shows only a subsection of this trace."""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:TRACe:PDYNamics:CURRent?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:TRACe:PDYNamics:AVERage?', suppressed)
 		return response
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Trace_/Pdynamics_/Maximum.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Trace/Pdynamics/Maximum.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,37 +1,37 @@
 from typing import List
 
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
-from .....Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from .....Internal.Types import DataType
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from ......Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Maximum:
-	"""Maximum commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class MaximumCls:
+	"""Maximum commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("maximum", core, parent)
+		self._cmd_group = CommandsGroup("maximum", core, parent)
 
 	def read(self) -> List[float]:
 		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:TRACe:PDYNamics:MAXimum \n
-		Snippet: value: List[float] = driver.multiEval.trace.pdynamics.maximum.read() \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.trace.pdynamics.maximum.read() \n
 		Return the values of the power dynamics traces. Each value is sampled with 48 Ts, corresponding to 1.5625 s. The results
 		of the current, average and maximum traces can be retrieved. See also 'Square Power Dynamics'. \n
 		Suppressed linked return values: reliability \n
 			:return: power: 2048 power values, from -1100 s to +2098.4375 s relative to the start of the measure subframe. The values have a spacing of 1.5625 s. The 705th value is at the start of the Measure Subframe (0 s) . The diagram in the GUI shows only a subsection of this trace."""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:LTE:MEASurement<Instance>:MEValuation:TRACe:PDYNamics:MAXimum?', suppressed)
 		return response
 
 	def fetch(self) -> List[float]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:TRACe:PDYNamics:MAXimum \n
-		Snippet: value: List[float] = driver.multiEval.trace.pdynamics.maximum.fetch() \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.trace.pdynamics.maximum.fetch() \n
 		Return the values of the power dynamics traces. Each value is sampled with 48 Ts, corresponding to 1.5625 s. The results
 		of the current, average and maximum traces can be retrieved. See also 'Square Power Dynamics'. \n
 		Suppressed linked return values: reliability \n
 			:return: power: 2048 power values, from -1100 s to +2098.4375 s relative to the start of the measure subframe. The values have a spacing of 1.5625 s. The 705th value is at the start of the Measure Subframe (0 s) . The diagram in the GUI shows only a subsection of this trace."""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:TRACe:PDYNamics:MAXimum?', suppressed)
 		return response
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Trace_/Pmonitor_/Cc.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Trace/Pmonitor/Cc.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,62 +1,62 @@
 from typing import List
 
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
-from .....Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from .....Internal.Types import DataType
-from .....Internal.RepeatedCapability import RepeatedCapability
-from ..... import repcap
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from ......Internal.Types import DataType
+from ......Internal.RepeatedCapability import RepeatedCapability
+from ...... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Cc:
-	"""Cc commands group definition. 2 total commands, 0 Sub-groups, 2 group commands
+class CcCls:
+	"""Cc commands group definition. 2 total commands, 0 Subgroups, 2 group commands
 	Repeated Capability: CarrierComponent, default value after init: CarrierComponent.Nr1"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("cc", core, parent)
-		self._base.rep_cap = RepeatedCapability(self._base.group_name, 'repcap_carrierComponent_get', 'repcap_carrierComponent_set', repcap.CarrierComponent.Nr1)
+		self._cmd_group = CommandsGroup("cc", core, parent)
+		self._cmd_group.rep_cap = RepeatedCapability(self._cmd_group.group_name, 'repcap_carrierComponent_get', 'repcap_carrierComponent_set', repcap.CarrierComponent.Nr1)
 
-	def repcap_carrierComponent_set(self, enum_value: repcap.CarrierComponent) -> None:
+	def repcap_carrierComponent_set(self, carrierComponent: repcap.CarrierComponent) -> None:
 		"""Repeated Capability default value numeric suffix.
 		This value is used, if you do not explicitely set it in the child set/get methods, or if you leave it to CarrierComponent.Default
 		Default value after init: CarrierComponent.Nr1"""
-		self._base.set_repcap_enum_value(enum_value)
+		self._cmd_group.set_repcap_enum_value(carrierComponent)
 
 	def repcap_carrierComponent_get(self) -> repcap.CarrierComponent:
 		"""Returns the current default repeated capability for the child set/get methods"""
 		# noinspection PyTypeChecker
-		return self._base.get_repcap_enum_value()
+		return self._cmd_group.get_repcap_enum_value()
 
 	def read(self, carrierComponent=repcap.CarrierComponent.Default) -> List[float]:
 		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:TRACe:PMONitor:CC<Nr> \n
-		Snippet: value: List[float] = driver.multiEval.trace.pmonitor.cc.read(carrierComponent = repcap.CarrierComponent.Default) \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.trace.pmonitor.cc.read(carrierComponent = repcap.CarrierComponent.Default) \n
 		Returns the power monitor results for all captured CC<no> subframes. \n
 		Suppressed linked return values: reliability \n
 			:param carrierComponent: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Cc')
 			:return: power: Comma-separated list of power values, one value per subframe"""
-		carrierComponent_cmd_val = self._base.get_repcap_cmd_value(carrierComponent, repcap.CarrierComponent)
+		carrierComponent_cmd_val = self._cmd_group.get_repcap_cmd_value(carrierComponent, repcap.CarrierComponent)
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:LTE:MEASurement<Instance>:MEValuation:TRACe:PMONitor:CC{carrierComponent_cmd_val}?', suppressed)
 		return response
 
 	def fetch(self, carrierComponent=repcap.CarrierComponent.Default) -> List[float]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:TRACe:PMONitor:CC<Nr> \n
-		Snippet: value: List[float] = driver.multiEval.trace.pmonitor.cc.fetch(carrierComponent = repcap.CarrierComponent.Default) \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.trace.pmonitor.cc.fetch(carrierComponent = repcap.CarrierComponent.Default) \n
 		Returns the power monitor results for all captured CC<no> subframes. \n
 		Suppressed linked return values: reliability \n
 			:param carrierComponent: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Cc')
 			:return: power: Comma-separated list of power values, one value per subframe"""
-		carrierComponent_cmd_val = self._base.get_repcap_cmd_value(carrierComponent, repcap.CarrierComponent)
+		carrierComponent_cmd_val = self._cmd_group.get_repcap_cmd_value(carrierComponent, repcap.CarrierComponent)
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:TRACe:PMONitor:CC{carrierComponent_cmd_val}?', suppressed)
 		return response
 
-	def clone(self) -> 'Cc':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'CcCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Cc(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = CcCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Trace_/Pmonitor_/Pcc.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Trace/Pmonitor/Ulca/Pcc.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,35 +1,35 @@
 from typing import List
 
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
-from .....Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from .....Internal.Types import DataType
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .......Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Pcc:
-	"""Pcc commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class PccCls:
+	"""Pcc commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("pcc", core, parent)
+		self._cmd_group = CommandsGroup("pcc", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:TRACe:PMONitor[:PCC] \n
-		Snippet: value: List[float] = driver.multiEval.trace.pmonitor.pcc.fetch() \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:TRACe:PMONitor:ULCA[:PCC] \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.trace.pmonitor.ulca.pcc.fetch() \n
 		No command help available \n
 		Suppressed linked return values: reliability \n
 			:return: power: No help available"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:TRACe:PMONitor:PCC?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:TRACe:PMONitor:ULCA:PCC?', suppressed)
 		return response
 
 	def read(self) -> List[float]:
-		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:TRACe:PMONitor[:PCC] \n
-		Snippet: value: List[float] = driver.multiEval.trace.pmonitor.pcc.read() \n
+		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:TRACe:PMONitor:ULCA[:PCC] \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.trace.pmonitor.ulca.pcc.read() \n
 		No command help available \n
 		Suppressed linked return values: reliability \n
 			:return: power: No help available"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:LTE:MEASurement<Instance>:MEValuation:TRACe:PMONitor:PCC?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:LTE:MEASurement<Instance>:MEValuation:TRACe:PMONitor:ULCA:PCC?', suppressed)
 		return response
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Trace_/Pmonitor_/Scc.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/Prach/Modulation/Nsymbol.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,35 +1,24 @@
-from typing import List
-
 from .....Internal.Core import Core
 from .....Internal.CommandsGroup import CommandsGroup
+from .....Internal import Conversions
 from .....Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from .....Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Scc:
-	"""Scc commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class NsymbolCls:
+	"""Nsymbol commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("scc", core, parent)
-
-	def read(self) -> List[float]:
-		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:TRACe:PMONitor:SCC \n
-		Snippet: value: List[float] = driver.multiEval.trace.pmonitor.scc.read() \n
-		No command help available \n
-		Suppressed linked return values: reliability \n
-			:return: power: No help available"""
-		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:LTE:MEASurement<Instance>:MEValuation:TRACe:PMONitor:SCC?', suppressed)
-		return response
+		self._cmd_group = CommandsGroup("nsymbol", core, parent)
 
-	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:TRACe:PMONitor:SCC \n
-		Snippet: value: List[float] = driver.multiEval.trace.pmonitor.scc.fetch() \n
-		No command help available \n
+	def fetch(self) -> int:
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:PRACh:MODulation:NSYMbol \n
+		Snippet: value: int = driver.lteMeas.prach.modulation.nsymbol.fetch() \n
+		Queries the number of active OFDM symbols (symbols with result bars) in the EVM vs symbol diagram. \n
 		Suppressed linked return values: reliability \n
-			:return: power: No help available"""
+			:return: no_of_symbols: No help available"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:TRACe:PMONitor:SCC?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'FETCh:LTE:MEASurement<Instance>:PRACh:MODulation:NSYMbol?', suppressed)
+		return Conversions.str_to_int(response)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Trace_/Pmonitor_/Ulca.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Sense/__init__.py`

 * *Files 25% similar despite different names*

```diff
@@ -1,35 +1,27 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
+from ...Internal.Core import Core
+from ...Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Ulca:
-	"""Ulca commands group definition. 4 total commands, 2 Sub-groups, 0 group commands"""
+class SenseCls:
+	"""Sense commands group definition. 6 total commands, 1 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("ulca", core, parent)
+		self._cmd_group = CommandsGroup("sense", core, parent)
 
 	@property
-	def scc(self):
-		"""scc commands group. 0 Sub-classes, 2 commands."""
-		if not hasattr(self, '_scc'):
-			from .Ulca_.Scc import Scc
-			self._scc = Scc(self._core, self._base)
-		return self._scc
+	def lteMeas(self):
+		"""lteMeas commands group. 2 Sub-classes, 0 commands."""
+		if not hasattr(self, '_lteMeas'):
+			from .LteMeas import LteMeasCls
+			self._lteMeas = LteMeasCls(self._core, self._cmd_group)
+		return self._lteMeas
 
-	@property
-	def pcc(self):
-		"""pcc commands group. 0 Sub-classes, 2 commands."""
-		if not hasattr(self, '_pcc'):
-			from .Ulca_.Pcc import Pcc
-			self._pcc = Pcc(self._core, self._base)
-		return self._pcc
-
-	def clone(self) -> 'Ulca':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'SenseCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Ulca(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = SenseCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Trace_/Pmonitor_/Ulca_/Pcc.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/Prach/Trace/Evm/Maximum.py`

 * *Files 26% similar despite different names*

```diff
@@ -3,33 +3,37 @@
 from ......Internal.Core import Core
 from ......Internal.CommandsGroup import CommandsGroup
 from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ......Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Pcc:
-	"""Pcc commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class MaximumCls:
+	"""Maximum commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("pcc", core, parent)
+		self._cmd_group = CommandsGroup("maximum", core, parent)
 
-	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:TRACe:PMONitor:ULCA[:PCC] \n
-		Snippet: value: List[float] = driver.multiEval.trace.pmonitor.ulca.pcc.fetch() \n
-		No command help available \n
+	def read(self) -> List[float]:
+		"""SCPI: READ:LTE:MEASurement<Instance>:PRACh:TRACe:EVM:MAXimum \n
+		Snippet: value: List[float] = driver.lteMeas.prach.trace.evm.maximum.read() \n
+		Return the values of the EVM vs subcarrier traces. Each value is averaged over the samples in one preamble subcarrier.
+		The results of the current, average and maximum traces can be retrieved. See also 'Square EVM, Magnitude Error, Phase
+		Error'. \n
 		Suppressed linked return values: reliability \n
-			:return: power: No help available"""
+			:return: results: The number of results depends on the preamble format. Format 0 to 3: 839 EVM values, format 4: 139 EVM values"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:TRACe:PMONitor:ULCA:PCC?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:LTE:MEASurement<Instance>:PRACh:TRACe:EVM:MAXimum?', suppressed)
 		return response
 
-	def read(self) -> List[float]:
-		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:TRACe:PMONitor:ULCA[:PCC] \n
-		Snippet: value: List[float] = driver.multiEval.trace.pmonitor.ulca.pcc.read() \n
-		No command help available \n
+	def fetch(self) -> List[float]:
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:PRACh:TRACe:EVM:MAXimum \n
+		Snippet: value: List[float] = driver.lteMeas.prach.trace.evm.maximum.fetch() \n
+		Return the values of the EVM vs subcarrier traces. Each value is averaged over the samples in one preamble subcarrier.
+		The results of the current, average and maximum traces can be retrieved. See also 'Square EVM, Magnitude Error, Phase
+		Error'. \n
 		Suppressed linked return values: reliability \n
-			:return: power: No help available"""
+			:return: results: The number of results depends on the preamble format. Format 0 to 3: 839 EVM values, format 4: 139 EVM values"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:LTE:MEASurement<Instance>:MEValuation:TRACe:PMONitor:ULCA:PCC?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:PRACh:TRACe:EVM:MAXimum?', suppressed)
 		return response
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Trace_/Pmonitor_/Ulca_/Scc.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Amarker/Pmonitor/Cc.py`

 * *Files 27% similar despite different names*

```diff
@@ -1,62 +1,53 @@
-from typing import List
-
 from ......Internal.Core import Core
 from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal import Conversions
 from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ......Internal.Types import DataType
 from ......Internal.RepeatedCapability import RepeatedCapability
 from ...... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Scc:
-	"""Scc commands group definition. 2 total commands, 0 Sub-groups, 2 group commands
-	Repeated Capability: SecondaryCC, default value after init: SecondaryCC.CC1"""
+class CcCls:
+	"""Cc commands group definition. 1 total commands, 0 Subgroups, 1 group commands
+	Repeated Capability: CarrierComponent, default value after init: CarrierComponent.Nr1"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("scc", core, parent)
-		self._base.rep_cap = RepeatedCapability(self._base.group_name, 'repcap_secondaryCC_get', 'repcap_secondaryCC_set', repcap.SecondaryCC.CC1)
+		self._cmd_group = CommandsGroup("cc", core, parent)
+		self._cmd_group.rep_cap = RepeatedCapability(self._cmd_group.group_name, 'repcap_carrierComponent_get', 'repcap_carrierComponent_set', repcap.CarrierComponent.Nr1)
 
-	def repcap_secondaryCC_set(self, enum_value: repcap.SecondaryCC) -> None:
+	def repcap_carrierComponent_set(self, carrierComponent: repcap.CarrierComponent) -> None:
 		"""Repeated Capability default value numeric suffix.
-		This value is used, if you do not explicitely set it in the child set/get methods, or if you leave it to SecondaryCC.Default
-		Default value after init: SecondaryCC.CC1"""
-		self._base.set_repcap_enum_value(enum_value)
+		This value is used, if you do not explicitely set it in the child set/get methods, or if you leave it to CarrierComponent.Default
+		Default value after init: CarrierComponent.Nr1"""
+		self._cmd_group.set_repcap_enum_value(carrierComponent)
 
-	def repcap_secondaryCC_get(self) -> repcap.SecondaryCC:
+	def repcap_carrierComponent_get(self) -> repcap.CarrierComponent:
 		"""Returns the current default repeated capability for the child set/get methods"""
 		# noinspection PyTypeChecker
-		return self._base.get_repcap_enum_value()
-
-	def read(self, secondaryCC=repcap.SecondaryCC.Default) -> List[float]:
-		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:TRACe:PMONitor:ULCA:SCC<Nr> \n
-		Snippet: value: List[float] = driver.multiEval.trace.pmonitor.ulca.scc.read(secondaryCC = repcap.SecondaryCC.Default) \n
-		No command help available \n
-		Suppressed linked return values: reliability \n
-			:param secondaryCC: optional repeated capability selector. Default value: CC1 (settable in the interface 'Scc')
-			:return: power: No help available"""
-		secondaryCC_cmd_val = self._base.get_repcap_cmd_value(secondaryCC, repcap.SecondaryCC)
-		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:LTE:MEASurement<Instance>:MEValuation:TRACe:PMONitor:ULCA:SCC{secondaryCC_cmd_val}?', suppressed)
-		return response
+		return self._cmd_group.get_repcap_enum_value()
 
-	def fetch(self, secondaryCC=repcap.SecondaryCC.Default) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:TRACe:PMONitor:ULCA:SCC<Nr> \n
-		Snippet: value: List[float] = driver.multiEval.trace.pmonitor.ulca.scc.fetch(secondaryCC = repcap.SecondaryCC.Default) \n
-		No command help available \n
+	def fetch(self, xvalue: int or bool, absMarker=repcap.AbsMarker.Default, carrierComponent=repcap.CarrierComponent.Default) -> float:
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:AMARker<No>:PMONitor:CC<Nr> \n
+		Snippet: value: float = driver.lteMeas.multiEval.amarker.pmonitor.cc.fetch(xvalue = 1, absMarker = repcap.AbsMarker.Default, carrierComponent = repcap.CarrierComponent.Default) \n
+		Uses the markers 1 and 2 with absolute values on the power monitor trace. \n
 		Suppressed linked return values: reliability \n
-			:param secondaryCC: optional repeated capability selector. Default value: CC1 (settable in the interface 'Scc')
-			:return: power: No help available"""
-		secondaryCC_cmd_val = self._base.get_repcap_cmd_value(secondaryCC, repcap.SecondaryCC)
+			:param xvalue: (integer or boolean) Absolute x-value of the marker position (subframe number)
+			:param absMarker: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Amarker')
+			:param carrierComponent: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Cc')
+			:return: yvalue: Absolute y-value of the marker position"""
+		param = Conversions.decimal_or_bool_value_to_str(xvalue)
+		absMarker_cmd_val = self._cmd_group.get_repcap_cmd_value(absMarker, repcap.AbsMarker)
+		carrierComponent_cmd_val = self._cmd_group.get_repcap_cmd_value(carrierComponent, repcap.CarrierComponent)
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:TRACe:PMONitor:ULCA:SCC{secondaryCC_cmd_val}?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:AMARker{absMarker_cmd_val}:PMONitor:CC{carrierComponent_cmd_val}? {param}', suppressed)
+		return Conversions.str_to_float(response)
 
-	def clone(self) -> 'Scc':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'CcCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Scc(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = CcCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Trace_/RbaTable.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/__init__.py`

 * *Files 27% similar despite different names*

```diff
@@ -1,51 +1,43 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
+from ...Internal.Core import Core
+from ...Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class RbaTable:
-	"""RbaTable commands group definition. 10 total commands, 4 Sub-groups, 0 group commands"""
+class LteMeasCls:
+	"""LteMeas commands group definition. 795 total commands, 3 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("rbaTable", core, parent)
+		self._cmd_group = CommandsGroup("lteMeas", core, parent)
 
 	@property
-	def scc(self):
-		"""scc commands group. 0 Sub-classes, 2 commands."""
-		if not hasattr(self, '_scc'):
-			from .RbaTable_.Scc import Scc
-			self._scc = Scc(self._core, self._base)
-		return self._scc
+	def multiEval(self):
+		"""multiEval commands group. 19 Sub-classes, 3 commands."""
+		if not hasattr(self, '_multiEval'):
+			from .MultiEval import MultiEvalCls
+			self._multiEval = MultiEvalCls(self._core, self._cmd_group)
+		return self._multiEval
 
 	@property
-	def ulca(self):
-		"""ulca commands group. 2 Sub-classes, 0 commands."""
-		if not hasattr(self, '_ulca'):
-			from .RbaTable_.Ulca import Ulca
-			self._ulca = Ulca(self._core, self._base)
-		return self._ulca
+	def prach(self):
+		"""prach commands group. 5 Sub-classes, 3 commands."""
+		if not hasattr(self, '_prach'):
+			from .Prach import PrachCls
+			self._prach = PrachCls(self._core, self._cmd_group)
+		return self._prach
 
 	@property
-	def cc(self):
-		"""cc commands group. 0 Sub-classes, 2 commands."""
-		if not hasattr(self, '_cc'):
-			from .RbaTable_.Cc import Cc
-			self._cc = Cc(self._core, self._base)
-		return self._cc
+	def srs(self):
+		"""srs commands group. 3 Sub-classes, 3 commands."""
+		if not hasattr(self, '_srs'):
+			from .Srs import SrsCls
+			self._srs = SrsCls(self._core, self._cmd_group)
+		return self._srs
 
-	@property
-	def pcc(self):
-		"""pcc commands group. 0 Sub-classes, 2 commands."""
-		if not hasattr(self, '_pcc'):
-			from .RbaTable_.Pcc import Pcc
-			self._pcc = Pcc(self._core, self._base)
-		return self._pcc
-
-	def clone(self) -> 'RbaTable':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'LteMeasCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = RbaTable(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = LteMeasCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Trace_/RbaTable_/Cc.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Trace/RbaTable/Cc.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,45 +1,45 @@
 from typing import List
 
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
-from .....Internal.Types import DataType
-from .....Internal.StructBase import StructBase
-from .....Internal.ArgStruct import ArgStruct
-from .....Internal.RepeatedCapability import RepeatedCapability
-from ..... import enums
-from ..... import repcap
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal.Types import DataType
+from ......Internal.StructBase import StructBase
+from ......Internal.ArgStruct import ArgStruct
+from ......Internal.RepeatedCapability import RepeatedCapability
+from ...... import enums
+from ...... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Cc:
-	"""Cc commands group definition. 2 total commands, 0 Sub-groups, 2 group commands
+class CcCls:
+	"""Cc commands group definition. 2 total commands, 0 Subgroups, 2 group commands
 	Repeated Capability: CarrierComponent, default value after init: CarrierComponent.Nr1"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("cc", core, parent)
-		self._base.rep_cap = RepeatedCapability(self._base.group_name, 'repcap_carrierComponent_get', 'repcap_carrierComponent_set', repcap.CarrierComponent.Nr1)
+		self._cmd_group = CommandsGroup("cc", core, parent)
+		self._cmd_group.rep_cap = RepeatedCapability(self._cmd_group.group_name, 'repcap_carrierComponent_get', 'repcap_carrierComponent_set', repcap.CarrierComponent.Nr1)
 
-	def repcap_carrierComponent_set(self, enum_value: repcap.CarrierComponent) -> None:
+	def repcap_carrierComponent_set(self, carrierComponent: repcap.CarrierComponent) -> None:
 		"""Repeated Capability default value numeric suffix.
 		This value is used, if you do not explicitely set it in the child set/get methods, or if you leave it to CarrierComponent.Default
 		Default value after init: CarrierComponent.Nr1"""
-		self._base.set_repcap_enum_value(enum_value)
+		self._cmd_group.set_repcap_enum_value(carrierComponent)
 
 	def repcap_carrierComponent_get(self) -> repcap.CarrierComponent:
 		"""Returns the current default repeated capability for the child set/get methods"""
 		# noinspection PyTypeChecker
-		return self._base.get_repcap_enum_value()
+		return self._cmd_group.get_repcap_enum_value()
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Channel_Type: List[enums.RbTableChannelType]: PUSCh / PUCCH: for UL slot with RB allocation PSSCh / PSCCh: for SL subframe with RB allocation NONE: UL slot or SL subframe contains no allocated RBs DL: DL slot (only for TDD UL measurements) SSUB: part of special SF (only for TDD UL measurements)
+			- Reliability: int: 'Reliability indicator'
+			- Channel_Type: List[enums.RbTableChannelType]: PUSCh / PUCCH: for UL slot with RB allocation PSSCh / PSCCh / PSBCh: for SL subframe with RB allocation NONE: UL slot or SL subframe contains no allocated RBs. DL: DL slot (only for TDD UL measurements) SSUB: part of special SF (only for TDD UL measurements)
 			- Offset_Rb: List[int]: Offset of first allocated RB for the given channel type
 			- No_Rb: List[int]: Number of allocated RBs for the given channel type"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct('Channel_Type', DataType.EnumList, enums.RbTableChannelType, False, True, 1),
 			ArgStruct('Offset_Rb', DataType.IntegerList, None, False, True, 1),
 			ArgStruct('No_Rb', DataType.IntegerList, None, False, True, 1)]
@@ -49,38 +49,38 @@
 			self.Reliability: int = None
 			self.Channel_Type: List[enums.RbTableChannelType] = None
 			self.Offset_Rb: List[int] = None
 			self.No_Rb: List[int] = None
 
 	def read(self, carrierComponent=repcap.CarrierComponent.Default) -> ResultData:
 		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:TRACe:RBATable:CC<Nr> \n
-		Snippet: value: ResultData = driver.multiEval.trace.rbaTable.cc.read(carrierComponent = repcap.CarrierComponent.Default) \n
+		Snippet: value: ResultData = driver.lteMeas.multiEval.trace.rbaTable.cc.read(carrierComponent = repcap.CarrierComponent.Default) \n
 		Returns the information of the CC<no> RB allocation table. See also 'Square RB Allocation Table'. For uplink measurements,
 		there are three results per captured slot (n = number of captured subframes) : <Reliability>, {<ChannelType>, <OffsetRB>,
 		<NoRB>}slot 1, ..., {...}slot (n*2) For sidelink measurements, there are six results per captured subframe (SF) , three
 		for the PSCCH and three for the PSSCH: <Reliability>, {...}SF 1 (PSCCH) , {...}SF 1 (PSSCH) , ..., {...}SF n (PSCCH) , {..
-		.}SF n ( PSSCH) \n
+		.}SF n (PSSCH) \n
 			:param carrierComponent: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Cc')
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		carrierComponent_cmd_val = self._base.get_repcap_cmd_value(carrierComponent, repcap.CarrierComponent)
+		carrierComponent_cmd_val = self._cmd_group.get_repcap_cmd_value(carrierComponent, repcap.CarrierComponent)
 		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:TRACe:RBATable:CC{carrierComponent_cmd_val}?', self.__class__.ResultData())
 
 	def fetch(self, carrierComponent=repcap.CarrierComponent.Default) -> ResultData:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:TRACe:RBATable:CC<Nr> \n
-		Snippet: value: ResultData = driver.multiEval.trace.rbaTable.cc.fetch(carrierComponent = repcap.CarrierComponent.Default) \n
+		Snippet: value: ResultData = driver.lteMeas.multiEval.trace.rbaTable.cc.fetch(carrierComponent = repcap.CarrierComponent.Default) \n
 		Returns the information of the CC<no> RB allocation table. See also 'Square RB Allocation Table'. For uplink measurements,
 		there are three results per captured slot (n = number of captured subframes) : <Reliability>, {<ChannelType>, <OffsetRB>,
 		<NoRB>}slot 1, ..., {...}slot (n*2) For sidelink measurements, there are six results per captured subframe (SF) , three
 		for the PSCCH and three for the PSSCH: <Reliability>, {...}SF 1 (PSCCH) , {...}SF 1 (PSSCH) , ..., {...}SF n (PSCCH) , {..
-		.}SF n ( PSSCH) \n
+		.}SF n (PSSCH) \n
 			:param carrierComponent: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Cc')
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		carrierComponent_cmd_val = self._base.get_repcap_cmd_value(carrierComponent, repcap.CarrierComponent)
+		carrierComponent_cmd_val = self._cmd_group.get_repcap_cmd_value(carrierComponent, repcap.CarrierComponent)
 		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:TRACe:RBATable:CC{carrierComponent_cmd_val}?', self.__class__.ResultData())
 
-	def clone(self) -> 'Cc':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'CcCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Cc(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = CcCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Trace_/RbaTable_/Ulca.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/__init__.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,35 +1,27 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
+from ...Internal.Core import Core
+from ...Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Ulca:
-	"""Ulca commands group definition. 4 total commands, 2 Sub-groups, 0 group commands"""
+class ConfigureCls:
+	"""Configure commands group definition. 219 total commands, 1 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("ulca", core, parent)
+		self._cmd_group = CommandsGroup("configure", core, parent)
 
 	@property
-	def scc(self):
-		"""scc commands group. 0 Sub-classes, 2 commands."""
-		if not hasattr(self, '_scc'):
-			from .Ulca_.Scc import Scc
-			self._scc = Scc(self._core, self._base)
-		return self._scc
+	def lteMeas(self):
+		"""lteMeas commands group. 10 Sub-classes, 5 commands."""
+		if not hasattr(self, '_lteMeas'):
+			from .LteMeas import LteMeasCls
+			self._lteMeas = LteMeasCls(self._core, self._cmd_group)
+		return self._lteMeas
 
-	@property
-	def pcc(self):
-		"""pcc commands group. 0 Sub-classes, 2 commands."""
-		if not hasattr(self, '_pcc'):
-			from .Ulca_.Pcc import Pcc
-			self._pcc = Pcc(self._core, self._base)
-		return self._pcc
-
-	def clone(self) -> 'Ulca':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'ConfigureCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Ulca(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = ConfigureCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Trace_/RbaTable_/Ulca_/Pcc.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Limit/Qpsk/Merror.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,51 +1,47 @@
-from typing import List
-
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.Types import DataType
-from ......Internal.StructBase import StructBase
-from ......Internal.ArgStruct import ArgStruct
-from ...... import enums
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal.Types import DataType
+from .......Internal.StructBase import StructBase
+from .......Internal.ArgStruct import ArgStruct
+from .......Internal.ArgSingleList import ArgSingleList
+from .......Internal.ArgSingle import ArgSingle
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Pcc:
-	"""Pcc commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class MerrorCls:
+	"""Merror commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("pcc", core, parent)
+		self._cmd_group = CommandsGroup("merror", core, parent)
+
+	def set(self, rms: float or bool, peak: float or bool) -> None:
+		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QPSK:MERRor \n
+		Snippet: driver.configure.lteMeas.multiEval.limit.qpsk.merror.set(rms = 1.0, peak = 1.0) \n
+		Defines upper limits for the RMS and peak values of the magnitude error for QPSK. \n
+			:param rms: (float or boolean) No help available
+			:param peak: (float or boolean) No help available
+		"""
+		param = ArgSingleList().compose_cmd_string(ArgSingle('rms', rms, DataType.FloatExt), ArgSingle('peak', peak, DataType.FloatExt))
+		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QPSK:MERRor {param}'.rstrip())
 
 	# noinspection PyTypeChecker
-	class ResultData(StructBase):
+	class MerrorStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: No parameter help available
-			- Channel_Type: List[enums.RbTableChannelType]: No parameter help available
-			- Offset_Rb: List[int]: No parameter help available
-			- No_Rb: List[int]: No parameter help available"""
+			- Rms: float or bool: No parameter help available
+			- Peak: float or bool: No parameter help available"""
 		__meta_args_list = [
-			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct('Channel_Type', DataType.EnumList, enums.RbTableChannelType, False, True, 1),
-			ArgStruct('Offset_Rb', DataType.IntegerList, None, False, True, 1),
-			ArgStruct('No_Rb', DataType.IntegerList, None, False, True, 1)]
+			ArgStruct.scalar_float_ext('Rms'),
+			ArgStruct.scalar_float_ext('Peak')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
-			self.Reliability: int = None
-			self.Channel_Type: List[enums.RbTableChannelType] = None
-			self.Offset_Rb: List[int] = None
-			self.No_Rb: List[int] = None
-
-	def read(self) -> ResultData:
-		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:TRACe:RBATable:ULCA[:PCC] \n
-		Snippet: value: ResultData = driver.multiEval.trace.rbaTable.ulca.pcc.read() \n
-		No command help available \n
-			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:TRACe:RBATable:ULCA:PCC?', self.__class__.ResultData())
-
-	def fetch(self) -> ResultData:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:TRACe:RBATable:ULCA[:PCC] \n
-		Snippet: value: ResultData = driver.multiEval.trace.rbaTable.ulca.pcc.fetch() \n
-		No command help available \n
-			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:TRACe:RBATable:ULCA:PCC?', self.__class__.ResultData())
+			self.Rms: float or bool = None
+			self.Peak: float or bool = None
+
+	def get(self) -> MerrorStruct:
+		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QPSK:MERRor \n
+		Snippet: value: MerrorStruct = driver.configure.lteMeas.multiEval.limit.qpsk.merror.get() \n
+		Defines upper limits for the RMS and peak values of the magnitude error for QPSK. \n
+			:return: structure: for return value, see the help for MerrorStruct structure arguments."""
+		return self._core.io.query_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QPSK:MERRor?', self.__class__.MerrorStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Trace_/RbaTable_/Ulca_/Scc.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Trace/RbaTable/Ulca/Scc.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,39 +1,39 @@
 from typing import List
 
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.Types import DataType
-from ......Internal.StructBase import StructBase
-from ......Internal.ArgStruct import ArgStruct
-from ......Internal.RepeatedCapability import RepeatedCapability
-from ...... import enums
-from ...... import repcap
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal.Types import DataType
+from .......Internal.StructBase import StructBase
+from .......Internal.ArgStruct import ArgStruct
+from .......Internal.RepeatedCapability import RepeatedCapability
+from ....... import enums
+from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Scc:
-	"""Scc commands group definition. 2 total commands, 0 Sub-groups, 2 group commands
+class SccCls:
+	"""Scc commands group definition. 2 total commands, 0 Subgroups, 2 group commands
 	Repeated Capability: SecondaryCC, default value after init: SecondaryCC.CC1"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("scc", core, parent)
-		self._base.rep_cap = RepeatedCapability(self._base.group_name, 'repcap_secondaryCC_get', 'repcap_secondaryCC_set', repcap.SecondaryCC.CC1)
+		self._cmd_group = CommandsGroup("scc", core, parent)
+		self._cmd_group.rep_cap = RepeatedCapability(self._cmd_group.group_name, 'repcap_secondaryCC_get', 'repcap_secondaryCC_set', repcap.SecondaryCC.CC1)
 
-	def repcap_secondaryCC_set(self, enum_value: repcap.SecondaryCC) -> None:
+	def repcap_secondaryCC_set(self, secondaryCC: repcap.SecondaryCC) -> None:
 		"""Repeated Capability default value numeric suffix.
 		This value is used, if you do not explicitely set it in the child set/get methods, or if you leave it to SecondaryCC.Default
 		Default value after init: SecondaryCC.CC1"""
-		self._base.set_repcap_enum_value(enum_value)
+		self._cmd_group.set_repcap_enum_value(secondaryCC)
 
 	def repcap_secondaryCC_get(self) -> repcap.SecondaryCC:
 		"""Returns the current default repeated capability for the child set/get methods"""
 		# noinspection PyTypeChecker
-		return self._base.get_repcap_enum_value()
+		return self._cmd_group.get_repcap_enum_value()
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
 			- Reliability: int: No parameter help available
 			- Channel_Type: List[enums.RbTableChannelType]: No parameter help available
 			- Offset_Rb: List[int]: No parameter help available
@@ -49,30 +49,30 @@
 			self.Reliability: int = None
 			self.Channel_Type: List[enums.RbTableChannelType] = None
 			self.Offset_Rb: List[int] = None
 			self.No_Rb: List[int] = None
 
 	def read(self, secondaryCC=repcap.SecondaryCC.Default) -> ResultData:
 		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:TRACe:RBATable:ULCA:SCC<Nr> \n
-		Snippet: value: ResultData = driver.multiEval.trace.rbaTable.ulca.scc.read(secondaryCC = repcap.SecondaryCC.Default) \n
+		Snippet: value: ResultData = driver.lteMeas.multiEval.trace.rbaTable.ulca.scc.read(secondaryCC = repcap.SecondaryCC.Default) \n
 		No command help available \n
 			:param secondaryCC: optional repeated capability selector. Default value: CC1 (settable in the interface 'Scc')
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		secondaryCC_cmd_val = self._base.get_repcap_cmd_value(secondaryCC, repcap.SecondaryCC)
+		secondaryCC_cmd_val = self._cmd_group.get_repcap_cmd_value(secondaryCC, repcap.SecondaryCC)
 		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:MEValuation:TRACe:RBATable:ULCA:SCC{secondaryCC_cmd_val}?', self.__class__.ResultData())
 
 	def fetch(self, secondaryCC=repcap.SecondaryCC.Default) -> ResultData:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:TRACe:RBATable:ULCA:SCC<Nr> \n
-		Snippet: value: ResultData = driver.multiEval.trace.rbaTable.ulca.scc.fetch(secondaryCC = repcap.SecondaryCC.Default) \n
+		Snippet: value: ResultData = driver.lteMeas.multiEval.trace.rbaTable.ulca.scc.fetch(secondaryCC = repcap.SecondaryCC.Default) \n
 		No command help available \n
 			:param secondaryCC: optional repeated capability selector. Default value: CC1 (settable in the interface 'Scc')
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		secondaryCC_cmd_val = self._base.get_repcap_cmd_value(secondaryCC, repcap.SecondaryCC)
+		secondaryCC_cmd_val = self._cmd_group.get_repcap_cmd_value(secondaryCC, repcap.SecondaryCC)
 		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:MEValuation:TRACe:RBATable:ULCA:SCC{secondaryCC_cmd_val}?', self.__class__.ResultData())
 
-	def clone(self) -> 'Scc':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'SccCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Scc(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = SccCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Trace_/SeMask.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/Evm/Rms/__init__.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,27 +1,35 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
+from ........Internal.Core import Core
+from ........Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class SeMask:
-	"""SeMask commands group definition. 6 total commands, 1 Sub-groups, 0 group commands"""
+class RmsCls:
+	"""Rms commands group definition. 14 total commands, 2 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("seMask", core, parent)
+		self._cmd_group = CommandsGroup("rms", core, parent)
 
 	@property
-	def rbw(self):
-		"""rbw commands group. 3 Sub-classes, 0 commands."""
-		if not hasattr(self, '_rbw'):
-			from .SeMask_.Rbw import Rbw
-			self._rbw = Rbw(self._core, self._base)
-		return self._rbw
+	def low(self):
+		"""low commands group. 4 Sub-classes, 0 commands."""
+		if not hasattr(self, '_low'):
+			from .Low import LowCls
+			self._low = LowCls(self._core, self._cmd_group)
+		return self._low
 
-	def clone(self) -> 'SeMask':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	@property
+	def high(self):
+		"""high commands group. 4 Sub-classes, 0 commands."""
+		if not hasattr(self, '_high'):
+			from .High import HighCls
+			self._high = HighCls(self._core, self._cmd_group)
+		return self._high
+
+	def clone(self) -> 'RmsCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = SeMask(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = RmsCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Trace_/SeMask_/Rbw.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Amarker/__init__.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,58 +1,74 @@
 from .....Internal.Core import Core
 from .....Internal.CommandsGroup import CommandsGroup
 from .....Internal.RepeatedCapability import RepeatedCapability
 from ..... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Rbw:
-	"""Rbw commands group definition. 6 total commands, 3 Sub-groups, 0 group commands
-	Repeated Capability: RBWkHz, default value after init: RBWkHz.Rbw30"""
+class AmarkerCls:
+	"""Amarker commands group definition. 6 total commands, 5 Subgroups, 0 group commands
+	Repeated Capability: AbsMarker, default value after init: AbsMarker.Nr1"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("rbw", core, parent)
-		self._base.rep_cap = RepeatedCapability(self._base.group_name, 'repcap_rBWkHz_get', 'repcap_rBWkHz_set', repcap.RBWkHz.Rbw30)
+		self._cmd_group = CommandsGroup("amarker", core, parent)
+		self._cmd_group.rep_cap = RepeatedCapability(self._cmd_group.group_name, 'repcap_absMarker_get', 'repcap_absMarker_set', repcap.AbsMarker.Nr1)
 
-	def repcap_rBWkHz_set(self, enum_value: repcap.RBWkHz) -> None:
+	def repcap_absMarker_set(self, absMarker: repcap.AbsMarker) -> None:
 		"""Repeated Capability default value numeric suffix.
-		This value is used, if you do not explicitely set it in the child set/get methods, or if you leave it to RBWkHz.Default
-		Default value after init: RBWkHz.Rbw30"""
-		self._base.set_repcap_enum_value(enum_value)
+		This value is used, if you do not explicitely set it in the child set/get methods, or if you leave it to AbsMarker.Default
+		Default value after init: AbsMarker.Nr1"""
+		self._cmd_group.set_repcap_enum_value(absMarker)
 
-	def repcap_rBWkHz_get(self) -> repcap.RBWkHz:
+	def repcap_absMarker_get(self) -> repcap.AbsMarker:
 		"""Returns the current default repeated capability for the child set/get methods"""
 		# noinspection PyTypeChecker
-		return self._base.get_repcap_enum_value()
+		return self._cmd_group.get_repcap_enum_value()
 
 	@property
-	def current(self):
-		"""current commands group. 0 Sub-classes, 2 commands."""
-		if not hasattr(self, '_current'):
-			from .Rbw_.Current import Current
-			self._current = Current(self._core, self._base)
-		return self._current
+	def pdynamics(self):
+		"""pdynamics commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_pdynamics'):
+			from .Pdynamics import PdynamicsCls
+			self._pdynamics = PdynamicsCls(self._core, self._cmd_group)
+		return self._pdynamics
 
 	@property
-	def average(self):
-		"""average commands group. 0 Sub-classes, 2 commands."""
-		if not hasattr(self, '_average'):
-			from .Rbw_.Average import Average
-			self._average = Average(self._core, self._base)
-		return self._average
+	def pmonitor(self):
+		"""pmonitor commands group. 1 Sub-classes, 0 commands."""
+		if not hasattr(self, '_pmonitor'):
+			from .Pmonitor import PmonitorCls
+			self._pmonitor = PmonitorCls(self._core, self._cmd_group)
+		return self._pmonitor
 
 	@property
-	def maximum(self):
-		"""maximum commands group. 0 Sub-classes, 2 commands."""
-		if not hasattr(self, '_maximum'):
-			from .Rbw_.Maximum import Maximum
-			self._maximum = Maximum(self._core, self._base)
-		return self._maximum
+	def evMagnitude(self):
+		"""evMagnitude commands group. 1 Sub-classes, 1 commands."""
+		if not hasattr(self, '_evMagnitude'):
+			from .EvMagnitude import EvMagnitudeCls
+			self._evMagnitude = EvMagnitudeCls(self._core, self._cmd_group)
+		return self._evMagnitude
 
-	def clone(self) -> 'Rbw':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	@property
+	def merror(self):
+		"""merror commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_merror'):
+			from .Merror import MerrorCls
+			self._merror = MerrorCls(self._core, self._cmd_group)
+		return self._merror
+
+	@property
+	def perror(self):
+		"""perror commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_perror'):
+			from .Perror import PerrorCls
+			self._perror = PerrorCls(self._core, self._cmd_group)
+		return self._perror
+
+	def clone(self) -> 'AmarkerCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Rbw(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = AmarkerCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Trace_/SeMask_/Rbw_/Average.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Trace/SeMask/Rbw/Average.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,44 +1,44 @@
 from typing import List
 
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ......Internal.Types import DataType
-from ...... import repcap
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .......Internal.Types import DataType
+from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class AverageCls:
+	"""Average commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	def read(self, rBWkHz=repcap.RBWkHz.Default) -> List[float]:
 		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:TRACe:SEMask:RBW<kHz>:AVERage \n
-		Snippet: value: List[float] = driver.multiEval.trace.seMask.rbw.average.read(rBWkHz = repcap.RBWkHz.Default) \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.trace.seMask.rbw.average.read(rBWkHz = repcap.RBWkHz.Default) \n
 		Returns the values of the spectrum emission traces. Separate traces are available for the individual resolution
 		bandwidths (<kHz>) . The results of the current, average and maximum traces can be retrieved. See also 'Square Spectrum
 		Emission Mask'. \n
 		Suppressed linked return values: reliability \n
 			:param rBWkHz: optional repeated capability selector. Default value: Rbw30 (settable in the interface 'Rbw')
-			:return: power: Comma-separated list of power results The value in the middle of the result array corresponds to the center frequency. The test point separation between two results depends on the resolution bandwidth, see table below. For RBW100 and greater, results are only available for frequencies with active limits using these RBWs. For other frequencies, INV is returned."""
-		rBWkHz_cmd_val = self._base.get_repcap_cmd_value(rBWkHz, repcap.RBWkHz)
+			:return: power: Comma-separated list of power results The value in the middle of the result array corresponds to the center frequency. The test point separation between adjacent results depends on the resolution bandwidth, see table below. For RBW100 and greater, results are only available for frequencies with active limits using these RBWs. For other frequencies, INV is returned."""
+		rBWkHz_cmd_val = self._cmd_group.get_repcap_cmd_value(rBWkHz, repcap.RBWkHz)
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:LTE:MEASurement<Instance>:MEValuation:TRACe:SEMask:RBW{rBWkHz_cmd_val}:AVERage?', suppressed)
 		return response
 
 	def fetch(self, rBWkHz=repcap.RBWkHz.Default) -> List[float]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:TRACe:SEMask:RBW<kHz>:AVERage \n
-		Snippet: value: List[float] = driver.multiEval.trace.seMask.rbw.average.fetch(rBWkHz = repcap.RBWkHz.Default) \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.trace.seMask.rbw.average.fetch(rBWkHz = repcap.RBWkHz.Default) \n
 		Returns the values of the spectrum emission traces. Separate traces are available for the individual resolution
 		bandwidths (<kHz>) . The results of the current, average and maximum traces can be retrieved. See also 'Square Spectrum
 		Emission Mask'. \n
 		Suppressed linked return values: reliability \n
 			:param rBWkHz: optional repeated capability selector. Default value: Rbw30 (settable in the interface 'Rbw')
-			:return: power: Comma-separated list of power results The value in the middle of the result array corresponds to the center frequency. The test point separation between two results depends on the resolution bandwidth, see table below. For RBW100 and greater, results are only available for frequencies with active limits using these RBWs. For other frequencies, INV is returned."""
-		rBWkHz_cmd_val = self._base.get_repcap_cmd_value(rBWkHz, repcap.RBWkHz)
+			:return: power: Comma-separated list of power results The value in the middle of the result array corresponds to the center frequency. The test point separation between adjacent results depends on the resolution bandwidth, see table below. For RBW100 and greater, results are only available for frequencies with active limits using these RBWs. For other frequencies, INV is returned."""
+		rBWkHz_cmd_val = self._cmd_group.get_repcap_cmd_value(rBWkHz, repcap.RBWkHz)
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:TRACe:SEMask:RBW{rBWkHz_cmd_val}:AVERage?', suppressed)
 		return response
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Trace_/SeMask_/Rbw_/Current.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Trace/SeMask/Rbw/Current.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,44 +1,44 @@
 from typing import List
 
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ......Internal.Types import DataType
-from ...... import repcap
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .......Internal.Types import DataType
+from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	def read(self, rBWkHz=repcap.RBWkHz.Default) -> List[float]:
 		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:TRACe:SEMask:RBW<kHz>:CURRent \n
-		Snippet: value: List[float] = driver.multiEval.trace.seMask.rbw.current.read(rBWkHz = repcap.RBWkHz.Default) \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.trace.seMask.rbw.current.read(rBWkHz = repcap.RBWkHz.Default) \n
 		Returns the values of the spectrum emission traces. Separate traces are available for the individual resolution
 		bandwidths (<kHz>) . The results of the current, average and maximum traces can be retrieved. See also 'Square Spectrum
 		Emission Mask'. \n
 		Suppressed linked return values: reliability \n
 			:param rBWkHz: optional repeated capability selector. Default value: Rbw30 (settable in the interface 'Rbw')
-			:return: power: Comma-separated list of power results The value in the middle of the result array corresponds to the center frequency. The test point separation between two results depends on the resolution bandwidth, see table below. For RBW100 and greater, results are only available for frequencies with active limits using these RBWs. For other frequencies, INV is returned."""
-		rBWkHz_cmd_val = self._base.get_repcap_cmd_value(rBWkHz, repcap.RBWkHz)
+			:return: power: Comma-separated list of power results The value in the middle of the result array corresponds to the center frequency. The test point separation between adjacent results depends on the resolution bandwidth, see table below. For RBW100 and greater, results are only available for frequencies with active limits using these RBWs. For other frequencies, INV is returned."""
+		rBWkHz_cmd_val = self._cmd_group.get_repcap_cmd_value(rBWkHz, repcap.RBWkHz)
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:LTE:MEASurement<Instance>:MEValuation:TRACe:SEMask:RBW{rBWkHz_cmd_val}:CURRent?', suppressed)
 		return response
 
 	def fetch(self, rBWkHz=repcap.RBWkHz.Default) -> List[float]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:TRACe:SEMask:RBW<kHz>:CURRent \n
-		Snippet: value: List[float] = driver.multiEval.trace.seMask.rbw.current.fetch(rBWkHz = repcap.RBWkHz.Default) \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.trace.seMask.rbw.current.fetch(rBWkHz = repcap.RBWkHz.Default) \n
 		Returns the values of the spectrum emission traces. Separate traces are available for the individual resolution
 		bandwidths (<kHz>) . The results of the current, average and maximum traces can be retrieved. See also 'Square Spectrum
 		Emission Mask'. \n
 		Suppressed linked return values: reliability \n
 			:param rBWkHz: optional repeated capability selector. Default value: Rbw30 (settable in the interface 'Rbw')
-			:return: power: Comma-separated list of power results The value in the middle of the result array corresponds to the center frequency. The test point separation between two results depends on the resolution bandwidth, see table below. For RBW100 and greater, results are only available for frequencies with active limits using these RBWs. For other frequencies, INV is returned."""
-		rBWkHz_cmd_val = self._base.get_repcap_cmd_value(rBWkHz, repcap.RBWkHz)
+			:return: power: Comma-separated list of power results The value in the middle of the result array corresponds to the center frequency. The test point separation between adjacent results depends on the resolution bandwidth, see table below. For RBW100 and greater, results are only available for frequencies with active limits using these RBWs. For other frequencies, INV is returned."""
+		rBWkHz_cmd_val = self._cmd_group.get_repcap_cmd_value(rBWkHz, repcap.RBWkHz)
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:TRACe:SEMask:RBW{rBWkHz_cmd_val}:CURRent?', suppressed)
 		return response
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/MultiEval_/Trace_/SeMask_/Rbw_/Maximum.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Trace/SeMask/Rbw/Maximum.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,44 +1,44 @@
 from typing import List
 
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ......Internal.Types import DataType
-from ...... import repcap
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .......Internal.Types import DataType
+from ....... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Maximum:
-	"""Maximum commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class MaximumCls:
+	"""Maximum commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("maximum", core, parent)
+		self._cmd_group = CommandsGroup("maximum", core, parent)
 
 	def read(self, rBWkHz=repcap.RBWkHz.Default) -> List[float]:
 		"""SCPI: READ:LTE:MEASurement<Instance>:MEValuation:TRACe:SEMask:RBW<kHz>:MAXimum \n
-		Snippet: value: List[float] = driver.multiEval.trace.seMask.rbw.maximum.read(rBWkHz = repcap.RBWkHz.Default) \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.trace.seMask.rbw.maximum.read(rBWkHz = repcap.RBWkHz.Default) \n
 		Returns the values of the spectrum emission traces. Separate traces are available for the individual resolution
 		bandwidths (<kHz>) . The results of the current, average and maximum traces can be retrieved. See also 'Square Spectrum
 		Emission Mask'. \n
 		Suppressed linked return values: reliability \n
 			:param rBWkHz: optional repeated capability selector. Default value: Rbw30 (settable in the interface 'Rbw')
-			:return: power: Comma-separated list of power results The value in the middle of the result array corresponds to the center frequency. The test point separation between two results depends on the resolution bandwidth, see table below. For RBW100 and greater, results are only available for frequencies with active limits using these RBWs. For other frequencies, INV is returned."""
-		rBWkHz_cmd_val = self._base.get_repcap_cmd_value(rBWkHz, repcap.RBWkHz)
+			:return: power: Comma-separated list of power results The value in the middle of the result array corresponds to the center frequency. The test point separation between adjacent results depends on the resolution bandwidth, see table below. For RBW100 and greater, results are only available for frequencies with active limits using these RBWs. For other frequencies, INV is returned."""
+		rBWkHz_cmd_val = self._cmd_group.get_repcap_cmd_value(rBWkHz, repcap.RBWkHz)
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:LTE:MEASurement<Instance>:MEValuation:TRACe:SEMask:RBW{rBWkHz_cmd_val}:MAXimum?', suppressed)
 		return response
 
 	def fetch(self, rBWkHz=repcap.RBWkHz.Default) -> List[float]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:TRACe:SEMask:RBW<kHz>:MAXimum \n
-		Snippet: value: List[float] = driver.multiEval.trace.seMask.rbw.maximum.fetch(rBWkHz = repcap.RBWkHz.Default) \n
+		Snippet: value: List[float] = driver.lteMeas.multiEval.trace.seMask.rbw.maximum.fetch(rBWkHz = repcap.RBWkHz.Default) \n
 		Returns the values of the spectrum emission traces. Separate traces are available for the individual resolution
 		bandwidths (<kHz>) . The results of the current, average and maximum traces can be retrieved. See also 'Square Spectrum
 		Emission Mask'. \n
 		Suppressed linked return values: reliability \n
 			:param rBWkHz: optional repeated capability selector. Default value: Rbw30 (settable in the interface 'Rbw')
-			:return: power: Comma-separated list of power results The value in the middle of the result array corresponds to the center frequency. The test point separation between two results depends on the resolution bandwidth, see table below. For RBW100 and greater, results are only available for frequencies with active limits using these RBWs. For other frequencies, INV is returned."""
-		rBWkHz_cmd_val = self._base.get_repcap_cmd_value(rBWkHz, repcap.RBWkHz)
+			:return: power: Comma-separated list of power results The value in the middle of the result array corresponds to the center frequency. The test point separation between adjacent results depends on the resolution bandwidth, see table below. For RBW100 and greater, results are only available for frequencies with active limits using these RBWs. For other frequencies, INV is returned."""
+		rBWkHz_cmd_val = self._cmd_group.get_repcap_cmd_value(rBWkHz, repcap.RBWkHz)
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:TRACe:SEMask:RBW{rBWkHz_cmd_val}:MAXimum?', suppressed)
 		return response
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Prach.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/Srs/__init__.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,120 +1,88 @@
-from ..Internal.Core import Core
-from ..Internal.CommandsGroup import CommandsGroup
+from ....Internal.Core import Core
+from ....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Prach:
-	"""Prach commands group definition. 69 total commands, 4 Sub-groups, 3 group commands"""
+class SrsCls:
+	"""Srs commands group definition. 26 total commands, 3 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("prach", core, parent)
+		self._cmd_group = CommandsGroup("srs", core, parent)
 
 	@property
 	def state(self):
 		"""state commands group. 1 Sub-classes, 1 commands."""
 		if not hasattr(self, '_state'):
-			from .Prach_.State import State
-			self._state = State(self._core, self._base)
+			from .State import StateCls
+			self._state = StateCls(self._core, self._cmd_group)
 		return self._state
 
 	@property
 	def trace(self):
-		"""trace commands group. 7 Sub-classes, 0 commands."""
+		"""trace commands group. 1 Sub-classes, 0 commands."""
 		if not hasattr(self, '_trace'):
-			from .Prach_.Trace import Trace
-			self._trace = Trace(self._core, self._base)
+			from .Trace import TraceCls
+			self._trace = TraceCls(self._core, self._cmd_group)
 		return self._trace
 
 	@property
-	def modulation(self):
-		"""modulation commands group. 8 Sub-classes, 0 commands."""
-		if not hasattr(self, '_modulation'):
-			from .Prach_.Modulation import Modulation
-			self._modulation = Modulation(self._core, self._base)
-		return self._modulation
-
-	@property
 	def pdynamics(self):
 		"""pdynamics commands group. 5 Sub-classes, 0 commands."""
 		if not hasattr(self, '_pdynamics'):
-			from .Prach_.Pdynamics import Pdynamics
-			self._pdynamics = Pdynamics(self._core, self._base)
+			from .Pdynamics import PdynamicsCls
+			self._pdynamics = PdynamicsCls(self._core, self._cmd_group)
 		return self._pdynamics
 
-	def initiate(self) -> None:
-		"""SCPI: INITiate:LTE:MEASurement<Instance>:PRACh \n
-		Snippet: driver.prach.initiate() \n
-			INTRO_CMD_HELP: Starts, stops, or aborts the measurement: \n
-			- INITiate... starts or restarts the measurement. The measurement enters the 'RUN' state.
-			- STOP... halts the measurement immediately. The measurement enters the 'RDY' state. Measurement results are kept. The resources remain allocated to the measurement.
-			- ABORt... halts the measurement immediately. The measurement enters the 'OFF' state. All measurement values are set to NAV. Allocated resources are released.
+	def initiate(self, opc_timeout_ms: int = -1) -> None:
+		"""SCPI: INITiate:LTE:MEASurement<Instance>:SRS \n
+		Snippet: driver.lteMeas.srs.initiate() \n
+			INTRO_CMD_HELP: Starts, stops or aborts the measurement: \n
+			- INITiate... starts or restarts the measurement. The measurement enters the RUN state.
+			- STOP... halts the measurement immediately. The measurement enters the RDY state. Measurement results are kept. The resources remain allocated to the measurement.
+			- ABORt... halts the measurement immediately. The measurement enters the OFF state. All measurement values are set to NAV. Allocated resources are released.
 		Use FETCh...STATe? to query the current measurement state. \n
-		"""
-		self._core.io.write(f'INITiate:LTE:MEASurement<Instance>:PRACh')
-
-	def initiate_with_opc(self) -> None:
-		"""SCPI: INITiate:LTE:MEASurement<Instance>:PRACh \n
-		Snippet: driver.prach.initiate_with_opc() \n
-			INTRO_CMD_HELP: Starts, stops, or aborts the measurement: \n
-			- INITiate... starts or restarts the measurement. The measurement enters the 'RUN' state.
-			- STOP... halts the measurement immediately. The measurement enters the 'RDY' state. Measurement results are kept. The resources remain allocated to the measurement.
-			- ABORt... halts the measurement immediately. The measurement enters the 'OFF' state. All measurement values are set to NAV. Allocated resources are released.
-		Use FETCh...STATe? to query the current measurement state. \n
-		Same as initiate, but waits for the operation to complete before continuing further. Use the RsCMPX_LteMeas.utilities.opc_timeout_set() to set the timeout value. \n
-		"""
-		self._core.io.write_with_opc(f'INITiate:LTE:MEASurement<Instance>:PRACh')
+			:param opc_timeout_ms: Maximum time to wait in milliseconds, valid only for this call."""
+		self._core.io.write_with_opc(f'INITiate:LTE:MEASurement<Instance>:SRS', opc_timeout_ms)
 
 	def stop(self) -> None:
-		"""SCPI: STOP:LTE:MEASurement<Instance>:PRACh \n
-		Snippet: driver.prach.stop() \n
-			INTRO_CMD_HELP: Starts, stops, or aborts the measurement: \n
-			- INITiate... starts or restarts the measurement. The measurement enters the 'RUN' state.
-			- STOP... halts the measurement immediately. The measurement enters the 'RDY' state. Measurement results are kept. The resources remain allocated to the measurement.
-			- ABORt... halts the measurement immediately. The measurement enters the 'OFF' state. All measurement values are set to NAV. Allocated resources are released.
-		Use FETCh...STATe? to query the current measurement state. \n
-		"""
-		self._core.io.write(f'STOP:LTE:MEASurement<Instance>:PRACh')
-
-	def stop_with_opc(self) -> None:
-		"""SCPI: STOP:LTE:MEASurement<Instance>:PRACh \n
-		Snippet: driver.prach.stop_with_opc() \n
-			INTRO_CMD_HELP: Starts, stops, or aborts the measurement: \n
-			- INITiate... starts or restarts the measurement. The measurement enters the 'RUN' state.
-			- STOP... halts the measurement immediately. The measurement enters the 'RDY' state. Measurement results are kept. The resources remain allocated to the measurement.
-			- ABORt... halts the measurement immediately. The measurement enters the 'OFF' state. All measurement values are set to NAV. Allocated resources are released.
+		"""SCPI: STOP:LTE:MEASurement<Instance>:SRS \n
+		Snippet: driver.lteMeas.srs.stop() \n
+			INTRO_CMD_HELP: Starts, stops or aborts the measurement: \n
+			- INITiate... starts or restarts the measurement. The measurement enters the RUN state.
+			- STOP... halts the measurement immediately. The measurement enters the RDY state. Measurement results are kept. The resources remain allocated to the measurement.
+			- ABORt... halts the measurement immediately. The measurement enters the OFF state. All measurement values are set to NAV. Allocated resources are released.
+		Use FETCh...STATe? to query the current measurement state. \n
+		"""
+		self._core.io.write(f'STOP:LTE:MEASurement<Instance>:SRS')
+
+	def stop_with_opc(self, opc_timeout_ms: int = -1) -> None:
+		"""SCPI: STOP:LTE:MEASurement<Instance>:SRS \n
+		Snippet: driver.lteMeas.srs.stop_with_opc() \n
+			INTRO_CMD_HELP: Starts, stops or aborts the measurement: \n
+			- INITiate... starts or restarts the measurement. The measurement enters the RUN state.
+			- STOP... halts the measurement immediately. The measurement enters the RDY state. Measurement results are kept. The resources remain allocated to the measurement.
+			- ABORt... halts the measurement immediately. The measurement enters the OFF state. All measurement values are set to NAV. Allocated resources are released.
 		Use FETCh...STATe? to query the current measurement state. \n
 		Same as stop, but waits for the operation to complete before continuing further. Use the RsCMPX_LteMeas.utilities.opc_timeout_set() to set the timeout value. \n
-		"""
-		self._core.io.write_with_opc(f'STOP:LTE:MEASurement<Instance>:PRACh')
+			:param opc_timeout_ms: Maximum time to wait in milliseconds, valid only for this call."""
+		self._core.io.write_with_opc(f'STOP:LTE:MEASurement<Instance>:SRS', opc_timeout_ms)
 
-	def abort(self) -> None:
-		"""SCPI: ABORt:LTE:MEASurement<Instance>:PRACh \n
-		Snippet: driver.prach.abort() \n
-			INTRO_CMD_HELP: Starts, stops, or aborts the measurement: \n
-			- INITiate... starts or restarts the measurement. The measurement enters the 'RUN' state.
-			- STOP... halts the measurement immediately. The measurement enters the 'RDY' state. Measurement results are kept. The resources remain allocated to the measurement.
-			- ABORt... halts the measurement immediately. The measurement enters the 'OFF' state. All measurement values are set to NAV. Allocated resources are released.
+	def abort(self, opc_timeout_ms: int = -1) -> None:
+		"""SCPI: ABORt:LTE:MEASurement<Instance>:SRS \n
+		Snippet: driver.lteMeas.srs.abort() \n
+			INTRO_CMD_HELP: Starts, stops or aborts the measurement: \n
+			- INITiate... starts or restarts the measurement. The measurement enters the RUN state.
+			- STOP... halts the measurement immediately. The measurement enters the RDY state. Measurement results are kept. The resources remain allocated to the measurement.
+			- ABORt... halts the measurement immediately. The measurement enters the OFF state. All measurement values are set to NAV. Allocated resources are released.
 		Use FETCh...STATe? to query the current measurement state. \n
-		"""
-		self._core.io.write(f'ABORt:LTE:MEASurement<Instance>:PRACh')
-
-	def abort_with_opc(self) -> None:
-		"""SCPI: ABORt:LTE:MEASurement<Instance>:PRACh \n
-		Snippet: driver.prach.abort_with_opc() \n
-			INTRO_CMD_HELP: Starts, stops, or aborts the measurement: \n
-			- INITiate... starts or restarts the measurement. The measurement enters the 'RUN' state.
-			- STOP... halts the measurement immediately. The measurement enters the 'RDY' state. Measurement results are kept. The resources remain allocated to the measurement.
-			- ABORt... halts the measurement immediately. The measurement enters the 'OFF' state. All measurement values are set to NAV. Allocated resources are released.
-		Use FETCh...STATe? to query the current measurement state. \n
-		Same as abort, but waits for the operation to complete before continuing further. Use the RsCMPX_LteMeas.utilities.opc_timeout_set() to set the timeout value. \n
-		"""
-		self._core.io.write_with_opc(f'ABORt:LTE:MEASurement<Instance>:PRACh')
+			:param opc_timeout_ms: Maximum time to wait in milliseconds, valid only for this call."""
+		self._core.io.write_with_opc(f'ABORt:LTE:MEASurement<Instance>:SRS', opc_timeout_ms)
 
-	def clone(self) -> 'Prach':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'SrsCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Prach(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = SrsCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Prach_/Modulation_/Average.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/Prach/Modulation/Current.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,42 +1,42 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
-from ....Internal.StructBase import StructBase
-from ....Internal.ArgStruct import ArgStruct
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
+from .....Internal.StructBase import StructBase
+from .....Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Out_Of_Tolerance: int: Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for modulation measurements exceeding the specified modulation limits.
-			- Evm_Rms_Low: float: EVM RMS value, low EVM window position
-			- Evm_Rms_High: float: EVM RMS value, high EVM window position
-			- Evm_Peak_Low: float: EVM peak value, low EVM window position
-			- Evm_Peak_High: float: EVM peak value, high EVM window position
-			- Mag_Error_Rms_Low: float: Magnitude error RMS value, low EVM window position
-			- Mag_Error_Rms_High: float: Magnitude error RMS value, low EVM window position
-			- Mag_Error_Peak_Low: float: Magnitude error peak value, low EVM window position
-			- Mag_Err_Peak_High: float: Magnitude error peak value, high EVM window position
-			- Ph_Error_Rms_Low: float: Phase error RMS value, low EVM window position
-			- Ph_Error_Rms_High: float: Phase error RMS value, high EVM window position
-			- Ph_Error_Peak_Low: float: Phase error peak value, low EVM window position
-			- Ph_Error_Peak_High: float: Phase error peak value, high EVM window position
-			- Frequency_Error: float: Carrier frequency error
-			- Timing_Error: float: Transmit time error
-			- Tx_Power: float: User equipment power
-			- Peak_Power: float: User equipment peak power"""
+			- Reliability: int: 'Reliability indicator'
+			- Out_Of_Tolerance: int: Out of tolerance result, i.e. the percentage of measurement intervals of the statistic count for modulation measurements exceeding the specified modulation limits.
+			- Evm_Rms_Low: float: EVM RMS value, low EVM window position.
+			- Evm_Rms_High: float: EVM RMS value, high EVM window position.
+			- Evm_Peak_Low: float: EVM peak value, low EVM window position.
+			- Evm_Peak_High: float: EVM peak value, high EVM window position.
+			- Mag_Error_Rms_Low: float: Magnitude error RMS value, low EVM window position.
+			- Mag_Error_Rms_High: float: Magnitude error RMS value, low EVM window position.
+			- Mag_Error_Peak_Low: float: Magnitude error peak value, low EVM window position.
+			- Mag_Err_Peak_High: float: Magnitude error peak value, high EVM window position.
+			- Ph_Error_Rms_Low: float: Phase error RMS value, low EVM window position.
+			- Ph_Error_Rms_High: float: Phase error RMS value, high EVM window position.
+			- Ph_Error_Peak_Low: float: Phase error peak value, low EVM window position.
+			- Ph_Error_Peak_High: float: Phase error peak value, high EVM window position.
+			- Frequency_Error: float: Carrier frequency error.
+			- Timing_Error: float: Transmit time error.
+			- Tx_Power: float: UE RMS power.
+			- Peak_Power: float: UE peak power."""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
 			ArgStruct.scalar_float('Evm_Rms_Low'),
 			ArgStruct.scalar_float('Evm_Rms_High'),
 			ArgStruct.scalar_float('Evm_Peak_Low'),
 			ArgStruct.scalar_float('Evm_Peak_High'),
@@ -71,91 +71,91 @@
 			self.Ph_Error_Peak_High: float = None
 			self.Frequency_Error: float = None
 			self.Timing_Error: float = None
 			self.Tx_Power: float = None
 			self.Peak_Power: float = None
 
 	def read(self) -> ResultData:
-		"""SCPI: READ:LTE:MEASurement<Instance>:PRACh:MODulation:AVERage \n
-		Snippet: value: ResultData = driver.prach.modulation.average.read() \n
-		Return the current, average and standard deviation single value results. The values described below are returned by FETCh
+		"""SCPI: READ:LTE:MEASurement<Instance>:PRACh:MODulation:CURRent \n
+		Snippet: value: ResultData = driver.lteMeas.prach.modulation.current.read() \n
+		Return the current, average and standard deviation single-value results. The values described below are returned by FETCh
 		and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:PRACh:MODulation:AVERage?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:PRACh:MODulation:CURRent?', self.__class__.ResultData())
 
 	def fetch(self) -> ResultData:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:PRACh:MODulation:AVERage \n
-		Snippet: value: ResultData = driver.prach.modulation.average.fetch() \n
-		Return the current, average and standard deviation single value results. The values described below are returned by FETCh
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:PRACh:MODulation:CURRent \n
+		Snippet: value: ResultData = driver.lteMeas.prach.modulation.current.fetch() \n
+		Return the current, average and standard deviation single-value results. The values described below are returned by FETCh
 		and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:PRACh:MODulation:AVERage?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:PRACh:MODulation:CURRent?', self.__class__.ResultData())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Out_Of_Tolerance: int: Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for modulation measurements exceeding the specified modulation limits.
-			- Evm_Rms_Low: float: EVM RMS value, low EVM window position
-			- Evm_Rms_High: float: EVM RMS value, high EVM window position
-			- Evm_Peak_Low: float: EVM peak value, low EVM window position
-			- Evm_Peak_High: float: EVM peak value, high EVM window position
-			- Mag_Error_Rms_Low: float: Magnitude error RMS value, low EVM window position
-			- Mag_Error_Rms_High: float: Magnitude error RMS value, low EVM window position
-			- Mag_Error_Peak_Low: float: Magnitude error peak value, low EVM window position
-			- Mag_Err_Peak_High: float: Magnitude error peak value, high EVM window position
-			- Ph_Error_Rms_Low: float: Phase error RMS value, low EVM window position
-			- Ph_Error_Rms_High: float: Phase error RMS value, high EVM window position
-			- Ph_Error_Peak_Low: float: Phase error peak value, low EVM window position
-			- Ph_Error_Peak_High: float: Phase error peak value, high EVM window position
-			- Frequency_Error: float: Carrier frequency error
-			- Timing_Error: float: Transmit time error
-			- Tx_Power: float: User equipment power
-			- Peak_Power: float: User equipment peak power"""
+			- Reliability: int: 'Reliability indicator'
+			- Out_Of_Tolerance: int: Out of tolerance result, i.e. the percentage of measurement intervals of the statistic count for modulation measurements exceeding the specified modulation limits.
+			- Evm_Rms_Low: float or bool: EVM RMS value, low EVM window position.
+			- Evm_Rms_High: float or bool: EVM RMS value, high EVM window position.
+			- Evm_Peak_Low: float or bool: EVM peak value, low EVM window position.
+			- Evm_Peak_High: float or bool: EVM peak value, high EVM window position.
+			- Mag_Error_Rms_Low: float or bool: Magnitude error RMS value, low EVM window position.
+			- Mag_Error_Rms_High: float or bool: Magnitude error RMS value, low EVM window position.
+			- Mag_Error_Peak_Low: float or bool: Magnitude error peak value, low EVM window position.
+			- Mag_Err_Peak_High: float or bool: Magnitude error peak value, high EVM window position.
+			- Ph_Error_Rms_Low: float or bool: Phase error RMS value, low EVM window position.
+			- Ph_Error_Rms_High: float or bool: Phase error RMS value, high EVM window position.
+			- Ph_Error_Peak_Low: float or bool: Phase error peak value, low EVM window position.
+			- Ph_Error_Peak_High: float or bool: Phase error peak value, high EVM window position.
+			- Frequency_Error: float or bool: Carrier frequency error.
+			- Timing_Error: float or bool: Transmit time error.
+			- Tx_Power: float or bool: UE RMS power.
+			- Peak_Power: float or bool: UE peak power."""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
-			ArgStruct.scalar_float('Evm_Rms_Low'),
-			ArgStruct.scalar_float('Evm_Rms_High'),
-			ArgStruct.scalar_float('Evm_Peak_Low'),
-			ArgStruct.scalar_float('Evm_Peak_High'),
-			ArgStruct.scalar_float('Mag_Error_Rms_Low'),
-			ArgStruct.scalar_float('Mag_Error_Rms_High'),
-			ArgStruct.scalar_float('Mag_Error_Peak_Low'),
-			ArgStruct.scalar_float('Mag_Err_Peak_High'),
-			ArgStruct.scalar_float('Ph_Error_Rms_Low'),
-			ArgStruct.scalar_float('Ph_Error_Rms_High'),
-			ArgStruct.scalar_float('Ph_Error_Peak_Low'),
-			ArgStruct.scalar_float('Ph_Error_Peak_High'),
-			ArgStruct.scalar_float('Frequency_Error'),
-			ArgStruct.scalar_float('Timing_Error'),
-			ArgStruct.scalar_float('Tx_Power'),
-			ArgStruct.scalar_float('Peak_Power')]
+			ArgStruct.scalar_float_ext('Evm_Rms_Low'),
+			ArgStruct.scalar_float_ext('Evm_Rms_High'),
+			ArgStruct.scalar_float_ext('Evm_Peak_Low'),
+			ArgStruct.scalar_float_ext('Evm_Peak_High'),
+			ArgStruct.scalar_float_ext('Mag_Error_Rms_Low'),
+			ArgStruct.scalar_float_ext('Mag_Error_Rms_High'),
+			ArgStruct.scalar_float_ext('Mag_Error_Peak_Low'),
+			ArgStruct.scalar_float_ext('Mag_Err_Peak_High'),
+			ArgStruct.scalar_float_ext('Ph_Error_Rms_Low'),
+			ArgStruct.scalar_float_ext('Ph_Error_Rms_High'),
+			ArgStruct.scalar_float_ext('Ph_Error_Peak_Low'),
+			ArgStruct.scalar_float_ext('Ph_Error_Peak_High'),
+			ArgStruct.scalar_float_ext('Frequency_Error'),
+			ArgStruct.scalar_float_ext('Timing_Error'),
+			ArgStruct.scalar_float_ext('Tx_Power'),
+			ArgStruct.scalar_float_ext('Peak_Power')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tolerance: int = None
-			self.Evm_Rms_Low: float = None
-			self.Evm_Rms_High: float = None
-			self.Evm_Peak_Low: float = None
-			self.Evm_Peak_High: float = None
-			self.Mag_Error_Rms_Low: float = None
-			self.Mag_Error_Rms_High: float = None
-			self.Mag_Error_Peak_Low: float = None
-			self.Mag_Err_Peak_High: float = None
-			self.Ph_Error_Rms_Low: float = None
-			self.Ph_Error_Rms_High: float = None
-			self.Ph_Error_Peak_Low: float = None
-			self.Ph_Error_Peak_High: float = None
-			self.Frequency_Error: float = None
-			self.Timing_Error: float = None
-			self.Tx_Power: float = None
-			self.Peak_Power: float = None
+			self.Evm_Rms_Low: float or bool = None
+			self.Evm_Rms_High: float or bool = None
+			self.Evm_Peak_Low: float or bool = None
+			self.Evm_Peak_High: float or bool = None
+			self.Mag_Error_Rms_Low: float or bool = None
+			self.Mag_Error_Rms_High: float or bool = None
+			self.Mag_Error_Peak_Low: float or bool = None
+			self.Mag_Err_Peak_High: float or bool = None
+			self.Ph_Error_Rms_Low: float or bool = None
+			self.Ph_Error_Rms_High: float or bool = None
+			self.Ph_Error_Peak_Low: float or bool = None
+			self.Ph_Error_Peak_High: float or bool = None
+			self.Frequency_Error: float or bool = None
+			self.Timing_Error: float or bool = None
+			self.Tx_Power: float or bool = None
+			self.Peak_Power: float or bool = None
 
 	def calculate(self) -> CalculateStruct:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:PRACh:MODulation:AVERage \n
-		Snippet: value: CalculateStruct = driver.prach.modulation.average.calculate() \n
-		Return the current, average and standard deviation single value results. The values described below are returned by FETCh
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:PRACh:MODulation:CURRent \n
+		Snippet: value: CalculateStruct = driver.lteMeas.prach.modulation.current.calculate() \n
+		Return the current, average and standard deviation single-value results. The values described below are returned by FETCh
 		and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:PRACh:MODulation:AVERage?', self.__class__.CalculateStruct())
+		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:PRACh:MODulation:CURRent?', self.__class__.CalculateStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Prach_/Modulation_/Current.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/Prach/Modulation/Average.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,42 +1,42 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
-from ....Internal.StructBase import StructBase
-from ....Internal.ArgStruct import ArgStruct
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
+from .....Internal.StructBase import StructBase
+from .....Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class AverageCls:
+	"""Average commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Out_Of_Tolerance: int: Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for modulation measurements exceeding the specified modulation limits.
-			- Evm_Rms_Low: float: EVM RMS value, low EVM window position
-			- Evm_Rms_High: float: EVM RMS value, high EVM window position
-			- Evm_Peak_Low: float: EVM peak value, low EVM window position
-			- Evm_Peak_High: float: EVM peak value, high EVM window position
-			- Mag_Error_Rms_Low: float: Magnitude error RMS value, low EVM window position
-			- Mag_Error_Rms_High: float: Magnitude error RMS value, low EVM window position
-			- Mag_Error_Peak_Low: float: Magnitude error peak value, low EVM window position
-			- Mag_Err_Peak_High: float: Magnitude error peak value, high EVM window position
-			- Ph_Error_Rms_Low: float: Phase error RMS value, low EVM window position
-			- Ph_Error_Rms_High: float: Phase error RMS value, high EVM window position
-			- Ph_Error_Peak_Low: float: Phase error peak value, low EVM window position
-			- Ph_Error_Peak_High: float: Phase error peak value, high EVM window position
-			- Frequency_Error: float: Carrier frequency error
-			- Timing_Error: float: Transmit time error
-			- Tx_Power: float: User equipment power
-			- Peak_Power: float: User equipment peak power"""
+			- Reliability: int: 'Reliability indicator'
+			- Out_Of_Tolerance: int: Out of tolerance result, i.e. the percentage of measurement intervals of the statistic count for modulation measurements exceeding the specified modulation limits.
+			- Evm_Rms_Low: float: EVM RMS value, low EVM window position.
+			- Evm_Rms_High: float: EVM RMS value, high EVM window position.
+			- Evm_Peak_Low: float: EVM peak value, low EVM window position.
+			- Evm_Peak_High: float: EVM peak value, high EVM window position.
+			- Mag_Error_Rms_Low: float: Magnitude error RMS value, low EVM window position.
+			- Mag_Error_Rms_High: float: Magnitude error RMS value, low EVM window position.
+			- Mag_Error_Peak_Low: float: Magnitude error peak value, low EVM window position.
+			- Mag_Err_Peak_High: float: Magnitude error peak value, high EVM window position.
+			- Ph_Error_Rms_Low: float: Phase error RMS value, low EVM window position.
+			- Ph_Error_Rms_High: float: Phase error RMS value, high EVM window position.
+			- Ph_Error_Peak_Low: float: Phase error peak value, low EVM window position.
+			- Ph_Error_Peak_High: float: Phase error peak value, high EVM window position.
+			- Frequency_Error: float: Carrier frequency error.
+			- Timing_Error: float: Transmit time error.
+			- Tx_Power: float: UE RMS power.
+			- Peak_Power: float: UE peak power."""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
 			ArgStruct.scalar_float('Evm_Rms_Low'),
 			ArgStruct.scalar_float('Evm_Rms_High'),
 			ArgStruct.scalar_float('Evm_Peak_Low'),
 			ArgStruct.scalar_float('Evm_Peak_High'),
@@ -71,91 +71,91 @@
 			self.Ph_Error_Peak_High: float = None
 			self.Frequency_Error: float = None
 			self.Timing_Error: float = None
 			self.Tx_Power: float = None
 			self.Peak_Power: float = None
 
 	def read(self) -> ResultData:
-		"""SCPI: READ:LTE:MEASurement<Instance>:PRACh:MODulation:CURRent \n
-		Snippet: value: ResultData = driver.prach.modulation.current.read() \n
-		Return the current, average and standard deviation single value results. The values described below are returned by FETCh
+		"""SCPI: READ:LTE:MEASurement<Instance>:PRACh:MODulation:AVERage \n
+		Snippet: value: ResultData = driver.lteMeas.prach.modulation.average.read() \n
+		Return the current, average and standard deviation single-value results. The values described below are returned by FETCh
 		and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:PRACh:MODulation:CURRent?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:PRACh:MODulation:AVERage?', self.__class__.ResultData())
 
 	def fetch(self) -> ResultData:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:PRACh:MODulation:CURRent \n
-		Snippet: value: ResultData = driver.prach.modulation.current.fetch() \n
-		Return the current, average and standard deviation single value results. The values described below are returned by FETCh
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:PRACh:MODulation:AVERage \n
+		Snippet: value: ResultData = driver.lteMeas.prach.modulation.average.fetch() \n
+		Return the current, average and standard deviation single-value results. The values described below are returned by FETCh
 		and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:PRACh:MODulation:CURRent?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:PRACh:MODulation:AVERage?', self.__class__.ResultData())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Out_Of_Tolerance: int: Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for modulation measurements exceeding the specified modulation limits.
-			- Evm_Rms_Low: float: EVM RMS value, low EVM window position
-			- Evm_Rms_High: float: EVM RMS value, high EVM window position
-			- Evm_Peak_Low: float: EVM peak value, low EVM window position
-			- Evm_Peak_High: float: EVM peak value, high EVM window position
-			- Mag_Error_Rms_Low: float: Magnitude error RMS value, low EVM window position
-			- Mag_Error_Rms_High: float: Magnitude error RMS value, low EVM window position
-			- Mag_Error_Peak_Low: float: Magnitude error peak value, low EVM window position
-			- Mag_Err_Peak_High: float: Magnitude error peak value, high EVM window position
-			- Ph_Error_Rms_Low: float: Phase error RMS value, low EVM window position
-			- Ph_Error_Rms_High: float: Phase error RMS value, high EVM window position
-			- Ph_Error_Peak_Low: float: Phase error peak value, low EVM window position
-			- Ph_Error_Peak_High: float: Phase error peak value, high EVM window position
-			- Frequency_Error: float: Carrier frequency error
-			- Timing_Error: float: Transmit time error
-			- Tx_Power: float: User equipment power
-			- Peak_Power: float: User equipment peak power"""
+			- Reliability: int: 'Reliability indicator'
+			- Out_Of_Tolerance: int: Out of tolerance result, i.e. the percentage of measurement intervals of the statistic count for modulation measurements exceeding the specified modulation limits.
+			- Evm_Rms_Low: float or bool: EVM RMS value, low EVM window position.
+			- Evm_Rms_High: float or bool: EVM RMS value, high EVM window position.
+			- Evm_Peak_Low: float or bool: EVM peak value, low EVM window position.
+			- Evm_Peak_High: float or bool: EVM peak value, high EVM window position.
+			- Mag_Error_Rms_Low: float or bool: Magnitude error RMS value, low EVM window position.
+			- Mag_Error_Rms_High: float or bool: Magnitude error RMS value, low EVM window position.
+			- Mag_Error_Peak_Low: float or bool: Magnitude error peak value, low EVM window position.
+			- Mag_Err_Peak_High: float or bool: Magnitude error peak value, high EVM window position.
+			- Ph_Error_Rms_Low: float or bool: Phase error RMS value, low EVM window position.
+			- Ph_Error_Rms_High: float or bool: Phase error RMS value, high EVM window position.
+			- Ph_Error_Peak_Low: float or bool: Phase error peak value, low EVM window position.
+			- Ph_Error_Peak_High: float or bool: Phase error peak value, high EVM window position.
+			- Frequency_Error: float or bool: Carrier frequency error.
+			- Timing_Error: float or bool: Transmit time error.
+			- Tx_Power: float or bool: UE RMS power.
+			- Peak_Power: float or bool: UE peak power."""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
-			ArgStruct.scalar_float('Evm_Rms_Low'),
-			ArgStruct.scalar_float('Evm_Rms_High'),
-			ArgStruct.scalar_float('Evm_Peak_Low'),
-			ArgStruct.scalar_float('Evm_Peak_High'),
-			ArgStruct.scalar_float('Mag_Error_Rms_Low'),
-			ArgStruct.scalar_float('Mag_Error_Rms_High'),
-			ArgStruct.scalar_float('Mag_Error_Peak_Low'),
-			ArgStruct.scalar_float('Mag_Err_Peak_High'),
-			ArgStruct.scalar_float('Ph_Error_Rms_Low'),
-			ArgStruct.scalar_float('Ph_Error_Rms_High'),
-			ArgStruct.scalar_float('Ph_Error_Peak_Low'),
-			ArgStruct.scalar_float('Ph_Error_Peak_High'),
-			ArgStruct.scalar_float('Frequency_Error'),
-			ArgStruct.scalar_float('Timing_Error'),
-			ArgStruct.scalar_float('Tx_Power'),
-			ArgStruct.scalar_float('Peak_Power')]
+			ArgStruct.scalar_float_ext('Evm_Rms_Low'),
+			ArgStruct.scalar_float_ext('Evm_Rms_High'),
+			ArgStruct.scalar_float_ext('Evm_Peak_Low'),
+			ArgStruct.scalar_float_ext('Evm_Peak_High'),
+			ArgStruct.scalar_float_ext('Mag_Error_Rms_Low'),
+			ArgStruct.scalar_float_ext('Mag_Error_Rms_High'),
+			ArgStruct.scalar_float_ext('Mag_Error_Peak_Low'),
+			ArgStruct.scalar_float_ext('Mag_Err_Peak_High'),
+			ArgStruct.scalar_float_ext('Ph_Error_Rms_Low'),
+			ArgStruct.scalar_float_ext('Ph_Error_Rms_High'),
+			ArgStruct.scalar_float_ext('Ph_Error_Peak_Low'),
+			ArgStruct.scalar_float_ext('Ph_Error_Peak_High'),
+			ArgStruct.scalar_float_ext('Frequency_Error'),
+			ArgStruct.scalar_float_ext('Timing_Error'),
+			ArgStruct.scalar_float_ext('Tx_Power'),
+			ArgStruct.scalar_float_ext('Peak_Power')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tolerance: int = None
-			self.Evm_Rms_Low: float = None
-			self.Evm_Rms_High: float = None
-			self.Evm_Peak_Low: float = None
-			self.Evm_Peak_High: float = None
-			self.Mag_Error_Rms_Low: float = None
-			self.Mag_Error_Rms_High: float = None
-			self.Mag_Error_Peak_Low: float = None
-			self.Mag_Err_Peak_High: float = None
-			self.Ph_Error_Rms_Low: float = None
-			self.Ph_Error_Rms_High: float = None
-			self.Ph_Error_Peak_Low: float = None
-			self.Ph_Error_Peak_High: float = None
-			self.Frequency_Error: float = None
-			self.Timing_Error: float = None
-			self.Tx_Power: float = None
-			self.Peak_Power: float = None
+			self.Evm_Rms_Low: float or bool = None
+			self.Evm_Rms_High: float or bool = None
+			self.Evm_Peak_Low: float or bool = None
+			self.Evm_Peak_High: float or bool = None
+			self.Mag_Error_Rms_Low: float or bool = None
+			self.Mag_Error_Rms_High: float or bool = None
+			self.Mag_Error_Peak_Low: float or bool = None
+			self.Mag_Err_Peak_High: float or bool = None
+			self.Ph_Error_Rms_Low: float or bool = None
+			self.Ph_Error_Rms_High: float or bool = None
+			self.Ph_Error_Peak_Low: float or bool = None
+			self.Ph_Error_Peak_High: float or bool = None
+			self.Frequency_Error: float or bool = None
+			self.Timing_Error: float or bool = None
+			self.Tx_Power: float or bool = None
+			self.Peak_Power: float or bool = None
 
 	def calculate(self) -> CalculateStruct:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:PRACh:MODulation:CURRent \n
-		Snippet: value: CalculateStruct = driver.prach.modulation.current.calculate() \n
-		Return the current, average and standard deviation single value results. The values described below are returned by FETCh
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:PRACh:MODulation:AVERage \n
+		Snippet: value: CalculateStruct = driver.lteMeas.prach.modulation.average.calculate() \n
+		Return the current, average and standard deviation single-value results. The values described below are returned by FETCh
 		and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:PRACh:MODulation:CURRent?', self.__class__.CalculateStruct())
+		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:PRACh:MODulation:AVERage?', self.__class__.CalculateStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Prach_/Modulation_/DpfOffset.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/Prach/Modulation/Scorrelation/__init__.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,40 +1,42 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
-from ....Internal import Conversions
-from ....Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ....Internal.Types import DataType
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal import Conversions
+from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from ......Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class DpfOffset:
-	"""DpfOffset commands group definition. 2 total commands, 1 Sub-groups, 1 group commands"""
+class ScorrelationCls:
+	"""Scorrelation commands group definition. 2 total commands, 1 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("dpfOffset", core, parent)
+		self._cmd_group = CommandsGroup("scorrelation", core, parent)
 
 	@property
 	def preamble(self):
 		"""preamble commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_preamble'):
-			from .DpfOffset_.Preamble import Preamble
-			self._preamble = Preamble(self._core, self._base)
+			from .Preamble import PreambleCls
+			self._preamble = PreambleCls(self._core, self._cmd_group)
 		return self._preamble
 
-	def fetch(self) -> int:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:PRACh:MODulation:DPFoffset \n
-		Snippet: value: int = driver.prach.modulation.dpfOffset.fetch() \n
-		Returns the automatically detected or manually configured PRACH frequency offset for single-preamble measurements. \n
+	def fetch(self) -> float:
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:PRACh:MODulation:SCORrelation \n
+		Snippet: value: float = driver.lteMeas.prach.modulation.scorrelation.fetch() \n
+		Returns the sequence correlation for single-preamble measurements. It indicates the correlation between the ideal
+		preamble sequence determined from the parameter settings and the measured preamble sequence. A value of 1 corresponds to
+		perfect correlation. A value close to 0 indicates that the preamble sequence was not found. \n
 		Suppressed linked return values: reliability \n
-			:return: prach_freq_offset: PRACH frequency offset"""
+			:return: seq_correlation: Sequence correlation"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_str_suppressed(f'FETCh:LTE:MEASurement<Instance>:PRACh:MODulation:DPFoffset?', suppressed)
-		return Conversions.str_to_int(response)
+		response = self._core.io.query_str_suppressed(f'FETCh:LTE:MEASurement<Instance>:PRACh:MODulation:SCORrelation?', suppressed)
+		return Conversions.str_to_float(response)
 
-	def clone(self) -> 'DpfOffset':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'ScorrelationCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = DpfOffset(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = ScorrelationCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Prach_/Modulation_/DpfOffset_/Preamble.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/Prach/Modulation/Scorrelation/Preamble.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,50 +1,51 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
-from .....Internal import Conversions
-from .....Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from .....Internal.Types import DataType
-from .....Internal.RepeatedCapability import RepeatedCapability
-from ..... import repcap
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal import Conversions
+from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from ......Internal.Types import DataType
+from ......Internal.RepeatedCapability import RepeatedCapability
+from ...... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Preamble:
-	"""Preamble commands group definition. 1 total commands, 0 Sub-groups, 1 group commands
+class PreambleCls:
+	"""Preamble commands group definition. 1 total commands, 0 Subgroups, 1 group commands
 	Repeated Capability: Preamble, default value after init: Preamble.Nr1"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("preamble", core, parent)
-		self._base.rep_cap = RepeatedCapability(self._base.group_name, 'repcap_preamble_get', 'repcap_preamble_set', repcap.Preamble.Nr1)
+		self._cmd_group = CommandsGroup("preamble", core, parent)
+		self._cmd_group.rep_cap = RepeatedCapability(self._cmd_group.group_name, 'repcap_preamble_get', 'repcap_preamble_set', repcap.Preamble.Nr1)
 
-	def repcap_preamble_set(self, enum_value: repcap.Preamble) -> None:
+	def repcap_preamble_set(self, preamble: repcap.Preamble) -> None:
 		"""Repeated Capability default value numeric suffix.
 		This value is used, if you do not explicitely set it in the child set/get methods, or if you leave it to Preamble.Default
 		Default value after init: Preamble.Nr1"""
-		self._base.set_repcap_enum_value(enum_value)
+		self._cmd_group.set_repcap_enum_value(preamble)
 
 	def repcap_preamble_get(self) -> repcap.Preamble:
 		"""Returns the current default repeated capability for the child set/get methods"""
 		# noinspection PyTypeChecker
-		return self._base.get_repcap_enum_value()
+		return self._cmd_group.get_repcap_enum_value()
 
-	def fetch(self, preamble=repcap.Preamble.Default) -> int:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:PRACh:MODulation:DPFoffset:PREamble<Number> \n
-		Snippet: value: int = driver.prach.modulation.dpfOffset.preamble.fetch(preamble = repcap.Preamble.Default) \n
-		Returns the automatically detected or manually configured PRACH frequency offset for a selected preamble of
-		multi-preamble measurements. \n
+	def fetch(self, preamble=repcap.Preamble.Default) -> float:
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:PRACh:MODulation:SCORrelation:PREamble<Number> \n
+		Snippet: value: float = driver.lteMeas.prach.modulation.scorrelation.preamble.fetch(preamble = repcap.Preamble.Default) \n
+		Returns the sequence correlation for a selected preamble of multi-preamble measurements. It indicates the correlation
+		between the ideal preamble sequence determined from the parameter settings and the measured preamble sequence. A value of
+		1 corresponds to perfect correlation. A value close to 0 indicates that the preamble sequence was not found. \n
 		Suppressed linked return values: reliability \n
 			:param preamble: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Preamble')
-			:return: prach_freq_offset: PRACH frequency offset"""
-		preamble_cmd_val = self._base.get_repcap_cmd_value(preamble, repcap.Preamble)
+			:return: seq_correlation: Sequence correlation"""
+		preamble_cmd_val = self._cmd_group.get_repcap_cmd_value(preamble, repcap.Preamble)
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_str_suppressed(f'FETCh:LTE:MEASurement<Instance>:PRACh:MODulation:DPFoffset:PREamble{preamble_cmd_val}?', suppressed)
-		return Conversions.str_to_int(response)
+		response = self._core.io.query_str_suppressed(f'FETCh:LTE:MEASurement<Instance>:PRACh:MODulation:SCORrelation:PREamble{preamble_cmd_val}?', suppressed)
+		return Conversions.str_to_float(response)
 
-	def clone(self) -> 'Preamble':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'PreambleCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Preamble(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = PreambleCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Prach_/Modulation_/DsIndex.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Amarker/Pdynamics.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,40 +1,33 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
-from ....Internal import Conversions
-from ....Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ....Internal.Types import DataType
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
+from .....Internal import Conversions
+from .....Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .....Internal.Types import DataType
+from .....Internal.ArgSingleList import ArgSingleList
+from .....Internal.ArgSingle import ArgSingle
+from ..... import enums
+from ..... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class DsIndex:
-	"""DsIndex commands group definition. 2 total commands, 1 Sub-groups, 1 group commands"""
+class PdynamicsCls:
+	"""Pdynamics commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("dsIndex", core, parent)
+		self._cmd_group = CommandsGroup("pdynamics", core, parent)
 
-	@property
-	def preamble(self):
-		"""preamble commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_preamble'):
-			from .DsIndex_.Preamble import Preamble
-			self._preamble = Preamble(self._core, self._base)
-		return self._preamble
-
-	def fetch(self) -> int:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:PRACh:MODulation:DSINdex \n
-		Snippet: value: int = driver.prach.modulation.dsIndex.fetch() \n
-		Returns the automatically detected or manually configured sequence index for single-preamble measurements. \n
+	def fetch(self, xvalue: float or bool, trace_select: enums.TraceSelect, absMarker=repcap.AbsMarker.Default) -> float:
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:AMARker<No>:PDYNamics \n
+		Snippet: value: float = driver.lteMeas.multiEval.amarker.pdynamics.fetch(xvalue = 1.0, trace_select = enums.TraceSelect.AVERage, absMarker = repcap.AbsMarker.Default) \n
+		Uses the markers 1 and 2 with absolute values on the power dynamics trace. \n
 		Suppressed linked return values: reliability \n
-			:return: sequence_index: Sequence index"""
+			:param xvalue: (float or boolean) Absolute x-value of the marker position
+			:param trace_select: No help available
+			:param absMarker: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Amarker')
+			:return: yvalue: Absolute y-value of the marker position"""
+		param = ArgSingleList().compose_cmd_string(ArgSingle('xvalue', xvalue, DataType.FloatExt), ArgSingle('trace_select', trace_select, DataType.Enum, enums.TraceSelect))
+		absMarker_cmd_val = self._cmd_group.get_repcap_cmd_value(absMarker, repcap.AbsMarker)
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_str_suppressed(f'FETCh:LTE:MEASurement<Instance>:PRACh:MODulation:DSINdex?', suppressed)
-		return Conversions.str_to_int(response)
-
-	def clone(self) -> 'DsIndex':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
-		Also copies all the existing default Repeated Capabilities setting,
-		which you can change independently without affecting the original group"""
-		new_group = DsIndex(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
-		return new_group
+		response = self._core.io.query_str_suppressed(f'FETCh:LTE:MEASurement<Instance>:MEValuation:AMARker{absMarker_cmd_val}:PDYNamics? {param}'.rstrip(), suppressed)
+		return Conversions.str_to_float(response)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Prach_/Modulation_/DsIndex_/Preamble.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/Prach/Modulation/DpfOffset/Preamble.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,50 +1,50 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
-from .....Internal import Conversions
-from .....Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from .....Internal.Types import DataType
-from .....Internal.RepeatedCapability import RepeatedCapability
-from ..... import repcap
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal import Conversions
+from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from ......Internal.Types import DataType
+from ......Internal.RepeatedCapability import RepeatedCapability
+from ...... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Preamble:
-	"""Preamble commands group definition. 1 total commands, 0 Sub-groups, 1 group commands
+class PreambleCls:
+	"""Preamble commands group definition. 1 total commands, 0 Subgroups, 1 group commands
 	Repeated Capability: Preamble, default value after init: Preamble.Nr1"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("preamble", core, parent)
-		self._base.rep_cap = RepeatedCapability(self._base.group_name, 'repcap_preamble_get', 'repcap_preamble_set', repcap.Preamble.Nr1)
+		self._cmd_group = CommandsGroup("preamble", core, parent)
+		self._cmd_group.rep_cap = RepeatedCapability(self._cmd_group.group_name, 'repcap_preamble_get', 'repcap_preamble_set', repcap.Preamble.Nr1)
 
-	def repcap_preamble_set(self, enum_value: repcap.Preamble) -> None:
+	def repcap_preamble_set(self, preamble: repcap.Preamble) -> None:
 		"""Repeated Capability default value numeric suffix.
 		This value is used, if you do not explicitely set it in the child set/get methods, or if you leave it to Preamble.Default
 		Default value after init: Preamble.Nr1"""
-		self._base.set_repcap_enum_value(enum_value)
+		self._cmd_group.set_repcap_enum_value(preamble)
 
 	def repcap_preamble_get(self) -> repcap.Preamble:
 		"""Returns the current default repeated capability for the child set/get methods"""
 		# noinspection PyTypeChecker
-		return self._base.get_repcap_enum_value()
+		return self._cmd_group.get_repcap_enum_value()
 
 	def fetch(self, preamble=repcap.Preamble.Default) -> int:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:PRACh:MODulation:DSINdex:PREamble<Number> \n
-		Snippet: value: int = driver.prach.modulation.dsIndex.preamble.fetch(preamble = repcap.Preamble.Default) \n
-		Returns the automatically detected or manually configured sequence index for a selected preamble of multi-preamble
-		measurements. \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:PRACh:MODulation:DPFoffset:PREamble<Number> \n
+		Snippet: value: int = driver.lteMeas.prach.modulation.dpfOffset.preamble.fetch(preamble = repcap.Preamble.Default) \n
+		Returns the automatically detected or manually configured PRACH frequency offset for a selected preamble of
+		multi-preamble measurements. \n
 		Suppressed linked return values: reliability \n
 			:param preamble: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Preamble')
-			:return: sequence_index: Sequence index"""
-		preamble_cmd_val = self._base.get_repcap_cmd_value(preamble, repcap.Preamble)
+			:return: prach_freq_offset: PRACH frequency offset"""
+		preamble_cmd_val = self._cmd_group.get_repcap_cmd_value(preamble, repcap.Preamble)
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_str_suppressed(f'FETCh:LTE:MEASurement<Instance>:PRACh:MODulation:DSINdex:PREamble{preamble_cmd_val}?', suppressed)
+		response = self._core.io.query_str_suppressed(f'FETCh:LTE:MEASurement<Instance>:PRACh:MODulation:DPFoffset:PREamble{preamble_cmd_val}?', suppressed)
 		return Conversions.str_to_int(response)
 
-	def clone(self) -> 'Preamble':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'PreambleCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Preamble(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = PreambleCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Prach_/Modulation_/Extreme.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/Prach/Modulation/StandardDev.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,44 +1,42 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
-from ....Internal.StructBase import StructBase
-from ....Internal.ArgStruct import ArgStruct
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
+from .....Internal.StructBase import StructBase
+from .....Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Extreme:
-	"""Extreme commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class StandardDevCls:
+	"""StandardDev commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("extreme", core, parent)
+		self._cmd_group = CommandsGroup("standardDev", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Out_Of_Tolerance: int: Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for modulation measurements exceeding the specified modulation limits.
-			- Evm_Rms_Low: float: EVM RMS value, low EVM window position
-			- Evm_Rms_High: float: EVM RMS value, high EVM window position
-			- Evm_Peak_Low: float: EVM peak value, low EVM window position
-			- Evm_Peak_High: float: EVM peak value, high EVM window position
-			- Mag_Error_Rms_Low: float: Magnitude error RMS value, low EVM window position
-			- Mag_Error_Rms_High: float: Magnitude error RMS value, low EVM window position
-			- Mag_Error_Peak_Low: float: Magnitude error peak value, low EVM window position
-			- Mag_Err_Peak_High: float: Magnitude error peak value, high EVM window position
-			- Ph_Error_Rms_Low: float: Phase error RMS value, low EVM window position
-			- Ph_Error_Rms_High: float: Phase error RMS value, high EVM window position
-			- Ph_Error_Peak_Low: float: Phase error peak value, low EVM window position
-			- Ph_Error_Peak_High: float: Phase error peak value, high EVM window position
-			- Frequency_Error: float: Carrier frequency error
-			- Timing_Error: float: Transmit time error
-			- Tx_Power_Minimum: float: Minimum user equipment power
-			- Tx_Power_Maximum: float: Maximum user equipment power
-			- Peak_Power_Min: float: Minimum user equipment peak power
-			- Peak_Power_Max: float: Maximum user equipment peak power"""
+			- Reliability: int: 'Reliability indicator'
+			- Out_Of_Tolerance: int: Out of tolerance result, i.e. the percentage of measurement intervals of the statistic count for modulation measurements exceeding the specified modulation limits.
+			- Evm_Rms_Low: float: EVM RMS value, low EVM window position.
+			- Evm_Rms_High: float: EVM RMS value, high EVM window position.
+			- Evm_Peak_Low: float: EVM peak value, low EVM window position.
+			- Evm_Peak_High: float: EVM peak value, high EVM window position.
+			- Mag_Error_Rms_Low: float: Magnitude error RMS value, low EVM window position.
+			- Mag_Error_Rms_High: float: Magnitude error RMS value, low EVM window position.
+			- Mag_Error_Peak_Low: float: Magnitude error peak value, low EVM window position.
+			- Mag_Err_Peak_High: float: Magnitude error peak value, high EVM window position.
+			- Ph_Error_Rms_Low: float: Phase error RMS value, low EVM window position.
+			- Ph_Error_Rms_High: float: Phase error RMS value, high EVM window position.
+			- Ph_Error_Peak_Low: float: Phase error peak value, low EVM window position.
+			- Ph_Error_Peak_High: float: Phase error peak value, high EVM window position.
+			- Frequency_Error: float: Carrier frequency error.
+			- Timing_Error: float: Transmit time error.
+			- Tx_Power: float: UE RMS power.
+			- Peak_Power: float: UE peak power."""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
 			ArgStruct.scalar_float('Evm_Rms_Low'),
 			ArgStruct.scalar_float('Evm_Rms_High'),
 			ArgStruct.scalar_float('Evm_Peak_Low'),
 			ArgStruct.scalar_float('Evm_Peak_High'),
@@ -48,18 +46,16 @@
 			ArgStruct.scalar_float('Mag_Err_Peak_High'),
 			ArgStruct.scalar_float('Ph_Error_Rms_Low'),
 			ArgStruct.scalar_float('Ph_Error_Rms_High'),
 			ArgStruct.scalar_float('Ph_Error_Peak_Low'),
 			ArgStruct.scalar_float('Ph_Error_Peak_High'),
 			ArgStruct.scalar_float('Frequency_Error'),
 			ArgStruct.scalar_float('Timing_Error'),
-			ArgStruct.scalar_float('Tx_Power_Minimum'),
-			ArgStruct.scalar_float('Tx_Power_Maximum'),
-			ArgStruct.scalar_float('Peak_Power_Min'),
-			ArgStruct.scalar_float('Peak_Power_Max')]
+			ArgStruct.scalar_float('Tx_Power'),
+			ArgStruct.scalar_float('Peak_Power')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tolerance: int = None
 			self.Evm_Rms_Low: float = None
 			self.Evm_Rms_High: float = None
@@ -71,103 +67,94 @@
 			self.Mag_Err_Peak_High: float = None
 			self.Ph_Error_Rms_Low: float = None
 			self.Ph_Error_Rms_High: float = None
 			self.Ph_Error_Peak_Low: float = None
 			self.Ph_Error_Peak_High: float = None
 			self.Frequency_Error: float = None
 			self.Timing_Error: float = None
-			self.Tx_Power_Minimum: float = None
-			self.Tx_Power_Maximum: float = None
-			self.Peak_Power_Min: float = None
-			self.Peak_Power_Max: float = None
+			self.Tx_Power: float = None
+			self.Peak_Power: float = None
 
 	def read(self) -> ResultData:
-		"""SCPI: READ:LTE:MEASurement<Instance>:PRACh:MODulation:EXTReme \n
-		Snippet: value: ResultData = driver.prach.modulation.extreme.read() \n
-		Returns the extreme single value results. The values described below are returned by FETCh and READ commands. CALCulate
-		commands return limit check results instead, one value for each result listed below. \n
+		"""SCPI: READ:LTE:MEASurement<Instance>:PRACh:MODulation:SDEViation \n
+		Snippet: value: ResultData = driver.lteMeas.prach.modulation.standardDev.read() \n
+		Return the current, average and standard deviation single-value results. The values described below are returned by FETCh
+		and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:PRACh:MODulation:EXTReme?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:PRACh:MODulation:SDEViation?', self.__class__.ResultData())
 
 	def fetch(self) -> ResultData:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:PRACh:MODulation:EXTReme \n
-		Snippet: value: ResultData = driver.prach.modulation.extreme.fetch() \n
-		Returns the extreme single value results. The values described below are returned by FETCh and READ commands. CALCulate
-		commands return limit check results instead, one value for each result listed below. \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:PRACh:MODulation:SDEViation \n
+		Snippet: value: ResultData = driver.lteMeas.prach.modulation.standardDev.fetch() \n
+		Return the current, average and standard deviation single-value results. The values described below are returned by FETCh
+		and READ commands. CALCulate commands return limit check results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:PRACh:MODulation:EXTReme?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:PRACh:MODulation:SDEViation?', self.__class__.ResultData())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Out_Of_Tolerance: int: Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for modulation measurements exceeding the specified modulation limits.
-			- Evm_Rms_Low: float: EVM RMS value, low EVM window position
-			- Evm_Rms_High: float: EVM RMS value, high EVM window position
-			- Evm_Peak_Low: float: EVM peak value, low EVM window position
-			- Evm_Peak_High: float: EVM peak value, high EVM window position
-			- Mag_Error_Rms_Low: float: Magnitude error RMS value, low EVM window position
-			- Mag_Error_Rms_High: float: Magnitude error RMS value, low EVM window position
-			- Mag_Error_Peak_Low: float: Magnitude error peak value, low EVM window position
-			- Mag_Err_Peak_High: float: Magnitude error peak value, high EVM window position
-			- Ph_Error_Rms_Low: float: Phase error RMS value, low EVM window position
-			- Ph_Error_Rms_High: float: Phase error RMS value, high EVM window position
-			- Ph_Error_Peak_Low: float: Phase error peak value, low EVM window position
-			- Ph_Error_Peak_High: float: Phase error peak value, high EVM window position
-			- Frequency_Error: float: Carrier frequency error
-			- Timing_Error: float: Transmit time error
-			- Tx_Power_Minimum: float: Minimum user equipment power
-			- Tx_Power_Maximum: float: Maximum user equipment power
-			- Peak_Power_Min: float: Minimum user equipment peak power
-			- Peak_Power_Max: float: Maximum user equipment peak power"""
+			- Reliability: int: No parameter help available
+			- Out_Of_Tolerance: int: No parameter help available
+			- Evm_Rms_Low: float or bool: No parameter help available
+			- Evm_Rms_High: float or bool: No parameter help available
+			- Evm_Peak_Low: float or bool: No parameter help available
+			- Evm_Peak_High: float or bool: No parameter help available
+			- Mag_Error_Rms_Low: float or bool: No parameter help available
+			- Mag_Error_Rms_High: float or bool: No parameter help available
+			- Mag_Error_Peak_Low: float or bool: No parameter help available
+			- Mag_Err_Peak_High: float or bool: No parameter help available
+			- Ph_Error_Rms_Low: float or bool: No parameter help available
+			- Ph_Error_Rms_High: float or bool: No parameter help available
+			- Ph_Error_Peak_Low: float or bool: No parameter help available
+			- Ph_Error_Peak_High: float or bool: No parameter help available
+			- Frequency_Error: float or bool: No parameter help available
+			- Timing_Error: float or bool: No parameter help available
+			- Tx_Power: float or bool: No parameter help available
+			- Peak_Power: float or bool: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
-			ArgStruct.scalar_float('Evm_Rms_Low'),
-			ArgStruct.scalar_float('Evm_Rms_High'),
-			ArgStruct.scalar_float('Evm_Peak_Low'),
-			ArgStruct.scalar_float('Evm_Peak_High'),
-			ArgStruct.scalar_float('Mag_Error_Rms_Low'),
-			ArgStruct.scalar_float('Mag_Error_Rms_High'),
-			ArgStruct.scalar_float('Mag_Error_Peak_Low'),
-			ArgStruct.scalar_float('Mag_Err_Peak_High'),
-			ArgStruct.scalar_float('Ph_Error_Rms_Low'),
-			ArgStruct.scalar_float('Ph_Error_Rms_High'),
-			ArgStruct.scalar_float('Ph_Error_Peak_Low'),
-			ArgStruct.scalar_float('Ph_Error_Peak_High'),
-			ArgStruct.scalar_float('Frequency_Error'),
-			ArgStruct.scalar_float('Timing_Error'),
-			ArgStruct.scalar_float('Tx_Power_Minimum'),
-			ArgStruct.scalar_float('Tx_Power_Maximum'),
-			ArgStruct.scalar_float('Peak_Power_Min'),
-			ArgStruct.scalar_float('Peak_Power_Max')]
+			ArgStruct.scalar_float_ext('Evm_Rms_Low'),
+			ArgStruct.scalar_float_ext('Evm_Rms_High'),
+			ArgStruct.scalar_float_ext('Evm_Peak_Low'),
+			ArgStruct.scalar_float_ext('Evm_Peak_High'),
+			ArgStruct.scalar_float_ext('Mag_Error_Rms_Low'),
+			ArgStruct.scalar_float_ext('Mag_Error_Rms_High'),
+			ArgStruct.scalar_float_ext('Mag_Error_Peak_Low'),
+			ArgStruct.scalar_float_ext('Mag_Err_Peak_High'),
+			ArgStruct.scalar_float_ext('Ph_Error_Rms_Low'),
+			ArgStruct.scalar_float_ext('Ph_Error_Rms_High'),
+			ArgStruct.scalar_float_ext('Ph_Error_Peak_Low'),
+			ArgStruct.scalar_float_ext('Ph_Error_Peak_High'),
+			ArgStruct.scalar_float_ext('Frequency_Error'),
+			ArgStruct.scalar_float_ext('Timing_Error'),
+			ArgStruct.scalar_float_ext('Tx_Power'),
+			ArgStruct.scalar_float_ext('Peak_Power')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tolerance: int = None
-			self.Evm_Rms_Low: float = None
-			self.Evm_Rms_High: float = None
-			self.Evm_Peak_Low: float = None
-			self.Evm_Peak_High: float = None
-			self.Mag_Error_Rms_Low: float = None
-			self.Mag_Error_Rms_High: float = None
-			self.Mag_Error_Peak_Low: float = None
-			self.Mag_Err_Peak_High: float = None
-			self.Ph_Error_Rms_Low: float = None
-			self.Ph_Error_Rms_High: float = None
-			self.Ph_Error_Peak_Low: float = None
-			self.Ph_Error_Peak_High: float = None
-			self.Frequency_Error: float = None
-			self.Timing_Error: float = None
-			self.Tx_Power_Minimum: float = None
-			self.Tx_Power_Maximum: float = None
-			self.Peak_Power_Min: float = None
-			self.Peak_Power_Max: float = None
+			self.Evm_Rms_Low: float or bool = None
+			self.Evm_Rms_High: float or bool = None
+			self.Evm_Peak_Low: float or bool = None
+			self.Evm_Peak_High: float or bool = None
+			self.Mag_Error_Rms_Low: float or bool = None
+			self.Mag_Error_Rms_High: float or bool = None
+			self.Mag_Error_Peak_Low: float or bool = None
+			self.Mag_Err_Peak_High: float or bool = None
+			self.Ph_Error_Rms_Low: float or bool = None
+			self.Ph_Error_Rms_High: float or bool = None
+			self.Ph_Error_Peak_Low: float or bool = None
+			self.Ph_Error_Peak_High: float or bool = None
+			self.Frequency_Error: float or bool = None
+			self.Timing_Error: float or bool = None
+			self.Tx_Power: float or bool = None
+			self.Peak_Power: float or bool = None
 
 	def calculate(self) -> CalculateStruct:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:PRACh:MODulation:EXTReme \n
-		Snippet: value: CalculateStruct = driver.prach.modulation.extreme.calculate() \n
-		Returns the extreme single value results. The values described below are returned by FETCh and READ commands. CALCulate
-		commands return limit check results instead, one value for each result listed below. \n
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:PRACh:MODulation:SDEViation \n
+		Snippet: value: CalculateStruct = driver.lteMeas.prach.modulation.standardDev.calculate() \n
+		No command help available \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:PRACh:MODulation:EXTReme?', self.__class__.CalculateStruct())
+		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:PRACh:MODulation:SDEViation?', self.__class__.CalculateStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Prach_/Modulation_/Preamble.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/Prach/Modulation/Preamble.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,57 +1,57 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
-from ....Internal.StructBase import StructBase
-from ....Internal.ArgStruct import ArgStruct
-from ....Internal.RepeatedCapability import RepeatedCapability
-from .... import repcap
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
+from .....Internal.StructBase import StructBase
+from .....Internal.ArgStruct import ArgStruct
+from .....Internal.RepeatedCapability import RepeatedCapability
+from ..... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Preamble:
-	"""Preamble commands group definition. 2 total commands, 0 Sub-groups, 2 group commands
+class PreambleCls:
+	"""Preamble commands group definition. 2 total commands, 0 Subgroups, 2 group commands
 	Repeated Capability: Preamble, default value after init: Preamble.Nr1"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("preamble", core, parent)
-		self._base.rep_cap = RepeatedCapability(self._base.group_name, 'repcap_preamble_get', 'repcap_preamble_set', repcap.Preamble.Nr1)
+		self._cmd_group = CommandsGroup("preamble", core, parent)
+		self._cmd_group.rep_cap = RepeatedCapability(self._cmd_group.group_name, 'repcap_preamble_get', 'repcap_preamble_set', repcap.Preamble.Nr1)
 
-	def repcap_preamble_set(self, enum_value: repcap.Preamble) -> None:
+	def repcap_preamble_set(self, preamble: repcap.Preamble) -> None:
 		"""Repeated Capability default value numeric suffix.
 		This value is used, if you do not explicitely set it in the child set/get methods, or if you leave it to Preamble.Default
 		Default value after init: Preamble.Nr1"""
-		self._base.set_repcap_enum_value(enum_value)
+		self._cmd_group.set_repcap_enum_value(preamble)
 
 	def repcap_preamble_get(self) -> repcap.Preamble:
 		"""Returns the current default repeated capability for the child set/get methods"""
 		# noinspection PyTypeChecker
-		return self._base.get_repcap_enum_value()
+		return self._cmd_group.get_repcap_enum_value()
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Preamble_Rel: int: Reliability indicator for the preamble
-			- Evm_Rms_Low: float: EVM RMS value, low EVM window position
-			- Evm_Rms_High: float: EVM RMS value, high EVM window position
-			- Evm_Peak_Low: float: EVM peak value, low EVM window position
-			- Evm_Peak_High: float: EVM peak value, high EVM window position
-			- Mag_Error_Rms_Low: float: Magnitude error RMS value, low EVM window position
-			- Mag_Error_Rms_High: float: Magnitude error RMS value, low EVM window position
-			- Mag_Error_Peak_Low: float: Magnitude error peak value, low EVM window position
-			- Mag_Err_Peak_High: float: Magnitude error peak value, high EVM window position
-			- Ph_Error_Rms_Low: float: Phase error RMS value, low EVM window position
-			- Ph_Error_Rms_High: float: Phase error RMS value, high EVM window position
-			- Ph_Error_Peak_Low: float: Phase error peak value, low EVM window position
-			- Ph_Error_Peak_High: float: Phase error peak value, high EVM window position
-			- Frequency_Error: float: Carrier frequency error
-			- Timing_Error: float: Transmit time error
-			- Tx_Power: float: User equipment power
-			- Peak_Power: float: User equipment peak power"""
+			- Reliability: int: 'Reliability indicator'
+			- Preamble_Rel: int: Reliability indicator for the preamble.
+			- Evm_Rms_Low: float: EVM RMS value, low EVM window position.
+			- Evm_Rms_High: float: EVM RMS value, high EVM window position.
+			- Evm_Peak_Low: float: EVM peak value, low EVM window position.
+			- Evm_Peak_High: float: EVM peak value, high EVM window position.
+			- Mag_Error_Rms_Low: float: Magnitude error RMS value, low EVM window position.
+			- Mag_Error_Rms_High: float: Magnitude error RMS value, low EVM window position.
+			- Mag_Error_Peak_Low: float: Magnitude error peak value, low EVM window position.
+			- Mag_Err_Peak_High: float: Magnitude error peak value, high EVM window position.
+			- Ph_Error_Rms_Low: float: Phase error RMS value, low EVM window position.
+			- Ph_Error_Rms_High: float: Phase error RMS value, high EVM window position.
+			- Ph_Error_Peak_Low: float: Phase error peak value, low EVM window position.
+			- Ph_Error_Peak_High: float: Phase error peak value, high EVM window position.
+			- Frequency_Error: float: Carrier frequency error.
+			- Timing_Error: float: Transmit time error.
+			- Tx_Power: float: UE RMS power.
+			- Peak_Power: float: UE peak power."""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Preamble_Rel'),
 			ArgStruct.scalar_float('Evm_Rms_Low'),
 			ArgStruct.scalar_float('Evm_Rms_High'),
 			ArgStruct.scalar_float('Evm_Peak_Low'),
 			ArgStruct.scalar_float('Evm_Peak_High'),
@@ -87,32 +87,32 @@
 			self.Frequency_Error: float = None
 			self.Timing_Error: float = None
 			self.Tx_Power: float = None
 			self.Peak_Power: float = None
 
 	def read(self, preamble=repcap.Preamble.Default) -> ResultData:
 		"""SCPI: READ:LTE:MEASurement<Instance>:PRACh:MODulation:PREamble<Number> \n
-		Snippet: value: ResultData = driver.prach.modulation.preamble.read(preamble = repcap.Preamble.Default) \n
+		Snippet: value: ResultData = driver.lteMeas.prach.modulation.preamble.read(preamble = repcap.Preamble.Default) \n
 		Return the single value results of the EVM vs Preamble and Power vs Preamble views, for a selected preamble. See also
 		'Square EVM vs Preamble, Power vs Preamble'. \n
 			:param preamble: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Preamble')
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		preamble_cmd_val = self._base.get_repcap_cmd_value(preamble, repcap.Preamble)
+		preamble_cmd_val = self._cmd_group.get_repcap_cmd_value(preamble, repcap.Preamble)
 		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:PRACh:MODulation:PREamble{preamble_cmd_val}?', self.__class__.ResultData())
 
 	def fetch(self, preamble=repcap.Preamble.Default) -> ResultData:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:PRACh:MODulation:PREamble<Number> \n
-		Snippet: value: ResultData = driver.prach.modulation.preamble.fetch(preamble = repcap.Preamble.Default) \n
+		Snippet: value: ResultData = driver.lteMeas.prach.modulation.preamble.fetch(preamble = repcap.Preamble.Default) \n
 		Return the single value results of the EVM vs Preamble and Power vs Preamble views, for a selected preamble. See also
 		'Square EVM vs Preamble, Power vs Preamble'. \n
 			:param preamble: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Preamble')
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		preamble_cmd_val = self._base.get_repcap_cmd_value(preamble, repcap.Preamble)
+		preamble_cmd_val = self._cmd_group.get_repcap_cmd_value(preamble, repcap.Preamble)
 		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:PRACh:MODulation:PREamble{preamble_cmd_val}?', self.__class__.ResultData())
 
-	def clone(self) -> 'Preamble':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'PreambleCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Preamble(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = PreambleCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Prach_/Pdynamics.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/Prach/EvmSymbol/__init__.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,59 +1,51 @@
-from ...Internal.Core import Core
-from ...Internal.CommandsGroup import CommandsGroup
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Pdynamics:
-	"""Pdynamics commands group definition. 15 total commands, 5 Sub-groups, 0 group commands"""
+class EvmSymbolCls:
+	"""EvmSymbol commands group definition. 15 total commands, 4 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("pdynamics", core, parent)
+		self._cmd_group = CommandsGroup("evmSymbol", core, parent)
 
 	@property
 	def current(self):
 		"""current commands group. 0 Sub-classes, 3 commands."""
 		if not hasattr(self, '_current'):
-			from .Pdynamics_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
 	@property
 	def average(self):
 		"""average commands group. 0 Sub-classes, 3 commands."""
 		if not hasattr(self, '_average'):
-			from .Pdynamics_.Average import Average
-			self._average = Average(self._core, self._base)
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
 		return self._average
 
 	@property
 	def maximum(self):
 		"""maximum commands group. 0 Sub-classes, 3 commands."""
 		if not hasattr(self, '_maximum'):
-			from .Pdynamics_.Maximum import Maximum
-			self._maximum = Maximum(self._core, self._base)
+			from .Maximum import MaximumCls
+			self._maximum = MaximumCls(self._core, self._cmd_group)
 		return self._maximum
 
 	@property
-	def minimum(self):
-		"""minimum commands group. 0 Sub-classes, 3 commands."""
-		if not hasattr(self, '_minimum'):
-			from .Pdynamics_.Minimum import Minimum
-			self._minimum = Minimum(self._core, self._base)
-		return self._minimum
+	def peak(self):
+		"""peak commands group. 3 Sub-classes, 0 commands."""
+		if not hasattr(self, '_peak'):
+			from .Peak import PeakCls
+			self._peak = PeakCls(self._core, self._cmd_group)
+		return self._peak
 
-	@property
-	def standardDev(self):
-		"""standardDev commands group. 0 Sub-classes, 3 commands."""
-		if not hasattr(self, '_standardDev'):
-			from .Pdynamics_.StandardDev import StandardDev
-			self._standardDev = StandardDev(self._core, self._base)
-		return self._standardDev
-
-	def clone(self) -> 'Pdynamics':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'EvmSymbolCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Pdynamics(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = EvmSymbolCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Prach_/Pdynamics_/Average.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/Prach/Pdynamics/Minimum.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,30 +1,30 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
-from ....Internal.StructBase import StructBase
-from ....Internal.ArgStruct import ArgStruct
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
+from .....Internal.StructBase import StructBase
+from .....Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class MinimumCls:
+	"""Minimum commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("minimum", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Out_Of_Tolerance: int: Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for power dynamics measurements exceeding the specified power dynamics limits.
-			- Off_Power_Before: float: OFF power mean value for subframe before preamble without transient period
-			- On_Power_Rms: float: ON power mean value over preamble
-			- On_Power_Peak: float: ON power peak value within preamble
-			- Off_Power_After: float: OFF power mean value for subframe after preamble without transient period"""
+			- Reliability: int: 'Reliability indicator'
+			- Out_Of_Tolerance: int: Out of tolerance result, i.e. the percentage of measurement intervals of the statistic count for power dynamics measurements exceeding the specified power dynamics limits.
+			- Off_Power_Before: float: OFF power mean value for subframe before preamble without transient period.
+			- On_Power_Rms: float: ON power mean value over preamble.
+			- On_Power_Peak: float: ON power peak value within preamble.
+			- Off_Power_After: float: OFF power mean value for subframe after preamble without transient period."""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
 			ArgStruct.scalar_float('Off_Power_Before'),
 			ArgStruct.scalar_float('On_Power_Rms'),
 			ArgStruct.scalar_float('On_Power_Peak'),
 			ArgStruct.scalar_float('Off_Power_After')]
@@ -35,58 +35,58 @@
 			self.Out_Of_Tolerance: int = None
 			self.Off_Power_Before: float = None
 			self.On_Power_Rms: float = None
 			self.On_Power_Peak: float = None
 			self.Off_Power_After: float = None
 
 	def read(self) -> ResultData:
-		"""SCPI: READ:LTE:MEASurement<Instance>:PRACh:PDYNamics:AVERage \n
-		Snippet: value: ResultData = driver.prach.pdynamics.average.read() \n
-		Return the current, average, minimum, maximum and standard deviation single value results of the power dynamics
+		"""SCPI: READ:LTE:MEASurement<Instance>:PRACh:PDYNamics:MINimum \n
+		Snippet: value: ResultData = driver.lteMeas.prach.pdynamics.minimum.read() \n
+		Return the current, average, minimum, maximum and standard deviation single-value results of the power dynamics
 		measurement. The values described below are returned by FETCh and READ commands. CALCulate commands return limit check
 		results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:PRACh:PDYNamics:AVERage?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:PRACh:PDYNamics:MINimum?', self.__class__.ResultData())
 
 	def fetch(self) -> ResultData:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:PRACh:PDYNamics:AVERage \n
-		Snippet: value: ResultData = driver.prach.pdynamics.average.fetch() \n
-		Return the current, average, minimum, maximum and standard deviation single value results of the power dynamics
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:PRACh:PDYNamics:MINimum \n
+		Snippet: value: ResultData = driver.lteMeas.prach.pdynamics.minimum.fetch() \n
+		Return the current, average, minimum, maximum and standard deviation single-value results of the power dynamics
 		measurement. The values described below are returned by FETCh and READ commands. CALCulate commands return limit check
 		results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:PRACh:PDYNamics:AVERage?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:PRACh:PDYNamics:MINimum?', self.__class__.ResultData())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Out_Of_Tolerance: int: Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for power dynamics measurements exceeding the specified power dynamics limits.
-			- Off_Power_Before: float: OFF power mean value for subframe before preamble without transient period
-			- On_Power_Rms: float: ON power mean value over preamble
-			- On_Power_Peak: float: ON power peak value within preamble
-			- Off_Power_After: float: OFF power mean value for subframe after preamble without transient period"""
+			- Reliability: int: 'Reliability indicator'
+			- Out_Of_Tolerance: int: Out of tolerance result, i.e. the percentage of measurement intervals of the statistic count for power dynamics measurements exceeding the specified power dynamics limits.
+			- Off_Power_Before: float or bool: OFF power mean value for subframe before preamble without transient period.
+			- On_Power_Rms: float or bool: ON power mean value over preamble.
+			- On_Power_Peak: float or bool: ON power peak value within preamble.
+			- Off_Power_After: float or bool: OFF power mean value for subframe after preamble without transient period."""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
-			ArgStruct.scalar_float('Off_Power_Before'),
-			ArgStruct.scalar_float('On_Power_Rms'),
-			ArgStruct.scalar_float('On_Power_Peak'),
-			ArgStruct.scalar_float('Off_Power_After')]
+			ArgStruct.scalar_float_ext('Off_Power_Before'),
+			ArgStruct.scalar_float_ext('On_Power_Rms'),
+			ArgStruct.scalar_float_ext('On_Power_Peak'),
+			ArgStruct.scalar_float_ext('Off_Power_After')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tolerance: int = None
-			self.Off_Power_Before: float = None
-			self.On_Power_Rms: float = None
-			self.On_Power_Peak: float = None
-			self.Off_Power_After: float = None
+			self.Off_Power_Before: float or bool = None
+			self.On_Power_Rms: float or bool = None
+			self.On_Power_Peak: float or bool = None
+			self.Off_Power_After: float or bool = None
 
 	def calculate(self) -> CalculateStruct:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:PRACh:PDYNamics:AVERage \n
-		Snippet: value: CalculateStruct = driver.prach.pdynamics.average.calculate() \n
-		Return the current, average, minimum, maximum and standard deviation single value results of the power dynamics
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:PRACh:PDYNamics:MINimum \n
+		Snippet: value: CalculateStruct = driver.lteMeas.prach.pdynamics.minimum.calculate() \n
+		Return the current, average, minimum, maximum and standard deviation single-value results of the power dynamics
 		measurement. The values described below are returned by FETCh and READ commands. CALCulate commands return limit check
 		results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:PRACh:PDYNamics:AVERage?', self.__class__.CalculateStruct())
+		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:PRACh:PDYNamics:MINimum?', self.__class__.CalculateStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Prach_/Pdynamics_/Current.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/Prach/Pdynamics/Average.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,30 +1,30 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
-from ....Internal.StructBase import StructBase
-from ....Internal.ArgStruct import ArgStruct
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
+from .....Internal.StructBase import StructBase
+from .....Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class AverageCls:
+	"""Average commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Out_Of_Tolerance: int: Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for power dynamics measurements exceeding the specified power dynamics limits.
-			- Off_Power_Before: float: OFF power mean value for subframe before preamble without transient period
-			- On_Power_Rms: float: ON power mean value over preamble
-			- On_Power_Peak: float: ON power peak value within preamble
-			- Off_Power_After: float: OFF power mean value for subframe after preamble without transient period"""
+			- Reliability: int: 'Reliability indicator'
+			- Out_Of_Tolerance: int: Out of tolerance result, i.e. the percentage of measurement intervals of the statistic count for power dynamics measurements exceeding the specified power dynamics limits.
+			- Off_Power_Before: float: OFF power mean value for subframe before preamble without transient period.
+			- On_Power_Rms: float: ON power mean value over preamble.
+			- On_Power_Peak: float: ON power peak value within preamble.
+			- Off_Power_After: float: OFF power mean value for subframe after preamble without transient period."""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
 			ArgStruct.scalar_float('Off_Power_Before'),
 			ArgStruct.scalar_float('On_Power_Rms'),
 			ArgStruct.scalar_float('On_Power_Peak'),
 			ArgStruct.scalar_float('Off_Power_After')]
@@ -35,58 +35,58 @@
 			self.Out_Of_Tolerance: int = None
 			self.Off_Power_Before: float = None
 			self.On_Power_Rms: float = None
 			self.On_Power_Peak: float = None
 			self.Off_Power_After: float = None
 
 	def read(self) -> ResultData:
-		"""SCPI: READ:LTE:MEASurement<Instance>:PRACh:PDYNamics:CURRent \n
-		Snippet: value: ResultData = driver.prach.pdynamics.current.read() \n
-		Return the current, average, minimum, maximum and standard deviation single value results of the power dynamics
+		"""SCPI: READ:LTE:MEASurement<Instance>:PRACh:PDYNamics:AVERage \n
+		Snippet: value: ResultData = driver.lteMeas.prach.pdynamics.average.read() \n
+		Return the current, average, minimum, maximum and standard deviation single-value results of the power dynamics
 		measurement. The values described below are returned by FETCh and READ commands. CALCulate commands return limit check
 		results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:PRACh:PDYNamics:CURRent?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:PRACh:PDYNamics:AVERage?', self.__class__.ResultData())
 
 	def fetch(self) -> ResultData:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:PRACh:PDYNamics:CURRent \n
-		Snippet: value: ResultData = driver.prach.pdynamics.current.fetch() \n
-		Return the current, average, minimum, maximum and standard deviation single value results of the power dynamics
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:PRACh:PDYNamics:AVERage \n
+		Snippet: value: ResultData = driver.lteMeas.prach.pdynamics.average.fetch() \n
+		Return the current, average, minimum, maximum and standard deviation single-value results of the power dynamics
 		measurement. The values described below are returned by FETCh and READ commands. CALCulate commands return limit check
 		results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:PRACh:PDYNamics:CURRent?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:PRACh:PDYNamics:AVERage?', self.__class__.ResultData())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Out_Of_Tolerance: int: Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for power dynamics measurements exceeding the specified power dynamics limits.
-			- Off_Power_Before: float: OFF power mean value for subframe before preamble without transient period
-			- On_Power_Rms: float: ON power mean value over preamble
-			- On_Power_Peak: float: ON power peak value within preamble
-			- Off_Power_After: float: OFF power mean value for subframe after preamble without transient period"""
+			- Reliability: int: 'Reliability indicator'
+			- Out_Of_Tolerance: int: Out of tolerance result, i.e. the percentage of measurement intervals of the statistic count for power dynamics measurements exceeding the specified power dynamics limits.
+			- Off_Power_Before: float or bool: OFF power mean value for subframe before preamble without transient period.
+			- On_Power_Rms: float or bool: ON power mean value over preamble.
+			- On_Power_Peak: float or bool: ON power peak value within preamble.
+			- Off_Power_After: float or bool: OFF power mean value for subframe after preamble without transient period."""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
-			ArgStruct.scalar_float('Off_Power_Before'),
-			ArgStruct.scalar_float('On_Power_Rms'),
-			ArgStruct.scalar_float('On_Power_Peak'),
-			ArgStruct.scalar_float('Off_Power_After')]
+			ArgStruct.scalar_float_ext('Off_Power_Before'),
+			ArgStruct.scalar_float_ext('On_Power_Rms'),
+			ArgStruct.scalar_float_ext('On_Power_Peak'),
+			ArgStruct.scalar_float_ext('Off_Power_After')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tolerance: int = None
-			self.Off_Power_Before: float = None
-			self.On_Power_Rms: float = None
-			self.On_Power_Peak: float = None
-			self.Off_Power_After: float = None
+			self.Off_Power_Before: float or bool = None
+			self.On_Power_Rms: float or bool = None
+			self.On_Power_Peak: float or bool = None
+			self.Off_Power_After: float or bool = None
 
 	def calculate(self) -> CalculateStruct:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:PRACh:PDYNamics:CURRent \n
-		Snippet: value: CalculateStruct = driver.prach.pdynamics.current.calculate() \n
-		Return the current, average, minimum, maximum and standard deviation single value results of the power dynamics
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:PRACh:PDYNamics:AVERage \n
+		Snippet: value: CalculateStruct = driver.lteMeas.prach.pdynamics.average.calculate() \n
+		Return the current, average, minimum, maximum and standard deviation single-value results of the power dynamics
 		measurement. The values described below are returned by FETCh and READ commands. CALCulate commands return limit check
 		results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:PRACh:PDYNamics:CURRent?', self.__class__.CalculateStruct())
+		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:PRACh:PDYNamics:AVERage?', self.__class__.CalculateStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Prach_/Pdynamics_/Maximum.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/Prach/Pdynamics/Maximum.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,30 +1,30 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
-from ....Internal.StructBase import StructBase
-from ....Internal.ArgStruct import ArgStruct
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
+from .....Internal.StructBase import StructBase
+from .....Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Maximum:
-	"""Maximum commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class MaximumCls:
+	"""Maximum commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("maximum", core, parent)
+		self._cmd_group = CommandsGroup("maximum", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Out_Of_Tolerance: int: Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for power dynamics measurements exceeding the specified power dynamics limits.
-			- Off_Power_Before: float: OFF power mean value for subframe before preamble without transient period
-			- On_Power_Rms: float: ON power mean value over preamble
-			- On_Power_Peak: float: ON power peak value within preamble
-			- Off_Power_After: float: OFF power mean value for subframe after preamble without transient period"""
+			- Reliability: int: 'Reliability indicator'
+			- Out_Of_Tolerance: int: Out of tolerance result, i.e. the percentage of measurement intervals of the statistic count for power dynamics measurements exceeding the specified power dynamics limits.
+			- Off_Power_Before: float: OFF power mean value for subframe before preamble without transient period.
+			- On_Power_Rms: float: ON power mean value over preamble.
+			- On_Power_Peak: float: ON power peak value within preamble.
+			- Off_Power_After: float: OFF power mean value for subframe after preamble without transient period."""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
 			ArgStruct.scalar_float('Off_Power_Before'),
 			ArgStruct.scalar_float('On_Power_Rms'),
 			ArgStruct.scalar_float('On_Power_Peak'),
 			ArgStruct.scalar_float('Off_Power_After')]
@@ -36,57 +36,57 @@
 			self.Off_Power_Before: float = None
 			self.On_Power_Rms: float = None
 			self.On_Power_Peak: float = None
 			self.Off_Power_After: float = None
 
 	def read(self) -> ResultData:
 		"""SCPI: READ:LTE:MEASurement<Instance>:PRACh:PDYNamics:MAXimum \n
-		Snippet: value: ResultData = driver.prach.pdynamics.maximum.read() \n
-		Return the current, average, minimum, maximum and standard deviation single value results of the power dynamics
+		Snippet: value: ResultData = driver.lteMeas.prach.pdynamics.maximum.read() \n
+		Return the current, average, minimum, maximum and standard deviation single-value results of the power dynamics
 		measurement. The values described below are returned by FETCh and READ commands. CALCulate commands return limit check
 		results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
 		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:PRACh:PDYNamics:MAXimum?', self.__class__.ResultData())
 
 	def fetch(self) -> ResultData:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:PRACh:PDYNamics:MAXimum \n
-		Snippet: value: ResultData = driver.prach.pdynamics.maximum.fetch() \n
-		Return the current, average, minimum, maximum and standard deviation single value results of the power dynamics
+		Snippet: value: ResultData = driver.lteMeas.prach.pdynamics.maximum.fetch() \n
+		Return the current, average, minimum, maximum and standard deviation single-value results of the power dynamics
 		measurement. The values described below are returned by FETCh and READ commands. CALCulate commands return limit check
 		results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
 		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:PRACh:PDYNamics:MAXimum?', self.__class__.ResultData())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Out_Of_Tolerance: int: Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for power dynamics measurements exceeding the specified power dynamics limits.
-			- Off_Power_Before: float: OFF power mean value for subframe before preamble without transient period
-			- On_Power_Rms: float: ON power mean value over preamble
-			- On_Power_Peak: float: ON power peak value within preamble
-			- Off_Power_After: float: OFF power mean value for subframe after preamble without transient period"""
+			- Reliability: int: 'Reliability indicator'
+			- Out_Of_Tolerance: int: Out of tolerance result, i.e. the percentage of measurement intervals of the statistic count for power dynamics measurements exceeding the specified power dynamics limits.
+			- Off_Power_Before: float or bool: OFF power mean value for subframe before preamble without transient period.
+			- On_Power_Rms: float or bool: ON power mean value over preamble.
+			- On_Power_Peak: float or bool: ON power peak value within preamble.
+			- Off_Power_After: float or bool: OFF power mean value for subframe after preamble without transient period."""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
-			ArgStruct.scalar_float('Off_Power_Before'),
-			ArgStruct.scalar_float('On_Power_Rms'),
-			ArgStruct.scalar_float('On_Power_Peak'),
-			ArgStruct.scalar_float('Off_Power_After')]
+			ArgStruct.scalar_float_ext('Off_Power_Before'),
+			ArgStruct.scalar_float_ext('On_Power_Rms'),
+			ArgStruct.scalar_float_ext('On_Power_Peak'),
+			ArgStruct.scalar_float_ext('Off_Power_After')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tolerance: int = None
-			self.Off_Power_Before: float = None
-			self.On_Power_Rms: float = None
-			self.On_Power_Peak: float = None
-			self.Off_Power_After: float = None
+			self.Off_Power_Before: float or bool = None
+			self.On_Power_Rms: float or bool = None
+			self.On_Power_Peak: float or bool = None
+			self.Off_Power_After: float or bool = None
 
 	def calculate(self) -> CalculateStruct:
 		"""SCPI: CALCulate:LTE:MEASurement<Instance>:PRACh:PDYNamics:MAXimum \n
-		Snippet: value: CalculateStruct = driver.prach.pdynamics.maximum.calculate() \n
-		Return the current, average, minimum, maximum and standard deviation single value results of the power dynamics
+		Snippet: value: CalculateStruct = driver.lteMeas.prach.pdynamics.maximum.calculate() \n
+		Return the current, average, minimum, maximum and standard deviation single-value results of the power dynamics
 		measurement. The values described below are returned by FETCh and READ commands. CALCulate commands return limit check
 		results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
 		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:PRACh:PDYNamics:MAXimum?', self.__class__.CalculateStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Prach_/Pdynamics_/Minimum.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/Srs/Pdynamics/StandardDev.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,92 +1,102 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
-from ....Internal.StructBase import StructBase
-from ....Internal.ArgStruct import ArgStruct
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
+from .....Internal.StructBase import StructBase
+from .....Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Minimum:
-	"""Minimum commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class StandardDevCls:
+	"""StandardDev commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("minimum", core, parent)
+		self._cmd_group = CommandsGroup("standardDev", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Out_Of_Tolerance: int: Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for power dynamics measurements exceeding the specified power dynamics limits.
-			- Off_Power_Before: float: OFF power mean value for subframe before preamble without transient period
-			- On_Power_Rms: float: ON power mean value over preamble
-			- On_Power_Peak: float: ON power peak value within preamble
-			- Off_Power_After: float: OFF power mean value for subframe after preamble without transient period"""
+			- Reliability: int: 'Reliability indicator'
+			- Out_Of_Tolerance: int: Out of tolerance result, i.e. the percentage of measurement intervals of the statistic count for power dynamics measurements exceeding the specified power dynamics limits.
+			- Off_Power_Before: float: OFF power mean value for the time period before the SRS symbol.
+			- On_Power_Rms_1: float: ON power mean value over the first SRS symbol.
+			- On_Power_Peak_1: float: ON power peak value for the first SRS symbol.
+			- On_Power_Rms_2: float: ON power mean value over the second SRS symbol (NCAP returned for FDD) .
+			- On_Power_Peak_2: float: ON power peak value for the second SRS symbol (NCAP returned for FDD) .
+			- Off_Power_After: float: OFF power mean value for the subframe after the SRS symbol."""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
 			ArgStruct.scalar_float('Off_Power_Before'),
-			ArgStruct.scalar_float('On_Power_Rms'),
-			ArgStruct.scalar_float('On_Power_Peak'),
+			ArgStruct.scalar_float('On_Power_Rms_1'),
+			ArgStruct.scalar_float('On_Power_Peak_1'),
+			ArgStruct.scalar_float('On_Power_Rms_2'),
+			ArgStruct.scalar_float('On_Power_Peak_2'),
 			ArgStruct.scalar_float('Off_Power_After')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tolerance: int = None
 			self.Off_Power_Before: float = None
-			self.On_Power_Rms: float = None
-			self.On_Power_Peak: float = None
+			self.On_Power_Rms_1: float = None
+			self.On_Power_Peak_1: float = None
+			self.On_Power_Rms_2: float = None
+			self.On_Power_Peak_2: float = None
 			self.Off_Power_After: float = None
 
 	def read(self) -> ResultData:
-		"""SCPI: READ:LTE:MEASurement<Instance>:PRACh:PDYNamics:MINimum \n
-		Snippet: value: ResultData = driver.prach.pdynamics.minimum.read() \n
-		Return the current, average, minimum, maximum and standard deviation single value results of the power dynamics
+		"""SCPI: READ:LTE:MEASurement<Instance>:SRS:PDYNamics:SDEViation \n
+		Snippet: value: ResultData = driver.lteMeas.srs.pdynamics.standardDev.read() \n
+		Return the current, average, minimum, maximum and standard deviation single-value results of the power dynamics
 		measurement. The values described below are returned by FETCh and READ commands. CALCulate commands return limit check
 		results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:PRACh:PDYNamics:MINimum?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:SRS:PDYNamics:SDEViation?', self.__class__.ResultData())
 
 	def fetch(self) -> ResultData:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:PRACh:PDYNamics:MINimum \n
-		Snippet: value: ResultData = driver.prach.pdynamics.minimum.fetch() \n
-		Return the current, average, minimum, maximum and standard deviation single value results of the power dynamics
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:SRS:PDYNamics:SDEViation \n
+		Snippet: value: ResultData = driver.lteMeas.srs.pdynamics.standardDev.fetch() \n
+		Return the current, average, minimum, maximum and standard deviation single-value results of the power dynamics
 		measurement. The values described below are returned by FETCh and READ commands. CALCulate commands return limit check
 		results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:PRACh:PDYNamics:MINimum?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:SRS:PDYNamics:SDEViation?', self.__class__.ResultData())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Out_Of_Tolerance: int: Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for power dynamics measurements exceeding the specified power dynamics limits.
-			- Off_Power_Before: float: OFF power mean value for subframe before preamble without transient period
-			- On_Power_Rms: float: ON power mean value over preamble
-			- On_Power_Peak: float: ON power peak value within preamble
-			- Off_Power_After: float: OFF power mean value for subframe after preamble without transient period"""
+			- Reliability: int: No parameter help available
+			- Out_Of_Tolerance: int: No parameter help available
+			- Off_Power_Before: float or bool: No parameter help available
+			- On_Power_Rms_1: float or bool: No parameter help available
+			- On_Power_Peak_1: float or bool: No parameter help available
+			- On_Power_Rms_2: float or bool: No parameter help available
+			- On_Power_Peak_2: float or bool: No parameter help available
+			- Off_Power_After: float or bool: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
-			ArgStruct.scalar_float('Off_Power_Before'),
-			ArgStruct.scalar_float('On_Power_Rms'),
-			ArgStruct.scalar_float('On_Power_Peak'),
-			ArgStruct.scalar_float('Off_Power_After')]
+			ArgStruct.scalar_float_ext('Off_Power_Before'),
+			ArgStruct.scalar_float_ext('On_Power_Rms_1'),
+			ArgStruct.scalar_float_ext('On_Power_Peak_1'),
+			ArgStruct.scalar_float_ext('On_Power_Rms_2'),
+			ArgStruct.scalar_float_ext('On_Power_Peak_2'),
+			ArgStruct.scalar_float_ext('Off_Power_After')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tolerance: int = None
-			self.Off_Power_Before: float = None
-			self.On_Power_Rms: float = None
-			self.On_Power_Peak: float = None
-			self.Off_Power_After: float = None
+			self.Off_Power_Before: float or bool = None
+			self.On_Power_Rms_1: float or bool = None
+			self.On_Power_Peak_1: float or bool = None
+			self.On_Power_Rms_2: float or bool = None
+			self.On_Power_Peak_2: float or bool = None
+			self.Off_Power_After: float or bool = None
 
 	def calculate(self) -> CalculateStruct:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:PRACh:PDYNamics:MINimum \n
-		Snippet: value: CalculateStruct = driver.prach.pdynamics.minimum.calculate() \n
-		Return the current, average, minimum, maximum and standard deviation single value results of the power dynamics
-		measurement. The values described below are returned by FETCh and READ commands. CALCulate commands return limit check
-		results instead, one value for each result listed below. \n
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:SRS:PDYNamics:SDEViation \n
+		Snippet: value: CalculateStruct = driver.lteMeas.srs.pdynamics.standardDev.calculate() \n
+		No command help available \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:PRACh:PDYNamics:MINimum?', self.__class__.CalculateStruct())
+		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:SRS:PDYNamics:SDEViation?', self.__class__.CalculateStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Prach_/Pdynamics_/StandardDev.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/Prach/Pdynamics/StandardDev.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,30 +1,30 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
-from ....Internal.StructBase import StructBase
-from ....Internal.ArgStruct import ArgStruct
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
+from .....Internal.StructBase import StructBase
+from .....Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class StandardDev:
-	"""StandardDev commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class StandardDevCls:
+	"""StandardDev commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("standardDev", core, parent)
+		self._cmd_group = CommandsGroup("standardDev", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Out_Of_Tolerance: int: Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for power dynamics measurements exceeding the specified power dynamics limits.
-			- Off_Power_Before: float: OFF power mean value for subframe before preamble without transient period
-			- On_Power_Rms: float: ON power mean value over preamble
-			- On_Power_Peak: float: ON power peak value within preamble
-			- Off_Power_After: float: OFF power mean value for subframe after preamble without transient period"""
+			- Reliability: int: 'Reliability indicator'
+			- Out_Of_Tolerance: int: Out of tolerance result, i.e. the percentage of measurement intervals of the statistic count for power dynamics measurements exceeding the specified power dynamics limits.
+			- Off_Power_Before: float: OFF power mean value for subframe before preamble without transient period.
+			- On_Power_Rms: float: ON power mean value over preamble.
+			- On_Power_Peak: float: ON power peak value within preamble.
+			- Off_Power_After: float: OFF power mean value for subframe after preamble without transient period."""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
 			ArgStruct.scalar_float('Off_Power_Before'),
 			ArgStruct.scalar_float('On_Power_Rms'),
 			ArgStruct.scalar_float('On_Power_Peak'),
 			ArgStruct.scalar_float('Off_Power_After')]
@@ -36,55 +36,55 @@
 			self.Off_Power_Before: float = None
 			self.On_Power_Rms: float = None
 			self.On_Power_Peak: float = None
 			self.Off_Power_After: float = None
 
 	def read(self) -> ResultData:
 		"""SCPI: READ:LTE:MEASurement<Instance>:PRACh:PDYNamics:SDEViation \n
-		Snippet: value: ResultData = driver.prach.pdynamics.standardDev.read() \n
-		Return the current, average, minimum, maximum and standard deviation single value results of the power dynamics
+		Snippet: value: ResultData = driver.lteMeas.prach.pdynamics.standardDev.read() \n
+		Return the current, average, minimum, maximum and standard deviation single-value results of the power dynamics
 		measurement. The values described below are returned by FETCh and READ commands. CALCulate commands return limit check
 		results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
 		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:PRACh:PDYNamics:SDEViation?', self.__class__.ResultData())
 
 	def fetch(self) -> ResultData:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:PRACh:PDYNamics:SDEViation \n
-		Snippet: value: ResultData = driver.prach.pdynamics.standardDev.fetch() \n
-		Return the current, average, minimum, maximum and standard deviation single value results of the power dynamics
+		Snippet: value: ResultData = driver.lteMeas.prach.pdynamics.standardDev.fetch() \n
+		Return the current, average, minimum, maximum and standard deviation single-value results of the power dynamics
 		measurement. The values described below are returned by FETCh and READ commands. CALCulate commands return limit check
 		results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
 		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:PRACh:PDYNamics:SDEViation?', self.__class__.ResultData())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
 			- Reliability: int: No parameter help available
 			- Out_Of_Tolerance: int: No parameter help available
-			- Off_Power_Before: float: No parameter help available
-			- On_Power_Rms: float: No parameter help available
-			- On_Power_Peak: float: No parameter help available
-			- Off_Power_After: float: No parameter help available"""
+			- Off_Power_Before: float or bool: No parameter help available
+			- On_Power_Rms: float or bool: No parameter help available
+			- On_Power_Peak: float or bool: No parameter help available
+			- Off_Power_After: float or bool: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
-			ArgStruct.scalar_float('Off_Power_Before'),
-			ArgStruct.scalar_float('On_Power_Rms'),
-			ArgStruct.scalar_float('On_Power_Peak'),
-			ArgStruct.scalar_float('Off_Power_After')]
+			ArgStruct.scalar_float_ext('Off_Power_Before'),
+			ArgStruct.scalar_float_ext('On_Power_Rms'),
+			ArgStruct.scalar_float_ext('On_Power_Peak'),
+			ArgStruct.scalar_float_ext('Off_Power_After')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tolerance: int = None
-			self.Off_Power_Before: float = None
-			self.On_Power_Rms: float = None
-			self.On_Power_Peak: float = None
-			self.Off_Power_After: float = None
+			self.Off_Power_Before: float or bool = None
+			self.On_Power_Rms: float or bool = None
+			self.On_Power_Peak: float or bool = None
+			self.Off_Power_After: float or bool = None
 
 	def calculate(self) -> CalculateStruct:
 		"""SCPI: CALCulate:LTE:MEASurement<Instance>:PRACh:PDYNamics:SDEViation \n
-		Snippet: value: CalculateStruct = driver.prach.pdynamics.standardDev.calculate() \n
+		Snippet: value: CalculateStruct = driver.lteMeas.prach.pdynamics.standardDev.calculate() \n
 		No command help available \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
 		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:PRACh:PDYNamics:SDEViation?', self.__class__.CalculateStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Prach_/Trace_/EvPreamble.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/Prach/Trace/EvPreamble.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,35 +1,35 @@
 from typing import List
 
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
-from ....Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ....Internal.Types import DataType
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
+from .....Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .....Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class EvPreamble:
-	"""EvPreamble commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class EvPreambleCls:
+	"""EvPreamble commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("evPreamble", core, parent)
+		self._cmd_group = CommandsGroup("evPreamble", core, parent)
 
 	def read(self) -> List[float]:
 		"""SCPI: READ:LTE:MEASurement<Instance>:PRACh:TRACe:EVPReamble \n
-		Snippet: value: List[float] = driver.prach.trace.evPreamble.read() \n
+		Snippet: value: List[float] = driver.lteMeas.prach.trace.evPreamble.read() \n
 		Return the values of the EVM vs preamble traces. See also 'Square EVM vs Preamble, Power vs Preamble'. \n
 		Suppressed linked return values: reliability \n
 			:return: results: 32 EVM values, for preamble 1 to 32 (NCAP for not measured preambles)"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:LTE:MEASurement<Instance>:PRACh:TRACe:EVPReamble?', suppressed)
 		return response
 
 	def fetch(self) -> List[float]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:PRACh:TRACe:EVPReamble \n
-		Snippet: value: List[float] = driver.prach.trace.evPreamble.fetch() \n
+		Snippet: value: List[float] = driver.lteMeas.prach.trace.evPreamble.fetch() \n
 		Return the values of the EVM vs preamble traces. See also 'Square EVM vs Preamble, Power vs Preamble'. \n
 		Suppressed linked return values: reliability \n
 			:return: results: 32 EVM values, for preamble 1 to 32 (NCAP for not measured preambles)"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:PRACh:TRACe:EVPReamble?', suppressed)
 		return response
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Prach_/Trace_/Evm.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/Prach/Trace/Perror/__init__.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,43 +1,43 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Evm:
-	"""Evm commands group definition. 6 total commands, 3 Sub-groups, 0 group commands"""
+class PerrorCls:
+	"""Perror commands group definition. 6 total commands, 3 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("evm", core, parent)
+		self._cmd_group = CommandsGroup("perror", core, parent)
 
 	@property
 	def current(self):
 		"""current commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_current'):
-			from .Evm_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
 	@property
 	def average(self):
 		"""average commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_average'):
-			from .Evm_.Average import Average
-			self._average = Average(self._core, self._base)
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
 		return self._average
 
 	@property
 	def maximum(self):
 		"""maximum commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_maximum'):
-			from .Evm_.Maximum import Maximum
-			self._maximum = Maximum(self._core, self._base)
+			from .Maximum import MaximumCls
+			self._maximum = MaximumCls(self._core, self._cmd_group)
 		return self._maximum
 
-	def clone(self) -> 'Evm':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'PerrorCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Evm(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = PerrorCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Prach_/Trace_/Evm_/Average.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/Prach/Trace/Evm/Average.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,38 +1,38 @@
 from typing import List
 
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
-from .....Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from .....Internal.Types import DataType
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from ......Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class AverageCls:
+	"""Average commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	def read(self) -> List[float]:
 		"""SCPI: READ:LTE:MEASurement<Instance>:PRACh:TRACe:EVM:AVERage \n
-		Snippet: value: List[float] = driver.prach.trace.evm.average.read() \n
+		Snippet: value: List[float] = driver.lteMeas.prach.trace.evm.average.read() \n
 		Return the values of the EVM vs subcarrier traces. Each value is averaged over the samples in one preamble subcarrier.
 		The results of the current, average and maximum traces can be retrieved. See also 'Square EVM, Magnitude Error, Phase
 		Error'. \n
 		Suppressed linked return values: reliability \n
 			:return: results: The number of results depends on the preamble format. Format 0 to 3: 839 EVM values, format 4: 139 EVM values"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:LTE:MEASurement<Instance>:PRACh:TRACe:EVM:AVERage?', suppressed)
 		return response
 
 	def fetch(self) -> List[float]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:PRACh:TRACe:EVM:AVERage \n
-		Snippet: value: List[float] = driver.prach.trace.evm.average.fetch() \n
+		Snippet: value: List[float] = driver.lteMeas.prach.trace.evm.average.fetch() \n
 		Return the values of the EVM vs subcarrier traces. Each value is averaged over the samples in one preamble subcarrier.
 		The results of the current, average and maximum traces can be retrieved. See also 'Square EVM, Magnitude Error, Phase
 		Error'. \n
 		Suppressed linked return values: reliability \n
 			:return: results: The number of results depends on the preamble format. Format 0 to 3: 839 EVM values, format 4: 139 EVM values"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:PRACh:TRACe:EVM:AVERage?', suppressed)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Prach_/Trace_/Evm_/Current.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/Prach/Trace/Evm/Current.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,38 +1,38 @@
 from typing import List
 
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
-from .....Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from .....Internal.Types import DataType
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from ......Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	def read(self) -> List[float]:
 		"""SCPI: READ:LTE:MEASurement<Instance>:PRACh:TRACe:EVM:CURRent \n
-		Snippet: value: List[float] = driver.prach.trace.evm.current.read() \n
+		Snippet: value: List[float] = driver.lteMeas.prach.trace.evm.current.read() \n
 		Return the values of the EVM vs subcarrier traces. Each value is averaged over the samples in one preamble subcarrier.
 		The results of the current, average and maximum traces can be retrieved. See also 'Square EVM, Magnitude Error, Phase
 		Error'. \n
 		Suppressed linked return values: reliability \n
 			:return: results: The number of results depends on the preamble format. Format 0 to 3: 839 EVM values, format 4: 139 EVM values"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:LTE:MEASurement<Instance>:PRACh:TRACe:EVM:CURRent?', suppressed)
 		return response
 
 	def fetch(self) -> List[float]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:PRACh:TRACe:EVM:CURRent \n
-		Snippet: value: List[float] = driver.prach.trace.evm.current.fetch() \n
+		Snippet: value: List[float] = driver.lteMeas.prach.trace.evm.current.fetch() \n
 		Return the values of the EVM vs subcarrier traces. Each value is averaged over the samples in one preamble subcarrier.
 		The results of the current, average and maximum traces can be retrieved. See also 'Square EVM, Magnitude Error, Phase
 		Error'. \n
 		Suppressed linked return values: reliability \n
 			:return: results: The number of results depends on the preamble format. Format 0 to 3: 839 EVM values, format 4: 139 EVM values"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:PRACh:TRACe:EVM:CURRent?', suppressed)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Prach_/Trace_/Evm_/Maximum.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/Prach/Trace/Merror/Average.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,39 +1,37 @@
 from typing import List
 
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
-from .....Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from .....Internal.Types import DataType
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from ......Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Maximum:
-	"""Maximum commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class AverageCls:
+	"""Average commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("maximum", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	def read(self) -> List[float]:
-		"""SCPI: READ:LTE:MEASurement<Instance>:PRACh:TRACe:EVM:MAXimum \n
-		Snippet: value: List[float] = driver.prach.trace.evm.maximum.read() \n
-		Return the values of the EVM vs subcarrier traces. Each value is averaged over the samples in one preamble subcarrier.
-		The results of the current, average and maximum traces can be retrieved. See also 'Square EVM, Magnitude Error, Phase
-		Error'. \n
+		"""SCPI: READ:LTE:MEASurement<Instance>:PRACh:TRACe:MERRor:AVERage \n
+		Snippet: value: List[float] = driver.lteMeas.prach.trace.merror.average.read() \n
+		Return the values of the magnitude error traces. Each value is averaged over the samples in one preamble subcarrier. The
+		results of the current, average and maximum traces can be retrieved. See also 'Square EVM, Magnitude Error, Phase Error'. \n
 		Suppressed linked return values: reliability \n
 			:return: results: The number of results depends on the preamble format. Format 0 to 3: 839 EVM values, format 4: 139 EVM values"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:LTE:MEASurement<Instance>:PRACh:TRACe:EVM:MAXimum?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:LTE:MEASurement<Instance>:PRACh:TRACe:MERRor:AVERage?', suppressed)
 		return response
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:PRACh:TRACe:EVM:MAXimum \n
-		Snippet: value: List[float] = driver.prach.trace.evm.maximum.fetch() \n
-		Return the values of the EVM vs subcarrier traces. Each value is averaged over the samples in one preamble subcarrier.
-		The results of the current, average and maximum traces can be retrieved. See also 'Square EVM, Magnitude Error, Phase
-		Error'. \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:PRACh:TRACe:MERRor:AVERage \n
+		Snippet: value: List[float] = driver.lteMeas.prach.trace.merror.average.fetch() \n
+		Return the values of the magnitude error traces. Each value is averaged over the samples in one preamble subcarrier. The
+		results of the current, average and maximum traces can be retrieved. See also 'Square EVM, Magnitude Error, Phase Error'. \n
 		Suppressed linked return values: reliability \n
 			:return: results: The number of results depends on the preamble format. Format 0 to 3: 839 EVM values, format 4: 139 EVM values"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:PRACh:TRACe:EVM:MAXimum?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:PRACh:TRACe:MERRor:AVERage?', suppressed)
 		return response
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Prach_/Trace_/Iq.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/Prach/Limit/Merror.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,43 +1,47 @@
-from typing import List
-
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
-from ....Internal.Types import DataType
-from ....Internal.StructBase import StructBase
-from ....Internal.ArgStruct import ArgStruct
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal.Types import DataType
+from ......Internal.StructBase import StructBase
+from ......Internal.ArgStruct import ArgStruct
+from ......Internal.ArgSingleList import ArgSingleList
+from ......Internal.ArgSingle import ArgSingle
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Iq:
-	"""Iq commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class MerrorCls:
+	"""Merror commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("iq", core, parent)
+		self._cmd_group = CommandsGroup("merror", core, parent)
+
+	def set(self, rms: float or bool, peak: float or bool) -> None:
+		"""SCPI: CONFigure:LTE:MEASurement<Instance>:PRACh:LIMit:MERRor \n
+		Snippet: driver.configure.lteMeas.prach.limit.merror.set(rms = 1.0, peak = 1.0) \n
+		Defines upper limits for the RMS and peak values of the magnitude error. \n
+			:param rms: (float or boolean) No help available
+			:param peak: (float or boolean) No help available
+		"""
+		param = ArgSingleList().compose_cmd_string(ArgSingle('rms', rms, DataType.FloatExt), ArgSingle('peak', peak, DataType.FloatExt))
+		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:PRACh:LIMit:MERRor {param}'.rstrip())
 
 	# noinspection PyTypeChecker
-	class FetchStruct(StructBase):
+	class MerrorStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Iphase: List[float]: Normalized I amplitude
-			- Qphase: List[float]: Normalized Q amplitude"""
+			- Rms: float or bool: No parameter help available
+			- Peak: float or bool: No parameter help available"""
 		__meta_args_list = [
-			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct('Iphase', DataType.FloatList, None, False, True, 1),
-			ArgStruct('Qphase', DataType.FloatList, None, False, True, 1)]
+			ArgStruct.scalar_float_ext('Rms'),
+			ArgStruct.scalar_float_ext('Peak')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
-			self.Reliability: int = None
-			self.Iphase: List[float] = None
-			self.Qphase: List[float] = None
-
-	def fetch(self) -> FetchStruct:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:PRACh:TRACe:IQ \n
-		Snippet: value: FetchStruct = driver.prach.trace.iq.fetch() \n
-		Returns the results in the I/Q constellation diagram. There is one pair of values per modulation symbol. For preamble
-		format 4, there are 139 symbols. For preamble format 0 to 3, there are 839 symbols. The results are returned in the
-		following order: <Reliability>, {<IPhase>, <QPhase>}symbol 1, ..., {<IPhase>, <QPhase>}symbol n See also 'Square I/Q
-		Constellation'. \n
-			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:PRACh:TRACe:IQ?', self.__class__.FetchStruct())
+			self.Rms: float or bool = None
+			self.Peak: float or bool = None
+
+	def get(self) -> MerrorStruct:
+		"""SCPI: CONFigure:LTE:MEASurement<Instance>:PRACh:LIMit:MERRor \n
+		Snippet: value: MerrorStruct = driver.configure.lteMeas.prach.limit.merror.get() \n
+		Defines upper limits for the RMS and peak values of the magnitude error. \n
+			:return: structure: for return value, see the help for MerrorStruct structure arguments."""
+		return self._core.io.query_struct(f'CONFigure:LTE:MEASurement<Instance>:PRACh:LIMit:MERRor?', self.__class__.MerrorStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Prach_/Trace_/Merror_/Average.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/Prach/Trace/Merror/Maximum.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,37 +1,37 @@
 from typing import List
 
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
-from .....Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from .....Internal.Types import DataType
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from ......Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class MaximumCls:
+	"""Maximum commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("maximum", core, parent)
 
 	def read(self) -> List[float]:
-		"""SCPI: READ:LTE:MEASurement<Instance>:PRACh:TRACe:MERRor:AVERage \n
-		Snippet: value: List[float] = driver.prach.trace.merror.average.read() \n
+		"""SCPI: READ:LTE:MEASurement<Instance>:PRACh:TRACe:MERRor:MAXimum \n
+		Snippet: value: List[float] = driver.lteMeas.prach.trace.merror.maximum.read() \n
 		Return the values of the magnitude error traces. Each value is averaged over the samples in one preamble subcarrier. The
 		results of the current, average and maximum traces can be retrieved. See also 'Square EVM, Magnitude Error, Phase Error'. \n
 		Suppressed linked return values: reliability \n
 			:return: results: The number of results depends on the preamble format. Format 0 to 3: 839 EVM values, format 4: 139 EVM values"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:LTE:MEASurement<Instance>:PRACh:TRACe:MERRor:AVERage?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:LTE:MEASurement<Instance>:PRACh:TRACe:MERRor:MAXimum?', suppressed)
 		return response
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:PRACh:TRACe:MERRor:AVERage \n
-		Snippet: value: List[float] = driver.prach.trace.merror.average.fetch() \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:PRACh:TRACe:MERRor:MAXimum \n
+		Snippet: value: List[float] = driver.lteMeas.prach.trace.merror.maximum.fetch() \n
 		Return the values of the magnitude error traces. Each value is averaged over the samples in one preamble subcarrier. The
 		results of the current, average and maximum traces can be retrieved. See also 'Square EVM, Magnitude Error, Phase Error'. \n
 		Suppressed linked return values: reliability \n
 			:return: results: The number of results depends on the preamble format. Format 0 to 3: 839 EVM values, format 4: 139 EVM values"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:PRACh:TRACe:MERRor:AVERage?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:PRACh:TRACe:MERRor:MAXimum?', suppressed)
 		return response
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Prach_/Trace_/Merror_/Current.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/Prach/Trace/Perror/Maximum.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,37 +1,39 @@
 from typing import List
 
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
-from .....Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from .....Internal.Types import DataType
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from ......Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class MaximumCls:
+	"""Maximum commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("maximum", core, parent)
 
 	def read(self) -> List[float]:
-		"""SCPI: READ:LTE:MEASurement<Instance>:PRACh:TRACe:MERRor:CURRent \n
-		Snippet: value: List[float] = driver.prach.trace.merror.current.read() \n
-		Return the values of the magnitude error traces. Each value is averaged over the samples in one preamble subcarrier. The
-		results of the current, average and maximum traces can be retrieved. See also 'Square EVM, Magnitude Error, Phase Error'. \n
+		"""SCPI: READ:LTE:MEASurement<Instance>:PRACh:TRACe:PERRor:MAXimum \n
+		Snippet: value: List[float] = driver.lteMeas.prach.trace.perror.maximum.read() \n
+		Return the values of the phase error traces. Each value is averaged over the samples in one preamble subcarrier.
+		The results of the current, average and maximum traces can be retrieved. See also 'Square EVM, Magnitude Error, Phase
+		Error'. \n
 		Suppressed linked return values: reliability \n
 			:return: results: The number of results depends on the preamble format. Format 0 to 3: 839 EVM values, format 4: 139 EVM values"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:LTE:MEASurement<Instance>:PRACh:TRACe:MERRor:CURRent?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:LTE:MEASurement<Instance>:PRACh:TRACe:PERRor:MAXimum?', suppressed)
 		return response
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:PRACh:TRACe:MERRor:CURRent \n
-		Snippet: value: List[float] = driver.prach.trace.merror.current.fetch() \n
-		Return the values of the magnitude error traces. Each value is averaged over the samples in one preamble subcarrier. The
-		results of the current, average and maximum traces can be retrieved. See also 'Square EVM, Magnitude Error, Phase Error'. \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:PRACh:TRACe:PERRor:MAXimum \n
+		Snippet: value: List[float] = driver.lteMeas.prach.trace.perror.maximum.fetch() \n
+		Return the values of the phase error traces. Each value is averaged over the samples in one preamble subcarrier.
+		The results of the current, average and maximum traces can be retrieved. See also 'Square EVM, Magnitude Error, Phase
+		Error'. \n
 		Suppressed linked return values: reliability \n
 			:return: results: The number of results depends on the preamble format. Format 0 to 3: 839 EVM values, format 4: 139 EVM values"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:PRACh:TRACe:MERRor:CURRent?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:PRACh:TRACe:PERRor:MAXimum?', suppressed)
 		return response
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Prach_/Trace_/Merror_/Maximum.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/Prach/Trace/Perror/Current.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,37 +1,39 @@
 from typing import List
 
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
-from .....Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from .....Internal.Types import DataType
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from ......Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Maximum:
-	"""Maximum commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("maximum", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	def read(self) -> List[float]:
-		"""SCPI: READ:LTE:MEASurement<Instance>:PRACh:TRACe:MERRor:MAXimum \n
-		Snippet: value: List[float] = driver.prach.trace.merror.maximum.read() \n
-		Return the values of the magnitude error traces. Each value is averaged over the samples in one preamble subcarrier. The
-		results of the current, average and maximum traces can be retrieved. See also 'Square EVM, Magnitude Error, Phase Error'. \n
+		"""SCPI: READ:LTE:MEASurement<Instance>:PRACh:TRACe:PERRor:CURRent \n
+		Snippet: value: List[float] = driver.lteMeas.prach.trace.perror.current.read() \n
+		Return the values of the phase error traces. Each value is averaged over the samples in one preamble subcarrier.
+		The results of the current, average and maximum traces can be retrieved. See also 'Square EVM, Magnitude Error, Phase
+		Error'. \n
 		Suppressed linked return values: reliability \n
 			:return: results: The number of results depends on the preamble format. Format 0 to 3: 839 EVM values, format 4: 139 EVM values"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:LTE:MEASurement<Instance>:PRACh:TRACe:MERRor:MAXimum?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:LTE:MEASurement<Instance>:PRACh:TRACe:PERRor:CURRent?', suppressed)
 		return response
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:PRACh:TRACe:MERRor:MAXimum \n
-		Snippet: value: List[float] = driver.prach.trace.merror.maximum.fetch() \n
-		Return the values of the magnitude error traces. Each value is averaged over the samples in one preamble subcarrier. The
-		results of the current, average and maximum traces can be retrieved. See also 'Square EVM, Magnitude Error, Phase Error'. \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:PRACh:TRACe:PERRor:CURRent \n
+		Snippet: value: List[float] = driver.lteMeas.prach.trace.perror.current.fetch() \n
+		Return the values of the phase error traces. Each value is averaged over the samples in one preamble subcarrier.
+		The results of the current, average and maximum traces can be retrieved. See also 'Square EVM, Magnitude Error, Phase
+		Error'. \n
 		Suppressed linked return values: reliability \n
 			:return: results: The number of results depends on the preamble format. Format 0 to 3: 839 EVM values, format 4: 139 EVM values"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:PRACh:TRACe:MERRor:MAXimum?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:PRACh:TRACe:PERRor:CURRent?', suppressed)
 		return response
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Prach_/Trace_/Pdynamics.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/Merror/__init__.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,43 +1,43 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Pdynamics:
-	"""Pdynamics commands group definition. 6 total commands, 3 Sub-groups, 0 group commands"""
+class MerrorCls:
+	"""Merror commands group definition. 15 total commands, 3 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("pdynamics", core, parent)
+		self._cmd_group = CommandsGroup("merror", core, parent)
 
 	@property
 	def current(self):
-		"""current commands group. 0 Sub-classes, 2 commands."""
+		"""current commands group. 1 Sub-classes, 3 commands."""
 		if not hasattr(self, '_current'):
-			from .Pdynamics_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
 	@property
 	def average(self):
-		"""average commands group. 0 Sub-classes, 2 commands."""
+		"""average commands group. 1 Sub-classes, 3 commands."""
 		if not hasattr(self, '_average'):
-			from .Pdynamics_.Average import Average
-			self._average = Average(self._core, self._base)
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
 		return self._average
 
 	@property
 	def maximum(self):
-		"""maximum commands group. 0 Sub-classes, 2 commands."""
+		"""maximum commands group. 1 Sub-classes, 3 commands."""
 		if not hasattr(self, '_maximum'):
-			from .Pdynamics_.Maximum import Maximum
-			self._maximum = Maximum(self._core, self._base)
+			from .Maximum import MaximumCls
+			self._maximum = MaximumCls(self._core, self._cmd_group)
 		return self._maximum
 
-	def clone(self) -> 'Pdynamics':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'MerrorCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Pdynamics(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = MerrorCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Prach_/Trace_/Pdynamics_/Average.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/Prach/Trace/Pdynamics/Average.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,37 +1,37 @@
 from typing import List
 
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
-from .....Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from .....Internal.Types import DataType
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from ......Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class AverageCls:
+	"""Average commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	def read(self) -> List[float]:
 		"""SCPI: READ:LTE:MEASurement<Instance>:PRACh:TRACe:PDYNamics:AVERage \n
-		Snippet: value: List[float] = driver.prach.trace.pdynamics.average.read() \n
+		Snippet: value: List[float] = driver.lteMeas.prach.trace.pdynamics.average.read() \n
 		Return the values of the power dynamics traces. Each value is sampled with 48 Ts, corresponding to 1.5625 s. The results
 		of the current, average and maximum traces can be retrieved. See also 'Square Power Dynamics'. \n
 		Suppressed linked return values: reliability \n
 			:return: power: 2048 power values, from -1100 s to +2098.4375 s relative to the start of the preamble. The values have a spacing of 1.5625 s. The 705th value is at the start of the preamble (0 s) ."""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:LTE:MEASurement<Instance>:PRACh:TRACe:PDYNamics:AVERage?', suppressed)
 		return response
 
 	def fetch(self) -> List[float]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:PRACh:TRACe:PDYNamics:AVERage \n
-		Snippet: value: List[float] = driver.prach.trace.pdynamics.average.fetch() \n
+		Snippet: value: List[float] = driver.lteMeas.prach.trace.pdynamics.average.fetch() \n
 		Return the values of the power dynamics traces. Each value is sampled with 48 Ts, corresponding to 1.5625 s. The results
 		of the current, average and maximum traces can be retrieved. See also 'Square Power Dynamics'. \n
 		Suppressed linked return values: reliability \n
 			:return: power: 2048 power values, from -1100 s to +2098.4375 s relative to the start of the preamble. The values have a spacing of 1.5625 s. The 705th value is at the start of the preamble (0 s) ."""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:PRACh:TRACe:PDYNamics:AVERage?', suppressed)
 		return response
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Prach_/Trace_/Pdynamics_/Current.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/Prach/Trace/Pdynamics/Current.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,37 +1,37 @@
 from typing import List
 
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
-from .....Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from .....Internal.Types import DataType
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from ......Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	def read(self) -> List[float]:
 		"""SCPI: READ:LTE:MEASurement<Instance>:PRACh:TRACe:PDYNamics:CURRent \n
-		Snippet: value: List[float] = driver.prach.trace.pdynamics.current.read() \n
+		Snippet: value: List[float] = driver.lteMeas.prach.trace.pdynamics.current.read() \n
 		Return the values of the power dynamics traces. Each value is sampled with 48 Ts, corresponding to 1.5625 s. The results
 		of the current, average and maximum traces can be retrieved. See also 'Square Power Dynamics'. \n
 		Suppressed linked return values: reliability \n
 			:return: power: 2048 power values, from -1100 s to +2098.4375 s relative to the start of the preamble. The values have a spacing of 1.5625 s. The 705th value is at the start of the preamble (0 s) ."""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:LTE:MEASurement<Instance>:PRACh:TRACe:PDYNamics:CURRent?', suppressed)
 		return response
 
 	def fetch(self) -> List[float]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:PRACh:TRACe:PDYNamics:CURRent \n
-		Snippet: value: List[float] = driver.prach.trace.pdynamics.current.fetch() \n
+		Snippet: value: List[float] = driver.lteMeas.prach.trace.pdynamics.current.fetch() \n
 		Return the values of the power dynamics traces. Each value is sampled with 48 Ts, corresponding to 1.5625 s. The results
 		of the current, average and maximum traces can be retrieved. See also 'Square Power Dynamics'. \n
 		Suppressed linked return values: reliability \n
 			:return: power: 2048 power values, from -1100 s to +2098.4375 s relative to the start of the preamble. The values have a spacing of 1.5625 s. The 705th value is at the start of the preamble (0 s) ."""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:PRACh:TRACe:PDYNamics:CURRent?', suppressed)
 		return response
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Prach_/Trace_/Pdynamics_/Maximum.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/Prach/Trace/Pdynamics/Maximum.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,37 +1,37 @@
 from typing import List
 
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
-from .....Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from .....Internal.Types import DataType
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from ......Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Maximum:
-	"""Maximum commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class MaximumCls:
+	"""Maximum commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("maximum", core, parent)
+		self._cmd_group = CommandsGroup("maximum", core, parent)
 
 	def read(self) -> List[float]:
 		"""SCPI: READ:LTE:MEASurement<Instance>:PRACh:TRACe:PDYNamics:MAXimum \n
-		Snippet: value: List[float] = driver.prach.trace.pdynamics.maximum.read() \n
+		Snippet: value: List[float] = driver.lteMeas.prach.trace.pdynamics.maximum.read() \n
 		Return the values of the power dynamics traces. Each value is sampled with 48 Ts, corresponding to 1.5625 s. The results
 		of the current, average and maximum traces can be retrieved. See also 'Square Power Dynamics'. \n
 		Suppressed linked return values: reliability \n
 			:return: power: 2048 power values, from -1100 s to +2098.4375 s relative to the start of the preamble. The values have a spacing of 1.5625 s. The 705th value is at the start of the preamble (0 s) ."""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:LTE:MEASurement<Instance>:PRACh:TRACe:PDYNamics:MAXimum?', suppressed)
 		return response
 
 	def fetch(self) -> List[float]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:PRACh:TRACe:PDYNamics:MAXimum \n
-		Snippet: value: List[float] = driver.prach.trace.pdynamics.maximum.fetch() \n
+		Snippet: value: List[float] = driver.lteMeas.prach.trace.pdynamics.maximum.fetch() \n
 		Return the values of the power dynamics traces. Each value is sampled with 48 Ts, corresponding to 1.5625 s. The results
 		of the current, average and maximum traces can be retrieved. See also 'Square Power Dynamics'. \n
 		Suppressed linked return values: reliability \n
 			:return: power: 2048 power values, from -1100 s to +2098.4375 s relative to the start of the preamble. The values have a spacing of 1.5625 s. The 705th value is at the start of the preamble (0 s) ."""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:PRACh:TRACe:PDYNamics:MAXimum?', suppressed)
 		return response
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Prach_/Trace_/Perror_/Average.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/Prach/Trace/Perror/Average.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,38 +1,38 @@
 from typing import List
 
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
-from .....Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from .....Internal.Types import DataType
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from ......Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class AverageCls:
+	"""Average commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	def read(self) -> List[float]:
 		"""SCPI: READ:LTE:MEASurement<Instance>:PRACh:TRACe:PERRor:AVERage \n
-		Snippet: value: List[float] = driver.prach.trace.perror.average.read() \n
+		Snippet: value: List[float] = driver.lteMeas.prach.trace.perror.average.read() \n
 		Return the values of the phase error traces. Each value is averaged over the samples in one preamble subcarrier.
 		The results of the current, average and maximum traces can be retrieved. See also 'Square EVM, Magnitude Error, Phase
 		Error'. \n
 		Suppressed linked return values: reliability \n
 			:return: results: The number of results depends on the preamble format. Format 0 to 3: 839 EVM values, format 4: 139 EVM values"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:LTE:MEASurement<Instance>:PRACh:TRACe:PERRor:AVERage?', suppressed)
 		return response
 
 	def fetch(self) -> List[float]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:PRACh:TRACe:PERRor:AVERage \n
-		Snippet: value: List[float] = driver.prach.trace.perror.average.fetch() \n
+		Snippet: value: List[float] = driver.lteMeas.prach.trace.perror.average.fetch() \n
 		Return the values of the phase error traces. Each value is averaged over the samples in one preamble subcarrier.
 		The results of the current, average and maximum traces can be retrieved. See also 'Square EVM, Magnitude Error, Phase
 		Error'. \n
 		Suppressed linked return values: reliability \n
 			:return: results: The number of results depends on the preamble format. Format 0 to 3: 839 EVM values, format 4: 139 EVM values"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:PRACh:TRACe:PERRor:AVERage?', suppressed)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Prach_/Trace_/Perror_/Current.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/Prach/Trace/Merror/Current.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,39 +1,37 @@
 from typing import List
 
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
-from .....Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from .....Internal.Types import DataType
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from ......Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	def read(self) -> List[float]:
-		"""SCPI: READ:LTE:MEASurement<Instance>:PRACh:TRACe:PERRor:CURRent \n
-		Snippet: value: List[float] = driver.prach.trace.perror.current.read() \n
-		Return the values of the phase error traces. Each value is averaged over the samples in one preamble subcarrier.
-		The results of the current, average and maximum traces can be retrieved. See also 'Square EVM, Magnitude Error, Phase
-		Error'. \n
+		"""SCPI: READ:LTE:MEASurement<Instance>:PRACh:TRACe:MERRor:CURRent \n
+		Snippet: value: List[float] = driver.lteMeas.prach.trace.merror.current.read() \n
+		Return the values of the magnitude error traces. Each value is averaged over the samples in one preamble subcarrier. The
+		results of the current, average and maximum traces can be retrieved. See also 'Square EVM, Magnitude Error, Phase Error'. \n
 		Suppressed linked return values: reliability \n
 			:return: results: The number of results depends on the preamble format. Format 0 to 3: 839 EVM values, format 4: 139 EVM values"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:LTE:MEASurement<Instance>:PRACh:TRACe:PERRor:CURRent?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:LTE:MEASurement<Instance>:PRACh:TRACe:MERRor:CURRent?', suppressed)
 		return response
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:PRACh:TRACe:PERRor:CURRent \n
-		Snippet: value: List[float] = driver.prach.trace.perror.current.fetch() \n
-		Return the values of the phase error traces. Each value is averaged over the samples in one preamble subcarrier.
-		The results of the current, average and maximum traces can be retrieved. See also 'Square EVM, Magnitude Error, Phase
-		Error'. \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:PRACh:TRACe:MERRor:CURRent \n
+		Snippet: value: List[float] = driver.lteMeas.prach.trace.merror.current.fetch() \n
+		Return the values of the magnitude error traces. Each value is averaged over the samples in one preamble subcarrier. The
+		results of the current, average and maximum traces can be retrieved. See also 'Square EVM, Magnitude Error, Phase Error'. \n
 		Suppressed linked return values: reliability \n
 			:return: results: The number of results depends on the preamble format. Format 0 to 3: 839 EVM values, format 4: 139 EVM values"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:PRACh:TRACe:PERRor:CURRent?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:PRACh:TRACe:MERRor:CURRent?', suppressed)
 		return response
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Prach_/Trace_/Perror_/Maximum.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/Srs/Trace/Pdynamics/Maximum.py`

 * *Files 25% similar despite different names*

```diff
@@ -1,39 +1,39 @@
 from typing import List
 
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
-from .....Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from .....Internal.Types import DataType
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from ......Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Maximum:
-	"""Maximum commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class MaximumCls:
+	"""Maximum commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("maximum", core, parent)
+		self._cmd_group = CommandsGroup("maximum", core, parent)
 
 	def read(self) -> List[float]:
-		"""SCPI: READ:LTE:MEASurement<Instance>:PRACh:TRACe:PERRor:MAXimum \n
-		Snippet: value: List[float] = driver.prach.trace.perror.maximum.read() \n
-		Return the values of the phase error traces. Each value is averaged over the samples in one preamble subcarrier.
-		The results of the current, average and maximum traces can be retrieved. See also 'Square EVM, Magnitude Error, Phase
-		Error'. \n
+		"""SCPI: READ:LTE:MEASurement<Instance>:SRS:TRACe:PDYNamics:MAXimum \n
+		Snippet: value: List[float] = driver.lteMeas.srs.trace.pdynamics.maximum.read() \n
+		Return the values of the power dynamics traces. Each value is sampled with 48 Ts, corresponding to 1.5625 s. The results
+		of the current, average and maximum traces can be retrieved. Note that the GUI shows only the beginning of the trace
+		returned via a remote command. The last 800 s cannot be displayed at the GUI. See also 'Measurement results'. \n
 		Suppressed linked return values: reliability \n
-			:return: results: The number of results depends on the preamble format. Format 0 to 3: 839 EVM values, format 4: 139 EVM values"""
+			:return: power: 2048 power values, from -1100 s to +2098.4375 s relative to the start of the SRS symbol. The values have a spacing of 1.5625 s. The 705th value is at the start of the SRS symbol (0 s) ."""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:LTE:MEASurement<Instance>:PRACh:TRACe:PERRor:MAXimum?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:LTE:MEASurement<Instance>:SRS:TRACe:PDYNamics:MAXimum?', suppressed)
 		return response
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:PRACh:TRACe:PERRor:MAXimum \n
-		Snippet: value: List[float] = driver.prach.trace.perror.maximum.fetch() \n
-		Return the values of the phase error traces. Each value is averaged over the samples in one preamble subcarrier.
-		The results of the current, average and maximum traces can be retrieved. See also 'Square EVM, Magnitude Error, Phase
-		Error'. \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:SRS:TRACe:PDYNamics:MAXimum \n
+		Snippet: value: List[float] = driver.lteMeas.srs.trace.pdynamics.maximum.fetch() \n
+		Return the values of the power dynamics traces. Each value is sampled with 48 Ts, corresponding to 1.5625 s. The results
+		of the current, average and maximum traces can be retrieved. Note that the GUI shows only the beginning of the trace
+		returned via a remote command. The last 800 s cannot be displayed at the GUI. See also 'Measurement results'. \n
 		Suppressed linked return values: reliability \n
-			:return: results: The number of results depends on the preamble format. Format 0 to 3: 839 EVM values, format 4: 139 EVM values"""
+			:return: power: 2048 power values, from -1100 s to +2098.4375 s relative to the start of the SRS symbol. The values have a spacing of 1.5625 s. The 705th value is at the start of the SRS symbol (0 s) ."""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:PRACh:TRACe:PERRor:MAXimum?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:SRS:TRACe:PDYNamics:MAXimum?', suppressed)
 		return response
```

#### encoding

```diff
@@ -1 +1 @@
-us-ascii
+utf-8
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Prach_/Trace_/PvPreamble.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/Prach/Trace/PvPreamble.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,35 +1,35 @@
 from typing import List
 
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
-from ....Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ....Internal.Types import DataType
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
+from .....Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .....Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class PvPreamble:
-	"""PvPreamble commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class PvPreambleCls:
+	"""PvPreamble commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("pvPreamble", core, parent)
+		self._cmd_group = CommandsGroup("pvPreamble", core, parent)
 
 	def read(self) -> List[float]:
 		"""SCPI: READ:LTE:MEASurement<Instance>:PRACh:TRACe:PVPReamble \n
-		Snippet: value: List[float] = driver.prach.trace.pvPreamble.read() \n
+		Snippet: value: List[float] = driver.lteMeas.prach.trace.pvPreamble.read() \n
 		Return the values of the power vs preamble traces. See also 'Square EVM vs Preamble, Power vs Preamble'. \n
 		Suppressed linked return values: reliability \n
 			:return: results: 32 power values, for preamble 1 to 32 (NCAP for not measured preambles)"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:LTE:MEASurement<Instance>:PRACh:TRACe:PVPReamble?', suppressed)
 		return response
 
 	def fetch(self) -> List[float]:
 		"""SCPI: FETCh:LTE:MEASurement<Instance>:PRACh:TRACe:PVPReamble \n
-		Snippet: value: List[float] = driver.prach.trace.pvPreamble.fetch() \n
+		Snippet: value: List[float] = driver.lteMeas.prach.trace.pvPreamble.fetch() \n
 		Return the values of the power vs preamble traces. See also 'Square EVM vs Preamble, Power vs Preamble'. \n
 		Suppressed linked return values: reliability \n
 			:return: results: 32 power values, for preamble 1 to 32 (NCAP for not measured preambles)"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:PRACh:TRACe:PVPReamble?', suppressed)
 		return response
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Route.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/State/__init__.py`

 * *Files 27% similar despite different names*

```diff
@@ -1,67 +1,46 @@
-from ..Internal.Core import Core
-from ..Internal.CommandsGroup import CommandsGroup
-from ..Internal.StructBase import StructBase
-from ..Internal.ArgStruct import ArgStruct
-from .. import enums
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
+from .....Internal import Conversions
+from .....Internal.Types import DataType
+from .....Internal.ArgSingleList import ArgSingleList
+from .....Internal.ArgSingle import ArgSingle
+from ..... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Route:
-	"""Route commands group definition. 6 total commands, 2 Sub-groups, 1 group commands"""
+class StateCls:
+	"""State commands group definition. 2 total commands, 1 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("route", core, parent)
+		self._cmd_group = CommandsGroup("state", core, parent)
 
 	@property
-	def scenario(self):
-		"""scenario commands group. 2 Sub-classes, 2 commands."""
-		if not hasattr(self, '_scenario'):
-			from .Route_.Scenario import Scenario
-			self._scenario = Scenario(self._core, self._base)
-		return self._scenario
-
-	@property
-	def rfSettings(self):
-		"""rfSettings commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_rfSettings'):
-			from .Route_.RfSettings import RfSettings
-			self._rfSettings = RfSettings(self._core, self._base)
-		return self._rfSettings
-
-	# noinspection PyTypeChecker
-	class ValueStruct(StructBase):
-		"""Structure for reading output parameters. Fields: \n
-			- Scenario: enums.Scenario: No parameter help available
-			- Controller: str: No parameter help available
-			- Rx_Connector: enums.RxConnector: No parameter help available
-			- Rf_Converter: enums.RxConverter: No parameter help available"""
-		__meta_args_list = [
-			ArgStruct.scalar_enum('Scenario', enums.Scenario),
-			ArgStruct.scalar_str('Controller'),
-			ArgStruct.scalar_enum('Rx_Connector', enums.RxConnector),
-			ArgStruct.scalar_enum('Rf_Converter', enums.RxConverter)]
-
-		def __init__(self):
-			StructBase.__init__(self, self)
-			self.Scenario: enums.Scenario = None
-			self.Controller: str = None
-			self.Rx_Connector: enums.RxConnector = None
-			self.Rf_Converter: enums.RxConverter = None
+	def all(self):
+		"""all commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_all'):
+			from .All import AllCls
+			self._all = AllCls(self._core, self._cmd_group)
+		return self._all
 
 	# noinspection PyTypeChecker
-	def get_value(self) -> ValueStruct:
-		"""SCPI: ROUTe:LTE:MEASurement<Instance> \n
-		Snippet: value: ValueStruct = driver.route.get_value() \n
-		No command help available \n
-			:return: structure: for return value, see the help for ValueStruct structure arguments.
-		"""
-		return self._core.io.query_struct('ROUTe:LTE:MEASurement<Instance>?', self.__class__.ValueStruct())
+	def fetch(self, timeout: float = None, target_main_state: enums.TargetStateA = None, target_sync_state: enums.TargetSyncState = None) -> enums.ResourceState:
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:MEValuation:STATe \n
+		Snippet: value: enums.ResourceState = driver.lteMeas.multiEval.state.fetch(timeout = 1.0, target_main_state = enums.TargetStateA.OFF, target_sync_state = enums.TargetSyncState.ADJusted) \n
+		Queries the main measurement state. Without query parameters, the state is returned immediately. With query parameters,
+		the state is returned when the <TargetMainState> and the <TargetSyncState> are reached or when the <Timeout> expires. \n
+			:param timeout: No help available
+			:param target_main_state: Target MainState for the query Default is RUN.
+			:param target_sync_state: Target SyncState for the query Default is ADJ.
+			:return: meas_status: Current state or target state of ongoing state transition OFF: measurement off RUN: measurement running RDY: measurement completed"""
+		param = ArgSingleList().compose_cmd_string(ArgSingle('timeout', timeout, DataType.Float, None, is_optional=True), ArgSingle('target_main_state', target_main_state, DataType.Enum, enums.TargetStateA, is_optional=True), ArgSingle('target_sync_state', target_sync_state, DataType.Enum, enums.TargetSyncState, is_optional=True))
+		response = self._core.io.query_str(f'FETCh:LTE:MEASurement<Instance>:MEValuation:STATe? {param}'.rstrip())
+		return Conversions.str_to_scalar_enum(response, enums.ResourceState)
 
-	def clone(self) -> 'Route':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'StateCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Route(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = StateCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Route_/Scenario.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Limit/Qpsk/Ibe/__init__.py`

 * *Files 27% similar despite different names*

```diff
@@ -1,88 +1,77 @@
-from ...Internal.Core import Core
-from ...Internal.CommandsGroup import CommandsGroup
-from ...Internal import Conversions
-from ...Internal.StructBase import StructBase
-from ...Internal.ArgStruct import ArgStruct
-from ... import enums
+from ........Internal.Core import Core
+from ........Internal.CommandsGroup import CommandsGroup
+from ........Internal.Types import DataType
+from ........Internal.StructBase import StructBase
+from ........Internal.ArgStruct import ArgStruct
+from ........Internal.ArgSingleList import ArgSingleList
+from ........Internal.ArgSingle import ArgSingle
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Scenario:
-	"""Scenario commands group definition. 4 total commands, 2 Sub-groups, 2 group commands"""
+class IbeCls:
+	"""Ibe commands group definition. 2 total commands, 1 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("scenario", core, parent)
+		self._cmd_group = CommandsGroup("ibe", core, parent)
 
 	@property
-	def combinedSignalPath(self):
-		"""combinedSignalPath commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_combinedSignalPath'):
-			from .Scenario_.CombinedSignalPath import CombinedSignalPath
-			self._combinedSignalPath = CombinedSignalPath(self._core, self._base)
-		return self._combinedSignalPath
-
-	@property
-	def maProtocol(self):
-		"""maProtocol commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_maProtocol'):
-			from .Scenario_.MaProtocol import MaProtocol
-			self._maProtocol = MaProtocol(self._core, self._base)
-		return self._maProtocol
+	def iqOffset(self):
+		"""iqOffset commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_iqOffset'):
+			from .IqOffset import IqOffsetCls
+			self._iqOffset = IqOffsetCls(self._core, self._cmd_group)
+		return self._iqOffset
+
+	def set(self, enable: bool, minimum: float, evm: float, rb_power: float, iq_image: float) -> None:
+		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QPSK:IBE \n
+		Snippet: driver.configure.lteMeas.multiEval.limit.qpsk.ibe.set(enable = False, minimum = 1.0, evm = 1.0, rb_power = 1.0, iq_image = 1.0) \n
+		Defines parameters used for calculation of an upper limit for the in-band emission (QPSK modulation) , see 'In-band
+		emissions limits'. \n
+			:param enable: OFF: disables the limit check ON: enables the limit check
+			:param minimum: No help available
+			:param evm: No help available
+			:param rb_power: No help available
+			:param iq_image: No help available
+		"""
+		param = ArgSingleList().compose_cmd_string(ArgSingle('enable', enable, DataType.Boolean), ArgSingle('minimum', minimum, DataType.Float), ArgSingle('evm', evm, DataType.Float), ArgSingle('rb_power', rb_power, DataType.Float), ArgSingle('iq_image', iq_image, DataType.Float))
+		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QPSK:IBE {param}'.rstrip())
 
 	# noinspection PyTypeChecker
-	class SaloneStruct(StructBase):
-		"""Structure for reading output parameters. Fields: \n
-			- Rx_Connector: enums.RxConnector: RF connector for the input path Single R&S CMW500: RFnC for RF n COM CMWflexx: RabC for CMW a, connector RF b COM
-			- Rf_Converter: enums.RxConverter: RX module for the input path Single R&S CMW500: TX1 to TX4 CMWflexx: TXab for CMW a, TX b"""
+	class IbeStruct(StructBase):
+		"""Response structure. Fields: \n
+			- Enable: bool: OFF: disables the limit check ON: enables the limit check
+			- Minimum: float: No parameter help available
+			- Evm: float: No parameter help available
+			- Rb_Power: float: No parameter help available
+			- Iq_Image: float: No parameter help available"""
 		__meta_args_list = [
-			ArgStruct.scalar_enum('Rx_Connector', enums.RxConnector),
-			ArgStruct.scalar_enum('Rf_Converter', enums.RxConverter)]
+			ArgStruct.scalar_bool('Enable'),
+			ArgStruct.scalar_float('Minimum'),
+			ArgStruct.scalar_float('Evm'),
+			ArgStruct.scalar_float('Rb_Power'),
+			ArgStruct.scalar_float('Iq_Image')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
-			self.Rx_Connector: enums.RxConnector = None
-			self.Rf_Converter: enums.RxConverter = None
-
-	# noinspection PyTypeChecker
-	def get_salone(self) -> SaloneStruct:
-		"""SCPI: ROUTe:LTE:MEASurement<Instance>:SCENario:SALone \n
-		Snippet: value: SaloneStruct = driver.route.scenario.get_salone() \n
-		Selects the signal path for the measured signal.
-			INTRO_CMD_HELP: Value combinations: \n
-			- RF 1 COM and RF 2 COM are compatible with TX 1 and TX 3.
-			- RF 3 COM and RF 4 COM are compatible with TX 2 and TX 4.
-		Note: This command is an interim solution. It is planned to replace this command in a later software version. \n
-			:return: structure: for return value, see the help for SaloneStruct structure arguments.
-		"""
-		return self._core.io.query_struct('ROUTe:LTE:MEASurement<Instance>:SCENario:SALone?', self.__class__.SaloneStruct())
-
-	def set_salone(self, value: SaloneStruct) -> None:
-		"""SCPI: ROUTe:LTE:MEASurement<Instance>:SCENario:SALone \n
-		Snippet: driver.route.scenario.set_salone(value = SaloneStruct()) \n
-		Selects the signal path for the measured signal.
-			INTRO_CMD_HELP: Value combinations: \n
-			- RF 1 COM and RF 2 COM are compatible with TX 1 and TX 3.
-			- RF 3 COM and RF 4 COM are compatible with TX 2 and TX 4.
-		Note: This command is an interim solution. It is planned to replace this command in a later software version. \n
-			:param value: see the help for SaloneStruct structure arguments.
-		"""
-		self._core.io.write_struct('ROUTe:LTE:MEASurement<Instance>:SCENario:SALone', value)
-
-	# noinspection PyTypeChecker
-	def get_value(self) -> enums.Scenario:
-		"""SCPI: ROUTe:LTE:MEASurement<Instance>:SCENario \n
-		Snippet: value: enums.Scenario = driver.route.scenario.get_value() \n
-		No command help available \n
-			:return: scenario: No help available
-		"""
-		response = self._core.io.query_str('ROUTe:LTE:MEASurement<Instance>:SCENario?')
-		return Conversions.str_to_scalar_enum(response, enums.Scenario)
+			self.Enable: bool = None
+			self.Minimum: float = None
+			self.Evm: float = None
+			self.Rb_Power: float = None
+			self.Iq_Image: float = None
+
+	def get(self) -> IbeStruct:
+		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QPSK:IBE \n
+		Snippet: value: IbeStruct = driver.configure.lteMeas.multiEval.limit.qpsk.ibe.get() \n
+		Defines parameters used for calculation of an upper limit for the in-band emission (QPSK modulation) , see 'In-band
+		emissions limits'. \n
+			:return: structure: for return value, see the help for IbeStruct structure arguments."""
+		return self._core.io.query_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QPSK:IBE?', self.__class__.IbeStruct())
 
-	def clone(self) -> 'Scenario':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'IbeCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Scenario(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = IbeCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Route_/Scenario_/CombinedSignalPath.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Limit/Qpsk/EvMagnitude.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,50 +1,47 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
-from ....Internal.Types import DataType
-from ....Internal.StructBase import StructBase
-from ....Internal.ArgStruct import ArgStruct
-from ....Internal.ArgSingleList import ArgSingleList
-from ....Internal.ArgSingle import ArgSingle
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal.Types import DataType
+from .......Internal.StructBase import StructBase
+from .......Internal.ArgStruct import ArgStruct
+from .......Internal.ArgSingleList import ArgSingleList
+from .......Internal.ArgSingle import ArgSingle
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class CombinedSignalPath:
-	"""CombinedSignalPath commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class EvMagnitudeCls:
+	"""EvMagnitude commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("combinedSignalPath", core, parent)
+		self._cmd_group = CommandsGroup("evMagnitude", core, parent)
 
-	def set(self, master: str, carrier: str = None) -> None:
-		"""SCPI: ROUTe:LTE:MEASurement<Instance>:SCENario:CSPath \n
-		Snippet: driver.route.scenario.combinedSignalPath.set(master = '1', carrier = '1') \n
-		No command help available \n
-			:param master: No help available
-			:param carrier: No help available
+	def set(self, rms: float or bool, peak: float or bool) -> None:
+		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QPSK:EVMagnitude \n
+		Snippet: driver.configure.lteMeas.multiEval.limit.qpsk.evMagnitude.set(rms = 1.0, peak = 1.0) \n
+		Defines upper limits for the RMS and peak values of the error vector magnitude (EVM) for QPSK. \n
+			:param rms: (float or boolean) No help available
+			:param peak: (float or boolean) No help available
 		"""
-		param = ArgSingleList().compose_cmd_string(ArgSingle('master', master, DataType.String), ArgSingle('carrier', carrier, DataType.String, True))
-		self._core.io.write(f'ROUTe:LTE:MEASurement<Instance>:SCENario:CSPath {param}'.rstrip())
+		param = ArgSingleList().compose_cmd_string(ArgSingle('rms', rms, DataType.FloatExt), ArgSingle('peak', peak, DataType.FloatExt))
+		self._core.io.write(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QPSK:EVMagnitude {param}'.rstrip())
 
 	# noinspection PyTypeChecker
-	class GetStruct(StructBase):
+	class EvMagnitudeStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Master: str: No parameter help available
-			- Carrier: str: No parameter help available
-			- Set_Py: str: No parameter help available"""
+			- Rms: float or bool: No parameter help available
+			- Peak: float or bool: No parameter help available"""
 		__meta_args_list = [
-			ArgStruct.scalar_str('Master'),
-			ArgStruct.scalar_str('Carrier'),
-			ArgStruct.scalar_str('Set_Py')]
+			ArgStruct.scalar_float_ext('Rms'),
+			ArgStruct.scalar_float_ext('Peak')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
-			self.Master: str = None
-			self.Carrier: str = None
-			self.Set_Py: str = None
-
-	def get(self) -> GetStruct:
-		"""SCPI: ROUTe:LTE:MEASurement<Instance>:SCENario:CSPath \n
-		Snippet: value: GetStruct = driver.route.scenario.combinedSignalPath.get() \n
-		No command help available \n
-			:return: structure: for return value, see the help for GetStruct structure arguments."""
-		return self._core.io.query_struct(f'ROUTe:LTE:MEASurement<Instance>:SCENario:CSPath?', self.__class__.GetStruct())
+			self.Rms: float or bool = None
+			self.Peak: float or bool = None
+
+	def get(self) -> EvMagnitudeStruct:
+		"""SCPI: CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QPSK:EVMagnitude \n
+		Snippet: value: EvMagnitudeStruct = driver.configure.lteMeas.multiEval.limit.qpsk.evMagnitude.get() \n
+		Defines upper limits for the RMS and peak values of the error vector magnitude (EVM) for QPSK. \n
+			:return: structure: for return value, see the help for EvMagnitudeStruct structure arguments."""
+		return self._core.io.query_struct(f'CONFigure:LTE:MEASurement<Instance>:MEValuation:LIMit:QPSK:EVMagnitude?', self.__class__.EvMagnitudeStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Sense.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Sense/LteMeas/__init__.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,35 +1,35 @@
-from ..Internal.Core import Core
-from ..Internal.CommandsGroup import CommandsGroup
+from ....Internal.Core import Core
+from ....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Sense:
-	"""Sense commands group definition. 6 total commands, 2 Sub-groups, 0 group commands"""
+class LteMeasCls:
+	"""LteMeas commands group definition. 6 total commands, 2 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("sense", core, parent)
+		self._cmd_group = CommandsGroup("lteMeas", core, parent)
 
 	@property
 	def carrierAggregation(self):
 		"""carrierAggregation commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_carrierAggregation'):
-			from .Sense_.CarrierAggregation import CarrierAggregation
-			self._carrierAggregation = CarrierAggregation(self._core, self._base)
+			from .CarrierAggregation import CarrierAggregationCls
+			self._carrierAggregation = CarrierAggregationCls(self._core, self._cmd_group)
 		return self._carrierAggregation
 
 	@property
 	def multiEval(self):
 		"""multiEval commands group. 2 Sub-classes, 0 commands."""
 		if not hasattr(self, '_multiEval'):
-			from .Sense_.MultiEval import MultiEval
-			self._multiEval = MultiEval(self._core, self._base)
+			from .MultiEval import MultiEvalCls
+			self._multiEval = MultiEvalCls(self._core, self._cmd_group)
 		return self._multiEval
 
-	def clone(self) -> 'Sense':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'LteMeasCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Sense(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = LteMeasCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Sense_/CarrierAggregation.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Sense/LteMeas/CarrierAggregation.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,21 +1,21 @@
-from ...Internal.Core import Core
-from ...Internal.CommandsGroup import CommandsGroup
-from ...Internal import Conversions
+from ....Internal.Core import Core
+from ....Internal.CommandsGroup import CommandsGroup
+from ....Internal import Conversions
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class CarrierAggregation:
-	"""CarrierAggregation commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class CarrierAggregationCls:
+	"""CarrierAggregation commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("carrierAggregation", core, parent)
+		self._cmd_group = CommandsGroup("carrierAggregation", core, parent)
 
 	def get_fshware(self) -> bool:
 		"""SCPI: SENSe:LTE:MEASurement<Instance>:CAGGregation:FSHWare \n
-		Snippet: value: bool = driver.sense.carrierAggregation.get_fshware() \n
+		Snippet: value: bool = driver.sense.lteMeas.carrierAggregation.get_fshware() \n
 		No command help available \n
 			:return: value: No help available
 		"""
 		response = self._core.io.query_str('SENSe:LTE:MEASurement<Instance>:CAGGregation:FSHWare?')
 		return Conversions.str_to_bool(response)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Sense_/MultiEval_/Limit.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Sense/LteMeas/MultiEval/Spectrum/__init__.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,27 +1,27 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Limit:
-	"""Limit commands group definition. 4 total commands, 1 Sub-groups, 0 group commands"""
+class SpectrumCls:
+	"""Spectrum commands group definition. 1 total commands, 1 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("limit", core, parent)
+		self._cmd_group = CommandsGroup("spectrum", core, parent)
 
 	@property
-	def iemissions(self):
-		"""iemissions commands group. 1 Sub-classes, 2 commands."""
-		if not hasattr(self, '_iemissions'):
-			from .Limit_.Iemissions import Iemissions
-			self._iemissions = Iemissions(self._core, self._base)
-		return self._iemissions
+	def seMask(self):
+		"""seMask commands group. 1 Sub-classes, 0 commands."""
+		if not hasattr(self, '_seMask'):
+			from .SeMask import SeMaskCls
+			self._seMask = SeMaskCls(self._core, self._cmd_group)
+		return self._seMask
 
-	def clone(self) -> 'Limit':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'SpectrumCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Limit(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = SpectrumCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Sense_/MultiEval_/Limit_/Iemissions.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Sense/LteMeas/MultiEval/Limit/Iemissions/__init__.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,47 +1,47 @@
 from typing import List
 
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Iemissions:
-	"""Iemissions commands group definition. 4 total commands, 1 Sub-groups, 2 group commands"""
+class IemissionsCls:
+	"""Iemissions commands group definition. 4 total commands, 1 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("iemissions", core, parent)
+		self._cmd_group = CommandsGroup("iemissions", core, parent)
 
 	@property
 	def ulca(self):
 		"""ulca commands group. 1 Sub-classes, 1 commands."""
 		if not hasattr(self, '_ulca'):
-			from .Iemissions_.Ulca import Ulca
-			self._ulca = Ulca(self._core, self._base)
+			from .Ulca import UlcaCls
+			self._ulca = UlcaCls(self._core, self._cmd_group)
 		return self._ulca
 
 	def get_scc(self) -> List[float]:
 		"""SCPI: SENSe:LTE:MEASurement<Instance>:MEValuation:LIMit:IEMissions:SCC \n
-		Snippet: value: List[float] = driver.sense.multiEval.limit.iemissions.get_scc() \n
+		Snippet: value: List[float] = driver.sense.lteMeas.multiEval.limit.iemissions.get_scc() \n
 		No command help available \n
 			:return: power: No help available
 		"""
 		response = self._core.io.query_bin_or_ascii_float_list('SENSe:LTE:MEASurement<Instance>:MEValuation:LIMit:IEMissions:SCC?')
 		return response
 
 	def get_pcc(self) -> List[float]:
 		"""SCPI: SENSe:LTE:MEASurement<Instance>:MEValuation:LIMit:IEMissions[:PCC] \n
-		Snippet: value: List[float] = driver.sense.multiEval.limit.iemissions.get_pcc() \n
+		Snippet: value: List[float] = driver.sense.lteMeas.multiEval.limit.iemissions.get_pcc() \n
 		No command help available \n
 			:return: power: No help available
 		"""
 		response = self._core.io.query_bin_or_ascii_float_list('SENSe:LTE:MEASurement<Instance>:MEValuation:LIMit:IEMissions:PCC?')
 		return response
 
-	def clone(self) -> 'Iemissions':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'IemissionsCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Iemissions(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = IemissionsCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Sense_/MultiEval_/Spectrum_/SeMask.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Configure/LteMeas/MultiEval/Spectrum/__init__.py`

 * *Files 23% similar despite different names*

```diff
@@ -1,27 +1,35 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class SeMask:
-	"""SeMask commands group definition. 1 total commands, 1 Sub-groups, 0 group commands"""
+class SpectrumCls:
+	"""Spectrum commands group definition. 2 total commands, 2 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("seMask", core, parent)
+		self._cmd_group = CommandsGroup("spectrum", core, parent)
 
 	@property
-	def rbw(self):
-		"""rbw commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_rbw'):
-			from .SeMask_.Rbw import Rbw
-			self._rbw = Rbw(self._core, self._base)
-		return self._rbw
+	def seMask(self):
+		"""seMask commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_seMask'):
+			from .SeMask import SeMaskCls
+			self._seMask = SeMaskCls(self._core, self._cmd_group)
+		return self._seMask
 
-	def clone(self) -> 'SeMask':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	@property
+	def aclr(self):
+		"""aclr commands group. 1 Sub-classes, 0 commands."""
+		if not hasattr(self, '_aclr'):
+			from .Aclr import AclrCls
+			self._aclr = AclrCls(self._core, self._cmd_group)
+		return self._aclr
+
+	def clone(self) -> 'SpectrumCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = SeMask(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = SpectrumCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Sense_/MultiEval_/Spectrum_/SeMask_/Rbw.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Sense/LteMeas/MultiEval/Spectrum/SeMask/Rbw.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,23 +1,23 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
-from ......Internal.StructBase import StructBase
-from ......Internal.ArgStruct import ArgStruct
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal.StructBase import StructBase
+from .......Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Rbw:
-	"""Rbw commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class RbwCls:
+	"""Rbw commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("rbw", core, parent)
+		self._cmd_group = CommandsGroup("rbw", core, parent)
 
 	# noinspection PyTypeChecker
-	class UsedStruct(StructBase):
+	class UsedStruct(StructBase):  # From ReadStructDefinition CmdPropertyTemplate.xml
 		"""Structure for reading output parameters. Fields: \n
 			- Trace_1: int: RBW for trace 1 (smallest RBW)
 			- Trace_2: int: RBW for trace 2 (intermediate RBW)
 			- Trace_3: int: RBW for trace 3 (largest RBW)"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Trace_1'),
 			ArgStruct.scalar_int('Trace_2'),
@@ -27,13 +27,13 @@
 			StructBase.__init__(self, self)
 			self.Trace_1: int = None
 			self.Trace_2: int = None
 			self.Trace_3: int = None
 
 	def get_used(self) -> UsedStruct:
 		"""SCPI: SENSe:LTE:MEASurement<Instance>:MEValuation:SPECtrum:SEMask:RBW:USED \n
-		Snippet: value: UsedStruct = driver.sense.multiEval.spectrum.seMask.rbw.get_used() \n
+		Snippet: value: UsedStruct = driver.sense.lteMeas.multiEval.spectrum.seMask.rbw.get_used() \n
 		Queries the resolution bandwidths (RBW) allowed for spectrum emission measurements. The RBWs depend on the channel
-		bandwidth and on the network signaled value. \n
+		bandwidth and on the 'network signaled value'. \n
 			:return: structure: for return value, see the help for UsedStruct structure arguments.
 		"""
 		return self._core.io.query_struct('SENSe:LTE:MEASurement<Instance>:MEValuation:SPECtrum:SEMask:RBW:USED?', self.__class__.UsedStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Srs.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/Prach/__init__.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,112 +1,104 @@
-from ..Internal.Core import Core
-from ..Internal.CommandsGroup import CommandsGroup
+from ....Internal.Core import Core
+from ....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Srs:
-	"""Srs commands group definition. 26 total commands, 3 Sub-groups, 3 group commands"""
+class PrachCls:
+	"""Prach commands group definition. 85 total commands, 5 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("srs", core, parent)
+		self._cmd_group = CommandsGroup("prach", core, parent)
 
 	@property
 	def state(self):
 		"""state commands group. 1 Sub-classes, 1 commands."""
 		if not hasattr(self, '_state'):
-			from .Srs_.State import State
-			self._state = State(self._core, self._base)
+			from .State import StateCls
+			self._state = StateCls(self._core, self._cmd_group)
 		return self._state
 
 	@property
 	def trace(self):
-		"""trace commands group. 1 Sub-classes, 0 commands."""
+		"""trace commands group. 7 Sub-classes, 0 commands."""
 		if not hasattr(self, '_trace'):
-			from .Srs_.Trace import Trace
-			self._trace = Trace(self._core, self._base)
+			from .Trace import TraceCls
+			self._trace = TraceCls(self._core, self._cmd_group)
 		return self._trace
 
 	@property
+	def modulation(self):
+		"""modulation commands group. 9 Sub-classes, 0 commands."""
+		if not hasattr(self, '_modulation'):
+			from .Modulation import ModulationCls
+			self._modulation = ModulationCls(self._core, self._cmd_group)
+		return self._modulation
+
+	@property
+	def evmSymbol(self):
+		"""evmSymbol commands group. 4 Sub-classes, 0 commands."""
+		if not hasattr(self, '_evmSymbol'):
+			from .EvmSymbol import EvmSymbolCls
+			self._evmSymbol = EvmSymbolCls(self._core, self._cmd_group)
+		return self._evmSymbol
+
+	@property
 	def pdynamics(self):
 		"""pdynamics commands group. 5 Sub-classes, 0 commands."""
 		if not hasattr(self, '_pdynamics'):
-			from .Srs_.Pdynamics import Pdynamics
-			self._pdynamics = Pdynamics(self._core, self._base)
+			from .Pdynamics import PdynamicsCls
+			self._pdynamics = PdynamicsCls(self._core, self._cmd_group)
 		return self._pdynamics
 
-	def initiate(self) -> None:
-		"""SCPI: INITiate:LTE:MEASurement<Instance>:SRS \n
-		Snippet: driver.srs.initiate() \n
-			INTRO_CMD_HELP: Starts, stops, or aborts the measurement: \n
-			- INITiate... starts or restarts the measurement. The measurement enters the 'RUN' state.
-			- STOP... halts the measurement immediately. The measurement enters the 'RDY' state. Measurement results are kept. The resources remain allocated to the measurement.
-			- ABORt... halts the measurement immediately. The measurement enters the 'OFF' state. All measurement values are set to NAV. Allocated resources are released.
+	def initiate(self, opc_timeout_ms: int = -1) -> None:
+		"""SCPI: INITiate:LTE:MEASurement<Instance>:PRACh \n
+		Snippet: driver.lteMeas.prach.initiate() \n
+			INTRO_CMD_HELP: Starts, stops or aborts the measurement: \n
+			- INITiate... starts or restarts the measurement. The measurement enters the RUN state.
+			- STOP... halts the measurement immediately. The measurement enters the RDY state. Measurement results are kept. The resources remain allocated to the measurement.
+			- ABORt... halts the measurement immediately. The measurement enters the OFF state. All measurement values are set to NAV. Allocated resources are released.
 		Use FETCh...STATe? to query the current measurement state. \n
-		"""
-		self._core.io.write(f'INITiate:LTE:MEASurement<Instance>:SRS')
-
-	def initiate_with_opc(self) -> None:
-		"""SCPI: INITiate:LTE:MEASurement<Instance>:SRS \n
-		Snippet: driver.srs.initiate_with_opc() \n
-			INTRO_CMD_HELP: Starts, stops, or aborts the measurement: \n
-			- INITiate... starts or restarts the measurement. The measurement enters the 'RUN' state.
-			- STOP... halts the measurement immediately. The measurement enters the 'RDY' state. Measurement results are kept. The resources remain allocated to the measurement.
-			- ABORt... halts the measurement immediately. The measurement enters the 'OFF' state. All measurement values are set to NAV. Allocated resources are released.
-		Use FETCh...STATe? to query the current measurement state. \n
-		Same as initiate, but waits for the operation to complete before continuing further. Use the RsCMPX_LteMeas.utilities.opc_timeout_set() to set the timeout value. \n
-		"""
-		self._core.io.write_with_opc(f'INITiate:LTE:MEASurement<Instance>:SRS')
+			:param opc_timeout_ms: Maximum time to wait in milliseconds, valid only for this call."""
+		self._core.io.write_with_opc(f'INITiate:LTE:MEASurement<Instance>:PRACh', opc_timeout_ms)
 
 	def stop(self) -> None:
-		"""SCPI: STOP:LTE:MEASurement<Instance>:SRS \n
-		Snippet: driver.srs.stop() \n
-			INTRO_CMD_HELP: Starts, stops, or aborts the measurement: \n
-			- INITiate... starts or restarts the measurement. The measurement enters the 'RUN' state.
-			- STOP... halts the measurement immediately. The measurement enters the 'RDY' state. Measurement results are kept. The resources remain allocated to the measurement.
-			- ABORt... halts the measurement immediately. The measurement enters the 'OFF' state. All measurement values are set to NAV. Allocated resources are released.
-		Use FETCh...STATe? to query the current measurement state. \n
-		"""
-		self._core.io.write(f'STOP:LTE:MEASurement<Instance>:SRS')
-
-	def stop_with_opc(self) -> None:
-		"""SCPI: STOP:LTE:MEASurement<Instance>:SRS \n
-		Snippet: driver.srs.stop_with_opc() \n
-			INTRO_CMD_HELP: Starts, stops, or aborts the measurement: \n
-			- INITiate... starts or restarts the measurement. The measurement enters the 'RUN' state.
-			- STOP... halts the measurement immediately. The measurement enters the 'RDY' state. Measurement results are kept. The resources remain allocated to the measurement.
-			- ABORt... halts the measurement immediately. The measurement enters the 'OFF' state. All measurement values are set to NAV. Allocated resources are released.
+		"""SCPI: STOP:LTE:MEASurement<Instance>:PRACh \n
+		Snippet: driver.lteMeas.prach.stop() \n
+			INTRO_CMD_HELP: Starts, stops or aborts the measurement: \n
+			- INITiate... starts or restarts the measurement. The measurement enters the RUN state.
+			- STOP... halts the measurement immediately. The measurement enters the RDY state. Measurement results are kept. The resources remain allocated to the measurement.
+			- ABORt... halts the measurement immediately. The measurement enters the OFF state. All measurement values are set to NAV. Allocated resources are released.
+		Use FETCh...STATe? to query the current measurement state. \n
+		"""
+		self._core.io.write(f'STOP:LTE:MEASurement<Instance>:PRACh')
+
+	def stop_with_opc(self, opc_timeout_ms: int = -1) -> None:
+		"""SCPI: STOP:LTE:MEASurement<Instance>:PRACh \n
+		Snippet: driver.lteMeas.prach.stop_with_opc() \n
+			INTRO_CMD_HELP: Starts, stops or aborts the measurement: \n
+			- INITiate... starts or restarts the measurement. The measurement enters the RUN state.
+			- STOP... halts the measurement immediately. The measurement enters the RDY state. Measurement results are kept. The resources remain allocated to the measurement.
+			- ABORt... halts the measurement immediately. The measurement enters the OFF state. All measurement values are set to NAV. Allocated resources are released.
 		Use FETCh...STATe? to query the current measurement state. \n
 		Same as stop, but waits for the operation to complete before continuing further. Use the RsCMPX_LteMeas.utilities.opc_timeout_set() to set the timeout value. \n
-		"""
-		self._core.io.write_with_opc(f'STOP:LTE:MEASurement<Instance>:SRS')
+			:param opc_timeout_ms: Maximum time to wait in milliseconds, valid only for this call."""
+		self._core.io.write_with_opc(f'STOP:LTE:MEASurement<Instance>:PRACh', opc_timeout_ms)
 
-	def abort(self) -> None:
-		"""SCPI: ABORt:LTE:MEASurement<Instance>:SRS \n
-		Snippet: driver.srs.abort() \n
-			INTRO_CMD_HELP: Starts, stops, or aborts the measurement: \n
-			- INITiate... starts or restarts the measurement. The measurement enters the 'RUN' state.
-			- STOP... halts the measurement immediately. The measurement enters the 'RDY' state. Measurement results are kept. The resources remain allocated to the measurement.
-			- ABORt... halts the measurement immediately. The measurement enters the 'OFF' state. All measurement values are set to NAV. Allocated resources are released.
+	def abort(self, opc_timeout_ms: int = -1) -> None:
+		"""SCPI: ABORt:LTE:MEASurement<Instance>:PRACh \n
+		Snippet: driver.lteMeas.prach.abort() \n
+			INTRO_CMD_HELP: Starts, stops or aborts the measurement: \n
+			- INITiate... starts or restarts the measurement. The measurement enters the RUN state.
+			- STOP... halts the measurement immediately. The measurement enters the RDY state. Measurement results are kept. The resources remain allocated to the measurement.
+			- ABORt... halts the measurement immediately. The measurement enters the OFF state. All measurement values are set to NAV. Allocated resources are released.
 		Use FETCh...STATe? to query the current measurement state. \n
-		"""
-		self._core.io.write(f'ABORt:LTE:MEASurement<Instance>:SRS')
-
-	def abort_with_opc(self) -> None:
-		"""SCPI: ABORt:LTE:MEASurement<Instance>:SRS \n
-		Snippet: driver.srs.abort_with_opc() \n
-			INTRO_CMD_HELP: Starts, stops, or aborts the measurement: \n
-			- INITiate... starts or restarts the measurement. The measurement enters the 'RUN' state.
-			- STOP... halts the measurement immediately. The measurement enters the 'RDY' state. Measurement results are kept. The resources remain allocated to the measurement.
-			- ABORt... halts the measurement immediately. The measurement enters the 'OFF' state. All measurement values are set to NAV. Allocated resources are released.
-		Use FETCh...STATe? to query the current measurement state. \n
-		Same as abort, but waits for the operation to complete before continuing further. Use the RsCMPX_LteMeas.utilities.opc_timeout_set() to set the timeout value. \n
-		"""
-		self._core.io.write_with_opc(f'ABORt:LTE:MEASurement<Instance>:SRS')
+			:param opc_timeout_ms: Maximum time to wait in milliseconds, valid only for this call."""
+		self._core.io.write_with_opc(f'ABORt:LTE:MEASurement<Instance>:PRACh', opc_timeout_ms)
 
-	def clone(self) -> 'Srs':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'PrachCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Srs(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = PrachCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Srs_/Pdynamics.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/Modulation/IqOffset/__init__.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,59 +1,51 @@
-from ...Internal.Core import Core
-from ...Internal.CommandsGroup import CommandsGroup
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Pdynamics:
-	"""Pdynamics commands group definition. 15 total commands, 5 Sub-groups, 0 group commands"""
+class IqOffsetCls:
+	"""IqOffset commands group definition. 7 total commands, 4 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("pdynamics", core, parent)
+		self._cmd_group = CommandsGroup("iqOffset", core, parent)
 
 	@property
 	def current(self):
-		"""current commands group. 0 Sub-classes, 3 commands."""
+		"""current commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_current'):
-			from .Pdynamics_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
 	@property
 	def average(self):
-		"""average commands group. 0 Sub-classes, 3 commands."""
+		"""average commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_average'):
-			from .Pdynamics_.Average import Average
-			self._average = Average(self._core, self._base)
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
 		return self._average
 
 	@property
-	def maximum(self):
-		"""maximum commands group. 0 Sub-classes, 3 commands."""
-		if not hasattr(self, '_maximum'):
-			from .Pdynamics_.Maximum import Maximum
-			self._maximum = Maximum(self._core, self._base)
-		return self._maximum
-
-	@property
-	def minimum(self):
-		"""minimum commands group. 0 Sub-classes, 3 commands."""
-		if not hasattr(self, '_minimum'):
-			from .Pdynamics_.Minimum import Minimum
-			self._minimum = Minimum(self._core, self._base)
-		return self._minimum
+	def extreme(self):
+		"""extreme commands group. 0 Sub-classes, 2 commands."""
+		if not hasattr(self, '_extreme'):
+			from .Extreme import ExtremeCls
+			self._extreme = ExtremeCls(self._core, self._cmd_group)
+		return self._extreme
 
 	@property
 	def standardDev(self):
-		"""standardDev commands group. 0 Sub-classes, 3 commands."""
+		"""standardDev commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_standardDev'):
-			from .Pdynamics_.StandardDev import StandardDev
-			self._standardDev = StandardDev(self._core, self._base)
+			from .StandardDev import StandardDevCls
+			self._standardDev = StandardDevCls(self._core, self._cmd_group)
 		return self._standardDev
 
-	def clone(self) -> 'Pdynamics':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'IqOffsetCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Pdynamics(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = IqOffsetCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Srs_/Pdynamics_/Average.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/Srs/Pdynamics/Current.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,32 +1,32 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
-from ....Internal.StructBase import StructBase
-from ....Internal.ArgStruct import ArgStruct
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
+from .....Internal.StructBase import StructBase
+from .....Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Out_Of_Tolerance: int: Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for power dynamics measurements exceeding the specified power dynamics limits.
-			- Off_Power_Before: float: OFF power mean value for time period before SRS symbol
-			- On_Power_Rms_1: float: ON power mean value over the first SRS symbol
-			- On_Power_Peak_1: float: ON power peak value for the first SRS symbol
-			- On_Power_Rms_2: float: ON power mean value over the second SRS symbol (NCAP returned for FDD)
-			- On_Power_Peak_2: float: ON power peak value for the second SRS symbol (NCAP returned for FDD)
-			- Off_Power_After: float: OFF power mean value for subframe after SRS symbol"""
+			- Reliability: int: 'Reliability indicator'
+			- Out_Of_Tolerance: int: Out of tolerance result, i.e. the percentage of measurement intervals of the statistic count for power dynamics measurements exceeding the specified power dynamics limits.
+			- Off_Power_Before: float: OFF power mean value for the time period before the SRS symbol.
+			- On_Power_Rms_1: float: ON power mean value over the first SRS symbol.
+			- On_Power_Peak_1: float: ON power peak value for the first SRS symbol.
+			- On_Power_Rms_2: float: ON power mean value over the second SRS symbol (NCAP returned for FDD) .
+			- On_Power_Peak_2: float: ON power peak value for the second SRS symbol (NCAP returned for FDD) .
+			- Off_Power_After: float: OFF power mean value for the subframe after the SRS symbol."""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
 			ArgStruct.scalar_float('Off_Power_Before'),
 			ArgStruct.scalar_float('On_Power_Rms_1'),
 			ArgStruct.scalar_float('On_Power_Peak_1'),
 			ArgStruct.scalar_float('On_Power_Rms_2'),
@@ -41,64 +41,64 @@
 			self.On_Power_Rms_1: float = None
 			self.On_Power_Peak_1: float = None
 			self.On_Power_Rms_2: float = None
 			self.On_Power_Peak_2: float = None
 			self.Off_Power_After: float = None
 
 	def read(self) -> ResultData:
-		"""SCPI: READ:LTE:MEASurement<Instance>:SRS:PDYNamics:AVERage \n
-		Snippet: value: ResultData = driver.srs.pdynamics.average.read() \n
-		Return the current, average, minimum, maximum and standard deviation single value results of the power dynamics
+		"""SCPI: READ:LTE:MEASurement<Instance>:SRS:PDYNamics:CURRent \n
+		Snippet: value: ResultData = driver.lteMeas.srs.pdynamics.current.read() \n
+		Return the current, average, minimum, maximum and standard deviation single-value results of the power dynamics
 		measurement. The values described below are returned by FETCh and READ commands. CALCulate commands return limit check
 		results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:SRS:PDYNamics:AVERage?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:SRS:PDYNamics:CURRent?', self.__class__.ResultData())
 
 	def fetch(self) -> ResultData:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:SRS:PDYNamics:AVERage \n
-		Snippet: value: ResultData = driver.srs.pdynamics.average.fetch() \n
-		Return the current, average, minimum, maximum and standard deviation single value results of the power dynamics
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:SRS:PDYNamics:CURRent \n
+		Snippet: value: ResultData = driver.lteMeas.srs.pdynamics.current.fetch() \n
+		Return the current, average, minimum, maximum and standard deviation single-value results of the power dynamics
 		measurement. The values described below are returned by FETCh and READ commands. CALCulate commands return limit check
 		results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:SRS:PDYNamics:AVERage?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:SRS:PDYNamics:CURRent?', self.__class__.ResultData())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Out_Of_Tolerance: int: Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for power dynamics measurements exceeding the specified power dynamics limits.
-			- Off_Power_Before: float: OFF power mean value for time period before SRS symbol
-			- On_Power_Rms_1: float: ON power mean value over the first SRS symbol
-			- On_Power_Peak_1: float: ON power peak value for the first SRS symbol
-			- On_Power_Rms_2: float: ON power mean value over the second SRS symbol (NCAP returned for FDD)
-			- On_Power_Peak_2: float: ON power peak value for the second SRS symbol (NCAP returned for FDD)
-			- Off_Power_After: float: OFF power mean value for subframe after SRS symbol"""
+			- Reliability: int: 'Reliability indicator'
+			- Out_Of_Tolerance: int: Out of tolerance result, i.e. the percentage of measurement intervals of the statistic count for power dynamics measurements exceeding the specified power dynamics limits.
+			- Off_Power_Before: float or bool: OFF power mean value for the time period before the SRS symbol.
+			- On_Power_Rms_1: float or bool: ON power mean value over the first SRS symbol.
+			- On_Power_Peak_1: float or bool: ON power peak value for the first SRS symbol.
+			- On_Power_Rms_2: float or bool: ON power mean value over the second SRS symbol (NCAP returned for FDD) .
+			- On_Power_Peak_2: float or bool: ON power peak value for the second SRS symbol (NCAP returned for FDD) .
+			- Off_Power_After: float or bool: OFF power mean value for the subframe after the SRS symbol."""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
-			ArgStruct.scalar_float('Off_Power_Before'),
-			ArgStruct.scalar_float('On_Power_Rms_1'),
-			ArgStruct.scalar_float('On_Power_Peak_1'),
-			ArgStruct.scalar_float('On_Power_Rms_2'),
-			ArgStruct.scalar_float('On_Power_Peak_2'),
-			ArgStruct.scalar_float('Off_Power_After')]
+			ArgStruct.scalar_float_ext('Off_Power_Before'),
+			ArgStruct.scalar_float_ext('On_Power_Rms_1'),
+			ArgStruct.scalar_float_ext('On_Power_Peak_1'),
+			ArgStruct.scalar_float_ext('On_Power_Rms_2'),
+			ArgStruct.scalar_float_ext('On_Power_Peak_2'),
+			ArgStruct.scalar_float_ext('Off_Power_After')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tolerance: int = None
-			self.Off_Power_Before: float = None
-			self.On_Power_Rms_1: float = None
-			self.On_Power_Peak_1: float = None
-			self.On_Power_Rms_2: float = None
-			self.On_Power_Peak_2: float = None
-			self.Off_Power_After: float = None
+			self.Off_Power_Before: float or bool = None
+			self.On_Power_Rms_1: float or bool = None
+			self.On_Power_Peak_1: float or bool = None
+			self.On_Power_Rms_2: float or bool = None
+			self.On_Power_Peak_2: float or bool = None
+			self.Off_Power_After: float or bool = None
 
 	def calculate(self) -> CalculateStruct:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:SRS:PDYNamics:AVERage \n
-		Snippet: value: CalculateStruct = driver.srs.pdynamics.average.calculate() \n
-		Return the current, average, minimum, maximum and standard deviation single value results of the power dynamics
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:SRS:PDYNamics:CURRent \n
+		Snippet: value: CalculateStruct = driver.lteMeas.srs.pdynamics.current.calculate() \n
+		Return the current, average, minimum, maximum and standard deviation single-value results of the power dynamics
 		measurement. The values described below are returned by FETCh and READ commands. CALCulate commands return limit check
 		results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:SRS:PDYNamics:AVERage?', self.__class__.CalculateStruct())
+		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:SRS:PDYNamics:CURRent?', self.__class__.CalculateStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Srs_/Pdynamics_/Current.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/Srs/Pdynamics/Average.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,32 +1,32 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
-from ....Internal.StructBase import StructBase
-from ....Internal.ArgStruct import ArgStruct
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
+from .....Internal.StructBase import StructBase
+from .....Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class AverageCls:
+	"""Average commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Out_Of_Tolerance: int: Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for power dynamics measurements exceeding the specified power dynamics limits.
-			- Off_Power_Before: float: OFF power mean value for time period before SRS symbol
-			- On_Power_Rms_1: float: ON power mean value over the first SRS symbol
-			- On_Power_Peak_1: float: ON power peak value for the first SRS symbol
-			- On_Power_Rms_2: float: ON power mean value over the second SRS symbol (NCAP returned for FDD)
-			- On_Power_Peak_2: float: ON power peak value for the second SRS symbol (NCAP returned for FDD)
-			- Off_Power_After: float: OFF power mean value for subframe after SRS symbol"""
+			- Reliability: int: 'Reliability indicator'
+			- Out_Of_Tolerance: int: Out of tolerance result, i.e. the percentage of measurement intervals of the statistic count for power dynamics measurements exceeding the specified power dynamics limits.
+			- Off_Power_Before: float: OFF power mean value for the time period before the SRS symbol.
+			- On_Power_Rms_1: float: ON power mean value over the first SRS symbol.
+			- On_Power_Peak_1: float: ON power peak value for the first SRS symbol.
+			- On_Power_Rms_2: float: ON power mean value over the second SRS symbol (NCAP returned for FDD) .
+			- On_Power_Peak_2: float: ON power peak value for the second SRS symbol (NCAP returned for FDD) .
+			- Off_Power_After: float: OFF power mean value for the subframe after the SRS symbol."""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
 			ArgStruct.scalar_float('Off_Power_Before'),
 			ArgStruct.scalar_float('On_Power_Rms_1'),
 			ArgStruct.scalar_float('On_Power_Peak_1'),
 			ArgStruct.scalar_float('On_Power_Rms_2'),
@@ -41,64 +41,64 @@
 			self.On_Power_Rms_1: float = None
 			self.On_Power_Peak_1: float = None
 			self.On_Power_Rms_2: float = None
 			self.On_Power_Peak_2: float = None
 			self.Off_Power_After: float = None
 
 	def read(self) -> ResultData:
-		"""SCPI: READ:LTE:MEASurement<Instance>:SRS:PDYNamics:CURRent \n
-		Snippet: value: ResultData = driver.srs.pdynamics.current.read() \n
-		Return the current, average, minimum, maximum and standard deviation single value results of the power dynamics
+		"""SCPI: READ:LTE:MEASurement<Instance>:SRS:PDYNamics:AVERage \n
+		Snippet: value: ResultData = driver.lteMeas.srs.pdynamics.average.read() \n
+		Return the current, average, minimum, maximum and standard deviation single-value results of the power dynamics
 		measurement. The values described below are returned by FETCh and READ commands. CALCulate commands return limit check
 		results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:SRS:PDYNamics:CURRent?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:SRS:PDYNamics:AVERage?', self.__class__.ResultData())
 
 	def fetch(self) -> ResultData:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:SRS:PDYNamics:CURRent \n
-		Snippet: value: ResultData = driver.srs.pdynamics.current.fetch() \n
-		Return the current, average, minimum, maximum and standard deviation single value results of the power dynamics
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:SRS:PDYNamics:AVERage \n
+		Snippet: value: ResultData = driver.lteMeas.srs.pdynamics.average.fetch() \n
+		Return the current, average, minimum, maximum and standard deviation single-value results of the power dynamics
 		measurement. The values described below are returned by FETCh and READ commands. CALCulate commands return limit check
 		results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:SRS:PDYNamics:CURRent?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:SRS:PDYNamics:AVERage?', self.__class__.ResultData())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Out_Of_Tolerance: int: Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for power dynamics measurements exceeding the specified power dynamics limits.
-			- Off_Power_Before: float: OFF power mean value for time period before SRS symbol
-			- On_Power_Rms_1: float: ON power mean value over the first SRS symbol
-			- On_Power_Peak_1: float: ON power peak value for the first SRS symbol
-			- On_Power_Rms_2: float: ON power mean value over the second SRS symbol (NCAP returned for FDD)
-			- On_Power_Peak_2: float: ON power peak value for the second SRS symbol (NCAP returned for FDD)
-			- Off_Power_After: float: OFF power mean value for subframe after SRS symbol"""
+			- Reliability: int: 'Reliability indicator'
+			- Out_Of_Tolerance: int: Out of tolerance result, i.e. the percentage of measurement intervals of the statistic count for power dynamics measurements exceeding the specified power dynamics limits.
+			- Off_Power_Before: float or bool: OFF power mean value for the time period before the SRS symbol.
+			- On_Power_Rms_1: float or bool: ON power mean value over the first SRS symbol.
+			- On_Power_Peak_1: float or bool: ON power peak value for the first SRS symbol.
+			- On_Power_Rms_2: float or bool: ON power mean value over the second SRS symbol (NCAP returned for FDD) .
+			- On_Power_Peak_2: float or bool: ON power peak value for the second SRS symbol (NCAP returned for FDD) .
+			- Off_Power_After: float or bool: OFF power mean value for the subframe after the SRS symbol."""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
-			ArgStruct.scalar_float('Off_Power_Before'),
-			ArgStruct.scalar_float('On_Power_Rms_1'),
-			ArgStruct.scalar_float('On_Power_Peak_1'),
-			ArgStruct.scalar_float('On_Power_Rms_2'),
-			ArgStruct.scalar_float('On_Power_Peak_2'),
-			ArgStruct.scalar_float('Off_Power_After')]
+			ArgStruct.scalar_float_ext('Off_Power_Before'),
+			ArgStruct.scalar_float_ext('On_Power_Rms_1'),
+			ArgStruct.scalar_float_ext('On_Power_Peak_1'),
+			ArgStruct.scalar_float_ext('On_Power_Rms_2'),
+			ArgStruct.scalar_float_ext('On_Power_Peak_2'),
+			ArgStruct.scalar_float_ext('Off_Power_After')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tolerance: int = None
-			self.Off_Power_Before: float = None
-			self.On_Power_Rms_1: float = None
-			self.On_Power_Peak_1: float = None
-			self.On_Power_Rms_2: float = None
-			self.On_Power_Peak_2: float = None
-			self.Off_Power_After: float = None
+			self.Off_Power_Before: float or bool = None
+			self.On_Power_Rms_1: float or bool = None
+			self.On_Power_Peak_1: float or bool = None
+			self.On_Power_Rms_2: float or bool = None
+			self.On_Power_Peak_2: float or bool = None
+			self.Off_Power_After: float or bool = None
 
 	def calculate(self) -> CalculateStruct:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:SRS:PDYNamics:CURRent \n
-		Snippet: value: CalculateStruct = driver.srs.pdynamics.current.calculate() \n
-		Return the current, average, minimum, maximum and standard deviation single value results of the power dynamics
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:SRS:PDYNamics:AVERage \n
+		Snippet: value: CalculateStruct = driver.lteMeas.srs.pdynamics.average.calculate() \n
+		Return the current, average, minimum, maximum and standard deviation single-value results of the power dynamics
 		measurement. The values described below are returned by FETCh and READ commands. CALCulate commands return limit check
 		results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:SRS:PDYNamics:CURRent?', self.__class__.CalculateStruct())
+		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:SRS:PDYNamics:AVERage?', self.__class__.CalculateStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Srs_/Pdynamics_/Maximum.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/Srs/Pdynamics/Minimum.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,32 +1,32 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
-from ....Internal.StructBase import StructBase
-from ....Internal.ArgStruct import ArgStruct
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
+from .....Internal.StructBase import StructBase
+from .....Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Maximum:
-	"""Maximum commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class MinimumCls:
+	"""Minimum commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("maximum", core, parent)
+		self._cmd_group = CommandsGroup("minimum", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Out_Of_Tolerance: int: Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for power dynamics measurements exceeding the specified power dynamics limits.
-			- Off_Power_Before: float: OFF power mean value for time period before SRS symbol
-			- On_Power_Rms_1: float: ON power mean value over the first SRS symbol
-			- On_Power_Peak_1: float: ON power peak value for the first SRS symbol
-			- On_Power_Rms_2: float: ON power mean value over the second SRS symbol (NCAP returned for FDD)
-			- On_Power_Peak_2: float: ON power peak value for the second SRS symbol (NCAP returned for FDD)
-			- Off_Power_After: float: OFF power mean value for subframe after SRS symbol"""
+			- Reliability: int: 'Reliability indicator'
+			- Out_Of_Tolerance: int: Out of tolerance result, i.e. the percentage of measurement intervals of the statistic count for power dynamics measurements exceeding the specified power dynamics limits.
+			- Off_Power_Before: float: OFF power mean value for the time period before the SRS symbol.
+			- On_Power_Rms_1: float: ON power mean value over the first SRS symbol.
+			- On_Power_Peak_1: float: ON power peak value for the first SRS symbol.
+			- On_Power_Rms_2: float: ON power mean value over the second SRS symbol (NCAP returned for FDD) .
+			- On_Power_Peak_2: float: ON power peak value for the second SRS symbol (NCAP returned for FDD) .
+			- Off_Power_After: float: OFF power mean value for the subframe after the SRS symbol."""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
 			ArgStruct.scalar_float('Off_Power_Before'),
 			ArgStruct.scalar_float('On_Power_Rms_1'),
 			ArgStruct.scalar_float('On_Power_Peak_1'),
 			ArgStruct.scalar_float('On_Power_Rms_2'),
@@ -41,64 +41,64 @@
 			self.On_Power_Rms_1: float = None
 			self.On_Power_Peak_1: float = None
 			self.On_Power_Rms_2: float = None
 			self.On_Power_Peak_2: float = None
 			self.Off_Power_After: float = None
 
 	def read(self) -> ResultData:
-		"""SCPI: READ:LTE:MEASurement<Instance>:SRS:PDYNamics:MAXimum \n
-		Snippet: value: ResultData = driver.srs.pdynamics.maximum.read() \n
-		Return the current, average, minimum, maximum and standard deviation single value results of the power dynamics
+		"""SCPI: READ:LTE:MEASurement<Instance>:SRS:PDYNamics:MINimum \n
+		Snippet: value: ResultData = driver.lteMeas.srs.pdynamics.minimum.read() \n
+		Return the current, average, minimum, maximum and standard deviation single-value results of the power dynamics
 		measurement. The values described below are returned by FETCh and READ commands. CALCulate commands return limit check
 		results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:SRS:PDYNamics:MAXimum?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:SRS:PDYNamics:MINimum?', self.__class__.ResultData())
 
 	def fetch(self) -> ResultData:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:SRS:PDYNamics:MAXimum \n
-		Snippet: value: ResultData = driver.srs.pdynamics.maximum.fetch() \n
-		Return the current, average, minimum, maximum and standard deviation single value results of the power dynamics
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:SRS:PDYNamics:MINimum \n
+		Snippet: value: ResultData = driver.lteMeas.srs.pdynamics.minimum.fetch() \n
+		Return the current, average, minimum, maximum and standard deviation single-value results of the power dynamics
 		measurement. The values described below are returned by FETCh and READ commands. CALCulate commands return limit check
 		results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:SRS:PDYNamics:MAXimum?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:SRS:PDYNamics:MINimum?', self.__class__.ResultData())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Out_Of_Tolerance: int: Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for power dynamics measurements exceeding the specified power dynamics limits.
-			- Off_Power_Before: float: OFF power mean value for time period before SRS symbol
-			- On_Power_Rms_1: float: ON power mean value over the first SRS symbol
-			- On_Power_Peak_1: float: ON power peak value for the first SRS symbol
-			- On_Power_Rms_2: float: ON power mean value over the second SRS symbol (NCAP returned for FDD)
-			- On_Power_Peak_2: float: ON power peak value for the second SRS symbol (NCAP returned for FDD)
-			- Off_Power_After: float: OFF power mean value for subframe after SRS symbol"""
+			- Reliability: int: 'Reliability indicator'
+			- Out_Of_Tolerance: int: Out of tolerance result, i.e. the percentage of measurement intervals of the statistic count for power dynamics measurements exceeding the specified power dynamics limits.
+			- Off_Power_Before: float or bool: OFF power mean value for the time period before the SRS symbol.
+			- On_Power_Rms_1: float or bool: ON power mean value over the first SRS symbol.
+			- On_Power_Peak_1: float or bool: ON power peak value for the first SRS symbol.
+			- On_Power_Rms_2: float or bool: ON power mean value over the second SRS symbol (NCAP returned for FDD) .
+			- On_Power_Peak_2: float or bool: ON power peak value for the second SRS symbol (NCAP returned for FDD) .
+			- Off_Power_After: float or bool: OFF power mean value for the subframe after the SRS symbol."""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
-			ArgStruct.scalar_float('Off_Power_Before'),
-			ArgStruct.scalar_float('On_Power_Rms_1'),
-			ArgStruct.scalar_float('On_Power_Peak_1'),
-			ArgStruct.scalar_float('On_Power_Rms_2'),
-			ArgStruct.scalar_float('On_Power_Peak_2'),
-			ArgStruct.scalar_float('Off_Power_After')]
+			ArgStruct.scalar_float_ext('Off_Power_Before'),
+			ArgStruct.scalar_float_ext('On_Power_Rms_1'),
+			ArgStruct.scalar_float_ext('On_Power_Peak_1'),
+			ArgStruct.scalar_float_ext('On_Power_Rms_2'),
+			ArgStruct.scalar_float_ext('On_Power_Peak_2'),
+			ArgStruct.scalar_float_ext('Off_Power_After')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tolerance: int = None
-			self.Off_Power_Before: float = None
-			self.On_Power_Rms_1: float = None
-			self.On_Power_Peak_1: float = None
-			self.On_Power_Rms_2: float = None
-			self.On_Power_Peak_2: float = None
-			self.Off_Power_After: float = None
+			self.Off_Power_Before: float or bool = None
+			self.On_Power_Rms_1: float or bool = None
+			self.On_Power_Peak_1: float or bool = None
+			self.On_Power_Rms_2: float or bool = None
+			self.On_Power_Peak_2: float or bool = None
+			self.Off_Power_After: float or bool = None
 
 	def calculate(self) -> CalculateStruct:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:SRS:PDYNamics:MAXimum \n
-		Snippet: value: CalculateStruct = driver.srs.pdynamics.maximum.calculate() \n
-		Return the current, average, minimum, maximum and standard deviation single value results of the power dynamics
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:SRS:PDYNamics:MINimum \n
+		Snippet: value: CalculateStruct = driver.lteMeas.srs.pdynamics.minimum.calculate() \n
+		Return the current, average, minimum, maximum and standard deviation single-value results of the power dynamics
 		measurement. The values described below are returned by FETCh and READ commands. CALCulate commands return limit check
 		results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:SRS:PDYNamics:MAXimum?', self.__class__.CalculateStruct())
+		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:SRS:PDYNamics:MINimum?', self.__class__.CalculateStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Srs_/Pdynamics_/Minimum.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/Srs/Pdynamics/Maximum.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,32 +1,32 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
-from ....Internal.StructBase import StructBase
-from ....Internal.ArgStruct import ArgStruct
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
+from .....Internal.StructBase import StructBase
+from .....Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Minimum:
-	"""Minimum commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class MaximumCls:
+	"""Maximum commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("minimum", core, parent)
+		self._cmd_group = CommandsGroup("maximum", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Out_Of_Tolerance: int: Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for power dynamics measurements exceeding the specified power dynamics limits.
-			- Off_Power_Before: float: OFF power mean value for time period before SRS symbol
-			- On_Power_Rms_1: float: ON power mean value over the first SRS symbol
-			- On_Power_Peak_1: float: ON power peak value for the first SRS symbol
-			- On_Power_Rms_2: float: ON power mean value over the second SRS symbol (NCAP returned for FDD)
-			- On_Power_Peak_2: float: ON power peak value for the second SRS symbol (NCAP returned for FDD)
-			- Off_Power_After: float: OFF power mean value for subframe after SRS symbol"""
+			- Reliability: int: 'Reliability indicator'
+			- Out_Of_Tolerance: int: Out of tolerance result, i.e. the percentage of measurement intervals of the statistic count for power dynamics measurements exceeding the specified power dynamics limits.
+			- Off_Power_Before: float: OFF power mean value for the time period before the SRS symbol.
+			- On_Power_Rms_1: float: ON power mean value over the first SRS symbol.
+			- On_Power_Peak_1: float: ON power peak value for the first SRS symbol.
+			- On_Power_Rms_2: float: ON power mean value over the second SRS symbol (NCAP returned for FDD) .
+			- On_Power_Peak_2: float: ON power peak value for the second SRS symbol (NCAP returned for FDD) .
+			- Off_Power_After: float: OFF power mean value for the subframe after the SRS symbol."""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
 			ArgStruct.scalar_float('Off_Power_Before'),
 			ArgStruct.scalar_float('On_Power_Rms_1'),
 			ArgStruct.scalar_float('On_Power_Peak_1'),
 			ArgStruct.scalar_float('On_Power_Rms_2'),
@@ -41,64 +41,64 @@
 			self.On_Power_Rms_1: float = None
 			self.On_Power_Peak_1: float = None
 			self.On_Power_Rms_2: float = None
 			self.On_Power_Peak_2: float = None
 			self.Off_Power_After: float = None
 
 	def read(self) -> ResultData:
-		"""SCPI: READ:LTE:MEASurement<Instance>:SRS:PDYNamics:MINimum \n
-		Snippet: value: ResultData = driver.srs.pdynamics.minimum.read() \n
-		Return the current, average, minimum, maximum and standard deviation single value results of the power dynamics
+		"""SCPI: READ:LTE:MEASurement<Instance>:SRS:PDYNamics:MAXimum \n
+		Snippet: value: ResultData = driver.lteMeas.srs.pdynamics.maximum.read() \n
+		Return the current, average, minimum, maximum and standard deviation single-value results of the power dynamics
 		measurement. The values described below are returned by FETCh and READ commands. CALCulate commands return limit check
 		results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:SRS:PDYNamics:MINimum?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'READ:LTE:MEASurement<Instance>:SRS:PDYNamics:MAXimum?', self.__class__.ResultData())
 
 	def fetch(self) -> ResultData:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:SRS:PDYNamics:MINimum \n
-		Snippet: value: ResultData = driver.srs.pdynamics.minimum.fetch() \n
-		Return the current, average, minimum, maximum and standard deviation single value results of the power dynamics
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:SRS:PDYNamics:MAXimum \n
+		Snippet: value: ResultData = driver.lteMeas.srs.pdynamics.maximum.fetch() \n
+		Return the current, average, minimum, maximum and standard deviation single-value results of the power dynamics
 		measurement. The values described below are returned by FETCh and READ commands. CALCulate commands return limit check
 		results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:SRS:PDYNamics:MINimum?', self.__class__.ResultData())
+		return self._core.io.query_struct(f'FETCh:LTE:MEASurement<Instance>:SRS:PDYNamics:MAXimum?', self.__class__.ResultData())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: 'Reliability Indicator'
-			- Out_Of_Tolerance: int: Out of tolerance result, i.e. percentage of measurement intervals of the statistic count for power dynamics measurements exceeding the specified power dynamics limits.
-			- Off_Power_Before: float: OFF power mean value for time period before SRS symbol
-			- On_Power_Rms_1: float: ON power mean value over the first SRS symbol
-			- On_Power_Peak_1: float: ON power peak value for the first SRS symbol
-			- On_Power_Rms_2: float: ON power mean value over the second SRS symbol (NCAP returned for FDD)
-			- On_Power_Peak_2: float: ON power peak value for the second SRS symbol (NCAP returned for FDD)
-			- Off_Power_After: float: OFF power mean value for subframe after SRS symbol"""
+			- Reliability: int: 'Reliability indicator'
+			- Out_Of_Tolerance: int: Out of tolerance result, i.e. the percentage of measurement intervals of the statistic count for power dynamics measurements exceeding the specified power dynamics limits.
+			- Off_Power_Before: float or bool: OFF power mean value for the time period before the SRS symbol.
+			- On_Power_Rms_1: float or bool: ON power mean value over the first SRS symbol.
+			- On_Power_Peak_1: float or bool: ON power peak value for the first SRS symbol.
+			- On_Power_Rms_2: float or bool: ON power mean value over the second SRS symbol (NCAP returned for FDD) .
+			- On_Power_Peak_2: float or bool: ON power peak value for the second SRS symbol (NCAP returned for FDD) .
+			- Off_Power_After: float or bool: OFF power mean value for the subframe after the SRS symbol."""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_int('Out_Of_Tolerance'),
-			ArgStruct.scalar_float('Off_Power_Before'),
-			ArgStruct.scalar_float('On_Power_Rms_1'),
-			ArgStruct.scalar_float('On_Power_Peak_1'),
-			ArgStruct.scalar_float('On_Power_Rms_2'),
-			ArgStruct.scalar_float('On_Power_Peak_2'),
-			ArgStruct.scalar_float('Off_Power_After')]
+			ArgStruct.scalar_float_ext('Off_Power_Before'),
+			ArgStruct.scalar_float_ext('On_Power_Rms_1'),
+			ArgStruct.scalar_float_ext('On_Power_Peak_1'),
+			ArgStruct.scalar_float_ext('On_Power_Rms_2'),
+			ArgStruct.scalar_float_ext('On_Power_Peak_2'),
+			ArgStruct.scalar_float_ext('Off_Power_After')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Out_Of_Tolerance: int = None
-			self.Off_Power_Before: float = None
-			self.On_Power_Rms_1: float = None
-			self.On_Power_Peak_1: float = None
-			self.On_Power_Rms_2: float = None
-			self.On_Power_Peak_2: float = None
-			self.Off_Power_After: float = None
+			self.Off_Power_Before: float or bool = None
+			self.On_Power_Rms_1: float or bool = None
+			self.On_Power_Peak_1: float or bool = None
+			self.On_Power_Rms_2: float or bool = None
+			self.On_Power_Peak_2: float or bool = None
+			self.Off_Power_After: float or bool = None
 
 	def calculate(self) -> CalculateStruct:
-		"""SCPI: CALCulate:LTE:MEASurement<Instance>:SRS:PDYNamics:MINimum \n
-		Snippet: value: CalculateStruct = driver.srs.pdynamics.minimum.calculate() \n
-		Return the current, average, minimum, maximum and standard deviation single value results of the power dynamics
+		"""SCPI: CALCulate:LTE:MEASurement<Instance>:SRS:PDYNamics:MAXimum \n
+		Snippet: value: CalculateStruct = driver.lteMeas.srs.pdynamics.maximum.calculate() \n
+		Return the current, average, minimum, maximum and standard deviation single-value results of the power dynamics
 		measurement. The values described below are returned by FETCh and READ commands. CALCulate commands return limit check
 		results instead, one value for each result listed below. \n
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:SRS:PDYNamics:MINimum?', self.__class__.CalculateStruct())
+		return self._core.io.query_struct(f'CALCulate:LTE:MEASurement<Instance>:SRS:PDYNamics:MAXimum?', self.__class__.CalculateStruct())
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Srs_/Trace_/Pdynamics.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/MultiEval/ListPy/SeMask/Margin/Area/Negativ/__init__.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,43 +1,43 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
+from .........Internal.Core import Core
+from .........Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Pdynamics:
-	"""Pdynamics commands group definition. 6 total commands, 3 Sub-groups, 0 group commands"""
+class NegativCls:
+	"""Negativ commands group definition. 3 total commands, 3 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("pdynamics", core, parent)
+		self._cmd_group = CommandsGroup("negativ", core, parent)
 
 	@property
 	def current(self):
-		"""current commands group. 0 Sub-classes, 2 commands."""
+		"""current commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_current'):
-			from .Pdynamics_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
 	@property
 	def average(self):
-		"""average commands group. 0 Sub-classes, 2 commands."""
+		"""average commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_average'):
-			from .Pdynamics_.Average import Average
-			self._average = Average(self._core, self._base)
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
 		return self._average
 
 	@property
-	def maximum(self):
-		"""maximum commands group. 0 Sub-classes, 2 commands."""
-		if not hasattr(self, '_maximum'):
-			from .Pdynamics_.Maximum import Maximum
-			self._maximum = Maximum(self._core, self._base)
-		return self._maximum
+	def minimum(self):
+		"""minimum commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_minimum'):
+			from .Minimum import MinimumCls
+			self._minimum = MinimumCls(self._core, self._cmd_group)
+		return self._minimum
 
-	def clone(self) -> 'Pdynamics':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'NegativCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Pdynamics(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = NegativCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Srs_/Trace_/Pdynamics_/Average.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/Srs/Trace/Pdynamics/Current.py`

 * *Files 11% similar despite different names*

```diff
@@ -1,39 +1,39 @@
 from typing import List
 
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
-from .....Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from .....Internal.Types import DataType
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from ......Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	def read(self) -> List[float]:
-		"""SCPI: READ:LTE:MEASurement<Instance>:SRS:TRACe:PDYNamics:AVERage \n
-		Snippet: value: List[float] = driver.srs.trace.pdynamics.average.read() \n
+		"""SCPI: READ:LTE:MEASurement<Instance>:SRS:TRACe:PDYNamics:CURRent \n
+		Snippet: value: List[float] = driver.lteMeas.srs.trace.pdynamics.current.read() \n
 		Return the values of the power dynamics traces. Each value is sampled with 48 Ts, corresponding to 1.5625 s. The results
 		of the current, average and maximum traces can be retrieved. Note that the GUI shows only the beginning of the trace
-		returned via remote command. The last 800 s cannot be displayed at the GUI. See also 'Measurement Results'. \n
+		returned via a remote command. The last 800 s cannot be displayed at the GUI. See also 'Measurement results'. \n
 		Suppressed linked return values: reliability \n
 			:return: power: 2048 power values, from -1100 s to +2098.4375 s relative to the start of the SRS symbol. The values have a spacing of 1.5625 s. The 705th value is at the start of the SRS symbol (0 s) ."""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:LTE:MEASurement<Instance>:SRS:TRACe:PDYNamics:AVERage?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:LTE:MEASurement<Instance>:SRS:TRACe:PDYNamics:CURRent?', suppressed)
 		return response
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:SRS:TRACe:PDYNamics:AVERage \n
-		Snippet: value: List[float] = driver.srs.trace.pdynamics.average.fetch() \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:SRS:TRACe:PDYNamics:CURRent \n
+		Snippet: value: List[float] = driver.lteMeas.srs.trace.pdynamics.current.fetch() \n
 		Return the values of the power dynamics traces. Each value is sampled with 48 Ts, corresponding to 1.5625 s. The results
 		of the current, average and maximum traces can be retrieved. Note that the GUI shows only the beginning of the trace
-		returned via remote command. The last 800 s cannot be displayed at the GUI. See also 'Measurement Results'. \n
+		returned via a remote command. The last 800 s cannot be displayed at the GUI. See also 'Measurement results'. \n
 		Suppressed linked return values: reliability \n
 			:return: power: 2048 power values, from -1100 s to +2098.4375 s relative to the start of the SRS symbol. The values have a spacing of 1.5625 s. The 705th value is at the start of the SRS symbol (0 s) ."""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:SRS:TRACe:PDYNamics:AVERage?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:SRS:TRACe:PDYNamics:CURRent?', suppressed)
 		return response
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Srs_/Trace_/Pdynamics_/Current.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/LteMeas/Srs/Trace/Pdynamics/Average.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,39 +1,39 @@
 from typing import List
 
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
-from .....Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from .....Internal.Types import DataType
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from ......Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class AverageCls:
+	"""Average commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	def read(self) -> List[float]:
-		"""SCPI: READ:LTE:MEASurement<Instance>:SRS:TRACe:PDYNamics:CURRent \n
-		Snippet: value: List[float] = driver.srs.trace.pdynamics.current.read() \n
+		"""SCPI: READ:LTE:MEASurement<Instance>:SRS:TRACe:PDYNamics:AVERage \n
+		Snippet: value: List[float] = driver.lteMeas.srs.trace.pdynamics.average.read() \n
 		Return the values of the power dynamics traces. Each value is sampled with 48 Ts, corresponding to 1.5625 s. The results
 		of the current, average and maximum traces can be retrieved. Note that the GUI shows only the beginning of the trace
-		returned via remote command. The last 800 s cannot be displayed at the GUI. See also 'Measurement Results'. \n
+		returned via a remote command. The last 800 s cannot be displayed at the GUI. See also 'Measurement results'. \n
 		Suppressed linked return values: reliability \n
 			:return: power: 2048 power values, from -1100 s to +2098.4375 s relative to the start of the SRS symbol. The values have a spacing of 1.5625 s. The 705th value is at the start of the SRS symbol (0 s) ."""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:LTE:MEASurement<Instance>:SRS:TRACe:PDYNamics:CURRent?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:LTE:MEASurement<Instance>:SRS:TRACe:PDYNamics:AVERage?', suppressed)
 		return response
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:LTE:MEASurement<Instance>:SRS:TRACe:PDYNamics:CURRent \n
-		Snippet: value: List[float] = driver.srs.trace.pdynamics.current.fetch() \n
+		"""SCPI: FETCh:LTE:MEASurement<Instance>:SRS:TRACe:PDYNamics:AVERage \n
+		Snippet: value: List[float] = driver.lteMeas.srs.trace.pdynamics.average.fetch() \n
 		Return the values of the power dynamics traces. Each value is sampled with 48 Ts, corresponding to 1.5625 s. The results
 		of the current, average and maximum traces can be retrieved. Note that the GUI shows only the beginning of the trace
-		returned via remote command. The last 800 s cannot be displayed at the GUI. See also 'Measurement Results'. \n
+		returned via a remote command. The last 800 s cannot be displayed at the GUI. See also 'Measurement results'. \n
 		Suppressed linked return values: reliability \n
 			:return: power: 2048 power values, from -1100 s to +2098.4375 s relative to the start of the SRS symbol. The values have a spacing of 1.5625 s. The 705th value is at the start of the SRS symbol (0 s) ."""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:SRS:TRACe:PDYNamics:CURRent?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:LTE:MEASurement<Instance>:SRS:TRACe:PDYNamics:AVERage?', suppressed)
 		return response
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Trigger.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Trigger/LteMeas/__init__.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,43 +1,43 @@
-from ..Internal.Core import Core
-from ..Internal.CommandsGroup import CommandsGroup
+from ....Internal.Core import Core
+from ....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Trigger:
-	"""Trigger commands group definition. 22 total commands, 3 Sub-groups, 0 group commands"""
+class LteMeasCls:
+	"""LteMeas commands group definition. 17 total commands, 3 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("trigger", core, parent)
+		self._cmd_group = CommandsGroup("lteMeas", core, parent)
 
 	@property
 	def multiEval(self):
-		"""multiEval commands group. 2 Sub-classes, 8 commands."""
+		"""multiEval commands group. 1 Sub-classes, 7 commands."""
 		if not hasattr(self, '_multiEval'):
-			from .Trigger_.MultiEval import MultiEval
-			self._multiEval = MultiEval(self._core, self._base)
+			from .MultiEval import MultiEvalCls
+			self._multiEval = MultiEvalCls(self._core, self._cmd_group)
 		return self._multiEval
 
 	@property
 	def prach(self):
-		"""prach commands group. 1 Sub-classes, 5 commands."""
+		"""prach commands group. 0 Sub-classes, 4 commands."""
 		if not hasattr(self, '_prach'):
-			from .Trigger_.Prach import Prach
-			self._prach = Prach(self._core, self._base)
+			from .Prach import PrachCls
+			self._prach = PrachCls(self._core, self._cmd_group)
 		return self._prach
 
 	@property
 	def srs(self):
-		"""srs commands group. 1 Sub-classes, 5 commands."""
+		"""srs commands group. 0 Sub-classes, 4 commands."""
 		if not hasattr(self, '_srs'):
-			from .Trigger_.Srs import Srs
-			self._srs = Srs(self._core, self._base)
+			from .Srs import SrsCls
+			self._srs = SrsCls(self._core, self._cmd_group)
 		return self._srs
 
-	def clone(self) -> 'Trigger':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'LteMeasCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Trigger(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = LteMeasCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Trigger_/MultiEval.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Trigger/LteMeas/MultiEval/__init__.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,203 +1,168 @@
-from ...Internal.Core import Core
-from ...Internal.CommandsGroup import CommandsGroup
-from ...Internal import Conversions
-from ...Internal.Utilities import trim_str_response
-from ... import enums
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
+from .....Internal import Conversions
+from ..... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class MultiEval:
-	"""MultiEval commands group definition. 10 total commands, 2 Sub-groups, 8 group commands"""
+class MultiEvalCls:
+	"""MultiEval commands group definition. 9 total commands, 1 Subgroups, 7 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("multiEval", core, parent)
-
-	@property
-	def catalog(self):
-		"""catalog commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_catalog'):
-			from .MultiEval_.Catalog import Catalog
-			self._catalog = Catalog(self._core, self._base)
-		return self._catalog
+		self._cmd_group = CommandsGroup("multiEval", core, parent)
 
 	@property
 	def listPy(self):
-		"""listPy commands group. 0 Sub-classes, 1 commands."""
+		"""listPy commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_listPy'):
-			from .MultiEval_.ListPy import ListPy
-			self._listPy = ListPy(self._core, self._base)
+			from .ListPy import ListPyCls
+			self._listPy = ListPyCls(self._core, self._cmd_group)
 		return self._listPy
 
-	def get_source(self) -> str:
-		"""SCPI: TRIGger:LTE:MEASurement<Instance>:MEValuation:SOURce \n
-		Snippet: value: str = driver.trigger.multiEval.get_source() \n
-		Selects the source of the trigger events. Some values are always available. They are listed below. Depending on the
-		installed options, additional values are available. You can query a list of all supported values via TRIGger:...
-		:CATalog:SOURce?. \n
-			:return: source:
-				- 'Free Run (Fast Sync) ': Free run with synchronization
-				- 'Free Run (No Sync) ': Free run without synchronization
-				- 'IF Power': Power trigger (received RF power) """
-		response = self._core.io.query_str('TRIGger:LTE:MEASurement<Instance>:MEValuation:SOURce?')
-		return trim_str_response(response)
-
-	def set_source(self, source: str) -> None:
-		"""SCPI: TRIGger:LTE:MEASurement<Instance>:MEValuation:SOURce \n
-		Snippet: driver.trigger.multiEval.set_source(source = '1') \n
-		Selects the source of the trigger events. Some values are always available. They are listed below. Depending on the
-		installed options, additional values are available. You can query a list of all supported values via TRIGger:...
-		:CATalog:SOURce?. \n
-			:param source:
-				- 'Free Run (Fast Sync) ': Free run with synchronization
-				- 'Free Run (No Sync) ': Free run without synchronization
-				- 'IF Power': Power trigger (received RF power) """
-		param = Conversions.value_to_quoted_str(source)
-		self._core.io.write(f'TRIGger:LTE:MEASurement<Instance>:MEValuation:SOURce {param}')
-
 	def get_threshold(self) -> float or bool:
 		"""SCPI: TRIGger:LTE:MEASurement<Instance>:MEValuation:THReshold \n
-		Snippet: value: float or bool = driver.trigger.multiEval.get_threshold() \n
+		Snippet: value: float or bool = driver.trigger.lteMeas.multiEval.get_threshold() \n
 		Defines the trigger threshold for power trigger sources. \n
-			:return: trig_threshold: No help available
+			:return: trig_threshold: (float or boolean) No help available
 		"""
 		response = self._core.io.query_str('TRIGger:LTE:MEASurement<Instance>:MEValuation:THReshold?')
 		return Conversions.str_to_float_or_bool(response)
 
 	def set_threshold(self, trig_threshold: float or bool) -> None:
 		"""SCPI: TRIGger:LTE:MEASurement<Instance>:MEValuation:THReshold \n
-		Snippet: driver.trigger.multiEval.set_threshold(trig_threshold = 1.0) \n
+		Snippet: driver.trigger.lteMeas.multiEval.set_threshold(trig_threshold = 1.0) \n
 		Defines the trigger threshold for power trigger sources. \n
-			:param trig_threshold: No help available
+			:param trig_threshold: (float or boolean) No help available
 		"""
 		param = Conversions.decimal_or_bool_value_to_str(trig_threshold)
 		self._core.io.write(f'TRIGger:LTE:MEASurement<Instance>:MEValuation:THReshold {param}')
 
 	# noinspection PyTypeChecker
 	def get_slope(self) -> enums.SignalSlope:
 		"""SCPI: TRIGger:LTE:MEASurement<Instance>:MEValuation:SLOPe \n
-		Snippet: value: enums.SignalSlope = driver.trigger.multiEval.get_slope() \n
+		Snippet: value: enums.SignalSlope = driver.trigger.lteMeas.multiEval.get_slope() \n
 		Qualifies whether the trigger event is generated at the rising or at the falling edge of the trigger pulse (valid for
 		external and power trigger sources) . \n
 			:return: slope: REDGe: Rising edge FEDGe: Falling edge
 		"""
 		response = self._core.io.query_str('TRIGger:LTE:MEASurement<Instance>:MEValuation:SLOPe?')
 		return Conversions.str_to_scalar_enum(response, enums.SignalSlope)
 
 	def set_slope(self, slope: enums.SignalSlope) -> None:
 		"""SCPI: TRIGger:LTE:MEASurement<Instance>:MEValuation:SLOPe \n
-		Snippet: driver.trigger.multiEval.set_slope(slope = enums.SignalSlope.FEDGe) \n
+		Snippet: driver.trigger.lteMeas.multiEval.set_slope(slope = enums.SignalSlope.FEDGe) \n
 		Qualifies whether the trigger event is generated at the rising or at the falling edge of the trigger pulse (valid for
 		external and power trigger sources) . \n
 			:param slope: REDGe: Rising edge FEDGe: Falling edge
 		"""
 		param = Conversions.enum_scalar_to_str(slope, enums.SignalSlope)
 		self._core.io.write(f'TRIGger:LTE:MEASurement<Instance>:MEValuation:SLOPe {param}')
 
 	def get_delay(self) -> float:
 		"""SCPI: TRIGger:LTE:MEASurement<Instance>:MEValuation:DELay \n
-		Snippet: value: float = driver.trigger.multiEval.get_delay() \n
+		Snippet: value: float = driver.trigger.lteMeas.multiEval.get_delay() \n
 		Defines a time delaying the start of the measurement relative to the trigger event. This setting has no influence on free
 		run measurements. \n
 			:return: delay: No help available
 		"""
 		response = self._core.io.query_str('TRIGger:LTE:MEASurement<Instance>:MEValuation:DELay?')
 		return Conversions.str_to_float(response)
 
 	def set_delay(self, delay: float) -> None:
 		"""SCPI: TRIGger:LTE:MEASurement<Instance>:MEValuation:DELay \n
-		Snippet: driver.trigger.multiEval.set_delay(delay = 1.0) \n
+		Snippet: driver.trigger.lteMeas.multiEval.set_delay(delay = 1.0) \n
 		Defines a time delaying the start of the measurement relative to the trigger event. This setting has no influence on free
 		run measurements. \n
 			:param delay: No help available
 		"""
 		param = Conversions.decimal_value_to_str(delay)
 		self._core.io.write(f'TRIGger:LTE:MEASurement<Instance>:MEValuation:DELay {param}')
 
 	def get_timeout(self) -> float or bool:
 		"""SCPI: TRIGger:LTE:MEASurement<Instance>:MEValuation:TOUT \n
-		Snippet: value: float or bool = driver.trigger.multiEval.get_timeout() \n
+		Snippet: value: float or bool = driver.trigger.lteMeas.multiEval.get_timeout() \n
 		Selects the maximum time that the measurement waits for a trigger event before it stops in remote control mode or
 		indicates a trigger timeout in manual operation mode. This setting has no influence on Free Run measurements. \n
-			:return: trigger_timeout: No help available
+			:return: trigger_timeout: (float or boolean) No help available
 		"""
 		response = self._core.io.query_str('TRIGger:LTE:MEASurement<Instance>:MEValuation:TOUT?')
 		return Conversions.str_to_float_or_bool(response)
 
 	def set_timeout(self, trigger_timeout: float or bool) -> None:
 		"""SCPI: TRIGger:LTE:MEASurement<Instance>:MEValuation:TOUT \n
-		Snippet: driver.trigger.multiEval.set_timeout(trigger_timeout = 1.0) \n
+		Snippet: driver.trigger.lteMeas.multiEval.set_timeout(trigger_timeout = 1.0) \n
 		Selects the maximum time that the measurement waits for a trigger event before it stops in remote control mode or
 		indicates a trigger timeout in manual operation mode. This setting has no influence on Free Run measurements. \n
-			:param trigger_timeout: No help available
+			:param trigger_timeout: (float or boolean) No help available
 		"""
 		param = Conversions.decimal_or_bool_value_to_str(trigger_timeout)
 		self._core.io.write(f'TRIGger:LTE:MEASurement<Instance>:MEValuation:TOUT {param}')
 
 	def get_mgap(self) -> int:
 		"""SCPI: TRIGger:LTE:MEASurement<Instance>:MEValuation:MGAP \n
-		Snippet: value: int = driver.trigger.multiEval.get_mgap() \n
+		Snippet: value: int = driver.trigger.lteMeas.multiEval.get_mgap() \n
 		Sets a minimum time during which the IF signal must be below the trigger threshold before the trigger is armed so that an
 		IF power trigger event can be generated. \n
 			:return: min_trig_gap: No help available
 		"""
 		response = self._core.io.query_str('TRIGger:LTE:MEASurement<Instance>:MEValuation:MGAP?')
 		return Conversions.str_to_int(response)
 
 	def set_mgap(self, min_trig_gap: int) -> None:
 		"""SCPI: TRIGger:LTE:MEASurement<Instance>:MEValuation:MGAP \n
-		Snippet: driver.trigger.multiEval.set_mgap(min_trig_gap = 1) \n
+		Snippet: driver.trigger.lteMeas.multiEval.set_mgap(min_trig_gap = 1) \n
 		Sets a minimum time during which the IF signal must be below the trigger threshold before the trigger is armed so that an
 		IF power trigger event can be generated. \n
 			:param min_trig_gap: No help available
 		"""
 		param = Conversions.decimal_value_to_str(min_trig_gap)
 		self._core.io.write(f'TRIGger:LTE:MEASurement<Instance>:MEValuation:MGAP {param}')
 
 	# noinspection PyTypeChecker
 	def get_smode(self) -> enums.SyncMode:
 		"""SCPI: TRIGger:LTE:MEASurement<Instance>:MEValuation:SMODe \n
-		Snippet: value: enums.SyncMode = driver.trigger.multiEval.get_smode() \n
+		Snippet: value: enums.SyncMode = driver.trigger.lteMeas.multiEval.get_smode() \n
 		Selects the size of the search window for synchronization - normal or enhanced. \n
 			:return: sync_mode: No help available
 		"""
 		response = self._core.io.query_str('TRIGger:LTE:MEASurement<Instance>:MEValuation:SMODe?')
 		return Conversions.str_to_scalar_enum(response, enums.SyncMode)
 
 	def set_smode(self, sync_mode: enums.SyncMode) -> None:
 		"""SCPI: TRIGger:LTE:MEASurement<Instance>:MEValuation:SMODe \n
-		Snippet: driver.trigger.multiEval.set_smode(sync_mode = enums.SyncMode.ENHanced) \n
+		Snippet: driver.trigger.lteMeas.multiEval.set_smode(sync_mode = enums.SyncMode.ENHanced) \n
 		Selects the size of the search window for synchronization - normal or enhanced. \n
 			:param sync_mode: No help available
 		"""
 		param = Conversions.enum_scalar_to_str(sync_mode, enums.SyncMode)
 		self._core.io.write(f'TRIGger:LTE:MEASurement<Instance>:MEValuation:SMODe {param}')
 
 	# noinspection PyTypeChecker
 	def get_amode(self) -> enums.MevAcquisitionMode:
 		"""SCPI: TRIGger:LTE:MEASurement<Instance>:MEValuation:AMODe \n
-		Snippet: value: enums.MevAcquisitionMode = driver.trigger.multiEval.get_amode() \n
+		Snippet: value: enums.MevAcquisitionMode = driver.trigger.lteMeas.multiEval.get_amode() \n
 		Selects whether the measurement synchronizes to a slot boundary or to a subframe boundary. The parameter is relevant for
 		Free Run (Fast Sync) and for list mode measurements with Synchronization Mode = Enhanced. \n
 			:return: acquisition_mode: No help available
 		"""
 		response = self._core.io.query_str('TRIGger:LTE:MEASurement<Instance>:MEValuation:AMODe?')
 		return Conversions.str_to_scalar_enum(response, enums.MevAcquisitionMode)
 
 	def set_amode(self, acquisition_mode: enums.MevAcquisitionMode) -> None:
 		"""SCPI: TRIGger:LTE:MEASurement<Instance>:MEValuation:AMODe \n
-		Snippet: driver.trigger.multiEval.set_amode(acquisition_mode = enums.MevAcquisitionMode.SLOT) \n
+		Snippet: driver.trigger.lteMeas.multiEval.set_amode(acquisition_mode = enums.MevAcquisitionMode.SLOT) \n
 		Selects whether the measurement synchronizes to a slot boundary or to a subframe boundary. The parameter is relevant for
 		Free Run (Fast Sync) and for list mode measurements with Synchronization Mode = Enhanced. \n
 			:param acquisition_mode: No help available
 		"""
 		param = Conversions.enum_scalar_to_str(acquisition_mode, enums.MevAcquisitionMode)
 		self._core.io.write(f'TRIGger:LTE:MEASurement<Instance>:MEValuation:AMODe {param}')
 
-	def clone(self) -> 'MultiEval':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'MultiEvalCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = MultiEval(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = MultiEvalCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Implementations/Trigger_/Prach.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Implementations/Trigger/LteMeas/Srs.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,131 +1,92 @@
-from ...Internal.Core import Core
-from ...Internal.CommandsGroup import CommandsGroup
-from ...Internal import Conversions
-from ...Internal.Utilities import trim_str_response
-from ... import enums
+from ....Internal.Core import Core
+from ....Internal.CommandsGroup import CommandsGroup
+from ....Internal import Conversions
+from .... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Prach:
-	"""Prach commands group definition. 6 total commands, 1 Sub-groups, 5 group commands"""
+class SrsCls:
+	"""Srs commands group definition. 4 total commands, 0 Subgroups, 4 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("prach", core, parent)
-
-	@property
-	def catalog(self):
-		"""catalog commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_catalog'):
-			from .Prach_.Catalog import Catalog
-			self._catalog = Catalog(self._core, self._base)
-		return self._catalog
-
-	def get_source(self) -> str:
-		"""SCPI: TRIGger:LTE:MEASurement<Instance>:PRACh:SOURce \n
-		Snippet: value: str = driver.trigger.prach.get_source() \n
-		Selects the source of the trigger events. Some values are always available. They are listed below. Depending on the
-		installed options, additional values are available. You can query a list of all supported values via TRIGger:...
-		:CATalog:SOURce?. \n
-			:return: source: 'IF Power': Power trigger (received RF power)
-		"""
-		response = self._core.io.query_str('TRIGger:LTE:MEASurement<Instance>:PRACh:SOURce?')
-		return trim_str_response(response)
-
-	def set_source(self, source: str) -> None:
-		"""SCPI: TRIGger:LTE:MEASurement<Instance>:PRACh:SOURce \n
-		Snippet: driver.trigger.prach.set_source(source = '1') \n
-		Selects the source of the trigger events. Some values are always available. They are listed below. Depending on the
-		installed options, additional values are available. You can query a list of all supported values via TRIGger:...
-		:CATalog:SOURce?. \n
-			:param source: 'IF Power': Power trigger (received RF power)
-		"""
-		param = Conversions.value_to_quoted_str(source)
-		self._core.io.write(f'TRIGger:LTE:MEASurement<Instance>:PRACh:SOURce {param}')
+		self._cmd_group = CommandsGroup("srs", core, parent)
 
 	def get_threshold(self) -> float or bool:
-		"""SCPI: TRIGger:LTE:MEASurement<Instance>:PRACh:THReshold \n
-		Snippet: value: float or bool = driver.trigger.prach.get_threshold() \n
+		"""SCPI: TRIGger:LTE:MEASurement<Instance>:SRS:THReshold \n
+		Snippet: value: float or bool = driver.trigger.lteMeas.srs.get_threshold() \n
 		Defines the trigger threshold for power trigger sources. \n
-			:return: trig_threshold: No help available
+			:return: trig_threshold: (float or boolean) No help available
 		"""
-		response = self._core.io.query_str('TRIGger:LTE:MEASurement<Instance>:PRACh:THReshold?')
+		response = self._core.io.query_str('TRIGger:LTE:MEASurement<Instance>:SRS:THReshold?')
 		return Conversions.str_to_float_or_bool(response)
 
 	def set_threshold(self, trig_threshold: float or bool) -> None:
-		"""SCPI: TRIGger:LTE:MEASurement<Instance>:PRACh:THReshold \n
-		Snippet: driver.trigger.prach.set_threshold(trig_threshold = 1.0) \n
+		"""SCPI: TRIGger:LTE:MEASurement<Instance>:SRS:THReshold \n
+		Snippet: driver.trigger.lteMeas.srs.set_threshold(trig_threshold = 1.0) \n
 		Defines the trigger threshold for power trigger sources. \n
-			:param trig_threshold: No help available
+			:param trig_threshold: (float or boolean) No help available
 		"""
 		param = Conversions.decimal_or_bool_value_to_str(trig_threshold)
-		self._core.io.write(f'TRIGger:LTE:MEASurement<Instance>:PRACh:THReshold {param}')
+		self._core.io.write(f'TRIGger:LTE:MEASurement<Instance>:SRS:THReshold {param}')
 
 	# noinspection PyTypeChecker
 	def get_slope(self) -> enums.SignalSlope:
-		"""SCPI: TRIGger:LTE:MEASurement<Instance>:PRACh:SLOPe \n
-		Snippet: value: enums.SignalSlope = driver.trigger.prach.get_slope() \n
+		"""SCPI: TRIGger:LTE:MEASurement<Instance>:SRS:SLOPe \n
+		Snippet: value: enums.SignalSlope = driver.trigger.lteMeas.srs.get_slope() \n
 		Qualifies whether the trigger event is generated at the rising or at the falling edge of the trigger pulse (valid for
 		external and power trigger sources) . \n
 			:return: slope: REDGe: Rising edge FEDGe: Falling edge
 		"""
-		response = self._core.io.query_str('TRIGger:LTE:MEASurement<Instance>:PRACh:SLOPe?')
+		response = self._core.io.query_str('TRIGger:LTE:MEASurement<Instance>:SRS:SLOPe?')
 		return Conversions.str_to_scalar_enum(response, enums.SignalSlope)
 
 	def set_slope(self, slope: enums.SignalSlope) -> None:
-		"""SCPI: TRIGger:LTE:MEASurement<Instance>:PRACh:SLOPe \n
-		Snippet: driver.trigger.prach.set_slope(slope = enums.SignalSlope.FEDGe) \n
+		"""SCPI: TRIGger:LTE:MEASurement<Instance>:SRS:SLOPe \n
+		Snippet: driver.trigger.lteMeas.srs.set_slope(slope = enums.SignalSlope.FEDGe) \n
 		Qualifies whether the trigger event is generated at the rising or at the falling edge of the trigger pulse (valid for
 		external and power trigger sources) . \n
 			:param slope: REDGe: Rising edge FEDGe: Falling edge
 		"""
 		param = Conversions.enum_scalar_to_str(slope, enums.SignalSlope)
-		self._core.io.write(f'TRIGger:LTE:MEASurement<Instance>:PRACh:SLOPe {param}')
+		self._core.io.write(f'TRIGger:LTE:MEASurement<Instance>:SRS:SLOPe {param}')
 
 	def get_timeout(self) -> float or bool:
-		"""SCPI: TRIGger:LTE:MEASurement<Instance>:PRACh:TOUT \n
-		Snippet: value: float or bool = driver.trigger.prach.get_timeout() \n
+		"""SCPI: TRIGger:LTE:MEASurement<Instance>:SRS:TOUT \n
+		Snippet: value: float or bool = driver.trigger.lteMeas.srs.get_timeout() \n
 		Selects the maximum time that the measurement waits for a trigger event before it stops in remote control mode or
 		indicates a trigger timeout in manual operation mode. This setting has no influence on Free Run measurements. \n
-			:return: trigger_timeout: No help available
+			:return: trigger_timeout: (float or boolean) No help available
 		"""
-		response = self._core.io.query_str('TRIGger:LTE:MEASurement<Instance>:PRACh:TOUT?')
+		response = self._core.io.query_str('TRIGger:LTE:MEASurement<Instance>:SRS:TOUT?')
 		return Conversions.str_to_float_or_bool(response)
 
 	def set_timeout(self, trigger_timeout: float or bool) -> None:
-		"""SCPI: TRIGger:LTE:MEASurement<Instance>:PRACh:TOUT \n
-		Snippet: driver.trigger.prach.set_timeout(trigger_timeout = 1.0) \n
+		"""SCPI: TRIGger:LTE:MEASurement<Instance>:SRS:TOUT \n
+		Snippet: driver.trigger.lteMeas.srs.set_timeout(trigger_timeout = 1.0) \n
 		Selects the maximum time that the measurement waits for a trigger event before it stops in remote control mode or
 		indicates a trigger timeout in manual operation mode. This setting has no influence on Free Run measurements. \n
-			:param trigger_timeout: No help available
+			:param trigger_timeout: (float or boolean) No help available
 		"""
 		param = Conversions.decimal_or_bool_value_to_str(trigger_timeout)
-		self._core.io.write(f'TRIGger:LTE:MEASurement<Instance>:PRACh:TOUT {param}')
+		self._core.io.write(f'TRIGger:LTE:MEASurement<Instance>:SRS:TOUT {param}')
 
 	def get_mgap(self) -> float:
-		"""SCPI: TRIGger:LTE:MEASurement<Instance>:PRACh:MGAP \n
-		Snippet: value: float = driver.trigger.prach.get_mgap() \n
+		"""SCPI: TRIGger:LTE:MEASurement<Instance>:SRS:MGAP \n
+		Snippet: value: float = driver.trigger.lteMeas.srs.get_mgap() \n
 		Sets a minimum time during which the IF signal must be below the trigger threshold before the trigger is armed so that an
 		IF power trigger event can be generated. \n
 			:return: min_trig_gap: No help available
 		"""
-		response = self._core.io.query_str('TRIGger:LTE:MEASurement<Instance>:PRACh:MGAP?')
+		response = self._core.io.query_str('TRIGger:LTE:MEASurement<Instance>:SRS:MGAP?')
 		return Conversions.str_to_float(response)
 
 	def set_mgap(self, min_trig_gap: float) -> None:
-		"""SCPI: TRIGger:LTE:MEASurement<Instance>:PRACh:MGAP \n
-		Snippet: driver.trigger.prach.set_mgap(min_trig_gap = 1.0) \n
+		"""SCPI: TRIGger:LTE:MEASurement<Instance>:SRS:MGAP \n
+		Snippet: driver.trigger.lteMeas.srs.set_mgap(min_trig_gap = 1.0) \n
 		Sets a minimum time during which the IF signal must be below the trigger threshold before the trigger is armed so that an
 		IF power trigger event can be generated. \n
 			:param min_trig_gap: No help available
 		"""
 		param = Conversions.decimal_value_to_str(min_trig_gap)
-		self._core.io.write(f'TRIGger:LTE:MEASurement<Instance>:PRACh:MGAP {param}')
-
-	def clone(self) -> 'Prach':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
-		Also copies all the existing default Repeated Capabilities setting,
-		which you can change independently without affecting the original group"""
-		new_group = Prach(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
-		return new_group
+		self._core.io.write(f'TRIGger:LTE:MEASurement<Instance>:SRS:MGAP {param}')
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Internal/ArgLinkedEventArgs.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Internal/ArgLinkedEventArgs.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,7 +1,9 @@
+"""Class defining Linked argument Event."""
+
 import time
 
 
 class ArgLinkedEventArgs(object):
 	"""Contains event data for suppressed argument."""
 
 	def __init__(self, link_name: str, arg_name: str, value: object = None, context: str = '', timestamp: time = None):
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Internal/ArgSingle.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Internal/ArgSingle.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,54 +1,57 @@
+"""Single argument definition for a scalar argument."""
+
 from .ConverterFromScpiString import ConverterFromScpiString
 from .ConverterToScpiString import ConverterToScpiString
+from .InstrumentErrors import RsInstrException
+
 from .Types import DataType
 
 
 class ArgSingle(object):
 	"""Single Argument outside a structure - used for composing query arguments.
 	Contains the argument value as well (self.value)."""
 
-	def __init__(self, name: str, value, data_type: DataType, is_optional: bool = False, is_open_list: bool = False, repetition: int = 1, intern_link: str = None):
+	def __init__(self, name: str, value, data_type: DataType, enum_type=None, is_optional: bool = False, is_open_list: bool = False, repetition: int = 1, intern_link: str = None):
 		self.name = name if name else ''
 		self.argument_ix = None
 		self.value = value
 		self.data_type = data_type
+		self.enum_type = enum_type
 		self.is_optional = is_optional
 		self.is_open_list = is_open_list
 		self.repetition = repetition
 		self.intern_link = intern_link
 		self.conv_from_scpi_string = None
 		self.conv_to_scpi_string = None
 
-		if self.data_type == DataType.Enum:
-			self.assert_mandatory_has_value(self)
-			if self.value is not None:
-				self.enum_type = type(self.value)
-				self.conv_from_scpi_string = ConverterFromScpiString(self.data_type, self.enum_type)
-				self.conv_to_scpi_string = ConverterToScpiString(self.data_type, self.enum_type)
-		elif self.data_type == DataType.EnumList:
-			self.assert_mandatory_has_value(self)
+		if self.data_type.is_scalar_enum:
+			# self.assert_mandatory_has_value(self)
+			self.conv_from_scpi_string = ConverterFromScpiString(self.data_type, self.enum_type)
+			self.conv_to_scpi_string = ConverterToScpiString(self.data_type, self.enum_type)
+		elif self.data_type.is_list_enum:
+			# self.assert_mandatory_has_value(self)
 			if self.value is not None:
-				self.enum_type = type(self.value[0])
 				self.conv_from_scpi_string = ConverterFromScpiString(self.data_type, self.enum_type)
 				self.conv_to_scpi_string = ConverterToScpiString(self.data_type, self.enum_type)
 		else:
 			self.conv_from_scpi_string = ConverterFromScpiString(self.data_type)
 			self.conv_to_scpi_string = ConverterToScpiString(self.data_type)
 
 		self.check_consistency()
 
 	@classmethod
-	def as_open_list(cls, name: str, value: object, data_type: DataType) -> 'ArgSingle':
+	def as_open_list(cls, name: str, value: object, data_type: DataType, enum_type=None) -> 'ArgSingle':
 		"""Creates new ArgSingle of open list type.Use this method for all non-interleaved list types. \n
-		:param name: name of the argument.
-		:param value: value of the argument.
-		:param data_type: data type of the argument.
-		:return: ArgSingle object of an open list type."""
-		return cls(name, value, data_type, False, True, 1, None)
+		:param name: name of the argument
+		:param value: value of the argument
+		:param data_type: data type of the argument
+		:param enum_type: enum type if the data_type is Enum or EnumExt (or list of those)
+		:return: ArgSingle object of an open list type"""
+		return cls(name, value, data_type, enum_type, False, True, 1, None)
 
 	def __str__(self):
 		opt = '~' if self.is_optional else ''
 		name = f" '{self.name}'" if self.name != '' else ''
 		out = f"SingleArg {opt}{self.data_type.name}{name}"
 
 		if self.is_open_list is False and self.repetition > 1:
@@ -72,15 +75,15 @@
 
 	# noinspection PyUnusedLocal
 	def assert_is_optional(self, obj=None) -> None:
 		"""Asserts that the parameter is optional.
 		If not, the method throws an exception."""
 		if self.is_optional:
 			return
-		raise Exception(f'Single argument is not optional: {self}')
+		raise RsInstrException(f'Single argument is not optional: {self}')
 
 	# noinspection PyUnusedLocal
 	def assert_mandatory_has_value(self, value_obj=None) -> None:
 		"""Asserts that if the parameter is mandatory, it must have value assigned.
 		If not, the method throws an exception."""
 		if self.is_optional:
 			return
@@ -93,11 +96,11 @@
 
 	def check_consistency(self) -> None:
 		"""Checks the consistency of the object"""
 		if self.value is None:
 			return
 		if isinstance(self.value, list):
 			if self.data_type.is_scalar:
-				raise Exception(f'Argument real data type is list, but it is declared as {self.data_type}. Value: {self.value}')
+				raise RsInstrException(f'Argument real data type is list, but it is declared as {self.data_type}. Value: {self.value}')
 		else:
 			if self.data_type.is_list:
-				raise Exception(f'Argument real data type is scalar, but it is declared as {self.data_type}. Value: {self.value}')
+				raise RsInstrException(f'Argument real data type is scalar, but it is declared as {self.data_type}. Value: {self.value}')
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Internal/ArgSingleList.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Internal/ArgSingleList.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,7 +1,9 @@
+"""Single argument definition for a list argument."""
+
 from .ArgSingle import ArgSingle
 from .ArgStringComposer import compose_cmd_string_from_single_args
 
 
 class ArgSingleList(object):
 	"""Contains methods for composing cmd string for the list of single arguments.
 	Used in methods with 1+ set or query arguments.
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Internal/ArgSingleSuppressed.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Internal/ArgSingleSuppressed.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,7 +1,10 @@
+"""Contains definition for an argument that is suppressed and not exposed to the user.
+Usually such arguments are also linked to a callback."""
+
 from .Types import DataType
 
 
 class ArgSingleSuppressed(object):
 	"""Single suppressed Argument - used in Query_XxXx_Suppressed() to remove it from the returned value.
 	It does not contain:
 	- 'value' attribute, since this is discarded or linked internally directly  in the Query_XxXx_Suppressed().
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Internal/ArgStringComposer.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Internal/ArgStringComposer.py`

 * *Files 2% similar despite different names*

```diff
@@ -6,14 +6,15 @@
 The composing of the SCPI parameter string is similar for the ArgStruct and ArgSingle[] objects, therefore they share the same module."""
 
 from typing import Dict
 
 from .ArgSingle import ArgSingle
 from .ArgStruct import ArgStruct
 from .Utilities import get_plural_string
+from .InstrumentErrors import RsInstrException
 
 
 class SingleComposer:
 	"""Composes strings for single argument.
 	Provides Composer interface with 3 functions:
 	- from_scalar_arg
 	- from_list_arg
@@ -135,15 +136,15 @@
 					# The last argument, ignore the repetitions and convert the whole list to string
 					string_arg.append(composer.from_list_arg(arg))
 				else:
 					# The optional argument, which has no value. End the entire string_arg composition
 					arg.assert_is_optional(values_obj)
 					opt_null_ix = arg_ix
 			else:
-				# More than one arguments remaining. Loop through them interleaving the result strings
+				# More than one argument remaining. Loop through them interleaving the result strings
 				# Interleaving arguments must all have values
 
 				# Check if each list has at least Repetition number of elements
 				cycles_error = False
 				alignments_error = False
 				cycle = -1
 				data = {}
@@ -151,19 +152,18 @@
 					arg = args[x]
 					curr_size: int = composer.get_arg_list_size(arg)
 					curr_cycle: int = curr_size // arg.repetition
 					curr_align: int = curr_size % arg.repetition
 					data[x] = (curr_size, curr_cycle, curr_align)
 
 					if curr_size < 0:
-						raise Exception(
-							f"Argument '{arg.name}' has repetitions, therefore it must be declared as a list. Current Declaration: '{arg.data_type}'")
+						raise RsInstrException(f"Argument '{arg.name}' has repetitions, therefore it must be declared as a list. Current Declaration: '{arg.data_type}'")
 
 					if arg.repetition > curr_size:
-						raise Exception(f"Argument '{arg.name}' has repetitions {arg.repetition}, but its list size is only {curr_size}")
+						raise RsInstrException(f"Argument '{arg.name}' has repetitions {arg.repetition}, but its list size is only {curr_size}")
 
 					# noinspection PyChainedComparisons
 					if cycle >= 0 and curr_cycle != cycle:
 						cycles_error = True
 
 					cycle = curr_cycle
 
@@ -171,23 +171,21 @@
 						alignments_error = True
 
 				if cycles_error:
 					message = 'Arguments interleaving is not aligned - all the cycles must be the same. Actual cycles:\n'
 					for x in range(arg_ix, arg_count):
 						message += f'{args[x].name}[{data[x][0]}] sliced by {get_plural_string("element", args[x].repetition)} ' \
 							f'results in {data[x][0] / args[x].repetition} cycles\n'
-
-					raise Exception(message)
+					raise RsInstrException(message)
 
 				if alignments_error:
 					message = 'At least one argument has a list size not dividable by the defined repetitions:\n'
 					for x in range(arg_ix, arg_count):
 						message += f'{args[x].name}[{data[x][0]}] modulo {args[x].repetition}x results in {data[x][0] % args[x].repetition}\n'
-
-					raise Exception(message)
+					raise RsInstrException(message)
 
 				for x in range(cycle):
 					for y in range(arg_ix, arg_count):
 						arg = args[y]
 						string_arg.append(composer.from_list_arg(arg, arg.repetition * x, arg.repetition))
 
 	if opt_null_ix >= 0:
@@ -198,15 +196,15 @@
 			if arg.has_value(values_obj):
 				rest.append(arg.name)
 
 		if len(rest):
 			msg = f"Optional Argument '{args[opt_null_ix].name}' has no value, but the further ones do. " \
 				f"If you skip an optional argument, you have to skip all the ones following it. " \
 				f"Clear the values for the rest of the argument(s):\n{', '.join(rest)}"
-			raise Exception(msg)
+			raise RsInstrException(msg)
 
 	return ','.join(string_arg)
 
 
 def compose_cmd_string_from_single_args(args: Dict[int, ArgSingle]) -> str:
 	"""Returns SCPI-composed string based on the single args specification.
 	We can use the same function as for the struct arguments, with the difference of providing a SingleComposer.
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Internal/ArgStruct.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Internal/ArgStruct.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,10 +1,13 @@
+"""Definition for an argument which is a part of a structure."""
+
 from .ConverterFromScpiString import ConverterFromScpiString
 from .ConverterToScpiString import ConverterToScpiString
 from .Types import DataType
+from .InstrumentErrors import RsInstrException
 
 
 class ArgStruct(object):
 	"""Describes an argument in data structures.
 	This info is used to parse a string query response to the output structure,
 	or to parse the output structure to the string parameter for writing.
 	Contains reference to the value in the owning structure."""
@@ -121,17 +124,17 @@
 	def assert_is_optional(self, obj) -> None:
 		"""Asserts that the parameter is optional.
 		If not, the method throws an exception."""
 		if self.is_optional:
 			return
 		value = getattr(obj, self.name)
 		if value is None:
-			raise Exception(f"Structure '{obj}', argument without value is not optional: {self}")
+			raise RsInstrException(f"Structure '{obj}', argument without value is not optional: {self}")
 		else:
-			raise Exception(f"Structure '{obj}', argument is not optional: {self}', value '{value}'")
+			raise RsInstrException(f"Structure '{obj}', argument is not optional: {self}', value '{value}'")
 
 	def assert_mandatory_has_value(self, obj) -> None:
 		"""Asserts that if the parameter is mandatory, it must have value assigned.
 		If not, the method throws an exception."""
 		if self.is_optional:
 			return
 		if getattr(obj, self.name) is None:
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Internal/ArgStructList.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Internal/ArgStructList.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,10 +1,13 @@
+"""See the class docstring."""
+
 from .ArgStringComposer import StructComposer, compose_cmd_string_from_struct_args
 from .ArgStructStringParser import ArgStructStringParser
 from .StructBase import StructBase
+from .InstrumentErrors import RsInstrException
 
 
 class ArgStructList(object):
 	"""Contains methods for composing cmd string and parsing cmd response to the provided structure instance."""
 
 	RAW_DATA_PROP_NAME = 'RawReturnData'
 
@@ -53,22 +56,22 @@
 			# Still some args to go
 			if arg.is_open_list is True:
 				# The previous loop ended because the next argument had is_open_list True
 				if arg_ix == (arg_count - 1):
 					# This is the last argument, ignore the repetitions and take the whole rest of the elements
 					parser.to_list_value(arg, True, 0, parser.remaining, parser.remaining, 1)
 				else:
-					# More than one arguments remaining. Loop through them interleaving the result strings
+					# More than one argument remaining. Loop through them interleaving the result strings
 					open_list_args = {key: value for key, value in self.args.items() if key >= arg_ix}
 
 					# Accumulate the number of repetitions from all the open_list_args
 					period: int = sum(open_list_args[ix].repetition for ix in open_list_args)
 					reminder: int = parser.remaining % period
 					if reminder != 0:
-						raise Exception(
+						raise RsInstrException(
 							f'Arguments parsing is not aligned - source string elements remaining to parse {parser.remaining}'
 							f'is not dividable by the summary Period {period} of all the open list arguments:\n' + '\n'.join(['{}'.format(x) for x in open_list_args]))
 					# Go through the arguments and accumulate the list content
 					offset = 0
 					for x in open_list_args:
 						arg = open_list_args[x]
 						parser.to_list_value(arg, False, offset, arg.repetition, period, -1)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Internal/ArgStructStringParser.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Internal/ArgStructStringParser.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,9 +1,12 @@
+"""See the class docstring."""
+
 from . import Utilities
 from .ArgStruct import ArgStruct
+from .InstrumentErrors import RsInstrException
 
 
 class ArgStructStringParser:
 	"""Class for parsing a response from the instrument to an output structure of arguments.
 	It is used by the ArgStructList class for filling structures with return values."""
 
 	def __init__(self, struct, value: str):
@@ -17,34 +20,34 @@
 		"""Remaining items to parse."""
 		return self.count - self.position
 
 	def to_scalar_value(self, arg: ArgStruct):
 		"""Parses the current element to a scalar argument."""
 		assert arg.data_type.is_scalar, f'to_scalar_value() method only works with scalar values. Data type: {arg.data_type}'
 		if self.position >= self.count:
-			raise Exception(
+			raise RsInstrException(
 				f"Cannot parse a scalar value to structure argument. Response contains only {self.count} elements, "
 				f"argument '{arg.name}' has position {self.position + 1}.\n"
 				f"Response (commas replaced by new lines):\n" + Utilities.truncate_string_from_end('\n'.join(self.elements), 1000))
 		string = self.elements[self.position]
 		value = arg.conv_from_scpi_string.get_one_element_value(string)
 		setattr(self.struct, arg.name, value)
 		self.position += 1
 
 	def to_list_value(self, arg: ArgStruct, increase_pos: bool, offset: int, count: int, period: int, cycles: int) -> None:
 		"""Parses more elements to the list argument - slicing."""
 		assert arg.data_type.is_list, f'to_list_value method only works with list values. Data type: {arg.data_type}'
 		if cycles < 0:
 			cycles = self.remaining // period
 		if self.position >= self.count:
-			raise Exception(
+			raise RsInstrException(
 				f"Cannot parse an list value to the argument '{arg.name}', "
 				f"because the element position {self.position} is over the parsed list length {self.count}")
 		if (self.position + offset + count) > self.count:
-			raise Exception(
+			raise RsInstrException(
 				f"Cannot parse the whole list value to the argument '{arg.name}', because the element position {self.position} "
 				f"plus the argument offset {offset} and argument length {count} would be over the parsed list length {self.count}")
 
 		result = []
 		for cycle in range(cycles):
 			start_ix = self.position + (cycle * period) + offset
 			for i in range(count):
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Internal/CommandsGroup.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Internal/CommandsGroup.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,7 +1,9 @@
+"""See the class docstring."""
+
 from enum import Enum
 from typing import List
 from .Core import Core
 from .RepeatedCapability import RepeatedCapability as RepCap
 from .InstrumentErrors import DriverValueError
 
 
@@ -38,27 +40,27 @@
 		return self.multi_repcap_types != ''
 
 	def add_existing_child(self, child: 'CommandsGroup') -> None:
 		"""Adds the child to the parent's list of created children.
 		This is used when the group is cloned, where the whole existing tree of groups have to be recreated"""
 		self.existing_children.append(child)
 
-	def set_repcap_enum_value(self, enum_value: Enum) -> None:
-		"""Sets RepCap value as enum
-		Default is not allowed."""
+	def set_repcap_enum_value(self, enum_value: Enum or int) -> None:
+		"""Sets RepCap value as enum or integer
+		Default is not allowed here."""
 		try:
 			self.rep_cap.set_enum_value(enum_value)
 		except ValueError:
 			raise DriverValueError(self.io.resource_name, f"Commands group RepCap value '{self.rep_cap.name}.Default' cannot be set. Please select a concrete value.")
 
 	def get_repcap_enum_value(self) -> Enum:
 		"""Returns RepCap value as enum"""
 		return self.rep_cap.get_enum_value()
 
-	def get_repcap_cmd_value(self, enum_value: Enum, enum_type) -> str:
+	def get_repcap_cmd_value(self, enum_value: Enum or int, enum_type) -> str:
 		"""Returns the current string of RepCapCmdValue for the entered RepCapEnumName
 		The enum_value can be a repcap of the current CommandsGroup or any of their parents"""
 		# Use the static functions of the RepeatedCapability to get the non-default value
 		# It is faster, since there is no need to use the RepCap instance
 		if not RepCap.clsm_is_default_value(enum_value, enum_type):
 			return RepCap.clsm_get_cmd_string_value(enum_value, enum_type)
 		# Default value - get it from the group or the parent groups
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Internal/Conversions.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Internal/Conversions.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,14 +1,20 @@
+"""Contains conversion functions for SCPI string -> parameter and vice versa."""
+
 import math
 import struct
 import sys
 from enum import Enum
-from typing import List
+from typing import List, Tuple
+from .ScpiEnums import ScpiEnum, enum_spec_prefixes, enum_spec_strings
+from .Properties import Properties
+from datetime import datetime
 
 from . import Utilities
+from .InstrumentErrors import RsInstrException
 
 
 class BinFloatFormat(Enum):
 	"""Binary format of a float number."""
 	Single_4bytes = 1
 	Single_4bytes_swapped = 2
 	Double_8bytes = 3
@@ -24,15 +30,15 @@
 
 
 def assert_string_data(value: str) -> None:
 	"""Asserts value is string type."""
 	assert isinstance(value, str), f"Input value type must be string. Actual type: {type(value)}, value: {value}"
 
 
-def assert_list_data(value: list) -> None:
+def assert_list_data(value: List) -> None:
 	"""Asserts value is list type."""
 	assert isinstance(value, list), f"Input value type must be a list. Actual type: {type(value)}, value: {value}"
 
 
 def _get_endianness_symbol(swap_endianness: bool) -> str:
 	"""Based on the current endianness returns the symbol used in the 'struct' module."""
 	if swap_endianness is False:
@@ -143,15 +149,15 @@
 bool_true_lookup = frozenset(['1', 'on', 'On', 'ON', 'true', 'True', 'TRUE'])
 bool_false_lookup = frozenset(['0', 'off', 'Off', 'OFF', 'false', 'False', 'FALSE'])
 pure_bool_false_lookup = frozenset(['off', 'Off', 'OFF', 'false', 'False', 'FALSE'])
 
 
 def str_to_bool(string: str) -> bool:
 	"""Converts string to boolean value.
-	The function robust, and case insensitive.
+	The function is robust, and case-insensitive.
 	If the string can not be converted to a boolean, the function returns False."""
 	assert_string_data(string)
 	if string in bool_true_lookup:
 		return True
 	if string in bool_false_lookup:
 		return False
 	# If leading/trailing spaces
@@ -193,24 +199,38 @@
 
 
 number_plus_inf_lookup = frozenset(['Inf', 'INF', 'INFINITY', '+Inf', '+INF', '+inf', '+INFINITY', '+Infinity', '+infinity'])
 number_minus_inf_lookup = frozenset(['-Inf', '-INF', '-inf', '-INFINITY', '-Infinity', '-infinity'])
 number_nan_lookup = frozenset(['Nan', 'NAN', 'nan', 'NaN', 'NAV', 'NaV', 'NCAP', 'INV', 'NONE', 'none', 'None', 'DTX', 'UND', 'und'])
 number_max_lookup = frozenset(['OFL', 'ofl', 'Ofl'])
 number_min_lookup = frozenset(['UFL', 'ufl', 'Ufl'])
+number_si_suffix = {
+	'pHz': 1E-12, 'MHz': 1E+6, 'kHz': 1E+3, 'GHz': 1E+9, 'mHz': 1E-3, 'uHz': 1E-6, 'Hz': 1E-6, 'THz': 1E+12, 'nHz': 1E-9, 'ns': 1E-9, 'fW': 1E-15,
+	'pW': 1E-12, 'nW': 1E-9, 'uW': 1E-6, 'W': 1E-6, 'mW': 1E-3, 'kW': 1E3, 'MW': 1E6, 'GW': 1E9, 'MV': 1E+6, 'MA': 1E+6, 'ps': 1E-12, 'fs': 1E-15,
+	'km': 1E+3, 'kV': 1E+3, 'kA': 1E+3, 'pF': 1E-2, 'Hz': 1.0, 'mm': 1E-3, 'mA': 1E-3, 'mF': 1E-3, 'mV': 1E-3, 'pV': 1E-12, 'nF': 1E-9, 'nA': 1E-9,
+	'nV': 1E-9, 'nm': 1E-9, 'pm': 1E-12, 'us': 1E-6, 's': 1E-6, 'uF': 1E-6, 'F': 1E-6, 'ms': 1E-3, 'uA': 1E-6, 'A': 1E-6, 'uV': 1E-6, 'V': 1E-6,
+	'um': 1E-6, 'm': 1E-6, 'pA': 1E-12, 'V': 1, 'W': 1, 'A': 1, 'F': 1, 's': 1, 'm': 1}
 int_neg_inf = -(sys.maxsize - 1)
-enum_spec_prefixes = {'_minus': '-', '_plus': '+', '_': ''}
-enum_spec_strings = {'_dash_': '-', '_dot_': '.'}
+
+
+def strip_si_suffix(string: str) -> Tuple[bool, str, float]:
+	"""Tries to find defined suffixes in the text and returns the stripped text and the multiplier as double number.
+	If no known suffix is detected, the method returns false, strippedText=text, multiplier=1.0
+	Example: text='123 MHz' strippedText='123' multiplier=1E6"""
+	for suffix in number_si_suffix.keys():
+		if string.endswith(suffix):
+			return True, string[:-len(suffix)].rstrip(), number_si_suffix[suffix]
+	return False, string, 1.0
 
 
 def str_to_int(string: str) -> int:
 	"""Converts string to integer value. Float values are coerced to integer.
-	Also recognizes case insensitive special values like NaN, INV, NCAP..."""
+	Also recognizes case-insensitive special values like NaN, INV, NCAP..."""
 	assert_string_data(string)
-	string = string.strip()
+	string = string.strip(" \t\r\n'\"")
 	if string == '':
 		return 0
 	value = str_special_values_to_int(string)
 	if value:
 		return value
 
 	# Hexadecimal numbers
@@ -232,15 +252,24 @@
 		if ',' in string:
 			return int(string[2:string.find(',')], 8)
 		else:
 			return int(string[2:], 8)
 	# Simulation
 	if string == 'Simulating':
 		return 0
-	return int(round(float(string)))
+	try:
+		return int(round(float(string)))
+	except ValueError:
+		result = strip_si_suffix(string)
+		if result[0] is False:
+			raise
+		try:
+			return int(round(float(result[1]) * result[2]))
+		except ValueError:
+			raise ValueError(f"could not convert string to integer: '{string}'")
 
 
 def str_special_values_to_int(string: str) -> int:
 	"""Converts special string values to integer. Returns None if no special value was found."""
 	assert_string_data(string)
 	if string in number_plus_inf_lookup or string in number_max_lookup:
 		return sys.maxsize
@@ -270,17 +299,17 @@
 	if result is not None:
 		return result
 	return str_to_int(string)
 
 
 def str_to_float(string: str) -> float:
 	"""Converts string to float value.
-	Also recognizes case insensitive special values like NaN, INV, NCAP..."""
+	Also recognizes case-insensitive special values like NaN, INV, NCAP..."""
 	assert_string_data(string)
-	string = string.strip()
+	string = string.strip(" \t\r\n'\"")
 	if string == '':
 		return 0.0
 	if string in number_plus_inf_lookup:
 		return math.inf
 	if string in number_minus_inf_lookup:
 		return -math.inf
 	if string in number_nan_lookup:
@@ -299,15 +328,24 @@
 		return -sys.float_info.max / 100
 	if string == 'ULEU':
 		return sys.float_info.max / 10
 	if string == 'ULEL':
 		return -sys.float_info.max / 10
 	if string == 'Simulating':
 		return 0.0
-	return float(string)
+	try:
+		return float(string)
+	except ValueError:
+		result = strip_si_suffix(string)
+		if result[0] is False:
+			raise
+		try:
+			return float(result[1]) * result[2]
+		except ValueError:
+			raise ValueError(f"could not convert string to float: '{string}'")
 
 
 def str_to_float_or_bool(string: str) -> float or bool:
 	"""Similar to str_to_float, but for special values "ON/OFF" the function returns boolean"""
 	result = string_to_pure_bool(string)
 	if result is not None:
 		return result
@@ -320,24 +358,24 @@
 
 
 def bool_to_str(value: bool) -> str:
 	"""Converts boolean to 'ON' or 'OFF' string."""
 	if type(value) is bool:
 		return 'ON' if value is True else 'OFF'
 	else:
-		raise Exception(f"bool_to_str: unsupported variable type '{type(value)}', value '{value}'. Only boolean values are supported.")
+		raise RsInstrException(f"bool_to_str: unsupported variable type '{type(value)}', value '{value}'. Only boolean values are supported.")
 
 
 def str_enclose_by_quotes(string: str) -> str:
 	"""Returns string enclosed by single quotes."""
 	assert_string_data(string)
-	return "'" + string + "'"
+	return Properties.scpi_quotes + string + Properties.scpi_quotes
 
 
-def list_to_csv_str(value: list) -> str:
+def list_to_csv_str(value: List, delimiter: str = ',') -> str:
 	"""Converts list of elements to strings separated by commas.
 	Element types can differ on an individual basis.
 	Supported element types:
 	- int
 	- bool
 	- float
 	- string -> string no quotes
@@ -345,18 +383,18 @@
 	assert_list_data(value)
 	result = []
 	for x in value:
 		el = value_to_str(x)
 		if not el:
 			raise TypeError(f"List element type is not supported by Conversions.list_to_csv_str: '{x}'")
 		result.append(el)
-	return ','.join(result)
+	return delimiter.join(result)
 
 
-def list_to_csv_quoted_str(value: list) -> str:
+def list_to_csv_quoted_str(value: List) -> str:
 	"""Converts list of elements to quoted strings separated by commas.
 	Only string elements are enclosed by single quotes
 	Element types can differ on an individual basis.
 	Supported element types:
 	- int
 	- bool
 	- float
@@ -368,29 +406,28 @@
 		if isinstance(x, str):
 			el = str_enclose_by_quotes(x)
 		else:
 			el = value_to_str(x)
 		if not el:
 			raise TypeError(f"List element type is not supported by Conversions.list_to_csv_quoted_str: '{x}'")
 		result.append(el)
-
 	return ','.join(result)
 
 
 def decimal_value_to_str(x: int or float) -> str:
 	"""Converts scalar decimal value to string.
 	Supported element types:
 	- int
 	- float"""
 	if isinstance(x, int) and type(x) is not bool:
 		return str(x)
 	elif isinstance(x, float):
 		return float_to_str(x)
 	else:
-		raise Exception(f"decimal_value_to_str: unsupported variable type '{type(x)}', value '{x}'. Only integer and float types are supported.")
+		raise RsInstrException(f"decimal_value_to_str: unsupported variable type '{type(x)}', value '{x}'. Only integer and float types are supported.")
 
 
 def decimal_or_bool_value_to_str(x: int or float or bool) -> str:
 	"""Converts scalar decimal value to string.
 	Supported element types:
 	- int
 	- float
@@ -398,15 +435,15 @@
 	if type(x) is bool:
 		return bool_to_str(x)
 	if isinstance(x, int):
 		return str(x)
 	elif isinstance(x, float):
 		return float_to_str(x)
 	else:
-		raise Exception(f"decimal_or_bool_value_to_str: unsupported variable type '{type(x)}', value '{x}'. Only integer, float and boolean types are supported.")
+		raise RsInstrException(f"decimal_or_bool_value_to_str: unsupported variable type '{type(x)}', value '{x}'. Only integer, float and boolean types are supported.")
 
 
 def value_to_str(x: int or bool or float or str or Enum) -> str:
 	"""Converts scalar value to string.
 	Supported element types:
 	- int
 	- bool
@@ -418,17 +455,19 @@
 	elif isinstance(x, int):
 		return str(x)
 	elif isinstance(x, float):
 		return float_to_str(x)
 	elif isinstance(x, str):
 		return x
 	elif isinstance(x, Enum):
+		if isinstance(x.value, str):
+			return enum_value_to_scpi_string(x.value)
 		return enum_value_to_scpi_string(x.name)
 	else:
-		raise Exception(f"value_to_str: unsupported variable type '{type(x)}', value '{x}'. Supported types: int, bool, float, str, enum.")
+		raise RsInstrException(f"value_to_str: unsupported variable type '{type(x)}', value '{x}'. Supported types: int, bool, float, str, enum.")
 
 
 def enum_value_to_scpi_string(enum_value: str) -> str:
 	"""Conversion EnumValue -> SCPI_String
 	Unescapes all the special characters that can not be contained in the enum member definition, but can be sent to the instrument as enum string.
 	Use this to send the scpi enum value to the instrument."""
 	for key in enum_spec_prefixes:
@@ -443,15 +482,15 @@
 	"""Converts scalar value to string enclosed by single quotes.
 	Supported element types:
 	- int
 	- bool
 	- float
 	- string
 	- enum"""
-	return f"'{value_to_str(x)}'"
+	return Properties.scpi_quotes + value_to_str(x) + Properties.scpi_quotes
 
 
 def str_to_float_list(string: str) -> List[float]:
 	"""Converts string with comma-separated values to list of Floats."""
 	assert_string_data(string)
 	if not string:
 		return []
@@ -504,103 +543,158 @@
 		return []
 	result = [*map(Utilities.trim_str_response, string.split(','))]
 	if clear_one_empty_item and len(result) == 1 and result[0] == '':
 		return []
 	return result
 
 
-def _find_in_enum_members(item: str, enum_members: List[str]) -> int:
-	"""Matches a string in the provided list of member strings.
-	The item must be not fully matched.
-	The item is matched if a member string starts with the item (the item is a prefix of the member).
-	Example: item='CONN' will match the enum_member 'CONNected'
-	If the item contains a comma, only the value before comma is considered
-	Returns found index in the enum_members list"""
-	if ',' in item:
-		item = item[:item.index(',')].strip()
-	i = 0
-	for x in enum_members:
-		if x.startswith(item):
-			return i
-		i += 1
-
-	# smart matching:
-	# item = 'MAX' matches enum 'MAXpeak'
-	# item = 'SPECtrum1' matches enum 'SPEC1'
-	# item = 'SPEC' matches enum 'SPECtrum1'
-
-	item = ''.join([c for c in item if not c.islower()])
-	# item must be longer than 1 character
-	if len(item) < 2:
-		return -1
-	i = 0
-	for x in enum_members:
-		x_uc = ''.join([c for c in x if not c.islower()])
-		if x_uc == item:
-			return i
-		i += 1
-	return -1
-
-
-def str_to_scalar_enum_helper(string: str, enum_type: Enum, enum_members=None) -> Enum:
+def str_to_scalar_enum_helper(string: str, scpi_enum: ScpiEnum, array_search: bool, exc_if_not_found) -> Enum:
 	"""Converts string to one enum element.
-	enum_members are optional to improve the performance for repeated conversions.
-	If you do not provide them, they are generated inside the function."""
-	value = Utilities.trim_str_response(string)
-	if not enum_members:
-		# noinspection PyTypeChecker
-		enum_members = [x.name for x in enum_type]
-
-	# Search in the enum member and return the index of the matched item
-	ix = _find_in_enum_members(value, enum_members)
-	if ix >= 0:
-		# noinspection PyUnresolvedReferences
-		return enum_type[enum_members[ix]]
-
-	# If the result is -1 (not found), try to replace the special values and search again
-	# This is done to improve the performance, since most of the enums have no special values
-	enum_members_conv = [enum_value_to_scpi_string(x) for x in enum_members]
-	ix = _find_in_enum_members(value, enum_members_conv)
-	if ix >= 0:
-		# noinspection PyUnresolvedReferences
-		return enum_type[enum_members[ix]]
-
+	array_search signal no need to force the comma removing,
+	because the elements definitely do not have any commas - commas have been used to split string to the list of strings
+	The function can also return:
+	- integer special value, if the string was not found in the enum, and it is a special value.
+	- input string, if the string was not found and raise_if_not_found is set to False - used for the EnumExt types."""
+	if scpi_enum.has_quotes:
+		value = Utilities.trim_str_response(string, mode=Utilities.TrimStringMode.white_chars_double_quotes)
+	else:
+		value = Utilities.trim_str_response(string)
+	enum_value = scpi_enum.find_in_enum_members(value, False)
+	if enum_value is not None:
+		return enum_value
+	if array_search is False:
+		# If the result is still -1 (not found), try to force removing the comma in the string.
+		enum_value = scpi_enum.find_in_enum_members(value, True)
+		if enum_value is not None:
+			return enum_value
 	# If not found, search in the special integer numbers:
 	spec_value = str_special_values_to_int(value)
-	if not spec_value:
-		raise Exception(f"String '{value}' can not be found in the enum type '{enum_type}'")
+	if spec_value:
+		# noinspection PyTypeChecker
+		return spec_value
+	if exc_if_not_found:
+		raise RsInstrException(f"String '{value}' can not be found in the enum type '{scpi_enum.enum_type}'")
 	# noinspection PyTypeChecker
-	return spec_value
+	return Utilities.trim_str_response(string)
 
 
-def str_to_list_enum_helper(string: str, enum_type: Enum, enum_members=None) -> List[Enum]:
-	"""Converts string to list of enum elements.
-	enum_members are optional to improve the performance for repeated conversions.
-	If you do not provide them, they are generated inside the function."""
-	if not enum_members:
-		# noinspection PyTypeChecker
-		enum_members = [x.name for x in enum_type]
+def str_to_simple_scalar_enum(string: str, enum_type, case_sensitive: bool = True, ignore_underscores: bool = False) -> Enum or None:
+	"""Converts string to one enum element.
+	Does not handle special value or non-mandatory parts.
+	The function is used in core only for standard enum conversions, not for SCPI enum conversions."""
+	value = Utilities.trim_str_response(string)
+	enum_members = [x.name for x in enum_type]
+	enum_members_mod = [x.name for x in enum_type]
+	if not case_sensitive:
+		enum_members_mod = [x.upper() for x in enum_members]
+		value = value.upper()
+	if ignore_underscores:
+		enum_members_mod = [x.replace('_', '') for x in enum_members_mod]
+		value = value.replace('_', '')
+	if value in enum_members_mod:
+		return enum_type[enum_members[enum_members_mod.index(value)]]
+	return None
+
+
+def str_to_list_enum_helper(string: str, scpi_enum: ScpiEnum, exc_if_not_found: bool = True) -> List[Enum]:
+	"""Converts string to list of enum elements. separated by comma"""
 	elements = string.split(',')
-	return [str_to_scalar_enum_helper(x, enum_type, enum_members) for x in elements]
+	return [str_to_scalar_enum_helper(x, scpi_enum, True, exc_if_not_found) for x in elements]
 
 
 def enum_scalar_to_str(data, enum_type) -> str:
 	"""Converts enum scalar value to string."""
 	assert isinstance(data, enum_type), f"Expected command parameter {enum_type}, actual data type: {type(data)}. Value: {data}"
 	return value_to_str(data)
 
 
+def enum_ext_scalar_to_str(data, enum_type) -> str:
+	"""Converts enum scalar value to string.
+	If the input value is string, the function returns the string with single quotes."""
+	if isinstance(data, str):
+		# Return string with quotes
+		return value_to_quoted_str(Utilities.trim_str_response(data))
+	assert isinstance(data, enum_type), f"Expected command parameter string or {enum_type}, actual data type: {type(data)}. Value: {data}"
+	return value_to_str(data)
+
+
 def enum_list_to_str(data: List, enum_type) -> str:
 	"""Converts enum list to csv-string."""
 	# For enums, check that each element is an enum
 	assert all(isinstance(x, enum_type) for x in data), f"Expected command parameter list of {enum_type}, detected one or more elements of non-enum type. Value: {data}"
 	return list_to_csv_str(data)
 
 
+def enum_ext_list_to_str(data: List, enum_type) -> str:
+	"""Converts enum list to csv-string. Allows the elements to be either enum or string."""
+	assert all((isinstance(x, enum_type or str) or isinstance(x, str)) for x in data), f"Expected command parameter list of strings or {enum_type}, detected one or more elements of non-enum/non-string type. Value: {data}"
+	return list_to_csv_quoted_str(data)
+
+
 def str_to_scalar_enum(string: str, enum_type) -> Enum:
-	"""Converts string to one enum element."""
-	return str_to_scalar_enum_helper(string, enum_type)
+	"""Converts string to one enum element.
+	Throws exception if the string can not be converted to an enum element or a special value."""
+	return str_to_scalar_enum_helper(string, ScpiEnum(enum_type), False, exc_if_not_found=True)
+
+
+def str_to_scalar_enum_ext(string: str, enum_type) -> Enum:
+	"""Converts string to one enum element.
+	Compared to str_to_scalar_enum, in case the string can not be converted, it is returned trimmed for quotes and ."""
+	return str_to_scalar_enum_helper(string, ScpiEnum(enum_type), False, exc_if_not_found=False)
 
 
 def str_to_list_enum(string: str, enum_type) -> List[Enum]:
 	"""Converts string to list of enum elements."""
-	return str_to_list_enum_helper(string, enum_type)
+	return str_to_list_enum_helper(string, ScpiEnum(enum_type))
+
+
+def str_to_list_enum_ext(string: str, enum_type) -> List[Enum]:
+	"""Converts string to list of enum or string elements."""
+	return str_to_list_enum_helper(string, ScpiEnum(enum_type), exc_if_not_found=False)
+
+
+def convert_ts_to_datetime(timestamp: datetime or float) -> datetime:
+	"""Converts timestamp as float to datetime. For datetime tuple it just passes the value."""
+	if isinstance(timestamp, float) or isinstance(timestamp, int):
+		return datetime.fromtimestamp(timestamp)
+	return timestamp
+
+
+def get_timestamp_string(timestamp: datetime or float) -> str:
+	"""Returns the timestamp as string. The timestamp can be a datetime tuple or float seconds coming from the time.time()."""
+	timestamp = convert_ts_to_datetime(timestamp)
+	cur_time = timestamp.strftime('%H:%M:%S.%f')[:-3]
+	return cur_time
+
+
+def get_timedelta_fixed_string(time_start: datetime or float, time_end: datetime or float) -> str:
+	"""Returns the time span as string - fixed in the format of '%H:%M:%S.%f'."""
+	time_a = convert_ts_to_datetime(time_start)
+	time_b = convert_ts_to_datetime(time_end)
+	frac = (time_b - time_a).total_seconds()
+	wh = math.floor(frac)
+	d = int(wh / 86400)
+	h = int((wh - (d * 86400)) / 3600)
+	m = int((wh - (d * 86400 + h * 3600)) / 60)
+	s = int((wh - (d * 86400 + h * 3600 + m * 60)))
+	ms = int((frac - wh) * 1000)
+	res = f'{h:02d}:{m:02d}:{s:02d}.{ms:03d}'
+	if d > 0:
+		res = f'{d}d ' + res
+	return res
+
+
+def get_timedelta_string(time_a: datetime or float, time_b: datetime or float) -> str:
+	"""Returns the time span as string - dynamic based on the difference."""
+	time_a = convert_ts_to_datetime(time_a)
+	time_b = convert_ts_to_datetime(time_b)
+	if time_b < time_a:
+		return '0.000 ms'
+	diff = time_b - time_a
+	if diff.seconds < 10:
+		return f'{diff.total_seconds() * 1000:0.3f} ms'
+	elif diff.seconds < 1000:
+		a = diff.total_seconds()
+		return f'{a:0.3f} secs'
+	hours, remainder = divmod(diff.seconds, 3600)
+	minutes, seconds = divmod(remainder, 60)
+	return f'{hours:02d}:{minutes:02d}:{seconds:02d}'
```

#### encoding

```diff
@@ -1 +1 @@
-us-ascii
+utf-8
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Internal/ConverterFromScpiString.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Internal/ConverterFromScpiString.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,28 +1,32 @@
+"""See the class docstring."""
+
 from enum import Enum
 
 from .Conversions import str_to_bool, str_to_int, str_to_int_or_bool, str_to_float, str_to_float_or_bool, str_to_scalar_enum_helper
 from .Conversions import str_to_str_list, str_to_bool_list, str_to_int_list, str_to_int_or_bool_list, str_to_float_list, str_to_float_or_bool_list, str_to_list_enum_helper
 from .Types import DataType
 from .Utilities import trim_str_response
+from .InstrumentErrors import RsInstrException
+from .ScpiEnums import ScpiEnum
 
 
 class ConverterFromScpiString:
 	"""Converter from SCPI response string to argument value
 	For list argument types, you must use the method get_one_element_value in a loop for each element.
 	Provides methods:
 	- get_one_element_value(str): returns one scalar value converted from the SCPI string.
 	- get_list_value(str): return complete list value converted from the SCPI string.
 	- get_value(str): calls either get_one_element_value or get_list_value() depending on the data type. \n
 	The reason for the different methods is, that sometimes the list data are interleaved with other arguments.
 	In order to parse them properly, the ArgStructStringParser module must be able to set the argument value element-by-element.
-	On the other side, the driver methods might want to set the whole argument value, because the result scpi string is a single argument response."""
+	The driver methods might want to set the whole argument value, because the result scpi string is a single argument response."""
 
 	def __init__(self, data_type: DataType, enum_type: Enum = None):
-		self.enum_type = enum_type
+		self.scpi_enum = None
 		self.data_type = data_type
 		self.element_type = self.data_type.element_type
 
 		if self.element_type == DataType.RawString:
 			self.converter = trim_str_response
 			self.list_converter = str_to_str_list
 
@@ -46,30 +50,29 @@
 			self.converter = str_to_float
 			self.list_converter = str_to_float_list
 
 		elif self.element_type == DataType.FloatExt:
 			self.converter = str_to_float_or_bool
 			self.list_converter = str_to_float_or_bool_list
 
-		elif self.element_type == DataType.Enum:
-			assert self.enum_type, f"For data type enum, you have to define the enum_type variable."
+		elif self.element_type.is_scalar_enum:
+			assert enum_type, f"For data type enum, you have to define the enum_type variable."
 			# noinspection PyTypeChecker
-			self.enum_members = [x.name for x in self.enum_type]
+			self.scpi_enum = ScpiEnum(enum_type)
 		else:
-			raise Exception(f"Unsupported data type '{data_type}'")
+			raise RsInstrException(f"Unsupported data type '{data_type}'")
 
 	def get_one_element_value(self, scpi_string: str):
-		"""Returns single element !!! of the argument value converted from the SCPI string (single element)"""
+		"""Returns single element (not an array!!!) of the argument value converted from the SCPI string (single element)"""
 		assert isinstance(scpi_string, str), f"Input parameter scpi_string must be string. Actual parameter: {type(scpi_string)}, value: {scpi_string}"
-		if self.element_type is DataType.Enum:
-			return str_to_scalar_enum_helper(scpi_string, self.enum_type, self.enum_members)
+		if self.element_type.is_scalar_enum:
+			return str_to_scalar_enum_helper(scpi_string, self.scpi_enum, False, exc_if_not_found=self.element_type == DataType.Enum)
 		return self.converter(scpi_string)
 
 	def get_value(self, scpi_string: str):
 		"""Returns complete value of the argument converted from the SCPI string (list or scalar)"""
 		if not self.data_type.is_list:
 			return self.get_one_element_value(scpi_string)
-
 		assert isinstance(scpi_string, str), f"Input parameter scpi_string must be string. Actual parameter: {type(scpi_string)}, value: {scpi_string}"
 		if self.element_type is DataType.Enum:
-			return str_to_list_enum_helper(scpi_string, self.enum_type, self.enum_members)
+			return str_to_list_enum_helper(scpi_string, self.scpi_enum, exc_if_not_found=self.element_type == DataType.Enum)
 		return self.list_converter(scpi_string)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Internal/ConverterToScpiString.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Internal/ConverterToScpiString.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,16 +1,19 @@
+"""See the class docstring."""
+
 from enum import Enum
 
-from .Conversions import list_to_csv_quoted_str, value_to_quoted_str, list_to_csv_str, value_to_str, enum_list_to_str, enum_scalar_to_str
+from .Conversions import list_to_csv_quoted_str, value_to_quoted_str, list_to_csv_str, value_to_str, enum_list_to_str, enum_scalar_to_str, enum_ext_scalar_to_str, enum_ext_list_to_str
 from .Types import DataType
+from .InstrumentErrors import RsInstrException
 
 
-def value_to_scpi_string(data, data_type: DataType):
-	"""Method to be used in the driver implementation.
-	Convert data to SCPI string parameter: data -> str"""
+def value_to_scpi_string(data, data_type: DataType) -> str:
+	"""Convert data to SCPI string parameter: data -> str.
+	Does not work with enum data types."""
 	if data_type.is_list:
 		assert isinstance(data, list), f"Expected command parameter list, actual data type: {type(data)}. Value: {data}"
 	else:
 		assert not isinstance(data, list), f"Expected command parameter scalar, actual data type: {type(data)}. Value: {data}"
 	# Strings are enclosed by single quotes
 	if data_type == DataType.StringList:
 		assert all(isinstance(x, str) for x in data), f"Expected command parameter list of strings, detected one or more elements of non-string type. Value: {data}"
@@ -46,35 +49,37 @@
 	elif data_type == DataType.IntegerExtList or data_type == DataType.FloatExtList:
 		assert all((isinstance(x, int) or isinstance(x, float) or isinstance(x, bool)) for x in data), f"Expected command parameter list of numbers or booleans, detected one or more elements of non-number type. Value: {data}"
 		return list_to_csv_str(data)
 	elif data_type == DataType.IntegerExt or data_type == DataType.FloatExt:
 		assert (isinstance(data, int) or isinstance(data, float) or isinstance(data, bool)), f"Expected command parameter number or boolean, actual data type: {type(data)}. Value: {data}"
 		return value_to_str(data)
 	else:
-		raise Exception(f"Unsupported data type: '{type(data_type)}'.")
+		raise RsInstrException(f"Unsupported data type: '{type(data_type)}'.")
 
 
 class ConverterToScpiString:
 	"""Converter from argument value to SCPI string.
 	Provides method get_value(arg_value) -> str
 	"""
 
 	def __init__(self, data_type: DataType, enum_type: Enum = None):
 		self.enum_type = enum_type
 		self.data_type = data_type
 		self.element_type = self.data_type.element_type
-		if self.element_type == DataType.Enum:
+		if self.element_type == DataType.Enum or self.element_type == DataType.EnumExt:
 			assert self.enum_type, f"For data_type {data_type.name}, you have to define the enum_type variable."
 
 	def get_value(self, data) -> str:
 		"""Returns SCPI string converted from the argument data."""
 		if self.data_type.is_list:
 			assert isinstance(data, list), f"Expected command parameter list, actual data type: {type(data)}. Value: {data}"
 		else:
 			assert not isinstance(data, list), f"Expected command parameter scalar, actual data type: {type(data)}. Value: {data}"
-
 		if self.data_type == DataType.Enum:
 			return enum_scalar_to_str(data, self.enum_type)
-		elif self.data_type == DataType.EnumList:
+		if self.data_type == DataType.EnumExt:
+			return enum_ext_scalar_to_str(data, self.enum_type)
+		if self.data_type == DataType.EnumList:
 			return enum_list_to_str(data, self.enum_type)
-
+		if self.data_type == DataType.EnumExtList:
+			return enum_ext_list_to_str(data, self.enum_type)
 		return value_to_scpi_string(data, self.data_type)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Internal/Core.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Internal/Core.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,28 +1,126 @@
-import re
+"""See the class docstring."""
+
 from typing import Callable
 
-from . import InstrumentOptions as Options, Conversions as Conv
+from . import InstrumentOptions as Options
 from .ArgSingle import ArgSingle
 from .ArgSingleList import ArgSingleList
 from .Conversions import BinFloatFormat, BinIntFormat
 from .Instrument import Instrument
-from .InstrumentSettings import InstrViClearMode, InstrumentSettings, WaitForOpcMode
-from .Utilities import parse_token_to_key_and_value, trim_str_response
+from .InstrumentSettings import InstrViClearMode, InstrumentSettings, WaitForOpcMode, OpcSyncQueryMechanism
+from .ScpiLogger import LoggingMode
+from .InstrumentErrors import RsInstrException
+from .Properties import Properties
 
 
 class Core(object):
 	"""Main driver component. Provides: \n
 		- Main core constructor
 		- 'io' interface for all the write / query operations
 		- Command parameters string composer for single arguments...
 		- Link handlers adding / changing / deleting
 
 		Version history:
 
+		1.70.0 (27.02.2024)
+			- Added settings profile 'XK41' for R&S Software Defined Radios.
+			- Added settings 'FirstCmds' where you can send the defined commands right after the init. Send more commands in a row with ';;' separator.
+			- Added settings 'EachCmdPrefix' - this prefix is added to each command sent to the instrument. Supported values are also 'lf', 'cr', 'tab'
+
+		1.60.0 (31.01.2024)
+			- Added Properties script for global properties.
+			- Added Properties.scpi_quotes, string option settings token: 'ScpiQuotes'. Example: ScpiQuotes=double. Default: Single
+			- Fixed VisaPluginSocketIo read() method for cases where the session is lost. The method now generates exception in that case.
+			- Added settings 'OpcSyncQueryMechanism' with values: Standard, AlsoCheckMav, ClsOnlyCheckMavErrQueue, OnlyCheckMavErrQueue
+
+		1.54.0 (27.06.2023)
+			- Added new options profile for ATS chambers.
+			- Added settings boolean token EachCmdAsQuery. Example: EachCmdAsQuery=True. Default: False
+
+		1.53.0 (18.10.2022)
+			- Improved mode where the instrument works with a session from another object.
+			- Silently ignoring invalid *IDN? string.
+			- Added new options profile 'Minimal' for non-SCPI-99 instruments.
+
+		1.52.0 (28.09.2022)
+			- Fixed DisableOpcQuery=True settings effect.
+			- Improved robustness of the TerminationCharacter option value entry.
+			- Added new options profile for CMQ500.
+
+		1.51.0 (08.09.2022)
+			- Changed the accepted IDN? response to more permissive.
+			- added methods go_to_remote() and go_to_local()
+			- added methods file_exists() and get_file_size()
+
+		1.50.0 (23.06.2022)
+			- Added relative timestamp to the logger.
+			- ScpiLogger can read GlobalData class variables making it possible to define common target and reference timestamp for all instances.
+			- Logger stream entries are by default immediately flushed, making sure that the log is complete.
+			- Added time statistic methods get_total_execution_time(), get_total_time(), reset_time_statistics().
+
+		1.24.0 (03.06.2022)
+			- Changed parsing of SYST:ERR? response to tolerate +0,"No Error" response.
+			- Added settings integer token OpenTimeout. Example: OpenTimeout=5000. Default: 0
+			- Added settings boolean token ExclusiveLock. Example: ExclusiveLock=True. Default: False
+
+		1.23.0 (24.05.2022)
+			- Added stripping of trailing commas when parsing the *IDN? response.
+			- If the Resource Manager does not find any default VISA implementation, it falls back to R&S VISA - relevant for LINUX or macOS
+			- Other typos and formatting corrections.
+
+		1.22.0 (20.04.2022)
+			- Added optional parameter timeout to reset()
+			- Added query list methods:  query_bool_list, query_bool_list_with_opc
+
+		1.21.0 (07.01.2022)
+			- Added logging to UDP port (49200) to integrate with new R&S Instrument Control plugin for Pycharm
+
+		1.20.0 (19.11.2021)
+			- Fixed logging strings when device name was a substring of the resource name
+
+		1.18.0 (build 64) 05.11.2021
+			- Added setting profile for non-standard instruments. Example of the options string: options='Profile=hm8123'
+
+		1.17.0 (build 63) 15.10.2021
+			- Added correct conversion of strings with SI suffixes (e.g.: MHz, KHz, THz, GHz, ms, us) to float and integer
+
+		1.16.0 (build 62) 31.08.2021
+			- Changed default encoding of string<=>bin from utf-8 to charmap.
+			- Added settable encoding for the session. Property: RsInstrument.encoding
+
+		1.15.0 (build 61) 17.08.2021
+			- Added support for EnumExt and EnumExtList
+			- Added support for custom scpi enums
+			- Improved exception handling in cases where the instrument session is closed.
+			- Fixed warning in Instrument.py
+			- Fixed Instrument.query_bin_block() for timeout errors
+			- Repeated capabilities are now allowed to be integer numbers as well
+
+		1.14.0 (build 53) 12.07.2021
+			- Scpi logger time entries now support not only datetime tuples, but also float timestamps
+			- changed handling of the syst:err? responses - now they are always Tuple (code, message)
+			- StatusException has new field errors_list: List[ Tuple[code, message] ]
+			- Added logger.log_status_check_ok property. This allows for skipping lines with 'Status check: OK'
+
+		1.12.0 (build 50) 26.06.2021
+			- Added SCPI Logger
+			- Simplified constructor's options string format - removed DriverSetup=() syntax:
+			Instead of "DriverSetup=(TerminationCharacter='\n')", you use "TerminationCharacter='\n'"
+			The original format is still supported.
+
+			- Fixed calling SYST:ERR? even if *STB? returned 0
+			- Replaced @ni backend with @ivi for resource manager - this is necessary for the future pyvisa version 1.12+
+
+		1.11.0 (build 49) 09.06.2021
+			- Added is_connection_active() + reconnect()
+
+		1.10.1 (build 47) 01.06.2021
+			- Fixed bug with error checking when events are defined
+
 		1.10.0 (build 46) 03.05.2021
 			- Added methods to Instrument: query_struct_with_opc(), query_str_suppressed_with_opc()
 
 		1.9.0 (build 45) 13.04.2021
 			- Added option to set callbacks before_write and before_query
 			- When a RepCap has a member with integer number 0 defined, the command string interpretation of such member is '0', not empty string
 
@@ -32,15 +130,15 @@
 		1.7.7 (build 42) 26.11.2020
 			- Extended ArgSingleList.compose_cmd_string() to 9 arguments
 
 		1.7.6 (build 41) 23.11.2020
 			- Extended data types for IntegerExt, FloatExt, IntegerExtArray, FloatExtArray
 
 		1.7.5 (build 40) 12.11.2020
-			- Extended Conversions method str_to_str_list() by parameter 'clear_one_empty_item' with default value False
+			- Extended 'Conversions' method str_to_str_list() by parameter 'clear_one_empty_item' with default value False
 
 		1.7.4 (build 39) 11.09.2020
 			- Fixed parsing of the instrument errors when an error message contains two double quotes
 
 		1.7.3 (build 38) 21.10.2020
 			- Added 'UND' to the list of float numbers that are represented as NaN
 
@@ -60,15 +158,15 @@
 
 		1.4.0 (build 32) 17.09.2020
 			- Added recognition of RsVisa library location for linux when using options string 'SelectVisa=rs'
 			- Fixed bug in reading binary data 16 bit
 
 		1.3.0 (build 31) 04.09.2020
 			- added DRIVERSETUP_QUERYOPT to the driver's option string
-			- *OPT? is no longer performed at the init, but only at the first access to options string.
+			- *OPT? is no longer performed at the init, but only at the first access to the options string.
 				In addition, the *OPT? query is executed with 1000 ms timeout, and the errors are suppressed
 
 		1.2.0 (build 30), 03.08.2020
 			- Fixed NRP-Z session parameters: vxi_capable = False, io_segment_size = 1000000
 
 		1.1.0 (build 29), 20.06.2020
 			- Added RepeatedCapability and base class CommandsGroup
@@ -89,85 +187,94 @@
 			reset: bool = False,
 			driver_options: str = None,
 			user_options: str = None,
 			direct_session: object = None):
 		"""Initializes new driver session. For cleaner code, use the class methods: \n
 		- Core.from_existing_session() - initializes a new Core with an existing pyvisa session."""
 
-		self.core_version = '1.9.0'
-		self.simulating = False
-		self.supported_idn_patterns = []
-		self.supported_instr_models = []
-
-		self._args_single_list = ArgSingleList()
-		sett_dr = self._parse_init_settings_string(driver_options)
-		self._apply_settings_to_core(sett_dr)
-		sett_user = self._parse_init_settings_string(user_options)
-		self._apply_settings_to_core(sett_user)
+		self.core_version = '1.55.0'
+		self.resource_name = resource_name
 
 		# Typical settings for the Core
 		self._instrumentSettings = InstrumentSettings(
 			InstrViClearMode.execute_on_all,  # Instrument viClear mode
 			False,  # Full model name. True: SMW200A, False: SMW
 			0,  # Delay by each write
 			0,  # Delay by each read
-			100000,  # Max chunk read / write size in bytes
+			1000000,  # Max chunk read / write size in bytes
 			WaitForOpcMode.stb_poll,  # Waiting for OPC Mode: Status byte polling
 			30000,  # OPC timeout
 			10000,  # VISA timeout
 			60000,  # Self-test timeout
 			Options.ParseMode.Auto,  # *OPT? response parsing mode
 			BinFloatFormat.Single_4bytes,  # Format for parsing of binary float numbers
 			BinIntFormat.Integer32_4bytes,  # Format for parsing of binary integer numbers
-			False  # OPC query after each setting
+			False,  # OPC query after each setting
+			LoggingMode.Off,
+			OpcSyncQueryMechanism.only_check_mav_err_queue
+			# Logging mode
 		)
 
-		self._instrumentSettings.apply_option_settings(sett_dr)
-		self._instrumentSettings.apply_option_settings(sett_user)
+		self._instrumentSettings.apply_option_settings(driver_options)
+		self._instrumentSettings.apply_option_settings(user_options)
 
-		# Resolve the direct_session to handle. Options for direct_session type:
-		# - VisaSession object, retrieved from the driver's RsInstrument.get_session_handle() method
-		# - string in case of a simulation session
-		handle = direct_session
-		if handle:
-			# Check if the entered 'direct_session' is either the driver object or the Visa session
-			if hasattr(direct_session, 'get_session_handle'):
-				assert hasattr(direct_session, '_core'), f"Direct session is a class type. It must be an instance of the top-level driver class."
-				handle = direct_session.get_session_handle()
-			# Check if the handle is not a simulation mode string
-			if isinstance(handle, str):
-				if "Simulating session, resource name " in handle:
-					self.simulating = True
-					handle = None
+		self.simulating = self._instrumentSettings.simulating
+		self.supported_idn_patterns = self._instrumentSettings.supported_idn_patterns
+		self.supported_instr_models = self._instrumentSettings.supported_instr_models
 
-		self.io = Instrument(resource_name, self.simulating, self._instrumentSettings, handle)
+		self._args_single_list = ArgSingleList()
+		handle = self._resolve_direct_session(direct_session)
+		self.io = Instrument(self.resource_name, self.simulating, self._instrumentSettings, handle)
 		self.io.query_instr_status = True
+		# Update the resource name if it changed, for example because of the direct session
+		self.resource_name = self.io.resource_name
+		self.allow_reconnect = self.io.allow_reconnect
 
-		self._apply_settings_to_instrument(sett_dr)
-		self._apply_settings_to_instrument(sett_user)
-
+		self._apply_settings_to_instrument(self._instrumentSettings)
+		self._apply_global_properties(self._instrumentSettings)
 		self.io.set_simulating_cmds()
 
 		if id_query:
 			self.io.fits_idn_pattern(self.supported_idn_patterns, self.supported_instr_models)
 
 		if reset:
 			self.io.reset()
 		else:
 			self.io.check_status()
 
 	@classmethod
 	def from_existing_session(cls, session: object, driver_options: str = None) -> 'Core':
 		"""Creates a new Core object with the entered 'session' reused."""
 		# noinspection PyTypeChecker
-		return cls(None, False, False, driver_options, None, session)
+		return cls(resource_name=None, id_query=False, reset=False, driver_options=driver_options, user_options=None, direct_session=session)
 
 	def __str__(self):
 		return f"Core session '{self.io.resource_name}'"
 
+	def _resolve_direct_session(self, direct_session):
+		# Resolve the direct_session to handle. Options for direct_session type:
+		# - VisaSession object, retrieved from the driver's RsInstrument.get_session_handle() method
+		# - string in case of a simulation session
+		handle = direct_session
+		if not direct_session:
+			return None
+		# Check if the entered 'direct_session' is either the driver object or the Visa session
+		if hasattr(direct_session, 'get_session_handle'):
+			if not hasattr(direct_session, '_core'):
+				raise RsInstrException('Direct session is a class type. It must be an instance of the top-level driver class.')
+			handle = direct_session.get_session_handle()
+		# If the handle is a simulating session, change the session to simulating and set disable the 'from existing session' feature
+		if isinstance(handle, str):
+			mand_string = 'Simulating session, resource name '
+			if mand_string in handle:
+				self.resource_name = handle[len(mand_string):].strip().strip("'").strip()
+				self.simulating = True
+				handle = None
+		return handle
+
 	def set_link_handler(self, link_name: str, handler: Callable) -> Callable:
 		"""Adds / Updates link handler for the entered link_name.
 		Handler API: handler(event_args: ArgLinkedEventArgs)
 		Returns the previous registered handler, or None if no handler was registered before."""
 		return self.io.set_link_handler(link_name, handler)
 
 	def del_link_handler(self, link_name: str) -> Callable:
@@ -176,82 +283,30 @@
 		return self.io.del_link_handler(link_name)
 
 	def del_all_link_handlers(self) -> int:
 		"""Deletes all the link handlers.
 		Returns number of deleted links."""
 		return self.io.del_all_link_handlers()
 
-	# noinspection PyMethodMayBeStatic
-	def _parse_init_settings_string(self, text: str) -> dict:
-		"""Parses init string to a dictionary of settings: name -> value."""
-		tokens = {}
-		if not text:
-			return tokens
-
-		# Text enclosed in single brackets '' must have the commas escaped
-		literal_pattern = r"'([^']+)'"
-		while True:
-			# literal loop
-			m = re.search(literal_pattern, text)
-			if not m:
-				break
-			lit_part = '"' + m.group(1).replace(',', '<COMMA_ESC>') + '"'
-			text = text.replace(m.group(0), lit_part)
-
-		# Remove all the class-options enclosed by round brackets e.g. "<groupName>=(<groupTokens>)"
-		group_pattern = r'(\w+)\s*=\s*\(([^\)]*)\)'
-		# Match class-settings, add them as separate keys with groupName_Key
-		while True:
-			# Group loop
-			m = re.search(group_pattern, text)
-			if not m:
-				break
-			text = text.replace(m.group(0), '')
-			group_name = m.group(1).upper()
-			group_tokens = m.group(2).strip().split(',')
-			for token in group_tokens:
-				key, value = parse_token_to_key_and_value(token)
-				if value:
-					tokens[f'{group_name}_{key.upper()}'] = value
-
-		# All groups are removed from the text, now we can use splitting on commas and remove white-space-only elements
-		for token in text.split(','):
-			key, value = parse_token_to_key_and_value(token.replace('<COMMA_ESC>', ','))
-			if value:
-				tokens[key.upper()] = value
-		return tokens
-
-	def _apply_settings_to_core(self, settings: dict) -> None:
-		"""Applies settings relevant for the Core from the dictionary."""
-		value = settings.get('SIMULATE')
-		if value:
-			self.simulating = Conv.str_to_bool(value)
-
-		value = settings.get('SUPPORTEDINSTRMODELS')
-		if value:
-			self.supported_instr_models = [*map(trim_str_response, value.split('/'))]
-
-		value = settings.get('SUPPORTEDIDNPATTERNS')
-		if value:
-			self.supported_idn_patterns = [*map(trim_str_response, value.split('/'))]
-
-	def _apply_settings_to_instrument(self, settings: dict) -> None:
-		"""Applies settings relevant for the Instrument from the dictionary."""
-		value = settings.get('QUERYINSTRUMENTSTATUS')
-		if value:
-			self.io.query_instr_status = Conv.str_to_bool(value)
-
-		value = settings.get('SIMULATIONIDNSTRING')
-		if value and self.simulating:
-			# Use the '*' instead of the ',' in the value to avoid comma as token delimiter
-			self.io.idn_string = value.replace('*', ',')
+	def _apply_settings_to_instrument(self, settings: InstrumentSettings) -> None:
+		"""Applies settings relevant for the Instrument from the InstrumentSettings structure."""
+		if settings.instrument_status_check is not None:
+			self.io.query_instr_status = settings.instrument_status_check
+		if self.simulating and settings.instrument_simulation_idn_string is not None:
+			self.io.idn_string = settings.instrument_simulation_idn_string
+
+	@staticmethod
+	def _apply_global_properties(settings: InstrumentSettings) -> None:
+		"""Applies settings valid for the entire module. All are available in the module 'Properties'."""
+		if settings.scpi_quotes is not None:
+			Properties.scpi_quotes = settings.scpi_quotes
 
 	def compose_cmd_arg_param(
 			self, arg1: ArgSingle, arg2: ArgSingle = None, arg3: ArgSingle = None, arg4: ArgSingle = None, arg5: ArgSingle = None, arg6: ArgSingle = None) -> str:
-		"""Composes command parameter string based on the single arguments definition."""
+		"""Composes command parameter string based on the single argument definition."""
 		return self._args_single_list.compose_cmd_string(arg1, arg2, arg3, arg4, arg5, arg6)
 
 	def get_last_sent_cmd(self) -> str:
 		"""Returns the last commands sent to the instrument. Only works in simulation mode"""
 		return self.io.get_last_sent_cmd()
 
 	def get_session_handle(self):
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Internal/InstrumentErrors.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Internal/InstrumentErrors.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,63 +1,79 @@
+"""Definition of RsInstrument exceptions, assert functions, and other error-related functions."""
+
+from typing import List, Tuple
+
+
 class RsInstrException(Exception):
 	"""Exception base class for all the RsInstrument exceptions."""
 	def __init__(self, message: str):
 		super(RsInstrException, self).__init__(message)
+		self.message = message
 
 
 class TimeoutException(RsInstrException):
 	"""Exception for timeout errors."""
 	def __init__(self, message: str):
 		super(TimeoutException, self).__init__(message)
 
 
 class StatusException(RsInstrException):
-	"""Exception for instrument status errors."""
-	def __init__(self, rsrc_name: str, message: str):
-		self.rsrc_name = rsrc_name
+	"""Exception for instrument status errors.
+	Tje field  errors_list contains the complete list of all the errors with messages and codes."""
+	def __init__(self, rsrc_name: str, message: str, errors_list: List[Tuple[int, str]], first_exc: Exception = None):
+		self.rsrc_name: str = rsrc_name
+		self.first_exc: Exception = first_exc
+		self.errors_list: List[Tuple[int, str]] = errors_list
 		super(StatusException, self).__init__(message)
 
 
 class UnexpectedResponseException(RsInstrException):
 	"""Exception for instrument unexpected responses."""
 	def __init__(self, rsrc_name: str, message: str):
-		self.rsrc_name = rsrc_name
+		self.rsrc_name: str = rsrc_name
 		super(UnexpectedResponseException, self).__init__(message)
 
 
 class ResourceError(RsInstrException):
 	"""Exception for resource name - e.g. resource not found."""
 	def __init__(self, rsrc_name: str, message: str):
-		self.rsrc_name = rsrc_name
+		self.rsrc_name: str = rsrc_name
 		super(ResourceError, self).__init__(message)
 
 
 class DriverValueError(RsInstrException):
 	"""Exception for different driver value settings e.g. RepCap values or Enum values."""
 	def __init__(self, rsrc_name: str, message: str):
-		self.rsrc_name = rsrc_name
+		self.rsrc_name: str = rsrc_name
 		super(DriverValueError, self).__init__(message)
 
 
-def assert_no_instrument_status_errors(rsrc_name: str, errors: list, context: str = '') -> None:
-	"""Checks the errors list and of it contains at least one element, it throws StatusException."""
-	if errors is None:
-		return
-	if len(errors) == 0:
+def get_instrument_status_errors(rsrc_name: str, errors: List[Tuple[int, str]], context: str = '') -> str or None:
+	"""Checks the errors list and of it contains at least one element, it returns the error message.
+	Otherwise, it returns None."""
+	if errors is None or len(errors) == 0:
 		return
 	if context:
 		message = f"'{rsrc_name}': {context} "
 	else:
 		message = f"'{rsrc_name}': "
+	errors_msg = '\n'.join([f'{x[0]},"{x[1]}"' for x in errors])
 	if len(errors) == 1:
-		message += f'Instrument error detected: {errors[0]}'
-		raise StatusException(rsrc_name, message)
+		message += f'Instrument error detected: {errors_msg}'
+		return message
 	if len(errors) > 1:
-		message += '{} Instrument errors detected:\n{}'.format(len(errors), '\n'.join(errors))
-		raise StatusException(rsrc_name, message)
+		message += f'{len(errors)} Instrument errors detected:\n{errors_msg}'
+		return message
+
+
+def assert_no_instrument_status_errors(rsrc_name: str, errors: List[Tuple[int, str]], context: str = '', first_exc=None) -> None:
+	"""Checks the errors list and of it contains at least one element, it throws StatusException."""
+	msg = get_instrument_status_errors(rsrc_name, errors, context)
+	if msg:
+		raise StatusException(rsrc_name, msg, errors, first_exc=first_exc)
 
 
 def throw_opc_tout_exception(opc_tout: int, used_tout: int, context: str = '') -> None:
 	"""Throws TimeoutException - use it for any timeout error."""
 	if not context:
 		message = ''
 	else:
@@ -83,21 +99,21 @@
 
 def assert_query_has_qmark(query: str, context: str = '') -> None:
 	"""Throws Exception if the query does not contain any question marks."""
 	if '?' in query:
 		return
 	message = ''
 	if context:
-		message = ' ' + context
+		message = context.strip() + ': '
 	message = message + "Query commands must contain question-marks. Sent query: '{0}'".format(query.strip('\n'))
-	raise Exception(message)
+	raise RsInstrException(message)
 
 
 def assert_cmd_has_no_qmark(command: str, context: str = '') -> None:
 	"""Throws Exception if the query contains a question marks."""
 	if '?' not in command:
 		return
 	message = ''
 	if context:
-		message = ' ' + context
+		message = context.strip() + ': '
 	message = message + "Set commands must not contain question-marks. Sent command: '{0}'".format(command.strip('\n'))
-	raise Exception(message)
+	raise RsInstrException(message)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Internal/InstrumentOptions.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Internal/InstrumentOptions.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,7 +1,9 @@
+"""See the class docstring."""
+
 import re
 from enum import Enum
 
 from .Utilities import trim_str_response
 
 
 class ParseMode(Enum):
@@ -10,14 +12,15 @@
 	KeepOriginal = 1
 	KeepBeforeDash = 2
 	KeepAfterDash = 3
 	Auto = 4
 
 
 class Options(object):
+	"""Class for handling the instrument options - parsing from the *OPT? string and providing method get_all()"""
 	_optionsList = []
 
 	def __init__(self, options_str: str, mode=ParseMode.Auto):
 		"""Initializes the options with the *OPT? return string."""
 		self._initialize_from_string(options_str, mode)
 
 	def __str__(self):
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Internal/InternalLinker.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Internal/InternalLinker.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,13 +1,16 @@
+"""Links a variable from a structure to a callback in the driver."""
+
 from time import time
 from typing import Dict, Callable
 
 from . import ArgSingle, ArgSingleSuppressed
 from .ArgLinkedEventArgs import ArgLinkedEventArgs
 from .Utilities import get_plural_string
+from .InstrumentErrors import RsInstrException
 
 
 class InternalLinker(object):
 	"""Class for:
 		- cutting out suppressed arguments from a device response.
 		- invoking a handler if the argument has InternalLinking defined.
 		- holds dictionary of handlers where the dict_key is the InternalLinking string.
@@ -44,22 +47,22 @@
 		Returns number of deleted links."""
 		count = len(self._handlers)
 		self._handlers = {}
 		return count
 
 	def cut_from_response_string(self, arg: ArgSingleSuppressed, response: str, context: str) -> str:
 		"""Takes the string 'response', removes the suppressed argument value from it and returns the rest.
-		The cut out part is sent via handler if the internal linking exists for that argument exists."""
+		The cut-out part is sent via handler if the internal linking exists for that argument exists."""
 		result = ''
 		if arg.argument_ix is None:
-			raise Exception(f'Argument has argument_ix attribute not assigned (equals None). Argument: {arg}')
+			raise RsInstrException(f'Argument has argument_ix attribute not assigned (equals None). Argument: {arg}')
 		if arg.argument_ix != 0:
-			raise Exception(f'Only arguments with index 0 can be suppressed. Argument: {arg}')
+			raise RsInstrException(f'Only arguments with index 0 can be suppressed. Argument: {arg}')
 		if arg.is_open_list:
-			raise Exception(f'Open List arguments can not be suppressed. Argument: {arg}')
+			raise RsInstrException(f'Open List arguments can not be suppressed. Argument: {arg}')
 		repetition = 0
 		i = 0
 		for c in response:
 			if c == ',':
 				repetition += 1
 			if repetition == arg.repetition:
 				break
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Internal/IoTransferEventArgs.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Internal/IoTransferEventArgs.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,7 +1,9 @@
+"""See the docstring for the IoTransferEventArgs class."""
+
 import itertools
 from typing import AnyStr
 
 from .Utilities import size_to_kb_mb_string
 
 
 class IoTransferEventArgs(object):
@@ -48,25 +50,25 @@
 		return cls(True, opc_sync, None, context)
 
 	@classmethod
 	def write_str(cls, opc_sync: bool, total_size: int, context: str) -> 'IoTransferEventArgs':
 		"""Creates new IoTransferEventArgs of write string \n
 		:param opc_sync: defines if the command is OPC-synchronised
 		:param total_size: size of the data to write
-		:param context: SCPI command write. It is truncated to maximum of 100 characters.
-		:return: IoTransferEventArgs object of a write string operation."""
+		:param context: SCPI command write. It is truncated to maximum of 100 characters
+		:return: IoTransferEventArgs object of a write-string operation."""
 		obj = cls(False, opc_sync, total_size, context)
 		obj.binary = False
 		return obj
 
 	@classmethod
 	def write_bin(cls, context: str) -> 'IoTransferEventArgs':
 		"""Creates new IoTransferEventArgs of read binary data \n
 		:param context: SCPI command. It is truncated to maximum of 100 characters.
-		:return: IoTransferEventArgs object of a write binary data operation."""
+		:return: IoTransferEventArgs object of a write-binary-data operation."""
 		# noinspection PyTypeChecker
 		obj = cls(False, False, None, context.rstrip())
 		obj.binary = True
 		return obj
 
 	def __str__(self):
 		if self.binary:
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Internal/RepeatedCapability.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Internal/RepeatedCapability.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,7 +1,9 @@
+"""See the docstring for the RepeatedCapability class."""
+
 from enum import Enum
 
 
 # Command integer value that signals Default value "DEFAULT"
 VALUE_DEFAULT = -1
 
 # Command integer value that signals "EMPTY"
@@ -26,39 +28,47 @@
 	def __str__(self) -> str:
 		out = f'RepCap {self.name}'
 		if self._enum_value is not None:
 			out += f" = {self._enum_value}"
 		return out
 
 	@classmethod
-	def clsm_assert_type(cls, enum_value: Enum, enum_type) -> None:
-		"""Static assertion function to check if the entered value is a member of the defined repcap enum"""
+	def clsm_assert_type(cls, enum_value: Enum or int, enum_type) -> None:
+		"""Static assertion function to check if the entered value is a member of the defined repcap enum.
+		In addition, the integer value is also supported."""
+		if isinstance(enum_value, int):
+			return
 		if not isinstance(enum_value, enum_type):
 			raise TypeError(f"RepCap value must be of type '{enum_type}'. Entered value type: {type(enum_value)}, value '{enum_value}'")
 
 	@classmethod
-	def clsm_get_direct_cmd_value_int(cls, enum_value: Enum, enum_type) -> int:
+	def clsm_get_direct_cmd_value_int(cls, enum_value: Enum or int, enum_type) -> int:
 		"""Static function to get an integer interpretation of a direct enum value
 		Does not work with Empty or Default"""
 		RepeatedCapability.clsm_assert_type(enum_value, enum_type)
+		if isinstance(enum_value, int):
+			return enum_value
 		return enum_value.value
 
 	@classmethod
-	def clsm_is_default_value(cls, enum_value: Enum, enum_type) -> bool:
+	def clsm_is_default_value(cls, enum_value: Enum or int, enum_type) -> bool:
 		"""Returns True, if the entered value is enum.Default"""
 		return cls.clsm_get_direct_cmd_value_int(enum_value, enum_type) == VALUE_DEFAULT
 
 	def is_default_value(self) -> bool:
 		"""Returns True, if the repcap value is enum.Default"""
 		return RepeatedCapability.clsm_is_default_value(self._enum_value, self.enum_type)
 
-	def set_enum_value(self, enum_value: Enum) -> None:
+	def set_enum_value(self, enum_value: Enum or int) -> None:
 		"""Sets new enum value. Can not be Default"""
 		if RepeatedCapability.clsm_is_default_value(enum_value, self.enum_type):
 			raise ValueError(f"Setting RepCap enum value '{enum_value}' is not allowed. Please select a concrete value")
+		if isinstance(enum_value, int):
+			# Find the enum value that corresponds to the entered integer value
+			enum_value = self.enum_type(enum_value)
 		self._enum_value = enum_value
 
 	def get_enum_value(self) -> Enum:
 		"""Returns the actual enum value"""
 		return self._enum_value
 
 	def set_to_start_value(self) -> None:
@@ -66,16 +76,17 @@
 		self.set_enum_value(self._start_value)
 
 	def matches_type(self, enum_type) -> bool:
 		"""Returns true, if the entered type matches the EnumType"""
 		return self.enum_type == enum_type
 
 	@classmethod
-	def clsm_get_cmd_string_value(cls, enum_value: Enum, enum_type) -> str:
-		"""Converts RepCap integer value to string
+	def clsm_get_cmd_string_value(cls, enum_value: Enum or int, enum_type) -> str:
+		"""Class method version of the get_cmd_string_value().
+		Converts RepCap integer value to string
 		ValueEmpty is converted to "" (Not valid, but tolerated)
 		ValueDefault throws an exception
 		0 is converted to "" (Not valid, but tolerated)
 		Positive numbers are converted to integer strings e.g. 1 => '1' """
 		number = cls.clsm_get_direct_cmd_value_int(enum_value, enum_type)
 		if number == VALUE_EMPTY:
 			return ''
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Internal/StreamReader.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Internal/StreamReader.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,15 +1,19 @@
+"""See the docstring for the StreamReader class."""
+
 from enum import Enum
 from os import path
 from typing import AnyStr
 
 from .Utilities import size_to_kb_mb_string
+from .InstrumentErrors import RsInstrException
 
 
 class Type(Enum):
+	"""Defines type of the stream - variable or file."""
 	Variable = 1
 	File = 2
 
 
 class StreamReader:
 	"""Lightweight stream reader implementation. Data source can be: \n
 	- variable
@@ -21,31 +25,32 @@
 		:param source: Source type for the stream. Variable / File
 		:param data: Depending on the 'binary' and 'source':
 		For source type Variable the data must be either bytes() or str
 		For source type File data must be string with existing file path."""
 		self._source = source
 		self._binary = binary
 		self._start_ptr = 0
+		self._read_len = 0
 
 		if self._source == Type.Variable:
 			if self._binary:
 				assert isinstance(data, bytes), f'Data must be of bytes type. Actual type: {type(data)}'
 			else:
 				assert isinstance(data, str), f'Data must be of string type. Actual type: {type(data)}'
 			self._data = data
 			self._full_len = len(self._data)
 		elif self._source == Type.File:
 			assert isinstance(data, str), f'Data must be of string type (file path). Actual type: {type(data)}'
 			if not path.isfile(data):
-				raise Exception(f'File does not exist. File path: {data}')
+				raise RsInstrException(f'File does not exist. File path: {data}')
 			self.file_path = data
 			self._data = open(self.file_path, 'rb' if self._binary else 'r')
 			self._full_len = path.getsize(self.file_path)
 		else:
-			raise Exception(f'StreamReader unknown type {source}')
+			raise RsInstrException(f'StreamReader unknown type {source}')
 
 	@classmethod
 	def as_bin_var(cls, data: bytes) -> 'StreamReader':
 		"""Creates new StreamReader from bytes.
 		:param data: [bytes] data for the stream."""
 		return cls(True, Type.Variable, data)
 
@@ -100,29 +105,34 @@
 		If the remaining length is smaller than the chunk_size, the method returns the remaining length only.
 		:param chunk_size: chunk to read. If not set, the method reads the entire data."""
 		assert self._data is not None, 'StreamReader buffer is invalid. You have probably closed it already.'
 		chunk_size = len(self) if chunk_size is None else chunk_size
 		chunk_size = min(chunk_size, len(self))
 		if chunk_size < 0:
 			raise ValueError(f'Chunk size can not be negative number: {chunk_size}')
-
+		self._read_len += chunk_size
 		if self._source == Type.Variable:
 			self._start_ptr += chunk_size
 			return self._data[self._start_ptr - chunk_size: self._start_ptr]
 		elif self._source == Type.File:
 			self._start_ptr += chunk_size
 			return self._data.read(chunk_size)
 
-	def read_as_binary(self, chunk_size: int = None) -> bytes:
+	@property
+	def read_len(self) -> int:
+		"""Returns number of bytes read from the stream since its creation."""
+		return self._read_len
+
+	def read_as_binary(self, encoding: str, chunk_size: int = None) -> bytes:
 		"""Same as read(), but always returns the data in binary format.
 		Practically works exactly as read() for binary streams.
-		For string streams, the method converts the returned data using utf-8 encoding to bytes()."""
+		For string streams, the method converts the returned data using the provided encoding to bytes()."""
 		if self._binary:
 			return self.read(chunk_size)
 		else:
-			return self.read(chunk_size).encode('utf-8')
+			return self.read(chunk_size).encode(encoding)
 
 	def close(self):
 		"""Closes the StreamReader. You can not use its instance afterwards."""
 		if self._source == Type.File and self._data:
 			self._data.close()
 		self._data = None
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Internal/StreamWriter.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Internal/StreamWriter.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,17 +1,23 @@
+"""See the docstring for the StreamWriter class."""
+
 from enum import Flag
 from typing import AnyStr
+from io import BytesIO, StringIO
 
 from .Utilities import size_to_kb_mb_string
+from .InstrumentErrors import RsInstrException
 
 
 class Type(Flag):
+	"""Defines type of the stream - variable or file."""
 	Variable = 1
-	File = 2
-	FileAppend = 6
+	Forget = 2
+	File = 4
+	FileAppend = 12
 
 
 class StreamWriter:
 	"""Lightweight stream writer implementation. Data target can be: \n
 	- bytes
 	- string
 	- file"""
@@ -19,41 +25,48 @@
 	def __init__(self, binary: bool, target: Type, meta_data=None):
 		"""Initializes StreamWriter instance.\n
 		:param binary: True: Binary data, False: ASCII data
 		:param target: Target for the stream. Variable / File (FileAppend)
 		:param meta_data: Only valid for File and FileAppend - define file path as string:
 		For Type.File, data must be string with file path. If the file exists, it will be overwritten.
 		For Type.FileAppend, data must be string with file path. If the file exists, it will be appended."""
-		self._binary = binary
-		self._written_len = 0
+		self._binary: bool = binary
+		self._written_len: int = 0
 		self._target = target
 
 		if Type.Variable in self._target:
 			assert meta_data is None, f'You can not define input meta_data for a Variable StreamWriter.'
-			self._data: AnyStr = bytes() if binary else ''
+			self._data = BytesIO() if binary else StringIO()
+		elif Type.Forget in self._target:
+			self._data: AnyStr = ''
 		elif Type.File in self._target:
 			assert isinstance(meta_data, str), f'Additional data must be of string type (file path). Actual type: {type(meta_data)}'
 			self._file_path = meta_data
 			mode = 'w' if self._target == Type.File else 'a'
 			mode += 'b' if self._binary else ''
 			self._data = open(self._file_path, mode)
 		else:
-			raise Exception(f'StreamWriter unknown target {target}')
+			raise RsInstrException(f'StreamWriter unknown target {target}')
 
 	@classmethod
 	def as_bin_var(cls) -> 'StreamWriter':
 		"""Creates new StreamWriter with bytes variable."""
 		return cls(True, Type.Variable)
 
 	@classmethod
 	def as_string_var(cls) -> 'StreamWriter':
 		"""Creates new StreamWriter with string variable."""
 		return cls(False, Type.Variable)
 
 	@classmethod
+	def as_forget(cls) -> 'StreamWriter':
+		"""Creates new StreamWriter which writes to nowhere - forgets the data."""
+		return cls(False, Type.Forget)
+
+	@classmethod
 	def as_bin_file(cls, file_path: str, append: bool = False) -> 'StreamWriter':
 		"""Creates new StreamWriter to binary file.
 		:param file_path: [str] Path to the file.
 		:param append: Optional [bool] If True, the content is appended to the existing content."""
 		return cls(True, Type.FileAppend if append else Type.File, file_path)
 
 	@classmethod
@@ -67,14 +80,16 @@
 		if Type.Variable in self._target:
 			mode = 'binary' if self._binary else 'string'
 			return f'StreamWriter {mode} variable, current size {size_to_kb_mb_string(len(self), True)}'
 		if Type.File in self._target:
 			mode = 'binary' if self._binary else 'text'
 			append = ' appended' if Type.FileAppend in self._target else ''
 			return f'StreamWriter {mode} file{append}, current{append} size {size_to_kb_mb_string(len(self), True)}, file: {self._file_path}'
+		if Type.Forget in self._target:
+			return 'StreamWriter to nowhere.'
 
 	def __len__(self):
 		"""Returns remaining length."""
 		return self._written_len
 
 	def __enter__(self):
 		return self
@@ -88,49 +103,62 @@
 		File streams are always binary."""
 		return self._binary
 
 	def write(self, data: AnyStr) -> None:
 		"""Writes chunk to the stream.
 			- For Type.Bytes data must be bytes.
 			- For Type.String, data must be string.
-			- For Type.File and Type.FileAppend, data must be bytes"""
+			- For Type.File and Type.FileAppend, data must be bytes."""
+		if Type.Forget in self._target:
+			self._written_len += len(data)
+			return
+
 		assert self._data is not None, 'StreamWriter buffer is invalid. You have probably closed it already.'
 		if self._binary:
 			assert isinstance(data, bytes), f'Bytes data is required. Actual type: {type(data)}. {self}'
 		else:
 			assert isinstance(data, str), f'String data is required. Actual type: {type(data)}. {self}'
-
 		if Type.Variable in self._target:
-			self._data += data
+			self._data.write(data)
 		elif Type.File in self._target:
 			self._data.write(data)
 		self._written_len += len(data)
 
-	def switch_to_string_data(self) -> None:
+	def switch_to_string_data(self, encoding: str) -> None:
 		"""Switches from binary to string data.
-		For variables, the current content is converted.
+		For variables, the current content is converted to string using the provided encoding.
 		For files, they are closed and reopened as for appended text writing."""
 		if self._binary is False:
 			return
 		self._binary = False
 		if Type.Variable in self._target:
-			if len(self) == 0:
-				self._data = ''
-			else:
-				# noinspection PyUnresolvedReferences
-				self._data = self._data.decode('utf-8')
+			self._data = StringIO(self.content.decode(encoding))
 		elif Type.File in self._target:
 			self._data.close()
 			self._data = open(self._file_path, 'a')
 
+	# noinspection PyTypeChecker
 	@property
 	def content(self) -> AnyStr:
-		"""Returns content of the writer. Does only work with variable types."""
-		assert Type.Variable in self._target, f'Can not return content for the current {self}'
+		"""Returns content of the writer. Only works with variable types."""
+		if self._target == Type.Forget:
+			return ''
+		if self._target != Type.Variable:
+			raise RsInstrException(f'Can not return content for the current {self}')
 		# noinspection PyTypeChecker
-		return self._data
+		if not self._data:
+			return None
+		self._data.seek(0)
+		ret_val = self._data.read()
+		self._data.close()
+		return ret_val
+
+	@property
+	def written_len(self) -> int:
+		"""Returns number of bytes written to the stream since its creation."""
+		return self._written_len
 
 	def close(self) -> None:
 		"""Closes the StreamWriter. You can not use its instance afterwards."""
 		if Type.File in self._target and self._data:
 			self._data.close()
 		self._data = None
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Internal/StructBase.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Internal/StructBase.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,20 +1,22 @@
+"""See the docstring for the StructBase class."""
+
 from .Types import DataType
 
 
 class StructBase:
 	"""Base class for all the driver's argument structures."""
 	def __init__(self, owner):
 		self.__meta_args_link = dict()
 		ix = 0
 		for arg in self.__get_meta_args_list(owner):
 			arg.argument_ix = ix
 			ix += 1
 
-			if arg.data_type == DataType.Enum or arg.data_type == DataType.EnumList:
+			if arg.data_type in [DataType.Enum, DataType.EnumExt, DataType.EnumList, DataType.EnumExtList]:
 				assert arg.enum_type, f"Struct Argument '{arg.name}' is of enum type, you must define the parameter 'enum_type'"
 			else:
 				assert not arg.enum_type, f"Struct Argument '{arg.name}' data type is '{arg.data_type.name}'. You must set the parameter 'enum_type' to None"
 
 			if arg.is_optional:
 				# set all optional values to None
 				setattr(self, arg.name, None)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Internal/Types.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Internal/Types.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,54 +1,70 @@
+"""Data type class for the variables containing all the methods related to data types."""
+
 from enum import Enum, auto
 from typing import Any
 
 
+# noinspection PyArgumentList
 class DataType(Enum):
-	"""Data type of a variable in the driver."""
+	"""Data type of variable in the driver."""
 	String = auto()
 	RawString = auto()
 	Integer = auto()
 	IntegerExt = auto()
 	Boolean = auto()
 	Float = auto()
 	FloatExt = auto()
 	Enum = auto()
+	EnumExt = auto()
 	StringList = auto()
 	RawStringList = auto()
 	IntegerList = auto()
 	IntegerExtList = auto()
 	BooleanList = auto()
 	FloatList = auto()
 	FloatExtList = auto()
 	EnumList = auto()
+	EnumExtList = auto()
 
 	@property
 	def is_list(self) -> bool:
 		"""Returns True, if the data type is a list."""
 		return self in frozenset(
 			{
 				DataType.StringList,
 				DataType.RawStringList,
 				DataType.IntegerList,
 				DataType.IntegerExtList,
 				DataType.BooleanList,
 				DataType.FloatList,
 				DataType.FloatExtList,
-				DataType.EnumList
+				DataType.EnumList,
+				DataType.EnumExtList
 			})
 
 	@property
 	def is_scalar(self) -> bool:
 		"""Returns True, if the data type is a scalar."""
 		return not self.is_list
 
 	@property
+	def is_scalar_enum(self) -> bool:
+		"""Returns True, if the data type is a scalar enum or enum_ext."""
+		return self == DataType.Enum or self == DataType.EnumExt
+
+	@property
+	def is_list_enum(self) -> bool:
+		"""Returns True, if the data type is a list enum or list enum_ext."""
+		return self == DataType.EnumList or self == DataType.EnumExtList
+
+	@property
 	def is_enum(self) -> bool:
-		"""Returns True, if the data type is enum or enum array."""
-		return self == DataType.Enum or self == DataType.EnumList
+		"""Returns True, if the data type is enum or enum array - including the extended."""
+		return self in [DataType.Enum, DataType.EnumExt, DataType.EnumList, DataType.EnumExtList]
 
 	@property
 	def is_raw_string(self) -> bool:
 		"""Returns True for raw string and raw string list."""
 		return self == DataType.RawString or self == DataType.RawStringList
 
 	@property
@@ -81,14 +97,16 @@
 			return DataType.IntegerExt
 		elif self == DataType.FloatList:
 			return DataType.Float
 		elif self == DataType.FloatExtList:
 			return DataType.FloatExt
 		elif self == DataType.EnumList:
 			return DataType.Enum
+		elif self == DataType.EnumExtList:
+			return DataType.EnumExt
 
 	def get_default_value(self, enm: Enum = None) -> Any:
 		"""Returns default value for the current type.
 		If the data type is Enum or EnumString, you have to provide the enum class."""
 		if self.is_list:
 			return []
 		if self == DataType.RawString:
@@ -103,7 +121,9 @@
 			return 0
 		elif self == DataType.Float:
 			return 0.0
 		elif self == DataType.FloatExt:
 			return 0.0
 		elif self == DataType.Enum:
 			return enm(0)
+		elif self == DataType.EnumExt:
+			return enm(0)
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Internal/Utilities.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Internal/Utilities.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,7 +1,9 @@
+"""Utilities for string manipulation and string formatting for the user."""
+
 from enum import Flag
 from typing import Tuple
 
 
 class TrimStringMode(Flag):
 	"""Trimming mode for strings."""
 	white_chars_only = 1
@@ -133,7 +135,41 @@
 
 
 def calculate_chunks_count(data_size: int, chunk_size: int) -> int:
 	"""Returns number of chunks needed to transfer the data_size split to maximum of chunk_size blocks. \n
 	:param data_size: total data size
 	:param chunk_size: maximum size of one block"""
 	return (data_size // chunk_size) + (1 if (data_size % chunk_size) > 0 else 0)
+
+
+def escape_nonprintable_chars(string: str, encoding: str = 'charmap') -> str:
+	"""
+	Replace nonprintable characters in string s by its hex representation.
+	"""
+	if string.isprintable():
+		return string
+	new_string = ''
+	for char in string:
+		if char.isprintable():
+			new_string += char
+		elif char == '\n':
+			new_string += r'\n'
+		elif char == '\r':
+			new_string += r'\r'
+		elif char == '\t':
+			new_string += r'\t'
+		else:
+			byte = bytes(char, encoding)
+			char = byte.hex()
+			new_string += r'\x' + char
+	return new_string
+
+
+def shorten_string_middle(string: str, max_len: int) -> str:
+	"""If the length of the string is bigger than the max_len,
+	the middle of the string is abbreviated with ' .... ' """
+	count = len(string)
+	if count <= max_len:
+		return string
+	half = int((max_len - 6) / 2)
+	md = (max_len - 6) % 2
+	return string[:half + md] + ' .... ' + string[(count - half):]
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Internal/VisaPluginSocketIo.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Internal/VisaPluginSocketIo.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,23 +1,28 @@
+"""See the docstring for the SocketIo class."""
+
 import socket
 import re
 from contextlib import contextmanager
+from typing import Any
+
+from .InstrumentErrors import RsInstrException
 
 # noinspection PyPackageRequirements
 import pyvisa
 
 
 class SocketIo:
-
+	"""Socket IO plugin providing implementations for all the necessary VISA functions. This class does not need the underlying VISA installation."""
 	def __init__(self, resource_name: str):
 		self.session = socket.socket()
 		self.resource_name = resource_name
 		m = re.search(r'TCPIP::([^:]+)::([^:]+)::SOCKET', self.resource_name)
 		if not m:
-			raise Exception(f"SocketIO instrument unsupported resource name. '{self.resource_name}' Supported resource name example: 'TCPIP::192.168.1.100::5025::SOCKET'")
+			raise RsInstrException(f"SocketIO instrument unsupported resource name. '{self.resource_name}' Supported resource name example: 'TCPIP::192.168.1.100::5025::SOCKET'")
 		self.host = m.group(1).strip()
 		self.port = int(m.group(2).strip())
 		self._read_termination = None
 		self._chunk_size = 1024
 		self._timeout = 5000
 		self.visalib = VisaLib(self)
 
@@ -90,14 +95,22 @@
 
 	# noinspection PyUnusedLocal
 	def read_bytes(self, count: int, **kwargs) -> bytes:
 		"""Reads count bytes"""
 		data, status = self.visalib.read(self.session, count)
 		return data
 
+	def go_to_local(self) -> None:
+		"""Puts the instrument into local state."""
+		self.write("&GTL")
+
+	def go_to_remote(self) -> None:
+		"""Puts the instrument into remote state."""
+		self.write("&GTR")
+
 	# noinspection PyUnusedLocal
 	@contextmanager
 	def ignore_warning(self, filter_value: int) -> None:
 		"""Context property with no effect for the socket connection"""
 		try:
 			yield None
 		finally:
@@ -106,15 +119,15 @@
 
 	def close(self) -> None:
 		"""Closes the socket connection"""
 		self.session.close()
 
 
 class VisaLib:
-
+	"""Implementation of the pyvisa's VisaLib providing the method read()"""
 	def __init__(self, socket_io: SocketIo):
 		self._socket_io = socket_io
 
 	def __str__(self):
 		return "SocketIO"
 
 	# noinspection PyUnresolvedReferences
@@ -127,14 +140,16 @@
 
 		try:
 			while True:
 				to_read_len = chunk_size - read_len
 				if to_read_len <= 0:
 					break
 				data = session.recv(to_read_len)
+				if not data:
+					raise pyvisa.VisaIOError(pyvisa.constants.VI_ERROR_CONN_LOST)
 				chunk += data
 				read_len += len(data)
 
 				if self._socket_io.read_termination is not None:
 					# Read termination character is ON, look for it and stop the reading if found
 					term_char = self._socket_io.read_termination.encode()
 					if term_char in data:
@@ -159,17 +174,18 @@
 				more_data_available = True
 
 		return_code = pyvisa.constants.StatusCode.success_max_count_read if more_data_available else pyvisa.constants.StatusCode.success
 		return chunk, return_code
 
 
 class ResourceManager:
-
+	"""Implementation of the VISA's Resource Manager."""
 	def __init__(self):
 		self.VisaManufacturerName = "SocketIO"
 		self.connection = None
 
-	def open_resource(self, resource_name: str) -> SocketIo:
-		"""Creates new Socket connection"""
+	# noinspection PyUnusedLocal
+	def open_resource(self, resource_name: str, access_mode: Any = None, open_timeout: Any = None) -> SocketIo:
+		"""Creates new Socket connection. access_mode and open_timeout are here for compatibility reasons with the pyvisa rm.open_resource()"""
 		self.connection = SocketIo(resource_name)
 		self.connection.connect()
 		return self.connection
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Internal/VisaSession.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Internal/VisaSession.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,20 +1,23 @@
+"""Visa Session is an extension of the pure VISA providing higher level of methods regardless of the session kind."""
+
 import time
 from enum import Enum, Flag
-from typing import Tuple, Callable, AnyStr
+from typing import List, Tuple, Callable, AnyStr
 import os.path
 import re
 import threading
 
 # noinspection PyPackageRequirements
 import pyvisa
+from pyvisa.errors import StatusCode
 
 from .VisaPluginSocketIo import ResourceManager, SocketIo
 from . import InstrumentSettings, InstrumentErrors, Conversions as Conv
-from .InstrumentSettings import WaitForOpcMode, InstrViClearMode as ViClearMode
+from .InstrumentSettings import WaitForOpcMode, OpcSyncQueryMechanism, InstrViClearMode as ViClearMode
 from .StreamReader import StreamReader
 from .StreamWriter import StreamWriter
 from .Utilities import size_to_kb_mb_string, calculate_chunks_count
 import platform
 import struct
 
 
@@ -37,14 +40,16 @@
 	bin_known_len = 3
 	bin_unknown_len = 4
 
 
 class StatusByte(Flag):
 	"""Status Byte flags."""
 	NONE = 0x00
+	custom_bit_0 = 0x01
+	custom_bit_1 = 0x02
 	error_queue_not_empty = 0x04
 	questionable_status_reg = 0x08
 	message_available = 0x10
 	event_status_byte = 0x20
 	request_service = 0x40
 	operation_status_reg = 0x80
 
@@ -64,14 +69,22 @@
 		# noinspection PyTypeChecker
 		self._data_chunk_size: int = None
 		self._std_bin_block_header_max_len: int = 999999999
 		self._lock = None
 		self.disable_opc_query: bool = settings.disable_opc_query
 		self.last_status = None
 		self.visa_library_name = None
+		self.resource_name = resource_name  # might be changed later if direct_session is used
+		self.encoding = settings.encoding  # default encoder between bytes and string
+		self.cmd_idn = settings.cmd_idn
+		self.skip_status_system_setting = settings.skip_status_system_setting
+		self.skip_clear_status = settings.skip_clear_status
+		self.stb_in_error_check = settings.stb_in_error_check
+		self.opc_sync_query_mechanism = settings.opc_query_sync_mechanism
+		self.each_cmd_prefix = settings.each_cmd_prefix
 
 		# Implemented for interface compatibility with VisaSessionSim
 		self.cached_to_stream = False
 
 		# Event handlers
 		# noinspection PyTypeChecker
 		self.on_read_chunk_handler: Callable = None
@@ -80,36 +93,36 @@
 		self.on_write_chunk_handler: Callable = None
 		"""If assigned a handler, the VisaSession sends it event on each write chunk transfer."""
 		self.io_events_include_data: bool = False
 		"""If true, the VisaSession events sent to on_read_chunk_handler and on_write_chunk_handler contain transferred data."""
 
 		if self.reusing_session:
 			# Reuse the session
-			assert isinstance(direct_session, pyvisa.Resource) or isinstance(direct_session, SocketIo), f"Direct_session must be a VISA resource object. Actual type: '{type(direct_session)}', value: '{direct_session}'"
-			self._session = direct_session
-			self._resource_name = self._session.resource_name
+			self._session = VisaSession.get_and_check_direct_session(direct_session)
+			self.resource_name = self._session.resource_name
 		else:
 			# Create new session
 			# Check resource_name for the trailing (SelectVisa=..)
 			pure_resource_name, visa_select = self._get_pure_resource_name(resource_name)
 			if settings.visa_select is not None:
 				visa_select = settings.visa_select
 			self._rm = VisaSession.get_resource_manager(visa_select)
 			self.manufacturer = self._get_visa_manufacturer()
 
 			# Resource manager opening
 			try:
-				self._session = self._rm.open_resource(pure_resource_name)
+				acc_mode = pyvisa.constants.AccessModes.no_lock if settings.exclusive_lock is False else pyvisa.constants.AccessModes.exclusive_lock
+				self._session = self._rm.open_resource(resource_name=pure_resource_name, open_timeout=settings.open_timeout, access_mode=acc_mode)
 			except pyvisa.VisaIOError as e:
 				if e.error_code != pyvisa.constants.StatusCode.error_resource_not_found:
 					raise e
 				message = e.description
 				message += f"\nLibrary: {self._rm.visalib}\nManufacturer: {self.manufacturer}\nResource Name: '{resource_name}'"
 				raise InstrumentErrors.ResourceError(resource_name, message)
-			self._resource_name = resource_name
+			self.resource_name = resource_name
 
 		# Decide, whether to create a new thread lock or the existing one from the session
 		if hasattr(self._session, 'session_thread_rlock'):
 			rlock = self._session.session_thread_rlock
 			if isinstance(rlock, type(threading.RLock())):
 				self.assign_lock(rlock)
 		if self.get_lock() is None:
@@ -136,28 +149,22 @@
 			self._interface_type = SessionKind.vxi11
 			if self._session.resource_class == 'SOCKET':
 				self._interface_type = SessionKind.socket
 
 		# Specifics for different interfaces
 		self._assure_write_with_tc = settings.assure_write_with_tc
 		self._term_char = settings.term_char
-		self._term_char_bin = self._term_char.encode('utf-8')
+		self._term_char_bin = self._term_char.encode(self.encoding)
 		self._session.write_termination = ''
-		self.vxi_capable = True
+		self.vxi_capable = settings.vxi_capable
 
 		if self._interface_type == SessionKind.serial:
-			self._session.read_termination = self._term_char
 			self.vxi_capable = False
-			self._assure_write_with_tc = True
 		elif self._interface_type == SessionKind.socket:
-			self._session.read_termination = self._term_char
 			self.vxi_capable = False
-			self._assure_write_with_tc = True
-		else:
-			self._session.read_termination = ''
 
 		# NRP-Z specific settings
 		if self.is_rsnrp_session():
 			self.disable_opc_query = True
 			# NRP-Z does not support chunk reading, therefore the segment must be in one piece
 			settings.io_segment_size = 1000000
 			self.vxi_capable = False
@@ -166,78 +173,125 @@
 		self.read_delay = settings.read_delay
 		self._viclear_exe_mode = settings.viclear_exe_mode
 		self._opc_wait_mode = settings.opc_wait_mode
 
 		# Parameters that need to be coerced based on Vxi-capability
 		if self.vxi_capable:
 			self._add_term_char_to_write_bin_block = settings.add_term_char_to_write_bin_block
+			self._session.read_termination = ''
 		else:
 			self._add_term_char_to_write_bin_block = True
+			self._session.read_termination = self._term_char
+			self._assure_write_with_tc = True
 
 		# Changeable settings
 		self.opc_timeout = 10000 if settings.opc_timeout == 0 else settings.opc_timeout
 		self.visa_timeout = settings.visa_timeout
 		self._session.chunk_size = settings.io_segment_size
 		self._data_chunk_size = settings.io_segment_size
 
-		# Must call the VISA viClear() before the any communication with the instrument
+		# Must call the VISA viClear() before any communication with the instrument
 		self.clear()
 
 		# Further steps are for NRP-Z session not valid
 		if self.is_rsnrp_session():
 			return
 
+		# First commands, can be more than one, separated by ';;'
+		if settings.first_cmds:
+			cmds = settings.first_cmds.split(';;')
+			for cmd in cmds:
+				if cmd.startswith('<w>'):
+					self.write(cmd[3:])
+				elif cmd.startswith('<q>'):
+					_ = self._query_str_no_events(cmd[3:])
+				elif '?' in cmd:
+					_ = self._query_str_no_events(cmd)
+				else:
+					self.write(cmd)
+
 		# Clear instrument status
-		self.write('*CLS')
-		if self.vxi_capable:
-			stb = self._read_stb()
-			if stb & StatusByte.message_available:
-				self._flush_junk_data()
+		if self.skip_clear_status is False:
+			self.write('*CLS')
+			if self.vxi_capable:
+				stb = self._read_stb()
+				if stb & StatusByte.message_available:
+					self._flush_junk_data()
 
 		# Apply settings for ESE and SRE, plus coerce the _opcWaitMode if necessary
 		self._opc_wait_mode = self._set_regs_ese_sre(self._opc_wait_mode)
 
 	@staticmethod
+	def get_and_check_direct_session(direct_session):
+		"""Returns direct session if it's a proper type.
+		If the direct_session is None, the function returns None.
+		If the direct_session is of an unsupported type, the function raises RsInstrException."""
+		if direct_session is None:
+			return None
+		# Reuse the session
+		if not isinstance(direct_session, pyvisa.Resource) and not isinstance(direct_session, SocketIo):
+			raise InstrumentErrors.RsInstrException(f"Direct_session must be a VISA resource object. Actual type: '{type(direct_session)}', value: '{direct_session}'")
+		return direct_session
+
+	@staticmethod
 	def _get_pure_resource_name(resource_name: str):
 		"""Returns pure resource name stripped of the (SelectVisa) part and the visa_select string"""
 		m = re.search(r'(.+)\(SelectVisa=([^),]+)\)', resource_name)
 		if not m:
 			return resource_name, None
 		resource_name = m.group(1).strip()
 		visa_select = m.group(2).strip()
 		return resource_name, visa_select
 
 	@classmethod
 	def get_resource_manager(cls, visa_select: str) -> pyvisa.ResourceManager:
 		"""Returns resource manager for the desired VISA implementation"""
 		operating_system = platform.system().lower()
+		vsl = None if visa_select is None else visa_select.lower()
 		bittness = struct.calcsize('P') * 8
-		if visa_select is None or visa_select in ['@default', '@standard', 'default', 'standard', 'defaultvisa', 'standardvisa', '@defaultvisa', '@standardvisa']:
-			return pyvisa.ResourceManager()
-		if visa_select.lower() in ['@ni', 'ni', 'visa-ni', 'nivisa', 'ni-visa', 'nationalinstruments', 'nationalinstrumentsvisa']:
-			return pyvisa.ResourceManager('@ni')
-		if visa_select.lower() in ['@py', 'pyvisa', 'visa-py', 'pyvisa-py']:
-			return pyvisa.ResourceManager('@py')
-		if 'rohde&schwarz' in visa_select.lower() or 'rohdeschwarz' in visa_select.lower() or visa_select.lower() == 'rsvisa' or visa_select.lower() == 'rs' or visa_select.lower() == 'r&s':
+		# Try if you find the default VISA dll
+		try:
+			if visa_select is None or visa_select in ['@default', '@standard', 'default', 'standard', 'defaultvisa', 'standardvisa', '@defaultvisa', '@standardvisa']:
+				return pyvisa.ResourceManager()
+
+			if vsl in ['@ni', 'ni', 'ivi', '@ivi', 'visa-ni', 'nivisa', 'ni-visa', 'nationalinstruments', 'nationalinstrumentsvisa']:
+				return pyvisa.ResourceManager()
+
+			if vsl in ['@py', 'pyvisa', 'visa-py', 'pyvisa-py']:
+				return pyvisa.ResourceManager('@py')
+		except ValueError:
+			# None of the required implementations found, fall back to the R&S VISA
+			visa_select = 'rsvisa'
+			vsl = visa_select.lower()
+
+		# from here, RsVisa implementation is considered
+		if 'rohde&schwarz' in vsl or 'rohdeschwarz' in vsl or vsl == 'rsvisa' or vsl == 'rs' or vsl == 'r&s':
 			if operating_system == 'windows':
 				if bittness == 32:
 					visa_select = r'c:\Windows\SysWOW64\RsVisa32.dll'
 				else:
 					visa_select = r'c:\Windows\system32\RsVisa32.dll'
 				return pyvisa.ResourceManager(visa_select)
 			elif operating_system == 'linux':
 				# The default install location may be different
 				# for debian/red hat/opensuse derived distributions
 				check_visa = [f'/usr/lib{bittness}/librsvisa.so', r'/usr/lib/librsvisa.so']
 				for check in check_visa:
 					if os.path.isfile(check):
 						return pyvisa.ResourceManager(check)
+			elif operating_system == 'darwin':
+				# MacOS
+				check_visa = [f'/Library/Frameworks/RsVisa.framework/Versions/Current/RsVisa/librsvisa.dylib']
+				for check in check_visa:
+					if os.path.isfile(check):
+						return pyvisa.ResourceManager(check)
 
-		if visa_select.lower() in ['socketio', 'socket', 'none']:
+		if vsl in ['socketio', 'socket', 'none']:
 			return ResourceManager()
+
 		return pyvisa.ResourceManager(visa_select)
 
 	def _get_visa_manufacturer(self) -> str:
 		"""Returns manufacturer of the current VISA"""
 		if hasattr(self._rm, 'VisaManufacturerName'):
 			return self._rm.VisaManufacturerName
 		try:
@@ -256,14 +310,26 @@
 		setattr(self._session, 'session_thread_rlock', lock)
 		self._lock = lock
 
 	def get_lock(self) -> threading.RLock:
 		"""Returns the current RLock object."""
 		return self._lock
 
+	def lock_resource(self, timeout: int, requested_key: str or bytes = None) -> bytes or None:
+		"""Locks the instrument to prevent it from communicating with other clients."""
+		if requested_key is None:
+			self._session.lock_excl(timeout)
+			return None
+		else:
+			return self._session.lock(timeout, requested_key)
+
+	def unlock_resource(self) -> None:
+		"""Unlocks the instrument to other clients."""
+		self._session.unlock()
+
 	@property
 	def visa_timeout(self) -> int:
 		"""See the visa_timeout.setter."""
 		return int(self._session.timeout)
 
 	@visa_timeout.setter
 	def visa_timeout(self, value: int) -> None:
@@ -278,73 +344,96 @@
 	@data_chunk_size.setter
 	def data_chunk_size(self, chunk_size: int) -> None:
 		"""Sets the maximum size of one block transferred during write/read operations."""
 		self._data_chunk_size = int(chunk_size)
 		self._session.chunk_size = int(chunk_size)
 
 	def _resolve_opc_timeout(self, timeout: int) -> int:
-		"""Resolves entered timeout value - if the input value is less than 1, it is replaces with opc_timeout."""
+		"""Resolves entered timeout value - if the input value is less than 1, it is replaced with opc_timeout."""
 		if timeout is None or timeout < 1:
 			return self.opc_timeout
 		else:
 			return timeout
 
 	def _set_regs_ese_sre(self, mode: WaitForOpcMode) -> WaitForOpcMode:
 		"""Based on the WaitForOpcMode, it sets the ESE and SRE register masks.
 		Returns coerced WaitForOpcMode."""
 		# Set the SRE and ESE registers accordingly
 		# No SRE is supported
+		if self.skip_status_system_setting:
+			return mode
 		self._set_ese_mask(EventStatusRegister.operation_complete)
 		self._set_sre_mask(StatusByte.NONE)
 		return mode
 
+	# noinspection PyTypeChecker
 	def _set_ese_mask(self, mask: EventStatusRegister, reset: bool = True) -> None:
 		"""Sends *ESE command with mask parameter."""
 		if reset is False:
 			current_value = int(self._query_str_no_events('*ESE?'))
 			mask = current_value | mask.value
 		self.write("*ESE %d" % mask.value)
 
+	# noinspection PyTypeChecker
 	def _set_sre_mask(self, mask: StatusByte, reset: bool = True) -> None:
 		"""Sends *SRE command with StatusByte mask parameter."""
 		if reset is False:
 			current_value = int(self._query_str_no_events('*SRE?'))
 			mask = current_value | mask.value
 		# Also affect the _opc_wait_mode:
 		# If the mask has event_status_byte == false, and the _opc_wait_mode is service_request, set it to stb_poll
 		# If the mask has event_status_byte == true, do not change anything
 		self.write(f'*SRE {mask.value}')
 
-	def _write_and_poll_stb_vxi(self, command: str, is_query: bool, timeout: int, end_mask: StatusByte) -> StatusByte:
+	def _write_and_poll_stb_vxi(self, command: str, is_query: bool, timeout: int) -> StatusByte:
 		"""Reads Status Byte Register and ends if the ESB bit (5) is set to 1.
 		Also works with the SOCKET and SERIAL interface by sending *STB? query.
 		In that case however, command cannot be a query.
 		Returns the last read Status Byte value."""
 		timeout_secs = timeout / 1000
-		self.clear_before_read()
+		end_mask = StatusByte.error_queue_not_empty | StatusByte.event_status_byte
 		if command.endswith(self._term_char):
 			command = command.rstrip(self._term_char)
-		self.write(command + ';*OPC')
-		# Use catch to return the VISA Timeout back
+
+		if is_query is True:
+			if self.opc_sync_query_mechanism == OpcSyncQueryMechanism.standard or self.opc_sync_query_mechanism == OpcSyncQueryMechanism.also_check_mav:
+				self.clear_before_read()
+				self.write(command + ';*OPC')
+				if self.opc_sync_query_mechanism == OpcSyncQueryMechanism.also_check_mav:
+					end_mask |= StatusByte.message_available
+
+			elif self.opc_sync_query_mechanism == OpcSyncQueryMechanism.only_check_mav_err_queue:
+				self.write(command)
+				end_mask = StatusByte.error_queue_not_empty | StatusByte.message_available
+
+			elif self.opc_sync_query_mechanism == OpcSyncQueryMechanism.cls_only_check_mav_err_queue:
+				self.clear_before_read()
+				self.write(command)
+				end_mask = StatusByte.error_queue_not_empty | StatusByte.message_available
+		else:
+			self.clear_before_read()
+			self.write(command + ';*OPC')
+
 		start = time.time()
 		# STB polling loop
 		while True:
 			stb = self._read_stb()
 			elapsed = self._polling_delay(start)
 			if elapsed > timeout_secs:
 				self._narrow_down_opc_tout_error(command, is_query, timeout)
 			if end_mask & stb:
 				break
 		return stb
 
-	def _write_and_poll_stb_non_vxi(self, command: str, timeout: int, end_mask: StatusByte) -> StatusByte:
+	def _write_and_poll_stb_non_vxi(self, command: str, timeout: int) -> StatusByte:
 		"""Queries Status Byte Register (*STB?) and ends if the ESB bit (5) is set to 1.
 			The command must not be a query. Also works with the SOCKET and SERIAL interface.
 			Returns the last read Status Byte value."""
 		timeout_secs = timeout / 1000
+		end_mask = StatusByte.error_queue_not_empty | StatusByte.event_status_byte
 		self.clear_before_read()
 		if command.endswith(self._term_char):
 			command = command.rstrip(self._term_char)
 		self.write(command + ';*OPC')
 		start = time.time()
 		# STB polling loop
 		while True:
@@ -360,43 +449,47 @@
 		"""Called by the _write_and_poll_stb_vxi when the timeout expires.
 		The method tries to closer identify the cause of the timeout."""
 		stb = self._read_stb()
 		timeout = self._resolve_opc_timeout(timeout)
 		if is_query:
 			if stb & StatusByte.error_queue_not_empty:
 				self.clear()
-				context = f"Sending query '{command.strip()}' with OPC Wait resulted in timeout. OPC Timeout is set to {timeout} ms. Additionally, "
-				InstrumentErrors.assert_no_instrument_status_errors(self._resource_name, self.query_all_syst_errors(), context)
-			InstrumentErrors.throw_opc_tout_exception(self.opc_timeout, timeout, f"Sending query '{command.strip()}'.")
+				context = f"Query '{command.strip()}' with OPC Wait resulted in timeout. OPC Timeout is set to {timeout} ms. Additionally, "
+				InstrumentErrors.assert_no_instrument_status_errors(self.resource_name, self.query_all_syst_errors(), context, first_exc=InstrumentErrors.TimeoutException)
+			InstrumentErrors.throw_opc_tout_exception(self.opc_timeout, timeout, f"Query '{command.strip()}'.")
 		else:
 			if stb & StatusByte.error_queue_not_empty:
 				self.clear()
-				context = f"Sending command '{command.strip()}' with OPC Wait resulted in timeout. OPC Timeout is set to {timeout} ms. Additionally, "
-				InstrumentErrors.assert_no_instrument_status_errors(self._resource_name, self.query_all_syst_errors(), context)
-			InstrumentErrors.throw_opc_tout_exception(self.opc_timeout, timeout, f"Sending command '{command.strip()}'.")
+				context = f"Command '{command.strip()}' with OPC Wait resulted in timeout. OPC Timeout is set to {timeout} ms. Additionally, "
+				InstrumentErrors.assert_no_instrument_status_errors(self.resource_name, self.query_all_syst_errors(), context, first_exc=InstrumentErrors.TimeoutException)
+			InstrumentErrors.throw_opc_tout_exception(self.opc_timeout, timeout, f"Command '{command.strip()}'.")
 
 	def _narrow_down_io_tout_error(self, context: str, visa_timeout: int = 0) -> None:
 		"""Called internally after IOTimeoutException can narrow down the error to more specific exception.
-		You can define the visa_timeout value for the error message. Otherwise the current visa_timeout is reported."""
+		You can define the visa_timeout value for the error message. Otherwise, the current visa_timeout is reported."""
+		context_stripped = context.strip().rstrip("- ")
+		if self.stb_in_error_check is False:
+			raise InstrumentErrors.TimeoutException(context_stripped)
 		if self.vxi_capable:
 			stb = self._read_stb()
 		else:
 			# Non-Vxi session
 			old_tout = self.visa_timeout
 			try:
 				self.visa_timeout = 500
-				stb = self._query_stb()
+				stb = self._query_stb(False)
 			finally:
 				self.visa_timeout = old_tout
 		if visa_timeout <= 0:
 			visa_timeout = self.visa_timeout
+
 		context = context + f'VISA Timeout error occurred ({visa_timeout} milliseconds)'
 		if stb & StatusByte.error_queue_not_empty:
-			InstrumentErrors.assert_no_instrument_status_errors(self._resource_name, self.query_all_syst_errors(), context + ' and ...')
-		# In case the previous exception is not thrown
+			InstrumentErrors.assert_no_instrument_status_errors(self.resource_name, self.query_all_syst_errors(), context + ' and ...', first_exc=InstrumentErrors.TimeoutException)
+		# In case none of the previous exceptions is thrown
 		raise InstrumentErrors.TimeoutException(context)
 
 	def _polling_delay(self, start):
 		"""Generates progressive polling delay."""
 
 		elapsed = time.time() - start
 		if self._opc_wait_mode == WaitForOpcMode.stb_poll:
@@ -445,59 +538,80 @@
 			if elapsed < 20:
 				time.sleep(1)
 				return elapsed
 			time.sleep(2)
 
 		return elapsed
 
-	def query_syst_error(self) -> str or None:
-		"""Returns one response to the SYSTEM:ERROR? query."""
-		error = self.query_str('SYST:ERR?')
-		if error.startswith('0,'):
+	@staticmethod
+	def _parse_err_query_response(response: str) -> Tuple[int, str]:
+		"""
+		Parses entered response string to Tuple(code, message).
+		E.g.: response = '-110,"Command error"' returns: (-110,'Command error')
+		"""
+		m = re.match(r'([-+]?\d+).*?[\'"](.*)[\'"]', response)
+		code = 0
+		if m:
+			try:
+				code = int(m.group(1))
+			except ValueError:
+				pass
+			return code, m.group(2)
+		else:
+			return code, response
+
+	def query_syst_error(self) -> Tuple[int, str] or None:
+		"""Returns one response to the SYSTEM:ERROR? query.
+		The response is a Tuple of (code: int, message: str)"""
+		error = self._query_str_no_events('SYST:ERR?')
+		if error.startswith('0,') or error.startswith('+0,'):
 			return None
-		return error.strip()
+		return self._parse_err_query_response(error.strip())
 
-	def query_all_syst_errors(self) -> list or None:
-		"""Returns all errors in the instrument's error queue."""
+	def query_all_syst_errors(self) -> List[Tuple[int, str]] or None:
+		"""Returns all errors in the instrument's error queue.
+		If no error is detected, the return value is None."""
 		errors = []
 		while True:
 			entry = self.query_syst_error()
 			if entry is None:
 				break
 			errors.append(entry)
 			if len(errors) > 50:
 				# Safety stop
 				errors.append('query_all_syst_errors - max limit 50 of SYST:ERR? sent.')
 				break
-
 		if len(errors) == 0:
 			return None
 		else:
 			return errors
 
-	def _query_stb(self) -> StatusByte:
+	def _query_stb(self, allow_tout_error_narrow_down: bool = True) -> StatusByte:
 		"""Sends *STB? query and reads the result."""
-		return StatusByte(int(self._query_str_no_events('*STB?')))
+		return StatusByte(int(self._query_str_no_events('*STB?', allow_tout_error_narrow_down)))
 
 	def _read_stb(self) -> StatusByte:
 		"""Calls viReadStb and returns the result."""
 		return StatusByte(self._session.read_stb())
 
 	def clear_before_read(self) -> None:
 		"""Clears IO buffers and the ESR register before reading/writing responses synchronized with *OPC."""
 
 		# For NRP-Z sessions, skip this completely
-		if self.is_rsnrp_session():
+		if self.is_rsnrp_session() or self.skip_clear_status:
 			return
 
 		if not self.vxi_capable:
 			# Non-Vxi session must use *CLS in any case
 			self.write('*CLS')
 			correct = False
-			opc = self._query_str_no_events('*OPC?')
+			if self.disable_opc_query:
+				opc = '1'
+			else:
+				opc = self._query_str_no_events('*OPC?')
 			repeat = 0
 			while not correct:
 				if len(opc) <= 2:
 					opc = opc.strip()
 					correct = opc == '0' or opc == '1'
 				if not correct:
 					# Read again with a small VISA timeout
@@ -525,15 +639,15 @@
 				self.query_and_clear_esr()
 			# Check if the status byte value changed
 			previous_stb = stb
 			stb = self._query_stb()
 			if stb == previous_stb:
 				repeat += 1
 				if repeat > 10:
-					raise Exception(f"Cannot clear the instrument's status subsystem. Status Byte: '{stb}'")
+					raise RsInstrException(f"Cannot clear the instrument's status subsystem. Status Byte: '{stb}'")
 
 	def _flush_junk_data(self) -> None:
 		"""Reads junk bytes to clear the instrument's output buffer."""
 		if self.read_delay > 0:
 			time.sleep(self.read_delay / 1000)
 		self._read_unknown_len(StreamWriter.as_bin_var(), False)
 
@@ -568,39 +682,55 @@
 			try:
 				self._session.clear()
 			except Exception:
 				pass
 		else:
 			self._session.clear()
 
+	def is_connection_active(self) -> bool:
+		"""Returns true, if the VISA connection is active and the communication with the instrument still works.
+		This is achieved by:
+		- checking the session property timeout
+		- sending the *IDN? query"""
+		if self._session is None:
+			return False
+		# noinspection PyBroadException
+		try:
+			old_tout = self.visa_timeout
+			self.visa_timeout = 2000
+			if len(self.cmd_idn) > 0:
+				self.write(self.cmd_idn)
+				_ = self._read_str_no_events()
+			self.visa_timeout = old_tout
+			return True
+		except Exception:
+			return False
+
 	def _write_and_wait_for_opc(self, command: str, is_query: bool, timeout: int) -> StatusByte:
 		"""Internal method to synchronise a command with OPC timeout.
 		Timeout value 0 means the OPC timeout is used."""
 		timeout = self._resolve_opc_timeout(timeout)
 
 		if command.endswith(self._term_char):
 			command = command.rstrip(self._term_char)
 		if is_query:
 			InstrumentErrors.assert_query_has_qmark(command, 'Query with OPC')
 		else:
 			InstrumentErrors.assert_cmd_has_no_qmark(command, 'Write with OPC')
 
 		if self._opc_wait_mode == WaitForOpcMode.opc_query:
 			if is_query:
-				raise Exception('Sending a query with OpcQuery synchronization is not possible')
+				raise RsInstrException('Sending a query with OpcQuery synchronization is not possible')
 			stb = self._write_and_query_opc(command, timeout)
 		else:
 			# STB polling
-			end_stb_mask = StatusByte.error_queue_not_empty | StatusByte.event_status_byte
-			if is_query:
-				end_stb_mask |= StatusByte.message_available
 			if self.vxi_capable:
-				stb = self._write_and_poll_stb_vxi(command, is_query, timeout, end_stb_mask)
+				stb = self._write_and_poll_stb_vxi(command, is_query, timeout)
 			else:
-				stb = self._write_and_poll_stb_non_vxi(command, timeout, end_stb_mask)
+				stb = self._write_and_poll_stb_non_vxi(command, timeout)
 
 		return stb
 
 	def _write_and_query_opc(self, cmd: str, timeout: int) -> StatusByte:
 		"""Internal method to write a command followed by query_opc().
 		Used for opc-synchronization if the mode is set to WaitForOpcMode.opc_query or the session is not-vxi.
 		Timeout value 0 means the OPC timeout is used."""
@@ -614,40 +744,52 @@
 			self.write(cmd)
 			self.query_opc()
 		finally:
 			if old_tout != timeout:
 				self.visa_timeout = old_tout
 		return self._query_stb()
 
+	def clear_status_after_query_with_opc(self) -> bool:
+		"""Returns true, if the opc-sync queries require status clearing afterward."""
+		if self.vxi_capable is False or self._opc_wait_mode is WaitForOpcMode.opc_query:
+			return False
+		if self.opc_sync_query_mechanism == InstrumentSettings.OpcSyncQueryMechanism.standard:
+			return True
+		if self.opc_sync_query_mechanism == InstrumentSettings.OpcSyncQueryMechanism.also_check_mav:
+			return True
+		return False
+
 	def write(self, cmd: str) -> None:
 		"""Writes command to the instrument."""
 		if self.write_delay > 0:
 			time.sleep(self.write_delay / 1000)
 		add_tc = False
 		if self._assure_write_with_tc and not cmd.endswith(self._term_char):
 			add_tc = True
+		if self.each_cmd_prefix:
+			cmd = self.each_cmd_prefix + cmd
+		cmd_bytes = cmd.encode(self.encoding)
 		if add_tc:
-			self._session.write(cmd + self._term_char)
-		else:
-			self._session.write(cmd)
+			cmd_bytes += self._term_char.encode(self.encoding)
+		self._session.write_raw(cmd_bytes)
 
 	def _read_unknown_len(self, stream: StreamWriter, allow_chunk_events: bool, prepend_data: AnyStr = None) -> None:
 		"""Reads data of unknown length to the provided WriteStream.
 		The read is performed in an incremental chunk steps to optimize memory use (for NRP-Z session it is set to fixed self._data_chunk_size):
 			- The first read is performed with the fixed size of 1024 bytes
 			- The 2nd one reads 64 kBytes
 			- The 3rd one reads 128 kBytes
 			- The 4th one reads 256 kBytes and so on, with the max cap of self._data_chunk_size
 		:param stream: [StreamWriter] target for the read data
 		:param allow_chunk_events: [bool] if True, the method can send the chunk_events. If False, sending events is blocked.
-		:param prepend_data: Optional[bytes or string] You can prepend this data to the beginning. It will be considered part of the first chunk read
+		:param prepend_data: Optional[bytes or string] You can prepend this data to the beginning. It will be considered part of the first read chunk
 		:return: read data [bytes or string], depending on the parameter binary."""
 		with self._session.ignore_warning(pyvisa.constants.StatusCode.success_max_count_read):
 			if prepend_data and isinstance(prepend_data, str):
-				prepend_data = prepend_data.encode('utf-8')
+				prepend_data = prepend_data.encode(self.encoding)
 			chunk_ix = 0
 			eot = False
 			while not eot:
 				if self.is_rsnrp_session():
 					chunk_size = self._data_chunk_size
 				else:
 					if chunk_ix == 0:
@@ -660,15 +802,15 @@
 				if chunk_size > self._data_chunk_size:
 					chunk_size = self._data_chunk_size
 				chunk, self.last_status = self._session.visalib.read(self._session.session, chunk_size)
 				if chunk_ix == 0 and prepend_data:
 					chunk = prepend_data + chunk
 				eot = not self._last_status_more_data_available()
 				if not stream.binary:
-					chunk = chunk.decode('utf-8')
+					chunk = chunk.decode(self.encoding)
 					if eot:
 						chunk = chunk.rstrip(self._term_char)
 				stream.write(chunk)
 				if self.on_read_chunk_handler and allow_chunk_events:
 					total_size = len(stream) if eot is True else None
 					event_args = EventArgsChunk(stream.binary, chunk_ix, len(chunk), total_size, len(stream), eot, None, chunk if self.io_events_include_data else None)
 					self.on_read_chunk_handler(event_args)
@@ -683,37 +825,44 @@
 		Sending of any read events is blocked."""
 		if self.read_delay > 0:
 			time.sleep(self.read_delay / 1000)
 		stream = StreamWriter.as_string_var()
 		self._read_unknown_len(stream, False)
 		return stream.content
 
-	def _query_str_no_events(self, query: str) -> str:
+	def _query_str_no_events(self, query: str, allow_tout_error_narrow_down: bool = True) -> str:
 		"""Queries the instrument and reads the response as string.
 		The length of the string is not limited. The response is then trimmed for trailing LF.
 		Sending of any read events is blocked. Use this method for all the service VisaSession queries."""
 		response = ''
 		self.write(query)
 		try:
 			response = self._read_str_no_events()
-		except pyvisa.VisaIOError:
-			self._narrow_down_io_tout_error(f"Querying '{query.rstrip(self._term_char)}' - ")
+		except pyvisa.VisaIOError as e:
+			context = f"Query '{query.rstrip(self._term_char)}'"
+			if e.error_code == StatusCode.error_timeout:
+				if allow_tout_error_narrow_down:
+					self._narrow_down_io_tout_error(context + ' - ')
+				else:
+					raise InstrumentErrors.TimeoutException(context)
+			else:
+				raise InstrumentErrors.RsInstrException(context)
 		return response
 
 	def _query_str_no_events_timed(self, query: str, timeout: int, suppress_read_tout: bool = False) -> str:
 		"""Queries the instrument and reads the response as string.
 		The entered timeout sets the VISA timeout just for this call. You can suppress the timeout error.
 		The length of the string is not limited. The response is then trimmed for trailing LF.
 		Sending of any read events is blocked. Use this method for all the service VisaSession queries."""
 		response = ''
 		self.write(query)
 		try:
 			response = self._read_str_timed(timeout, suppress_read_tout)
 		except pyvisa.VisaIOError:
-			self._narrow_down_io_tout_error(f"Querying with timeout {timeout} ms '{query.rstrip(self._term_char)}' - ", timeout)
+			self._narrow_down_io_tout_error(f"Query with timeout {timeout} ms '{query.rstrip(self._term_char)}' - ", timeout)
 		return response
 
 	def _read_str_timed(self, timeout: int, suppress_read_tout: bool = False) -> str:
 		"""Reads response from the instrument with a VISA timeout temporarily set for the read.
 		The VISA timeout is set back to the previous value before the method finishes even if an exception occurs.
 		Sending of any read events is blocked."""
 		old_visa_tout = self.visa_timeout
@@ -748,15 +897,15 @@
 		"""Queries the instrument and reads the response as string.
 		The length of the string is not limited. The response is then trimmed for trailing LF."""
 		response = ''
 		self.write(query)
 		try:
 			response = self._read_str()
 		except pyvisa.VisaIOError:
-			self._narrow_down_io_tout_error(f"Querying '{query.rstrip(self._term_char)}' - ")
+			self._narrow_down_io_tout_error(f"Query '{query.rstrip(self._term_char)}' - ")
 		return response
 
 	def query_str_no_tout_err(self, query: str, tout: int) -> str:
 		"""Same as query_str, but you can set the timeout just for this one call.
 		If the timeout exception occurs, it is suppressed and the method returns Null"""
 		response = None
 		old_tout = self.visa_timeout
@@ -770,23 +919,23 @@
 		return response
 
 	def write_with_opc(self, command: str, timeout: int = None) -> None:
 		"""Sends command with OPC-sync.
 		If you do not provide timeout, the method uses current opc_timeout."""
 		self._write_and_wait_for_opc(command, False, timeout)
 
-	def query_str_with_opc(self, query: str, timeout: int = None) -> str:
+	def query_str_with_opc(self, query: str, timeout: int = None, context: str = 'Query string with OPC') -> str:
 		"""Query string with OPC synchronization.
 		The response is trimmed for any trailing LF.
 		If you do not provide timeout, the method uses current opc_timeout."""
 		timeout = self._resolve_opc_timeout(timeout)
 		if self.vxi_capable and self._opc_wait_mode is not WaitForOpcMode.opc_query:
 			# For Vxi session, use the STB poll or SRQ wait and then read the response
 			stb = self._write_and_wait_for_opc(query, True, timeout)
-			self._check_msg_available_after_opc_wait(stb, query, timeout, 'Query String With OPC')
+			self._check_msg_available_after_opc_wait(stb, query, timeout, context)
 			response = self._read_str()
 		else:
 			# For non-Vxi sessions, use the longer VISA Timeout without the *OPC?
 			# Same is valid for WaitForOpcMode.OpcQuery
 			InstrumentErrors.assert_query_has_qmark(query, 'Query with VISA timeout')
 			self.write(query)
 			old_tout = self.visa_timeout
@@ -824,57 +973,59 @@
 		"""Used internally after _StbPolling() to check if the message is available.
 		Throws an exception in case of MAV not available."""
 		if not self.vxi_capable:
 			return
 		if stb & StatusByte.message_available:
 			return
 		# Message not available
-		context = context + f" SCPI query '{query.rstrip(self._term_char)}'"
+		context = context + f" Query '{query.rstrip(self._term_char)}'"
 		if stb & StatusByte.error_queue_not_empty:
 			# Instrument reports an error
-			InstrumentErrors.assert_no_instrument_status_errors(self._resource_name, self.query_all_syst_errors(), context)
+			InstrumentErrors.assert_no_instrument_status_errors(self.resource_name, self.query_all_syst_errors(), context)
 		else:
 			# Sometimes even if the StatusByte.MessageAvailable is false, the message is available.
 			# Try to read the STB again
 			stb = self._read_stb()
 			if not stb & StatusByte.event_status_byte:
 				# Instrument did not respond within the defined time
 				InstrumentErrors.throw_opc_tout_exception(self.opc_timeout, timeout, f'{context} No response from the instrument.')
 
 	def error_in_error_queue(self) -> bool:
 		"""Returns true, if error queue contains at least one error."""
 		stb = self._query_stb()
-		return (stb & StatusByte.error_queue_not_empty) != 0
+		if stb & StatusByte.error_queue_not_empty:
+			return True
+		return False
 
 	def reset_ese_sre(self) -> None:
 		"""Resets the status of ESE and SRE registers to default values."""
 		self._set_regs_ese_sre(self._opc_wait_mode)
 
 	def write_bin_block(self, cmd: str, data_stream: StreamReader) -> None:
 		"""Writes all the payload as binary data block to the instrument.
 		The binary data header is added at the beginning of the transmission automatically.
 		:param cmd: [str] SCPI command with which to send the data
 		:param data_stream: [StreamReader] data provider for the payload"""
 		data_size = len(data_stream)
 		len_str = f'{data_size}'
 		cmd = cmd.rstrip(self._term_char)
 		if '#' in cmd:
-			raise Exception(
+			raise RsInstrException(
 				f"Command '{cmd}' must be provided without the binary data header. "
 				f"The method 'write_bin_block' composes and prepends the binary data header automatically.")
 		if data_size <= self._std_bin_block_header_max_len:
 			# Standard bin data header for sizes below 1E9 bytes, e.g.: '#512345'
-			cmd_plus_header = f'{cmd}#{len(len_str)}{len_str}'.encode('utf-8')
+			cmd_plus_header = f'{cmd}#{len(len_str)}{len_str}'.encode(self.encoding)
 		else:
 			# Big sizes bin data header: e.g.: '#(3000000000)'
-			cmd_plus_header = f'{cmd}#({len_str})'.encode('utf-8')
+			cmd_plus_header = f'{cmd}#({len_str})'.encode(self.encoding)
 
 		if data_size <= self._data_chunk_size:
 			# Write all in one step
-			full_chunk = data_stream.read_as_binary()
+			full_chunk = data_stream.read_as_binary(self.encoding)
 			write_buf = cmd_plus_header + full_chunk
 			if self._add_term_char_to_write_bin_block:
 				write_buf += self._term_char_bin
 			self._session.write_raw(write_buf)
 			# Event sending
 			if self.on_write_chunk_handler:
 				event_args = EventArgsChunk(True, 0, data_size, data_size, data_size, True, 1, full_chunk if self.io_events_include_data else None)
@@ -890,24 +1041,24 @@
 					time.sleep(self.write_delay / 1000)
 				# Write bin header
 				self._session.write_raw(cmd_plus_header)
 				# Write chunks
 				while True:
 					if len(data_stream) > self._data_chunk_size:
 						#  Not the last segment
-						chunk = data_stream.read_as_binary(self._data_chunk_size)
+						chunk = data_stream.read_as_binary(self.encoding, self._data_chunk_size)
 						self._session.write_raw(chunk)
 						# Event sending
 						if self.on_write_chunk_handler:
 							event_args = EventArgsChunk(
 								True, chunk_ix, self._data_chunk_size, data_size, data_size - len(data_stream), False, total_chunks, chunk if self.io_events_include_data else None)
 							self.on_write_chunk_handler(event_args)
 					else:
 						# Last segment, indicate end of message again
-						chunk = data_stream.read_as_binary()
+						chunk = data_stream.read_as_binary(self.encoding)
 						if self._add_term_char_to_write_bin_block:
 							# Append LF
 							self._session.write_raw(chunk)
 							self._session.send_end = True
 							self._session.write_raw(self._term_char_bin)
 						else:
 							self._session.send_end = True
@@ -936,60 +1087,88 @@
 			char = self._session.read_bytes(1, break_on_termchar=True)
 			if char == b'0':
 				data_type = ReadDataType.bin_unknown_len
 				return data_type, '#0', -1
 			if char == b'(':
 				# format for big lengths i.e. > 1E9 bytes: '#(1234567890123)...'
 				data_type = ReadDataType.bin_known_len
-				len_str = (self.read_up_to_char(b')', 100)[:-1]).decode('utf-8')
+				len_str = (self.read_up_to_char(b')', 100)[:-1]).decode(self.encoding)
 				whole_hdr = '#(' + len_str + ')'
 				length = int(len_str)
 				return data_type, whole_hdr, length
 
 			# classic format for < 1E9 bytes: '#9123456789...'
 			data_type = ReadDataType.bin_known_len
 			len_of_len = int(char)
-			len_str = self._session.read_bytes(len_of_len).decode('utf-8')
+			len_str = self._session.read_bytes(len_of_len).decode(self.encoding)
 			length = int(len_str)
-			whole_hdr = '#' + char.decode('utf-8') + len_str
+			whole_hdr = '#' + char.decode(self.encoding) + len_str
 			return data_type, whole_hdr, length
 
 		data_type = ReadDataType.ascii
 		if char == self._term_char_bin:
 			data_type = ReadDataType.null
 		if self.vxi_capable:
 			# For Vxi session, to be sure, check whether there are more chars in the read buffer
 			stb = self._read_stb()
 			if stb & StatusByte.message_available:
 				data_type = ReadDataType.ascii
-		whole_hdr = char.decode('utf-8')
+		whole_hdr = char.decode(self.encoding)
 		if exc_if_not_bin:
 			if data_type == ReadDataType.null:
-				InstrumentErrors.throw_bin_block_unexp_resp_exception(self._resource_name, self._term_char)
+				InstrumentErrors.throw_bin_block_unexp_resp_exception(self.resource_name, self._term_char)
 			# Read 20 more characters to compose a better exception message
-			whole_hdr += self.read_up_to_char(self._term_char_bin, 20).decode('utf-8')
+			whole_hdr += self.read_up_to_char(self._term_char_bin, 20).decode(self.encoding)
 			if self.last_status == pyvisa.constants.StatusCode.success_max_count_read:
 				self._flush_junk_data()
-			InstrumentErrors.throw_bin_block_unexp_resp_exception(self._resource_name, whole_hdr)
+			InstrumentErrors.throw_bin_block_unexp_resp_exception(self.resource_name, whole_hdr)
 		return data_type, whole_hdr, length
 
+	def get_bin_data_length(self, query: str) -> int or None:
+		"""Returns only the length binary data header, and discards the actual data.
+		Any timeout error is suppressed, and the method returns None instead.
+		Warning!!! - for non-VXI sessions (SOCKET, ASRL) this method transfers the entire file to the control PC, which might take a long time."""
+		if self.vxi_capable and self._opc_wait_mode != WaitForOpcMode.opc_query:
+			# For Vxi session, use the STB poll and read the header
+			stb = self._write_and_wait_for_opc(query, True, 0)
+			try:
+				self._check_msg_available_after_opc_wait(stb, query, 0, 'get_bin_data_length')
+			except InstrumentErrors.StatusException:
+				return None
+			data_type, header, length = self._parse_bin_data_header(True)
+			self.clear()
+			self.clear_before_read()
+			return length
+		else:
+			with StreamWriter.as_forget() as stream:
+				old_timeout = self.visa_timeout
+				try:
+					self.visa_timeout = 2000
+					self.query_bin_block(query, stream, True)
+				except InstrumentErrors.StatusException:
+					return None
+				finally:
+					self.visa_timeout = old_timeout
+				length = stream.written_len
+		return length
+
 	def read_bin_block(self, stream: StreamWriter, exc_if_not_bin: bool) -> None:
 		"""Reads binary data block to the provided stream. \n
 		:param stream: [StreamWriter] target for the read data. Can be string, bytes, or a file
 		:param exc_if_not_bin: if True, the method throws exception if the received data is not binary"""
 		data_type, header, length = self._parse_bin_data_header(exc_if_not_bin)
 		if data_type == ReadDataType.ascii:
-			stream.switch_to_string_data()
+			stream.switch_to_string_data(self.encoding)
 			self._read_unknown_len(stream, True, header)
 		elif data_type == ReadDataType.null:
-			# No data, consider it ASCII, Return empty string, and False (signaling ASCII transfer)
-			stream.switch_to_string_data()
+			# No data, consider it ASCII. Change the stream type to ASCII and return empty string
+			stream.switch_to_string_data(self.encoding)
 		elif data_type == ReadDataType.bin_unknown_len:
 			if not self.vxi_capable:
-				raise Exception(f'Non-Vxi11 sessions can not read binary data block of unknown length.')
+				raise RsInstrException(f'Non-Vxi11 sessions can not read binary data block of unknown length.')
 			self._read_unknown_len(stream, True)
 		elif length == 0:
 			self._flush_junk_data()
 		else:
 			self._read_bin_block_known_len(stream, length)
 
 	def _read_bin_block_known_len(self, stream: StreamWriter, length: int) -> None:
@@ -1027,15 +1206,18 @@
 
 	def query_bin_block(self, query: str, stream: StreamWriter, exc_if_not_bin: bool = True) -> None:
 		"""Query binary data block and returns it as byte data. \n
 		:param query: [str] query to send to the instrument
 		:param stream: [StreamWriter] target for the read data. Can be string, bytes, or a file
 		:param exc_if_not_bin: [Boolean] if True, the method throws exception if the received data is not binary"""
 		self.write(query)
-		self.read_bin_block(stream, exc_if_not_bin)
+		try:
+			self.read_bin_block(stream, exc_if_not_bin)
+		except pyvisa.VisaIOError:
+			self._narrow_down_io_tout_error(f"Query bin block '{query.rstrip(self._term_char)}' - ")
 		return
 
 	def query_bin_block_with_opc(self, query: str, stream: StreamWriter, exc_if_not_bin: bool = True, timeout: int = None) -> None:
 		"""Query binary data block with OPC and returns it as byte data.
 		:param query: [str] query to send to the instrument
 		:param stream: [StreamWriter] target for the read data. Can be string, bytes, or a file
 		:param exc_if_not_bin: [Boolean] if True, the method throws exception if the received data is not binary
@@ -1073,14 +1255,28 @@
 			response += char
 			if char in stop_chars:
 				break
 			if self.last_status != pyvisa.constants.StatusCode.success_max_count_read:
 				break
 		return response
 
+	def go_to_local(self) -> None:
+		"""Puts the instrument into local state."""
+		if self.vxi_capable:
+			self._session.control_ren(pyvisa.constants.RENLineOperation.deassert_gtl)
+		else:
+			self.write("&GTL")
+
+	def go_to_remote(self) -> None:
+		"""Puts the instrument into remote state."""
+		if self.vxi_capable:
+			self._session.control_ren(pyvisa.constants.RENLineOperation.asrt_address)
+		else:
+			self.write("&GTR")
+
 	def get_session_handle(self) -> object:
 		"""Returns the underlying pyvisa session."""
 		return self._session
 
 	def close(self) -> None:
 		"""Closes the Visa session.
 		If the object was created with the direct session input, the session is not closed."""
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/Internal/VisaSessionSim.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/Internal/VisaSessionSim.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,7 +1,9 @@
+"""VisaSession for simulated sessions."""
+
 import threading
 from typing import Callable, Dict, AnyStr
 
 from . import InstrumentSettings
 from .StreamReader import StreamReader
 from .StreamWriter import StreamWriter
 
@@ -9,14 +11,15 @@
 # noinspection PyMethodMayBeStatic,PyUnusedLocal
 class VisaSessionSim(object):
 	"""Visa session in simulation mode.
 	Provides the properties for the simulation mode.
 	Also serves as a cache for the SCPI command values: If you query a SCPI command value, it returns the last set value by that SCPI command."""
 
 	def __init__(self, resource_name: str, settings: InstrumentSettings, direct_session=None):
+		self.reusing_session = direct_session is not None
 		# noinspection PyTypeChecker
 		self._data_chunk_size: int = None
 		# noinspection PyTypeChecker
 		self._lock: threading.RLock = None
 
 		# Event handlers
 		# noinspection PyTypeChecker
@@ -25,16 +28,17 @@
 		# noinspection PyTypeChecker
 		self.on_write_chunk_handler: Callable = None
 		"""If assigned a handler, the VisaSession sends it event on each write chunk transfer."""
 		self.io_events_include_data: bool = False
 		"""If true, the VisaSession events sent to on_read_chunk_handler and on_write_chunk_handler contain transferred data."""
 
 		self.manufacturer: str = 'Rohde&Schwarz'
-		self._resource_name = resource_name
+		self.resource_name = resource_name
 		self.vxi_capable = True
+		self.encoding = settings.encoding  # default encoder between bytes and string
 
 		# Changeable settings
 		self.opc_timeout = 10000 if settings.opc_timeout == 0 else settings.opc_timeout
 		self.visa_timeout = settings.visa_timeout
 		self.data_chunk_size = settings.io_segment_size
 
 		self._last_cmd = None
@@ -50,14 +54,17 @@
 			rlock = direct_session.session_thread_rlock
 			if isinstance(rlock, type(threading.RLock())):
 				self.assign_lock(rlock)
 		if self.get_lock() is None:
 			# The existing session did not have a thread lock, assign a new one
 			self.assign_lock(threading.RLock())
 
+		if self.reusing_session:
+			self.resource_name = direct_session.resource_name
+
 	def assign_lock(self, lock: threading.RLock) -> None:
 		"""Assigns the provided thread lock. The lock is only used by the parent class Instrument."""
 		self._lock = lock
 
 	def get_lock(self) -> threading.RLock:
 		"""Returns the current RLock object."""
 		return self._lock
@@ -92,25 +99,30 @@
 		return False
 
 	def query_syst_error(self) -> str or None:
 		"""Returns one response to the SYSTEM:ERROR? query."""
 		return None
 
 	def query_all_syst_errors(self) -> list or None:
-		"""Returns all errors in the instrument's error queue."""
-		return []
+		"""Returns all errors in the instrument's error queue.
+		If no error is detected, the return value is None."""
+		return None
 
 	def clear_before_read(self) -> None:
 		"""Clears IO buffers and the ESR register before reading/writing responses synchronized with *OPC."""
 		return
 
 	def clear(self) -> None:
 		"""Perform VISA viClear conditionally based on the instrument settings."""
 		return
 
+	def clear_status_after_query_with_opc(self) -> bool:
+		"""Returns true, if the opc-sync queries require status clearing afterward."""
+		return False
+
 	def write(self, cmd: str) -> None:
 		"""Writes command to the instrument."""
 		self._last_cmd = cmd
 		self._update_cmd_vals_cache(cmd)
 		return
 
 	def query_str(self, query: str) -> str:
@@ -121,15 +133,15 @@
 		return 'Simulating' if cached is None else cached
 
 	def write_with_opc(self, cmd: str, timeout: int = None) -> None:
 		"""Sends command with OPC-sync.
 		If you do not provide timeout, the method uses current opc_timeout."""
 		self.write(cmd)
 
-	def query_str_with_opc(self, query: str, timeout: int = None) -> str:
+	def query_str_with_opc(self, query: str, timeout: int = None, context: str = 'Query string with OPC') -> str:
 		"""Query string with OPC synchronization.
 		The response is trimmed for any trailing LF.
 		If you do not provide timeout, the method uses current opc_timeout."""
 		return self.query_str(query)
 
 	def query_opc(self, timeout: int = 0) -> bool:
 		"""Sends *OPC? query and reads the result."""
@@ -160,28 +172,28 @@
 		cached = self._get_cmd_cached_value(query)
 
 		if cached is None:
 			stream.write(bytes([0, 1, 2, 3, 4, 5, 6, 7, 8, 65, 66]))
 			self.cached_to_stream = False
 		else:
 			if isinstance(cached, str):
-				stream.switch_to_string_data()
+				stream.switch_to_string_data(self.encoding)
 			stream.write(cached)
 			self.cached_to_stream = True
 
 	def query_bin_block_with_opc(self, query: str, stream: StreamWriter, exc_if_not_bin: bool = True, timeout: int = None) -> None:
 		"""Query binary data block with OPC and returns it as byte data."""
 		self.query_bin_block(query, stream)
 
 	def read_up_to_char(self, stop_chars: bytes, max_cnt: int) -> bytes:
 		"""Reads until one of the stop_chars is read or the max_cnt is reached, or EOT is detected.
 		Returns the read data including the stop character."""
 		return b'Simulating'
 
 	def get_session_handle(self) -> object:
 		"""Returns the underlying pyvisa session."""
-		return f"Simulating session, resource name '{self._resource_name}'"
+		return f"Simulating session, resource name '{self.resource_name}'"
 
 	def close(self) -> None:
 		"""Closes the Visa session.
 		If the object was created with the direct session input, the session is not closed."""
 		return
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/__init__.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/__init__.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,27 +1,30 @@
 """RsCMPX_LteMeas instrument driver
-	:version: 4.0.7.5
-	:copyright: 2021 by Rohde & Schwarz GMBH & Co. KG
+	:version: 5.0.70.14
+	:copyright: 2023 by Rohde & Schwarz GMBH & Co. KG
 	:license: MIT, see LICENSE for more details.
 """
 
-__version__ = '4.0.7.5'
+__version__ = '5.0.70.14'
 
 # Main class
 from RsCMPX_LteMeas.RsCMPX_LteMeas import RsCMPX_LteMeas
 
 # Bin data format
 from RsCMPX_LteMeas.Internal.Conversions import BinIntFormat, BinFloatFormat
 
 # Exceptions
 from RsCMPX_LteMeas.Internal.InstrumentErrors import RsInstrException, TimeoutException, StatusException, UnexpectedResponseException, ResourceError, DriverValueError
 
 # Callback Event Argument prototypes
 from RsCMPX_LteMeas.Internal.IoTransferEventArgs import IoTransferEventArgs
 
+# Logging Mode
+from RsCMPX_LteMeas.Internal.ScpiLogger import LoggingMode
+
 # enums
 from RsCMPX_LteMeas import enums
 
 # repcaps
 from RsCMPX_LteMeas import repcap
 
 # Reliability interface
```

### Comparing `RsCMPX_LteMeas-4.0.7.5/RsCMPX_LteMeas/enums.py` & `RsCMPX_LteMeas-5.0.70/RsCMPX_LteMeas/enums.py`

 * *Files 10% similar despite different names*

```diff
@@ -66,14 +66,23 @@
 	OB85 = 59
 	OB87 = 60
 	OB88 = 61
 	OB9 = 62
 
 
 # noinspection SpellCheckingInspection
+class BandwidthNarrow(Enum):
+	"""4 Members, M010 ... M080"""
+	M010 = 0
+	M020 = 1
+	M040 = 2
+	M080 = 3
+
+
+# noinspection SpellCheckingInspection
 class CarrAggrLocalOscLocation(Enum):
 	"""3 Members, AUTO ... CECC"""
 	AUTO = 0
 	CACB = 1
 	CECC = 2
 
 
@@ -313,14 +322,22 @@
 	Q16 = 0
 	Q256 = 1
 	Q64 = 2
 	QPSK = 3
 
 
 # noinspection SpellCheckingInspection
+class NetworkSharing(Enum):
+	"""3 Members, FSHared ... OCONnection"""
+	FSHared = 0
+	NSHared = 1
+	OCONnection = 2
+
+
+# noinspection SpellCheckingInspection
 class NetworkSigValue(Enum):
 	"""32 Members, NS01 ... NS32"""
 	NS01 = 0
 	NS02 = 1
 	NS03 = 2
 	NS04 = 3
 	NS05 = 4
@@ -678,22 +695,23 @@
 	F2A = 4
 	F2B = 5
 	F3 = 6
 
 
 # noinspection SpellCheckingInspection
 class RbTableChannelType(Enum):
-	"""7 Members, DL ... SSUB"""
+	"""8 Members, DL ... SSUB"""
 	DL = 0
 	NONE = 1
-	PSCCh = 2
-	PSSCh = 3
-	PUCCh = 4
-	PUSCh = 5
-	SSUB = 6
+	PSBCh = 2
+	PSCCh = 3
+	PSSCh = 4
+	PUCCh = 5
+	PUSCh = 6
+	SSUB = 7
 
 
 # noinspection SpellCheckingInspection
 class Rbw(Enum):
 	"""3 Members, K030 ... M1"""
 	K030 = 0
 	K100 = 1
@@ -744,257 +762,38 @@
 	UFL = 7
 	ULEL = 8
 	ULEU = 9
 
 
 # noinspection SpellCheckingInspection
 class RetriggerFlag(Enum):
-	"""3 Members, IFPower ... ON"""
-	IFPower = 0
-	OFF = 1
-	ON = 2
-
-
-# noinspection SpellCheckingInspection
-class RxConnector(Enum):
-	"""163 Members, I11I ... RH8"""
-	I11I = 0
-	I13I = 1
-	I15I = 2
-	I17I = 3
-	I21I = 4
-	I23I = 5
-	I25I = 6
-	I27I = 7
-	I31I = 8
-	I33I = 9
-	I35I = 10
-	I37I = 11
-	I41I = 12
-	I43I = 13
-	I45I = 14
-	I47I = 15
-	IFI1 = 16
-	IFI2 = 17
-	IFI3 = 18
-	IFI4 = 19
-	IFI5 = 20
-	IFI6 = 21
-	IQ1I = 22
-	IQ3I = 23
-	IQ5I = 24
-	IQ7I = 25
-	R10D = 26
-	R11 = 27
-	R11C = 28
-	R11D = 29
-	R12 = 30
-	R12C = 31
-	R12D = 32
-	R12I = 33
-	R13 = 34
-	R13C = 35
-	R14 = 36
-	R14C = 37
-	R14I = 38
-	R15 = 39
-	R16 = 40
-	R17 = 41
-	R18 = 42
-	R21 = 43
-	R21C = 44
-	R22 = 45
-	R22C = 46
-	R22I = 47
-	R23 = 48
-	R23C = 49
-	R24 = 50
-	R24C = 51
-	R24I = 52
-	R25 = 53
-	R26 = 54
-	R27 = 55
-	R28 = 56
-	R31 = 57
-	R31C = 58
-	R32 = 59
-	R32C = 60
-	R32I = 61
-	R33 = 62
-	R33C = 63
-	R34 = 64
-	R34C = 65
-	R34I = 66
-	R35 = 67
-	R36 = 68
-	R37 = 69
-	R38 = 70
-	R41 = 71
-	R41C = 72
-	R42 = 73
-	R42C = 74
-	R42I = 75
-	R43 = 76
-	R43C = 77
-	R44 = 78
-	R44C = 79
-	R44I = 80
-	R45 = 81
-	R46 = 82
-	R47 = 83
-	R48 = 84
-	RA1 = 85
-	RA2 = 86
-	RA3 = 87
-	RA4 = 88
-	RA5 = 89
-	RA6 = 90
-	RA7 = 91
-	RA8 = 92
-	RB1 = 93
-	RB2 = 94
-	RB3 = 95
-	RB4 = 96
-	RB5 = 97
-	RB6 = 98
-	RB7 = 99
-	RB8 = 100
-	RC1 = 101
-	RC2 = 102
-	RC3 = 103
-	RC4 = 104
-	RC5 = 105
-	RC6 = 106
-	RC7 = 107
-	RC8 = 108
-	RD1 = 109
-	RD2 = 110
-	RD3 = 111
-	RD4 = 112
-	RD5 = 113
-	RD6 = 114
-	RD7 = 115
-	RD8 = 116
-	RE1 = 117
-	RE2 = 118
-	RE3 = 119
-	RE4 = 120
-	RE5 = 121
-	RE6 = 122
-	RE7 = 123
-	RE8 = 124
-	RF1 = 125
-	RF1C = 126
-	RF2 = 127
-	RF2C = 128
-	RF2I = 129
-	RF3 = 130
-	RF3C = 131
-	RF4 = 132
-	RF4C = 133
-	RF4I = 134
-	RF5 = 135
-	RF5C = 136
-	RF6 = 137
-	RF6C = 138
-	RF7 = 139
-	RF7C = 140
-	RF8 = 141
-	RF8C = 142
-	RF9C = 143
-	RFAC = 144
-	RFBC = 145
-	RFBI = 146
-	RG1 = 147
-	RG2 = 148
-	RG3 = 149
-	RG4 = 150
-	RG5 = 151
-	RG6 = 152
-	RG7 = 153
-	RG8 = 154
-	RH1 = 155
-	RH2 = 156
-	RH3 = 157
-	RH4 = 158
-	RH5 = 159
-	RH6 = 160
-	RH7 = 161
-	RH8 = 162
-
-
-# noinspection SpellCheckingInspection
-class RxConverter(Enum):
-	"""40 Members, IRX1 ... RX44"""
-	IRX1 = 0
-	IRX11 = 1
-	IRX12 = 2
-	IRX13 = 3
-	IRX14 = 4
-	IRX2 = 5
-	IRX21 = 6
-	IRX22 = 7
-	IRX23 = 8
-	IRX24 = 9
-	IRX3 = 10
-	IRX31 = 11
-	IRX32 = 12
-	IRX33 = 13
-	IRX34 = 14
-	IRX4 = 15
-	IRX41 = 16
-	IRX42 = 17
-	IRX43 = 18
-	IRX44 = 19
-	RX1 = 20
-	RX11 = 21
-	RX12 = 22
-	RX13 = 23
-	RX14 = 24
-	RX2 = 25
-	RX21 = 26
-	RX22 = 27
-	RX23 = 28
-	RX24 = 29
-	RX3 = 30
-	RX31 = 31
-	RX32 = 32
-	RX33 = 33
-	RX34 = 34
-	RX4 = 35
-	RX41 = 36
-	RX42 = 37
-	RX43 = 38
-	RX44 = 39
-
-
-# noinspection SpellCheckingInspection
-class Scenario(Enum):
-	"""4 Members, CSPath ... SALone"""
-	CSPath = 0
-	MAPRotocol = 1
-	NAV = 2
-	SALone = 3
+	"""4 Members, IFPNarrow ... ON"""
+	IFPNarrow = 0
+	IFPower = 1
+	OFF = 2
+	ON = 3
 
 
 # noinspection SpellCheckingInspection
 class SegmentChannelTypeExtended(Enum):
-	"""5 Members, AUTO ... PUSCh"""
+	"""6 Members, AUTO ... PUSCh"""
 	AUTO = 0
-	PSCCh = 1
-	PSSCh = 2
-	PUCCh = 3
-	PUSCh = 4
+	PSBCh = 1
+	PSCCh = 2
+	PSSCh = 3
+	PUCCh = 4
+	PUSCh = 5
 
 
 # noinspection SpellCheckingInspection
 class SidelinkChannelType(Enum):
-	"""2 Members, PSCCh ... PSSCh"""
-	PSCCh = 0
-	PSSCh = 1
+	"""3 Members, PSBCh ... PSSCh"""
+	PSBCh = 0
+	PSCCh = 1
+	PSSCh = 2
 
 
 # noinspection SpellCheckingInspection
 class SignalSlope(Enum):
 	"""2 Members, FEDGe ... REDGe"""
 	FEDGe = 0
 	REDGe = 1
@@ -1018,22 +817,45 @@
 class SyncMode(Enum):
 	"""2 Members, ENHanced ... NORMal"""
 	ENHanced = 0
 	NORMal = 1
 
 
 # noinspection SpellCheckingInspection
+class TargetStateA(Enum):
+	"""3 Members, OFF ... RUN"""
+	OFF = 0
+	RDY = 1
+	RUN = 2
+
+
+# noinspection SpellCheckingInspection
+class TargetSyncState(Enum):
+	"""2 Members, ADJusted ... PENDing"""
+	ADJusted = 0
+	PENDing = 1
+
+
+# noinspection SpellCheckingInspection
 class TimeMask(Enum):
 	"""3 Members, GOO ... SBLanking"""
 	GOO = 0
 	PPSRs = 1
 	SBLanking = 2
 
 
 # noinspection SpellCheckingInspection
+class TraceSelect(Enum):
+	"""3 Members, AVERage ... MAXimum"""
+	AVERage = 0
+	CURRent = 1
+	MAXimum = 2
+
+
+# noinspection SpellCheckingInspection
 class UplinkChannelType(Enum):
 	"""2 Members, PUCCh ... PUSCh"""
 	PUCCh = 0
 	PUSCh = 1
 
 
 # noinspection SpellCheckingInspection
@@ -1054,23 +876,24 @@
 	RBATable = 12
 	SEMask = 13
 	TXM = 14
 
 
 # noinspection SpellCheckingInspection
 class ViewPrach(Enum):
-	"""9 Members, EVMagnitude ... TXM"""
+	"""10 Members, EVMagnitude ... TXM"""
 	EVMagnitude = 0
 	EVPReamble = 1
-	IQ = 2
-	MERRor = 3
-	OVERview = 4
-	PDYNamics = 5
-	PERRor = 6
-	PVPReamble = 7
-	TXM = 8
+	EVSYmbol = 2
+	IQ = 3
+	MERRor = 4
+	OVERview = 5
+	PDYNamics = 6
+	PERRor = 7
+	PVPReamble = 8
+	TXM = 9
 
 
 # noinspection SpellCheckingInspection
 class ViewSrs(Enum):
 	"""1 Members, PDYNamics ... PDYNamics"""
 	PDYNamics = 0
```

