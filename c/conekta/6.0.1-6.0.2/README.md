# Comparing `tmp/conekta-6.0.1.tar.gz` & `tmp/conekta-6.0.2.tar.gz`

## filetype from file(1)

```diff
@@ -1 +1 @@
-gzip compressed data, was "conekta-6.0.1.tar", last modified: Fri Jul  7 16:46:13 2023, max compression
+gzip compressed data, was "conekta-6.0.2.tar", last modified: Fri Dec 22 16:33:06 2023, max compression
```

## Comparing `conekta-6.0.1.tar` & `conekta-6.0.2.tar`

### file list

```diff
@@ -1,276 +1,283 @@
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-07 16:46:13.150551 conekta-6.0.1/
--rw-r--r--   0 runner    (1001) docker     (123)     1398 2023-07-07 16:46:02.000000 conekta-6.0.1/AUTHORS.md
--rw-r--r--   0 runner    (1001) docker     (123)     1096 2023-07-07 16:46:02.000000 conekta-6.0.1/LICENSE
--rw-r--r--   0 runner    (1001) docker     (123)       37 2023-07-07 16:46:02.000000 conekta-6.0.1/MANIFEST.in
--rw-r--r--   0 runner    (1001) docker     (123)    28438 2023-07-07 16:46:13.150551 conekta-6.0.1/PKG-INFO
--rw-r--r--   0 runner    (1001) docker     (123)    27689 2023-07-07 16:46:02.000000 conekta-6.0.1/README.md
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-07 16:46:13.110548 conekta-6.0.1/conekta/
--rw-r--r--   0 runner    (1001) docker     (123)    17504 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-07 16:46:13.118548 conekta-6.0.1/conekta/api/
--rw-r--r--   0 runner    (1001) docker     (123)     1214 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/api/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)    43665 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/api/antifraud_api.py
--rw-r--r--   0 runner    (1001) docker     (123)    40748 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/api/api_keys_api.py
--rw-r--r--   0 runner    (1001) docker     (123)     7245 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/api/balances_api.py
--rw-r--r--   0 runner    (1001) docker     (123)    19076 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/api/charges_api.py
--rw-r--r--   0 runner    (1001) docker     (123)    16249 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/api/companies_api.py
--rw-r--r--   0 runner    (1001) docker     (123)    63028 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/api/customers_api.py
--rw-r--r--   0 runner    (1001) docker     (123)    46902 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/api/discounts_api.py
--rw-r--r--   0 runner    (1001) docker     (123)    25270 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/api/events_api.py
--rw-r--r--   0 runner    (1001) docker     (123)    18002 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/api/logs_api.py
--rw-r--r--   0 runner    (1001) docker     (123)    67602 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/api/orders_api.py
--rw-r--r--   0 runner    (1001) docker     (123)    51140 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/api/payment_link_api.py
--rw-r--r--   0 runner    (1001) docker     (123)    38951 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/api/payment_methods_api.py
--rw-r--r--   0 runner    (1001) docker     (123)    41008 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/api/plans_api.py
--rw-r--r--   0 runner    (1001) docker     (123)    27109 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/api/products_api.py
--rw-r--r--   0 runner    (1001) docker     (123)    28786 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/api/shipping_contacts_api.py
--rw-r--r--   0 runner    (1001) docker     (123)    27258 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/api/shippings_api.py
--rw-r--r--   0 runner    (1001) docker     (123)    57213 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/api/subscriptions_api.py
--rw-r--r--   0 runner    (1001) docker     (123)    27176 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/api/taxes_api.py
--rw-r--r--   0 runner    (1001) docker     (123)     8103 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/api/tokens_api.py
--rw-r--r--   0 runner    (1001) docker     (123)    18251 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/api/transactions_api.py
--rw-r--r--   0 runner    (1001) docker     (123)    18152 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/api/transfers_api.py
--rw-r--r--   0 runner    (1001) docker     (123)    39790 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/api/webhook_keys_api.py
--rw-r--r--   0 runner    (1001) docker     (123)    47871 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/api/webhooks_api.py
--rw-r--r--   0 runner    (1001) docker     (123)    30526 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/api_client.py
--rw-r--r--   0 runner    (1001) docker     (123)      844 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/api_response.py
--rw-r--r--   0 runner    (1001) docker     (123)    14582 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/configuration.py
--rw-r--r--   0 runner    (1001) docker     (123)     5106 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/exceptions.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-07 16:46:13.150551 conekta-6.0.1/conekta/models/
--rw-r--r--   0 runner    (1001) docker     (123)    15857 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     4267 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/api_key_create_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     2224 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/api_key_create_response_all_of.py
--rw-r--r--   0 runner    (1001) docker     (123)     2033 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/api_key_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     3853 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/api_key_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     3281 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/api_key_response_on_delete.py
--rw-r--r--   0 runner    (1001) docker     (123)     2167 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/api_key_update_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     2098 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/balance_common_field.py
--rw-r--r--   0 runner    (1001) docker     (123)     7770 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/balance_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     2390 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/blacklist_rule_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     6747 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/charge_data_payment_method_bank_transfer_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     3143 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/charge_data_payment_method_card_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     3394 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/charge_data_payment_method_cash_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     5686 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/charge_order_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     7756 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/charge_order_response_payment_method.py
--rw-r--r--   0 runner    (1001) docker     (123)     2786 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/charge_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     2736 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/charge_request_payment_method.py
--rw-r--r--   0 runner    (1001) docker     (123)     5463 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/charge_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     2279 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/charge_response_channel.py
--rw-r--r--   0 runner    (1001) docker     (123)     7696 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/charge_response_payment_method.py
--rw-r--r--   0 runner    (1001) docker     (123)     3581 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/charge_response_refunds.py
--rw-r--r--   0 runner    (1001) docker     (123)     2481 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/charge_response_refunds_all_of.py
--rw-r--r--   0 runner    (1001) docker     (123)     2592 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/charge_response_refunds_data.py
--rw-r--r--   0 runner    (1001) docker     (123)     5503 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/charges_data_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     4852 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/checkout.py
--rw-r--r--   0 runner    (1001) docker     (123)     3675 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/checkout_order_template.py
--rw-r--r--   0 runner    (1001) docker     (123)     5470 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/checkout_order_template_customer_info.py
--rw-r--r--   0 runner    (1001) docker     (123)     3494 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/checkout_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     5017 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/checkout_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     3481 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/checkouts_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     2374 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/checkouts_response_all_of.py
--rw-r--r--   0 runner    (1001) docker     (123)     3420 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/company_fiscal_info_address_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     3617 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/company_fiscal_info_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     3434 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/company_payout_destination_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     4146 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/company_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     3404 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/create_customer_fiscal_entities_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     2464 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/create_customer_fiscal_entities_response_all_of.py
--rw-r--r--   0 runner    (1001) docker     (123)     6483 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/create_customer_payment_methods_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     8321 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/create_customer_payment_methods_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     2182 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/create_risk_rules_data.py
--rw-r--r--   0 runner    (1001) docker     (123)     7153 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/customer.py
--rw-r--r--   0 runner    (1001) docker     (123)     2700 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/customer_address.py
--rw-r--r--   0 runner    (1001) docker     (123)     2075 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/customer_antifraud_info.py
--rw-r--r--   0 runner    (1001) docker     (123)     2139 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/customer_antifraud_info_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     3388 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/customer_fiscal_entities_data_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     2870 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/customer_fiscal_entities_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     2868 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/customer_fiscal_entities_request_address.py
--rw-r--r--   0 runner    (1001) docker     (123)     2838 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/customer_fiscal_entities_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     2553 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/customer_fiscal_entities_response_all_of.py
--rw-r--r--   0 runner    (1001) docker     (123)     2201 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/customer_info.py
--rw-r--r--   0 runner    (1001) docker     (123)     1945 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/customer_info_just_customer_id.py
--rw-r--r--   0 runner    (1001) docker     (123)     2033 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/customer_info_just_customer_id_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     2318 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/customer_info_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     2034 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/customer_payment_method_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     2416 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/customer_payment_methods.py
--rw-r--r--   0 runner    (1001) docker     (123)     8201 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/customer_payment_methods_data.py
--rw-r--r--   0 runner    (1001) docker     (123)     6355 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/customer_payment_methods_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     3627 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/customer_payment_methods_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     6535 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/customer_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     2862 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/customer_response_shipping_contacts.py
--rw-r--r--   0 runner    (1001) docker     (123)     2577 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/customer_response_shipping_contacts_all_of.py
--rw-r--r--   0 runner    (1001) docker     (123)     3750 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/customer_shipping_contacts.py
--rw-r--r--   0 runner    (1001) docker     (123)     2954 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/customer_shipping_contacts_address.py
--rw-r--r--   0 runner    (1001) docker     (123)     3887 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/customer_shipping_contacts_data_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     2228 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/customer_shipping_contacts_data_response_all_of.py
--rw-r--r--   0 runner    (1001) docker     (123)     3599 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/customer_shipping_contacts_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     2736 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/customer_shipping_contacts_response_address.py
--rw-r--r--   0 runner    (1001) docker     (123)     2915 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/customer_update_fiscal_entities_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     3796 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/customer_update_shipping_contacts.py
--rw-r--r--   0 runner    (1001) docker     (123)     3481 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/customers_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     2374 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/customers_response_all_of.py
--rw-r--r--   0 runner    (1001) docker     (123)     3222 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/delete_api_keys_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     1955 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/delete_api_keys_response_all_of.py
--rw-r--r--   0 runner    (1001) docker     (123)     2462 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/deleted_blacklist_rule_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     2462 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/deleted_whitelist_rule_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     2265 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/details.py
--rw-r--r--   0 runner    (1001) docker     (123)     2326 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/details_error.py
--rw-r--r--   0 runner    (1001) docker     (123)     2629 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/discount_lines_data_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     2597 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/discount_lines_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     2188 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/discount_lines_response_all_of.py
--rw-r--r--   0 runner    (1001) docker     (123)     1873 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/email_checkout_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     2765 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/error.py
--rw-r--r--   0 runner    (1001) docker     (123)     2232 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/error_all_of.py
--rw-r--r--   0 runner    (1001) docker     (123)     3053 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/event_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     2525 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/events_resend_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     3482 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/get_api_keys_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     2375 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/get_api_keys_response_all_of.py
--rw-r--r--   0 runner    (1001) docker     (123)     3481 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/get_charges_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     2374 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/get_charges_response_all_of.py
--rw-r--r--   0 runner    (1001) docker     (123)     3501 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/get_companies_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     2394 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/get_companies_response_all_of.py
--rw-r--r--   0 runner    (1001) docker     (123)     8321 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/get_customer_payment_method_data_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     3469 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/get_events_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     2362 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/get_events_response_all_of.py
--rw-r--r--   0 runner    (1001) docker     (123)     3598 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/get_order_discount_lines_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     2491 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/get_order_discount_lines_response_all_of.py
--rw-r--r--   0 runner    (1001) docker     (123)     3465 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/get_orders_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     3621 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/get_payment_method_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     2514 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/get_payment_method_response_all_of.py
--rw-r--r--   0 runner    (1001) docker     (123)     3457 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/get_plans_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     2350 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/get_plans_response_all_of.py
--rw-r--r--   0 runner    (1001) docker     (123)     3576 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/get_transactions_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     2476 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/get_transactions_response_all_of.py
--rw-r--r--   0 runner    (1001) docker     (123)     3541 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/get_transfers_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     2441 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/get_transfers_response_all_of.py
--rw-r--r--   0 runner    (1001) docker     (123)     3530 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/get_webhook_keys_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     2423 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/get_webhook_keys_response_all_of.py
--rw-r--r--   0 runner    (1001) docker     (123)     3493 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/get_webhooks_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     2386 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/get_webhooks_response_all_of.py
--rw-r--r--   0 runner    (1001) docker     (123)     4657 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/log_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     3741 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/logs_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     4704 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/logs_response_data.py
--rw-r--r--   0 runner    (1001) docker     (123)     1915 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/order_capture_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     2297 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/order_discount_lines_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     2310 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/order_refund_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     8156 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/order_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     5304 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/order_request_customer_info.py
--rw-r--r--   0 runner    (1001) docker     (123)     7721 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/order_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     2713 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/order_response_charges.py
--rw-r--r--   0 runner    (1001) docker     (123)     2411 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/order_response_charges_all_of.py
--rw-r--r--   0 runner    (1001) docker     (123)     5164 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/order_response_checkout.py
--rw-r--r--   0 runner    (1001) docker     (123)     2468 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/order_response_customer_info.py
--rw-r--r--   0 runner    (1001) docker     (123)     1981 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/order_response_customer_info_all_of.py
--rw-r--r--   0 runner    (1001) docker     (123)     2769 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/order_response_discount_lines.py
--rw-r--r--   0 runner    (1001) docker     (123)     2484 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/order_response_discount_lines_all_of.py
--rw-r--r--   0 runner    (1001) docker     (123)     2572 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/order_response_fiscal_entity.py
--rw-r--r--   0 runner    (1001) docker     (123)     2926 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/order_response_fiscal_entity_address.py
--rw-r--r--   0 runner    (1001) docker     (123)     2037 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/order_response_fiscal_entity_address_all_of.py
--rw-r--r--   0 runner    (1001) docker     (123)     3526 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/order_response_products.py
--rw-r--r--   0 runner    (1001) docker     (123)     2419 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/order_response_products_all_of.py
--rw-r--r--   0 runner    (1001) docker     (123)     3504 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/order_response_shipping_contact.py
--rw-r--r--   0 runner    (1001) docker     (123)     2196 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/order_response_shipping_contact_all_of.py
--rw-r--r--   0 runner    (1001) docker     (123)     2252 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/order_tax_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     7446 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/order_update_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     5380 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/order_update_request_customer_info.py
--rw-r--r--   0 runner    (1001) docker     (123)     2291 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/orders_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     2521 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/page.py
--rw-r--r--   0 runner    (1001) docker     (123)     2027 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/pagination.py
--rw-r--r--   0 runner    (1001) docker     (123)     1930 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/payment_method.py
--rw-r--r--   0 runner    (1001) docker     (123)     6790 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/payment_method_bank_transfer.py
--rw-r--r--   0 runner    (1001) docker     (123)     3180 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/payment_method_card.py
--rw-r--r--   0 runner    (1001) docker     (123)     2265 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/payment_method_card_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     2227 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/payment_method_card_request_all_of.py
--rw-r--r--   0 runner    (1001) docker     (123)     3341 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/payment_method_card_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     2917 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/payment_method_card_response_all_of.py
--rw-r--r--   0 runner    (1001) docker     (123)     3438 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/payment_method_cash.py
--rw-r--r--   0 runner    (1001) docker     (123)     2083 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/payment_method_cash_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     1989 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/payment_method_cash_request_all_of.py
--rw-r--r--   0 runner    (1001) docker     (123)     2817 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/payment_method_cash_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     2404 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/payment_method_cash_response_all_of.py
--rw-r--r--   0 runner    (1001) docker     (123)     2275 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/payment_method_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     2523 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/payment_method_spei_recurrent.py
--rw-r--r--   0 runner    (1001) docker     (123)     2098 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/payment_method_spei_recurrent_all_of.py
--rw-r--r--   0 runner    (1001) docker     (123)     2083 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/payment_method_spei_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     3623 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/plan_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     3362 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/plan_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     2645 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/plan_update_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     3285 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/product.py
--rw-r--r--   0 runner    (1001) docker     (123)     3647 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/product_data_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     2109 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/product_data_response_all_of.py
--rw-r--r--   0 runner    (1001) docker     (123)     3655 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/product_order_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     2117 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/product_order_response_all_of.py
--rw-r--r--   0 runner    (1001) docker     (123)     2259 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/risk_rules.py
--rw-r--r--   0 runner    (1001) docker     (123)     2741 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/risk_rules_data.py
--rw-r--r--   0 runner    (1001) docker     (123)     3438 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/risk_rules_list.py
--rw-r--r--   0 runner    (1001) docker     (123)     2926 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/shipping_order_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     2612 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/shipping_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     1881 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/sms_checkout_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     3541 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/subscription_events_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     2215 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/subscription_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     5351 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/subscription_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     2201 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/subscription_update_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     2830 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/token.py
--rw-r--r--   0 runner    (1001) docker     (123)     2877 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/token_card.py
--rw-r--r--   0 runner    (1001) docker     (123)     1984 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/token_checkout.py
--rw-r--r--   0 runner    (1001) docker     (123)     3004 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/token_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     5537 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/token_response_checkout.py
--rw-r--r--   0 runner    (1001) docker     (123)     3877 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/transaction_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     3105 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/transfer_destination_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     3070 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/transfer_method_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     4052 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/transfer_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     3979 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/transfers_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     7258 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/update_customer.py
--rw-r--r--   0 runner    (1001) docker     (123)     2123 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/update_customer_antifraud_info.py
--rw-r--r--   0 runner    (1001) docker     (123)     3404 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/update_customer_fiscal_entities_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     2464 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/update_customer_fiscal_entities_response_all_of.py
--rw-r--r--   0 runner    (1001) docker     (123)     8321 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/update_customer_payment_methods_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     2232 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/update_order_discount_lines_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     2327 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/update_order_tax_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     2583 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/update_order_tax_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     2133 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/update_order_tax_response_all_of.py
--rw-r--r--   0 runner    (1001) docker     (123)     1893 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/update_payment_methods.py
--rw-r--r--   0 runner    (1001) docker     (123)     2753 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/update_product.py
--rw-r--r--   0 runner    (1001) docker     (123)     2825 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/webhook_key_create_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     2817 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/webhook_key_delete_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     1990 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/webhook_key_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     3234 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/webhook_key_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     2040 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/webhook_key_update_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     2544 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/webhook_log.py
--rw-r--r--   0 runner    (1001) docker     (123)     2659 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/webhook_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     3066 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/webhook_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     2918 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/webhook_update_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     2422 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/models/whitelistlist_rule_response.py
--rw-r--r--   0 runner    (1001) docker     (123)    12745 2023-07-07 16:46:02.000000 conekta-6.0.1/conekta/rest.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-07 16:46:13.114548 conekta-6.0.1/conekta.egg-info/
--rw-r--r--   0 runner    (1001) docker     (123)    28438 2023-07-07 16:46:13.000000 conekta-6.0.1/conekta.egg-info/PKG-INFO
--rw-r--r--   0 runner    (1001) docker     (123)    10667 2023-07-07 16:46:13.000000 conekta-6.0.1/conekta.egg-info/SOURCES.txt
--rw-r--r--   0 runner    (1001) docker     (123)        1 2023-07-07 16:46:13.000000 conekta-6.0.1/conekta.egg-info/dependency_links.txt
--rw-r--r--   0 runner    (1001) docker     (123)       58 2023-07-07 16:46:13.000000 conekta-6.0.1/conekta.egg-info/requires.txt
--rw-r--r--   0 runner    (1001) docker     (123)        8 2023-07-07 16:46:13.000000 conekta-6.0.1/conekta.egg-info/top_level.txt
--rw-r--r--   0 runner    (1001) docker     (123)     1260 2023-07-07 16:46:02.000000 conekta-6.0.1/pyproject.toml
--rw-r--r--   0 runner    (1001) docker     (123)       69 2023-07-07 16:46:13.154552 conekta-6.0.1/setup.cfg
--rw-r--r--   0 runner    (1001) docker     (123)     1161 2023-07-07 16:46:02.000000 conekta-6.0.1/setup.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-07 16:46:13.150551 conekta-6.0.1/test/
--rw-r--r--   0 runner    (1001) docker     (123)     2820 2023-07-07 16:46:02.000000 conekta-6.0.1/test/test_antifraud_api.py
--rw-r--r--   0 runner    (1001) docker     (123)     2491 2023-07-07 16:46:02.000000 conekta-6.0.1/test/test_api_keys_api.py
--rw-r--r--   0 runner    (1001) docker     (123)      802 2023-07-07 16:46:02.000000 conekta-6.0.1/test/test_balances_api.py
--rw-r--r--   0 runner    (1001) docker     (123)     2068 2023-07-07 16:46:02.000000 conekta-6.0.1/test/test_charges_api.py
--rw-r--r--   0 runner    (1001) docker     (123)     1354 2023-07-07 16:46:02.000000 conekta-6.0.1/test/test_companies_api.py
--rw-r--r--   0 runner    (1001) docker     (123)     4402 2023-07-07 16:46:02.000000 conekta-6.0.1/test/test_customers_api.py
--rw-r--r--   0 runner    (1001) docker     (123)     2065 2023-07-07 16:46:02.000000 conekta-6.0.1/test/test_discounts_api.py
--rw-r--r--   0 runner    (1001) docker     (123)     1592 2023-07-07 16:46:02.000000 conekta-6.0.1/test/test_events_api.py
--rw-r--r--   0 runner    (1001) docker     (123)     1306 2023-07-07 16:46:02.000000 conekta-6.0.1/test/test_logs_api.py
--rw-r--r--   0 runner    (1001) docker     (123)     4517 2023-07-07 16:46:02.000000 conekta-6.0.1/test/test_orders_api.py
--rw-r--r--   0 runner    (1001) docker     (123)     3223 2023-07-07 16:46:02.000000 conekta-6.0.1/test/test_payment_link_api.py
--rw-r--r--   0 runner    (1001) docker     (123)     3003 2023-07-07 16:46:02.000000 conekta-6.0.1/test/test_payment_methods_api.py
--rw-r--r--   0 runner    (1001) docker     (123)     2348 2023-07-07 16:46:02.000000 conekta-6.0.1/test/test_plans_api.py
--rw-r--r--   0 runner    (1001) docker     (123)     2132 2023-07-07 16:46:02.000000 conekta-6.0.1/test/test_products_api.py
--rw-r--r--   0 runner    (1001) docker     (123)     2432 2023-07-07 16:46:02.000000 conekta-6.0.1/test/test_shipping_contacts_api.py
--rw-r--r--   0 runner    (1001) docker     (123)     2042 2023-07-07 16:46:02.000000 conekta-6.0.1/test/test_shippings_api.py
--rw-r--r--   0 runner    (1001) docker     (123)     3151 2023-07-07 16:46:02.000000 conekta-6.0.1/test/test_subscriptions_api.py
--rw-r--r--   0 runner    (1001) docker     (123)     1990 2023-07-07 16:46:02.000000 conekta-6.0.1/test/test_taxes_api.py
--rw-r--r--   0 runner    (1001) docker     (123)     1298 2023-07-07 16:46:02.000000 conekta-6.0.1/test/test_tokens_api.py
--rw-r--r--   0 runner    (1001) docker     (123)     1396 2023-07-07 16:46:02.000000 conekta-6.0.1/test/test_transactions_api.py
--rw-r--r--   0 runner    (1001) docker     (123)     1359 2023-07-07 16:46:02.000000 conekta-6.0.1/test/test_transfers_api.py
--rw-r--r--   0 runner    (1001) docker     (123)      114 2023-07-07 16:46:02.000000 conekta-6.0.1/test/test_utils.py
--rw-r--r--   0 runner    (1001) docker     (123)     2430 2023-07-07 16:46:02.000000 conekta-6.0.1/test/test_webhook_keys_api.py
--rw-r--r--   0 runner    (1001) docker     (123)     2690 2023-07-07 16:46:02.000000 conekta-6.0.1/test/test_webhooks_api.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-12-22 16:33:06.913409 conekta-6.0.2/
+-rw-r--r--   0 runner    (1001) docker     (127)     1398 2023-12-22 16:32:56.000000 conekta-6.0.2/AUTHORS.md
+-rw-r--r--   0 runner    (1001) docker     (127)     1096 2023-12-22 16:32:56.000000 conekta-6.0.2/LICENSE
+-rw-r--r--   0 runner    (1001) docker     (127)       37 2023-12-22 16:32:56.000000 conekta-6.0.2/MANIFEST.in
+-rw-r--r--   0 runner    (1001) docker     (127)      505 2023-12-22 16:33:06.909409 conekta-6.0.2/PKG-INFO
+-rw-r--r--   0 runner    (1001) docker     (127)    28195 2023-12-22 16:32:56.000000 conekta-6.0.2/README.md
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-12-22 16:33:06.865409 conekta-6.0.2/conekta/
+-rw-r--r--   0 runner    (1001) docker     (127)    18011 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-12-22 16:33:06.869409 conekta-6.0.2/conekta/api/
+-rw-r--r--   0 runner    (1001) docker     (127)     1214 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/api/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)    70802 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/api/antifraud_api.py
+-rw-r--r--   0 runner    (1001) docker     (127)    65381 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/api/api_keys_api.py
+-rw-r--r--   0 runner    (1001) docker     (127)    11464 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/api/balances_api.py
+-rw-r--r--   0 runner    (1001) docker     (127)    44037 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/api/charges_api.py
+-rw-r--r--   0 runner    (1001) docker     (127)    25875 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/api/companies_api.py
+-rw-r--r--   0 runner    (1001) docker     (127)   100517 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/api/customers_api.py
+-rw-r--r--   0 runner    (1001) docker     (127)    74287 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/api/discounts_api.py
+-rw-r--r--   0 runner    (1001) docker     (127)    40314 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/api/events_api.py
+-rw-r--r--   0 runner    (1001) docker     (127)    28481 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/api/logs_api.py
+-rw-r--r--   0 runner    (1001) docker     (127)   108908 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/api/orders_api.py
+-rw-r--r--   0 runner    (1001) docker     (127)    82599 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/api/payment_link_api.py
+-rw-r--r--   0 runner    (1001) docker     (127)    61359 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/api/payment_methods_api.py
+-rw-r--r--   0 runner    (1001) docker     (127)    66247 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/api/plans_api.py
+-rw-r--r--   0 runner    (1001) docker     (127)    43057 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/api/products_api.py
+-rw-r--r--   0 runner    (1001) docker     (127)    45369 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/api/shipping_contacts_api.py
+-rw-r--r--   0 runner    (1001) docker     (127)    43323 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/api/shippings_api.py
+-rw-r--r--   0 runner    (1001) docker     (127)    92190 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/api/subscriptions_api.py
+-rw-r--r--   0 runner    (1001) docker     (127)    43167 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/api/taxes_api.py
+-rw-r--r--   0 runner    (1001) docker     (127)    12774 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/api/tokens_api.py
+-rw-r--r--   0 runner    (1001) docker     (127)    31057 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/api/transactions_api.py
+-rw-r--r--   0 runner    (1001) docker     (127)    28658 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/api/transfers_api.py
+-rw-r--r--   0 runner    (1001) docker     (127)    63889 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/api/webhook_keys_api.py
+-rw-r--r--   0 runner    (1001) docker     (127)    77156 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/api/webhooks_api.py
+-rw-r--r--   0 runner    (1001) docker     (127)    25400 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/api_client.py
+-rw-r--r--   0 runner    (1001) docker     (127)      674 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/api_response.py
+-rw-r--r--   0 runner    (1001) docker     (127)    14119 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/configuration.py
+-rw-r--r--   0 runner    (1001) docker     (127)     5387 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/exceptions.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-12-22 16:33:06.905409 conekta-6.0.2/conekta/models/
+-rw-r--r--   0 runner    (1001) docker     (127)    16364 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4844 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/api_key_create_response.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2689 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/api_key_create_response_all_of.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2533 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/api_key_request.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4446 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/api_key_response.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3822 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/api_key_response_on_delete.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2664 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/api_key_update_request.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2599 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/balance_common_field.py
+-rw-r--r--   0 runner    (1001) docker     (127)     8302 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/balance_response.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2895 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/blacklist_rule_response.py
+-rw-r--r--   0 runner    (1001) docker     (127)     7129 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/charge_data_payment_method_bank_transfer_response.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3497 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/charge_data_payment_method_card_response.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3803 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/charge_data_payment_method_cash_response.py
+-rw-r--r--   0 runner    (1001) docker     (127)     6092 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/charge_order_response.py
+-rw-r--r--   0 runner    (1001) docker     (127)     8001 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/charge_order_response_payment_method.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3047 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/charge_request.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3391 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/charge_request_payment_method.py
+-rw-r--r--   0 runner    (1001) docker     (127)     5906 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/charge_response.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2732 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/charge_response_channel.py
+-rw-r--r--   0 runner    (1001) docker     (127)     7961 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/charge_response_payment_method.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4058 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/charge_response_refunds.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2924 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/charge_response_refunds_all_of.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3013 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/charge_response_refunds_data.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2471 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/charge_update_request.py
+-rw-r--r--   0 runner    (1001) docker     (127)     5926 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/charges_data_response.py
+-rw-r--r--   0 runner    (1001) docker     (127)     5362 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/checkout.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4164 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/checkout_order_template.py
+-rw-r--r--   0 runner    (1001) docker     (127)     5647 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/checkout_order_template_customer_info.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4005 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/checkout_request.py
+-rw-r--r--   0 runner    (1001) docker     (127)     5443 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/checkout_response.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3966 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/checkouts_response.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2805 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/checkouts_response_all_of.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3933 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/company_fiscal_info_address_response.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4134 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/company_fiscal_info_response.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3929 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/company_payout_destination_response.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4703 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/company_response.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3735 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/create_customer_fiscal_entities_response.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2791 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/create_customer_fiscal_entities_response_all_of.py
+-rw-r--r--   0 runner    (1001) docker     (127)     6726 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/create_customer_payment_methods_request.py
+-rw-r--r--   0 runner    (1001) docker     (127)     8584 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/create_customer_payment_methods_response.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2665 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/create_risk_rules_data.py
+-rw-r--r--   0 runner    (1001) docker     (127)     7688 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/customer.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3216 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/customer_address.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2528 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/customer_antifraud_info.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2560 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/customer_antifraud_info_response.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3727 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/customer_fiscal_entities_data_response.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3268 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/customer_fiscal_entities_request.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3300 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/customer_fiscal_entities_request_address.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3247 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/customer_fiscal_entities_response.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2932 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/customer_fiscal_entities_response_all_of.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2644 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/customer_info.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2375 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/customer_info_just_customer_id.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2434 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/customer_info_just_customer_id_response.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2491 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/customer_payment_method_request.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2847 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/customer_payment_methods.py
+-rw-r--r--   0 runner    (1001) docker     (127)     8504 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/customer_payment_methods_data.py
+-rw-r--r--   0 runner    (1001) docker     (127)     6622 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/customer_payment_methods_request.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4060 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/customer_payment_methods_response.py
+-rw-r--r--   0 runner    (1001) docker     (127)     7481 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/customer_response.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3263 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/customer_response_shipping_contacts.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2948 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/customer_response_shipping_contacts_all_of.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4409 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/customer_shipping_contacts.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3399 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/customer_shipping_contacts_address.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4459 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/customer_shipping_contacts_data_response.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2572 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/customer_shipping_contacts_data_response_all_of.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4218 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/customer_shipping_contacts_response.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3344 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/customer_shipping_contacts_response_address.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3309 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/customer_update_fiscal_entities_request.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4265 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/customer_update_shipping_contacts.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3966 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/customers_response.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2805 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/customers_response_all_of.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3759 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/delete_api_keys_response.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2388 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/delete_api_keys_response_all_of.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2939 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/deleted_blacklist_rule_response.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2939 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/deleted_whitelist_rule_response.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2756 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/details.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2819 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/details_error.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3120 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/discount_lines_data_response.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3104 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/discount_lines_response.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2643 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/discount_lines_response_all_of.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2327 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/email_checkout_request.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3296 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/error.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2761 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/error_all_of.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3509 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/event_response.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2971 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/events_resend_response.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3475 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/fiscal_entity_address.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3963 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/get_api_keys_response.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2802 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/get_api_keys_response_all_of.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3962 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/get_charges_response.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2801 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/get_charges_response_all_of.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3974 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/get_companies_response.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2813 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/get_companies_response_all_of.py
+-rw-r--r--   0 runner    (1001) docker     (127)     8584 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/get_customer_payment_method_data_response.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3954 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/get_events_response.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2793 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/get_events_response_all_of.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4035 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/get_order_discount_lines_response.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2874 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/get_order_discount_lines_response_all_of.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3937 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/get_orders_response.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4078 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/get_payment_method_response.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2917 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/get_payment_method_response_all_of.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3946 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/get_plans_response.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2785 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/get_plans_response_all_of.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4045 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/get_transactions_response.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2911 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/get_transactions_response_all_of.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4022 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/get_transfers_response.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2888 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/get_transfers_response_all_of.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3995 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/get_webhook_keys_response.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2834 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/get_webhook_keys_response_all_of.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3970 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/get_webhooks_response.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2809 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/get_webhooks_response_all_of.py
+-rw-r--r--   0 runner    (1001) docker     (127)     5096 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/log_response.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4360 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/logs_response.py
+-rw-r--r--   0 runner    (1001) docker     (127)     5169 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/logs_response_data.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2455 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/order_capture_request.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3318 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/order_customer_info_response.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2803 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/order_discount_lines_request.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3604 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/order_fiscal_entity_address_response.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2426 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/order_fiscal_entity_address_response_all_of.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3907 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/order_fiscal_entity_request.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4743 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/order_fiscal_entity_response.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3064 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/order_next_action_response.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2837 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/order_next_action_response_redirect_to_url.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2746 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/order_refund_request.py
+-rw-r--r--   0 runner    (1001) docker     (127)     9616 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/order_request.py
+-rw-r--r--   0 runner    (1001) docker     (127)     5517 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/order_request_customer_info.py
+-rw-r--r--   0 runner    (1001) docker     (127)     8996 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/order_response.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3162 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/order_response_charges.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2830 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/order_response_charges_all_of.py
+-rw-r--r--   0 runner    (1001) docker     (127)     5594 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/order_response_checkout.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3428 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/order_response_customer_info.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2398 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/order_response_customer_info_all_of.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3194 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/order_response_discount_lines.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2879 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/order_response_discount_lines_all_of.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3995 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/order_response_products.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2834 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/order_response_products_all_of.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4139 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/order_response_shipping_contact.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2601 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/order_response_shipping_contact_all_of.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2782 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/order_tax_request.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3925 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/order_update_fiscal_entity_request.py
+-rw-r--r--   0 runner    (1001) docker     (127)     8495 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/order_update_request.py
+-rw-r--r--   0 runner    (1001) docker     (127)     5569 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/order_update_request_customer_info.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2734 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/orders_response.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3086 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/page.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2551 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/pagination.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2395 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/payment_method.py
+-rw-r--r--   0 runner    (1001) docker     (127)     7243 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/payment_method_bank_transfer.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3612 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/payment_method_card.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2733 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/payment_method_card_request.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2676 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/payment_method_card_request_all_of.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3719 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/payment_method_card_response.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3334 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/payment_method_card_response_all_of.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3899 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/payment_method_cash.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2539 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/payment_method_cash_request.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2410 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/payment_method_cash_request_all_of.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3195 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/payment_method_cash_response.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2821 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/payment_method_cash_response_all_of.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2669 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/payment_method_response.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2897 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/payment_method_spei_recurrent.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2511 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/payment_method_spei_recurrent_all_of.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2539 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/payment_method_spei_request.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4229 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/plan_request.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3933 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/plan_response.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3220 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/plan_update_request.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3879 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/product.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4193 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/product_data_response.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2550 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/product_data_response_all_of.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4197 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/product_order_response.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2554 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/product_order_response_all_of.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2742 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/risk_rules.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3302 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/risk_rules_data.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3939 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/risk_rules_list.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3462 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/shipping_order_response.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3172 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/shipping_request.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2343 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/sms_checkout_request.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3990 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/subscription_events_response.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2656 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/subscription_request.py
+-rw-r--r--   0 runner    (1001) docker     (127)     5836 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/subscription_response.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2638 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/subscription_update_request.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3355 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/token.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3458 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/token_card.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2497 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/token_checkout.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3493 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/token_response.py
+-rw-r--r--   0 runner    (1001) docker     (127)     6087 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/token_response_checkout.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4367 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/transaction_response.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3618 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/transfer_destination_response.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3603 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/transfer_method_response.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4664 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/transfer_response.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4587 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/transfers_response.py
+-rw-r--r--   0 runner    (1001) docker     (127)     7808 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/update_customer.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2552 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/update_customer_antifraud_info.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3735 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/update_customer_fiscal_entities_response.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2791 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/update_customer_fiscal_entities_response_all_of.py
+-rw-r--r--   0 runner    (1001) docker     (127)     8584 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/update_customer_payment_methods_response.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2720 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/update_order_discount_lines_request.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2867 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/update_order_tax_request.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3072 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/update_order_tax_response.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2562 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/update_order_tax_response_all_of.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2350 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/update_payment_methods.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3313 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/update_product.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3334 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/webhook_key_create_response.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3326 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/webhook_key_delete_response.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2487 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/webhook_key_request.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3779 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/webhook_key_response.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2513 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/webhook_key_update_request.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3030 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/webhook_log.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3226 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/webhook_request.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3529 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/webhook_response.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3395 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/webhook_update_request.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2911 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/models/whitelistlist_rule_response.py
+-rw-r--r--   0 runner    (1001) docker     (127)        0 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/py.typed
+-rw-r--r--   0 runner    (1001) docker     (127)     8228 2023-12-22 16:32:56.000000 conekta-6.0.2/conekta/rest.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-12-22 16:33:06.909409 conekta-6.0.2/conekta.egg-info/
+-rw-r--r--   0 runner    (1001) docker     (127)      505 2023-12-22 16:33:06.000000 conekta-6.0.2/conekta.egg-info/PKG-INFO
+-rw-r--r--   0 runner    (1001) docker     (127)    10975 2023-12-22 16:33:06.000000 conekta-6.0.2/conekta.egg-info/SOURCES.txt
+-rw-r--r--   0 runner    (1001) docker     (127)        1 2023-12-22 16:33:06.000000 conekta-6.0.2/conekta.egg-info/dependency_links.txt
+-rw-r--r--   0 runner    (1001) docker     (127)       76 2023-12-22 16:33:06.000000 conekta-6.0.2/conekta.egg-info/requires.txt
+-rw-r--r--   0 runner    (1001) docker     (127)        8 2023-12-22 16:33:06.000000 conekta-6.0.2/conekta.egg-info/top_level.txt
+-rw-r--r--   0 runner    (1001) docker     (127)      710 2023-12-22 16:32:56.000000 conekta-6.0.2/pyproject.toml
+-rw-r--r--   0 runner    (1001) docker     (127)       69 2023-12-22 16:33:06.913409 conekta-6.0.2/setup.cfg
+-rw-r--r--   0 runner    (1001) docker     (127)     1227 2023-12-22 16:32:56.000000 conekta-6.0.2/setup.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-12-22 16:33:06.909409 conekta-6.0.2/test/
+-rw-r--r--   0 runner    (1001) docker     (127)     2820 2023-12-22 16:32:56.000000 conekta-6.0.2/test/test_antifraud_api.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2491 2023-12-22 16:32:56.000000 conekta-6.0.2/test/test_api_keys_api.py
+-rw-r--r--   0 runner    (1001) docker     (127)      802 2023-12-22 16:32:56.000000 conekta-6.0.2/test/test_balances_api.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2068 2023-12-22 16:32:56.000000 conekta-6.0.2/test/test_charges_api.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1354 2023-12-22 16:32:56.000000 conekta-6.0.2/test/test_companies_api.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4402 2023-12-22 16:32:56.000000 conekta-6.0.2/test/test_customers_api.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2065 2023-12-22 16:32:56.000000 conekta-6.0.2/test/test_discounts_api.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1592 2023-12-22 16:32:56.000000 conekta-6.0.2/test/test_events_api.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1306 2023-12-22 16:32:56.000000 conekta-6.0.2/test/test_logs_api.py
+-rw-r--r--   0 runner    (1001) docker     (127)     5453 2023-12-22 16:32:56.000000 conekta-6.0.2/test/test_orders_api.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3223 2023-12-22 16:32:56.000000 conekta-6.0.2/test/test_payment_link_api.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3003 2023-12-22 16:32:56.000000 conekta-6.0.2/test/test_payment_methods_api.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2348 2023-12-22 16:32:56.000000 conekta-6.0.2/test/test_plans_api.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2132 2023-12-22 16:32:56.000000 conekta-6.0.2/test/test_products_api.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2432 2023-12-22 16:32:56.000000 conekta-6.0.2/test/test_shipping_contacts_api.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2042 2023-12-22 16:32:56.000000 conekta-6.0.2/test/test_shippings_api.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3151 2023-12-22 16:32:56.000000 conekta-6.0.2/test/test_subscriptions_api.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1990 2023-12-22 16:32:56.000000 conekta-6.0.2/test/test_taxes_api.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1298 2023-12-22 16:32:56.000000 conekta-6.0.2/test/test_tokens_api.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1396 2023-12-22 16:32:56.000000 conekta-6.0.2/test/test_transactions_api.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1359 2023-12-22 16:32:56.000000 conekta-6.0.2/test/test_transfers_api.py
+-rw-r--r--   0 runner    (1001) docker     (127)      114 2023-12-22 16:32:56.000000 conekta-6.0.2/test/test_utils.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2453 2023-12-22 16:32:56.000000 conekta-6.0.2/test/test_webhook_keys_api.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2690 2023-12-22 16:32:56.000000 conekta-6.0.2/test/test_webhooks_api.py
```

### Comparing `conekta-6.0.1/AUTHORS.md` & `conekta-6.0.2/AUTHORS.md`

 * *Files identical despite different names*

### Comparing `conekta-6.0.1/LICENSE` & `conekta-6.0.2/LICENSE`

 * *Files identical despite different names*

### Comparing `conekta-6.0.1/PKG-INFO` & `conekta-6.0.2/README.md`

 * *Files 5% similar despite different names*

```diff
@@ -1,34 +1,15 @@
-Metadata-Version: 2.1
-Name: conekta
-Version: 6.0.1
-Summary: This is a Python library that allows interaction with https://api.conekta.io API.
-Home-page: https://github.com/conekta/conekta-python
-Author: Engineering Conekta
-Author-email: Engineering Conekta <engineering@conekta.com>
-License: MIT-LICENSE
-Project-URL: Homepage, https://github.com/conekta/conekta-python
-Project-URL: Bug Tracker, https://github.com/conekta/conekta-python/issues
-Keywords: OpenAPI,OpenAPI-Generator,Conekta API
-Classifier: Programming Language :: Python :: 3
-Classifier: License :: OSI Approved :: MIT License
-Classifier: Operating System :: OS Independent
-Requires-Python: >=3.7
-Description-Content-Type: text/markdown
-License-File: LICENSE
-License-File: AUTHORS.md
-
 # conekta
 Conekta sdk
 
 This Python package is automatically generated by the [OpenAPI Generator](https://openapi-generator.tech) project:
 
 - API version: 2.1.0
-- Package version: 6.0.1
-- Build package: org.openapitools.codegen.languages.PythonNextgenClientCodegen
+- Package version: 6.0.2
+- Build package: org.openapitools.codegen.languages.PythonClientCodegen
 For more information, please visit [https://github.com/conekta/openapi/issues](https://github.com/conekta/openapi/issues)
 
 ## Requirements.
 
 Python 3.7+
 
 ## Installation & Usage
@@ -78,15 +59,15 @@
 # The client must configure the authentication and authorization parameters
 # in accordance with the API server security policy.
 # Examples for each auth method are provided below, use the example that
 # satisfies your auth use case.
 
 # Configure Bearer authorization: bearerAuth
 configuration = conekta.Configuration(
-    access_token = os.environ["BEARER_TOKEN"]
+    access_token = os.environ["API_KEY"]
 )
 
 
 # Enter a context with an instance of the API client
 with conekta.ApiClient(configuration) as api_client:
     # Create an instance of the API class
     api_instance = conekta.CustomersApi(api_client)
@@ -120,17 +101,18 @@
 *AntifraudApi* | [**get_rule_blacklist**](docs/AntifraudApi.md#get_rule_blacklist) | **GET** /antifraud/blacklists | Get list of blacklisted rules
 *AntifraudApi* | [**get_rule_whitelist**](docs/AntifraudApi.md#get_rule_whitelist) | **GET** /antifraud/whitelists | Get a list of whitelisted rules
 *ApiKeysApi* | [**create_api_key**](docs/ApiKeysApi.md#create_api_key) | **POST** /api_keys | Create Api Key
 *ApiKeysApi* | [**delete_api_key**](docs/ApiKeysApi.md#delete_api_key) | **DELETE** /api_keys/{id} | Delete Api Key
 *ApiKeysApi* | [**get_api_key**](docs/ApiKeysApi.md#get_api_key) | **GET** /api_keys/{id} | Get Api Key
 *ApiKeysApi* | [**get_api_keys**](docs/ApiKeysApi.md#get_api_keys) | **GET** /api_keys | Get list of Api Keys
 *ApiKeysApi* | [**update_api_key**](docs/ApiKeysApi.md#update_api_key) | **PUT** /api_keys/{id} | Update Api Key
-*BalancesApi* | [**get_balance**](docs/BalancesApi.md#get_balance) | **GET** /balances | Get a company&#39;s balance
+*BalancesApi* | [**get_balance**](docs/BalancesApi.md#get_balance) | **GET** /balance | Get a company&#39;s balance
 *ChargesApi* | [**get_charges**](docs/ChargesApi.md#get_charges) | **GET** /charges | Get A List of Charges
 *ChargesApi* | [**orders_create_charge**](docs/ChargesApi.md#orders_create_charge) | **POST** /orders/{id}/charges | Create charge
+*ChargesApi* | [**update_charge**](docs/ChargesApi.md#update_charge) | **PUT** /charges/{id} | Update a charge
 *CompaniesApi* | [**get_companies**](docs/CompaniesApi.md#get_companies) | **GET** /companies | Get List of Companies
 *CompaniesApi* | [**get_company**](docs/CompaniesApi.md#get_company) | **GET** /companies/{id} | Get Company
 *CustomersApi* | [**create_customer**](docs/CustomersApi.md#create_customer) | **POST** /customers | Create customer
 *CustomersApi* | [**create_customer_fiscal_entities**](docs/CustomersApi.md#create_customer_fiscal_entities) | **POST** /customers/{id}/fiscal_entities | Create Fiscal Entity
 *CustomersApi* | [**delete_customer_by_id**](docs/CustomersApi.md#delete_customer_by_id) | **DELETE** /customers/{id} | Delete Customer
 *CustomersApi* | [**get_customer_by_id**](docs/CustomersApi.md#get_customer_by_id) | **GET** /customers/{id} | Get Customer
 *CustomersApi* | [**get_customers**](docs/CustomersApi.md#get_customers) | **GET** /customers | Get a list of customers
@@ -226,14 +208,15 @@
  - [ChargeRequestPaymentMethod](docs/ChargeRequestPaymentMethod.md)
  - [ChargeResponse](docs/ChargeResponse.md)
  - [ChargeResponseChannel](docs/ChargeResponseChannel.md)
  - [ChargeResponsePaymentMethod](docs/ChargeResponsePaymentMethod.md)
  - [ChargeResponseRefunds](docs/ChargeResponseRefunds.md)
  - [ChargeResponseRefundsAllOf](docs/ChargeResponseRefundsAllOf.md)
  - [ChargeResponseRefundsData](docs/ChargeResponseRefundsData.md)
+ - [ChargeUpdateRequest](docs/ChargeUpdateRequest.md)
  - [ChargesDataResponse](docs/ChargesDataResponse.md)
  - [Checkout](docs/Checkout.md)
  - [CheckoutOrderTemplate](docs/CheckoutOrderTemplate.md)
  - [CheckoutOrderTemplateCustomerInfo](docs/CheckoutOrderTemplateCustomerInfo.md)
  - [CheckoutRequest](docs/CheckoutRequest.md)
  - [CheckoutResponse](docs/CheckoutResponse.md)
  - [CheckoutsResponse](docs/CheckoutsResponse.md)
@@ -255,15 +238,14 @@
  - [CustomerFiscalEntitiesRequest](docs/CustomerFiscalEntitiesRequest.md)
  - [CustomerFiscalEntitiesRequestAddress](docs/CustomerFiscalEntitiesRequestAddress.md)
  - [CustomerFiscalEntitiesResponse](docs/CustomerFiscalEntitiesResponse.md)
  - [CustomerFiscalEntitiesResponseAllOf](docs/CustomerFiscalEntitiesResponseAllOf.md)
  - [CustomerInfo](docs/CustomerInfo.md)
  - [CustomerInfoJustCustomerId](docs/CustomerInfoJustCustomerId.md)
  - [CustomerInfoJustCustomerIdResponse](docs/CustomerInfoJustCustomerIdResponse.md)
- - [CustomerInfoResponse](docs/CustomerInfoResponse.md)
  - [CustomerPaymentMethodRequest](docs/CustomerPaymentMethodRequest.md)
  - [CustomerPaymentMethods](docs/CustomerPaymentMethods.md)
  - [CustomerPaymentMethodsData](docs/CustomerPaymentMethodsData.md)
  - [CustomerPaymentMethodsRequest](docs/CustomerPaymentMethodsRequest.md)
  - [CustomerPaymentMethodsResponse](docs/CustomerPaymentMethodsResponse.md)
  - [CustomerResponse](docs/CustomerResponse.md)
  - [CustomerResponseShippingContacts](docs/CustomerResponseShippingContacts.md)
@@ -288,14 +270,15 @@
  - [DiscountLinesResponse](docs/DiscountLinesResponse.md)
  - [DiscountLinesResponseAllOf](docs/DiscountLinesResponseAllOf.md)
  - [EmailCheckoutRequest](docs/EmailCheckoutRequest.md)
  - [Error](docs/Error.md)
  - [ErrorAllOf](docs/ErrorAllOf.md)
  - [EventResponse](docs/EventResponse.md)
  - [EventsResendResponse](docs/EventsResendResponse.md)
+ - [FiscalEntityAddress](docs/FiscalEntityAddress.md)
  - [GetApiKeysResponse](docs/GetApiKeysResponse.md)
  - [GetApiKeysResponseAllOf](docs/GetApiKeysResponseAllOf.md)
  - [GetChargesResponse](docs/GetChargesResponse.md)
  - [GetChargesResponseAllOf](docs/GetChargesResponseAllOf.md)
  - [GetCompaniesResponse](docs/GetCompaniesResponse.md)
  - [GetCompaniesResponseAllOf](docs/GetCompaniesResponseAllOf.md)
  - [GetCustomerPaymentMethodDataResponse](docs/GetCustomerPaymentMethodDataResponse.md)
@@ -316,34 +299,39 @@
  - [GetWebhookKeysResponseAllOf](docs/GetWebhookKeysResponseAllOf.md)
  - [GetWebhooksResponse](docs/GetWebhooksResponse.md)
  - [GetWebhooksResponseAllOf](docs/GetWebhooksResponseAllOf.md)
  - [LogResponse](docs/LogResponse.md)
  - [LogsResponse](docs/LogsResponse.md)
  - [LogsResponseData](docs/LogsResponseData.md)
  - [OrderCaptureRequest](docs/OrderCaptureRequest.md)
+ - [OrderCustomerInfoResponse](docs/OrderCustomerInfoResponse.md)
  - [OrderDiscountLinesRequest](docs/OrderDiscountLinesRequest.md)
+ - [OrderFiscalEntityAddressResponse](docs/OrderFiscalEntityAddressResponse.md)
+ - [OrderFiscalEntityAddressResponseAllOf](docs/OrderFiscalEntityAddressResponseAllOf.md)
+ - [OrderFiscalEntityRequest](docs/OrderFiscalEntityRequest.md)
+ - [OrderFiscalEntityResponse](docs/OrderFiscalEntityResponse.md)
+ - [OrderNextActionResponse](docs/OrderNextActionResponse.md)
+ - [OrderNextActionResponseRedirectToUrl](docs/OrderNextActionResponseRedirectToUrl.md)
  - [OrderRefundRequest](docs/OrderRefundRequest.md)
  - [OrderRequest](docs/OrderRequest.md)
  - [OrderRequestCustomerInfo](docs/OrderRequestCustomerInfo.md)
  - [OrderResponse](docs/OrderResponse.md)
  - [OrderResponseCharges](docs/OrderResponseCharges.md)
  - [OrderResponseChargesAllOf](docs/OrderResponseChargesAllOf.md)
  - [OrderResponseCheckout](docs/OrderResponseCheckout.md)
  - [OrderResponseCustomerInfo](docs/OrderResponseCustomerInfo.md)
  - [OrderResponseCustomerInfoAllOf](docs/OrderResponseCustomerInfoAllOf.md)
  - [OrderResponseDiscountLines](docs/OrderResponseDiscountLines.md)
  - [OrderResponseDiscountLinesAllOf](docs/OrderResponseDiscountLinesAllOf.md)
- - [OrderResponseFiscalEntity](docs/OrderResponseFiscalEntity.md)
- - [OrderResponseFiscalEntityAddress](docs/OrderResponseFiscalEntityAddress.md)
- - [OrderResponseFiscalEntityAddressAllOf](docs/OrderResponseFiscalEntityAddressAllOf.md)
  - [OrderResponseProducts](docs/OrderResponseProducts.md)
  - [OrderResponseProductsAllOf](docs/OrderResponseProductsAllOf.md)
  - [OrderResponseShippingContact](docs/OrderResponseShippingContact.md)
  - [OrderResponseShippingContactAllOf](docs/OrderResponseShippingContactAllOf.md)
  - [OrderTaxRequest](docs/OrderTaxRequest.md)
+ - [OrderUpdateFiscalEntityRequest](docs/OrderUpdateFiscalEntityRequest.md)
  - [OrderUpdateRequest](docs/OrderUpdateRequest.md)
  - [OrderUpdateRequestCustomerInfo](docs/OrderUpdateRequestCustomerInfo.md)
  - [OrdersResponse](docs/OrdersResponse.md)
  - [Page](docs/Page.md)
  - [Pagination](docs/Pagination.md)
  - [PaymentMethod](docs/PaymentMethod.md)
  - [PaymentMethodBankTransfer](docs/PaymentMethodBankTransfer.md)
```

### Comparing `conekta-6.0.1/conekta/__init__.py` & `conekta-6.0.2/conekta/__init__.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,25 +1,25 @@
 # coding: utf-8
 
 # flake8: noqa
 
 """
     Conekta API
 
-    Conekta sdk  # noqa: E501
+    Conekta sdk
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
-"""
+"""  # noqa: E501
 
 
-__version__ = "6.0.1"
+__version__ = "6.0.2"
 
 # import apis into sdk package
 from conekta.api.antifraud_api import AntifraudApi
 from conekta.api.api_keys_api import ApiKeysApi
 from conekta.api.balances_api import BalancesApi
 from conekta.api.charges_api import ChargesApi
 from conekta.api.companies_api import CompaniesApi
@@ -72,14 +72,15 @@
 from conekta.models.charge_request_payment_method import ChargeRequestPaymentMethod
 from conekta.models.charge_response import ChargeResponse
 from conekta.models.charge_response_channel import ChargeResponseChannel
 from conekta.models.charge_response_payment_method import ChargeResponsePaymentMethod
 from conekta.models.charge_response_refunds import ChargeResponseRefunds
 from conekta.models.charge_response_refunds_all_of import ChargeResponseRefundsAllOf
 from conekta.models.charge_response_refunds_data import ChargeResponseRefundsData
+from conekta.models.charge_update_request import ChargeUpdateRequest
 from conekta.models.charges_data_response import ChargesDataResponse
 from conekta.models.checkout import Checkout
 from conekta.models.checkout_order_template import CheckoutOrderTemplate
 from conekta.models.checkout_order_template_customer_info import CheckoutOrderTemplateCustomerInfo
 from conekta.models.checkout_request import CheckoutRequest
 from conekta.models.checkout_response import CheckoutResponse
 from conekta.models.checkouts_response import CheckoutsResponse
@@ -101,15 +102,14 @@
 from conekta.models.customer_fiscal_entities_request import CustomerFiscalEntitiesRequest
 from conekta.models.customer_fiscal_entities_request_address import CustomerFiscalEntitiesRequestAddress
 from conekta.models.customer_fiscal_entities_response import CustomerFiscalEntitiesResponse
 from conekta.models.customer_fiscal_entities_response_all_of import CustomerFiscalEntitiesResponseAllOf
 from conekta.models.customer_info import CustomerInfo
 from conekta.models.customer_info_just_customer_id import CustomerInfoJustCustomerId
 from conekta.models.customer_info_just_customer_id_response import CustomerInfoJustCustomerIdResponse
-from conekta.models.customer_info_response import CustomerInfoResponse
 from conekta.models.customer_payment_method_request import CustomerPaymentMethodRequest
 from conekta.models.customer_payment_methods import CustomerPaymentMethods
 from conekta.models.customer_payment_methods_data import CustomerPaymentMethodsData
 from conekta.models.customer_payment_methods_request import CustomerPaymentMethodsRequest
 from conekta.models.customer_payment_methods_response import CustomerPaymentMethodsResponse
 from conekta.models.customer_response import CustomerResponse
 from conekta.models.customer_response_shipping_contacts import CustomerResponseShippingContacts
@@ -134,14 +134,15 @@
 from conekta.models.discount_lines_response import DiscountLinesResponse
 from conekta.models.discount_lines_response_all_of import DiscountLinesResponseAllOf
 from conekta.models.email_checkout_request import EmailCheckoutRequest
 from conekta.models.error import Error
 from conekta.models.error_all_of import ErrorAllOf
 from conekta.models.event_response import EventResponse
 from conekta.models.events_resend_response import EventsResendResponse
+from conekta.models.fiscal_entity_address import FiscalEntityAddress
 from conekta.models.get_api_keys_response import GetApiKeysResponse
 from conekta.models.get_api_keys_response_all_of import GetApiKeysResponseAllOf
 from conekta.models.get_charges_response import GetChargesResponse
 from conekta.models.get_charges_response_all_of import GetChargesResponseAllOf
 from conekta.models.get_companies_response import GetCompaniesResponse
 from conekta.models.get_companies_response_all_of import GetCompaniesResponseAllOf
 from conekta.models.get_customer_payment_method_data_response import GetCustomerPaymentMethodDataResponse
@@ -162,34 +163,39 @@
 from conekta.models.get_webhook_keys_response_all_of import GetWebhookKeysResponseAllOf
 from conekta.models.get_webhooks_response import GetWebhooksResponse
 from conekta.models.get_webhooks_response_all_of import GetWebhooksResponseAllOf
 from conekta.models.log_response import LogResponse
 from conekta.models.logs_response import LogsResponse
 from conekta.models.logs_response_data import LogsResponseData
 from conekta.models.order_capture_request import OrderCaptureRequest
+from conekta.models.order_customer_info_response import OrderCustomerInfoResponse
 from conekta.models.order_discount_lines_request import OrderDiscountLinesRequest
+from conekta.models.order_fiscal_entity_address_response import OrderFiscalEntityAddressResponse
+from conekta.models.order_fiscal_entity_address_response_all_of import OrderFiscalEntityAddressResponseAllOf
+from conekta.models.order_fiscal_entity_request import OrderFiscalEntityRequest
+from conekta.models.order_fiscal_entity_response import OrderFiscalEntityResponse
+from conekta.models.order_next_action_response import OrderNextActionResponse
+from conekta.models.order_next_action_response_redirect_to_url import OrderNextActionResponseRedirectToUrl
 from conekta.models.order_refund_request import OrderRefundRequest
 from conekta.models.order_request import OrderRequest
 from conekta.models.order_request_customer_info import OrderRequestCustomerInfo
 from conekta.models.order_response import OrderResponse
 from conekta.models.order_response_charges import OrderResponseCharges
 from conekta.models.order_response_charges_all_of import OrderResponseChargesAllOf
 from conekta.models.order_response_checkout import OrderResponseCheckout
 from conekta.models.order_response_customer_info import OrderResponseCustomerInfo
 from conekta.models.order_response_customer_info_all_of import OrderResponseCustomerInfoAllOf
 from conekta.models.order_response_discount_lines import OrderResponseDiscountLines
 from conekta.models.order_response_discount_lines_all_of import OrderResponseDiscountLinesAllOf
-from conekta.models.order_response_fiscal_entity import OrderResponseFiscalEntity
-from conekta.models.order_response_fiscal_entity_address import OrderResponseFiscalEntityAddress
-from conekta.models.order_response_fiscal_entity_address_all_of import OrderResponseFiscalEntityAddressAllOf
 from conekta.models.order_response_products import OrderResponseProducts
 from conekta.models.order_response_products_all_of import OrderResponseProductsAllOf
 from conekta.models.order_response_shipping_contact import OrderResponseShippingContact
 from conekta.models.order_response_shipping_contact_all_of import OrderResponseShippingContactAllOf
 from conekta.models.order_tax_request import OrderTaxRequest
+from conekta.models.order_update_fiscal_entity_request import OrderUpdateFiscalEntityRequest
 from conekta.models.order_update_request import OrderUpdateRequest
 from conekta.models.order_update_request_customer_info import OrderUpdateRequestCustomerInfo
 from conekta.models.orders_response import OrdersResponse
 from conekta.models.page import Page
 from conekta.models.pagination import Pagination
 from conekta.models.payment_method import PaymentMethod
 from conekta.models.payment_method_bank_transfer import PaymentMethodBankTransfer
```

### Comparing `conekta-6.0.1/conekta/api/__init__.py` & `conekta-6.0.2/conekta/api/__init__.py`

 * *Files identical despite different names*

### Comparing `conekta-6.0.1/conekta/api_client.py` & `conekta-6.0.2/conekta/api_client.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,58 +1,64 @@
 # coding: utf-8
 
 """
     Conekta API
 
-    Conekta sdk  # noqa: E501
+    Conekta sdk
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
-"""
+"""  # noqa: E501
 
 
 import atexit
 import datetime
 from dateutil.parser import parse
 import json
 import mimetypes
-from multiprocessing.pool import ThreadPool
 import os
 import re
 import tempfile
 import platform
 
 from urllib.parse import quote
+from typing import Tuple, Optional, List
 
 from conekta.configuration import Configuration
 from conekta.api_response import ApiResponse
 import conekta.models
 from conekta import rest
-from conekta.exceptions import ApiValueError, ApiException
+from conekta.exceptions import (
+    ApiValueError,
+    ApiException,
+    BadRequestException,
+    UnauthorizedException,
+    ForbiddenException,
+    NotFoundException,
+    ServiceException
+)
 
 
-class ApiClient(object):
+class ApiClient:
     """Generic API client for OpenAPI client library builds.
 
     OpenAPI generic API client. This client handles the client-
     server communication, and is invariant across implementations. Specifics of
     the methods and models for each application are generated from the OpenAPI
     templates.
 
     :param configuration: .Configuration object for this client
     :param header_name: a header to pass when making calls to the API.
     :param header_value: a header value to pass when making calls to
         the API.
     :param cookie: a cookie to include in the header when making calls
         to the API
-    :param pool_threads: The number of threads to use for async requests
-        to the API. More threads means more concurrent API requests.
     """
 
     PRIMITIVE_TYPES = (float, bool, bytes, str, int)
     NATIVE_TYPES_MAPPING = {
         'int': int,
         'long': int, # TODO remove as only py3 is supported?
         'float': float,
@@ -62,70 +68,56 @@
         'datetime': datetime.datetime,
         'object': object,
     }
     data = {
       'lang': 'python',
       'lang_version': platform.python_version(),
       'publisher': 'conekta',
-      'bindings_version': '6.0.1',
+      'bindings_version': '6.0.2',
       'uname': platform.uname()
     }
     _pool = None
 
-    def __init__(self, configuration=None, header_name=None, header_value=None,
-                 cookie=None, pool_threads=1):
+    def __init__(
+        self,
+        configuration=None,
+        header_name=None,
+        header_value=None,
+        cookie=None
+    ) -> None:
         # use default configuration if none is provided
         if configuration is None:
             configuration = Configuration.get_default()
         self.configuration = configuration
-        self.pool_threads = pool_threads
 
         self.rest_client = rest.RESTClientObject(configuration)
         self.default_headers = {}
         if header_name is not None:
             self.default_headers[header_name] = header_value
         self.cookie = cookie
         # Set default User-Agent.
-        self.user_agent = 'Conekta/v2 PythonBindings/6.0.1'
+        self.user_agent = 'Conekta/v2 PythonBindings/6.0.2'
         self.conekta_user_agent = json.dumps(self.data)
         self.client_side_validation = configuration.client_side_validation
 
     def __enter__(self):
         return self
 
     def __exit__(self, exc_type, exc_value, traceback):
-        self.close()
-
-    def close(self):
-        if self._pool:
-            self._pool.close()
-            self._pool.join()
-            self._pool = None
-            if hasattr(atexit, 'unregister'):
-                atexit.unregister(self.close)
-
-    @property
-    def pool(self):
-        """Create thread pool on first request
-         avoids instantiating unused threadpool for blocking clients.
-        """
-        if self._pool is None:
-            atexit.register(self.close)
-            self._pool = ThreadPool(self.pool_threads)
-        return self._pool
+        pass
 
     @property
     def user_agent(self):
         """User agent for this API client"""
         return self.default_headers['User-Agent']
 
     @user_agent.setter
     def user_agent(self, value):
         self.default_headers['User-Agent'] = value
-    
+
     @property
     def conekta_user_agent(self):
         """User conekta agent for this API client"""
         return self.default_headers['X-Conekta-Client-User-Agent']
 
     @conekta_user_agent.setter
     def conekta_user_agent(self, value):
@@ -157,59 +149,98 @@
 
         It stores default ApiClient.
 
         :param default: object of ApiClient.
         """
         cls._default = default
 
-    def __call_api(
-            self, resource_path, method, path_params=None,
-            query_params=None, header_params=None, body=None, post_params=None,
-            files=None, response_types_map=None, auth_settings=None,
-            _return_http_data_only=None, collection_formats=None,
-            _preload_content=True, _request_timeout=None, _host=None,
-            _request_auth=None):
+    def param_serialize(
+        self,
+        method,
+        resource_path,
+        path_params=None,
+        query_params=None,
+        header_params=None,
+        body=None,
+        post_params=None,
+        files=None, auth_settings=None,
+        collection_formats=None,
+        _host=None,
+        _request_auth=None
+    ) -> Tuple:
+
+        """Builds the HTTP request params needed by the request.
+        :param method: Method to call.
+        :param resource_path: Path to method endpoint.
+        :param path_params: Path parameters in the url.
+        :param query_params: Query parameters in the url.
+        :param header_params: Header parameters to be
+            placed in the request header.
+        :param body: Request body.
+        :param post_params dict: Request post form parameters,
+            for `application/x-www-form-urlencoded`, `multipart/form-data`.
+        :param auth_settings list: Auth Settings names for the request.
+        :param files dict: key -> filename, value -> filepath,
+            for `multipart/form-data`.
+        :param collection_formats: dict of collection formats for path, query,
+            header, and post parameters.
+        :param _request_auth: set to override the auth_settings for an a single
+                              request; this effectively ignores the authentication
+                              in the spec for a single request.
+        :return: tuple of form (path, http_method, query_params, header_params,
+            body, post_params, files)
+        """
 
         config = self.configuration
 
         # header parameters
         header_params = header_params or {}
         header_params.update(self.default_headers)
         if self.cookie:
             header_params['Cookie'] = self.cookie
         if header_params:
             header_params = self.sanitize_for_serialization(header_params)
-            header_params = dict(self.parameters_to_tuples(header_params,
-                                                           collection_formats))
+            header_params = dict(
+                self.parameters_to_tuples(header_params,collection_formats)
+            )
 
         # path parameters
         if path_params:
             path_params = self.sanitize_for_serialization(path_params)
-            path_params = self.parameters_to_tuples(path_params,
-                                                    collection_formats)
+            path_params = self.parameters_to_tuples(
+                path_params,
+                collection_formats
+            )
             for k, v in path_params:
                 # specified safe chars, encode everything
                 resource_path = resource_path.replace(
                     '{%s}' % k,
                     quote(str(v), safe=config.safe_chars_for_path_param)
                 )
 
         # post parameters
         if post_params or files:
             post_params = post_params if post_params else []
             post_params = self.sanitize_for_serialization(post_params)
-            post_params = self.parameters_to_tuples(post_params,
-                                                    collection_formats)
+            post_params = self.parameters_to_tuples(
+                post_params,
+                collection_formats
+            )
             post_params.extend(self.files_parameters(files))
 
         # auth setting
         self.update_params_for_auth(
-            header_params, query_params, auth_settings,
-            resource_path, method, body,
-            request_auth=_request_auth)
+            header_params,
+            query_params,
+            auth_settings,
+            resource_path,
+            method,
+            body,
+            request_auth=_request_auth
+        )
 
         # body
         if body:
             body = self.sanitize_for_serialization(body)
 
         # request url
         if _host is None:
@@ -217,64 +248,117 @@
         else:
             # use server/host defined in path or operation instead
             url = _host + resource_path
 
         # query parameters
         if query_params:
             query_params = self.sanitize_for_serialization(query_params)
-            url_query = self.parameters_to_url_query(query_params,
-                                                     collection_formats)
+            url_query = self.parameters_to_url_query(
+                query_params,
+                collection_formats
+            )
             url += "?" + url_query
 
+        return method, url, header_params, body, post_params
+
+
+    def call_api(
+        self,
+        method,
+        url,
+        header_params=None,
+        body=None,
+        post_params=None,
+        _request_timeout=None
+    ) -> rest.RESTResponse:
+        """Makes the HTTP request (synchronous)
+        :param method: Method to call.
+        :param url: Path to method endpoint.
+        :param header_params: Header parameters to be
+            placed in the request header.
+        :param body: Request body.
+        :param post_params dict: Request post form parameters,
+            for `application/x-www-form-urlencoded`, `multipart/form-data`.
+        :param _request_timeout: timeout setting for this request.
+        :return: RESTResponse
+        """
+
         try:
             # perform request and return response
-            response_data = self.request(
+            response_data = self.rest_client.request(
                 method, url,
-                query_params=query_params,
                 headers=header_params,
-                post_params=post_params, body=body,
-                _preload_content=_preload_content,
-                _request_timeout=_request_timeout)
+                body=body, post_params=post_params,
+                _request_timeout=_request_timeout
+            )
+
         except ApiException as e:
             if e.body:
                 e.body = e.body.decode('utf-8')
             raise e
 
-        self.last_response = response_data
+        return response_data
+
+    def response_deserialize(
+        self,
+        response_data=None,
+        response_types_map=None
+    ) -> ApiResponse:
+        """Deserializes response into an object.
+        :param response_data: RESTResponse object to be deserialized.
+        :param response_types_map: dict of response types.
+        :return: ApiResponse
+        """
 
-        return_data = None # assuming derialization is not needed
-        # data needs deserialization or returns HTTP data (deserialized) only
-        if _preload_content or _return_http_data_only:
-          response_type = response_types_map.get(str(response_data.status), None)
-
-          if response_type == "bytearray":
-              response_data.data = response_data.data
-          else:
-              match = None
-              content_type = response_data.getheader('content-type')
-              if content_type is not None:
-                  match = re.search(r"charset=([a-zA-Z\-\d]+)[\s;]?", content_type)
-              encoding = match.group(1) if match else "utf-8"
-              response_data.data = response_data.data.decode(encoding)
-
-          # deserialize response data
-          if response_type == "bytearray":
-              return_data = response_data.data
-          elif response_type:
-              return_data = self.deserialize(response_data, response_type)
-          else:
-              return_data = None
 
-        if _return_http_data_only:
-            return return_data
+        response_type = response_types_map.get(str(response_data.status), None)
+        if not response_type and isinstance(response_data.status, int) and 100 <= response_data.status <= 599:
+            # if not found, look for '1XX', '2XX', etc.
+            response_type = response_types_map.get(str(response_data.status)[0] + "XX", None)
+
+        if not 200 <= response_data.status <= 299:
+            if response_data.status == 400:
+                raise BadRequestException(http_resp=response_data)
+
+            if response_data.status == 401:
+                raise UnauthorizedException(http_resp=response_data)
+
+            if response_data.status == 403:
+                raise ForbiddenException(http_resp=response_data)
+
+            if response_data.status == 404:
+                raise NotFoundException(http_resp=response_data)
+
+            if 500 <= response_data.status <= 599:
+                raise ServiceException(http_resp=response_data)
+            raise ApiException(http_resp=response_data)
+
+        # deserialize response data
+
+        if response_type == "bytearray":
+            return_data = response_data.data
+        elif response_type is None:
+            return_data = None
+        elif response_type == "file":
+            return_data = self.__deserialize_file(response_data)
         else:
-            return ApiResponse(status_code = response_data.status,
-                           data = return_data,
-                           headers = response_data.getheaders(),
-                           raw_data = response_data.data)
+            match = None
+            content_type = response_data.getheader('content-type')
+            if content_type is not None:
+                match = re.search(r"charset=([a-zA-Z\-\d]+)[\s;]?", content_type)
+            encoding = match.group(1) if match else "utf-8"
+            response_text = response_data.data.decode(encoding)
+            return_data = self.deserialize(response_text, response_type)
+
+        return ApiResponse(
+            status_code = response_data.status,
+            data = return_data,
+            headers = response_data.getheaders(),
+            raw_data = response_data.data
+        )
 
     def sanitize_for_serialization(self, obj):
         """Builds a JSON POST object.
 
         If obj is None, return None.
         If obj is str, int, long, float, bool, return directly.
         If obj is datetime.datetime, datetime.date
@@ -287,69 +371,69 @@
         :return: The serialized form of data.
         """
         if obj is None:
             return None
         elif isinstance(obj, self.PRIMITIVE_TYPES):
             return obj
         elif isinstance(obj, list):
-            return [self.sanitize_for_serialization(sub_obj)
-                    for sub_obj in obj]
+            return [
+                self.sanitize_for_serialization(sub_obj) for sub_obj in obj
+            ]
         elif isinstance(obj, tuple):
-            return tuple(self.sanitize_for_serialization(sub_obj)
-                         for sub_obj in obj)
+            return tuple(
+                self.sanitize_for_serialization(sub_obj) for sub_obj in obj
+            )
         elif isinstance(obj, (datetime.datetime, datetime.date)):
             return obj.isoformat()
 
-        if isinstance(obj, dict):
+        elif isinstance(obj, dict):
             obj_dict = obj
         else:
             # Convert model obj to dict except
             # attributes `openapi_types`, `attribute_map`
             # and attributes which value is not None.
             # Convert attribute name to json key in
             # model definition for request.
             obj_dict = obj.to_dict()
 
-        return {key: self.sanitize_for_serialization(val)
-                for key, val in obj_dict.items()}
+        return {
+            key: self.sanitize_for_serialization(val)
+            for key, val in obj_dict.items()
+        }
 
-    def deserialize(self, response, response_type):
+    def deserialize(self, response_text, response_type):
         """Deserializes response into an object.
 
         :param response: RESTResponse object to be deserialized.
         :param response_type: class literal for
             deserialized object, or string of class name.
 
         :return: deserialized object.
         """
-        # handle file downloading
-        # save response body into a tmp file and return the instance
-        if response_type == "file":
-            return self.__deserialize_file(response)
 
         # fetch data from response object
         try:
-            data = json.loads(response.data)
+            data = json.loads(response_text)
         except ValueError:
-            data = response.data
+            data = response_text
 
         return self.__deserialize(data, response_type)
 
     def __deserialize(self, data, klass):
         """Deserializes dict, list, str into an object.
 
         :param data: dict, list or str.
         :param klass: class literal, or string of class name.
 
         :return: object.
         """
         if data is None:
             return None
 
-        if type(klass) == str:
+        if isinstance(klass, str):
             if klass.startswith('List['):
                 sub_kls = re.match(r'List\[(.*)]', klass).group(1)
                 return [self.__deserialize(sub_data, sub_kls)
                         for sub_data in data]
 
             if klass.startswith('Dict['):
                 sub_kls = re.match(r'Dict\[([^,]*), (.*)]', klass).group(2)
@@ -369,154 +453,25 @@
         elif klass == datetime.date:
             return self.__deserialize_date(data)
         elif klass == datetime.datetime:
             return self.__deserialize_datetime(data)
         else:
             return self.__deserialize_model(data, klass)
 
-    def call_api(self, resource_path, method,
-                 path_params=None, query_params=None, header_params=None,
-                 body=None, post_params=None, files=None,
-                 response_types_map=None, auth_settings=None,
-                 async_req=None, _return_http_data_only=None,
-                 collection_formats=None, _preload_content=True,
-                 _request_timeout=None, _host=None, _request_auth=None):
-        """Makes the HTTP request (synchronous) and returns deserialized data.
-
-        To make an async_req request, set the async_req parameter.
-
-        :param resource_path: Path to method endpoint.
-        :param method: Method to call.
-        :param path_params: Path parameters in the url.
-        :param query_params: Query parameters in the url.
-        :param header_params: Header parameters to be
-            placed in the request header.
-        :param body: Request body.
-        :param post_params dict: Request post form parameters,
-            for `application/x-www-form-urlencoded`, `multipart/form-data`.
-        :param auth_settings list: Auth Settings names for the request.
-        :param response: Response data type.
-        :param files dict: key -> filename, value -> filepath,
-            for `multipart/form-data`.
-        :param async_req bool: execute request asynchronously
-        :param _return_http_data_only: response data instead of ApiResponse
-                                       object with status code, headers, etc
-        :param _preload_content: if False, the ApiResponse.data will
-                                 be set to none and raw_data will store the
-                                 HTTP response body without reading/decoding.
-                                 Default is True.
-        :param collection_formats: dict of collection formats for path, query,
-            header, and post parameters.
-        :param _request_timeout: timeout setting for this request. If one
-                                 number provided, it will be total request
-                                 timeout. It can also be a pair (tuple) of
-                                 (connection, read) timeouts.
-        :param _request_auth: set to override the auth_settings for an a single
-                              request; this effectively ignores the authentication
-                              in the spec for a single request.
-        :type _request_token: dict, optional
-        :return:
-            If async_req parameter is True,
-            the request will be called asynchronously.
-            The method will return the request thread.
-            If parameter async_req is False or missing,
-            then the method will return the response directly.
-        """
-        if not async_req:
-            return self.__call_api(resource_path, method,
-                                   path_params, query_params, header_params,
-                                   body, post_params, files,
-                                   response_types_map, auth_settings,
-                                   _return_http_data_only, collection_formats,
-                                   _preload_content, _request_timeout, _host,
-                                   _request_auth)
-
-        return self.pool.apply_async(self.__call_api, (resource_path,
-                                                       method, path_params,
-                                                       query_params,
-                                                       header_params, body,
-                                                       post_params, files,
-                                                       response_types_map,
-                                                       auth_settings,
-                                                       _return_http_data_only,
-                                                       collection_formats,
-                                                       _preload_content,
-                                                       _request_timeout,
-                                                       _host, _request_auth))
-
-    def request(self, method, url, query_params=None, headers=None,
-                post_params=None, body=None, _preload_content=True,
-                _request_timeout=None):
-        """Makes the HTTP request using RESTClient."""
-        if method == "GET":
-            return self.rest_client.get_request(url,
-                                        query_params=query_params,
-                                        _preload_content=_preload_content,
-                                        _request_timeout=_request_timeout,
-                                        headers=headers)
-        elif method == "HEAD":
-            return self.rest_client.head_request(url,
-                                         query_params=query_params,
-                                         _preload_content=_preload_content,
-                                         _request_timeout=_request_timeout,
-                                         headers=headers)
-        elif method == "OPTIONS":
-            return self.rest_client.options_request(url,
-                                            query_params=query_params,
-                                            headers=headers,
-                                            _preload_content=_preload_content,
-                                            _request_timeout=_request_timeout)
-        elif method == "POST":
-            return self.rest_client.post_request(url,
-                                         query_params=query_params,
-                                         headers=headers,
-                                         post_params=post_params,
-                                         _preload_content=_preload_content,
-                                         _request_timeout=_request_timeout,
-                                         body=body)
-        elif method == "PUT":
-            return self.rest_client.put_request(url,
-                                        query_params=query_params,
-                                        headers=headers,
-                                        post_params=post_params,
-                                        _preload_content=_preload_content,
-                                        _request_timeout=_request_timeout,
-                                        body=body)
-        elif method == "PATCH":
-            return self.rest_client.patch_request(url,
-                                          query_params=query_params,
-                                          headers=headers,
-                                          post_params=post_params,
-                                          _preload_content=_preload_content,
-                                          _request_timeout=_request_timeout,
-                                          body=body)
-        elif method == "DELETE":
-            return self.rest_client.delete_request(url,
-                                           query_params=query_params,
-                                           headers=headers,
-                                           _preload_content=_preload_content,
-                                           _request_timeout=_request_timeout,
-                                           body=body)
-        else:
-            raise ApiValueError(
-                "http method must be `GET`, `HEAD`, `OPTIONS`,"
-                " `POST`, `PATCH`, `PUT` or `DELETE`."
-            )
-
     def parameters_to_tuples(self, params, collection_formats):
         """Get parameters as list of tuples, formatting collections.
 
         :param params: Parameters as dict or list of two-tuples
         :param dict collection_formats: Parameter collection formats
         :return: Parameters as list of tuples, collections formatted
         """
         new_params = []
         if collection_formats is None:
             collection_formats = {}
-        for k, v in params.items() if isinstance(params, dict) else params:  # noqa: E501
+        for k, v in params.items() if isinstance(params, dict) else params:
             if k in collection_formats:
                 collection_format = collection_formats[k]
                 if collection_format == 'multi':
                     new_params.extend((k, value) for value in v)
                 else:
                     if collection_format == 'ssv':
                         delimiter = ' '
@@ -538,19 +493,19 @@
         :param params: Parameters as dict or list of two-tuples
         :param dict collection_formats: Parameter collection formats
         :return: URL query string (e.g. a=Hello%20World&b=123)
         """
         new_params = []
         if collection_formats is None:
             collection_formats = {}
-        for k, v in params.items() if isinstance(params, dict) else params:  # noqa: E501
-            if isinstance(v, (int, float)):
-                v = str(v)
+        for k, v in params.items() if isinstance(params, dict) else params:
             if isinstance(v, bool):
                 v = str(v).lower()
+            if isinstance(v, (int, float)):
+                v = str(v)
             if isinstance(v, dict):
                 v = json.dumps(v)
 
             if k in collection_formats:
                 collection_format = collection_formats[k]
                 if collection_format == 'multi':
                     new_params.extend((k, value) for value in v)
@@ -560,15 +515,16 @@
                     elif collection_format == 'tsv':
                         delimiter = '\t'
                     elif collection_format == 'pipes':
                         delimiter = '|'
                     else:  # csv is the default
                         delimiter = ','
                     new_params.append(
-                        (k, delimiter.join(quote(str(value)) for value in v)))
+                        (k, delimiter.join(quote(str(value)) for value in v))
+                    )
             else:
                 new_params.append((k, quote(str(v))))
 
         return "&".join(["=".join(item) for item in new_params])
 
     def files_parameters(self, files=None):
         """Builds form parameters.
@@ -583,29 +539,32 @@
                 if not v:
                     continue
                 file_names = v if type(v) is list else [v]
                 for n in file_names:
                     with open(n, 'rb') as f:
                         filename = os.path.basename(f.name)
                         filedata = f.read()
-                        mimetype = (mimetypes.guess_type(filename)[0] or
-                                    'application/octet-stream')
+                        mimetype = (
+                            mimetypes.guess_type(filename)[0]
+                            or 'application/octet-stream'
+                        )
                         params.append(
-                            tuple([k, tuple([filename, filedata, mimetype])]))
+                            tuple([k, tuple([filename, filedata, mimetype])])
+                        )
 
         return params
 
-    def select_header_accept(self, accepts):
+    def select_header_accept(self, accepts: List[str]) -> Optional[str]:
         """Returns `Accept` based on an array of accepts provided.
 
         :param accepts: List of headers.
         :return: Accept (e.g. application/json).
         """
         if not accepts:
-            return
+            return None
 
         for accept in accepts:
             if re.search('json', accept, re.IGNORECASE):
                 return accept
 
         return accepts[0]
 
@@ -620,17 +579,24 @@
 
         for content_type in content_types:
             if re.search('json', content_type, re.IGNORECASE):
                 return content_type
 
         return content_types[0]
 
-    def update_params_for_auth(self, headers, queries, auth_settings,
-                               resource_path, method, body,
-                               request_auth=None):
+    def update_params_for_auth(
+        self,
+        headers,
+        queries,
+        auth_settings,
+        resource_path,
+        method,
+        body,
+        request_auth=None
+    ) -> None:
         """Updates header and query params based on authentication setting.
 
         :param headers: Header parameters dict to be updated.
         :param queries: Query parameters tuple list to be updated.
         :param auth_settings: Authentication setting identifiers list.
         :resource_path: A string representation of the HTTP request resource path.
         :method: A string representation of the HTTP request method.
@@ -639,29 +605,44 @@
         :param request_auth: if set, the provided settings will
                              override the token in the configuration.
         """
         if not auth_settings:
             return
 
         if request_auth:
-            self._apply_auth_params(headers, queries,
-                                    resource_path, method, body,
-                                    request_auth)
-            return
-
-        for auth in auth_settings:
-            auth_setting = self.configuration.auth_settings().get(auth)
-            if auth_setting:
-                self._apply_auth_params(headers, queries,
-                                        resource_path, method, body,
-                                        auth_setting)
-
-    def _apply_auth_params(self, headers, queries,
-                           resource_path, method, body,
-                           auth_setting):
+            self._apply_auth_params(
+                headers,
+                queries,
+                resource_path,
+                method,
+                body,
+                request_auth
+            )
+        else:
+            for auth in auth_settings:
+                auth_setting = self.configuration.auth_settings().get(auth)
+                if auth_setting:
+                    self._apply_auth_params(
+                        headers,
+                        queries,
+                        resource_path,
+                        method,
+                        body,
+                        auth_setting
+                    )
+
+    def _apply_auth_params(
+        self,
+        headers,
+        queries,
+        resource_path,
+        method,
+        body,
+        auth_setting
+    ) -> None:
         """Updates the request parameters based on a single auth_setting
 
         :param headers: Header parameters dict to be updated.
         :param queries: Query parameters tuple list to be updated.
         :resource_path: A string representation of the HTTP request resource path.
         :method: A string representation of the HTTP request method.
         :body: A object representing the body of the HTTP request.
@@ -682,25 +663,30 @@
 
     def __deserialize_file(self, response):
         """Deserializes body to file
 
         Saves response body into a file in a temporary folder,
         using the filename from the `Content-Disposition` header if provided.
 
+        handle file downloading
+        save response body into a tmp file and return the instance
+
         :param response:  RESTResponse.
         :return: file path.
         """
         fd, path = tempfile.mkstemp(dir=self.configuration.temp_folder_path)
         os.close(fd)
         os.remove(path)
 
         content_disposition = response.getheader("Content-Disposition")
         if content_disposition:
-            filename = re.search(r'filename=[\'"]?([^\'"\s]+)[\'"]?',
-                                 content_disposition).group(1)
+            filename = re.search(
+                r'filename=[\'"]?([^\'"\s]+)[\'"]?',
+                content_disposition
+            ).group(1)
             path = os.path.join(os.path.dirname(path), filename)
 
         with open(path, "wb") as f:
             f.write(response.data)
 
         return path
```

### Comparing `conekta-6.0.1/conekta/configuration.py` & `conekta-6.0.2/conekta/configuration.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,45 +1,37 @@
 # coding: utf-8
 
 """
     Conekta API
 
-    Conekta sdk  # noqa: E501
+    Conekta sdk
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
-"""
-
+"""  # noqa: E501
 
-from __future__ import absolute_import
 
 import copy
 import logging
-import multiprocessing
 import sys
 import urllib3
 
 import http.client as httplib
-from conekta.exceptions import ApiValueError
-
 
 JSON_SCHEMA_VALIDATION_KEYWORDS = {
     'multipleOf', 'maximum', 'exclusiveMaximum',
     'minimum', 'exclusiveMinimum', 'maxLength',
     'minLength', 'pattern', 'maxItems', 'minItems'
 }
 
-class Configuration(object):
-    """NOTE: This class is auto generated by OpenAPI Generator
-
-    Ref: https://openapi-generator.tech
-    Do not edit the class manually.
+class Configuration:
+    """This class contains various settings of the API client.
 
     :param host: Base url.
     :param api_key: Dict to store API key(s).
       Each entry in the dict specifies an API key.
       The dict key is the name of the security scheme in the OAS specification.
       The dict value is the API key secret.
     :param api_key_prefix: Dict to store API prefix (e.g. Bearer).
@@ -52,15 +44,16 @@
     :param server_variables: Mapping with string values to replace variables in
       templated server configuration. The validation of enums is performed for
       variables with defined enum values before.
     :param server_operation_index: Mapping from operation ID to an index to server
       configuration.
     :param server_operation_variables: Mapping from operation ID to a mapping with
       string values to replace variables in templated server configuration.
-      The validation of enums is performed for variables with defined enum values before.
+      The validation of enums is performed for variables with defined enum
+      values before.
     :param ssl_ca_cert: str - the path to a file of concatenated CA certificates
       in PEM format.
 
     :Example:
     """
 
     _default = None
@@ -68,15 +61,15 @@
     def __init__(self, host=None,
                  api_key=None, api_key_prefix=None,
                  username=None, password=None,
                  access_token=None,
                  server_index=None, server_variables=None,
                  server_operation_index=None, server_operation_variables=None,
                  ssl_ca_cert=None,
-                 ):
+                 ) -> None:
         """Constructor
         """
         self._base_path = "https://api.conekta.io" if host is None else host
         """Default Base url
         """
         self.server_index = 0 if server_index is None and host is None else server_index
         self.server_operation_index = server_operation_index or {}
@@ -151,21 +144,14 @@
         """Set this to True/False to enable/disable SSL hostname verification.
         """
         self.tls_server_name = None
         """SSL/TLS Server Name Indication (SNI)
            Set this to the SNI value expected by the server.
         """
 
-        self.connection_pool_maxsize = multiprocessing.cpu_count() * 5
-        """urllib3 connection pool's maximum number of connections saved
-           per pool. urllib3 uses 1 connection as default value, but this is
-           not the best value when you are making a lot of possibly parallel
-           requests to the same host, which is often the case here.
-           cpu_count * 5 is used as default value to increase performance.
-        """
 
         self.proxy = None
         """Proxy URL
         """
         self.proxy_headers = None
         """Proxy headers
         """
@@ -178,14 +164,22 @@
         # Enable client side validation
         self.client_side_validation = True
 
         self.socket_options = None
         """Options to pass down to the underlying urllib3 socket
         """
 
+        self.datetime_format = "%Y-%m-%dT%H:%M:%S.%f%z"
+        """datetime format
+        """
+
+        self.date_format = "%Y-%m-%d"
+        """date format
+        """
+
     def __deepcopy__(self, memo):
         cls = self.__class__
         result = cls.__new__(cls)
         memo[id(self)] = result
         for k, v in self.__dict__.items():
             if k not in ('logger', 'logger_file_handler'):
                 setattr(result, k, copy.deepcopy(v, memo))
@@ -371,15 +365,15 @@
 
         :return: The report for debugging.
         """
         return "Python SDK Debug Report:\n"\
                "OS: {env}\n"\
                "Python Version: {pyversion}\n"\
                "Version of the API: 2.1.0\n"\
-               "SDK Package Version: 6.0.1".\
+               "SDK Package Version: 6.0.2".\
                format(env=sys.platform, pyversion=sys.version)
 
     def get_host_settings(self):
         """Gets an array of host settings
 
         :return: An array of host settings
         """
```

### Comparing `conekta-6.0.1/conekta/exceptions.py` & `conekta-6.0.2/conekta/exceptions.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,29 +1,29 @@
 # coding: utf-8
 
 """
     Conekta API
 
-    Conekta sdk  # noqa: E501
+    Conekta sdk
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
-"""
+"""  # noqa: E501
 
 
 class OpenApiException(Exception):
     """The base exception class for all OpenAPIExceptions"""
 
 
 class ApiTypeError(OpenApiException, TypeError):
     def __init__(self, msg, path_to_item=None, valid_classes=None,
-                 key_type=None):
+                 key_type=None) -> None:
         """ Raises an exception for TypeErrors
 
         Args:
             msg (str): the exception message
 
         Keyword Args:
             path_to_item (list): a list of keys an indices to get to the
@@ -43,15 +43,15 @@
         full_msg = msg
         if path_to_item:
             full_msg = "{0} at {1}".format(msg, render_path(path_to_item))
         super(ApiTypeError, self).__init__(full_msg)
 
 
 class ApiValueError(OpenApiException, ValueError):
-    def __init__(self, msg, path_to_item=None):
+    def __init__(self, msg, path_to_item=None) -> None:
         """
         Args:
             msg (str): the exception message
 
         Keyword Args:
             path_to_item (list) the path to the exception in the
                 received_data dict. None if unset
@@ -61,15 +61,15 @@
         full_msg = msg
         if path_to_item:
             full_msg = "{0} at {1}".format(msg, render_path(path_to_item))
         super(ApiValueError, self).__init__(full_msg)
 
 
 class ApiAttributeError(OpenApiException, AttributeError):
-    def __init__(self, msg, path_to_item=None):
+    def __init__(self, msg, path_to_item=None) -> None:
         """
         Raised when an attribute reference or assignment fails.
 
         Args:
             msg (str): the exception message
 
         Keyword Args:
@@ -80,15 +80,15 @@
         full_msg = msg
         if path_to_item:
             full_msg = "{0} at {1}".format(msg, render_path(path_to_item))
         super(ApiAttributeError, self).__init__(full_msg)
 
 
 class ApiKeyError(OpenApiException, KeyError):
-    def __init__(self, msg, path_to_item=None):
+    def __init__(self, msg, path_to_item=None) -> None:
         """
         Args:
             msg (str): the exception message
 
         Keyword Args:
             path_to_item (None/list) the path to the exception in the
                 received_data dict
@@ -98,19 +98,19 @@
         if path_to_item:
             full_msg = "{0} at {1}".format(msg, render_path(path_to_item))
         super(ApiKeyError, self).__init__(full_msg)
 
 
 class ApiException(OpenApiException):
 
-    def __init__(self, status=None, reason=None, http_resp=None):
+    def __init__(self, status=None, reason=None, http_resp=None) -> None:
         if http_resp:
             self.status = http_resp.status
             self.reason = http_resp.reason
-            self.body = http_resp.data
+            self.body = http_resp.data.decode('utf-8')
             self.headers = http_resp.getheaders()
         else:
             self.status = status
             self.reason = reason
             self.body = None
             self.headers = None
 
@@ -123,36 +123,40 @@
                 self.headers)
 
         if self.body:
             error_message += "HTTP response body: {0}\n".format(self.body)
 
         return error_message
 
+class BadRequestException(ApiException):
+
+    def __init__(self, status=None, reason=None, http_resp=None) -> None:
+        super(BadRequestException, self).__init__(status, reason, http_resp)
 
 class NotFoundException(ApiException):
 
-    def __init__(self, status=None, reason=None, http_resp=None):
+    def __init__(self, status=None, reason=None, http_resp=None) -> None:
         super(NotFoundException, self).__init__(status, reason, http_resp)
 
 
 class UnauthorizedException(ApiException):
 
-    def __init__(self, status=None, reason=None, http_resp=None):
+    def __init__(self, status=None, reason=None, http_resp=None) -> None:
         super(UnauthorizedException, self).__init__(status, reason, http_resp)
 
 
 class ForbiddenException(ApiException):
 
-    def __init__(self, status=None, reason=None, http_resp=None):
+    def __init__(self, status=None, reason=None, http_resp=None) -> None:
         super(ForbiddenException, self).__init__(status, reason, http_resp)
 
 
 class ServiceException(ApiException):
 
-    def __init__(self, status=None, reason=None, http_resp=None):
+    def __init__(self, status=None, reason=None, http_resp=None) -> None:
         super(ServiceException, self).__init__(status, reason, http_resp)
 
 
 def render_path(path_to_item):
     """Returns a string representation of a path"""
     result = ""
     for pth in path_to_item:
```

### Comparing `conekta-6.0.1/conekta/models/__init__.py` & `conekta-6.0.2/conekta/models/__init__.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,21 +1,21 @@
 # coding: utf-8
 
 # flake8: noqa
 """
     Conekta API
 
-    Conekta sdk  # noqa: E501
+    Conekta sdk
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
-"""
+"""  # noqa: E501
 
 
 # import models into model package
 from conekta.models.api_key_create_response import ApiKeyCreateResponse
 from conekta.models.api_key_create_response_all_of import ApiKeyCreateResponseAllOf
 from conekta.models.api_key_request import ApiKeyRequest
 from conekta.models.api_key_response import ApiKeyResponse
@@ -33,14 +33,15 @@
 from conekta.models.charge_request_payment_method import ChargeRequestPaymentMethod
 from conekta.models.charge_response import ChargeResponse
 from conekta.models.charge_response_channel import ChargeResponseChannel
 from conekta.models.charge_response_payment_method import ChargeResponsePaymentMethod
 from conekta.models.charge_response_refunds import ChargeResponseRefunds
 from conekta.models.charge_response_refunds_all_of import ChargeResponseRefundsAllOf
 from conekta.models.charge_response_refunds_data import ChargeResponseRefundsData
+from conekta.models.charge_update_request import ChargeUpdateRequest
 from conekta.models.charges_data_response import ChargesDataResponse
 from conekta.models.checkout import Checkout
 from conekta.models.checkout_order_template import CheckoutOrderTemplate
 from conekta.models.checkout_order_template_customer_info import CheckoutOrderTemplateCustomerInfo
 from conekta.models.checkout_request import CheckoutRequest
 from conekta.models.checkout_response import CheckoutResponse
 from conekta.models.checkouts_response import CheckoutsResponse
@@ -62,15 +63,14 @@
 from conekta.models.customer_fiscal_entities_request import CustomerFiscalEntitiesRequest
 from conekta.models.customer_fiscal_entities_request_address import CustomerFiscalEntitiesRequestAddress
 from conekta.models.customer_fiscal_entities_response import CustomerFiscalEntitiesResponse
 from conekta.models.customer_fiscal_entities_response_all_of import CustomerFiscalEntitiesResponseAllOf
 from conekta.models.customer_info import CustomerInfo
 from conekta.models.customer_info_just_customer_id import CustomerInfoJustCustomerId
 from conekta.models.customer_info_just_customer_id_response import CustomerInfoJustCustomerIdResponse
-from conekta.models.customer_info_response import CustomerInfoResponse
 from conekta.models.customer_payment_method_request import CustomerPaymentMethodRequest
 from conekta.models.customer_payment_methods import CustomerPaymentMethods
 from conekta.models.customer_payment_methods_data import CustomerPaymentMethodsData
 from conekta.models.customer_payment_methods_request import CustomerPaymentMethodsRequest
 from conekta.models.customer_payment_methods_response import CustomerPaymentMethodsResponse
 from conekta.models.customer_response import CustomerResponse
 from conekta.models.customer_response_shipping_contacts import CustomerResponseShippingContacts
@@ -95,14 +95,15 @@
 from conekta.models.discount_lines_response import DiscountLinesResponse
 from conekta.models.discount_lines_response_all_of import DiscountLinesResponseAllOf
 from conekta.models.email_checkout_request import EmailCheckoutRequest
 from conekta.models.error import Error
 from conekta.models.error_all_of import ErrorAllOf
 from conekta.models.event_response import EventResponse
 from conekta.models.events_resend_response import EventsResendResponse
+from conekta.models.fiscal_entity_address import FiscalEntityAddress
 from conekta.models.get_api_keys_response import GetApiKeysResponse
 from conekta.models.get_api_keys_response_all_of import GetApiKeysResponseAllOf
 from conekta.models.get_charges_response import GetChargesResponse
 from conekta.models.get_charges_response_all_of import GetChargesResponseAllOf
 from conekta.models.get_companies_response import GetCompaniesResponse
 from conekta.models.get_companies_response_all_of import GetCompaniesResponseAllOf
 from conekta.models.get_customer_payment_method_data_response import GetCustomerPaymentMethodDataResponse
@@ -123,34 +124,39 @@
 from conekta.models.get_webhook_keys_response_all_of import GetWebhookKeysResponseAllOf
 from conekta.models.get_webhooks_response import GetWebhooksResponse
 from conekta.models.get_webhooks_response_all_of import GetWebhooksResponseAllOf
 from conekta.models.log_response import LogResponse
 from conekta.models.logs_response import LogsResponse
 from conekta.models.logs_response_data import LogsResponseData
 from conekta.models.order_capture_request import OrderCaptureRequest
+from conekta.models.order_customer_info_response import OrderCustomerInfoResponse
 from conekta.models.order_discount_lines_request import OrderDiscountLinesRequest
+from conekta.models.order_fiscal_entity_address_response import OrderFiscalEntityAddressResponse
+from conekta.models.order_fiscal_entity_address_response_all_of import OrderFiscalEntityAddressResponseAllOf
+from conekta.models.order_fiscal_entity_request import OrderFiscalEntityRequest
+from conekta.models.order_fiscal_entity_response import OrderFiscalEntityResponse
+from conekta.models.order_next_action_response import OrderNextActionResponse
+from conekta.models.order_next_action_response_redirect_to_url import OrderNextActionResponseRedirectToUrl
 from conekta.models.order_refund_request import OrderRefundRequest
 from conekta.models.order_request import OrderRequest
 from conekta.models.order_request_customer_info import OrderRequestCustomerInfo
 from conekta.models.order_response import OrderResponse
 from conekta.models.order_response_charges import OrderResponseCharges
 from conekta.models.order_response_charges_all_of import OrderResponseChargesAllOf
 from conekta.models.order_response_checkout import OrderResponseCheckout
 from conekta.models.order_response_customer_info import OrderResponseCustomerInfo
 from conekta.models.order_response_customer_info_all_of import OrderResponseCustomerInfoAllOf
 from conekta.models.order_response_discount_lines import OrderResponseDiscountLines
 from conekta.models.order_response_discount_lines_all_of import OrderResponseDiscountLinesAllOf
-from conekta.models.order_response_fiscal_entity import OrderResponseFiscalEntity
-from conekta.models.order_response_fiscal_entity_address import OrderResponseFiscalEntityAddress
-from conekta.models.order_response_fiscal_entity_address_all_of import OrderResponseFiscalEntityAddressAllOf
 from conekta.models.order_response_products import OrderResponseProducts
 from conekta.models.order_response_products_all_of import OrderResponseProductsAllOf
 from conekta.models.order_response_shipping_contact import OrderResponseShippingContact
 from conekta.models.order_response_shipping_contact_all_of import OrderResponseShippingContactAllOf
 from conekta.models.order_tax_request import OrderTaxRequest
+from conekta.models.order_update_fiscal_entity_request import OrderUpdateFiscalEntityRequest
 from conekta.models.order_update_request import OrderUpdateRequest
 from conekta.models.order_update_request_customer_info import OrderUpdateRequestCustomerInfo
 from conekta.models.orders_response import OrdersResponse
 from conekta.models.page import Page
 from conekta.models.pagination import Pagination
 from conekta.models.payment_method import PaymentMethod
 from conekta.models.payment_method_bank_transfer import PaymentMethodBankTransfer
```

### Comparing `conekta-6.0.1/conekta/models/api_key_create_response.py` & `conekta-6.0.2/conekta/models/get_order_discount_lines_response.py`

 * *Files 23% similar despite different names*

```diff
@@ -1,98 +1,115 @@
 # coding: utf-8
 
 """
     Conekta API
 
-    Conekta sdk  # noqa: E501
+    Conekta sdk
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
-"""
+"""  # noqa: E501
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
 
-from typing import Optional
-from pydantic import BaseModel, Field, StrictBool, StrictInt, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from pydantic import BaseModel, StrictBool, StrictStr
+from pydantic import Field
+from conekta.models.discount_lines_response import DiscountLinesResponse
+try:
+    from typing import Self
+except ImportError:
+    from typing_extensions import Self
 
-class ApiKeyCreateResponse(BaseModel):
-    """
-    ApiKeyCreateResponse
+class GetOrderDiscountLinesResponse(BaseModel):
     """
-    authentication_token: Optional[StrictStr] = Field(None, description="It is occupied as a user when authenticated with basic authentication, with a blank password. This value will only appear once, in the request to create a new key. Copy and save it in a safe place.")
-    active: Optional[StrictBool] = Field(None, description="Indicates if the api key is active")
-    created_at: Optional[StrictInt] = Field(None, description="Unix timestamp in seconds of when the api key was created")
-    updated_at: Optional[StrictInt] = Field(None, description="Unix timestamp in seconds of when the api key was last updated")
-    deactivated_at: Optional[StrictInt] = Field(None, description="Unix timestamp in seconds of when the api key was deleted")
-    description: Optional[StrictStr] = Field(None, description="A name or brief explanation of what this api key is used for")
-    id: Optional[StrictStr] = Field(None, description="Unique identifier of the api key")
-    livemode: Optional[StrictBool] = Field(None, description="Indicates if the api key is in production")
-    deleted: Optional[StrictBool] = Field(None, description="Indicates if the api key was deleted")
-    object: Optional[StrictStr] = Field(None, description="Object name, value is 'api_key'")
-    prefix: Optional[StrictStr] = Field(None, description="The first few characters of the authentication_token")
-    role: Optional[StrictStr] = Field(None, description="Indicates if the api key is private or public")
-    __properties = ["authentication_token", "active", "created_at", "updated_at", "deactivated_at", "description", "id", "livemode", "deleted", "object", "prefix", "role"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    GetOrderDiscountLinesResponse
+    """ # noqa: E501
+    has_more: StrictBool = Field(description="Indicates if there are more pages to be requested")
+    object: StrictStr = Field(description="Object type, in this case is list")
+    next_page_url: Optional[StrictStr] = Field(default=None, description="URL of the next page.")
+    previous_page_url: Optional[StrictStr] = Field(default=None, description="Url of the previous page.")
+    data: Optional[List[DiscountLinesResponse]] = None
+    __properties: ClassVar[List[str]] = ["has_more", "object", "next_page_url", "previous_page_url", "data"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> ApiKeyCreateResponse:
-        """Create an instance of ApiKeyCreateResponse from a JSON string"""
+    def from_json(cls, json_str: str) -> Self:
+        """Create an instance of GetOrderDiscountLinesResponse from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
-        # set to None if deactivated_at (nullable) is None
-        # and __fields_set__ contains the field
-        if self.deactivated_at is None and "deactivated_at" in self.__fields_set__:
-            _dict['deactivated_at'] = None
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude={
+            },
+            exclude_none=True,
+        )
+        # override the default output from pydantic by calling `to_dict()` of each item in data (list)
+        _items = []
+        if self.data:
+            for _item in self.data:
+                if _item:
+                    _items.append(_item.to_dict())
+            _dict['data'] = _items
+        # set to None if next_page_url (nullable) is None
+        # and model_fields_set contains the field
+        if self.next_page_url is None and "next_page_url" in self.model_fields_set:
+            _dict['next_page_url'] = None
+
+        # set to None if previous_page_url (nullable) is None
+        # and model_fields_set contains the field
+        if self.previous_page_url is None and "previous_page_url" in self.model_fields_set:
+            _dict['previous_page_url'] = None
 
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> ApiKeyCreateResponse:
-        """Create an instance of ApiKeyCreateResponse from a dict"""
+    def from_dict(cls, obj: Dict) -> Self:
+        """Create an instance of GetOrderDiscountLinesResponse from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return ApiKeyCreateResponse.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = ApiKeyCreateResponse.parse_obj({
-            "authentication_token": obj.get("authentication_token"),
-            "active": obj.get("active"),
-            "created_at": obj.get("created_at"),
-            "updated_at": obj.get("updated_at"),
-            "deactivated_at": obj.get("deactivated_at"),
-            "description": obj.get("description"),
-            "id": obj.get("id"),
-            "livemode": obj.get("livemode"),
-            "deleted": obj.get("deleted"),
+        _obj = cls.model_validate({
+            "has_more": obj.get("has_more"),
             "object": obj.get("object"),
-            "prefix": obj.get("prefix"),
-            "role": obj.get("role")
+            "next_page_url": obj.get("next_page_url"),
+            "previous_page_url": obj.get("previous_page_url"),
+            "data": [DiscountLinesResponse.from_dict(_item) for _item in obj.get("data")] if obj.get("data") is not None else None
         })
         return _obj
 
+
```

### Comparing `conekta-6.0.1/conekta/models/api_key_request.py` & `conekta-6.0.2/conekta/models/page.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,73 +1,101 @@
 # coding: utf-8
 
 """
     Conekta API
 
-    Conekta sdk  # noqa: E501
+    Conekta sdk
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
-"""
+"""  # noqa: E501
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
 
-from typing import Optional
-from pydantic import BaseModel, Field, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from pydantic import BaseModel, StrictStr
+from pydantic import Field
+try:
+    from typing import Self
+except ImportError:
+    from typing_extensions import Self
 
-class ApiKeyRequest(BaseModel):
-    """
-    ApiKeyRequest
+class Page(BaseModel):
     """
-    description: Optional[StrictStr] = Field(None, description="A name or brief explanation of what this api key is used for")
-    role: StrictStr = Field(...)
-    __properties = ["description", "role"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    page metadata
+    """ # noqa: E501
+    next_page_url: Optional[StrictStr] = Field(default=None, description="URL of the next page.")
+    previous_page_url: Optional[StrictStr] = Field(default=None, description="Url of the previous page.")
+    __properties: ClassVar[List[str]] = ["next_page_url", "previous_page_url"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> ApiKeyRequest:
-        """Create an instance of ApiKeyRequest from a JSON string"""
+    def from_json(cls, json_str: str) -> Self:
+        """Create an instance of Page from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude={
+            },
+            exclude_none=True,
+        )
+        # set to None if next_page_url (nullable) is None
+        # and model_fields_set contains the field
+        if self.next_page_url is None and "next_page_url" in self.model_fields_set:
+            _dict['next_page_url'] = None
+
+        # set to None if previous_page_url (nullable) is None
+        # and model_fields_set contains the field
+        if self.previous_page_url is None and "previous_page_url" in self.model_fields_set:
+            _dict['previous_page_url'] = None
+
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> ApiKeyRequest:
-        """Create an instance of ApiKeyRequest from a dict"""
+    def from_dict(cls, obj: Dict) -> Self:
+        """Create an instance of Page from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return ApiKeyRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = ApiKeyRequest.parse_obj({
-            "description": obj.get("description"),
-            "role": obj.get("role")
+        _obj = cls.model_validate({
+            "next_page_url": obj.get("next_page_url"),
+            "previous_page_url": obj.get("previous_page_url")
         })
         return _obj
 
+
```

### Comparing `conekta-6.0.1/conekta/models/api_key_response.py` & `conekta-6.0.2/conekta/models/api_key_response.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,96 +1,114 @@
 # coding: utf-8
 
 """
     Conekta API
 
-    Conekta sdk  # noqa: E501
+    Conekta sdk
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
-"""
+"""  # noqa: E501
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
 
-from typing import Optional
-from pydantic import BaseModel, Field, StrictBool, StrictInt, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from pydantic import BaseModel, StrictBool, StrictInt, StrictStr
+from pydantic import Field
+try:
+    from typing import Self
+except ImportError:
+    from typing_extensions import Self
 
 class ApiKeyResponse(BaseModel):
     """
     api keys model
-    """
-    active: Optional[StrictBool] = Field(None, description="Indicates if the api key is active")
-    created_at: Optional[StrictInt] = Field(None, description="Unix timestamp in seconds of when the api key was created")
-    updated_at: Optional[StrictInt] = Field(None, description="Unix timestamp in seconds of when the api key was last updated")
-    deactivated_at: Optional[StrictInt] = Field(None, description="Unix timestamp in seconds of when the api key was deleted")
-    description: Optional[StrictStr] = Field(None, description="A name or brief explanation of what this api key is used for")
-    id: Optional[StrictStr] = Field(None, description="Unique identifier of the api key")
-    livemode: Optional[StrictBool] = Field(None, description="Indicates if the api key is in production")
-    deleted: Optional[StrictBool] = Field(None, description="Indicates if the api key was deleted")
-    object: Optional[StrictStr] = Field(None, description="Object name, value is 'api_key'")
-    prefix: Optional[StrictStr] = Field(None, description="The first few characters of the authentication_token")
-    role: Optional[StrictStr] = Field(None, description="Indicates if the api key is private or public")
-    __properties = ["active", "created_at", "updated_at", "deactivated_at", "description", "id", "livemode", "deleted", "object", "prefix", "role"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    """ # noqa: E501
+    active: Optional[StrictBool] = Field(default=None, description="Indicates if the api key is active")
+    created_at: Optional[StrictInt] = Field(default=None, description="Unix timestamp in seconds of when the api key was created")
+    updated_at: Optional[StrictInt] = Field(default=None, description="Unix timestamp in seconds of when the api key was last updated")
+    deactivated_at: Optional[StrictInt] = Field(default=None, description="Unix timestamp in seconds of when the api key was deleted")
+    description: Optional[StrictStr] = Field(default=None, description="A name or brief explanation of what this api key is used for")
+    id: Optional[StrictStr] = Field(default=None, description="Unique identifier of the api key")
+    livemode: Optional[StrictBool] = Field(default=None, description="Indicates if the api key is in production")
+    deleted: Optional[StrictBool] = Field(default=None, description="Indicates if the api key was deleted")
+    object: Optional[StrictStr] = Field(default=None, description="Object name, value is 'api_key'")
+    prefix: Optional[StrictStr] = Field(default=None, description="The first few characters of the authentication_token")
+    role: Optional[StrictStr] = Field(default=None, description="Indicates if the api key is private or public")
+    __properties: ClassVar[List[str]] = ["active", "created_at", "updated_at", "deactivated_at", "description", "id", "livemode", "deleted", "object", "prefix", "role"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> ApiKeyResponse:
+    def from_json(cls, json_str: str) -> Self:
         """Create an instance of ApiKeyResponse from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude={
+            },
+            exclude_none=True,
+        )
         # set to None if deactivated_at (nullable) is None
-        # and __fields_set__ contains the field
-        if self.deactivated_at is None and "deactivated_at" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.deactivated_at is None and "deactivated_at" in self.model_fields_set:
             _dict['deactivated_at'] = None
 
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> ApiKeyResponse:
+    def from_dict(cls, obj: Dict) -> Self:
         """Create an instance of ApiKeyResponse from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return ApiKeyResponse.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = ApiKeyResponse.parse_obj({
+        _obj = cls.model_validate({
             "active": obj.get("active"),
             "created_at": obj.get("created_at"),
             "updated_at": obj.get("updated_at"),
             "deactivated_at": obj.get("deactivated_at"),
             "description": obj.get("description"),
             "id": obj.get("id"),
             "livemode": obj.get("livemode"),
             "deleted": obj.get("deleted"),
             "object": obj.get("object"),
             "prefix": obj.get("prefix"),
             "role": obj.get("role")
         })
         return _obj
 
+
```

### Comparing `conekta-6.0.1/conekta/models/api_key_response_on_delete.py` & `conekta-6.0.2/conekta/models/delete_api_keys_response.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,87 +1,105 @@
 # coding: utf-8
 
 """
     Conekta API
 
-    Conekta sdk  # noqa: E501
+    Conekta sdk
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
-"""
+"""  # noqa: E501
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
 
-from typing import Optional
-from pydantic import BaseModel, Field, StrictBool, StrictInt, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from pydantic import BaseModel, StrictBool, StrictInt, StrictStr
+from pydantic import Field
+try:
+    from typing import Self
+except ImportError:
+    from typing_extensions import Self
 
-class ApiKeyResponseOnDelete(BaseModel):
-    """
-    api keys model
+class DeleteApiKeysResponse(BaseModel):
     """
-    active: Optional[StrictBool] = Field(None, description="Indicates if the api key is active")
-    created_at: Optional[StrictInt] = Field(None, description="Unix timestamp in seconds of when the api key was created")
-    description: Optional[StrictStr] = Field(None, description="A name or brief explanation of what this api key is used for")
-    livemode: Optional[StrictBool] = Field(None, description="Indicates if the api key is in production")
-    prefix: Optional[StrictStr] = Field(None, description="The first few characters of the authentication_token")
-    id: Optional[StrictStr] = Field(None, description="Unique identifier of the api key")
-    object: Optional[StrictStr] = Field(None, description="Object name, value is 'api_key'")
-    deleted: Optional[StrictBool] = Field(None, description="Indicates if the api key was deleted")
-    role: Optional[StrictStr] = Field(None, description="Indicates if the api key is private or public")
-    __properties = ["active", "created_at", "description", "livemode", "prefix", "id", "object", "deleted", "role"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    DeleteApiKeysResponse
+    """ # noqa: E501
+    active: Optional[StrictBool] = Field(default=None, description="Indicates if the api key is active")
+    created_at: Optional[StrictInt] = Field(default=None, description="Unix timestamp in seconds of when the api key was created")
+    description: Optional[StrictStr] = Field(default=None, description="A name or brief explanation of what this api key is used for")
+    livemode: Optional[StrictBool] = Field(default=None, description="Indicates if the api key is in production")
+    prefix: Optional[StrictStr] = Field(default=None, description="The first few characters of the authentication_token")
+    id: Optional[StrictStr] = Field(default=None, description="Unique identifier of the api key")
+    object: Optional[StrictStr] = Field(default=None, description="Object name, value is 'api_key'")
+    deleted: Optional[StrictBool] = None
+    role: Optional[StrictStr] = Field(default=None, description="Indicates if the api key is private or public")
+    __properties: ClassVar[List[str]] = ["active", "created_at", "description", "livemode", "prefix", "id", "object", "deleted", "role"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> ApiKeyResponseOnDelete:
-        """Create an instance of ApiKeyResponseOnDelete from a JSON string"""
+    def from_json(cls, json_str: str) -> Self:
+        """Create an instance of DeleteApiKeysResponse from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude={
+            },
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> ApiKeyResponseOnDelete:
-        """Create an instance of ApiKeyResponseOnDelete from a dict"""
+    def from_dict(cls, obj: Dict) -> Self:
+        """Create an instance of DeleteApiKeysResponse from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return ApiKeyResponseOnDelete.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = ApiKeyResponseOnDelete.parse_obj({
+        _obj = cls.model_validate({
             "active": obj.get("active"),
             "created_at": obj.get("created_at"),
             "description": obj.get("description"),
             "livemode": obj.get("livemode"),
             "prefix": obj.get("prefix"),
             "id": obj.get("id"),
             "object": obj.get("object"),
             "deleted": obj.get("deleted"),
             "role": obj.get("role")
         })
         return _obj
 
+
```

### Comparing `conekta-6.0.1/conekta/models/api_key_update_request.py` & `conekta-6.0.2/conekta/models/deleted_whitelist_rule_response.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,73 +1,95 @@
 # coding: utf-8
 
 """
     Conekta API
 
-    Conekta sdk  # noqa: E501
+    Conekta sdk
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
-"""
+"""  # noqa: E501
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
 
-from typing import Optional
-from pydantic import BaseModel, Field, StrictBool, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from pydantic import BaseModel, StrictStr
+from pydantic import Field
+try:
+    from typing import Self
+except ImportError:
+    from typing_extensions import Self
 
-class ApiKeyUpdateRequest(BaseModel):
-    """
-    ApiKeyUpdateRequest
+class DeletedWhitelistRuleResponse(BaseModel):
     """
-    active: Optional[StrictBool] = Field(None, description="Indicates if the webhook key is active")
-    description: Optional[StrictStr] = Field(None, description="A name or brief explanation of what this api key is used for")
-    __properties = ["active", "description"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    DeletedWhitelistRuleResponse
+    """ # noqa: E501
+    id: Optional[StrictStr] = Field(default=None, description="Whitelist rule id")
+    field: Optional[StrictStr] = Field(default=None, description="field used for whitelists rule deleted")
+    value: Optional[StrictStr] = Field(default=None, description="value used for whitelists rule deleted")
+    description: Optional[StrictStr] = Field(default=None, description="use an description for whitelisted rule")
+    __properties: ClassVar[List[str]] = ["id", "field", "value", "description"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> ApiKeyUpdateRequest:
-        """Create an instance of ApiKeyUpdateRequest from a JSON string"""
+    def from_json(cls, json_str: str) -> Self:
+        """Create an instance of DeletedWhitelistRuleResponse from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude={
+            },
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> ApiKeyUpdateRequest:
-        """Create an instance of ApiKeyUpdateRequest from a dict"""
+    def from_dict(cls, obj: Dict) -> Self:
+        """Create an instance of DeletedWhitelistRuleResponse from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return ApiKeyUpdateRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = ApiKeyUpdateRequest.parse_obj({
-            "active": obj.get("active"),
+        _obj = cls.model_validate({
+            "id": obj.get("id"),
+            "field": obj.get("field"),
+            "value": obj.get("value"),
             "description": obj.get("description")
         })
         return _obj
 
+
```

### Comparing `conekta-6.0.1/conekta/models/balance_common_field.py` & `conekta-6.0.2/conekta/models/blacklist_rule_response.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,73 +1,95 @@
 # coding: utf-8
 
 """
     Conekta API
 
-    Conekta sdk  # noqa: E501
+    Conekta sdk
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
-"""
+"""  # noqa: E501
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
 
-from typing import Optional
-from pydantic import BaseModel, Field, StrictInt, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from pydantic import BaseModel, StrictStr
+from pydantic import Field
+try:
+    from typing import Self
+except ImportError:
+    from typing_extensions import Self
 
-class BalanceCommonField(BaseModel):
-    """
-    balance common fields model
+class BlacklistRuleResponse(BaseModel):
     """
-    amount: Optional[StrictInt] = Field(None, description="The balance's amount")
-    currency: Optional[StrictStr] = Field(None, description="The balance's currency")
-    __properties = ["amount", "currency"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    BlacklistRuleResponse
+    """ # noqa: E501
+    id: Optional[StrictStr] = Field(default=None, description="Blacklist rule id")
+    field: Optional[StrictStr] = Field(default=None, description="field used for blacklists rule")
+    value: Optional[StrictStr] = Field(default=None, description="value used for blacklists rule")
+    description: Optional[StrictStr] = Field(default=None, description="use an description for blacklisted rule")
+    __properties: ClassVar[List[str]] = ["id", "field", "value", "description"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> BalanceCommonField:
-        """Create an instance of BalanceCommonField from a JSON string"""
+    def from_json(cls, json_str: str) -> Self:
+        """Create an instance of BlacklistRuleResponse from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude={
+            },
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> BalanceCommonField:
-        """Create an instance of BalanceCommonField from a dict"""
+    def from_dict(cls, obj: Dict) -> Self:
+        """Create an instance of BlacklistRuleResponse from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return BalanceCommonField.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = BalanceCommonField.parse_obj({
-            "amount": obj.get("amount"),
-            "currency": obj.get("currency")
+        _obj = cls.model_validate({
+            "id": obj.get("id"),
+            "field": obj.get("field"),
+            "value": obj.get("value"),
+            "description": obj.get("description")
         })
         return _obj
 
+
```

### Comparing `conekta-6.0.1/conekta/models/balance_response.py` & `conekta-6.0.2/conekta/models/balance_response.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,72 +1,89 @@
 # coding: utf-8
 
 """
     Conekta API
 
-    Conekta sdk  # noqa: E501
+    Conekta sdk
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
-"""
+"""  # noqa: E501
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
 
-from typing import Any, Dict, List, Optional
-from pydantic import BaseModel, Field, conlist
+from typing import Any, ClassVar, Dict, List, Optional, Union
+from pydantic import BaseModel
+from pydantic import Field
 from conekta.models.balance_common_field import BalanceCommonField
+try:
+    from typing import Self
+except ImportError:
+    from typing_extensions import Self
 
 class BalanceResponse(BaseModel):
     """
     balance model
-    """
-    available: Optional[conlist(BalanceCommonField)] = Field(None, description="The balance's available")
-    cashout_retention_amount: Optional[conlist(BalanceCommonField)] = Field(None, description="The balance's cashout retention amount")
-    conekta_retention: Optional[conlist(BalanceCommonField)] = Field(None, description="The balance's conekta retention")
-    gateway: Optional[conlist(BalanceCommonField)] = Field(None, description="The balance's gateway")
-    pending: Optional[conlist(BalanceCommonField)] = Field(None, description="The balance's pending")
-    retained: Optional[conlist(BalanceCommonField)] = Field(None, description="The balance's retained")
-    retention_amount: Optional[conlist(BalanceCommonField)] = Field(None, description="The balance's retention amount")
-    target_collateral_amount: Optional[Dict[str, Any]] = Field(None, description="The balance's target collateral amount")
-    target_retention_amount: Optional[conlist(BalanceCommonField)] = Field(None, description="The balance's target retention amount")
-    temporarily_retained: Optional[conlist(BalanceCommonField)] = Field(None, description="The balance's temporarily retained")
-    __properties = ["available", "cashout_retention_amount", "conekta_retention", "gateway", "pending", "retained", "retention_amount", "target_collateral_amount", "target_retention_amount", "temporarily_retained"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    """ # noqa: E501
+    available: Optional[List[BalanceCommonField]] = Field(default=None, description="The balance's available")
+    cashout_retention_amount: Optional[List[BalanceCommonField]] = Field(default=None, description="The balance's cashout retention amount")
+    conekta_retention: Optional[List[BalanceCommonField]] = Field(default=None, description="The balance's conekta retention")
+    gateway: Optional[List[BalanceCommonField]] = Field(default=None, description="The balance's gateway")
+    pending: Optional[List[BalanceCommonField]] = Field(default=None, description="The balance's pending")
+    retained: Optional[List[BalanceCommonField]] = Field(default=None, description="The balance's retained")
+    retention_amount: Optional[List[BalanceCommonField]] = Field(default=None, description="The balance's retention amount")
+    target_collateral_amount: Optional[Union[str, Any]] = Field(default=None, description="The balance's target collateral amount")
+    target_retention_amount: Optional[List[BalanceCommonField]] = Field(default=None, description="The balance's target retention amount")
+    temporarily_retained: Optional[List[BalanceCommonField]] = Field(default=None, description="The balance's temporarily retained")
+    __properties: ClassVar[List[str]] = ["available", "cashout_retention_amount", "conekta_retention", "gateway", "pending", "retained", "retention_amount", "target_collateral_amount", "target_retention_amount", "temporarily_retained"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> BalanceResponse:
+    def from_json(cls, json_str: str) -> Self:
         """Create an instance of BalanceResponse from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude={
+            },
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of each item in available (list)
         _items = []
         if self.available:
             for _item in self.available:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['available'] = _items
@@ -125,29 +142,30 @@
             for _item in self.temporarily_retained:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['temporarily_retained'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> BalanceResponse:
+    def from_dict(cls, obj: Dict) -> Self:
         """Create an instance of BalanceResponse from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return BalanceResponse.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = BalanceResponse.parse_obj({
+        _obj = cls.model_validate({
             "available": [BalanceCommonField.from_dict(_item) for _item in obj.get("available")] if obj.get("available") is not None else None,
             "cashout_retention_amount": [BalanceCommonField.from_dict(_item) for _item in obj.get("cashout_retention_amount")] if obj.get("cashout_retention_amount") is not None else None,
             "conekta_retention": [BalanceCommonField.from_dict(_item) for _item in obj.get("conekta_retention")] if obj.get("conekta_retention") is not None else None,
             "gateway": [BalanceCommonField.from_dict(_item) for _item in obj.get("gateway")] if obj.get("gateway") is not None else None,
             "pending": [BalanceCommonField.from_dict(_item) for _item in obj.get("pending")] if obj.get("pending") is not None else None,
             "retained": [BalanceCommonField.from_dict(_item) for _item in obj.get("retained")] if obj.get("retained") is not None else None,
             "retention_amount": [BalanceCommonField.from_dict(_item) for _item in obj.get("retention_amount")] if obj.get("retention_amount") is not None else None,
             "target_collateral_amount": obj.get("target_collateral_amount"),
             "target_retention_amount": [BalanceCommonField.from_dict(_item) for _item in obj.get("target_retention_amount")] if obj.get("target_retention_amount") is not None else None,
             "temporarily_retained": [BalanceCommonField.from_dict(_item) for _item in obj.get("temporarily_retained")] if obj.get("temporarily_retained") is not None else None
         })
         return _obj
 
+
```

### Comparing `conekta-6.0.1/conekta/models/blacklist_rule_response.py` & `conekta-6.0.2/conekta/models/subscription_request.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,77 +1,92 @@
 # coding: utf-8
 
 """
     Conekta API
 
-    Conekta sdk  # noqa: E501
+    Conekta sdk
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
-"""
+"""  # noqa: E501
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
 
-from typing import Optional
-from pydantic import BaseModel, Field, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from pydantic import BaseModel, StrictInt, StrictStr
+try:
+    from typing import Self
+except ImportError:
+    from typing_extensions import Self
 
-class BlacklistRuleResponse(BaseModel):
-    """
-    BlacklistRuleResponse
+class SubscriptionRequest(BaseModel):
     """
-    id: Optional[StrictStr] = Field(None, description="Blacklist rule id")
-    field: Optional[StrictStr] = Field(None, description="field used for blacklists rule")
-    value: Optional[StrictStr] = Field(None, description="value used for blacklists rule")
-    description: Optional[StrictStr] = Field(None, description="use an description for blacklisted rule")
-    __properties = ["id", "field", "value", "description"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    It is a parameter that allows to identify in the response, the detailed content of the plans to which the client has subscribed
+    """ # noqa: E501
+    plan_id: StrictStr
+    card_id: Optional[StrictStr] = None
+    trial_end: Optional[StrictInt] = None
+    __properties: ClassVar[List[str]] = ["plan_id", "card_id", "trial_end"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> BlacklistRuleResponse:
-        """Create an instance of BlacklistRuleResponse from a JSON string"""
+    def from_json(cls, json_str: str) -> Self:
+        """Create an instance of SubscriptionRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude={
+            },
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> BlacklistRuleResponse:
-        """Create an instance of BlacklistRuleResponse from a dict"""
+    def from_dict(cls, obj: Dict) -> Self:
+        """Create an instance of SubscriptionRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return BlacklistRuleResponse.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = BlacklistRuleResponse.parse_obj({
-            "id": obj.get("id"),
-            "field": obj.get("field"),
-            "value": obj.get("value"),
-            "description": obj.get("description")
+        _obj = cls.model_validate({
+            "plan_id": obj.get("plan_id"),
+            "card_id": obj.get("card_id"),
+            "trial_end": obj.get("trial_end")
         })
         return _obj
 
+
```

### Comparing `conekta-6.0.1/conekta/models/charge_data_payment_method_bank_transfer_response.py` & `conekta-6.0.2/conekta/models/payment_method_bank_transfer.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,139 +1,159 @@
 # coding: utf-8
 
 """
     Conekta API
 
-    Conekta sdk  # noqa: E501
+    Conekta sdk
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
-"""
+"""  # noqa: E501
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
 
-from typing import Any, List, Optional
-from pydantic import BaseModel, StrictInt, StrictStr, conlist
+from typing import Any, ClassVar, Dict, List, Optional, Union
+from pydantic import BaseModel, StrictInt, StrictStr
+try:
+    from typing import Self
+except ImportError:
+    from typing_extensions import Self
 
-class ChargeDataPaymentMethodBankTransferResponse(BaseModel):
-    """
-    use for bank transfer responses
+class PaymentMethodBankTransfer(BaseModel):
     """
+    PaymentMethodBankTransfer
+    """ # noqa: E501
+    type: Optional[StrictStr] = None
+    object: StrictStr
     bank: Optional[StrictStr] = None
     clabe: Optional[StrictStr] = None
     description: Optional[StrictStr] = None
     executed_at: Optional[StrictInt] = None
     expires_at: Optional[StrictInt] = None
     issuing_account_bank: Optional[StrictStr] = None
     issuing_account_number: Optional[StrictStr] = None
     issuing_account_holder_name: Optional[StrictStr] = None
     issuing_account_tax_id: Optional[StrictStr] = None
-    payment_attempts: Optional[conlist(Any)] = None
+    payment_attempts: Optional[List[Union[str, Any]]] = None
     receiving_account_holder_name: Optional[StrictStr] = None
     receiving_account_number: Optional[StrictStr] = None
     receiving_account_bank: Optional[StrictStr] = None
     receiving_account_tax_id: Optional[StrictStr] = None
     reference_number: Optional[StrictStr] = None
     tracking_code: Optional[StrictStr] = None
-    __properties = ["bank", "clabe", "description", "executed_at", "expires_at", "issuing_account_bank", "issuing_account_number", "issuing_account_holder_name", "issuing_account_tax_id", "payment_attempts", "receiving_account_holder_name", "receiving_account_number", "receiving_account_bank", "receiving_account_tax_id", "reference_number", "tracking_code"]
+    __properties: ClassVar[List[str]] = ["type", "object", "bank", "clabe", "description", "executed_at", "expires_at", "issuing_account_bank", "issuing_account_number", "issuing_account_holder_name", "issuing_account_tax_id", "payment_attempts", "receiving_account_holder_name", "receiving_account_number", "receiving_account_bank", "receiving_account_tax_id", "reference_number", "tracking_code"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True
+    }
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> ChargeDataPaymentMethodBankTransferResponse:
-        """Create an instance of ChargeDataPaymentMethodBankTransferResponse from a JSON string"""
+    def from_json(cls, json_str: str) -> Self:
+        """Create an instance of PaymentMethodBankTransfer from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude={
+            },
+            exclude_none=True,
+        )
         # set to None if description (nullable) is None
-        # and __fields_set__ contains the field
-        if self.description is None and "description" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.description is None and "description" in self.model_fields_set:
             _dict['description'] = None
 
         # set to None if executed_at (nullable) is None
-        # and __fields_set__ contains the field
-        if self.executed_at is None and "executed_at" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.executed_at is None and "executed_at" in self.model_fields_set:
             _dict['executed_at'] = None
 
         # set to None if issuing_account_bank (nullable) is None
-        # and __fields_set__ contains the field
-        if self.issuing_account_bank is None and "issuing_account_bank" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.issuing_account_bank is None and "issuing_account_bank" in self.model_fields_set:
             _dict['issuing_account_bank'] = None
 
         # set to None if issuing_account_number (nullable) is None
-        # and __fields_set__ contains the field
-        if self.issuing_account_number is None and "issuing_account_number" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.issuing_account_number is None and "issuing_account_number" in self.model_fields_set:
             _dict['issuing_account_number'] = None
 
         # set to None if issuing_account_holder_name (nullable) is None
-        # and __fields_set__ contains the field
-        if self.issuing_account_holder_name is None and "issuing_account_holder_name" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.issuing_account_holder_name is None and "issuing_account_holder_name" in self.model_fields_set:
             _dict['issuing_account_holder_name'] = None
 
         # set to None if issuing_account_tax_id (nullable) is None
-        # and __fields_set__ contains the field
-        if self.issuing_account_tax_id is None and "issuing_account_tax_id" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.issuing_account_tax_id is None and "issuing_account_tax_id" in self.model_fields_set:
             _dict['issuing_account_tax_id'] = None
 
         # set to None if receiving_account_holder_name (nullable) is None
-        # and __fields_set__ contains the field
-        if self.receiving_account_holder_name is None and "receiving_account_holder_name" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.receiving_account_holder_name is None and "receiving_account_holder_name" in self.model_fields_set:
             _dict['receiving_account_holder_name'] = None
 
         # set to None if receiving_account_tax_id (nullable) is None
-        # and __fields_set__ contains the field
-        if self.receiving_account_tax_id is None and "receiving_account_tax_id" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.receiving_account_tax_id is None and "receiving_account_tax_id" in self.model_fields_set:
             _dict['receiving_account_tax_id'] = None
 
         # set to None if reference_number (nullable) is None
-        # and __fields_set__ contains the field
-        if self.reference_number is None and "reference_number" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.reference_number is None and "reference_number" in self.model_fields_set:
             _dict['reference_number'] = None
 
         # set to None if tracking_code (nullable) is None
-        # and __fields_set__ contains the field
-        if self.tracking_code is None and "tracking_code" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.tracking_code is None and "tracking_code" in self.model_fields_set:
             _dict['tracking_code'] = None
 
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> ChargeDataPaymentMethodBankTransferResponse:
-        """Create an instance of ChargeDataPaymentMethodBankTransferResponse from a dict"""
+    def from_dict(cls, obj: Dict) -> Self:
+        """Create an instance of PaymentMethodBankTransfer from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return ChargeDataPaymentMethodBankTransferResponse.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = ChargeDataPaymentMethodBankTransferResponse.parse_obj({
+        _obj = cls.model_validate({
+            "type": obj.get("type"),
+            "object": obj.get("object"),
             "bank": obj.get("bank"),
             "clabe": obj.get("clabe"),
             "description": obj.get("description"),
             "executed_at": obj.get("executed_at"),
             "expires_at": obj.get("expires_at"),
             "issuing_account_bank": obj.get("issuing_account_bank"),
             "issuing_account_number": obj.get("issuing_account_number"),
@@ -145,7 +165,8 @@
             "receiving_account_bank": obj.get("receiving_account_bank"),
             "receiving_account_tax_id": obj.get("receiving_account_tax_id"),
             "reference_number": obj.get("reference_number"),
             "tracking_code": obj.get("tracking_code")
         })
         return _obj
 
+
```

### Comparing `conekta-6.0.1/conekta/models/charge_data_payment_method_card_response.py` & `conekta-6.0.2/conekta/models/charge_response_channel.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,91 +1,94 @@
 # coding: utf-8
 
 """
     Conekta API
 
-    Conekta sdk  # noqa: E501
+    Conekta sdk
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
-"""
+"""  # noqa: E501
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
 
-from typing import Any, List, Optional
-from pydantic import BaseModel, Field, StrictStr, conlist, constr
+from typing import Any, ClassVar, Dict, List, Optional
+from pydantic import BaseModel, StrictStr
+try:
+    from typing import Self
+except ImportError:
+    from typing_extensions import Self
 
-class ChargeDataPaymentMethodCardResponse(BaseModel):
-    """
-    use for card responses
+class ChargeResponseChannel(BaseModel):
     """
-    account_type: Optional[StrictStr] = None
-    auth_code: Optional[StrictStr] = None
-    brand: Optional[StrictStr] = None
-    contract_id: Optional[constr(strict=True, max_length=10, min_length=10)] = Field(None, description="Id sent for recurrent charges.")
-    country: Optional[StrictStr] = None
-    exp_month: Optional[StrictStr] = None
-    exp_year: Optional[StrictStr] = None
-    fraud_indicators: Optional[conlist(Any)] = None
-    issuer: Optional[StrictStr] = None
-    last4: Optional[StrictStr] = None
-    name: Optional[StrictStr] = None
-    __properties = ["account_type", "auth_code", "brand", "contract_id", "country", "exp_month", "exp_year", "fraud_indicators", "issuer", "last4", "name"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    ChargeResponseChannel
+    """ # noqa: E501
+    segment: Optional[StrictStr] = None
+    checkout_request_id: Optional[StrictStr] = None
+    checkout_request_type: Optional[StrictStr] = None
+    id: Optional[StrictStr] = None
+    __properties: ClassVar[List[str]] = ["segment", "checkout_request_id", "checkout_request_type", "id"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> ChargeDataPaymentMethodCardResponse:
-        """Create an instance of ChargeDataPaymentMethodCardResponse from a JSON string"""
+    def from_json(cls, json_str: str) -> Self:
+        """Create an instance of ChargeResponseChannel from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude={
+            },
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> ChargeDataPaymentMethodCardResponse:
-        """Create an instance of ChargeDataPaymentMethodCardResponse from a dict"""
+    def from_dict(cls, obj: Dict) -> Self:
+        """Create an instance of ChargeResponseChannel from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return ChargeDataPaymentMethodCardResponse.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = ChargeDataPaymentMethodCardResponse.parse_obj({
-            "account_type": obj.get("account_type"),
-            "auth_code": obj.get("auth_code"),
-            "brand": obj.get("brand"),
-            "contract_id": obj.get("contract_id"),
-            "country": obj.get("country"),
-            "exp_month": obj.get("exp_month"),
-            "exp_year": obj.get("exp_year"),
-            "fraud_indicators": obj.get("fraud_indicators"),
-            "issuer": obj.get("issuer"),
-            "last4": obj.get("last4"),
-            "name": obj.get("name")
+        _obj = cls.model_validate({
+            "segment": obj.get("segment"),
+            "checkout_request_id": obj.get("checkout_request_id"),
+            "checkout_request_type": obj.get("checkout_request_type"),
+            "id": obj.get("id")
         })
         return _obj
 
+
```

### Comparing `conekta-6.0.1/conekta/models/charge_data_payment_method_cash_response.py` & `conekta-6.0.2/conekta/models/charge_data_payment_method_cash_response.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,100 +1,117 @@
 # coding: utf-8
 
 """
     Conekta API
 
-    Conekta sdk  # noqa: E501
+    Conekta sdk
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
-"""
+"""  # noqa: E501
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
 
-from typing import Optional
+from typing import Any, ClassVar, Dict, List, Optional
 from pydantic import BaseModel, StrictInt, StrictStr
+try:
+    from typing import Self
+except ImportError:
+    from typing_extensions import Self
 
 class ChargeDataPaymentMethodCashResponse(BaseModel):
     """
     use for cash responses
-    """
+    """ # noqa: E501
     auth_code: Optional[StrictInt] = None
     cashier_id: Optional[StrictStr] = None
     reference: Optional[StrictStr] = None
     barcode_url: Optional[StrictStr] = None
     expires_at: Optional[StrictInt] = None
     service_name: Optional[StrictStr] = None
     store: Optional[StrictStr] = None
     store_name: Optional[StrictStr] = None
-    __properties = ["auth_code", "cashier_id", "reference", "barcode_url", "expires_at", "service_name", "store", "store_name"]
+    __properties: ClassVar[List[str]] = ["auth_code", "cashier_id", "reference", "barcode_url", "expires_at", "service_name", "store", "store_name"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True
+    }
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> ChargeDataPaymentMethodCashResponse:
+    def from_json(cls, json_str: str) -> Self:
         """Create an instance of ChargeDataPaymentMethodCashResponse from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude={
+            },
+            exclude_none=True,
+        )
         # set to None if auth_code (nullable) is None
-        # and __fields_set__ contains the field
-        if self.auth_code is None and "auth_code" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.auth_code is None and "auth_code" in self.model_fields_set:
             _dict['auth_code'] = None
 
         # set to None if cashier_id (nullable) is None
-        # and __fields_set__ contains the field
-        if self.cashier_id is None and "cashier_id" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.cashier_id is None and "cashier_id" in self.model_fields_set:
             _dict['cashier_id'] = None
 
         # set to None if store (nullable) is None
-        # and __fields_set__ contains the field
-        if self.store is None and "store" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.store is None and "store" in self.model_fields_set:
             _dict['store'] = None
 
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> ChargeDataPaymentMethodCashResponse:
+    def from_dict(cls, obj: Dict) -> Self:
         """Create an instance of ChargeDataPaymentMethodCashResponse from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return ChargeDataPaymentMethodCashResponse.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = ChargeDataPaymentMethodCashResponse.parse_obj({
+        _obj = cls.model_validate({
             "auth_code": obj.get("auth_code"),
             "cashier_id": obj.get("cashier_id"),
             "reference": obj.get("reference"),
             "barcode_url": obj.get("barcode_url"),
             "expires_at": obj.get("expires_at"),
             "service_name": obj.get("service_name"),
             "store": obj.get("store"),
             "store_name": obj.get("store_name")
         })
         return _obj
 
+
```

### Comparing `conekta-6.0.1/conekta/models/charge_order_response.py` & `conekta-6.0.2/conekta/models/charge_response.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,137 +1,150 @@
 # coding: utf-8
 
 """
     Conekta API
 
-    Conekta sdk  # noqa: E501
+    Conekta sdk
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
-"""
+"""  # noqa: E501
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
 
-from typing import Any, Dict, List, Optional
-from pydantic import BaseModel, Field, StrictBool, StrictInt, StrictStr, conlist
-from conekta.models.charge_order_response_payment_method import ChargeOrderResponsePaymentMethod
+from typing import Any, ClassVar, Dict, List, Optional
+from pydantic import BaseModel, StrictBool, StrictInt, StrictStr
+from pydantic import Field
 from conekta.models.charge_response_channel import ChargeResponseChannel
+from conekta.models.charge_response_payment_method import ChargeResponsePaymentMethod
+from conekta.models.charge_response_refunds import ChargeResponseRefunds
+try:
+    from typing import Self
+except ImportError:
+    from typing_extensions import Self
 
-class ChargeOrderResponse(BaseModel):
-    """
-    ChargeOrderResponse
+class ChargeResponse(BaseModel):
     """
+    ChargeResponse
+    """ # noqa: E501
     amount: Optional[StrictInt] = None
     channel: Optional[ChargeResponseChannel] = None
     created_at: Optional[StrictInt] = None
     currency: Optional[StrictStr] = None
     customer_id: Optional[StrictStr] = None
     description: Optional[StrictStr] = None
     device_fingerprint: Optional[StrictStr] = None
     failure_code: Optional[StrictStr] = None
     failure_message: Optional[StrictStr] = None
-    fee: Optional[StrictInt] = None
     id: Optional[StrictStr] = None
     livemode: Optional[StrictBool] = None
-    monthly_installments: Optional[StrictInt] = None
     object: Optional[StrictStr] = None
     order_id: Optional[StrictStr] = None
     paid_at: Optional[StrictInt] = None
-    payment_method: Optional[ChargeOrderResponsePaymentMethod] = None
-    reference_id: Optional[StrictStr] = Field(None, description="Reference ID of the charge")
-    refunds: Optional[conlist(Dict[str, Any])] = None
+    payment_method: Optional[ChargeResponsePaymentMethod] = None
+    reference_id: Optional[StrictStr] = Field(default=None, description="Reference ID of the charge")
+    refunds: Optional[ChargeResponseRefunds] = None
     status: Optional[StrictStr] = None
-    __properties = ["amount", "channel", "created_at", "currency", "customer_id", "description", "device_fingerprint", "failure_code", "failure_message", "fee", "id", "livemode", "monthly_installments", "object", "order_id", "paid_at", "payment_method", "reference_id", "refunds", "status"]
+    __properties: ClassVar[List[str]] = ["amount", "channel", "created_at", "currency", "customer_id", "description", "device_fingerprint", "failure_code", "failure_message", "id", "livemode", "object", "order_id", "paid_at", "payment_method", "reference_id", "refunds", "status"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True
+    }
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> ChargeOrderResponse:
-        """Create an instance of ChargeOrderResponse from a JSON string"""
+    def from_json(cls, json_str: str) -> Self:
+        """Create an instance of ChargeResponse from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude={
+            },
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of channel
         if self.channel:
             _dict['channel'] = self.channel.to_dict()
         # override the default output from pydantic by calling `to_dict()` of payment_method
         if self.payment_method:
             _dict['payment_method'] = self.payment_method.to_dict()
-        # set to None if device_fingerprint (nullable) is None
-        # and __fields_set__ contains the field
-        if self.device_fingerprint is None and "device_fingerprint" in self.__fields_set__:
-            _dict['device_fingerprint'] = None
-
-        # set to None if monthly_installments (nullable) is None
-        # and __fields_set__ contains the field
-        if self.monthly_installments is None and "monthly_installments" in self.__fields_set__:
-            _dict['monthly_installments'] = None
-
+        # override the default output from pydantic by calling `to_dict()` of refunds
+        if self.refunds:
+            _dict['refunds'] = self.refunds.to_dict()
         # set to None if paid_at (nullable) is None
-        # and __fields_set__ contains the field
-        if self.paid_at is None and "paid_at" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.paid_at is None and "paid_at" in self.model_fields_set:
             _dict['paid_at'] = None
 
         # set to None if reference_id (nullable) is None
-        # and __fields_set__ contains the field
-        if self.reference_id is None and "reference_id" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.reference_id is None and "reference_id" in self.model_fields_set:
             _dict['reference_id'] = None
 
+        # set to None if refunds (nullable) is None
+        # and model_fields_set contains the field
+        if self.refunds is None and "refunds" in self.model_fields_set:
+            _dict['refunds'] = None
+
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> ChargeOrderResponse:
-        """Create an instance of ChargeOrderResponse from a dict"""
+    def from_dict(cls, obj: Dict) -> Self:
+        """Create an instance of ChargeResponse from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return ChargeOrderResponse.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = ChargeOrderResponse.parse_obj({
+        _obj = cls.model_validate({
             "amount": obj.get("amount"),
             "channel": ChargeResponseChannel.from_dict(obj.get("channel")) if obj.get("channel") is not None else None,
             "created_at": obj.get("created_at"),
             "currency": obj.get("currency"),
             "customer_id": obj.get("customer_id"),
             "description": obj.get("description"),
             "device_fingerprint": obj.get("device_fingerprint"),
             "failure_code": obj.get("failure_code"),
             "failure_message": obj.get("failure_message"),
-            "fee": obj.get("fee"),
             "id": obj.get("id"),
             "livemode": obj.get("livemode"),
-            "monthly_installments": obj.get("monthly_installments"),
             "object": obj.get("object"),
             "order_id": obj.get("order_id"),
             "paid_at": obj.get("paid_at"),
-            "payment_method": ChargeOrderResponsePaymentMethod.from_dict(obj.get("payment_method")) if obj.get("payment_method") is not None else None,
+            "payment_method": ChargeResponsePaymentMethod.from_dict(obj.get("payment_method")) if obj.get("payment_method") is not None else None,
             "reference_id": obj.get("reference_id"),
-            "refunds": obj.get("refunds"),
+            "refunds": ChargeResponseRefunds.from_dict(obj.get("refunds")) if obj.get("refunds") is not None else None,
             "status": obj.get("status")
         })
         return _obj
 
+
```

### Comparing `conekta-6.0.1/conekta/models/charge_order_response_payment_method.py` & `conekta-6.0.2/conekta/models/charge_order_response_payment_method.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,70 +1,77 @@
 # coding: utf-8
 
 """
     Conekta API
 
-    Conekta sdk  # noqa: E501
+    Conekta sdk
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
-"""
+"""  # noqa: E501
 
 
 from __future__ import annotations
 from inspect import getfullargspec
 import json
 import pprint
 import re  # noqa: F401
 
 from typing import Any, List, Optional
-from pydantic import BaseModel, Field, StrictStr, ValidationError, validator
+from pydantic import BaseModel, Field, StrictStr, ValidationError, field_validator
 from conekta.models.payment_method_bank_transfer import PaymentMethodBankTransfer
 from conekta.models.payment_method_card import PaymentMethodCard
 from conekta.models.payment_method_cash import PaymentMethodCash
-from typing import Any, List
+from typing import Union, Any, List, TYPE_CHECKING, Optional, Dict
+from typing_extensions import Literal
 from pydantic import StrictStr, Field
+try:
+    from typing import Self
+except ImportError:
+    from typing_extensions import Self
 
 CHARGEORDERRESPONSEPAYMENTMETHOD_ONE_OF_SCHEMAS = ["PaymentMethodBankTransfer", "PaymentMethodCard", "PaymentMethodCash"]
 
 class ChargeOrderResponsePaymentMethod(BaseModel):
     """
     ChargeOrderResponsePaymentMethod
     """
     # data type: PaymentMethodCash
     oneof_schema_1_validator: Optional[PaymentMethodCash] = None
     # data type: PaymentMethodCard
     oneof_schema_2_validator: Optional[PaymentMethodCard] = None
     # data type: PaymentMethodBankTransfer
     oneof_schema_3_validator: Optional[PaymentMethodBankTransfer] = None
-    actual_instance: Any
-    one_of_schemas: List[str] = Field(CHARGEORDERRESPONSEPAYMENTMETHOD_ONE_OF_SCHEMAS, const=True)
+    actual_instance: Optional[Union[PaymentMethodBankTransfer, PaymentMethodCard, PaymentMethodCash]] = None
+    one_of_schemas: List[str] = Literal["PaymentMethodBankTransfer", "PaymentMethodCard", "PaymentMethodCash"]
+
+    model_config = {
+        "validate_assignment": True
+    }
 
-    class Config:
-        validate_assignment = True
 
-    discriminator_value_class_map = {
+    discriminator_value_class_map: Dict[str, str] = {
     }
 
-    def __init__(self, *args, **kwargs):
+    def __init__(self, *args, **kwargs) -> None:
         if args:
             if len(args) > 1:
                 raise ValueError("If a position argument is used, only 1 is allowed to set `actual_instance`")
             if kwargs:
                 raise ValueError("If a position argument is used, keyword arguments cannot be used.")
             super().__init__(actual_instance=args[0])
         else:
             super().__init__(**kwargs)
 
-    @validator('actual_instance')
+    @field_validator('actual_instance')
     def actual_instance_must_validate_oneof(cls, v):
-        instance = ChargeOrderResponsePaymentMethod.construct()
+        instance = ChargeOrderResponsePaymentMethod.model_construct()
         error_messages = []
         match = 0
         # validate data type: PaymentMethodCash
         if not isinstance(v, PaymentMethodCash):
             error_messages.append(f"Error! Input type `{type(v)}` is not `PaymentMethodCash`")
         else:
             match += 1
@@ -84,21 +91,21 @@
         elif match == 0:
             # no match
             raise ValueError("No match found when setting `actual_instance` in ChargeOrderResponsePaymentMethod with oneOf schemas: PaymentMethodBankTransfer, PaymentMethodCard, PaymentMethodCash. Details: " + ", ".join(error_messages))
         else:
             return v
 
     @classmethod
-    def from_dict(cls, obj: dict) -> ChargeOrderResponsePaymentMethod:
+    def from_dict(cls, obj: dict) -> Self:
         return cls.from_json(json.dumps(obj))
 
     @classmethod
-    def from_json(cls, json_str: str) -> ChargeOrderResponsePaymentMethod:
+    def from_json(cls, json_str: str) -> Self:
         """Returns the object represented by the json string"""
-        instance = ChargeOrderResponsePaymentMethod.construct()
+        instance = cls.model_construct()
         error_messages = []
         match = 0
 
         # use oneOf discriminator to lookup the data type
         _data_type = json.loads(json_str).get("object")
         if not _data_type:
             raise ValueError("Failed to lookup data type from the field `object` in the input.")
@@ -168,23 +175,24 @@
 
         to_json = getattr(self.actual_instance, "to_json", None)
         if callable(to_json):
             return self.actual_instance.to_json()
         else:
             return json.dumps(self.actual_instance)
 
-    def to_dict(self) -> dict:
+    def to_dict(self) -> Dict:
         """Returns the dict representation of the actual instance"""
         if self.actual_instance is None:
             return None
 
         to_dict = getattr(self.actual_instance, "to_dict", None)
         if callable(to_dict):
             return self.actual_instance.to_dict()
         else:
             # primitive type
             return self.actual_instance
 
     def to_str(self) -> str:
         """Returns the string representation of the actual instance"""
-        return pprint.pformat(self.dict())
+        return pprint.pformat(self.model_dump())
+
```

### Comparing `conekta-6.0.1/conekta/models/charge_request.py` & `conekta-6.0.2/conekta/models/charge_request.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,81 +1,97 @@
 # coding: utf-8
 
 """
     Conekta API
 
-    Conekta sdk  # noqa: E501
+    Conekta sdk
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
-"""
+"""  # noqa: E501
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
 
-from typing import Optional
-from pydantic import BaseModel, Field, StrictInt, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from pydantic import BaseModel, StrictInt, StrictStr
+from pydantic import Field
 from conekta.models.charge_request_payment_method import ChargeRequestPaymentMethod
+try:
+    from typing import Self
+except ImportError:
+    from typing_extensions import Self
 
 class ChargeRequest(BaseModel):
     """
     The charges to be made
-    """
+    """ # noqa: E501
     amount: Optional[StrictInt] = None
-    monthly_installments: Optional[StrictInt] = Field(None, description="How many months without interest to apply, it can be 3, 6, 9, 12 or 18")
-    payment_method: ChargeRequestPaymentMethod = Field(...)
-    reference_id: Optional[StrictStr] = Field(None, description="Custom reference to add to the charge")
-    __properties = ["amount", "monthly_installments", "payment_method", "reference_id"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    payment_method: ChargeRequestPaymentMethod
+    reference_id: Optional[StrictStr] = Field(default=None, description="Custom reference to add to the charge")
+    __properties: ClassVar[List[str]] = ["amount", "payment_method", "reference_id"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> ChargeRequest:
+    def from_json(cls, json_str: str) -> Self:
         """Create an instance of ChargeRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude={
+            },
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of payment_method
         if self.payment_method:
             _dict['payment_method'] = self.payment_method.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> ChargeRequest:
+    def from_dict(cls, obj: Dict) -> Self:
         """Create an instance of ChargeRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return ChargeRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = ChargeRequest.parse_obj({
+        _obj = cls.model_validate({
             "amount": obj.get("amount"),
-            "monthly_installments": obj.get("monthly_installments"),
             "payment_method": ChargeRequestPaymentMethod.from_dict(obj.get("payment_method")) if obj.get("payment_method") is not None else None,
             "reference_id": obj.get("reference_id")
         })
         return _obj
 
+
```

### Comparing `conekta-6.0.1/conekta/models/charge_request_payment_method.py` & `conekta-6.0.2/conekta/models/subscription_update_request.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,79 +1,92 @@
 # coding: utf-8
 
 """
     Conekta API
 
-    Conekta sdk  # noqa: E501
+    Conekta sdk
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
-"""
+"""  # noqa: E501
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
 
-from typing import Optional
-from pydantic import BaseModel, Field, StrictInt, StrictStr, constr
+from typing import Any, ClassVar, Dict, List, Optional
+from pydantic import BaseModel, StrictInt, StrictStr
+try:
+    from typing import Self
+except ImportError:
+    from typing_extensions import Self
 
-class ChargeRequestPaymentMethod(BaseModel):
-    """
-    Payment method used in the charge. Go to the [payment methods](https://developers.conekta.com/reference/m%C3%A9todos-de-pago) section for more details 
+class SubscriptionUpdateRequest(BaseModel):
     """
-    expires_at: Optional[StrictInt] = Field(None, description="Method expiration date as unix timestamp")
-    type: StrictStr = Field(...)
-    token_id: Optional[StrictStr] = None
-    payment_source_id: Optional[StrictStr] = None
-    contract_id: Optional[constr(strict=True, max_length=10, min_length=10)] = Field(None, description="Optional id sent to indicate the bank contract for recurrent card charges.")
-    __properties = ["expires_at", "type", "token_id", "payment_source_id", "contract_id"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    You can modify the subscription to change the plan used by your customers.
+    """ # noqa: E501
+    plan_id: Optional[StrictStr] = None
+    card_id: Optional[StrictStr] = None
+    trial_end: Optional[StrictInt] = None
+    __properties: ClassVar[List[str]] = ["plan_id", "card_id", "trial_end"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> ChargeRequestPaymentMethod:
-        """Create an instance of ChargeRequestPaymentMethod from a JSON string"""
+    def from_json(cls, json_str: str) -> Self:
+        """Create an instance of SubscriptionUpdateRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude={
+            },
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> ChargeRequestPaymentMethod:
-        """Create an instance of ChargeRequestPaymentMethod from a dict"""
+    def from_dict(cls, obj: Dict) -> Self:
+        """Create an instance of SubscriptionUpdateRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return ChargeRequestPaymentMethod.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = ChargeRequestPaymentMethod.parse_obj({
-            "expires_at": obj.get("expires_at"),
-            "type": obj.get("type"),
-            "token_id": obj.get("token_id"),
-            "payment_source_id": obj.get("payment_source_id"),
-            "contract_id": obj.get("contract_id")
+        _obj = cls.model_validate({
+            "plan_id": obj.get("plan_id"),
+            "card_id": obj.get("card_id"),
+            "trial_end": obj.get("trial_end")
         })
         return _obj
 
+
```

### Comparing `conekta-6.0.1/conekta/models/charge_response.py` & `conekta-6.0.2/conekta/models/charges_data_response.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,134 +1,150 @@
 # coding: utf-8
 
 """
     Conekta API
 
-    Conekta sdk  # noqa: E501
+    Conekta sdk
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
-"""
+"""  # noqa: E501
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
 
-from typing import Optional
-from pydantic import BaseModel, Field, StrictBool, StrictInt, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from pydantic import BaseModel, StrictBool, StrictInt, StrictStr
+from pydantic import Field
 from conekta.models.charge_response_channel import ChargeResponseChannel
 from conekta.models.charge_response_payment_method import ChargeResponsePaymentMethod
 from conekta.models.charge_response_refunds import ChargeResponseRefunds
+try:
+    from typing import Self
+except ImportError:
+    from typing_extensions import Self
 
-class ChargeResponse(BaseModel):
-    """
-    ChargeResponse
+class ChargesDataResponse(BaseModel):
     """
+    ChargesDataResponse
+    """ # noqa: E501
     amount: Optional[StrictInt] = None
     channel: Optional[ChargeResponseChannel] = None
     created_at: Optional[StrictInt] = None
     currency: Optional[StrictStr] = None
     customer_id: Optional[StrictStr] = None
     description: Optional[StrictStr] = None
     device_fingerprint: Optional[StrictStr] = None
     failure_code: Optional[StrictStr] = None
     failure_message: Optional[StrictStr] = None
-    fee: Optional[StrictInt] = None
     id: Optional[StrictStr] = None
     livemode: Optional[StrictBool] = None
     object: Optional[StrictStr] = None
     order_id: Optional[StrictStr] = None
     paid_at: Optional[StrictInt] = None
     payment_method: Optional[ChargeResponsePaymentMethod] = None
-    reference_id: Optional[StrictStr] = Field(None, description="Reference ID of the charge")
+    reference_id: Optional[StrictStr] = Field(default=None, description="Reference ID of the charge")
     refunds: Optional[ChargeResponseRefunds] = None
     status: Optional[StrictStr] = None
-    __properties = ["amount", "channel", "created_at", "currency", "customer_id", "description", "device_fingerprint", "failure_code", "failure_message", "fee", "id", "livemode", "object", "order_id", "paid_at", "payment_method", "reference_id", "refunds", "status"]
+    __properties: ClassVar[List[str]] = ["amount", "channel", "created_at", "currency", "customer_id", "description", "device_fingerprint", "failure_code", "failure_message", "id", "livemode", "object", "order_id", "paid_at", "payment_method", "reference_id", "refunds", "status"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True
+    }
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> ChargeResponse:
-        """Create an instance of ChargeResponse from a JSON string"""
+    def from_json(cls, json_str: str) -> Self:
+        """Create an instance of ChargesDataResponse from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude={
+            },
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of channel
         if self.channel:
             _dict['channel'] = self.channel.to_dict()
         # override the default output from pydantic by calling `to_dict()` of payment_method
         if self.payment_method:
             _dict['payment_method'] = self.payment_method.to_dict()
         # override the default output from pydantic by calling `to_dict()` of refunds
         if self.refunds:
             _dict['refunds'] = self.refunds.to_dict()
         # set to None if paid_at (nullable) is None
-        # and __fields_set__ contains the field
-        if self.paid_at is None and "paid_at" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.paid_at is None and "paid_at" in self.model_fields_set:
             _dict['paid_at'] = None
 
         # set to None if reference_id (nullable) is None
-        # and __fields_set__ contains the field
-        if self.reference_id is None and "reference_id" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.reference_id is None and "reference_id" in self.model_fields_set:
             _dict['reference_id'] = None
 
         # set to None if refunds (nullable) is None
-        # and __fields_set__ contains the field
-        if self.refunds is None and "refunds" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.refunds is None and "refunds" in self.model_fields_set:
             _dict['refunds'] = None
 
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> ChargeResponse:
-        """Create an instance of ChargeResponse from a dict"""
+    def from_dict(cls, obj: Dict) -> Self:
+        """Create an instance of ChargesDataResponse from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return ChargeResponse.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = ChargeResponse.parse_obj({
+        _obj = cls.model_validate({
             "amount": obj.get("amount"),
             "channel": ChargeResponseChannel.from_dict(obj.get("channel")) if obj.get("channel") is not None else None,
             "created_at": obj.get("created_at"),
             "currency": obj.get("currency"),
             "customer_id": obj.get("customer_id"),
             "description": obj.get("description"),
             "device_fingerprint": obj.get("device_fingerprint"),
             "failure_code": obj.get("failure_code"),
             "failure_message": obj.get("failure_message"),
-            "fee": obj.get("fee"),
             "id": obj.get("id"),
             "livemode": obj.get("livemode"),
             "object": obj.get("object"),
             "order_id": obj.get("order_id"),
             "paid_at": obj.get("paid_at"),
             "payment_method": ChargeResponsePaymentMethod.from_dict(obj.get("payment_method")) if obj.get("payment_method") is not None else None,
             "reference_id": obj.get("reference_id"),
             "refunds": ChargeResponseRefunds.from_dict(obj.get("refunds")) if obj.get("refunds") is not None else None,
             "status": obj.get("status")
         })
         return _obj
 
+
```

### Comparing `conekta-6.0.1/conekta/models/charge_response_payment_method.py` & `conekta-6.0.2/conekta/models/charge_response_payment_method.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,70 +1,77 @@
 # coding: utf-8
 
 """
     Conekta API
 
-    Conekta sdk  # noqa: E501
+    Conekta sdk
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
-"""
+"""  # noqa: E501
 
 
 from __future__ import annotations
 from inspect import getfullargspec
 import json
 import pprint
 import re  # noqa: F401
 
 from typing import Any, List, Optional
-from pydantic import BaseModel, Field, StrictStr, ValidationError, validator
+from pydantic import BaseModel, Field, StrictStr, ValidationError, field_validator
 from conekta.models.payment_method_bank_transfer import PaymentMethodBankTransfer
 from conekta.models.payment_method_card import PaymentMethodCard
 from conekta.models.payment_method_cash import PaymentMethodCash
-from typing import Any, List
+from typing import Union, Any, List, TYPE_CHECKING, Optional, Dict
+from typing_extensions import Literal
 from pydantic import StrictStr, Field
+try:
+    from typing import Self
+except ImportError:
+    from typing_extensions import Self
 
 CHARGERESPONSEPAYMENTMETHOD_ONE_OF_SCHEMAS = ["PaymentMethodBankTransfer", "PaymentMethodCard", "PaymentMethodCash"]
 
 class ChargeResponsePaymentMethod(BaseModel):
     """
     ChargeResponsePaymentMethod
     """
     # data type: PaymentMethodCash
     oneof_schema_1_validator: Optional[PaymentMethodCash] = None
     # data type: PaymentMethodCard
     oneof_schema_2_validator: Optional[PaymentMethodCard] = None
     # data type: PaymentMethodBankTransfer
     oneof_schema_3_validator: Optional[PaymentMethodBankTransfer] = None
-    actual_instance: Any
-    one_of_schemas: List[str] = Field(CHARGERESPONSEPAYMENTMETHOD_ONE_OF_SCHEMAS, const=True)
+    actual_instance: Optional[Union[PaymentMethodBankTransfer, PaymentMethodCard, PaymentMethodCash]] = None
+    one_of_schemas: List[str] = Literal["PaymentMethodBankTransfer", "PaymentMethodCard", "PaymentMethodCash"]
+
+    model_config = {
+        "validate_assignment": True
+    }
 
-    class Config:
-        validate_assignment = True
 
-    discriminator_value_class_map = {
+    discriminator_value_class_map: Dict[str, str] = {
     }
 
-    def __init__(self, *args, **kwargs):
+    def __init__(self, *args, **kwargs) -> None:
         if args:
             if len(args) > 1:
                 raise ValueError("If a position argument is used, only 1 is allowed to set `actual_instance`")
             if kwargs:
                 raise ValueError("If a position argument is used, keyword arguments cannot be used.")
             super().__init__(actual_instance=args[0])
         else:
             super().__init__(**kwargs)
 
-    @validator('actual_instance')
+    @field_validator('actual_instance')
     def actual_instance_must_validate_oneof(cls, v):
-        instance = ChargeResponsePaymentMethod.construct()
+        instance = ChargeResponsePaymentMethod.model_construct()
         error_messages = []
         match = 0
         # validate data type: PaymentMethodCash
         if not isinstance(v, PaymentMethodCash):
             error_messages.append(f"Error! Input type `{type(v)}` is not `PaymentMethodCash`")
         else:
             match += 1
@@ -84,21 +91,21 @@
         elif match == 0:
             # no match
             raise ValueError("No match found when setting `actual_instance` in ChargeResponsePaymentMethod with oneOf schemas: PaymentMethodBankTransfer, PaymentMethodCard, PaymentMethodCash. Details: " + ", ".join(error_messages))
         else:
             return v
 
     @classmethod
-    def from_dict(cls, obj: dict) -> ChargeResponsePaymentMethod:
+    def from_dict(cls, obj: dict) -> Self:
         return cls.from_json(json.dumps(obj))
 
     @classmethod
-    def from_json(cls, json_str: str) -> ChargeResponsePaymentMethod:
+    def from_json(cls, json_str: str) -> Self:
         """Returns the object represented by the json string"""
-        instance = ChargeResponsePaymentMethod.construct()
+        instance = cls.model_construct()
         error_messages = []
         match = 0
 
         # use oneOf discriminator to lookup the data type
         _data_type = json.loads(json_str).get("object")
         if not _data_type:
             raise ValueError("Failed to lookup data type from the field `object` in the input.")
@@ -168,23 +175,24 @@
 
         to_json = getattr(self.actual_instance, "to_json", None)
         if callable(to_json):
             return self.actual_instance.to_json()
         else:
             return json.dumps(self.actual_instance)
 
-    def to_dict(self) -> dict:
+    def to_dict(self) -> Dict:
         """Returns the dict representation of the actual instance"""
         if self.actual_instance is None:
             return None
 
         to_dict = getattr(self.actual_instance, "to_dict", None)
         if callable(to_dict):
             return self.actual_instance.to_dict()
         else:
             # primitive type
             return self.actual_instance
 
     def to_str(self) -> str:
         """Returns the string representation of the actual instance"""
-        return pprint.pformat(self.dict())
+        return pprint.pformat(self.model_dump())
+
```

### Comparing `conekta-6.0.1/conekta/models/charge_response_refunds.py` & `conekta-6.0.2/conekta/models/charge_response_refunds.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,97 +1,115 @@
 # coding: utf-8
 
 """
     Conekta API
 
-    Conekta sdk  # noqa: E501
+    Conekta sdk
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
-"""
+"""  # noqa: E501
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
 
-from typing import List, Optional
-from pydantic import BaseModel, Field, StrictBool, StrictStr, conlist
+from typing import Any, ClassVar, Dict, List, Optional
+from pydantic import BaseModel, StrictBool, StrictStr
+from pydantic import Field
 from conekta.models.charge_response_refunds_data import ChargeResponseRefundsData
+try:
+    from typing import Self
+except ImportError:
+    from typing_extensions import Self
 
 class ChargeResponseRefunds(BaseModel):
     """
     ChargeResponseRefunds
-    """
-    has_more: StrictBool = Field(..., description="Indicates if there are more pages to be requested")
-    object: StrictStr = Field(..., description="Object type, in this case is list")
-    next_page_url: Optional[StrictStr] = Field(None, description="URL of the next page.")
-    previous_page_url: Optional[StrictStr] = Field(None, description="Url of the previous page.")
-    data: Optional[conlist(ChargeResponseRefundsData)] = Field(None, description="refunds")
-    __properties = ["has_more", "object", "next_page_url", "previous_page_url", "data"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    """ # noqa: E501
+    has_more: StrictBool = Field(description="Indicates if there are more pages to be requested")
+    object: StrictStr = Field(description="Object type, in this case is list")
+    next_page_url: Optional[StrictStr] = Field(default=None, description="URL of the next page.")
+    previous_page_url: Optional[StrictStr] = Field(default=None, description="Url of the previous page.")
+    data: Optional[List[ChargeResponseRefundsData]] = Field(default=None, description="refunds")
+    __properties: ClassVar[List[str]] = ["has_more", "object", "next_page_url", "previous_page_url", "data"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> ChargeResponseRefunds:
+    def from_json(cls, json_str: str) -> Self:
         """Create an instance of ChargeResponseRefunds from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude={
+            },
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of each item in data (list)
         _items = []
         if self.data:
             for _item in self.data:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['data'] = _items
         # set to None if next_page_url (nullable) is None
-        # and __fields_set__ contains the field
-        if self.next_page_url is None and "next_page_url" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.next_page_url is None and "next_page_url" in self.model_fields_set:
             _dict['next_page_url'] = None
 
         # set to None if previous_page_url (nullable) is None
-        # and __fields_set__ contains the field
-        if self.previous_page_url is None and "previous_page_url" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.previous_page_url is None and "previous_page_url" in self.model_fields_set:
             _dict['previous_page_url'] = None
 
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> ChargeResponseRefunds:
+    def from_dict(cls, obj: Dict) -> Self:
         """Create an instance of ChargeResponseRefunds from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return ChargeResponseRefunds.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = ChargeResponseRefunds.parse_obj({
+        _obj = cls.model_validate({
             "has_more": obj.get("has_more"),
             "object": obj.get("object"),
             "next_page_url": obj.get("next_page_url"),
             "previous_page_url": obj.get("previous_page_url"),
             "data": [ChargeResponseRefundsData.from_dict(_item) for _item in obj.get("data")] if obj.get("data") is not None else None
         })
         return _obj
 
+
```

### Comparing `conekta-6.0.1/conekta/models/charge_response_refunds_all_of.py` & `conekta-6.0.2/conekta/models/order_next_action_response.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,79 +1,95 @@
 # coding: utf-8
 
 """
     Conekta API
 
-    Conekta sdk  # noqa: E501
+    Conekta sdk
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
-"""
+"""  # noqa: E501
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
 
-from typing import List, Optional
-from pydantic import BaseModel, Field, conlist
-from conekta.models.charge_response_refunds_data import ChargeResponseRefundsData
+from typing import Any, ClassVar, Dict, List, Optional
+from pydantic import BaseModel, StrictStr
+from pydantic import Field
+from conekta.models.order_next_action_response_redirect_to_url import OrderNextActionResponseRedirectToUrl
+try:
+    from typing import Self
+except ImportError:
+    from typing_extensions import Self
 
-class ChargeResponseRefundsAllOf(BaseModel):
-    """
-    ChargeResponseRefundsAllOf
+class OrderNextActionResponse(BaseModel):
     """
-    data: Optional[conlist(ChargeResponseRefundsData)] = Field(None, description="refunds")
-    __properties = ["data"]
+    contains the following attributes that will guide to continue the flow
+    """ # noqa: E501
+    redirect_to_url: Optional[OrderNextActionResponseRedirectToUrl] = None
+    type: Optional[StrictStr] = Field(default=None, description="Indicates the type of action to be taken")
+    __properties: ClassVar[List[str]] = ["redirect_to_url", "type"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True
+    }
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> ChargeResponseRefundsAllOf:
-        """Create an instance of ChargeResponseRefundsAllOf from a JSON string"""
+    def from_json(cls, json_str: str) -> Self:
+        """Create an instance of OrderNextActionResponse from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
-        # override the default output from pydantic by calling `to_dict()` of each item in data (list)
-        _items = []
-        if self.data:
-            for _item in self.data:
-                if _item:
-                    _items.append(_item.to_dict())
-            _dict['data'] = _items
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude={
+            },
+            exclude_none=True,
+        )
+        # override the default output from pydantic by calling `to_dict()` of redirect_to_url
+        if self.redirect_to_url:
+            _dict['redirect_to_url'] = self.redirect_to_url.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> ChargeResponseRefundsAllOf:
-        """Create an instance of ChargeResponseRefundsAllOf from a dict"""
+    def from_dict(cls, obj: Dict) -> Self:
+        """Create an instance of OrderNextActionResponse from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return ChargeResponseRefundsAllOf.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = ChargeResponseRefundsAllOf.parse_obj({
-            "data": [ChargeResponseRefundsData.from_dict(_item) for _item in obj.get("data")] if obj.get("data") is not None else None
+        _obj = cls.model_validate({
+            "redirect_to_url": OrderNextActionResponseRedirectToUrl.from_dict(obj.get("redirect_to_url")) if obj.get("redirect_to_url") is not None else None,
+            "type": obj.get("type")
         })
         return _obj
 
+
```

### Comparing `conekta-6.0.1/conekta/models/charge_response_refunds_data.py` & `conekta-6.0.2/conekta/models/whitelistlist_rule_response.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,83 +1,95 @@
 # coding: utf-8
 
 """
     Conekta API
 
-    Conekta sdk  # noqa: E501
+    Conekta sdk
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
-"""
+"""  # noqa: E501
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
 
-from typing import Optional
-from pydantic import BaseModel, Field, StrictInt, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from pydantic import BaseModel, StrictStr
+from pydantic import Field
+try:
+    from typing import Self
+except ImportError:
+    from typing_extensions import Self
 
-class ChargeResponseRefundsData(BaseModel):
-    """
-    ChargeResponseRefundsData
+class WhitelistlistRuleResponse(BaseModel):
     """
-    amount: StrictInt = Field(...)
-    auth_code: Optional[StrictStr] = None
-    created_at: StrictInt = Field(...)
-    expires_at: Optional[StrictInt] = Field(None, description="refund expiration date")
-    id: StrictStr = Field(...)
-    object: StrictStr = Field(...)
-    status: Optional[StrictStr] = Field(None, description="refund status")
-    __properties = ["amount", "auth_code", "created_at", "expires_at", "id", "object", "status"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    WhitelistlistRuleResponse
+    """ # noqa: E501
+    id: Optional[StrictStr] = Field(default=None, description="Whitelist rule id")
+    field: Optional[StrictStr] = Field(default=None, description="field used for whitelists rule")
+    value: Optional[StrictStr] = Field(default=None, description="value used for whitelists rule")
+    description: Optional[StrictStr] = Field(default=None, description="use an description for whitelisted rule")
+    __properties: ClassVar[List[str]] = ["id", "field", "value", "description"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> ChargeResponseRefundsData:
-        """Create an instance of ChargeResponseRefundsData from a JSON string"""
+    def from_json(cls, json_str: str) -> Self:
+        """Create an instance of WhitelistlistRuleResponse from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude={
+            },
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> ChargeResponseRefundsData:
-        """Create an instance of ChargeResponseRefundsData from a dict"""
+    def from_dict(cls, obj: Dict) -> Self:
+        """Create an instance of WhitelistlistRuleResponse from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return ChargeResponseRefundsData.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = ChargeResponseRefundsData.parse_obj({
-            "amount": obj.get("amount"),
-            "auth_code": obj.get("auth_code"),
-            "created_at": obj.get("created_at"),
-            "expires_at": obj.get("expires_at"),
+        _obj = cls.model_validate({
             "id": obj.get("id"),
-            "object": obj.get("object"),
-            "status": obj.get("status")
+            "field": obj.get("field"),
+            "value": obj.get("value"),
+            "description": obj.get("description")
         })
         return _obj
 
+
```

### Comparing `conekta-6.0.1/conekta/models/charges_data_response.py` & `conekta-6.0.2/conekta/models/order_response_checkout.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,134 +1,143 @@
 # coding: utf-8
 
 """
     Conekta API
 
-    Conekta sdk  # noqa: E501
+    Conekta sdk
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
-"""
+"""  # noqa: E501
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
 
-from typing import Optional
-from pydantic import BaseModel, Field, StrictBool, StrictInt, StrictStr
-from conekta.models.charge_response_channel import ChargeResponseChannel
-from conekta.models.charge_response_payment_method import ChargeResponsePaymentMethod
-from conekta.models.charge_response_refunds import ChargeResponseRefunds
+from typing import Any, ClassVar, Dict, List, Optional, Union
+from pydantic import BaseModel, StrictBool, StrictInt, StrictStr
+try:
+    from typing import Self
+except ImportError:
+    from typing_extensions import Self
 
-class ChargesDataResponse(BaseModel):
-    """
-    ChargesDataResponse
+class OrderResponseCheckout(BaseModel):
     """
-    amount: Optional[StrictInt] = None
-    channel: Optional[ChargeResponseChannel] = None
-    created_at: Optional[StrictInt] = None
-    currency: Optional[StrictStr] = None
-    customer_id: Optional[StrictStr] = None
-    description: Optional[StrictStr] = None
-    device_fingerprint: Optional[StrictStr] = None
-    failure_code: Optional[StrictStr] = None
-    failure_message: Optional[StrictStr] = None
-    fee: Optional[StrictInt] = None
+    OrderResponseCheckout
+    """ # noqa: E501
+    allowed_payment_methods: Optional[List[StrictStr]] = None
+    can_not_expire: Optional[StrictBool] = None
+    emails_sent: Optional[StrictInt] = None
+    exclude_card_networks: Optional[List[Union[str, Any]]] = None
+    expires_at: Optional[StrictInt] = None
+    failure_url: Optional[StrictStr] = None
+    force_3ds_flow: Optional[StrictBool] = None
     id: Optional[StrictStr] = None
+    is_redirect_on_failure: Optional[StrictBool] = None
     livemode: Optional[StrictBool] = None
+    metadata: Optional[Dict[str, Any]] = None
+    monthly_installments_enabled: Optional[StrictBool] = None
+    monthly_installments_options: Optional[List[StrictInt]] = None
+    name: Optional[StrictStr] = None
+    needs_shipping_contact: Optional[StrictBool] = None
     object: Optional[StrictStr] = None
-    order_id: Optional[StrictStr] = None
-    paid_at: Optional[StrictInt] = None
-    payment_method: Optional[ChargeResponsePaymentMethod] = None
-    reference_id: Optional[StrictStr] = Field(None, description="Reference ID of the charge")
-    refunds: Optional[ChargeResponseRefunds] = None
+    on_demand_enabled: Optional[StrictBool] = None
+    paid_payments_count: Optional[StrictInt] = None
+    recurrent: Optional[StrictBool] = None
+    slug: Optional[StrictStr] = None
+    sms_sent: Optional[StrictInt] = None
+    success_url: Optional[StrictStr] = None
+    starts_at: Optional[StrictInt] = None
     status: Optional[StrictStr] = None
-    __properties = ["amount", "channel", "created_at", "currency", "customer_id", "description", "device_fingerprint", "failure_code", "failure_message", "fee", "id", "livemode", "object", "order_id", "paid_at", "payment_method", "reference_id", "refunds", "status"]
+    type: Optional[StrictStr] = None
+    url: Optional[StrictStr] = None
+    __properties: ClassVar[List[str]] = ["allowed_payment_methods", "can_not_expire", "emails_sent", "exclude_card_networks", "expires_at", "failure_url", "force_3ds_flow", "id", "is_redirect_on_failure", "livemode", "metadata", "monthly_installments_enabled", "monthly_installments_options", "name", "needs_shipping_contact", "object", "on_demand_enabled", "paid_payments_count", "recurrent", "slug", "sms_sent", "success_url", "starts_at", "status", "type", "url"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True
+    }
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> ChargesDataResponse:
-        """Create an instance of ChargesDataResponse from a JSON string"""
+    def from_json(cls, json_str: str) -> Self:
+        """Create an instance of OrderResponseCheckout from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
-        # override the default output from pydantic by calling `to_dict()` of channel
-        if self.channel:
-            _dict['channel'] = self.channel.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of payment_method
-        if self.payment_method:
-            _dict['payment_method'] = self.payment_method.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of refunds
-        if self.refunds:
-            _dict['refunds'] = self.refunds.to_dict()
-        # set to None if paid_at (nullable) is None
-        # and __fields_set__ contains the field
-        if self.paid_at is None and "paid_at" in self.__fields_set__:
-            _dict['paid_at'] = None
-
-        # set to None if reference_id (nullable) is None
-        # and __fields_set__ contains the field
-        if self.reference_id is None and "reference_id" in self.__fields_set__:
-            _dict['reference_id'] = None
-
-        # set to None if refunds (nullable) is None
-        # and __fields_set__ contains the field
-        if self.refunds is None and "refunds" in self.__fields_set__:
-            _dict['refunds'] = None
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude={
+            },
+            exclude_none=True,
+        )
+        # set to None if on_demand_enabled (nullable) is None
+        # and model_fields_set contains the field
+        if self.on_demand_enabled is None and "on_demand_enabled" in self.model_fields_set:
+            _dict['on_demand_enabled'] = None
 
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> ChargesDataResponse:
-        """Create an instance of ChargesDataResponse from a dict"""
+    def from_dict(cls, obj: Dict) -> Self:
+        """Create an instance of OrderResponseCheckout from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return ChargesDataResponse.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = ChargesDataResponse.parse_obj({
-            "amount": obj.get("amount"),
-            "channel": ChargeResponseChannel.from_dict(obj.get("channel")) if obj.get("channel") is not None else None,
-            "created_at": obj.get("created_at"),
-            "currency": obj.get("currency"),
-            "customer_id": obj.get("customer_id"),
-            "description": obj.get("description"),
-            "device_fingerprint": obj.get("device_fingerprint"),
-            "failure_code": obj.get("failure_code"),
-            "failure_message": obj.get("failure_message"),
-            "fee": obj.get("fee"),
+        _obj = cls.model_validate({
+            "allowed_payment_methods": obj.get("allowed_payment_methods"),
+            "can_not_expire": obj.get("can_not_expire"),
+            "emails_sent": obj.get("emails_sent"),
+            "exclude_card_networks": obj.get("exclude_card_networks"),
+            "expires_at": obj.get("expires_at"),
+            "failure_url": obj.get("failure_url"),
+            "force_3ds_flow": obj.get("force_3ds_flow"),
             "id": obj.get("id"),
+            "is_redirect_on_failure": obj.get("is_redirect_on_failure"),
             "livemode": obj.get("livemode"),
+            "metadata": obj.get("metadata"),
+            "monthly_installments_enabled": obj.get("monthly_installments_enabled"),
+            "monthly_installments_options": obj.get("monthly_installments_options"),
+            "name": obj.get("name"),
+            "needs_shipping_contact": obj.get("needs_shipping_contact"),
             "object": obj.get("object"),
-            "order_id": obj.get("order_id"),
-            "paid_at": obj.get("paid_at"),
-            "payment_method": ChargeResponsePaymentMethod.from_dict(obj.get("payment_method")) if obj.get("payment_method") is not None else None,
-            "reference_id": obj.get("reference_id"),
-            "refunds": ChargeResponseRefunds.from_dict(obj.get("refunds")) if obj.get("refunds") is not None else None,
-            "status": obj.get("status")
+            "on_demand_enabled": obj.get("on_demand_enabled"),
+            "paid_payments_count": obj.get("paid_payments_count"),
+            "recurrent": obj.get("recurrent"),
+            "slug": obj.get("slug"),
+            "sms_sent": obj.get("sms_sent"),
+            "success_url": obj.get("success_url"),
+            "starts_at": obj.get("starts_at"),
+            "status": obj.get("status"),
+            "type": obj.get("type"),
+            "url": obj.get("url")
         })
         return _obj
 
+
```

### Comparing `conekta-6.0.1/conekta/models/checkout.py` & `conekta-6.0.2/conekta/models/checkout_request.py`

 * *Files 21% similar despite different names*

```diff
@@ -1,100 +1,105 @@
 # coding: utf-8
 
 """
     Conekta API
 
-    Conekta sdk  # noqa: E501
+    Conekta sdk
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
-"""
+"""  # noqa: E501
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
 
-from typing import List, Optional
-from pydantic import BaseModel, Field, StrictBool, StrictInt, StrictStr, conlist
-from conekta.models.checkout_order_template import CheckoutOrderTemplate
+from typing import Any, ClassVar, Dict, List, Optional
+from pydantic import BaseModel, StrictBool, StrictInt, StrictStr
+from pydantic import Field
+try:
+    from typing import Self
+except ImportError:
+    from typing_extensions import Self
 
-class Checkout(BaseModel):
-    """
-    It is a sub-resource of the Order model that can be stipulated in order to configure its corresponding checkout
+class CheckoutRequest(BaseModel):
     """
-    allowed_payment_methods: conlist(StrictStr) = Field(..., description="Those are the payment methods that will be available for the link")
-    expires_at: StrictInt = Field(..., description="It is the time when the link will expire. It is expressed in seconds since the Unix epoch. The valid range is from 2 to 365 days (the valid range will be taken from the next day of the creation date at 00:01 hrs) ")
-    monthly_installments_enabled: Optional[StrictBool] = Field(None, description="This flag allows you to specify if months without interest will be active.")
-    monthly_installments_options: Optional[conlist(StrictInt)] = Field(None, description="This field allows you to specify the number of months without interest.")
-    name: StrictStr = Field(..., description="Reason for charge")
-    needs_shipping_contact: Optional[StrictBool] = Field(None, description="This flag allows you to fill in the shipping information at checkout.")
-    on_demand_enabled: Optional[StrictBool] = Field(None, description="This flag allows you to specify if the link will be on demand.")
-    order_template: CheckoutOrderTemplate = Field(...)
-    payments_limit_count: Optional[StrictInt] = Field(None, description="It is the number of payments that can be made through the link.")
-    recurrent: StrictBool = Field(..., description="false: single use. true: multiple payments")
-    type: StrictStr = Field(..., description="It is the type of link that will be created. It must be a valid type.")
-    __properties = ["allowed_payment_methods", "expires_at", "monthly_installments_enabled", "monthly_installments_options", "name", "needs_shipping_contact", "on_demand_enabled", "order_template", "payments_limit_count", "recurrent", "type"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    [Checkout](https://developers.conekta.com/v2.1.0/reference/payment-link) details 
+    """ # noqa: E501
+    allowed_payment_methods: List[StrictStr] = Field(description="Are the payment methods available for this link")
+    expires_at: Optional[StrictInt] = Field(default=None, description="Unix timestamp of checkout expiration")
+    failure_url: Optional[StrictStr] = Field(default=None, description="Redirection url back to the site in case of failed payment, applies only to HostedPayment.")
+    monthly_installments_enabled: Optional[StrictBool] = None
+    monthly_installments_options: Optional[List[StrictInt]] = None
+    name: Optional[StrictStr] = Field(default=None, description="Reason for payment")
+    on_demand_enabled: Optional[StrictBool] = None
+    success_url: Optional[StrictStr] = Field(default=None, description="Redirection url back to the site in case of successful payment, applies only to HostedPayment")
+    type: Optional[StrictStr] = Field(default=None, description="This field represents the type of checkout")
+    __properties: ClassVar[List[str]] = ["allowed_payment_methods", "expires_at", "failure_url", "monthly_installments_enabled", "monthly_installments_options", "name", "on_demand_enabled", "success_url", "type"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> Checkout:
-        """Create an instance of Checkout from a JSON string"""
+    def from_json(cls, json_str: str) -> Self:
+        """Create an instance of CheckoutRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
-        # override the default output from pydantic by calling `to_dict()` of order_template
-        if self.order_template:
-            _dict['order_template'] = self.order_template.to_dict()
-        # set to None if on_demand_enabled (nullable) is None
-        # and __fields_set__ contains the field
-        if self.on_demand_enabled is None and "on_demand_enabled" in self.__fields_set__:
-            _dict['on_demand_enabled'] = None
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
 
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude={
+            },
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> Checkout:
-        """Create an instance of Checkout from a dict"""
+    def from_dict(cls, obj: Dict) -> Self:
+        """Create an instance of CheckoutRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return Checkout.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = Checkout.parse_obj({
+        _obj = cls.model_validate({
             "allowed_payment_methods": obj.get("allowed_payment_methods"),
             "expires_at": obj.get("expires_at"),
+            "failure_url": obj.get("failure_url"),
             "monthly_installments_enabled": obj.get("monthly_installments_enabled"),
             "monthly_installments_options": obj.get("monthly_installments_options"),
             "name": obj.get("name"),
-            "needs_shipping_contact": obj.get("needs_shipping_contact"),
             "on_demand_enabled": obj.get("on_demand_enabled"),
-            "order_template": CheckoutOrderTemplate.from_dict(obj.get("order_template")) if obj.get("order_template") is not None else None,
-            "payments_limit_count": obj.get("payments_limit_count"),
-            "recurrent": obj.get("recurrent"),
+            "success_url": obj.get("success_url"),
             "type": obj.get("type")
         })
         return _obj
 
+
```

### Comparing `conekta-6.0.1/conekta/models/checkout_order_template.py` & `conekta-6.0.2/conekta/models/create_customer_fiscal_entities_response.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,89 +1,112 @@
 # coding: utf-8
 
 """
     Conekta API
 
-    Conekta sdk  # noqa: E501
+    Conekta sdk
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
-"""
+"""  # noqa: E501
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
 
-from typing import Any, Dict, List, Optional
-from pydantic import BaseModel, Field, conlist, constr
-from conekta.models.checkout_order_template_customer_info import CheckoutOrderTemplateCustomerInfo
-from conekta.models.product import Product
+from typing import Any, ClassVar, Dict, List, Optional, Union
+from pydantic import BaseModel, StrictBool, StrictInt, StrictStr
+from conekta.models.customer_fiscal_entities_request_address import CustomerFiscalEntitiesRequestAddress
+try:
+    from typing import Self
+except ImportError:
+    from typing_extensions import Self
 
-class CheckoutOrderTemplate(BaseModel):
-    """
-    It maintains the attributes with which the order will be created when receiving a new payment.
+class CreateCustomerFiscalEntitiesResponse(BaseModel):
     """
-    currency: constr(strict=True, max_length=3) = Field(..., description="It is the currency in which the order will be created. It must be a valid ISO 4217 currency code.")
-    customer_info: Optional[CheckoutOrderTemplateCustomerInfo] = None
-    line_items: conlist(Product) = Field(..., description="They are the products to buy. Each contains the \"unit price\" and \"quantity\" parameters that are used to calculate the total amount of the order.")
-    metadata: Optional[Dict[str, Any]] = Field(None, description="It is a set of key-value pairs that you can attach to the order. It can be used to store additional information about the order in a structured format.")
-    __properties = ["currency", "customer_info", "line_items", "metadata"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    CreateCustomerFiscalEntitiesResponse
+    """ # noqa: E501
+    address: CustomerFiscalEntitiesRequestAddress
+    tax_id: Optional[StrictStr] = None
+    email: Optional[StrictStr] = None
+    phone: Optional[StrictStr] = None
+    metadata: Optional[Dict[str, Union[str, Any]]] = None
+    company_name: Optional[StrictStr] = None
+    id: StrictStr
+    object: StrictStr
+    created_at: StrictInt
+    parent_id: Optional[StrictStr] = None
+    default: Optional[StrictBool] = None
+    __properties: ClassVar[List[str]] = ["address", "tax_id", "email", "phone", "metadata", "company_name", "id", "object", "created_at", "parent_id", "default"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> CheckoutOrderTemplate:
-        """Create an instance of CheckoutOrderTemplate from a JSON string"""
+    def from_json(cls, json_str: str) -> Self:
+        """Create an instance of CreateCustomerFiscalEntitiesResponse from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
-        # override the default output from pydantic by calling `to_dict()` of customer_info
-        if self.customer_info:
-            _dict['customer_info'] = self.customer_info.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of each item in line_items (list)
-        _items = []
-        if self.line_items:
-            for _item in self.line_items:
-                if _item:
-                    _items.append(_item.to_dict())
-            _dict['line_items'] = _items
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude={
+            },
+            exclude_none=True,
+        )
+        # override the default output from pydantic by calling `to_dict()` of address
+        if self.address:
+            _dict['address'] = self.address.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> CheckoutOrderTemplate:
-        """Create an instance of CheckoutOrderTemplate from a dict"""
+    def from_dict(cls, obj: Dict) -> Self:
+        """Create an instance of CreateCustomerFiscalEntitiesResponse from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return CheckoutOrderTemplate.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = CheckoutOrderTemplate.parse_obj({
-            "currency": obj.get("currency"),
-            "customer_info": CheckoutOrderTemplateCustomerInfo.from_dict(obj.get("customer_info")) if obj.get("customer_info") is not None else None,
-            "line_items": [Product.from_dict(_item) for _item in obj.get("line_items")] if obj.get("line_items") is not None else None,
-            "metadata": obj.get("metadata")
+        _obj = cls.model_validate({
+            "address": CustomerFiscalEntitiesRequestAddress.from_dict(obj.get("address")) if obj.get("address") is not None else None,
+            "tax_id": obj.get("tax_id"),
+            "email": obj.get("email"),
+            "phone": obj.get("phone"),
+            "metadata": obj.get("metadata"),
+            "company_name": obj.get("company_name"),
+            "id": obj.get("id"),
+            "object": obj.get("object"),
+            "created_at": obj.get("created_at"),
+            "parent_id": obj.get("parent_id"),
+            "default": obj.get("default")
         })
         return _obj
 
+
```

### Comparing `conekta-6.0.1/conekta/models/checkout_order_template_customer_info.py` & `conekta-6.0.2/conekta/models/order_update_request_customer_info.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,93 +1,100 @@
 # coding: utf-8
 
 """
     Conekta API
 
-    Conekta sdk  # noqa: E501
+    Conekta sdk
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
-"""
+"""  # noqa: E501
 
 
 from __future__ import annotations
 from inspect import getfullargspec
 import json
 import pprint
 import re  # noqa: F401
 
 from typing import Any, List, Optional
-from pydantic import BaseModel, Field, StrictStr, ValidationError, validator
+from pydantic import BaseModel, Field, StrictStr, ValidationError, field_validator
 from conekta.models.customer_info import CustomerInfo
 from conekta.models.customer_info_just_customer_id import CustomerInfoJustCustomerId
-from typing import Any, List
+from typing import Union, Any, List, TYPE_CHECKING, Optional, Dict
+from typing_extensions import Literal
 from pydantic import StrictStr, Field
+try:
+    from typing import Self
+except ImportError:
+    from typing_extensions import Self
 
-CHECKOUTORDERTEMPLATECUSTOMERINFO_ONE_OF_SCHEMAS = ["CustomerInfo", "CustomerInfoJustCustomerId"]
+ORDERUPDATEREQUESTCUSTOMERINFO_ONE_OF_SCHEMAS = ["CustomerInfo", "CustomerInfoJustCustomerId"]
 
-class CheckoutOrderTemplateCustomerInfo(BaseModel):
+class OrderUpdateRequestCustomerInfo(BaseModel):
     """
-    It is the information of the customer who will be created when receiving a new payment.
+    OrderUpdateRequestCustomerInfo
     """
     # data type: CustomerInfo
     oneof_schema_1_validator: Optional[CustomerInfo] = None
     # data type: CustomerInfoJustCustomerId
     oneof_schema_2_validator: Optional[CustomerInfoJustCustomerId] = None
-    actual_instance: Any
-    one_of_schemas: List[str] = Field(CHECKOUTORDERTEMPLATECUSTOMERINFO_ONE_OF_SCHEMAS, const=True)
+    actual_instance: Optional[Union[CustomerInfo, CustomerInfoJustCustomerId]] = None
+    one_of_schemas: List[str] = Literal["CustomerInfo", "CustomerInfoJustCustomerId"]
+
+    model_config = {
+        "validate_assignment": True
+    }
 
-    class Config:
-        validate_assignment = True
 
-    def __init__(self, *args, **kwargs):
+    def __init__(self, *args, **kwargs) -> None:
         if args:
             if len(args) > 1:
                 raise ValueError("If a position argument is used, only 1 is allowed to set `actual_instance`")
             if kwargs:
                 raise ValueError("If a position argument is used, keyword arguments cannot be used.")
             super().__init__(actual_instance=args[0])
         else:
             super().__init__(**kwargs)
 
-    @validator('actual_instance')
+    @field_validator('actual_instance')
     def actual_instance_must_validate_oneof(cls, v):
-        instance = CheckoutOrderTemplateCustomerInfo.construct()
+        instance = OrderUpdateRequestCustomerInfo.model_construct()
         error_messages = []
         match = 0
         # validate data type: CustomerInfo
         if not isinstance(v, CustomerInfo):
             error_messages.append(f"Error! Input type `{type(v)}` is not `CustomerInfo`")
         else:
             match += 1
         # validate data type: CustomerInfoJustCustomerId
         if not isinstance(v, CustomerInfoJustCustomerId):
             error_messages.append(f"Error! Input type `{type(v)}` is not `CustomerInfoJustCustomerId`")
         else:
             match += 1
         if match > 1:
             # more than 1 match
-            raise ValueError("Multiple matches found when setting `actual_instance` in CheckoutOrderTemplateCustomerInfo with oneOf schemas: CustomerInfo, CustomerInfoJustCustomerId. Details: " + ", ".join(error_messages))
+            raise ValueError("Multiple matches found when setting `actual_instance` in OrderUpdateRequestCustomerInfo with oneOf schemas: CustomerInfo, CustomerInfoJustCustomerId. Details: " + ", ".join(error_messages))
         elif match == 0:
             # no match
-            raise ValueError("No match found when setting `actual_instance` in CheckoutOrderTemplateCustomerInfo with oneOf schemas: CustomerInfo, CustomerInfoJustCustomerId. Details: " + ", ".join(error_messages))
+            raise ValueError("No match found when setting `actual_instance` in OrderUpdateRequestCustomerInfo with oneOf schemas: CustomerInfo, CustomerInfoJustCustomerId. Details: " + ", ".join(error_messages))
         else:
             return v
 
     @classmethod
-    def from_dict(cls, obj: dict) -> CheckoutOrderTemplateCustomerInfo:
+    def from_dict(cls, obj: dict) -> Self:
         return cls.from_json(json.dumps(obj))
 
     @classmethod
-    def from_json(cls, json_str: str) -> CheckoutOrderTemplateCustomerInfo:
+    def from_json(cls, json_str: str) -> Self:
         """Returns the object represented by the json string"""
-        instance = CheckoutOrderTemplateCustomerInfo.construct()
+        instance = cls.model_construct()
         error_messages = []
         match = 0
 
         # deserialize data into CustomerInfo
         try:
             instance.actual_instance = CustomerInfo.from_json(json_str)
             match += 1
@@ -98,41 +105,42 @@
             instance.actual_instance = CustomerInfoJustCustomerId.from_json(json_str)
             match += 1
         except (ValidationError, ValueError) as e:
             error_messages.append(str(e))
 
         if match > 1:
             # more than 1 match
-            raise ValueError("Multiple matches found when deserializing the JSON string into CheckoutOrderTemplateCustomerInfo with oneOf schemas: CustomerInfo, CustomerInfoJustCustomerId. Details: " + ", ".join(error_messages))
+            raise ValueError("Multiple matches found when deserializing the JSON string into OrderUpdateRequestCustomerInfo with oneOf schemas: CustomerInfo, CustomerInfoJustCustomerId. Details: " + ", ".join(error_messages))
         elif match == 0:
             # no match
-            raise ValueError("No match found when deserializing the JSON string into CheckoutOrderTemplateCustomerInfo with oneOf schemas: CustomerInfo, CustomerInfoJustCustomerId. Details: " + ", ".join(error_messages))
+            raise ValueError("No match found when deserializing the JSON string into OrderUpdateRequestCustomerInfo with oneOf schemas: CustomerInfo, CustomerInfoJustCustomerId. Details: " + ", ".join(error_messages))
         else:
             return instance
 
     def to_json(self) -> str:
         """Returns the JSON representation of the actual instance"""
         if self.actual_instance is None:
             return "null"
 
         to_json = getattr(self.actual_instance, "to_json", None)
         if callable(to_json):
             return self.actual_instance.to_json()
         else:
             return json.dumps(self.actual_instance)
 
-    def to_dict(self) -> dict:
+    def to_dict(self) -> Dict:
         """Returns the dict representation of the actual instance"""
         if self.actual_instance is None:
             return None
 
         to_dict = getattr(self.actual_instance, "to_dict", None)
         if callable(to_dict):
             return self.actual_instance.to_dict()
         else:
             # primitive type
             return self.actual_instance
 
     def to_str(self) -> str:
         """Returns the string representation of the actual instance"""
-        return pprint.pformat(self.dict())
+        return pprint.pformat(self.model_dump())
+
```

### Comparing `conekta-6.0.1/conekta/models/checkout_request.py` & `conekta-6.0.2/conekta/models/payment_method_card_response_all_of.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,87 +1,106 @@
 # coding: utf-8
 
 """
     Conekta API
 
-    Conekta sdk  # noqa: E501
+    Conekta sdk
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
-"""
+"""  # noqa: E501
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
 
-from typing import List, Optional
-from pydantic import BaseModel, Field, StrictBool, StrictInt, StrictStr, conlist
+from typing import Any, ClassVar, Dict, List, Optional
+from pydantic import BaseModel, StrictBool, StrictStr
+try:
+    from typing import Self
+except ImportError:
+    from typing_extensions import Self
 
-class CheckoutRequest(BaseModel):
-    """
-    [Checkout](https://developers.conekta.com/v2.1.0/reference/payment-link) details 
+class PaymentMethodCardResponseAllOf(BaseModel):
     """
-    allowed_payment_methods: conlist(StrictStr) = Field(..., description="Are the payment methods available for this link")
-    expires_at: Optional[StrictInt] = Field(None, description="Unix timestamp of checkout expiration")
-    failure_url: Optional[StrictStr] = Field(None, description="Redirection url back to the site in case of failed payment, applies only to HostedPayment.")
-    monthly_installments_enabled: Optional[StrictBool] = None
-    monthly_installments_options: Optional[conlist(StrictInt)] = None
-    name: Optional[StrictStr] = Field(None, description="Reason for payment")
-    on_demand_enabled: Optional[StrictBool] = None
-    success_url: Optional[StrictStr] = Field(None, description="Redirection url back to the site in case of successful payment, applies only to HostedPayment")
-    type: Optional[StrictStr] = Field(None, description="This field represents the type of checkout")
-    __properties = ["allowed_payment_methods", "expires_at", "failure_url", "monthly_installments_enabled", "monthly_installments_options", "name", "on_demand_enabled", "success_url", "type"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    use for card responses
+    """ # noqa: E501
+    last4: Optional[StrictStr] = None
+    bin: Optional[StrictStr] = None
+    card_type: Optional[StrictStr] = None
+    exp_month: Optional[StrictStr] = None
+    exp_year: Optional[StrictStr] = None
+    brand: Optional[StrictStr] = None
+    name: Optional[StrictStr] = None
+    default: Optional[StrictBool] = None
+    visible_on_checkout: Optional[StrictBool] = None
+    payment_source_status: Optional[StrictStr] = None
+    __properties: ClassVar[List[str]] = ["last4", "bin", "card_type", "exp_month", "exp_year", "brand", "name", "default", "visible_on_checkout", "payment_source_status"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> CheckoutRequest:
-        """Create an instance of CheckoutRequest from a JSON string"""
+    def from_json(cls, json_str: str) -> Self:
+        """Create an instance of PaymentMethodCardResponseAllOf from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude={
+            },
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> CheckoutRequest:
-        """Create an instance of CheckoutRequest from a dict"""
+    def from_dict(cls, obj: Dict) -> Self:
+        """Create an instance of PaymentMethodCardResponseAllOf from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return CheckoutRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = CheckoutRequest.parse_obj({
-            "allowed_payment_methods": obj.get("allowed_payment_methods"),
-            "expires_at": obj.get("expires_at"),
-            "failure_url": obj.get("failure_url"),
-            "monthly_installments_enabled": obj.get("monthly_installments_enabled"),
-            "monthly_installments_options": obj.get("monthly_installments_options"),
+        _obj = cls.model_validate({
+            "last4": obj.get("last4"),
+            "bin": obj.get("bin"),
+            "card_type": obj.get("card_type"),
+            "exp_month": obj.get("exp_month"),
+            "exp_year": obj.get("exp_year"),
+            "brand": obj.get("brand"),
             "name": obj.get("name"),
-            "on_demand_enabled": obj.get("on_demand_enabled"),
-            "success_url": obj.get("success_url"),
-            "type": obj.get("type")
+            "default": obj.get("default"),
+            "visible_on_checkout": obj.get("visible_on_checkout"),
+            "payment_source_status": obj.get("payment_source_status")
         })
         return _obj
 
+
```

### Comparing `conekta-6.0.1/conekta/models/checkout_response.py` & `conekta-6.0.2/conekta/models/checkout_response.py`

 * *Files 23% similar despite different names*

```diff
@@ -1,103 +1,120 @@
 # coding: utf-8
 
 """
     Conekta API
 
-    Conekta sdk  # noqa: E501
+    Conekta sdk
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
-"""
+"""  # noqa: E501
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
 
-from typing import Any, Dict, List, Optional
-from pydantic import BaseModel, Field, StrictBool, StrictInt, StrictStr, conlist
+from typing import Any, ClassVar, Dict, List, Optional, Union
+from pydantic import BaseModel, StrictBool, StrictInt, StrictStr
+from pydantic import Field
+try:
+    from typing import Self
+except ImportError:
+    from typing_extensions import Self
 
 class CheckoutResponse(BaseModel):
     """
     checkout response
-    """
-    allowed_payment_methods: Optional[conlist(StrictStr)] = None
+    """ # noqa: E501
+    allowed_payment_methods: Optional[List[StrictStr]] = None
     can_not_expire: Optional[StrictBool] = None
     emails_sent: Optional[StrictInt] = None
-    exclude_card_networks: Optional[conlist(Dict[str, Any])] = None
+    exclude_card_networks: Optional[List[Union[str, Any]]] = None
     expires_at: Optional[StrictInt] = None
     failure_url: Optional[StrictStr] = None
     force_3ds_flow: Optional[StrictBool] = None
-    id: StrictStr = Field(...)
-    livemode: StrictBool = Field(...)
+    id: StrictStr
+    livemode: StrictBool
     metadata: Optional[Dict[str, Any]] = None
     monthly_installments_enabled: Optional[StrictBool] = None
-    monthly_installments_options: Optional[conlist(StrictInt)] = None
-    name: StrictStr = Field(..., description="Reason for charge")
+    monthly_installments_options: Optional[List[StrictInt]] = None
+    name: StrictStr = Field(description="Reason for charge")
     needs_shipping_contact: Optional[StrictBool] = None
-    object: StrictStr = Field(...)
+    object: StrictStr
     paid_payments_count: Optional[StrictInt] = None
     payments_limit_count: Optional[StrictInt] = None
     recurrent: Optional[StrictBool] = None
     slug: Optional[StrictStr] = None
     sms_sent: Optional[StrictInt] = None
     starts_at: Optional[StrictInt] = None
     status: Optional[StrictStr] = None
     success_url: Optional[StrictStr] = None
     type: Optional[StrictStr] = None
     url: Optional[StrictStr] = None
-    __properties = ["allowed_payment_methods", "can_not_expire", "emails_sent", "exclude_card_networks", "expires_at", "failure_url", "force_3ds_flow", "id", "livemode", "metadata", "monthly_installments_enabled", "monthly_installments_options", "name", "needs_shipping_contact", "object", "paid_payments_count", "payments_limit_count", "recurrent", "slug", "sms_sent", "starts_at", "status", "success_url", "type", "url"]
+    __properties: ClassVar[List[str]] = ["allowed_payment_methods", "can_not_expire", "emails_sent", "exclude_card_networks", "expires_at", "failure_url", "force_3ds_flow", "id", "livemode", "metadata", "monthly_installments_enabled", "monthly_installments_options", "name", "needs_shipping_contact", "object", "paid_payments_count", "payments_limit_count", "recurrent", "slug", "sms_sent", "starts_at", "status", "success_url", "type", "url"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True
+    }
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> CheckoutResponse:
+    def from_json(cls, json_str: str) -> Self:
         """Create an instance of CheckoutResponse from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude={
+            },
+            exclude_none=True,
+        )
         # set to None if payments_limit_count (nullable) is None
-        # and __fields_set__ contains the field
-        if self.payments_limit_count is None and "payments_limit_count" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.payments_limit_count is None and "payments_limit_count" in self.model_fields_set:
             _dict['payments_limit_count'] = None
 
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> CheckoutResponse:
+    def from_dict(cls, obj: Dict) -> Self:
         """Create an instance of CheckoutResponse from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return CheckoutResponse.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = CheckoutResponse.parse_obj({
+        _obj = cls.model_validate({
             "allowed_payment_methods": obj.get("allowed_payment_methods"),
             "can_not_expire": obj.get("can_not_expire"),
             "emails_sent": obj.get("emails_sent"),
             "exclude_card_networks": obj.get("exclude_card_networks"),
             "expires_at": obj.get("expires_at"),
             "failure_url": obj.get("failure_url"),
             "force_3ds_flow": obj.get("force_3ds_flow"),
@@ -118,7 +135,8 @@
             "status": obj.get("status"),
             "success_url": obj.get("success_url"),
             "type": obj.get("type"),
             "url": obj.get("url")
         })
         return _obj
 
+
```

### Comparing `conekta-6.0.1/conekta/models/checkouts_response.py` & `conekta-6.0.2/conekta/models/subscription_events_response.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,97 +1,115 @@
 # coding: utf-8
 
 """
     Conekta API
 
-    Conekta sdk  # noqa: E501
+    Conekta sdk
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
-"""
+"""  # noqa: E501
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
 
-from typing import List, Optional
-from pydantic import BaseModel, Field, StrictBool, StrictStr, conlist
-from conekta.models.checkout_response import CheckoutResponse
+from typing import Any, ClassVar, Dict, List, Optional
+from pydantic import BaseModel, StrictBool, StrictStr
+from pydantic import Field
+from conekta.models.event_response import EventResponse
+try:
+    from typing import Self
+except ImportError:
+    from typing_extensions import Self
 
-class CheckoutsResponse(BaseModel):
-    """
-    CheckoutsResponse
+class SubscriptionEventsResponse(BaseModel):
     """
-    has_more: StrictBool = Field(..., description="Indicates if there are more pages to be requested")
-    object: StrictStr = Field(..., description="Object type, in this case is list")
-    next_page_url: Optional[StrictStr] = Field(None, description="URL of the next page.")
-    previous_page_url: Optional[StrictStr] = Field(None, description="Url of the previous page.")
-    data: Optional[conlist(CheckoutResponse)] = None
-    __properties = ["has_more", "object", "next_page_url", "previous_page_url", "data"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    SubscriptionEventsResponse
+    """ # noqa: E501
+    has_more: StrictBool = Field(description="Indicates if there are more pages to be requested")
+    object: StrictStr = Field(description="Object type, in this case is list")
+    next_page_url: Optional[StrictStr] = Field(default=None, description="URL of the next page.")
+    previous_page_url: Optional[StrictStr] = Field(default=None, description="Url of the previous page.")
+    data: Optional[List[EventResponse]] = None
+    __properties: ClassVar[List[str]] = ["has_more", "object", "next_page_url", "previous_page_url", "data"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> CheckoutsResponse:
-        """Create an instance of CheckoutsResponse from a JSON string"""
+    def from_json(cls, json_str: str) -> Self:
+        """Create an instance of SubscriptionEventsResponse from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude={
+            },
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of each item in data (list)
         _items = []
         if self.data:
             for _item in self.data:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['data'] = _items
         # set to None if next_page_url (nullable) is None
-        # and __fields_set__ contains the field
-        if self.next_page_url is None and "next_page_url" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.next_page_url is None and "next_page_url" in self.model_fields_set:
             _dict['next_page_url'] = None
 
         # set to None if previous_page_url (nullable) is None
-        # and __fields_set__ contains the field
-        if self.previous_page_url is None and "previous_page_url" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.previous_page_url is None and "previous_page_url" in self.model_fields_set:
             _dict['previous_page_url'] = None
 
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> CheckoutsResponse:
-        """Create an instance of CheckoutsResponse from a dict"""
+    def from_dict(cls, obj: Dict) -> Self:
+        """Create an instance of SubscriptionEventsResponse from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return CheckoutsResponse.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = CheckoutsResponse.parse_obj({
+        _obj = cls.model_validate({
             "has_more": obj.get("has_more"),
             "object": obj.get("object"),
             "next_page_url": obj.get("next_page_url"),
             "previous_page_url": obj.get("previous_page_url"),
-            "data": [CheckoutResponse.from_dict(_item) for _item in obj.get("data")] if obj.get("data") is not None else None
+            "data": [EventResponse.from_dict(_item) for _item in obj.get("data")] if obj.get("data") is not None else None
         })
         return _obj
 
+
```

### Comparing `conekta-6.0.1/conekta/models/checkouts_response_all_of.py` & `conekta-6.0.2/conekta/models/email_checkout_request.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,79 +1,88 @@
 # coding: utf-8
 
 """
     Conekta API
 
-    Conekta sdk  # noqa: E501
+    Conekta sdk
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
-"""
+"""  # noqa: E501
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
 
-from typing import List, Optional
-from pydantic import BaseModel, conlist
-from conekta.models.checkout_response import CheckoutResponse
+from typing import Any, ClassVar, Dict, List
+from pydantic import BaseModel, StrictStr
+try:
+    from typing import Self
+except ImportError:
+    from typing_extensions import Self
 
-class CheckoutsResponseAllOf(BaseModel):
-    """
-    CheckoutsResponseAllOf
+class EmailCheckoutRequest(BaseModel):
     """
-    data: Optional[conlist(CheckoutResponse)] = None
-    __properties = ["data"]
+    EmailCheckoutRequest
+    """ # noqa: E501
+    email: StrictStr
+    __properties: ClassVar[List[str]] = ["email"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True
+    }
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> CheckoutsResponseAllOf:
-        """Create an instance of CheckoutsResponseAllOf from a JSON string"""
+    def from_json(cls, json_str: str) -> Self:
+        """Create an instance of EmailCheckoutRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
-        # override the default output from pydantic by calling `to_dict()` of each item in data (list)
-        _items = []
-        if self.data:
-            for _item in self.data:
-                if _item:
-                    _items.append(_item.to_dict())
-            _dict['data'] = _items
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude={
+            },
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> CheckoutsResponseAllOf:
-        """Create an instance of CheckoutsResponseAllOf from a dict"""
+    def from_dict(cls, obj: Dict) -> Self:
+        """Create an instance of EmailCheckoutRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return CheckoutsResponseAllOf.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = CheckoutsResponseAllOf.parse_obj({
-            "data": [CheckoutResponse.from_dict(_item) for _item in obj.get("data")] if obj.get("data") is not None else None
+        _obj = cls.model_validate({
+            "email": obj.get("email")
         })
         return _obj
 
+
```

### Comparing `conekta-6.0.1/conekta/models/company_fiscal_info_address_response.py` & `conekta-6.0.2/conekta/models/customer_fiscal_entities_request.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,97 +1,102 @@
 # coding: utf-8
 
 """
     Conekta API
 
-    Conekta sdk  # noqa: E501
+    Conekta sdk
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
-"""
+"""  # noqa: E501
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
 
-from typing import Optional
-from pydantic import BaseModel, Field, StrictStr, validator
+from typing import Any, ClassVar, Dict, List, Optional, Union
+from pydantic import BaseModel, StrictStr
+from conekta.models.customer_fiscal_entities_request_address import CustomerFiscalEntitiesRequestAddress
+try:
+    from typing import Self
+except ImportError:
+    from typing_extensions import Self
 
-class CompanyFiscalInfoAddressResponse(BaseModel):
-    """
-    Company fiscal info address model
+class CustomerFiscalEntitiesRequest(BaseModel):
     """
-    object: Optional[StrictStr] = Field(None, description="The resource's type")
-    street1: Optional[StrictStr] = Field(None, description="Street Address")
-    street2: Optional[StrictStr] = Field(None, description="Colonia")
-    city: Optional[StrictStr] = Field(None, description="City")
-    state: Optional[StrictStr] = Field(None, description="State")
-    country: Optional[StrictStr] = Field(None, description="Country")
-    postal_code: Optional[StrictStr] = Field(None, description="Postal code")
-    external_number: Optional[StrictStr] = Field(None, description="Street number")
-    internal_number: Optional[StrictStr] = Field(None, description="Unit / apartment number")
-    __properties = ["object", "street1", "street2", "city", "state", "country", "postal_code", "external_number", "internal_number"]
-
-    @validator('object')
-    def object_validate_enum(cls, value):
-        """Validates the enum"""
-        if value is None:
-            return value
-
-        if value not in ('address'):
-            raise ValueError("must be one of enum values ('address')")
-        return value
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    CustomerFiscalEntitiesRequest
+    """ # noqa: E501
+    address: CustomerFiscalEntitiesRequestAddress
+    tax_id: Optional[StrictStr] = None
+    email: Optional[StrictStr] = None
+    phone: Optional[StrictStr] = None
+    metadata: Optional[Dict[str, Union[str, Any]]] = None
+    company_name: Optional[StrictStr] = None
+    __properties: ClassVar[List[str]] = ["address", "tax_id", "email", "phone", "metadata", "company_name"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> CompanyFiscalInfoAddressResponse:
-        """Create an instance of CompanyFiscalInfoAddressResponse from a JSON string"""
+    def from_json(cls, json_str: str) -> Self:
+        """Create an instance of CustomerFiscalEntitiesRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude={
+            },
+            exclude_none=True,
+        )
+        # override the default output from pydantic by calling `to_dict()` of address
+        if self.address:
+            _dict['address'] = self.address.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> CompanyFiscalInfoAddressResponse:
-        """Create an instance of CompanyFiscalInfoAddressResponse from a dict"""
+    def from_dict(cls, obj: Dict) -> Self:
+        """Create an instance of CustomerFiscalEntitiesRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return CompanyFiscalInfoAddressResponse.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = CompanyFiscalInfoAddressResponse.parse_obj({
-            "object": obj.get("object"),
-            "street1": obj.get("street1"),
-            "street2": obj.get("street2"),
-            "city": obj.get("city"),
-            "state": obj.get("state"),
-            "country": obj.get("country"),
-            "postal_code": obj.get("postal_code"),
-            "external_number": obj.get("external_number"),
-            "internal_number": obj.get("internal_number")
+        _obj = cls.model_validate({
+            "address": CustomerFiscalEntitiesRequestAddress.from_dict(obj.get("address")) if obj.get("address") is not None else None,
+            "tax_id": obj.get("tax_id"),
+            "email": obj.get("email"),
+            "phone": obj.get("phone"),
+            "metadata": obj.get("metadata"),
+            "company_name": obj.get("company_name")
         })
         return _obj
 
+
```

### Comparing `conekta-6.0.1/conekta/models/company_fiscal_info_response.py` & `conekta-6.0.2/conekta/models/company_fiscal_info_response.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,97 +1,115 @@
 # coding: utf-8
 
 """
     Conekta API
 
-    Conekta sdk  # noqa: E501
+    Conekta sdk
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
-"""
+"""  # noqa: E501
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
 
-from typing import Optional
-from pydantic import BaseModel, Field, StrictStr, validator
+from typing import Any, ClassVar, Dict, List, Optional
+from pydantic import BaseModel, StrictStr, field_validator
+from pydantic import Field
 from conekta.models.company_fiscal_info_address_response import CompanyFiscalInfoAddressResponse
+try:
+    from typing import Self
+except ImportError:
+    from typing_extensions import Self
 
 class CompanyFiscalInfoResponse(BaseModel):
     """
     Company fiscal info model
-    """
-    object: Optional[StrictStr] = Field(None, description="The resource's type")
-    tax_id: Optional[StrictStr] = Field(None, description="Tax ID of the company")
-    legal_entity_name: Optional[StrictStr] = Field(None, description="Legal name of the company")
-    business_type: Optional[StrictStr] = Field(None, description="Business type of the company")
-    phone: Optional[StrictStr] = Field(None, description="Phone number of the company")
-    physical_person_business_type: Optional[StrictStr] = Field(None, description="Business type if 'persona_fisica'")
+    """ # noqa: E501
+    object: Optional[StrictStr] = Field(default=None, description="The resource's type")
+    tax_id: Optional[StrictStr] = Field(default=None, description="Tax ID of the company")
+    legal_entity_name: Optional[StrictStr] = Field(default=None, description="Legal name of the company")
+    business_type: Optional[StrictStr] = Field(default=None, description="Business type of the company")
+    phone: Optional[StrictStr] = Field(default=None, description="Phone number of the company")
+    physical_person_business_type: Optional[StrictStr] = Field(default=None, description="Business type if 'persona_fisica'")
     address: Optional[CompanyFiscalInfoAddressResponse] = None
-    __properties = ["object", "tax_id", "legal_entity_name", "business_type", "phone", "physical_person_business_type", "address"]
+    __properties: ClassVar[List[str]] = ["object", "tax_id", "legal_entity_name", "business_type", "phone", "physical_person_business_type", "address"]
 
-    @validator('object')
+    @field_validator('object')
     def object_validate_enum(cls, value):
         """Validates the enum"""
         if value is None:
             return value
 
         if value not in ('fiscal_info'):
             raise ValueError("must be one of enum values ('fiscal_info')")
         return value
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> CompanyFiscalInfoResponse:
+    def from_json(cls, json_str: str) -> Self:
         """Create an instance of CompanyFiscalInfoResponse from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude={
+            },
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of address
         if self.address:
             _dict['address'] = self.address.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> CompanyFiscalInfoResponse:
+    def from_dict(cls, obj: Dict) -> Self:
         """Create an instance of CompanyFiscalInfoResponse from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return CompanyFiscalInfoResponse.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = CompanyFiscalInfoResponse.parse_obj({
+        _obj = cls.model_validate({
             "object": obj.get("object"),
             "tax_id": obj.get("tax_id"),
             "legal_entity_name": obj.get("legal_entity_name"),
             "business_type": obj.get("business_type"),
             "phone": obj.get("phone"),
             "physical_person_business_type": obj.get("physical_person_business_type"),
             "address": CompanyFiscalInfoAddressResponse.from_dict(obj.get("address")) if obj.get("address") is not None else None
         })
         return _obj
 
+
```

### Comparing `conekta-6.0.1/conekta/models/company_payout_destination_response.py` & `conekta-6.0.2/conekta/models/transfer_destination_response.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,101 +1,103 @@
 # coding: utf-8
 
 """
     Conekta API
 
-    Conekta sdk  # noqa: E501
+    Conekta sdk
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
-"""
+"""  # noqa: E501
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
 
-from typing import Optional
-from pydantic import BaseModel, Field, StrictStr, validator
+from typing import Any, ClassVar, Dict, List, Optional
+from pydantic import BaseModel, StrictInt, StrictStr
+from pydantic import Field
+try:
+    from typing import Self
+except ImportError:
+    from typing_extensions import Self
 
-class CompanyPayoutDestinationResponse(BaseModel):
-    """
-    Company payout destination model
+class TransferDestinationResponse(BaseModel):
     """
-    object: Optional[StrictStr] = Field(None, description="The resource's type")
-    currency: Optional[StrictStr] = Field(None, description="currency of the receiving account")
-    account_holder_name: Optional[StrictStr] = Field(None, description="Name of the account holder")
-    bank: Optional[StrictStr] = Field(None, description="Name of the bank")
-    type: Optional[StrictStr] = Field(None, description="Type of the payout destination")
-    account_number: Optional[StrictStr] = Field(None, description="Account number of the receiving account")
-    __properties = ["object", "currency", "account_holder_name", "bank", "type", "account_number"]
-
-    @validator('object')
-    def object_validate_enum(cls, value):
-        """Validates the enum"""
-        if value is None:
-            return value
-
-        if value not in ('payout_destination'):
-            raise ValueError("must be one of enum values ('payout_destination')")
-        return value
-
-    @validator('type')
-    def type_validate_enum(cls, value):
-        """Validates the enum"""
-        if value is None:
-            return value
-
-        if value not in ('bank_account'):
-            raise ValueError("must be one of enum values ('bank_account')")
-        return value
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    Method used to make the transfer.
+    """ # noqa: E501
+    account_holder: Optional[StrictStr] = Field(default=None, description="Name of the account holder.")
+    account_number: Optional[StrictStr] = Field(default=None, description="Account number of the bank account.")
+    bank: Optional[StrictStr] = Field(default=None, description="Name of the bank.")
+    created_at: Optional[StrictInt] = Field(default=None, description="Date and time of creation of the transfer.")
+    id: Optional[StrictStr] = Field(default=None, description="Unique identifier of the transfer.")
+    object: Optional[StrictStr] = Field(default=None, description="Object name, which is bank_transfer_payout_method.")
+    payee_id: Optional[StrictStr] = Field(default=None, description="Unique identifier of the payee.")
+    type: Optional[StrictStr] = Field(default=None, description="Type of the payee.")
+    __properties: ClassVar[List[str]] = ["account_holder", "account_number", "bank", "created_at", "id", "object", "payee_id", "type"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> CompanyPayoutDestinationResponse:
-        """Create an instance of CompanyPayoutDestinationResponse from a JSON string"""
+    def from_json(cls, json_str: str) -> Self:
+        """Create an instance of TransferDestinationResponse from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude={
+            },
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> CompanyPayoutDestinationResponse:
-        """Create an instance of CompanyPayoutDestinationResponse from a dict"""
+    def from_dict(cls, obj: Dict) -> Self:
+        """Create an instance of TransferDestinationResponse from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return CompanyPayoutDestinationResponse.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = CompanyPayoutDestinationResponse.parse_obj({
-            "object": obj.get("object"),
-            "currency": obj.get("currency"),
-            "account_holder_name": obj.get("account_holder_name"),
+        _obj = cls.model_validate({
+            "account_holder": obj.get("account_holder"),
+            "account_number": obj.get("account_number"),
             "bank": obj.get("bank"),
-            "type": obj.get("type"),
-            "account_number": obj.get("account_number")
+            "created_at": obj.get("created_at"),
+            "id": obj.get("id"),
+            "object": obj.get("object"),
+            "payee_id": obj.get("payee_id"),
+            "type": obj.get("type")
         })
         return _obj
 
+
```

### Comparing `conekta-6.0.1/conekta/models/company_response.py` & `conekta-6.0.2/conekta/models/product_data_response.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,103 +1,112 @@
 # coding: utf-8
 
 """
     Conekta API
 
-    Conekta sdk  # noqa: E501
+    Conekta sdk
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
-"""
+"""  # noqa: E501
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
 
-from typing import Optional
-from pydantic import BaseModel, Field, StrictBool, StrictInt, StrictStr, validator
-from conekta.models.company_fiscal_info_response import CompanyFiscalInfoResponse
-from conekta.models.company_payout_destination_response import CompanyPayoutDestinationResponse
+from typing import Any, ClassVar, Dict, List, Optional
+from pydantic import BaseModel, StrictStr
+from pydantic import Field
+from typing_extensions import Annotated
+try:
+    from typing import Self
+except ImportError:
+    from typing_extensions import Self
 
-class CompanyResponse(BaseModel):
-    """
-    Company model
+class ProductDataResponse(BaseModel):
     """
-    id: Optional[StrictStr] = Field(None, description="The child company's unique identifier")
-    created_at: Optional[StrictInt] = Field(None, description="The resource's creation date (unix timestamp)")
-    name: Optional[StrictStr] = Field(None, description="The child company's name")
-    object: Optional[StrictStr] = Field(None, description="The resource's type")
-    parent_company_id: Optional[StrictStr] = Field(None, description="Id of the parent company")
-    use_parent_fiscal_data: Optional[StrictBool] = Field(None, description="Whether the parent company's fiscal data is to be used for liquidation and tax purposes")
-    payout_destination: Optional[CompanyPayoutDestinationResponse] = None
-    fiscal_info: Optional[CompanyFiscalInfoResponse] = None
-    __properties = ["id", "created_at", "name", "object", "parent_company_id", "use_parent_fiscal_data", "payout_destination", "fiscal_info"]
-
-    @validator('object')
-    def object_validate_enum(cls, value):
-        """Validates the enum"""
-        if value is None:
-            return value
-
-        if value not in ('company'):
-            raise ValueError("must be one of enum values ('company')")
-        return value
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    ProductDataResponse
+    """ # noqa: E501
+    antifraud_info: Optional[Dict[str, Any]] = None
+    brand: Optional[StrictStr] = Field(default=None, description="The brand of the item.")
+    description: Optional[Annotated[str, Field(strict=True, max_length=250)]] = Field(default=None, description="Short description of the item")
+    metadata: Optional[Dict[str, StrictStr]] = Field(default=None, description="It is a key/value hash that can hold custom fields. Maximum 100 elements and allows special characters.")
+    name: StrictStr = Field(description="The name of the item. It will be displayed in the order.")
+    quantity: Annotated[int, Field(strict=True, ge=1)] = Field(description="The quantity of the item in the order.")
+    sku: Optional[StrictStr] = Field(default=None, description="The stock keeping unit for the item. It is used to identify the item in the order.")
+    tags: Optional[List[StrictStr]] = Field(default=None, description="List of tags for the item. It is used to identify the item in the order.")
+    unit_price: Annotated[int, Field(strict=True, ge=0)] = Field(description="The price of the item in cents.")
+    id: Optional[StrictStr] = None
+    object: Optional[StrictStr] = None
+    parent_id: Optional[StrictStr] = None
+    __properties: ClassVar[List[str]] = ["antifraud_info", "brand", "description", "metadata", "name", "quantity", "sku", "tags", "unit_price", "id", "object", "parent_id"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> CompanyResponse:
-        """Create an instance of CompanyResponse from a JSON string"""
+    def from_json(cls, json_str: str) -> Self:
+        """Create an instance of ProductDataResponse from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
-        # override the default output from pydantic by calling `to_dict()` of payout_destination
-        if self.payout_destination:
-            _dict['payout_destination'] = self.payout_destination.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of fiscal_info
-        if self.fiscal_info:
-            _dict['fiscal_info'] = self.fiscal_info.to_dict()
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude={
+            },
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> CompanyResponse:
-        """Create an instance of CompanyResponse from a dict"""
+    def from_dict(cls, obj: Dict) -> Self:
+        """Create an instance of ProductDataResponse from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return CompanyResponse.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = CompanyResponse.parse_obj({
-            "id": obj.get("id"),
-            "created_at": obj.get("created_at"),
+        _obj = cls.model_validate({
+            "antifraud_info": obj.get("antifraud_info"),
+            "brand": obj.get("brand"),
+            "description": obj.get("description"),
+            "metadata": obj.get("metadata"),
             "name": obj.get("name"),
+            "quantity": obj.get("quantity"),
+            "sku": obj.get("sku"),
+            "tags": obj.get("tags"),
+            "unit_price": obj.get("unit_price"),
+            "id": obj.get("id"),
             "object": obj.get("object"),
-            "parent_company_id": obj.get("parent_company_id"),
-            "use_parent_fiscal_data": obj.get("use_parent_fiscal_data"),
-            "payout_destination": CompanyPayoutDestinationResponse.from_dict(obj.get("payout_destination")) if obj.get("payout_destination") is not None else None,
-            "fiscal_info": CompanyFiscalInfoResponse.from_dict(obj.get("fiscal_info")) if obj.get("fiscal_info") is not None else None
+            "parent_id": obj.get("parent_id")
         })
         return _obj
 
+
```

### Comparing `conekta-6.0.1/conekta/models/create_customer_fiscal_entities_response.py` & `conekta-6.0.2/conekta/models/order_response_customer_info.py`

 * *Files 21% similar despite different names*

```diff
@@ -1,95 +1,106 @@
 # coding: utf-8
 
 """
     Conekta API
 
-    Conekta sdk  # noqa: E501
+    Conekta sdk
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
-"""
+"""  # noqa: E501
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
 
-from typing import Any, Dict, Optional
-from pydantic import BaseModel, Field, StrictBool, StrictInt, StrictStr
-from conekta.models.customer_fiscal_entities_request_address import CustomerFiscalEntitiesRequestAddress
+from typing import Any, ClassVar, Dict, List, Optional
+from pydantic import BaseModel, StrictBool, StrictStr
+from pydantic import Field
+try:
+    from typing import Self
+except ImportError:
+    from typing_extensions import Self
 
-class CreateCustomerFiscalEntitiesResponse(BaseModel):
-    """
-    CreateCustomerFiscalEntitiesResponse
+class OrderResponseCustomerInfo(BaseModel):
     """
-    address: CustomerFiscalEntitiesRequestAddress = Field(...)
-    tax_id: Optional[StrictStr] = None
+    OrderResponseCustomerInfo
+    """ # noqa: E501
+    object: Optional[StrictStr] = None
+    customer_custom_reference: Optional[StrictStr] = Field(default=None, description="Custom reference")
+    name: Optional[StrictStr] = None
     email: Optional[StrictStr] = None
     phone: Optional[StrictStr] = None
-    metadata: Optional[Dict[str, Dict[str, Any]]] = None
-    company_name: Optional[StrictStr] = None
-    id: StrictStr = Field(...)
-    object: StrictStr = Field(...)
-    created_at: StrictInt = Field(...)
-    parent_id: Optional[StrictStr] = None
-    default: Optional[StrictBool] = None
-    __properties = ["address", "tax_id", "email", "phone", "metadata", "company_name", "id", "object", "created_at", "parent_id", "default"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    corporate: Optional[StrictBool] = False
+    customer_id: Optional[StrictStr] = None
+    __properties: ClassVar[List[str]] = ["object", "customer_custom_reference", "name", "email", "phone", "corporate", "customer_id"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> CreateCustomerFiscalEntitiesResponse:
-        """Create an instance of CreateCustomerFiscalEntitiesResponse from a JSON string"""
+    def from_json(cls, json_str: str) -> Self:
+        """Create an instance of OrderResponseCustomerInfo from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
-        # override the default output from pydantic by calling `to_dict()` of address
-        if self.address:
-            _dict['address'] = self.address.to_dict()
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude={
+            },
+            exclude_none=True,
+        )
+        # set to None if customer_custom_reference (nullable) is None
+        # and model_fields_set contains the field
+        if self.customer_custom_reference is None and "customer_custom_reference" in self.model_fields_set:
+            _dict['customer_custom_reference'] = None
+
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> CreateCustomerFiscalEntitiesResponse:
-        """Create an instance of CreateCustomerFiscalEntitiesResponse from a dict"""
+    def from_dict(cls, obj: Dict) -> Self:
+        """Create an instance of OrderResponseCustomerInfo from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return CreateCustomerFiscalEntitiesResponse.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = CreateCustomerFiscalEntitiesResponse.parse_obj({
-            "address": CustomerFiscalEntitiesRequestAddress.from_dict(obj.get("address")) if obj.get("address") is not None else None,
-            "tax_id": obj.get("tax_id"),
+        _obj = cls.model_validate({
+            "object": obj.get("object"),
+            "customer_custom_reference": obj.get("customer_custom_reference"),
+            "name": obj.get("name"),
             "email": obj.get("email"),
             "phone": obj.get("phone"),
-            "metadata": obj.get("metadata"),
-            "company_name": obj.get("company_name"),
-            "id": obj.get("id"),
-            "object": obj.get("object"),
-            "created_at": obj.get("created_at"),
-            "parent_id": obj.get("parent_id"),
-            "default": obj.get("default")
+            "corporate": obj.get("corporate") if obj.get("corporate") is not None else False,
+            "customer_id": obj.get("customer_id")
         })
         return _obj
 
+
```

### Comparing `conekta-6.0.1/conekta/models/create_customer_payment_methods_request.py` & `conekta-6.0.2/conekta/models/create_customer_payment_methods_request.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,67 +1,74 @@
 # coding: utf-8
 
 """
     Conekta API
 
-    Conekta sdk  # noqa: E501
+    Conekta sdk
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
-"""
+"""  # noqa: E501
 
 
 from __future__ import annotations
 from inspect import getfullargspec
 import json
 import pprint
 import re  # noqa: F401
 
 from typing import Any, List, Optional
-from pydantic import BaseModel, Field, StrictStr, ValidationError, validator
+from pydantic import BaseModel, Field, StrictStr, ValidationError, field_validator
 from conekta.models.payment_method_card_request import PaymentMethodCardRequest
 from conekta.models.payment_method_cash_request import PaymentMethodCashRequest
 from conekta.models.payment_method_spei_request import PaymentMethodSpeiRequest
-from typing import Any, List
+from typing import Union, Any, List, TYPE_CHECKING, Optional, Dict
+from typing_extensions import Literal
 from pydantic import StrictStr, Field
+try:
+    from typing import Self
+except ImportError:
+    from typing_extensions import Self
 
 CREATECUSTOMERPAYMENTMETHODSREQUEST_ONE_OF_SCHEMAS = ["PaymentMethodCardRequest", "PaymentMethodCashRequest", "PaymentMethodSpeiRequest"]
 
 class CreateCustomerPaymentMethodsRequest(BaseModel):
     """
     Contains details of the payment methods that the customer has active or has used in Conekta
     """
     # data type: PaymentMethodCardRequest
     oneof_schema_1_validator: Optional[PaymentMethodCardRequest] = None
     # data type: PaymentMethodCashRequest
     oneof_schema_2_validator: Optional[PaymentMethodCashRequest] = None
     # data type: PaymentMethodSpeiRequest
     oneof_schema_3_validator: Optional[PaymentMethodSpeiRequest] = None
-    actual_instance: Any
-    one_of_schemas: List[str] = Field(CREATECUSTOMERPAYMENTMETHODSREQUEST_ONE_OF_SCHEMAS, const=True)
+    actual_instance: Optional[Union[PaymentMethodCardRequest, PaymentMethodCashRequest, PaymentMethodSpeiRequest]] = None
+    one_of_schemas: List[str] = Literal["PaymentMethodCardRequest", "PaymentMethodCashRequest", "PaymentMethodSpeiRequest"]
+
+    model_config = {
+        "validate_assignment": True
+    }
 
-    class Config:
-        validate_assignment = True
 
-    def __init__(self, *args, **kwargs):
+    def __init__(self, *args, **kwargs) -> None:
         if args:
             if len(args) > 1:
                 raise ValueError("If a position argument is used, only 1 is allowed to set `actual_instance`")
             if kwargs:
                 raise ValueError("If a position argument is used, keyword arguments cannot be used.")
             super().__init__(actual_instance=args[0])
         else:
             super().__init__(**kwargs)
 
-    @validator('actual_instance')
+    @field_validator('actual_instance')
     def actual_instance_must_validate_oneof(cls, v):
-        instance = CreateCustomerPaymentMethodsRequest.construct()
+        instance = CreateCustomerPaymentMethodsRequest.model_construct()
         error_messages = []
         match = 0
         # validate data type: PaymentMethodCardRequest
         if not isinstance(v, PaymentMethodCardRequest):
             error_messages.append(f"Error! Input type `{type(v)}` is not `PaymentMethodCardRequest`")
         else:
             match += 1
@@ -81,21 +88,21 @@
         elif match == 0:
             # no match
             raise ValueError("No match found when setting `actual_instance` in CreateCustomerPaymentMethodsRequest with oneOf schemas: PaymentMethodCardRequest, PaymentMethodCashRequest, PaymentMethodSpeiRequest. Details: " + ", ".join(error_messages))
         else:
             return v
 
     @classmethod
-    def from_dict(cls, obj: dict) -> CreateCustomerPaymentMethodsRequest:
+    def from_dict(cls, obj: dict) -> Self:
         return cls.from_json(json.dumps(obj))
 
     @classmethod
-    def from_json(cls, json_str: str) -> CreateCustomerPaymentMethodsRequest:
+    def from_json(cls, json_str: str) -> Self:
         """Returns the object represented by the json string"""
-        instance = CreateCustomerPaymentMethodsRequest.construct()
+        instance = cls.model_construct()
         error_messages = []
         match = 0
 
         # deserialize data into PaymentMethodCardRequest
         try:
             instance.actual_instance = PaymentMethodCardRequest.from_json(json_str)
             match += 1
@@ -130,23 +137,24 @@
 
         to_json = getattr(self.actual_instance, "to_json", None)
         if callable(to_json):
             return self.actual_instance.to_json()
         else:
             return json.dumps(self.actual_instance)
 
-    def to_dict(self) -> dict:
+    def to_dict(self) -> Dict:
         """Returns the dict representation of the actual instance"""
         if self.actual_instance is None:
             return None
 
         to_dict = getattr(self.actual_instance, "to_dict", None)
         if callable(to_dict):
             return self.actual_instance.to_dict()
         else:
             # primitive type
             return self.actual_instance
 
     def to_str(self) -> str:
         """Returns the string representation of the actual instance"""
-        return pprint.pformat(self.dict())
+        return pprint.pformat(self.model_dump())
+
```

### Comparing `conekta-6.0.1/conekta/models/create_customer_payment_methods_response.py` & `conekta-6.0.2/conekta/models/update_customer_payment_methods_response.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,70 +1,77 @@
 # coding: utf-8
 
 """
     Conekta API
 
-    Conekta sdk  # noqa: E501
+    Conekta sdk
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
-"""
+"""  # noqa: E501
 
 
 from __future__ import annotations
 from inspect import getfullargspec
 import json
 import pprint
 import re  # noqa: F401
 
 from typing import Any, List, Optional
-from pydantic import BaseModel, Field, StrictStr, ValidationError, validator
+from pydantic import BaseModel, Field, StrictStr, ValidationError, field_validator
 from conekta.models.payment_method_card_response import PaymentMethodCardResponse
 from conekta.models.payment_method_cash_response import PaymentMethodCashResponse
 from conekta.models.payment_method_spei_recurrent import PaymentMethodSpeiRecurrent
-from typing import Any, List
+from typing import Union, Any, List, TYPE_CHECKING, Optional, Dict
+from typing_extensions import Literal
 from pydantic import StrictStr, Field
+try:
+    from typing import Self
+except ImportError:
+    from typing_extensions import Self
 
-CREATECUSTOMERPAYMENTMETHODSRESPONSE_ONE_OF_SCHEMAS = ["PaymentMethodCardResponse", "PaymentMethodCashResponse", "PaymentMethodSpeiRecurrent"]
+UPDATECUSTOMERPAYMENTMETHODSRESPONSE_ONE_OF_SCHEMAS = ["PaymentMethodCardResponse", "PaymentMethodCashResponse", "PaymentMethodSpeiRecurrent"]
 
-class CreateCustomerPaymentMethodsResponse(BaseModel):
+class UpdateCustomerPaymentMethodsResponse(BaseModel):
     """
-    CreateCustomerPaymentMethodsResponse
+    UpdateCustomerPaymentMethodsResponse
     """
     # data type: PaymentMethodCashResponse
     oneof_schema_1_validator: Optional[PaymentMethodCashResponse] = None
     # data type: PaymentMethodCardResponse
     oneof_schema_2_validator: Optional[PaymentMethodCardResponse] = None
     # data type: PaymentMethodSpeiRecurrent
     oneof_schema_3_validator: Optional[PaymentMethodSpeiRecurrent] = None
-    actual_instance: Any
-    one_of_schemas: List[str] = Field(CREATECUSTOMERPAYMENTMETHODSRESPONSE_ONE_OF_SCHEMAS, const=True)
+    actual_instance: Optional[Union[PaymentMethodCardResponse, PaymentMethodCashResponse, PaymentMethodSpeiRecurrent]] = None
+    one_of_schemas: List[str] = Literal["PaymentMethodCardResponse", "PaymentMethodCashResponse", "PaymentMethodSpeiRecurrent"]
+
+    model_config = {
+        "validate_assignment": True
+    }
 
-    class Config:
-        validate_assignment = True
 
-    discriminator_value_class_map = {
+    discriminator_value_class_map: Dict[str, str] = {
     }
 
-    def __init__(self, *args, **kwargs):
+    def __init__(self, *args, **kwargs) -> None:
         if args:
             if len(args) > 1:
                 raise ValueError("If a position argument is used, only 1 is allowed to set `actual_instance`")
             if kwargs:
                 raise ValueError("If a position argument is used, keyword arguments cannot be used.")
             super().__init__(actual_instance=args[0])
         else:
             super().__init__(**kwargs)
 
-    @validator('actual_instance')
+    @field_validator('actual_instance')
     def actual_instance_must_validate_oneof(cls, v):
-        instance = CreateCustomerPaymentMethodsResponse.construct()
+        instance = UpdateCustomerPaymentMethodsResponse.model_construct()
         error_messages = []
         match = 0
         # validate data type: PaymentMethodCashResponse
         if not isinstance(v, PaymentMethodCashResponse):
             error_messages.append(f"Error! Input type `{type(v)}` is not `PaymentMethodCashResponse`")
         else:
             match += 1
@@ -76,29 +83,29 @@
         # validate data type: PaymentMethodSpeiRecurrent
         if not isinstance(v, PaymentMethodSpeiRecurrent):
             error_messages.append(f"Error! Input type `{type(v)}` is not `PaymentMethodSpeiRecurrent`")
         else:
             match += 1
         if match > 1:
             # more than 1 match
-            raise ValueError("Multiple matches found when setting `actual_instance` in CreateCustomerPaymentMethodsResponse with oneOf schemas: PaymentMethodCardResponse, PaymentMethodCashResponse, PaymentMethodSpeiRecurrent. Details: " + ", ".join(error_messages))
+            raise ValueError("Multiple matches found when setting `actual_instance` in UpdateCustomerPaymentMethodsResponse with oneOf schemas: PaymentMethodCardResponse, PaymentMethodCashResponse, PaymentMethodSpeiRecurrent. Details: " + ", ".join(error_messages))
         elif match == 0:
             # no match
-            raise ValueError("No match found when setting `actual_instance` in CreateCustomerPaymentMethodsResponse with oneOf schemas: PaymentMethodCardResponse, PaymentMethodCashResponse, PaymentMethodSpeiRecurrent. Details: " + ", ".join(error_messages))
+            raise ValueError("No match found when setting `actual_instance` in UpdateCustomerPaymentMethodsResponse with oneOf schemas: PaymentMethodCardResponse, PaymentMethodCashResponse, PaymentMethodSpeiRecurrent. Details: " + ", ".join(error_messages))
         else:
             return v
 
     @classmethod
-    def from_dict(cls, obj: dict) -> CreateCustomerPaymentMethodsResponse:
+    def from_dict(cls, obj: dict) -> Self:
         return cls.from_json(json.dumps(obj))
 
     @classmethod
-    def from_json(cls, json_str: str) -> CreateCustomerPaymentMethodsResponse:
+    def from_json(cls, json_str: str) -> Self:
         """Returns the object represented by the json string"""
-        instance = CreateCustomerPaymentMethodsResponse.construct()
+        instance = cls.model_construct()
         error_messages = []
         match = 0
 
         # use oneOf discriminator to lookup the data type
         _data_type = json.loads(json_str).get("type")
         if not _data_type:
             raise ValueError("Failed to lookup data type from the field `type` in the input.")
@@ -114,14 +121,19 @@
             return instance
 
         # check if data type is `PaymentMethodCashResponse`
         if _data_type == "oxxo_recurrent":
             instance.actual_instance = PaymentMethodCashResponse.from_json(json_str)
             return instance
 
+        # check if data type is `PaymentMethodSpeiRecurrent`
+        if _data_type == "spei_recurrent":
+            instance.actual_instance = PaymentMethodSpeiRecurrent.from_json(json_str)
+            return instance
+
         # check if data type is `PaymentMethodCardResponse`
         if _data_type == "payment_method_card_response":
             instance.actual_instance = PaymentMethodCardResponse.from_json(json_str)
             return instance
 
         # check if data type is `PaymentMethodCashResponse`
         if _data_type == "payment_method_cash_response":
@@ -129,19 +141,14 @@
             return instance
 
         # check if data type is `PaymentMethodSpeiRecurrent`
         if _data_type == "payment_method_spei_recurrent":
             instance.actual_instance = PaymentMethodSpeiRecurrent.from_json(json_str)
             return instance
 
-        # check if data type is `PaymentMethodSpeiRecurrent`
-        if _data_type == "spei_recurrent":
-            instance.actual_instance = PaymentMethodSpeiRecurrent.from_json(json_str)
-            return instance
-
         # deserialize data into PaymentMethodCashResponse
         try:
             instance.actual_instance = PaymentMethodCashResponse.from_json(json_str)
             match += 1
         except (ValidationError, ValueError) as e:
             error_messages.append(str(e))
         # deserialize data into PaymentMethodCardResponse
@@ -155,41 +162,42 @@
             instance.actual_instance = PaymentMethodSpeiRecurrent.from_json(json_str)
             match += 1
         except (ValidationError, ValueError) as e:
             error_messages.append(str(e))
 
         if match > 1:
             # more than 1 match
-            raise ValueError("Multiple matches found when deserializing the JSON string into CreateCustomerPaymentMethodsResponse with oneOf schemas: PaymentMethodCardResponse, PaymentMethodCashResponse, PaymentMethodSpeiRecurrent. Details: " + ", ".join(error_messages))
+            raise ValueError("Multiple matches found when deserializing the JSON string into UpdateCustomerPaymentMethodsResponse with oneOf schemas: PaymentMethodCardResponse, PaymentMethodCashResponse, PaymentMethodSpeiRecurrent. Details: " + ", ".join(error_messages))
         elif match == 0:
             # no match
-            raise ValueError("No match found when deserializing the JSON string into CreateCustomerPaymentMethodsResponse with oneOf schemas: PaymentMethodCardResponse, PaymentMethodCashResponse, PaymentMethodSpeiRecurrent. Details: " + ", ".join(error_messages))
+            raise ValueError("No match found when deserializing the JSON string into UpdateCustomerPaymentMethodsResponse with oneOf schemas: PaymentMethodCardResponse, PaymentMethodCashResponse, PaymentMethodSpeiRecurrent. Details: " + ", ".join(error_messages))
         else:
             return instance
 
     def to_json(self) -> str:
         """Returns the JSON representation of the actual instance"""
         if self.actual_instance is None:
             return "null"
 
         to_json = getattr(self.actual_instance, "to_json", None)
         if callable(to_json):
             return self.actual_instance.to_json()
         else:
             return json.dumps(self.actual_instance)
 
-    def to_dict(self) -> dict:
+    def to_dict(self) -> Dict:
         """Returns the dict representation of the actual instance"""
         if self.actual_instance is None:
             return None
 
         to_dict = getattr(self.actual_instance, "to_dict", None)
         if callable(to_dict):
             return self.actual_instance.to_dict()
         else:
             # primitive type
             return self.actual_instance
 
     def to_str(self) -> str:
         """Returns the string representation of the actual instance"""
-        return pprint.pformat(self.dict())
+        return pprint.pformat(self.model_dump())
+
```

### Comparing `conekta-6.0.1/conekta/models/create_risk_rules_data.py` & `conekta-6.0.2/conekta/models/deleted_blacklist_rule_response.py`

 * *Files 21% similar despite different names*

```diff
@@ -1,75 +1,95 @@
 # coding: utf-8
 
 """
     Conekta API
 
-    Conekta sdk  # noqa: E501
+    Conekta sdk
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
-"""
+"""  # noqa: E501
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
 
+from typing import Any, ClassVar, Dict, List, Optional
+from pydantic import BaseModel, StrictStr
+from pydantic import Field
+try:
+    from typing import Self
+except ImportError:
+    from typing_extensions import Self
 
-from pydantic import BaseModel, Field, StrictStr
-
-class CreateRiskRulesData(BaseModel):
+class DeletedBlacklistRuleResponse(BaseModel):
     """
-    CreateRiskRulesData
-    """
-    description: StrictStr = Field(..., description="Description of the rule")
-    field: StrictStr = Field(..., description="Field to be used for the rule")
-    value: StrictStr = Field(..., description="Value to be used for the rule")
-    __properties = ["description", "field", "value"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    DeletedBlacklistRuleResponse
+    """ # noqa: E501
+    id: Optional[StrictStr] = Field(default=None, description="Blacklist rule id")
+    field: Optional[StrictStr] = Field(default=None, description="field used for blacklists rule deleted")
+    value: Optional[StrictStr] = Field(default=None, description="value used for blacklists rule deleted")
+    description: Optional[StrictStr] = Field(default=None, description="use an description for blacklisted rule")
+    __properties: ClassVar[List[str]] = ["id", "field", "value", "description"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> CreateRiskRulesData:
-        """Create an instance of CreateRiskRulesData from a JSON string"""
+    def from_json(cls, json_str: str) -> Self:
+        """Create an instance of DeletedBlacklistRuleResponse from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude={
+            },
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> CreateRiskRulesData:
-        """Create an instance of CreateRiskRulesData from a dict"""
+    def from_dict(cls, obj: Dict) -> Self:
+        """Create an instance of DeletedBlacklistRuleResponse from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return CreateRiskRulesData.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = CreateRiskRulesData.parse_obj({
-            "description": obj.get("description"),
+        _obj = cls.model_validate({
+            "id": obj.get("id"),
             "field": obj.get("field"),
-            "value": obj.get("value")
+            "value": obj.get("value"),
+            "description": obj.get("description")
         })
         return _obj
 
+
```

### Comparing `conekta-6.0.1/conekta/models/customer.py` & `conekta-6.0.2/conekta/models/customer.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,80 +1,97 @@
 # coding: utf-8
 
 """
     Conekta API
 
-    Conekta sdk  # noqa: E501
+    Conekta sdk
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
-"""
+"""  # noqa: E501
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
 
-from typing import Any, Dict, List, Optional
-from pydantic import BaseModel, Field, StrictBool, StrictStr, conlist
+from typing import Any, ClassVar, Dict, List, Optional
+from pydantic import BaseModel, StrictBool, StrictStr
+from pydantic import Field
 from conekta.models.customer_antifraud_info import CustomerAntifraudInfo
 from conekta.models.customer_fiscal_entities_request import CustomerFiscalEntitiesRequest
 from conekta.models.customer_payment_methods_request import CustomerPaymentMethodsRequest
 from conekta.models.customer_shipping_contacts import CustomerShippingContacts
 from conekta.models.subscription_request import SubscriptionRequest
+try:
+    from typing import Self
+except ImportError:
+    from typing_extensions import Self
 
 class Customer(BaseModel):
     """
     a customer
-    """
+    """ # noqa: E501
     antifraud_info: Optional[CustomerAntifraudInfo] = None
-    corporate: Optional[StrictBool] = Field(False, description="It is a value that allows identifying if the email is corporate or not.")
-    custom_reference: Optional[StrictStr] = Field(None, description="It is an undefined value.")
-    email: StrictStr = Field(..., description="An email address is a series of customizable characters followed by a universal Internet symbol, the at symbol (@), the name of a host server, and a web domain ending (.mx, .com, .org, . net, etc).")
-    default_payment_source_id: Optional[StrictStr] = Field(None, description="It is a parameter that allows to identify in the response, the Conekta ID of a payment method (payment_id)")
-    default_shipping_contact_id: Optional[StrictStr] = Field(None, description="It is a parameter that allows to identify in the response, the Conekta ID of the shipping address (shipping_contact)")
-    fiscal_entities: Optional[conlist(CustomerFiscalEntitiesRequest)] = None
+    corporate: Optional[StrictBool] = Field(default=False, description="It is a value that allows identifying if the email is corporate or not.")
+    custom_reference: Optional[StrictStr] = Field(default=None, description="It is an undefined value.")
+    email: StrictStr = Field(description="An email address is a series of customizable characters followed by a universal Internet symbol, the at symbol (@), the name of a host server, and a web domain ending (.mx, .com, .org, . net, etc).")
+    default_payment_source_id: Optional[StrictStr] = Field(default=None, description="It is a parameter that allows to identify in the response, the Conekta ID of a payment method (payment_id)")
+    default_shipping_contact_id: Optional[StrictStr] = Field(default=None, description="It is a parameter that allows to identify in the response, the Conekta ID of the shipping address (shipping_contact)")
+    fiscal_entities: Optional[List[CustomerFiscalEntitiesRequest]] = None
     metadata: Optional[Dict[str, Any]] = None
-    name: StrictStr = Field(..., description="Client's name")
-    payment_sources: Optional[conlist(CustomerPaymentMethodsRequest)] = Field(None, description="Contains details of the payment methods that the customer has active or has used in Conekta")
-    phone: StrictStr = Field(..., description="Is the customer's phone number")
-    plan_id: Optional[StrictStr] = Field(None, description="Contains the ID of a plan, which could together with name, email and phone create a client directly to a subscription")
-    shipping_contacts: Optional[conlist(CustomerShippingContacts)] = Field(None, description="Contains the detail of the shipping addresses that the client has active or has used in Conekta")
+    name: StrictStr = Field(description="Client's name")
+    payment_sources: Optional[List[CustomerPaymentMethodsRequest]] = Field(default=None, description="Contains details of the payment methods that the customer has active or has used in Conekta")
+    phone: StrictStr = Field(description="Is the customer's phone number")
+    plan_id: Optional[StrictStr] = Field(default=None, description="Contains the ID of a plan, which could together with name, email and phone create a client directly to a subscription")
+    shipping_contacts: Optional[List[CustomerShippingContacts]] = Field(default=None, description="Contains the detail of the shipping addresses that the client has active or has used in Conekta")
     subscription: Optional[SubscriptionRequest] = None
-    __properties = ["antifraud_info", "corporate", "custom_reference", "email", "default_payment_source_id", "default_shipping_contact_id", "fiscal_entities", "metadata", "name", "payment_sources", "phone", "plan_id", "shipping_contacts", "subscription"]
+    __properties: ClassVar[List[str]] = ["antifraud_info", "corporate", "custom_reference", "email", "default_payment_source_id", "default_shipping_contact_id", "fiscal_entities", "metadata", "name", "payment_sources", "phone", "plan_id", "shipping_contacts", "subscription"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True
+    }
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> Customer:
+    def from_json(cls, json_str: str) -> Self:
         """Create an instance of Customer from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude={
+            },
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of antifraud_info
         if self.antifraud_info:
             _dict['antifraud_info'] = self.antifraud_info.to_dict()
         # override the default output from pydantic by calling `to_dict()` of each item in fiscal_entities (list)
         _items = []
         if self.fiscal_entities:
             for _item in self.fiscal_entities:
@@ -95,30 +112,30 @@
                 if _item:
                     _items.append(_item.to_dict())
             _dict['shipping_contacts'] = _items
         # override the default output from pydantic by calling `to_dict()` of subscription
         if self.subscription:
             _dict['subscription'] = self.subscription.to_dict()
         # set to None if antifraud_info (nullable) is None
-        # and __fields_set__ contains the field
-        if self.antifraud_info is None and "antifraud_info" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.antifraud_info is None and "antifraud_info" in self.model_fields_set:
             _dict['antifraud_info'] = None
 
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> Customer:
+    def from_dict(cls, obj: Dict) -> Self:
         """Create an instance of Customer from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return Customer.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = Customer.parse_obj({
+        _obj = cls.model_validate({
             "antifraud_info": CustomerAntifraudInfo.from_dict(obj.get("antifraud_info")) if obj.get("antifraud_info") is not None else None,
             "corporate": obj.get("corporate") if obj.get("corporate") is not None else False,
             "custom_reference": obj.get("custom_reference"),
             "email": obj.get("email"),
             "default_payment_source_id": obj.get("default_payment_source_id"),
             "default_shipping_contact_id": obj.get("default_shipping_contact_id"),
             "fiscal_entities": [CustomerFiscalEntitiesRequest.from_dict(_item) for _item in obj.get("fiscal_entities")] if obj.get("fiscal_entities") is not None else None,
@@ -128,7 +145,8 @@
             "phone": obj.get("phone"),
             "plan_id": obj.get("plan_id"),
             "shipping_contacts": [CustomerShippingContacts.from_dict(_item) for _item in obj.get("shipping_contacts")] if obj.get("shipping_contacts") is not None else None,
             "subscription": SubscriptionRequest.from_dict(obj.get("subscription")) if obj.get("subscription") is not None else None
         })
         return _obj
 
+
```

### Comparing `conekta-6.0.1/conekta/models/customer_address.py` & `conekta-6.0.2/conekta/models/customer_shipping_contacts_address.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,85 +1,106 @@
 # coding: utf-8
 
 """
     Conekta API
 
-    Conekta sdk  # noqa: E501
+    Conekta sdk
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
-"""
+"""  # noqa: E501
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
 
-from typing import Optional
-from pydantic import BaseModel, Field, StrictBool, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from pydantic import BaseModel, StrictBool, StrictStr
+from pydantic import Field
+try:
+    from typing import Self
+except ImportError:
+    from typing_extensions import Self
 
-class CustomerAddress(BaseModel):
-    """
-    CustomerAddress
+class CustomerShippingContactsAddress(BaseModel):
     """
-    street1: StrictStr = Field(...)
+    Address of the person who will receive the order
+    """ # noqa: E501
+    street1: Optional[StrictStr] = None
     street2: Optional[StrictStr] = None
-    postal_code: StrictStr = Field(...)
-    city: StrictStr = Field(...)
+    postal_code: Optional[StrictStr] = None
+    city: Optional[StrictStr] = None
     state: Optional[StrictStr] = None
-    country: Optional[StrictStr] = Field(None, description="this field follows the [ISO 3166-1 alpha-2 standard](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2)")
+    country: Optional[StrictStr] = Field(default=None, description="this field follows the [ISO 3166-1 alpha-2 standard](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2)")
     residential: Optional[StrictBool] = None
-    external_number: Optional[StrictStr] = None
-    __properties = ["street1", "street2", "postal_code", "city", "state", "country", "residential", "external_number"]
+    __properties: ClassVar[List[str]] = ["street1", "street2", "postal_code", "city", "state", "country", "residential"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True
+    }
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> CustomerAddress:
-        """Create an instance of CustomerAddress from a JSON string"""
+    def from_json(cls, json_str: str) -> Self:
+        """Create an instance of CustomerShippingContactsAddress from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude={
+            },
+            exclude_none=True,
+        )
+        # set to None if residential (nullable) is None
+        # and model_fields_set contains the field
+        if self.residential is None and "residential" in self.model_fields_set:
+            _dict['residential'] = None
+
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> CustomerAddress:
-        """Create an instance of CustomerAddress from a dict"""
+    def from_dict(cls, obj: Dict) -> Self:
+        """Create an instance of CustomerShippingContactsAddress from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return CustomerAddress.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = CustomerAddress.parse_obj({
+        _obj = cls.model_validate({
             "street1": obj.get("street1"),
             "street2": obj.get("street2"),
             "postal_code": obj.get("postal_code"),
             "city": obj.get("city"),
             "state": obj.get("state"),
             "country": obj.get("country"),
-            "residential": obj.get("residential"),
-            "external_number": obj.get("external_number")
+            "residential": obj.get("residential")
         })
         return _obj
 
+
```

### Comparing `conekta-6.0.1/conekta/models/customer_antifraud_info.py` & `conekta-6.0.2/conekta/models/details_error.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,73 +1,99 @@
 # coding: utf-8
 
 """
     Conekta API
 
-    Conekta sdk  # noqa: E501
+    Conekta sdk
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
-"""
+"""  # noqa: E501
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
 
-from typing import Optional
-from pydantic import BaseModel, StrictInt
+from typing import Any, ClassVar, Dict, List, Optional
+from pydantic import BaseModel, StrictStr
+try:
+    from typing import Self
+except ImportError:
+    from typing_extensions import Self
 
-class CustomerAntifraudInfo(BaseModel):
-    """
-    CustomerAntifraudInfo
+class DetailsError(BaseModel):
     """
-    account_created_at: Optional[StrictInt] = None
-    first_paid_at: Optional[StrictInt] = None
-    __properties = ["account_created_at", "first_paid_at"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    DetailsError
+    """ # noqa: E501
+    code: Optional[StrictStr] = None
+    param: Optional[StrictStr] = None
+    message: Optional[StrictStr] = None
+    debug_message: Optional[StrictStr] = None
+    __properties: ClassVar[List[str]] = ["code", "param", "message", "debug_message"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> CustomerAntifraudInfo:
-        """Create an instance of CustomerAntifraudInfo from a JSON string"""
+    def from_json(cls, json_str: str) -> Self:
+        """Create an instance of DetailsError from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude={
+            },
+            exclude_none=True,
+        )
+        # set to None if param (nullable) is None
+        # and model_fields_set contains the field
+        if self.param is None and "param" in self.model_fields_set:
+            _dict['param'] = None
+
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> CustomerAntifraudInfo:
-        """Create an instance of CustomerAntifraudInfo from a dict"""
+    def from_dict(cls, obj: Dict) -> Self:
+        """Create an instance of DetailsError from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return CustomerAntifraudInfo.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = CustomerAntifraudInfo.parse_obj({
-            "account_created_at": obj.get("account_created_at"),
-            "first_paid_at": obj.get("first_paid_at")
+        _obj = cls.model_validate({
+            "code": obj.get("code"),
+            "param": obj.get("param"),
+            "message": obj.get("message"),
+            "debug_message": obj.get("debug_message")
         })
         return _obj
 
+
```

### Comparing `conekta-6.0.1/conekta/models/customer_fiscal_entities_data_response.py` & `conekta-6.0.2/conekta/models/customer_fiscal_entities_data_response.py`

 * *Files 25% similar despite different names*

```diff
@@ -1,95 +1,112 @@
 # coding: utf-8
 
 """
     Conekta API
 
-    Conekta sdk  # noqa: E501
+    Conekta sdk
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
-"""
+"""  # noqa: E501
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
 
-from typing import Any, Dict, Optional
-from pydantic import BaseModel, Field, StrictBool, StrictInt, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional, Union
+from pydantic import BaseModel, StrictBool, StrictInt, StrictStr
 from conekta.models.customer_fiscal_entities_request_address import CustomerFiscalEntitiesRequestAddress
+try:
+    from typing import Self
+except ImportError:
+    from typing_extensions import Self
 
 class CustomerFiscalEntitiesDataResponse(BaseModel):
     """
     CustomerFiscalEntitiesDataResponse
-    """
-    address: CustomerFiscalEntitiesRequestAddress = Field(...)
+    """ # noqa: E501
+    address: CustomerFiscalEntitiesRequestAddress
     tax_id: Optional[StrictStr] = None
     email: Optional[StrictStr] = None
     phone: Optional[StrictStr] = None
-    metadata: Optional[Dict[str, Dict[str, Any]]] = None
+    metadata: Optional[Dict[str, Union[str, Any]]] = None
     company_name: Optional[StrictStr] = None
-    id: StrictStr = Field(...)
-    object: StrictStr = Field(...)
-    created_at: StrictInt = Field(...)
+    id: StrictStr
+    object: StrictStr
+    created_at: StrictInt
     parent_id: Optional[StrictStr] = None
     default: Optional[StrictBool] = None
-    __properties = ["address", "tax_id", "email", "phone", "metadata", "company_name", "id", "object", "created_at", "parent_id", "default"]
+    __properties: ClassVar[List[str]] = ["address", "tax_id", "email", "phone", "metadata", "company_name", "id", "object", "created_at", "parent_id", "default"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True
+    }
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> CustomerFiscalEntitiesDataResponse:
+    def from_json(cls, json_str: str) -> Self:
         """Create an instance of CustomerFiscalEntitiesDataResponse from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude={
+            },
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of address
         if self.address:
             _dict['address'] = self.address.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> CustomerFiscalEntitiesDataResponse:
+    def from_dict(cls, obj: Dict) -> Self:
         """Create an instance of CustomerFiscalEntitiesDataResponse from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return CustomerFiscalEntitiesDataResponse.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = CustomerFiscalEntitiesDataResponse.parse_obj({
+        _obj = cls.model_validate({
             "address": CustomerFiscalEntitiesRequestAddress.from_dict(obj.get("address")) if obj.get("address") is not None else None,
             "tax_id": obj.get("tax_id"),
             "email": obj.get("email"),
             "phone": obj.get("phone"),
             "metadata": obj.get("metadata"),
             "company_name": obj.get("company_name"),
             "id": obj.get("id"),
             "object": obj.get("object"),
             "created_at": obj.get("created_at"),
             "parent_id": obj.get("parent_id"),
             "default": obj.get("default")
         })
         return _obj
 
+
```

### Comparing `conekta-6.0.1/conekta/models/customer_fiscal_entities_request.py` & `conekta-6.0.2/conekta/models/customer_update_fiscal_entities_request.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,85 +1,102 @@
 # coding: utf-8
 
 """
     Conekta API
 
-    Conekta sdk  # noqa: E501
+    Conekta sdk
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
-"""
+"""  # noqa: E501
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
 
-from typing import Any, Dict, Optional
-from pydantic import BaseModel, Field, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional, Union
+from pydantic import BaseModel, StrictStr
 from conekta.models.customer_fiscal_entities_request_address import CustomerFiscalEntitiesRequestAddress
+try:
+    from typing import Self
+except ImportError:
+    from typing_extensions import Self
 
-class CustomerFiscalEntitiesRequest(BaseModel):
-    """
-    CustomerFiscalEntitiesRequest
+class CustomerUpdateFiscalEntitiesRequest(BaseModel):
     """
-    address: CustomerFiscalEntitiesRequestAddress = Field(...)
+    CustomerUpdateFiscalEntitiesRequest
+    """ # noqa: E501
+    address: Optional[CustomerFiscalEntitiesRequestAddress] = None
     tax_id: Optional[StrictStr] = None
     email: Optional[StrictStr] = None
     phone: Optional[StrictStr] = None
-    metadata: Optional[Dict[str, Dict[str, Any]]] = None
+    metadata: Optional[Dict[str, Union[str, Any]]] = None
     company_name: Optional[StrictStr] = None
-    __properties = ["address", "tax_id", "email", "phone", "metadata", "company_name"]
+    __properties: ClassVar[List[str]] = ["address", "tax_id", "email", "phone", "metadata", "company_name"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True
+    }
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> CustomerFiscalEntitiesRequest:
-        """Create an instance of CustomerFiscalEntitiesRequest from a JSON string"""
+    def from_json(cls, json_str: str) -> Self:
+        """Create an instance of CustomerUpdateFiscalEntitiesRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude={
+            },
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of address
         if self.address:
             _dict['address'] = self.address.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> CustomerFiscalEntitiesRequest:
-        """Create an instance of CustomerFiscalEntitiesRequest from a dict"""
+    def from_dict(cls, obj: Dict) -> Self:
+        """Create an instance of CustomerUpdateFiscalEntitiesRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return CustomerFiscalEntitiesRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = CustomerFiscalEntitiesRequest.parse_obj({
+        _obj = cls.model_validate({
             "address": CustomerFiscalEntitiesRequestAddress.from_dict(obj.get("address")) if obj.get("address") is not None else None,
             "tax_id": obj.get("tax_id"),
             "email": obj.get("email"),
             "phone": obj.get("phone"),
             "metadata": obj.get("metadata"),
             "company_name": obj.get("company_name")
         })
         return _obj
 
+
```

### Comparing `conekta-6.0.1/conekta/models/customer_fiscal_entities_request_address.py` & `conekta-6.0.2/conekta/models/customer_antifraud_info.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,85 +1,90 @@
 # coding: utf-8
 
 """
     Conekta API
 
-    Conekta sdk  # noqa: E501
+    Conekta sdk
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
-"""
+"""  # noqa: E501
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
 
-from typing import Optional
-from pydantic import BaseModel, Field, StrictBool, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from pydantic import BaseModel, StrictInt
+try:
+    from typing import Self
+except ImportError:
+    from typing_extensions import Self
 
-class CustomerFiscalEntitiesRequestAddress(BaseModel):
-    """
-    CustomerFiscalEntitiesRequestAddress
+class CustomerAntifraudInfo(BaseModel):
     """
-    street1: StrictStr = Field(...)
-    street2: Optional[StrictStr] = None
-    postal_code: StrictStr = Field(...)
-    city: StrictStr = Field(...)
-    state: Optional[StrictStr] = None
-    country: Optional[StrictStr] = Field(None, description="this field follows the [ISO 3166-1 alpha-2 standard](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2)")
-    residential: Optional[StrictBool] = None
-    external_number: Optional[StrictStr] = None
-    __properties = ["street1", "street2", "postal_code", "city", "state", "country", "residential", "external_number"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    CustomerAntifraudInfo
+    """ # noqa: E501
+    account_created_at: Optional[StrictInt] = None
+    first_paid_at: Optional[StrictInt] = None
+    __properties: ClassVar[List[str]] = ["account_created_at", "first_paid_at"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> CustomerFiscalEntitiesRequestAddress:
-        """Create an instance of CustomerFiscalEntitiesRequestAddress from a JSON string"""
+    def from_json(cls, json_str: str) -> Self:
+        """Create an instance of CustomerAntifraudInfo from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude={
+            },
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> CustomerFiscalEntitiesRequestAddress:
-        """Create an instance of CustomerFiscalEntitiesRequestAddress from a dict"""
+    def from_dict(cls, obj: Dict) -> Self:
+        """Create an instance of CustomerAntifraudInfo from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return CustomerFiscalEntitiesRequestAddress.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = CustomerFiscalEntitiesRequestAddress.parse_obj({
-            "street1": obj.get("street1"),
-            "street2": obj.get("street2"),
-            "postal_code": obj.get("postal_code"),
-            "city": obj.get("city"),
-            "state": obj.get("state"),
-            "country": obj.get("country"),
-            "residential": obj.get("residential"),
-            "external_number": obj.get("external_number")
+        _obj = cls.model_validate({
+            "account_created_at": obj.get("account_created_at"),
+            "first_paid_at": obj.get("first_paid_at")
         })
         return _obj
 
+
```

### Comparing `conekta-6.0.1/conekta/models/customer_fiscal_entities_response.py` & `conekta-6.0.2/conekta/models/customer_fiscal_entities_response_all_of.py`

 * *Files 23% similar despite different names*

```diff
@@ -1,83 +1,96 @@
 # coding: utf-8
 
 """
     Conekta API
 
-    Conekta sdk  # noqa: E501
+    Conekta sdk
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
-"""
+"""  # noqa: E501
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
 
-from typing import List, Optional
-from pydantic import BaseModel, Field, StrictBool, StrictStr, conlist
+from typing import Any, ClassVar, Dict, List, Optional
+from pydantic import BaseModel
 from conekta.models.customer_fiscal_entities_data_response import CustomerFiscalEntitiesDataResponse
+try:
+    from typing import Self
+except ImportError:
+    from typing_extensions import Self
 
-class CustomerFiscalEntitiesResponse(BaseModel):
-    """
-    CustomerFiscalEntitiesResponse
+class CustomerFiscalEntitiesResponseAllOf(BaseModel):
     """
-    has_more: StrictBool = Field(..., description="Indicates if there are more pages to be requested")
-    object: StrictStr = Field(..., description="Object type, in this case is list")
-    data: Optional[conlist(CustomerFiscalEntitiesDataResponse)] = None
-    __properties = ["has_more", "object", "data"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    CustomerFiscalEntitiesResponseAllOf
+    """ # noqa: E501
+    data: Optional[List[CustomerFiscalEntitiesDataResponse]] = None
+    __properties: ClassVar[List[str]] = ["data"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> CustomerFiscalEntitiesResponse:
-        """Create an instance of CustomerFiscalEntitiesResponse from a JSON string"""
+    def from_json(cls, json_str: str) -> Self:
+        """Create an instance of CustomerFiscalEntitiesResponseAllOf from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude={
+            },
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of each item in data (list)
         _items = []
         if self.data:
             for _item in self.data:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['data'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> CustomerFiscalEntitiesResponse:
-        """Create an instance of CustomerFiscalEntitiesResponse from a dict"""
+    def from_dict(cls, obj: Dict) -> Self:
+        """Create an instance of CustomerFiscalEntitiesResponseAllOf from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return CustomerFiscalEntitiesResponse.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = CustomerFiscalEntitiesResponse.parse_obj({
-            "has_more": obj.get("has_more"),
-            "object": obj.get("object"),
+        _obj = cls.model_validate({
             "data": [CustomerFiscalEntitiesDataResponse.from_dict(_item) for _item in obj.get("data")] if obj.get("data") is not None else None
         })
         return _obj
 
+
```

### Comparing `conekta-6.0.1/conekta/models/customer_payment_methods.py` & `conekta-6.0.2/conekta/models/orders_response.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,79 +1,96 @@
 # coding: utf-8
 
 """
     Conekta API
 
-    Conekta sdk  # noqa: E501
+    Conekta sdk
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
-"""
+"""  # noqa: E501
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
 
-from typing import List, Optional
-from pydantic import BaseModel, conlist
-from conekta.models.customer_payment_methods_data import CustomerPaymentMethodsData
+from typing import Any, ClassVar, Dict, List
+from pydantic import BaseModel
+from conekta.models.order_response import OrderResponse
+try:
+    from typing import Self
+except ImportError:
+    from typing_extensions import Self
 
-class CustomerPaymentMethods(BaseModel):
-    """
-    CustomerPaymentMethods
+class OrdersResponse(BaseModel):
     """
-    data: Optional[conlist(CustomerPaymentMethodsData)] = None
-    __properties = ["data"]
+    OrdersResponse
+    """ # noqa: E501
+    data: List[OrderResponse]
+    __properties: ClassVar[List[str]] = ["data"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True
+    }
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> CustomerPaymentMethods:
-        """Create an instance of CustomerPaymentMethods from a JSON string"""
+    def from_json(cls, json_str: str) -> Self:
+        """Create an instance of OrdersResponse from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude={
+            },
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of each item in data (list)
         _items = []
         if self.data:
             for _item in self.data:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['data'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> CustomerPaymentMethods:
-        """Create an instance of CustomerPaymentMethods from a dict"""
+    def from_dict(cls, obj: Dict) -> Self:
+        """Create an instance of OrdersResponse from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return CustomerPaymentMethods.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = CustomerPaymentMethods.parse_obj({
-            "data": [CustomerPaymentMethodsData.from_dict(_item) for _item in obj.get("data")] if obj.get("data") is not None else None
+        _obj = cls.model_validate({
+            "data": [OrderResponse.from_dict(_item) for _item in obj.get("data")] if obj.get("data") is not None else None
         })
         return _obj
 
+
```

### Comparing `conekta-6.0.1/conekta/models/customer_payment_methods_data.py` & `conekta-6.0.2/conekta/models/customer_payment_methods_data.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,70 +1,77 @@
 # coding: utf-8
 
 """
     Conekta API
 
-    Conekta sdk  # noqa: E501
+    Conekta sdk
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
-"""
+"""  # noqa: E501
 
 
 from __future__ import annotations
 from inspect import getfullargspec
 import json
 import pprint
 import re  # noqa: F401
 
 from typing import Any, List, Optional
-from pydantic import BaseModel, Field, StrictStr, ValidationError, validator
+from pydantic import BaseModel, Field, StrictStr, ValidationError, field_validator
 from conekta.models.payment_method_card_response import PaymentMethodCardResponse
 from conekta.models.payment_method_cash_response import PaymentMethodCashResponse
 from conekta.models.payment_method_spei_recurrent import PaymentMethodSpeiRecurrent
-from typing import Any, List
+from typing import Union, Any, List, TYPE_CHECKING, Optional, Dict
+from typing_extensions import Literal
 from pydantic import StrictStr, Field
+try:
+    from typing import Self
+except ImportError:
+    from typing_extensions import Self
 
 CUSTOMERPAYMENTMETHODSDATA_ONE_OF_SCHEMAS = ["PaymentMethodCardResponse", "PaymentMethodCashResponse", "PaymentMethodSpeiRecurrent"]
 
 class CustomerPaymentMethodsData(BaseModel):
     """
     CustomerPaymentMethodsData
     """
     # data type: PaymentMethodCashResponse
     oneof_schema_1_validator: Optional[PaymentMethodCashResponse] = None
     # data type: PaymentMethodCardResponse
     oneof_schema_2_validator: Optional[PaymentMethodCardResponse] = None
     # data type: PaymentMethodSpeiRecurrent
     oneof_schema_3_validator: Optional[PaymentMethodSpeiRecurrent] = None
-    actual_instance: Any
-    one_of_schemas: List[str] = Field(CUSTOMERPAYMENTMETHODSDATA_ONE_OF_SCHEMAS, const=True)
+    actual_instance: Optional[Union[PaymentMethodCardResponse, PaymentMethodCashResponse, PaymentMethodSpeiRecurrent]] = None
+    one_of_schemas: List[str] = Literal["PaymentMethodCardResponse", "PaymentMethodCashResponse", "PaymentMethodSpeiRecurrent"]
+
+    model_config = {
+        "validate_assignment": True
+    }
 
-    class Config:
-        validate_assignment = True
 
-    discriminator_value_class_map = {
+    discriminator_value_class_map: Dict[str, str] = {
     }
 
-    def __init__(self, *args, **kwargs):
+    def __init__(self, *args, **kwargs) -> None:
         if args:
             if len(args) > 1:
                 raise ValueError("If a position argument is used, only 1 is allowed to set `actual_instance`")
             if kwargs:
                 raise ValueError("If a position argument is used, keyword arguments cannot be used.")
             super().__init__(actual_instance=args[0])
         else:
             super().__init__(**kwargs)
 
-    @validator('actual_instance')
+    @field_validator('actual_instance')
     def actual_instance_must_validate_oneof(cls, v):
-        instance = CustomerPaymentMethodsData.construct()
+        instance = CustomerPaymentMethodsData.model_construct()
         error_messages = []
         match = 0
         # validate data type: PaymentMethodCashResponse
         if not isinstance(v, PaymentMethodCashResponse):
             error_messages.append(f"Error! Input type `{type(v)}` is not `PaymentMethodCashResponse`")
         else:
             match += 1
@@ -84,21 +91,21 @@
         elif match == 0:
             # no match
             raise ValueError("No match found when setting `actual_instance` in CustomerPaymentMethodsData with oneOf schemas: PaymentMethodCardResponse, PaymentMethodCashResponse, PaymentMethodSpeiRecurrent. Details: " + ", ".join(error_messages))
         else:
             return v
 
     @classmethod
-    def from_dict(cls, obj: dict) -> CustomerPaymentMethodsData:
+    def from_dict(cls, obj: dict) -> Self:
         return cls.from_json(json.dumps(obj))
 
     @classmethod
-    def from_json(cls, json_str: str) -> CustomerPaymentMethodsData:
+    def from_json(cls, json_str: str) -> Self:
         """Returns the object represented by the json string"""
-        instance = CustomerPaymentMethodsData.construct()
+        instance = cls.model_construct()
         error_messages = []
         match = 0
 
         # use oneOf discriminator to lookup the data type
         _data_type = json.loads(json_str).get("type")
         if not _data_type:
             raise ValueError("Failed to lookup data type from the field `type` in the input.")
@@ -114,14 +121,19 @@
             return instance
 
         # check if data type is `PaymentMethodCashResponse`
         if _data_type == "oxxo_recurrent":
             instance.actual_instance = PaymentMethodCashResponse.from_json(json_str)
             return instance
 
+        # check if data type is `PaymentMethodSpeiRecurrent`
+        if _data_type == "spei_recurrent":
+            instance.actual_instance = PaymentMethodSpeiRecurrent.from_json(json_str)
+            return instance
+
         # check if data type is `PaymentMethodCardResponse`
         if _data_type == "payment_method_card_response":
             instance.actual_instance = PaymentMethodCardResponse.from_json(json_str)
             return instance
 
         # check if data type is `PaymentMethodCashResponse`
         if _data_type == "payment_method_cash_response":
@@ -129,19 +141,14 @@
             return instance
 
         # check if data type is `PaymentMethodSpeiRecurrent`
         if _data_type == "payment_method_spei_recurrent":
             instance.actual_instance = PaymentMethodSpeiRecurrent.from_json(json_str)
             return instance
 
-        # check if data type is `PaymentMethodSpeiRecurrent`
-        if _data_type == "spei_recurrent":
-            instance.actual_instance = PaymentMethodSpeiRecurrent.from_json(json_str)
-            return instance
-
         # deserialize data into PaymentMethodCashResponse
         try:
             instance.actual_instance = PaymentMethodCashResponse.from_json(json_str)
             match += 1
         except (ValidationError, ValueError) as e:
             error_messages.append(str(e))
         # deserialize data into PaymentMethodCardResponse
@@ -173,23 +180,24 @@
 
         to_json = getattr(self.actual_instance, "to_json", None)
         if callable(to_json):
             return self.actual_instance.to_json()
         else:
             return json.dumps(self.actual_instance)
 
-    def to_dict(self) -> dict:
+    def to_dict(self) -> Dict:
         """Returns the dict representation of the actual instance"""
         if self.actual_instance is None:
             return None
 
         to_dict = getattr(self.actual_instance, "to_dict", None)
         if callable(to_dict):
             return self.actual_instance.to_dict()
         else:
             # primitive type
             return self.actual_instance
 
     def to_str(self) -> str:
         """Returns the string representation of the actual instance"""
-        return pprint.pformat(self.dict())
+        return pprint.pformat(self.model_dump())
+
```

### Comparing `conekta-6.0.1/conekta/models/customer_payment_methods_request.py` & `conekta-6.0.2/conekta/models/customer_payment_methods_request.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,67 +1,74 @@
 # coding: utf-8
 
 """
     Conekta API
 
-    Conekta sdk  # noqa: E501
+    Conekta sdk
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
-"""
+"""  # noqa: E501
 
 
 from __future__ import annotations
 from inspect import getfullargspec
 import json
 import pprint
 import re  # noqa: F401
 
 from typing import Any, List, Optional
-from pydantic import BaseModel, Field, StrictStr, ValidationError, validator
+from pydantic import BaseModel, Field, StrictStr, ValidationError, field_validator
 from conekta.models.payment_method_card_request import PaymentMethodCardRequest
 from conekta.models.payment_method_cash_request import PaymentMethodCashRequest
 from conekta.models.payment_method_spei_request import PaymentMethodSpeiRequest
-from typing import Any, List
+from typing import Union, Any, List, TYPE_CHECKING, Optional, Dict
+from typing_extensions import Literal
 from pydantic import StrictStr, Field
+try:
+    from typing import Self
+except ImportError:
+    from typing_extensions import Self
 
 CUSTOMERPAYMENTMETHODSREQUEST_ONE_OF_SCHEMAS = ["PaymentMethodCardRequest", "PaymentMethodCashRequest", "PaymentMethodSpeiRequest"]
 
 class CustomerPaymentMethodsRequest(BaseModel):
     """
     CustomerPaymentMethodsRequest
     """
     # data type: PaymentMethodCardRequest
     oneof_schema_1_validator: Optional[PaymentMethodCardRequest] = None
     # data type: PaymentMethodCashRequest
     oneof_schema_2_validator: Optional[PaymentMethodCashRequest] = None
     # data type: PaymentMethodSpeiRequest
     oneof_schema_3_validator: Optional[PaymentMethodSpeiRequest] = None
-    actual_instance: Any
-    one_of_schemas: List[str] = Field(CUSTOMERPAYMENTMETHODSREQUEST_ONE_OF_SCHEMAS, const=True)
+    actual_instance: Optional[Union[PaymentMethodCardRequest, PaymentMethodCashRequest, PaymentMethodSpeiRequest]] = None
+    one_of_schemas: List[str] = Literal["PaymentMethodCardRequest", "PaymentMethodCashRequest", "PaymentMethodSpeiRequest"]
+
+    model_config = {
+        "validate_assignment": True
+    }
 
-    class Config:
-        validate_assignment = True
 
-    def __init__(self, *args, **kwargs):
+    def __init__(self, *args, **kwargs) -> None:
         if args:
             if len(args) > 1:
                 raise ValueError("If a position argument is used, only 1 is allowed to set `actual_instance`")
             if kwargs:
                 raise ValueError("If a position argument is used, keyword arguments cannot be used.")
             super().__init__(actual_instance=args[0])
         else:
             super().__init__(**kwargs)
 
-    @validator('actual_instance')
+    @field_validator('actual_instance')
     def actual_instance_must_validate_oneof(cls, v):
-        instance = CustomerPaymentMethodsRequest.construct()
+        instance = CustomerPaymentMethodsRequest.model_construct()
         error_messages = []
         match = 0
         # validate data type: PaymentMethodCardRequest
         if not isinstance(v, PaymentMethodCardRequest):
             error_messages.append(f"Error! Input type `{type(v)}` is not `PaymentMethodCardRequest`")
         else:
             match += 1
@@ -81,21 +88,21 @@
         elif match == 0:
             # no match
             raise ValueError("No match found when setting `actual_instance` in CustomerPaymentMethodsRequest with oneOf schemas: PaymentMethodCardRequest, PaymentMethodCashRequest, PaymentMethodSpeiRequest. Details: " + ", ".join(error_messages))
         else:
             return v
 
     @classmethod
-    def from_dict(cls, obj: dict) -> CustomerPaymentMethodsRequest:
+    def from_dict(cls, obj: dict) -> Self:
         return cls.from_json(json.dumps(obj))
 
     @classmethod
-    def from_json(cls, json_str: str) -> CustomerPaymentMethodsRequest:
+    def from_json(cls, json_str: str) -> Self:
         """Returns the object represented by the json string"""
-        instance = CustomerPaymentMethodsRequest.construct()
+        instance = cls.model_construct()
         error_messages = []
         match = 0
 
         # deserialize data into PaymentMethodCardRequest
         try:
             instance.actual_instance = PaymentMethodCardRequest.from_json(json_str)
             match += 1
@@ -130,23 +137,24 @@
 
         to_json = getattr(self.actual_instance, "to_json", None)
         if callable(to_json):
             return self.actual_instance.to_json()
         else:
             return json.dumps(self.actual_instance)
 
-    def to_dict(self) -> dict:
+    def to_dict(self) -> Dict:
         """Returns the dict representation of the actual instance"""
         if self.actual_instance is None:
             return None
 
         to_dict = getattr(self.actual_instance, "to_dict", None)
         if callable(to_dict):
             return self.actual_instance.to_dict()
         else:
             # primitive type
             return self.actual_instance
 
     def to_str(self) -> str:
         """Returns the string representation of the actual instance"""
-        return pprint.pformat(self.dict())
+        return pprint.pformat(self.model_dump())
+
```

### Comparing `conekta-6.0.1/conekta/models/customer_payment_methods_response.py` & `conekta-6.0.2/conekta/models/customer_payment_methods_response.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,97 +1,115 @@
 # coding: utf-8
 
 """
     Conekta API
 
-    Conekta sdk  # noqa: E501
+    Conekta sdk
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
-"""
+"""  # noqa: E501
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
 
-from typing import List, Optional
-from pydantic import BaseModel, Field, StrictBool, StrictStr, conlist
+from typing import Any, ClassVar, Dict, List, Optional
+from pydantic import BaseModel, StrictBool, StrictStr
+from pydantic import Field
 from conekta.models.customer_payment_methods_data import CustomerPaymentMethodsData
+try:
+    from typing import Self
+except ImportError:
+    from typing_extensions import Self
 
 class CustomerPaymentMethodsResponse(BaseModel):
     """
     CustomerPaymentMethodsResponse
-    """
-    has_more: StrictBool = Field(..., description="Indicates if there are more pages to be requested")
-    object: StrictStr = Field(..., description="Object type, in this case is list")
-    next_page_url: Optional[StrictStr] = Field(None, description="URL of the next page.")
-    previous_page_url: Optional[StrictStr] = Field(None, description="Url of the previous page.")
-    data: Optional[conlist(CustomerPaymentMethodsData)] = None
-    __properties = ["has_more", "object", "next_page_url", "previous_page_url", "data"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    """ # noqa: E501
+    has_more: StrictBool = Field(description="Indicates if there are more pages to be requested")
+    object: StrictStr = Field(description="Object type, in this case is list")
+    next_page_url: Optional[StrictStr] = Field(default=None, description="URL of the next page.")
+    previous_page_url: Optional[StrictStr] = Field(default=None, description="Url of the previous page.")
+    data: Optional[List[CustomerPaymentMethodsData]] = None
+    __properties: ClassVar[List[str]] = ["has_more", "object", "next_page_url", "previous_page_url", "data"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> CustomerPaymentMethodsResponse:
+    def from_json(cls, json_str: str) -> Self:
         """Create an instance of CustomerPaymentMethodsResponse from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude={
+            },
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of each item in data (list)
         _items = []
         if self.data:
             for _item in self.data:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['data'] = _items
         # set to None if next_page_url (nullable) is None
-        # and __fields_set__ contains the field
-        if self.next_page_url is None and "next_page_url" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.next_page_url is None and "next_page_url" in self.model_fields_set:
             _dict['next_page_url'] = None
 
         # set to None if previous_page_url (nullable) is None
-        # and __fields_set__ contains the field
-        if self.previous_page_url is None and "previous_page_url" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.previous_page_url is None and "previous_page_url" in self.model_fields_set:
             _dict['previous_page_url'] = None
 
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> CustomerPaymentMethodsResponse:
+    def from_dict(cls, obj: Dict) -> Self:
         """Create an instance of CustomerPaymentMethodsResponse from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return CustomerPaymentMethodsResponse.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = CustomerPaymentMethodsResponse.parse_obj({
+        _obj = cls.model_validate({
             "has_more": obj.get("has_more"),
             "object": obj.get("object"),
             "next_page_url": obj.get("next_page_url"),
             "previous_page_url": obj.get("previous_page_url"),
             "data": [CustomerPaymentMethodsData.from_dict(_item) for _item in obj.get("data")] if obj.get("data") is not None else None
         })
         return _obj
 
+
```

### Comparing `conekta-6.0.1/conekta/models/customer_response.py` & `conekta-6.0.2/conekta/models/customer_response.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,83 +1,101 @@
 # coding: utf-8
 
 """
     Conekta API
 
-    Conekta sdk  # noqa: E501
+    Conekta sdk
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
-"""
+"""  # noqa: E501
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
 
-from typing import Optional
-from pydantic import BaseModel, Field, StrictBool, StrictInt, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from pydantic import BaseModel, StrictBool, StrictInt, StrictStr
+from pydantic import Field
 from conekta.models.customer_antifraud_info_response import CustomerAntifraudInfoResponse
 from conekta.models.customer_fiscal_entities_response import CustomerFiscalEntitiesResponse
 from conekta.models.customer_payment_methods_response import CustomerPaymentMethodsResponse
 from conekta.models.customer_response_shipping_contacts import CustomerResponseShippingContacts
 from conekta.models.subscription_response import SubscriptionResponse
+try:
+    from typing import Self
+except ImportError:
+    from typing_extensions import Self
 
 class CustomerResponse(BaseModel):
     """
     customer response
-    """
+    """ # noqa: E501
     antifraud_info: Optional[CustomerAntifraudInfoResponse] = None
-    corporate: Optional[StrictBool] = None
-    created_at: StrictInt = Field(...)
-    custom_reference: Optional[StrictStr] = None
+    corporate: Optional[StrictBool] = Field(default=None, description="true if the customer is a company")
+    created_at: StrictInt = Field(description="Creation date of the object")
+    custom_reference: Optional[StrictStr] = Field(default=None, description="Custom reference")
     default_fiscal_entity_id: Optional[StrictStr] = None
     default_shipping_contact_id: Optional[StrictStr] = None
     default_payment_source_id: Optional[StrictStr] = None
     email: Optional[StrictStr] = None
     fiscal_entities: Optional[CustomerFiscalEntitiesResponse] = None
-    id: StrictStr = Field(...)
-    livemode: StrictBool = Field(...)
-    name: Optional[StrictStr] = None
-    object: StrictStr = Field(...)
+    id: StrictStr = Field(description="Customer's ID")
+    livemode: StrictBool = Field(description="true if the object exists in live mode or the value false if the object exists in test mode")
+    name: StrictStr = Field(description="Customer's name")
+    metadata: Optional[Dict[str, Any]] = None
+    object: StrictStr
     payment_sources: Optional[CustomerPaymentMethodsResponse] = None
-    phone: Optional[StrictStr] = None
+    phone: Optional[StrictStr] = Field(default=None, description="Customer's phone number")
     shipping_contacts: Optional[CustomerResponseShippingContacts] = None
     subscription: Optional[SubscriptionResponse] = None
-    __properties = ["antifraud_info", "corporate", "created_at", "custom_reference", "default_fiscal_entity_id", "default_shipping_contact_id", "default_payment_source_id", "email", "fiscal_entities", "id", "livemode", "name", "object", "payment_sources", "phone", "shipping_contacts", "subscription"]
+    __properties: ClassVar[List[str]] = ["antifraud_info", "corporate", "created_at", "custom_reference", "default_fiscal_entity_id", "default_shipping_contact_id", "default_payment_source_id", "email", "fiscal_entities", "id", "livemode", "name", "metadata", "object", "payment_sources", "phone", "shipping_contacts", "subscription"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True
+    }
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> CustomerResponse:
+    def from_json(cls, json_str: str) -> Self:
         """Create an instance of CustomerResponse from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude={
+            },
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of antifraud_info
         if self.antifraud_info:
             _dict['antifraud_info'] = self.antifraud_info.to_dict()
         # override the default output from pydantic by calling `to_dict()` of fiscal_entities
         if self.fiscal_entities:
             _dict['fiscal_entities'] = self.fiscal_entities.to_dict()
         # override the default output from pydantic by calling `to_dict()` of payment_sources
@@ -86,53 +104,55 @@
         # override the default output from pydantic by calling `to_dict()` of shipping_contacts
         if self.shipping_contacts:
             _dict['shipping_contacts'] = self.shipping_contacts.to_dict()
         # override the default output from pydantic by calling `to_dict()` of subscription
         if self.subscription:
             _dict['subscription'] = self.subscription.to_dict()
         # set to None if antifraud_info (nullable) is None
-        # and __fields_set__ contains the field
-        if self.antifraud_info is None and "antifraud_info" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.antifraud_info is None and "antifraud_info" in self.model_fields_set:
             _dict['antifraud_info'] = None
 
         # set to None if default_fiscal_entity_id (nullable) is None
-        # and __fields_set__ contains the field
-        if self.default_fiscal_entity_id is None and "default_fiscal_entity_id" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.default_fiscal_entity_id is None and "default_fiscal_entity_id" in self.model_fields_set:
             _dict['default_fiscal_entity_id'] = None
 
         # set to None if default_payment_source_id (nullable) is None
-        # and __fields_set__ contains the field
-        if self.default_payment_source_id is None and "default_payment_source_id" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.default_payment_source_id is None and "default_payment_source_id" in self.model_fields_set:
             _dict['default_payment_source_id'] = None
 
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> CustomerResponse:
+    def from_dict(cls, obj: Dict) -> Self:
         """Create an instance of CustomerResponse from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return CustomerResponse.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = CustomerResponse.parse_obj({
+        _obj = cls.model_validate({
             "antifraud_info": CustomerAntifraudInfoResponse.from_dict(obj.get("antifraud_info")) if obj.get("antifraud_info") is not None else None,
             "corporate": obj.get("corporate"),
             "created_at": obj.get("created_at"),
             "custom_reference": obj.get("custom_reference"),
             "default_fiscal_entity_id": obj.get("default_fiscal_entity_id"),
             "default_shipping_contact_id": obj.get("default_shipping_contact_id"),
             "default_payment_source_id": obj.get("default_payment_source_id"),
             "email": obj.get("email"),
             "fiscal_entities": CustomerFiscalEntitiesResponse.from_dict(obj.get("fiscal_entities")) if obj.get("fiscal_entities") is not None else None,
             "id": obj.get("id"),
             "livemode": obj.get("livemode"),
             "name": obj.get("name"),
+            "metadata": obj.get("metadata"),
             "object": obj.get("object"),
             "payment_sources": CustomerPaymentMethodsResponse.from_dict(obj.get("payment_sources")) if obj.get("payment_sources") is not None else None,
             "phone": obj.get("phone"),
             "shipping_contacts": CustomerResponseShippingContacts.from_dict(obj.get("shipping_contacts")) if obj.get("shipping_contacts") is not None else None,
             "subscription": SubscriptionResponse.from_dict(obj.get("subscription")) if obj.get("subscription") is not None else None
         })
         return _obj
 
+
```

### Comparing `conekta-6.0.1/conekta/models/customer_response_shipping_contacts.py` & `conekta-6.0.2/conekta/models/customer_response_shipping_contacts.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,83 +1,101 @@
 # coding: utf-8
 
 """
     Conekta API
 
-    Conekta sdk  # noqa: E501
+    Conekta sdk
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
-"""
+"""  # noqa: E501
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
 
-from typing import List, Optional
-from pydantic import BaseModel, Field, StrictBool, StrictStr, conlist
+from typing import Any, ClassVar, Dict, List, Optional
+from pydantic import BaseModel, StrictBool, StrictStr
+from pydantic import Field
 from conekta.models.customer_shipping_contacts_data_response import CustomerShippingContactsDataResponse
+try:
+    from typing import Self
+except ImportError:
+    from typing_extensions import Self
 
 class CustomerResponseShippingContacts(BaseModel):
     """
     CustomerResponseShippingContacts
-    """
-    has_more: StrictBool = Field(..., description="Indicates if there are more pages to be requested")
-    object: StrictStr = Field(..., description="Object type, in this case is list")
-    data: Optional[conlist(CustomerShippingContactsDataResponse)] = None
-    __properties = ["has_more", "object", "data"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    """ # noqa: E501
+    has_more: StrictBool = Field(description="Indicates if there are more pages to be requested")
+    object: StrictStr = Field(description="Object type, in this case is list")
+    data: Optional[List[CustomerShippingContactsDataResponse]] = None
+    __properties: ClassVar[List[str]] = ["has_more", "object", "data"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> CustomerResponseShippingContacts:
+    def from_json(cls, json_str: str) -> Self:
         """Create an instance of CustomerResponseShippingContacts from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude={
+            },
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of each item in data (list)
         _items = []
         if self.data:
             for _item in self.data:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['data'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> CustomerResponseShippingContacts:
+    def from_dict(cls, obj: Dict) -> Self:
         """Create an instance of CustomerResponseShippingContacts from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return CustomerResponseShippingContacts.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = CustomerResponseShippingContacts.parse_obj({
+        _obj = cls.model_validate({
             "has_more": obj.get("has_more"),
             "object": obj.get("object"),
             "data": [CustomerShippingContactsDataResponse.from_dict(_item) for _item in obj.get("data")] if obj.get("data") is not None else None
         })
         return _obj
 
+
```

### Comparing `conekta-6.0.1/conekta/models/customer_shipping_contacts.py` & `conekta-6.0.2/conekta/models/order_customer_info_response.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,97 +1,104 @@
 # coding: utf-8
 
 """
     Conekta API
 
-    Conekta sdk  # noqa: E501
+    Conekta sdk
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
-"""
+"""  # noqa: E501
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
 
-from typing import Optional
-from pydantic import BaseModel, Field, StrictBool, StrictStr
-from conekta.models.customer_shipping_contacts_address import CustomerShippingContactsAddress
+from typing import Any, ClassVar, Dict, List, Optional
+from pydantic import BaseModel, StrictBool, StrictStr
+from pydantic import Field
+try:
+    from typing import Self
+except ImportError:
+    from typing_extensions import Self
 
-class CustomerShippingContacts(BaseModel):
-    """
-    [Shipping](https://developers.conekta.com/v2.1.0/reference/createcustomershippingcontacts) details, required in case of sending a shipping. If we do not receive a shipping_contact on the order, the default shipping_contact of the customer will be used.
+class OrderCustomerInfoResponse(BaseModel):
     """
-    phone: Optional[StrictStr] = Field(None, description="Phone contact")
-    receiver: Optional[StrictStr] = Field(None, description="Name of the person who will receive the order")
-    between_streets: Optional[StrictStr] = Field(None, description="The street names between which the order will be delivered.")
-    address: CustomerShippingContactsAddress = Field(...)
-    parent_id: Optional[StrictStr] = None
-    default: Optional[StrictBool] = None
-    deleted: Optional[StrictBool] = None
-    __properties = ["phone", "receiver", "between_streets", "address", "parent_id", "default", "deleted"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    OrderCustomerInfoResponse
+    """ # noqa: E501
+    customer_custom_reference: Optional[StrictStr] = Field(default=None, description="Custom reference")
+    name: Optional[StrictStr] = None
+    email: Optional[StrictStr] = None
+    phone: Optional[StrictStr] = None
+    corporate: Optional[StrictBool] = False
+    object: Optional[StrictStr] = None
+    __properties: ClassVar[List[str]] = ["customer_custom_reference", "name", "email", "phone", "corporate", "object"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> CustomerShippingContacts:
-        """Create an instance of CustomerShippingContacts from a JSON string"""
+    def from_json(cls, json_str: str) -> Self:
+        """Create an instance of OrderCustomerInfoResponse from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
-        # override the default output from pydantic by calling `to_dict()` of address
-        if self.address:
-            _dict['address'] = self.address.to_dict()
-        # set to None if default (nullable) is None
-        # and __fields_set__ contains the field
-        if self.default is None and "default" in self.__fields_set__:
-            _dict['default'] = None
-
-        # set to None if deleted (nullable) is None
-        # and __fields_set__ contains the field
-        if self.deleted is None and "deleted" in self.__fields_set__:
-            _dict['deleted'] = None
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude={
+            },
+            exclude_none=True,
+        )
+        # set to None if customer_custom_reference (nullable) is None
+        # and model_fields_set contains the field
+        if self.customer_custom_reference is None and "customer_custom_reference" in self.model_fields_set:
+            _dict['customer_custom_reference'] = None
 
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> CustomerShippingContacts:
-        """Create an instance of CustomerShippingContacts from a dict"""
+    def from_dict(cls, obj: Dict) -> Self:
+        """Create an instance of OrderCustomerInfoResponse from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return CustomerShippingContacts.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = CustomerShippingContacts.parse_obj({
+        _obj = cls.model_validate({
+            "customer_custom_reference": obj.get("customer_custom_reference"),
+            "name": obj.get("name"),
+            "email": obj.get("email"),
             "phone": obj.get("phone"),
-            "receiver": obj.get("receiver"),
-            "between_streets": obj.get("between_streets"),
-            "address": CustomerShippingContactsAddress.from_dict(obj.get("address")) if obj.get("address") is not None else None,
-            "parent_id": obj.get("parent_id"),
-            "default": obj.get("default"),
-            "deleted": obj.get("deleted")
+            "corporate": obj.get("corporate") if obj.get("corporate") is not None else False,
+            "object": obj.get("object")
         })
         return _obj
 
+
```

### Comparing `conekta-6.0.1/conekta/models/customer_shipping_contacts_address.py` & `conekta-6.0.2/conekta/models/customer_shipping_contacts_response_address.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,88 +1,107 @@
 # coding: utf-8
 
 """
     Conekta API
 
-    Conekta sdk  # noqa: E501
+    Conekta sdk
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
-"""
+"""  # noqa: E501
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
 
-from typing import Optional
-from pydantic import BaseModel, Field, StrictBool, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from pydantic import BaseModel, StrictBool, StrictStr
+try:
+    from typing import Self
+except ImportError:
+    from typing_extensions import Self
 
-class CustomerShippingContactsAddress(BaseModel):
-    """
-    Address of the person who will receive the order
+class CustomerShippingContactsResponseAddress(BaseModel):
     """
+    CustomerShippingContactsResponseAddress
+    """ # noqa: E501
+    object: Optional[StrictStr] = None
     street1: Optional[StrictStr] = None
     street2: Optional[StrictStr] = None
     postal_code: Optional[StrictStr] = None
     city: Optional[StrictStr] = None
     state: Optional[StrictStr] = None
-    country: Optional[StrictStr] = Field(None, description="this field follows the [ISO 3166-1 alpha-2 standard](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2)")
+    country: Optional[StrictStr] = None
     residential: Optional[StrictBool] = None
-    __properties = ["street1", "street2", "postal_code", "city", "state", "country", "residential"]
+    __properties: ClassVar[List[str]] = ["object", "street1", "street2", "postal_code", "city", "state", "country", "residential"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True
+    }
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> CustomerShippingContactsAddress:
-        """Create an instance of CustomerShippingContactsAddress from a JSON string"""
+    def from_json(cls, json_str: str) -> Self:
+        """Create an instance of CustomerShippingContactsResponseAddress from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude={
+            },
+            exclude_none=True,
+        )
         # set to None if residential (nullable) is None
-        # and __fields_set__ contains the field
-        if self.residential is None and "residential" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.residential is None and "residential" in self.model_fields_set:
             _dict['residential'] = None
 
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> CustomerShippingContactsAddress:
-        """Create an instance of CustomerShippingContactsAddress from a dict"""
+    def from_dict(cls, obj: Dict) -> Self:
+        """Create an instance of CustomerShippingContactsResponseAddress from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return CustomerShippingContactsAddress.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = CustomerShippingContactsAddress.parse_obj({
+        _obj = cls.model_validate({
+            "object": obj.get("object"),
             "street1": obj.get("street1"),
             "street2": obj.get("street2"),
             "postal_code": obj.get("postal_code"),
             "city": obj.get("city"),
             "state": obj.get("state"),
             "country": obj.get("country"),
             "residential": obj.get("residential")
         })
         return _obj
 
+
```

### Comparing `conekta-6.0.1/conekta/models/customer_shipping_contacts_data_response.py` & `conekta-6.0.2/conekta/models/customer_shipping_contacts_data_response.py`

 * *Files 11% similar despite different names*

```diff
@@ -1,103 +1,123 @@
 # coding: utf-8
 
 """
     Conekta API
 
-    Conekta sdk  # noqa: E501
+    Conekta sdk
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
-"""
+"""  # noqa: E501
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
 
-from typing import Optional
-from pydantic import BaseModel, Field, StrictBool, StrictInt, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from pydantic import BaseModel, StrictBool, StrictInt, StrictStr
+from pydantic import Field
 from conekta.models.customer_shipping_contacts_address import CustomerShippingContactsAddress
+try:
+    from typing import Self
+except ImportError:
+    from typing_extensions import Self
 
 class CustomerShippingContactsDataResponse(BaseModel):
     """
     CustomerShippingContactsDataResponse
-    """
-    phone: Optional[StrictStr] = Field(None, description="Phone contact")
-    receiver: Optional[StrictStr] = Field(None, description="Name of the person who will receive the order")
-    between_streets: Optional[StrictStr] = Field(None, description="The street names between which the order will be delivered.")
-    address: CustomerShippingContactsAddress = Field(...)
+    """ # noqa: E501
+    phone: Optional[StrictStr] = Field(default=None, description="Phone contact")
+    receiver: Optional[StrictStr] = Field(default=None, description="Name of the person who will receive the order")
+    between_streets: Optional[StrictStr] = Field(default=None, description="The street names between which the order will be delivered.")
+    address: CustomerShippingContactsAddress
     parent_id: Optional[StrictStr] = None
     default: Optional[StrictBool] = None
     deleted: Optional[StrictBool] = None
-    id: StrictStr = Field(...)
-    object: StrictStr = Field(...)
-    created_at: StrictInt = Field(...)
-    __properties = ["phone", "receiver", "between_streets", "address", "parent_id", "default", "deleted", "id", "object", "created_at"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    metadata: Optional[Dict[str, Any]] = Field(default=None, description="Metadata associated with the shipping contact")
+    id: StrictStr
+    object: StrictStr
+    created_at: StrictInt
+    __properties: ClassVar[List[str]] = ["phone", "receiver", "between_streets", "address", "parent_id", "default", "deleted", "metadata", "id", "object", "created_at"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> CustomerShippingContactsDataResponse:
+    def from_json(cls, json_str: str) -> Self:
         """Create an instance of CustomerShippingContactsDataResponse from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude={
+            },
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of address
         if self.address:
             _dict['address'] = self.address.to_dict()
         # set to None if default (nullable) is None
-        # and __fields_set__ contains the field
-        if self.default is None and "default" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.default is None and "default" in self.model_fields_set:
             _dict['default'] = None
 
         # set to None if deleted (nullable) is None
-        # and __fields_set__ contains the field
-        if self.deleted is None and "deleted" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.deleted is None and "deleted" in self.model_fields_set:
             _dict['deleted'] = None
 
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> CustomerShippingContactsDataResponse:
+    def from_dict(cls, obj: Dict) -> Self:
         """Create an instance of CustomerShippingContactsDataResponse from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return CustomerShippingContactsDataResponse.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = CustomerShippingContactsDataResponse.parse_obj({
+        _obj = cls.model_validate({
             "phone": obj.get("phone"),
             "receiver": obj.get("receiver"),
             "between_streets": obj.get("between_streets"),
             "address": CustomerShippingContactsAddress.from_dict(obj.get("address")) if obj.get("address") is not None else None,
             "parent_id": obj.get("parent_id"),
             "default": obj.get("default"),
             "deleted": obj.get("deleted"),
+            "metadata": obj.get("metadata"),
             "id": obj.get("id"),
             "object": obj.get("object"),
             "created_at": obj.get("created_at")
         })
         return _obj
 
+
```

### Comparing `conekta-6.0.1/conekta/models/customer_shipping_contacts_data_response_all_of.py` & `conekta-6.0.2/conekta/models/customer_payment_method_request.py`

 * *Files 25% similar despite different names*

```diff
@@ -1,75 +1,89 @@
 # coding: utf-8
 
 """
     Conekta API
 
-    Conekta sdk  # noqa: E501
+    Conekta sdk
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
-"""
+"""  # noqa: E501
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
 
+from typing import Any, ClassVar, Dict, List
+from pydantic import BaseModel, StrictStr
+from pydantic import Field
+try:
+    from typing import Self
+except ImportError:
+    from typing_extensions import Self
 
-from pydantic import BaseModel, Field, StrictInt, StrictStr
-
-class CustomerShippingContactsDataResponseAllOf(BaseModel):
+class CustomerPaymentMethodRequest(BaseModel):
     """
-    CustomerShippingContactsDataResponseAllOf
-    """
-    id: StrictStr = Field(...)
-    object: StrictStr = Field(...)
-    created_at: StrictInt = Field(...)
-    __properties = ["id", "object", "created_at"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    Contains details of the payment methods that the customer has active or has used in Conekta
+    """ # noqa: E501
+    type: StrictStr = Field(description="Type of payment method")
+    __properties: ClassVar[List[str]] = ["type"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> CustomerShippingContactsDataResponseAllOf:
-        """Create an instance of CustomerShippingContactsDataResponseAllOf from a JSON string"""
+    def from_json(cls, json_str: str) -> Self:
+        """Create an instance of CustomerPaymentMethodRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude={
+            },
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> CustomerShippingContactsDataResponseAllOf:
-        """Create an instance of CustomerShippingContactsDataResponseAllOf from a dict"""
+    def from_dict(cls, obj: Dict) -> Self:
+        """Create an instance of CustomerPaymentMethodRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return CustomerShippingContactsDataResponseAllOf.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = CustomerShippingContactsDataResponseAllOf.parse_obj({
-            "id": obj.get("id"),
-            "object": obj.get("object"),
-            "created_at": obj.get("created_at")
+        _obj = cls.model_validate({
+            "type": obj.get("type")
         })
         return _obj
 
+
```

### Comparing `conekta-6.0.1/conekta/models/customer_shipping_contacts_response.py` & `conekta-6.0.2/conekta/models/order_response_shipping_contact.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,98 +1,118 @@
 # coding: utf-8
 
 """
     Conekta API
 
-    Conekta sdk  # noqa: E501
+    Conekta sdk
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
-"""
+"""  # noqa: E501
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
 
-from typing import Optional
+from typing import Any, ClassVar, Dict, List, Optional
 from pydantic import BaseModel, StrictBool, StrictInt, StrictStr
+from pydantic import Field
 from conekta.models.customer_shipping_contacts_response_address import CustomerShippingContactsResponseAddress
+try:
+    from typing import Self
+except ImportError:
+    from typing_extensions import Self
 
-class CustomerShippingContactsResponse(BaseModel):
-    """
-    Contains the detail of the shipping addresses that the client has active or has used in Conekta
+class OrderResponseShippingContact(BaseModel):
     """
+    OrderResponseShippingContact
+    """ # noqa: E501
+    created_at: Optional[StrictInt] = None
+    id: Optional[StrictStr] = None
+    object: Optional[StrictStr] = None
     phone: Optional[StrictStr] = None
     receiver: Optional[StrictStr] = None
     between_streets: Optional[StrictStr] = None
     address: Optional[CustomerShippingContactsResponseAddress] = None
     parent_id: Optional[StrictStr] = None
     default: Optional[StrictBool] = None
-    id: Optional[StrictStr] = None
-    created_at: Optional[StrictInt] = None
-    object: Optional[StrictStr] = None
+    metadata: Optional[Dict[str, Any]] = Field(default=None, description="Metadata associated with the shipping contact")
     deleted: Optional[StrictBool] = None
-    __properties = ["phone", "receiver", "between_streets", "address", "parent_id", "default", "id", "created_at", "object", "deleted"]
+    __properties: ClassVar[List[str]] = ["created_at", "id", "object", "phone", "receiver", "between_streets", "address", "parent_id", "default", "metadata", "deleted"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True
+    }
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> CustomerShippingContactsResponse:
-        """Create an instance of CustomerShippingContactsResponse from a JSON string"""
+    def from_json(cls, json_str: str) -> Self:
+        """Create an instance of OrderResponseShippingContact from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude={
+            },
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of address
         if self.address:
             _dict['address'] = self.address.to_dict()
         # set to None if between_streets (nullable) is None
-        # and __fields_set__ contains the field
-        if self.between_streets is None and "between_streets" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.between_streets is None and "between_streets" in self.model_fields_set:
             _dict['between_streets'] = None
 
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> CustomerShippingContactsResponse:
-        """Create an instance of CustomerShippingContactsResponse from a dict"""
+    def from_dict(cls, obj: Dict) -> Self:
+        """Create an instance of OrderResponseShippingContact from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return CustomerShippingContactsResponse.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = CustomerShippingContactsResponse.parse_obj({
+        _obj = cls.model_validate({
+            "created_at": obj.get("created_at"),
+            "id": obj.get("id"),
+            "object": obj.get("object"),
             "phone": obj.get("phone"),
             "receiver": obj.get("receiver"),
             "between_streets": obj.get("between_streets"),
             "address": CustomerShippingContactsResponseAddress.from_dict(obj.get("address")) if obj.get("address") is not None else None,
             "parent_id": obj.get("parent_id"),
             "default": obj.get("default"),
-            "id": obj.get("id"),
-            "created_at": obj.get("created_at"),
-            "object": obj.get("object"),
+            "metadata": obj.get("metadata"),
             "deleted": obj.get("deleted")
         })
         return _obj
 
+
```

### Comparing `conekta-6.0.1/conekta/models/customer_shipping_contacts_response_address.py` & `conekta-6.0.2/conekta/models/create_customer_fiscal_entities_response_all_of.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,85 +1,96 @@
 # coding: utf-8
 
 """
     Conekta API
 
-    Conekta sdk  # noqa: E501
+    Conekta sdk
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
-"""
+"""  # noqa: E501
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
 
-from typing import Optional
-from pydantic import BaseModel, StrictBool, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from pydantic import BaseModel, StrictBool, StrictInt, StrictStr
+try:
+    from typing import Self
+except ImportError:
+    from typing_extensions import Self
 
-class CustomerShippingContactsResponseAddress(BaseModel):
-    """
-    CustomerShippingContactsResponseAddress
+class CreateCustomerFiscalEntitiesResponseAllOf(BaseModel):
     """
-    object: Optional[StrictStr] = None
-    street1: Optional[StrictStr] = None
-    street2: Optional[StrictStr] = None
-    postal_code: Optional[StrictStr] = None
-    city: Optional[StrictStr] = None
-    state: Optional[StrictStr] = None
-    country: Optional[StrictStr] = None
-    residential: Optional[StrictBool] = None
-    __properties = ["object", "street1", "street2", "postal_code", "city", "state", "country", "residential"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    CreateCustomerFiscalEntitiesResponseAllOf
+    """ # noqa: E501
+    id: StrictStr
+    object: StrictStr
+    created_at: StrictInt
+    parent_id: Optional[StrictStr] = None
+    default: Optional[StrictBool] = None
+    __properties: ClassVar[List[str]] = ["id", "object", "created_at", "parent_id", "default"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> CustomerShippingContactsResponseAddress:
-        """Create an instance of CustomerShippingContactsResponseAddress from a JSON string"""
+    def from_json(cls, json_str: str) -> Self:
+        """Create an instance of CreateCustomerFiscalEntitiesResponseAllOf from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude={
+            },
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> CustomerShippingContactsResponseAddress:
-        """Create an instance of CustomerShippingContactsResponseAddress from a dict"""
+    def from_dict(cls, obj: Dict) -> Self:
+        """Create an instance of CreateCustomerFiscalEntitiesResponseAllOf from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return CustomerShippingContactsResponseAddress.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = CustomerShippingContactsResponseAddress.parse_obj({
+        _obj = cls.model_validate({
+            "id": obj.get("id"),
             "object": obj.get("object"),
-            "street1": obj.get("street1"),
-            "street2": obj.get("street2"),
-            "postal_code": obj.get("postal_code"),
-            "city": obj.get("city"),
-            "state": obj.get("state"),
-            "country": obj.get("country"),
-            "residential": obj.get("residential")
+            "created_at": obj.get("created_at"),
+            "parent_id": obj.get("parent_id"),
+            "default": obj.get("default")
         })
         return _obj
 
+
```

### Comparing `conekta-6.0.1/conekta/models/customer_update_fiscal_entities_request.py` & `conekta-6.0.2/conekta/models/token.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,85 +1,108 @@
 # coding: utf-8
 
 """
     Conekta API
 
-    Conekta sdk  # noqa: E501
+    Conekta sdk
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
-"""
+"""  # noqa: E501
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
 
-from typing import Any, Dict, Optional
-from pydantic import BaseModel, StrictStr
-from conekta.models.customer_fiscal_entities_request_address import CustomerFiscalEntitiesRequestAddress
+from typing import Any, ClassVar, Dict, List, Optional
+from pydantic import BaseModel
+from conekta.models.token_card import TokenCard
+from conekta.models.token_checkout import TokenCheckout
+try:
+    from typing import Self
+except ImportError:
+    from typing_extensions import Self
 
-class CustomerUpdateFiscalEntitiesRequest(BaseModel):
-    """
-    CustomerUpdateFiscalEntitiesRequest
+class Token(BaseModel):
     """
-    address: Optional[CustomerFiscalEntitiesRequestAddress] = None
-    tax_id: Optional[StrictStr] = None
-    email: Optional[StrictStr] = None
-    phone: Optional[StrictStr] = None
-    metadata: Optional[Dict[str, Dict[str, Any]]] = None
-    company_name: Optional[StrictStr] = None
-    __properties = ["address", "tax_id", "email", "phone", "metadata", "company_name"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    a token
+    """ # noqa: E501
+    card: Optional[TokenCard] = None
+    checkout: Optional[TokenCheckout] = None
+    __properties: ClassVar[List[str]] = ["card", "checkout"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> CustomerUpdateFiscalEntitiesRequest:
-        """Create an instance of CustomerUpdateFiscalEntitiesRequest from a JSON string"""
+    def from_json(cls, json_str: str) -> Self:
+        """Create an instance of Token from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
-        # override the default output from pydantic by calling `to_dict()` of address
-        if self.address:
-            _dict['address'] = self.address.to_dict()
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude={
+            },
+            exclude_none=True,
+        )
+        # override the default output from pydantic by calling `to_dict()` of card
+        if self.card:
+            _dict['card'] = self.card.to_dict()
+        # override the default output from pydantic by calling `to_dict()` of checkout
+        if self.checkout:
+            _dict['checkout'] = self.checkout.to_dict()
+        # set to None if card (nullable) is None
+        # and model_fields_set contains the field
+        if self.card is None and "card" in self.model_fields_set:
+            _dict['card'] = None
+
+        # set to None if checkout (nullable) is None
+        # and model_fields_set contains the field
+        if self.checkout is None and "checkout" in self.model_fields_set:
+            _dict['checkout'] = None
+
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> CustomerUpdateFiscalEntitiesRequest:
-        """Create an instance of CustomerUpdateFiscalEntitiesRequest from a dict"""
+    def from_dict(cls, obj: Dict) -> Self:
+        """Create an instance of Token from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return CustomerUpdateFiscalEntitiesRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = CustomerUpdateFiscalEntitiesRequest.parse_obj({
-            "address": CustomerFiscalEntitiesRequestAddress.from_dict(obj.get("address")) if obj.get("address") is not None else None,
-            "tax_id": obj.get("tax_id"),
-            "email": obj.get("email"),
-            "phone": obj.get("phone"),
-            "metadata": obj.get("metadata"),
-            "company_name": obj.get("company_name")
+        _obj = cls.model_validate({
+            "card": TokenCard.from_dict(obj.get("card")) if obj.get("card") is not None else None,
+            "checkout": TokenCheckout.from_dict(obj.get("checkout")) if obj.get("checkout") is not None else None
         })
         return _obj
 
+
```

### Comparing `conekta-6.0.1/conekta/models/customer_update_shipping_contacts.py` & `conekta-6.0.2/conekta/models/update_customer_fiscal_entities_response.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,97 +1,112 @@
 # coding: utf-8
 
 """
     Conekta API
 
-    Conekta sdk  # noqa: E501
+    Conekta sdk
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
-"""
+"""  # noqa: E501
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
 
-from typing import Optional
-from pydantic import BaseModel, Field, StrictBool, StrictStr
-from conekta.models.customer_shipping_contacts_address import CustomerShippingContactsAddress
+from typing import Any, ClassVar, Dict, List, Optional, Union
+from pydantic import BaseModel, StrictBool, StrictInt, StrictStr
+from conekta.models.customer_fiscal_entities_request_address import CustomerFiscalEntitiesRequestAddress
+try:
+    from typing import Self
+except ImportError:
+    from typing_extensions import Self
 
-class CustomerUpdateShippingContacts(BaseModel):
-    """
-    [Shipping](https://developers.conekta.com/v2.1.0/reference/createcustomershippingcontacts) details, required in case of sending a shipping. If we do not receive a shipping_contact on the order, the default shipping_contact of the customer will be used.
+class UpdateCustomerFiscalEntitiesResponse(BaseModel):
     """
-    phone: Optional[StrictStr] = Field(None, description="Phone contact")
-    receiver: Optional[StrictStr] = Field(None, description="Name of the person who will receive the order")
-    between_streets: Optional[StrictStr] = Field(None, description="The street names between which the order will be delivered.")
-    address: Optional[CustomerShippingContactsAddress] = None
+    UpdateCustomerFiscalEntitiesResponse
+    """ # noqa: E501
+    address: CustomerFiscalEntitiesRequestAddress
+    tax_id: Optional[StrictStr] = None
+    email: Optional[StrictStr] = None
+    phone: Optional[StrictStr] = None
+    metadata: Optional[Dict[str, Union[str, Any]]] = None
+    company_name: Optional[StrictStr] = None
+    id: StrictStr
+    object: StrictStr
+    created_at: StrictInt
     parent_id: Optional[StrictStr] = None
     default: Optional[StrictBool] = None
-    deleted: Optional[StrictBool] = None
-    __properties = ["phone", "receiver", "between_streets", "address", "parent_id", "default", "deleted"]
+    __properties: ClassVar[List[str]] = ["address", "tax_id", "email", "phone", "metadata", "company_name", "id", "object", "created_at", "parent_id", "default"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True
+    }
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> CustomerUpdateShippingContacts:
-        """Create an instance of CustomerUpdateShippingContacts from a JSON string"""
+    def from_json(cls, json_str: str) -> Self:
+        """Create an instance of UpdateCustomerFiscalEntitiesResponse from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude={
+            },
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of address
         if self.address:
             _dict['address'] = self.address.to_dict()
-        # set to None if default (nullable) is None
-        # and __fields_set__ contains the field
-        if self.default is None and "default" in self.__fields_set__:
-            _dict['default'] = None
-
-        # set to None if deleted (nullable) is None
-        # and __fields_set__ contains the field
-        if self.deleted is None and "deleted" in self.__fields_set__:
-            _dict['deleted'] = None
-
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> CustomerUpdateShippingContacts:
-        """Create an instance of CustomerUpdateShippingContacts from a dict"""
+    def from_dict(cls, obj: Dict) -> Self:
+        """Create an instance of UpdateCustomerFiscalEntitiesResponse from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return CustomerUpdateShippingContacts.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = CustomerUpdateShippingContacts.parse_obj({
+        _obj = cls.model_validate({
+            "address": CustomerFiscalEntitiesRequestAddress.from_dict(obj.get("address")) if obj.get("address") is not None else None,
+            "tax_id": obj.get("tax_id"),
+            "email": obj.get("email"),
             "phone": obj.get("phone"),
-            "receiver": obj.get("receiver"),
-            "between_streets": obj.get("between_streets"),
-            "address": CustomerShippingContactsAddress.from_dict(obj.get("address")) if obj.get("address") is not None else None,
+            "metadata": obj.get("metadata"),
+            "company_name": obj.get("company_name"),
+            "id": obj.get("id"),
+            "object": obj.get("object"),
+            "created_at": obj.get("created_at"),
             "parent_id": obj.get("parent_id"),
-            "default": obj.get("default"),
-            "deleted": obj.get("deleted")
+            "default": obj.get("default")
         })
         return _obj
 
+
```

### Comparing `conekta-6.0.1/conekta/models/customers_response.py` & `conekta-6.0.2/conekta/models/get_orders_response.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,97 +1,115 @@
 # coding: utf-8
 
 """
     Conekta API
 
-    Conekta sdk  # noqa: E501
+    Conekta sdk
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
-"""
+"""  # noqa: E501
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
 
-from typing import List, Optional
-from pydantic import BaseModel, Field, StrictBool, StrictStr, conlist
-from conekta.models.customer_response import CustomerResponse
+from typing import Any, ClassVar, Dict, List, Optional
+from pydantic import BaseModel, StrictBool, StrictStr
+from pydantic import Field
+from conekta.models.order_response import OrderResponse
+try:
+    from typing import Self
+except ImportError:
+    from typing_extensions import Self
 
-class CustomersResponse(BaseModel):
-    """
-    CustomersResponse
+class GetOrdersResponse(BaseModel):
     """
-    data: Optional[conlist(CustomerResponse)] = None
-    has_more: StrictBool = Field(..., description="Indicates if there are more pages to be requested")
-    object: StrictStr = Field(..., description="Object type, in this case is list")
-    next_page_url: Optional[StrictStr] = Field(None, description="URL of the next page.")
-    previous_page_url: Optional[StrictStr] = Field(None, description="Url of the previous page.")
-    __properties = ["data", "has_more", "object", "next_page_url", "previous_page_url"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    GetOrdersResponse
+    """ # noqa: E501
+    data: List[OrderResponse]
+    has_more: StrictBool = Field(description="Indicates if there are more pages to be requested")
+    object: StrictStr = Field(description="Object type, in this case is list")
+    next_page_url: Optional[StrictStr] = Field(default=None, description="URL of the next page.")
+    previous_page_url: Optional[StrictStr] = Field(default=None, description="Url of the previous page.")
+    __properties: ClassVar[List[str]] = ["data", "has_more", "object", "next_page_url", "previous_page_url"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> CustomersResponse:
-        """Create an instance of CustomersResponse from a JSON string"""
+    def from_json(cls, json_str: str) -> Self:
+        """Create an instance of GetOrdersResponse from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude={
+            },
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of each item in data (list)
         _items = []
         if self.data:
             for _item in self.data:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['data'] = _items
         # set to None if next_page_url (nullable) is None
-        # and __fields_set__ contains the field
-        if self.next_page_url is None and "next_page_url" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.next_page_url is None and "next_page_url" in self.model_fields_set:
             _dict['next_page_url'] = None
 
         # set to None if previous_page_url (nullable) is None
-        # and __fields_set__ contains the field
-        if self.previous_page_url is None and "previous_page_url" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.previous_page_url is None and "previous_page_url" in self.model_fields_set:
             _dict['previous_page_url'] = None
 
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> CustomersResponse:
-        """Create an instance of CustomersResponse from a dict"""
+    def from_dict(cls, obj: Dict) -> Self:
+        """Create an instance of GetOrdersResponse from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return CustomersResponse.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = CustomersResponse.parse_obj({
-            "data": [CustomerResponse.from_dict(_item) for _item in obj.get("data")] if obj.get("data") is not None else None,
+        _obj = cls.model_validate({
+            "data": [OrderResponse.from_dict(_item) for _item in obj.get("data")] if obj.get("data") is not None else None,
             "has_more": obj.get("has_more"),
             "object": obj.get("object"),
             "next_page_url": obj.get("next_page_url"),
             "previous_page_url": obj.get("previous_page_url")
         })
         return _obj
 
+
```

### Comparing `conekta-6.0.1/conekta/models/delete_api_keys_response.py` & `conekta-6.0.2/conekta/models/token_response.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,87 +1,106 @@
 # coding: utf-8
 
 """
     Conekta API
 
-    Conekta sdk  # noqa: E501
+    Conekta sdk
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
-"""
+"""  # noqa: E501
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
 
-from typing import Optional
-from pydantic import BaseModel, Field, StrictBool, StrictInt, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from pydantic import BaseModel, StrictBool, StrictStr
+from pydantic import Field
+from conekta.models.token_response_checkout import TokenResponseCheckout
+try:
+    from typing import Self
+except ImportError:
+    from typing_extensions import Self
 
-class DeleteApiKeysResponse(BaseModel):
-    """
-    DeleteApiKeysResponse
+class TokenResponse(BaseModel):
     """
-    active: Optional[StrictBool] = Field(None, description="Indicates if the api key is active")
-    created_at: Optional[StrictInt] = Field(None, description="Unix timestamp in seconds of when the api key was created")
-    description: Optional[StrictStr] = Field(None, description="A name or brief explanation of what this api key is used for")
-    livemode: Optional[StrictBool] = Field(None, description="Indicates if the api key is in production")
-    prefix: Optional[StrictStr] = Field(None, description="The first few characters of the authentication_token")
-    id: Optional[StrictStr] = Field(None, description="Unique identifier of the api key")
-    object: Optional[StrictStr] = Field(None, description="Object name, value is 'api_key'")
-    deleted: Optional[StrictBool] = None
-    role: Optional[StrictStr] = Field(None, description="Indicates if the api key is private or public")
-    __properties = ["active", "created_at", "description", "livemode", "prefix", "id", "object", "deleted", "role"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    token response
+    """ # noqa: E501
+    checkout: Optional[TokenResponseCheckout] = None
+    id: StrictStr = Field(description="Unique identifier for the token generated by Conekta.")
+    livemode: StrictBool = Field(description="Indicates whether the token is in live mode or test mode.")
+    object: StrictStr = Field(description="Indicates the type of object, in this case token")
+    used: StrictBool = Field(description="Indicates if the token has been used")
+    __properties: ClassVar[List[str]] = ["checkout", "id", "livemode", "object", "used"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> DeleteApiKeysResponse:
-        """Create an instance of DeleteApiKeysResponse from a JSON string"""
+    def from_json(cls, json_str: str) -> Self:
+        """Create an instance of TokenResponse from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude={
+            },
+            exclude_none=True,
+        )
+        # override the default output from pydantic by calling `to_dict()` of checkout
+        if self.checkout:
+            _dict['checkout'] = self.checkout.to_dict()
+        # set to None if checkout (nullable) is None
+        # and model_fields_set contains the field
+        if self.checkout is None and "checkout" in self.model_fields_set:
+            _dict['checkout'] = None
+
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> DeleteApiKeysResponse:
-        """Create an instance of DeleteApiKeysResponse from a dict"""
+    def from_dict(cls, obj: Dict) -> Self:
+        """Create an instance of TokenResponse from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return DeleteApiKeysResponse.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = DeleteApiKeysResponse.parse_obj({
-            "active": obj.get("active"),
-            "created_at": obj.get("created_at"),
-            "description": obj.get("description"),
-            "livemode": obj.get("livemode"),
-            "prefix": obj.get("prefix"),
+        _obj = cls.model_validate({
+            "checkout": TokenResponseCheckout.from_dict(obj.get("checkout")) if obj.get("checkout") is not None else None,
             "id": obj.get("id"),
+            "livemode": obj.get("livemode"),
             "object": obj.get("object"),
-            "deleted": obj.get("deleted"),
-            "role": obj.get("role")
+            "used": obj.get("used")
         })
         return _obj
 
+
```

### Comparing `conekta-6.0.1/conekta/models/deleted_whitelist_rule_response.py` & `conekta-6.0.2/conekta/models/risk_rules_data.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,77 +1,101 @@
 # coding: utf-8
 
 """
     Conekta API
 
-    Conekta sdk  # noqa: E501
+    Conekta sdk
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
-"""
+"""  # noqa: E501
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
 
-from typing import Optional
-from pydantic import BaseModel, Field, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from pydantic import BaseModel, StrictBool, StrictStr
+from pydantic import Field
+try:
+    from typing import Self
+except ImportError:
+    from typing_extensions import Self
 
-class DeletedWhitelistRuleResponse(BaseModel):
-    """
-    DeletedWhitelistRuleResponse
+class RiskRulesData(BaseModel):
     """
-    id: Optional[StrictStr] = Field(None, description="Whitelist rule id")
-    field: Optional[StrictStr] = Field(None, description="field used for whitelists rule deleted")
-    value: Optional[StrictStr] = Field(None, description="value used for whitelists rule deleted")
-    description: Optional[StrictStr] = Field(None, description="use an description for whitelisted rule")
-    __properties = ["id", "field", "value", "description"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    RiskRulesData
+    """ # noqa: E501
+    id: Optional[StrictStr] = Field(default=None, description="rule id")
+    field: Optional[StrictStr] = Field(default=None, description="field to be used for the rule")
+    created_at: Optional[StrictStr] = Field(default=None, description="rule creation date")
+    value: Optional[StrictStr] = Field(default=None, description="value to be used for the rule")
+    is_global: Optional[StrictBool] = Field(default=None, description="if the rule is global")
+    is_test: Optional[StrictBool] = Field(default=None, description="if the rule is test")
+    description: Optional[StrictStr] = Field(default=None, description="description of the rule")
+    __properties: ClassVar[List[str]] = ["id", "field", "created_at", "value", "is_global", "is_test", "description"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> DeletedWhitelistRuleResponse:
-        """Create an instance of DeletedWhitelistRuleResponse from a JSON string"""
+    def from_json(cls, json_str: str) -> Self:
+        """Create an instance of RiskRulesData from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude={
+            },
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> DeletedWhitelistRuleResponse:
-        """Create an instance of DeletedWhitelistRuleResponse from a dict"""
+    def from_dict(cls, obj: Dict) -> Self:
+        """Create an instance of RiskRulesData from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return DeletedWhitelistRuleResponse.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = DeletedWhitelistRuleResponse.parse_obj({
+        _obj = cls.model_validate({
             "id": obj.get("id"),
             "field": obj.get("field"),
+            "created_at": obj.get("created_at"),
             "value": obj.get("value"),
+            "is_global": obj.get("is_global"),
+            "is_test": obj.get("is_test"),
             "description": obj.get("description")
         })
         return _obj
 
+
```

### Comparing `conekta-6.0.1/conekta/models/details.py` & `conekta-6.0.2/conekta/models/details.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,79 +1,96 @@
 # coding: utf-8
 
 """
     Conekta API
 
-    Conekta sdk  # noqa: E501
+    Conekta sdk
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
-"""
+"""  # noqa: E501
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
 
-from typing import List, Optional
-from pydantic import BaseModel, conlist
+from typing import Any, ClassVar, Dict, List, Optional
+from pydantic import BaseModel
 from conekta.models.details_error import DetailsError
+try:
+    from typing import Self
+except ImportError:
+    from typing_extensions import Self
 
 class Details(BaseModel):
     """
     Details
-    """
-    details: Optional[conlist(DetailsError)] = None
-    __properties = ["details"]
+    """ # noqa: E501
+    details: Optional[List[DetailsError]] = None
+    __properties: ClassVar[List[str]] = ["details"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True
+    }
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> Details:
+    def from_json(cls, json_str: str) -> Self:
         """Create an instance of Details from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude={
+            },
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of each item in details (list)
         _items = []
         if self.details:
             for _item in self.details:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['details'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> Details:
+    def from_dict(cls, obj: Dict) -> Self:
         """Create an instance of Details from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return Details.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = Details.parse_obj({
+        _obj = cls.model_validate({
             "details": [DetailsError.from_dict(_item) for _item in obj.get("details")] if obj.get("details") is not None else None
         })
         return _obj
 
+
```

### Comparing `conekta-6.0.1/conekta/models/details_error.py` & `conekta-6.0.2/conekta/models/update_payment_methods.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,82 +1,88 @@
 # coding: utf-8
 
 """
     Conekta API
 
-    Conekta sdk  # noqa: E501
+    Conekta sdk
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
-"""
+"""  # noqa: E501
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
 
-from typing import Optional
+from typing import Any, ClassVar, Dict, List, Optional
 from pydantic import BaseModel, StrictStr
+try:
+    from typing import Self
+except ImportError:
+    from typing_extensions import Self
 
-class DetailsError(BaseModel):
-    """
-    DetailsError
+class UpdatePaymentMethods(BaseModel):
     """
-    code: Optional[StrictStr] = None
-    param: Optional[StrictStr] = None
-    message: Optional[StrictStr] = None
-    debug_message: Optional[StrictStr] = None
-    __properties = ["code", "param", "message", "debug_message"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    UpdatePaymentMethods
+    """ # noqa: E501
+    name: Optional[StrictStr] = None
+    __properties: ClassVar[List[str]] = ["name"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> DetailsError:
-        """Create an instance of DetailsError from a JSON string"""
+    def from_json(cls, json_str: str) -> Self:
+        """Create an instance of UpdatePaymentMethods from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
-        # set to None if param (nullable) is None
-        # and __fields_set__ contains the field
-        if self.param is None and "param" in self.__fields_set__:
-            _dict['param'] = None
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
 
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude={
+            },
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> DetailsError:
-        """Create an instance of DetailsError from a dict"""
+    def from_dict(cls, obj: Dict) -> Self:
+        """Create an instance of UpdatePaymentMethods from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return DetailsError.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = DetailsError.parse_obj({
-            "code": obj.get("code"),
-            "param": obj.get("param"),
-            "message": obj.get("message"),
-            "debug_message": obj.get("debug_message")
+        _obj = cls.model_validate({
+            "name": obj.get("name")
         })
         return _obj
 
+
```

### Comparing `conekta-6.0.1/conekta/models/discount_lines_data_response.py` & `conekta-6.0.2/conekta/models/discount_lines_response.py`

 * *Files 23% similar despite different names*

```diff
@@ -1,81 +1,100 @@
 # coding: utf-8
 
 """
     Conekta API
 
-    Conekta sdk  # noqa: E501
+    Conekta sdk
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
-"""
+"""  # noqa: E501
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
 
+from typing import Any, ClassVar, Dict, List
+from pydantic import BaseModel, StrictStr
+from pydantic import Field
+from typing_extensions import Annotated
+try:
+    from typing import Self
+except ImportError:
+    from typing_extensions import Self
 
-from pydantic import BaseModel, Field, StrictStr, conint
-
-class DiscountLinesDataResponse(BaseModel):
+class DiscountLinesResponse(BaseModel):
     """
-    DiscountLinesDataResponse
-    """
-    amount: conint(strict=True, ge=0) = Field(..., description="The amount to be deducted from the total sum of all payments, in cents.")
-    code: StrictStr = Field(..., description="Discount code.")
-    type: StrictStr = Field(..., description="It can be 'loyalty', 'campaign', 'coupon' o 'sign'")
-    id: StrictStr = Field(..., description="The discount line id")
-    object: StrictStr = Field(..., description="The object name")
-    parent_id: StrictStr = Field(..., description="The order id")
-    __properties = ["amount", "code", "type", "id", "object", "parent_id"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    DiscountLinesResponse
+    """ # noqa: E501
+    amount: Annotated[int, Field(strict=True, ge=0)] = Field(description="The amount to be deducted from the total sum of all payments, in cents.")
+    code: StrictStr = Field(description="Discount code.")
+    type: StrictStr = Field(description="It can be 'loyalty', 'campaign', 'coupon' o 'sign'")
+    id: StrictStr = Field(description="The discount line id")
+    object: StrictStr = Field(description="The object name")
+    parent_id: StrictStr = Field(description="The order id")
+    __properties: ClassVar[List[str]] = ["amount", "code", "type", "id", "object", "parent_id"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> DiscountLinesDataResponse:
-        """Create an instance of DiscountLinesDataResponse from a JSON string"""
+    def from_json(cls, json_str: str) -> Self:
+        """Create an instance of DiscountLinesResponse from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude={
+            },
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> DiscountLinesDataResponse:
-        """Create an instance of DiscountLinesDataResponse from a dict"""
+    def from_dict(cls, obj: Dict) -> Self:
+        """Create an instance of DiscountLinesResponse from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return DiscountLinesDataResponse.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = DiscountLinesDataResponse.parse_obj({
+        _obj = cls.model_validate({
             "amount": obj.get("amount"),
             "code": obj.get("code"),
             "type": obj.get("type"),
             "id": obj.get("id"),
             "object": obj.get("object"),
             "parent_id": obj.get("parent_id")
         })
         return _obj
 
+
```

### Comparing `conekta-6.0.1/conekta/models/error.py` & `conekta-6.0.2/conekta/models/error.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,90 +1,108 @@
 # coding: utf-8
 
 """
     Conekta API
 
-    Conekta sdk  # noqa: E501
+    Conekta sdk
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
-"""
+"""  # noqa: E501
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
 
-from typing import List, Optional
-from pydantic import BaseModel, Field, StrictStr, conlist
+from typing import Any, ClassVar, Dict, List, Optional
+from pydantic import BaseModel, StrictStr
+from pydantic import Field
 from conekta.models.details_error import DetailsError
+try:
+    from typing import Self
+except ImportError:
+    from typing_extensions import Self
 
 class Error(BaseModel):
     """
     err model
-    """
-    details: Optional[conlist(DetailsError)] = None
-    log_id: Optional[StrictStr] = Field(None, description="log id")
+    """ # noqa: E501
+    details: Optional[List[DetailsError]] = None
+    log_id: Optional[StrictStr] = Field(default=None, description="log id")
     type: Optional[StrictStr] = None
     object: Optional[StrictStr] = None
-    __properties = ["details", "log_id", "type", "object"]
+    __properties: ClassVar[List[str]] = ["details", "log_id", "type", "object"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True
+    }
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> Error:
+    def from_json(cls, json_str: str) -> Self:
         """Create an instance of Error from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude={
+            },
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of each item in details (list)
         _items = []
         if self.details:
             for _item in self.details:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['details'] = _items
         # set to None if log_id (nullable) is None
-        # and __fields_set__ contains the field
-        if self.log_id is None and "log_id" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.log_id is None and "log_id" in self.model_fields_set:
             _dict['log_id'] = None
 
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> Error:
+    def from_dict(cls, obj: Dict) -> Self:
         """Create an instance of Error from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return Error.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = Error.parse_obj({
+        _obj = cls.model_validate({
             "details": [DetailsError.from_dict(_item) for _item in obj.get("details")] if obj.get("details") is not None else None,
             "log_id": obj.get("log_id"),
             "type": obj.get("type"),
             "object": obj.get("object")
         })
         return _obj
 
+
```

### Comparing `conekta-6.0.1/conekta/models/error_all_of.py` & `conekta-6.0.2/conekta/models/error_all_of.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,80 +1,98 @@
 # coding: utf-8
 
 """
     Conekta API
 
-    Conekta sdk  # noqa: E501
+    Conekta sdk
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
-"""
+"""  # noqa: E501
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
 
-from typing import Optional
-from pydantic import BaseModel, Field, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from pydantic import BaseModel, StrictStr
+from pydantic import Field
+try:
+    from typing import Self
+except ImportError:
+    from typing_extensions import Self
 
 class ErrorAllOf(BaseModel):
     """
     ErrorAllOf
-    """
-    log_id: Optional[StrictStr] = Field(None, description="log id")
+    """ # noqa: E501
+    log_id: Optional[StrictStr] = Field(default=None, description="log id")
     type: Optional[StrictStr] = None
     object: Optional[StrictStr] = None
-    __properties = ["log_id", "type", "object"]
+    __properties: ClassVar[List[str]] = ["log_id", "type", "object"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True
+    }
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> ErrorAllOf:
+    def from_json(cls, json_str: str) -> Self:
         """Create an instance of ErrorAllOf from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude={
+            },
+            exclude_none=True,
+        )
         # set to None if log_id (nullable) is None
-        # and __fields_set__ contains the field
-        if self.log_id is None and "log_id" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.log_id is None and "log_id" in self.model_fields_set:
             _dict['log_id'] = None
 
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> ErrorAllOf:
+    def from_dict(cls, obj: Dict) -> Self:
         """Create an instance of ErrorAllOf from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return ErrorAllOf.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = ErrorAllOf.parse_obj({
+        _obj = cls.model_validate({
             "log_id": obj.get("log_id"),
             "type": obj.get("type"),
             "object": obj.get("object")
         })
         return _obj
 
+
```

### Comparing `conekta-6.0.1/conekta/models/event_response.py` & `conekta-6.0.2/conekta/models/event_response.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,93 +1,110 @@
 # coding: utf-8
 
 """
     Conekta API
 
-    Conekta sdk  # noqa: E501
+    Conekta sdk
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
-"""
+"""  # noqa: E501
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
 
-from typing import Any, Dict, List, Optional
-from pydantic import BaseModel, StrictBool, StrictInt, StrictStr, conlist
+from typing import Any, ClassVar, Dict, List, Optional
+from pydantic import BaseModel, StrictBool, StrictInt, StrictStr
 from conekta.models.webhook_log import WebhookLog
+try:
+    from typing import Self
+except ImportError:
+    from typing_extensions import Self
 
 class EventResponse(BaseModel):
     """
     event model
-    """
+    """ # noqa: E501
     created_at: Optional[StrictInt] = None
     data: Optional[Dict[str, Any]] = None
     id: Optional[StrictStr] = None
     livemode: Optional[StrictBool] = None
     object: Optional[StrictStr] = None
     type: Optional[StrictStr] = None
-    webhook_logs: Optional[conlist(WebhookLog)] = None
+    webhook_logs: Optional[List[WebhookLog]] = None
     webhook_status: Optional[StrictStr] = None
-    __properties = ["created_at", "data", "id", "livemode", "object", "type", "webhook_logs", "webhook_status"]
+    __properties: ClassVar[List[str]] = ["created_at", "data", "id", "livemode", "object", "type", "webhook_logs", "webhook_status"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True
+    }
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> EventResponse:
+    def from_json(cls, json_str: str) -> Self:
         """Create an instance of EventResponse from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude={
+            },
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of each item in webhook_logs (list)
         _items = []
         if self.webhook_logs:
             for _item in self.webhook_logs:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['webhook_logs'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> EventResponse:
+    def from_dict(cls, obj: Dict) -> Self:
         """Create an instance of EventResponse from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return EventResponse.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = EventResponse.parse_obj({
+        _obj = cls.model_validate({
             "created_at": obj.get("created_at"),
             "data": obj.get("data"),
             "id": obj.get("id"),
             "livemode": obj.get("livemode"),
             "object": obj.get("object"),
             "type": obj.get("type"),
             "webhook_logs": [WebhookLog.from_dict(_item) for _item in obj.get("webhook_logs")] if obj.get("webhook_logs") is not None else None,
             "webhook_status": obj.get("webhook_status")
         })
         return _obj
 
+
```

### Comparing `conekta-6.0.1/conekta/models/events_resend_response.py` & `conekta-6.0.2/conekta/models/payment_method_cash_response.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,81 +1,106 @@
 # coding: utf-8
 
 """
     Conekta API
 
-    Conekta sdk  # noqa: E501
+    Conekta sdk
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
-"""
+"""  # noqa: E501
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
 
-from typing import Any, Dict, Optional
+from typing import Any, ClassVar, Dict, List, Optional
 from pydantic import BaseModel, StrictInt, StrictStr
+try:
+    from typing import Self
+except ImportError:
+    from typing_extensions import Self
 
-class EventsResendResponse(BaseModel):
-    """
-    event model
+class PaymentMethodCashResponse(BaseModel):
     """
-    failed_attempts: Optional[StrictInt] = None
-    id: Optional[StrictStr] = None
-    last_attempted_at: Optional[StrictInt] = None
-    last_http_response_status: Optional[StrictInt] = None
-    response_data: Optional[Dict[str, Any]] = None
-    url: Optional[StrictStr] = None
-    __properties = ["failed_attempts", "id", "last_attempted_at", "last_http_response_status", "response_data", "url"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    PaymentMethodCashResponse
+    """ # noqa: E501
+    type: StrictStr
+    id: StrictStr
+    object: StrictStr
+    created_at: StrictInt
+    parent_id: Optional[StrictStr] = None
+    reference: Optional[StrictStr] = None
+    barcode: Optional[StrictStr] = None
+    barcode_url: Optional[StrictStr] = None
+    expires_at: Optional[StrictInt] = None
+    provider: Optional[StrictStr] = None
+    __properties: ClassVar[List[str]] = ["type", "id", "object", "created_at", "parent_id", "reference", "barcode", "barcode_url", "expires_at", "provider"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> EventsResendResponse:
-        """Create an instance of EventsResendResponse from a JSON string"""
+    def from_json(cls, json_str: str) -> Self:
+        """Create an instance of PaymentMethodCashResponse from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude={
+            },
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> EventsResendResponse:
-        """Create an instance of EventsResendResponse from a dict"""
+    def from_dict(cls, obj: Dict) -> Self:
+        """Create an instance of PaymentMethodCashResponse from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return EventsResendResponse.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = EventsResendResponse.parse_obj({
-            "failed_attempts": obj.get("failed_attempts"),
+        _obj = cls.model_validate({
+            "type": obj.get("type"),
             "id": obj.get("id"),
-            "last_attempted_at": obj.get("last_attempted_at"),
-            "last_http_response_status": obj.get("last_http_response_status"),
-            "response_data": obj.get("response_data"),
-            "url": obj.get("url")
+            "object": obj.get("object"),
+            "created_at": obj.get("created_at"),
+            "parent_id": obj.get("parent_id"),
+            "reference": obj.get("reference"),
+            "barcode": obj.get("barcode"),
+            "barcode_url": obj.get("barcode_url"),
+            "expires_at": obj.get("expires_at"),
+            "provider": obj.get("provider")
         })
         return _obj
 
+
```

### Comparing `conekta-6.0.1/conekta/models/get_api_keys_response.py` & `conekta-6.0.2/conekta/models/customers_response.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,97 +1,115 @@
 # coding: utf-8
 
 """
     Conekta API
 
-    Conekta sdk  # noqa: E501
+    Conekta sdk
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
-"""
+"""  # noqa: E501
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
 
-from typing import List, Optional
-from pydantic import BaseModel, Field, StrictBool, StrictStr, conlist
-from conekta.models.api_key_response import ApiKeyResponse
+from typing import Any, ClassVar, Dict, List, Optional
+from pydantic import BaseModel, StrictBool, StrictStr
+from pydantic import Field
+from conekta.models.customer_response import CustomerResponse
+try:
+    from typing import Self
+except ImportError:
+    from typing_extensions import Self
 
-class GetApiKeysResponse(BaseModel):
-    """
-    GetApiKeysResponse
+class CustomersResponse(BaseModel):
     """
-    next_page_url: Optional[StrictStr] = Field(None, description="URL of the next page.")
-    previous_page_url: Optional[StrictStr] = Field(None, description="Url of the previous page.")
-    has_more: StrictBool = Field(..., description="Indicates if there are more pages to be requested")
-    object: StrictStr = Field(..., description="Object type, in this case is list")
-    data: Optional[conlist(ApiKeyResponse)] = None
-    __properties = ["next_page_url", "previous_page_url", "has_more", "object", "data"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    CustomersResponse
+    """ # noqa: E501
+    data: Optional[List[CustomerResponse]] = None
+    has_more: StrictBool = Field(description="Indicates if there are more pages to be requested")
+    object: StrictStr = Field(description="Object type, in this case is list")
+    next_page_url: Optional[StrictStr] = Field(default=None, description="URL of the next page.")
+    previous_page_url: Optional[StrictStr] = Field(default=None, description="Url of the previous page.")
+    __properties: ClassVar[List[str]] = ["data", "has_more", "object", "next_page_url", "previous_page_url"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> GetApiKeysResponse:
-        """Create an instance of GetApiKeysResponse from a JSON string"""
+    def from_json(cls, json_str: str) -> Self:
+        """Create an instance of CustomersResponse from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude={
+            },
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of each item in data (list)
         _items = []
         if self.data:
             for _item in self.data:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['data'] = _items
         # set to None if next_page_url (nullable) is None
-        # and __fields_set__ contains the field
-        if self.next_page_url is None and "next_page_url" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.next_page_url is None and "next_page_url" in self.model_fields_set:
             _dict['next_page_url'] = None
 
         # set to None if previous_page_url (nullable) is None
-        # and __fields_set__ contains the field
-        if self.previous_page_url is None and "previous_page_url" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.previous_page_url is None and "previous_page_url" in self.model_fields_set:
             _dict['previous_page_url'] = None
 
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> GetApiKeysResponse:
-        """Create an instance of GetApiKeysResponse from a dict"""
+    def from_dict(cls, obj: Dict) -> Self:
+        """Create an instance of CustomersResponse from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return GetApiKeysResponse.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = GetApiKeysResponse.parse_obj({
-            "next_page_url": obj.get("next_page_url"),
-            "previous_page_url": obj.get("previous_page_url"),
+        _obj = cls.model_validate({
+            "data": [CustomerResponse.from_dict(_item) for _item in obj.get("data")] if obj.get("data") is not None else None,
             "has_more": obj.get("has_more"),
             "object": obj.get("object"),
-            "data": [ApiKeyResponse.from_dict(_item) for _item in obj.get("data")] if obj.get("data") is not None else None
+            "next_page_url": obj.get("next_page_url"),
+            "previous_page_url": obj.get("previous_page_url")
         })
         return _obj
 
+
```

### Comparing `conekta-6.0.1/conekta/models/get_charges_response.py` & `conekta-6.0.2/conekta/models/checkouts_response.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,97 +1,115 @@
 # coding: utf-8
 
 """
     Conekta API
 
-    Conekta sdk  # noqa: E501
+    Conekta sdk
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
-"""
+"""  # noqa: E501
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
 
-from typing import List, Optional
-from pydantic import BaseModel, Field, StrictBool, StrictStr, conlist
-from conekta.models.charge_response import ChargeResponse
+from typing import Any, ClassVar, Dict, List, Optional
+from pydantic import BaseModel, StrictBool, StrictStr
+from pydantic import Field
+from conekta.models.checkout_response import CheckoutResponse
+try:
+    from typing import Self
+except ImportError:
+    from typing_extensions import Self
 
-class GetChargesResponse(BaseModel):
-    """
-    GetChargesResponse
+class CheckoutsResponse(BaseModel):
     """
-    has_more: StrictBool = Field(..., description="Indicates if there are more pages to be requested")
-    object: StrictStr = Field(..., description="Object type, in this case is list")
-    next_page_url: Optional[StrictStr] = Field(None, description="URL of the next page.")
-    previous_page_url: Optional[StrictStr] = Field(None, description="Url of the previous page.")
-    data: Optional[conlist(ChargeResponse)] = None
-    __properties = ["has_more", "object", "next_page_url", "previous_page_url", "data"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    CheckoutsResponse
+    """ # noqa: E501
+    has_more: StrictBool = Field(description="Indicates if there are more pages to be requested")
+    object: StrictStr = Field(description="Object type, in this case is list")
+    next_page_url: Optional[StrictStr] = Field(default=None, description="URL of the next page.")
+    previous_page_url: Optional[StrictStr] = Field(default=None, description="Url of the previous page.")
+    data: Optional[List[CheckoutResponse]] = None
+    __properties: ClassVar[List[str]] = ["has_more", "object", "next_page_url", "previous_page_url", "data"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> GetChargesResponse:
-        """Create an instance of GetChargesResponse from a JSON string"""
+    def from_json(cls, json_str: str) -> Self:
+        """Create an instance of CheckoutsResponse from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude={
+            },
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of each item in data (list)
         _items = []
         if self.data:
             for _item in self.data:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['data'] = _items
         # set to None if next_page_url (nullable) is None
-        # and __fields_set__ contains the field
-        if self.next_page_url is None and "next_page_url" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.next_page_url is None and "next_page_url" in self.model_fields_set:
             _dict['next_page_url'] = None
 
         # set to None if previous_page_url (nullable) is None
-        # and __fields_set__ contains the field
-        if self.previous_page_url is None and "previous_page_url" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.previous_page_url is None and "previous_page_url" in self.model_fields_set:
             _dict['previous_page_url'] = None
 
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> GetChargesResponse:
-        """Create an instance of GetChargesResponse from a dict"""
+    def from_dict(cls, obj: Dict) -> Self:
+        """Create an instance of CheckoutsResponse from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return GetChargesResponse.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = GetChargesResponse.parse_obj({
+        _obj = cls.model_validate({
             "has_more": obj.get("has_more"),
             "object": obj.get("object"),
             "next_page_url": obj.get("next_page_url"),
             "previous_page_url": obj.get("previous_page_url"),
-            "data": [ChargeResponse.from_dict(_item) for _item in obj.get("data")] if obj.get("data") is not None else None
+            "data": [CheckoutResponse.from_dict(_item) for _item in obj.get("data")] if obj.get("data") is not None else None
         })
         return _obj
 
+
```

### Comparing `conekta-6.0.1/conekta/models/get_charges_response_all_of.py` & `conekta-6.0.2/conekta/models/get_charges_response_all_of.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,79 +1,96 @@
 # coding: utf-8
 
 """
     Conekta API
 
-    Conekta sdk  # noqa: E501
+    Conekta sdk
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
-"""
+"""  # noqa: E501
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
 
-from typing import List, Optional
-from pydantic import BaseModel, conlist
+from typing import Any, ClassVar, Dict, List, Optional
+from pydantic import BaseModel
 from conekta.models.charge_response import ChargeResponse
+try:
+    from typing import Self
+except ImportError:
+    from typing_extensions import Self
 
 class GetChargesResponseAllOf(BaseModel):
     """
     GetChargesResponseAllOf
-    """
-    data: Optional[conlist(ChargeResponse)] = None
-    __properties = ["data"]
+    """ # noqa: E501
+    data: Optional[List[ChargeResponse]] = None
+    __properties: ClassVar[List[str]] = ["data"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True
+    }
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> GetChargesResponseAllOf:
+    def from_json(cls, json_str: str) -> Self:
         """Create an instance of GetChargesResponseAllOf from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude={
+            },
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of each item in data (list)
         _items = []
         if self.data:
             for _item in self.data:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['data'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> GetChargesResponseAllOf:
+    def from_dict(cls, obj: Dict) -> Self:
         """Create an instance of GetChargesResponseAllOf from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return GetChargesResponseAllOf.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = GetChargesResponseAllOf.parse_obj({
+        _obj = cls.model_validate({
             "data": [ChargeResponse.from_dict(_item) for _item in obj.get("data")] if obj.get("data") is not None else None
         })
         return _obj
 
+
```

### Comparing `conekta-6.0.1/conekta/models/get_companies_response.py` & `conekta-6.0.2/conekta/models/get_events_response.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,97 +1,115 @@
 # coding: utf-8
 
 """
     Conekta API
 
-    Conekta sdk  # noqa: E501
+    Conekta sdk
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
-"""
+"""  # noqa: E501
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
 
-from typing import List, Optional
-from pydantic import BaseModel, Field, StrictBool, StrictStr, conlist
-from conekta.models.company_response import CompanyResponse
+from typing import Any, ClassVar, Dict, List, Optional
+from pydantic import BaseModel, StrictBool, StrictStr
+from pydantic import Field
+from conekta.models.event_response import EventResponse
+try:
+    from typing import Self
+except ImportError:
+    from typing_extensions import Self
 
-class GetCompaniesResponse(BaseModel):
-    """
-    GetCompaniesResponse
+class GetEventsResponse(BaseModel):
     """
-    has_more: StrictBool = Field(..., description="Indicates if there are more pages to be requested")
-    object: StrictStr = Field(..., description="Object type, in this case is list")
-    next_page_url: Optional[StrictStr] = Field(None, description="URL of the next page.")
-    previous_page_url: Optional[StrictStr] = Field(None, description="Url of the previous page.")
-    data: Optional[conlist(CompanyResponse)] = None
-    __properties = ["has_more", "object", "next_page_url", "previous_page_url", "data"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    GetEventsResponse
+    """ # noqa: E501
+    has_more: StrictBool = Field(description="Indicates if there are more pages to be requested")
+    object: StrictStr = Field(description="Object type, in this case is list")
+    next_page_url: Optional[StrictStr] = Field(default=None, description="URL of the next page.")
+    previous_page_url: Optional[StrictStr] = Field(default=None, description="Url of the previous page.")
+    data: Optional[List[EventResponse]] = None
+    __properties: ClassVar[List[str]] = ["has_more", "object", "next_page_url", "previous_page_url", "data"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> GetCompaniesResponse:
-        """Create an instance of GetCompaniesResponse from a JSON string"""
+    def from_json(cls, json_str: str) -> Self:
+        """Create an instance of GetEventsResponse from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude={
+            },
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of each item in data (list)
         _items = []
         if self.data:
             for _item in self.data:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['data'] = _items
         # set to None if next_page_url (nullable) is None
-        # and __fields_set__ contains the field
-        if self.next_page_url is None and "next_page_url" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.next_page_url is None and "next_page_url" in self.model_fields_set:
             _dict['next_page_url'] = None
 
         # set to None if previous_page_url (nullable) is None
-        # and __fields_set__ contains the field
-        if self.previous_page_url is None and "previous_page_url" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.previous_page_url is None and "previous_page_url" in self.model_fields_set:
             _dict['previous_page_url'] = None
 
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> GetCompaniesResponse:
-        """Create an instance of GetCompaniesResponse from a dict"""
+    def from_dict(cls, obj: Dict) -> Self:
+        """Create an instance of GetEventsResponse from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return GetCompaniesResponse.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = GetCompaniesResponse.parse_obj({
+        _obj = cls.model_validate({
             "has_more": obj.get("has_more"),
             "object": obj.get("object"),
             "next_page_url": obj.get("next_page_url"),
             "previous_page_url": obj.get("previous_page_url"),
-            "data": [CompanyResponse.from_dict(_item) for _item in obj.get("data")] if obj.get("data") is not None else None
+            "data": [EventResponse.from_dict(_item) for _item in obj.get("data")] if obj.get("data") is not None else None
         })
         return _obj
 
+
```

### Comparing `conekta-6.0.1/conekta/models/get_companies_response_all_of.py` & `conekta-6.0.2/conekta/models/get_companies_response_all_of.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,79 +1,96 @@
 # coding: utf-8
 
 """
     Conekta API
 
-    Conekta sdk  # noqa: E501
+    Conekta sdk
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
-"""
+"""  # noqa: E501
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
 
-from typing import List, Optional
-from pydantic import BaseModel, conlist
+from typing import Any, ClassVar, Dict, List, Optional
+from pydantic import BaseModel
 from conekta.models.company_response import CompanyResponse
+try:
+    from typing import Self
+except ImportError:
+    from typing_extensions import Self
 
 class GetCompaniesResponseAllOf(BaseModel):
     """
     GetCompaniesResponseAllOf
-    """
-    data: Optional[conlist(CompanyResponse)] = None
-    __properties = ["data"]
+    """ # noqa: E501
+    data: Optional[List[CompanyResponse]] = None
+    __properties: ClassVar[List[str]] = ["data"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True
+    }
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> GetCompaniesResponseAllOf:
+    def from_json(cls, json_str: str) -> Self:
         """Create an instance of GetCompaniesResponseAllOf from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude={
+            },
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of each item in data (list)
         _items = []
         if self.data:
             for _item in self.data:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['data'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> GetCompaniesResponseAllOf:
+    def from_dict(cls, obj: Dict) -> Self:
         """Create an instance of GetCompaniesResponseAllOf from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return GetCompaniesResponseAllOf.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = GetCompaniesResponseAllOf.parse_obj({
+        _obj = cls.model_validate({
             "data": [CompanyResponse.from_dict(_item) for _item in obj.get("data")] if obj.get("data") is not None else None
         })
         return _obj
 
+
```

### Comparing `conekta-6.0.1/conekta/models/get_customer_payment_method_data_response.py` & `conekta-6.0.2/conekta/models/get_customer_payment_method_data_response.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,70 +1,77 @@
 # coding: utf-8
 
 """
     Conekta API
 
-    Conekta sdk  # noqa: E501
+    Conekta sdk
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
-"""
+"""  # noqa: E501
 
 
 from __future__ import annotations
 from inspect import getfullargspec
 import json
 import pprint
 import re  # noqa: F401
 
 from typing import Any, List, Optional
-from pydantic import BaseModel, Field, StrictStr, ValidationError, validator
+from pydantic import BaseModel, Field, StrictStr, ValidationError, field_validator
 from conekta.models.payment_method_card_response import PaymentMethodCardResponse
 from conekta.models.payment_method_cash_response import PaymentMethodCashResponse
 from conekta.models.payment_method_spei_recurrent import PaymentMethodSpeiRecurrent
-from typing import Any, List
+from typing import Union, Any, List, TYPE_CHECKING, Optional, Dict
+from typing_extensions import Literal
 from pydantic import StrictStr, Field
+try:
+    from typing import Self
+except ImportError:
+    from typing_extensions import Self
 
 GETCUSTOMERPAYMENTMETHODDATARESPONSE_ONE_OF_SCHEMAS = ["PaymentMethodCardResponse", "PaymentMethodCashResponse", "PaymentMethodSpeiRecurrent"]
 
 class GetCustomerPaymentMethodDataResponse(BaseModel):
     """
     GetCustomerPaymentMethodDataResponse
     """
     # data type: PaymentMethodCashResponse
     oneof_schema_1_validator: Optional[PaymentMethodCashResponse] = None
     # data type: PaymentMethodCardResponse
     oneof_schema_2_validator: Optional[PaymentMethodCardResponse] = None
     # data type: PaymentMethodSpeiRecurrent
     oneof_schema_3_validator: Optional[PaymentMethodSpeiRecurrent] = None
-    actual_instance: Any
-    one_of_schemas: List[str] = Field(GETCUSTOMERPAYMENTMETHODDATARESPONSE_ONE_OF_SCHEMAS, const=True)
+    actual_instance: Optional[Union[PaymentMethodCardResponse, PaymentMethodCashResponse, PaymentMethodSpeiRecurrent]] = None
+    one_of_schemas: List[str] = Literal["PaymentMethodCardResponse", "PaymentMethodCashResponse", "PaymentMethodSpeiRecurrent"]
+
+    model_config = {
+        "validate_assignment": True
+    }
 
-    class Config:
-        validate_assignment = True
 
-    discriminator_value_class_map = {
+    discriminator_value_class_map: Dict[str, str] = {
     }
 
-    def __init__(self, *args, **kwargs):
+    def __init__(self, *args, **kwargs) -> None:
         if args:
             if len(args) > 1:
                 raise ValueError("If a position argument is used, only 1 is allowed to set `actual_instance`")
             if kwargs:
                 raise ValueError("If a position argument is used, keyword arguments cannot be used.")
             super().__init__(actual_instance=args[0])
         else:
             super().__init__(**kwargs)
 
-    @validator('actual_instance')
+    @field_validator('actual_instance')
     def actual_instance_must_validate_oneof(cls, v):
-        instance = GetCustomerPaymentMethodDataResponse.construct()
+        instance = GetCustomerPaymentMethodDataResponse.model_construct()
         error_messages = []
         match = 0
         # validate data type: PaymentMethodCashResponse
         if not isinstance(v, PaymentMethodCashResponse):
             error_messages.append(f"Error! Input type `{type(v)}` is not `PaymentMethodCashResponse`")
         else:
             match += 1
@@ -84,21 +91,21 @@
         elif match == 0:
             # no match
             raise ValueError("No match found when setting `actual_instance` in GetCustomerPaymentMethodDataResponse with oneOf schemas: PaymentMethodCardResponse, PaymentMethodCashResponse, PaymentMethodSpeiRecurrent. Details: " + ", ".join(error_messages))
         else:
             return v
 
     @classmethod
-    def from_dict(cls, obj: dict) -> GetCustomerPaymentMethodDataResponse:
+    def from_dict(cls, obj: dict) -> Self:
         return cls.from_json(json.dumps(obj))
 
     @classmethod
-    def from_json(cls, json_str: str) -> GetCustomerPaymentMethodDataResponse:
+    def from_json(cls, json_str: str) -> Self:
         """Returns the object represented by the json string"""
-        instance = GetCustomerPaymentMethodDataResponse.construct()
+        instance = cls.model_construct()
         error_messages = []
         match = 0
 
         # use oneOf discriminator to lookup the data type
         _data_type = json.loads(json_str).get("type")
         if not _data_type:
             raise ValueError("Failed to lookup data type from the field `type` in the input.")
@@ -114,14 +121,19 @@
             return instance
 
         # check if data type is `PaymentMethodCashResponse`
         if _data_type == "oxxo_recurrent":
             instance.actual_instance = PaymentMethodCashResponse.from_json(json_str)
             return instance
 
+        # check if data type is `PaymentMethodSpeiRecurrent`
+        if _data_type == "spei_recurrent":
+            instance.actual_instance = PaymentMethodSpeiRecurrent.from_json(json_str)
+            return instance
+
         # check if data type is `PaymentMethodCardResponse`
         if _data_type == "payment_method_card_response":
             instance.actual_instance = PaymentMethodCardResponse.from_json(json_str)
             return instance
 
         # check if data type is `PaymentMethodCashResponse`
         if _data_type == "payment_method_cash_response":
@@ -129,19 +141,14 @@
             return instance
 
         # check if data type is `PaymentMethodSpeiRecurrent`
         if _data_type == "payment_method_spei_recurrent":
             instance.actual_instance = PaymentMethodSpeiRecurrent.from_json(json_str)
             return instance
 
-        # check if data type is `PaymentMethodSpeiRecurrent`
-        if _data_type == "spei_recurrent":
-            instance.actual_instance = PaymentMethodSpeiRecurrent.from_json(json_str)
-            return instance
-
         # deserialize data into PaymentMethodCashResponse
         try:
             instance.actual_instance = PaymentMethodCashResponse.from_json(json_str)
             match += 1
         except (ValidationError, ValueError) as e:
             error_messages.append(str(e))
         # deserialize data into PaymentMethodCardResponse
@@ -173,23 +180,24 @@
 
         to_json = getattr(self.actual_instance, "to_json", None)
         if callable(to_json):
             return self.actual_instance.to_json()
         else:
             return json.dumps(self.actual_instance)
 
-    def to_dict(self) -> dict:
+    def to_dict(self) -> Dict:
         """Returns the dict representation of the actual instance"""
         if self.actual_instance is None:
             return None
 
         to_dict = getattr(self.actual_instance, "to_dict", None)
         if callable(to_dict):
             return self.actual_instance.to_dict()
         else:
             # primitive type
             return self.actual_instance
 
     def to_str(self) -> str:
         """Returns the string representation of the actual instance"""
-        return pprint.pformat(self.dict())
+        return pprint.pformat(self.model_dump())
+
```

### Comparing `conekta-6.0.1/conekta/models/get_events_response.py` & `conekta-6.0.2/conekta/models/get_charges_response.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,97 +1,115 @@
 # coding: utf-8
 
 """
     Conekta API
 
-    Conekta sdk  # noqa: E501
+    Conekta sdk
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
-"""
+"""  # noqa: E501
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
 
-from typing import List, Optional
-from pydantic import BaseModel, Field, StrictBool, StrictStr, conlist
-from conekta.models.event_response import EventResponse
+from typing import Any, ClassVar, Dict, List, Optional
+from pydantic import BaseModel, StrictBool, StrictStr
+from pydantic import Field
+from conekta.models.charge_response import ChargeResponse
+try:
+    from typing import Self
+except ImportError:
+    from typing_extensions import Self
 
-class GetEventsResponse(BaseModel):
-    """
-    GetEventsResponse
+class GetChargesResponse(BaseModel):
     """
-    has_more: StrictBool = Field(..., description="Indicates if there are more pages to be requested")
-    object: StrictStr = Field(..., description="Object type, in this case is list")
-    next_page_url: Optional[StrictStr] = Field(None, description="URL of the next page.")
-    previous_page_url: Optional[StrictStr] = Field(None, description="Url of the previous page.")
-    data: Optional[conlist(EventResponse)] = None
-    __properties = ["has_more", "object", "next_page_url", "previous_page_url", "data"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    GetChargesResponse
+    """ # noqa: E501
+    has_more: StrictBool = Field(description="Indicates if there are more pages to be requested")
+    object: StrictStr = Field(description="Object type, in this case is list")
+    next_page_url: Optional[StrictStr] = Field(default=None, description="URL of the next page.")
+    previous_page_url: Optional[StrictStr] = Field(default=None, description="Url of the previous page.")
+    data: Optional[List[ChargeResponse]] = None
+    __properties: ClassVar[List[str]] = ["has_more", "object", "next_page_url", "previous_page_url", "data"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> GetEventsResponse:
-        """Create an instance of GetEventsResponse from a JSON string"""
+    def from_json(cls, json_str: str) -> Self:
+        """Create an instance of GetChargesResponse from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude={
+            },
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of each item in data (list)
         _items = []
         if self.data:
             for _item in self.data:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['data'] = _items
         # set to None if next_page_url (nullable) is None
-        # and __fields_set__ contains the field
-        if self.next_page_url is None and "next_page_url" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.next_page_url is None and "next_page_url" in self.model_fields_set:
             _dict['next_page_url'] = None
 
         # set to None if previous_page_url (nullable) is None
-        # and __fields_set__ contains the field
-        if self.previous_page_url is None and "previous_page_url" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.previous_page_url is None and "previous_page_url" in self.model_fields_set:
             _dict['previous_page_url'] = None
 
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> GetEventsResponse:
-        """Create an instance of GetEventsResponse from a dict"""
+    def from_dict(cls, obj: Dict) -> Self:
+        """Create an instance of GetChargesResponse from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return GetEventsResponse.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = GetEventsResponse.parse_obj({
+        _obj = cls.model_validate({
             "has_more": obj.get("has_more"),
             "object": obj.get("object"),
             "next_page_url": obj.get("next_page_url"),
             "previous_page_url": obj.get("previous_page_url"),
-            "data": [EventResponse.from_dict(_item) for _item in obj.get("data")] if obj.get("data") is not None else None
+            "data": [ChargeResponse.from_dict(_item) for _item in obj.get("data")] if obj.get("data") is not None else None
         })
         return _obj
 
+
```

### Comparing `conekta-6.0.1/conekta/models/get_events_response_all_of.py` & `conekta-6.0.2/conekta/models/get_transactions_response_all_of.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,79 +1,97 @@
 # coding: utf-8
 
 """
     Conekta API
 
-    Conekta sdk  # noqa: E501
+    Conekta sdk
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
-"""
+"""  # noqa: E501
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
 
-from typing import List, Optional
-from pydantic import BaseModel, conlist
-from conekta.models.event_response import EventResponse
+from typing import Any, ClassVar, Dict, List, Optional
+from pydantic import BaseModel
+from pydantic import Field
+from conekta.models.transaction_response import TransactionResponse
+try:
+    from typing import Self
+except ImportError:
+    from typing_extensions import Self
 
-class GetEventsResponseAllOf(BaseModel):
-    """
-    GetEventsResponseAllOf
+class GetTransactionsResponseAllOf(BaseModel):
     """
-    data: Optional[conlist(EventResponse)] = None
-    __properties = ["data"]
+    GetTransactionsResponseAllOf
+    """ # noqa: E501
+    data: Optional[List[TransactionResponse]] = Field(default=None, description="Transactions")
+    __properties: ClassVar[List[str]] = ["data"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True
+    }
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> GetEventsResponseAllOf:
-        """Create an instance of GetEventsResponseAllOf from a JSON string"""
+    def from_json(cls, json_str: str) -> Self:
+        """Create an instance of GetTransactionsResponseAllOf from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude={
+            },
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of each item in data (list)
         _items = []
         if self.data:
             for _item in self.data:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['data'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> GetEventsResponseAllOf:
-        """Create an instance of GetEventsResponseAllOf from a dict"""
+    def from_dict(cls, obj: Dict) -> Self:
+        """Create an instance of GetTransactionsResponseAllOf from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return GetEventsResponseAllOf.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = GetEventsResponseAllOf.parse_obj({
-            "data": [EventResponse.from_dict(_item) for _item in obj.get("data")] if obj.get("data") is not None else None
+        _obj = cls.model_validate({
+            "data": [TransactionResponse.from_dict(_item) for _item in obj.get("data")] if obj.get("data") is not None else None
         })
         return _obj
 
+
```

### Comparing `conekta-6.0.1/conekta/models/get_order_discount_lines_response.py` & `conekta-6.0.2/conekta/models/get_api_keys_response.py`

 * *Files 23% similar despite different names*

```diff
@@ -1,97 +1,115 @@
 # coding: utf-8
 
 """
     Conekta API
 
-    Conekta sdk  # noqa: E501
+    Conekta sdk
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
-"""
+"""  # noqa: E501
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
 
-from typing import List, Optional
-from pydantic import BaseModel, Field, StrictBool, StrictStr, conlist
-from conekta.models.discount_lines_response import DiscountLinesResponse
+from typing import Any, ClassVar, Dict, List, Optional
+from pydantic import BaseModel, StrictBool, StrictStr
+from pydantic import Field
+from conekta.models.api_key_response import ApiKeyResponse
+try:
+    from typing import Self
+except ImportError:
+    from typing_extensions import Self
 
-class GetOrderDiscountLinesResponse(BaseModel):
-    """
-    GetOrderDiscountLinesResponse
+class GetApiKeysResponse(BaseModel):
     """
-    has_more: StrictBool = Field(..., description="Indicates if there are more pages to be requested")
-    object: StrictStr = Field(..., description="Object type, in this case is list")
-    next_page_url: Optional[StrictStr] = Field(None, description="URL of the next page.")
-    previous_page_url: Optional[StrictStr] = Field(None, description="Url of the previous page.")
-    data: Optional[conlist(DiscountLinesResponse)] = None
-    __properties = ["has_more", "object", "next_page_url", "previous_page_url", "data"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    GetApiKeysResponse
+    """ # noqa: E501
+    next_page_url: Optional[StrictStr] = Field(default=None, description="URL of the next page.")
+    previous_page_url: Optional[StrictStr] = Field(default=None, description="Url of the previous page.")
+    has_more: StrictBool = Field(description="Indicates if there are more pages to be requested")
+    object: StrictStr = Field(description="Object type, in this case is list")
+    data: Optional[List[ApiKeyResponse]] = None
+    __properties: ClassVar[List[str]] = ["next_page_url", "previous_page_url", "has_more", "object", "data"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> GetOrderDiscountLinesResponse:
-        """Create an instance of GetOrderDiscountLinesResponse from a JSON string"""
+    def from_json(cls, json_str: str) -> Self:
+        """Create an instance of GetApiKeysResponse from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude={
+            },
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of each item in data (list)
         _items = []
         if self.data:
             for _item in self.data:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['data'] = _items
         # set to None if next_page_url (nullable) is None
-        # and __fields_set__ contains the field
-        if self.next_page_url is None and "next_page_url" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.next_page_url is None and "next_page_url" in self.model_fields_set:
             _dict['next_page_url'] = None
 
         # set to None if previous_page_url (nullable) is None
-        # and __fields_set__ contains the field
-        if self.previous_page_url is None and "previous_page_url" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.previous_page_url is None and "previous_page_url" in self.model_fields_set:
             _dict['previous_page_url'] = None
 
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> GetOrderDiscountLinesResponse:
-        """Create an instance of GetOrderDiscountLinesResponse from a dict"""
+    def from_dict(cls, obj: Dict) -> Self:
+        """Create an instance of GetApiKeysResponse from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return GetOrderDiscountLinesResponse.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = GetOrderDiscountLinesResponse.parse_obj({
-            "has_more": obj.get("has_more"),
-            "object": obj.get("object"),
+        _obj = cls.model_validate({
             "next_page_url": obj.get("next_page_url"),
             "previous_page_url": obj.get("previous_page_url"),
-            "data": [DiscountLinesResponse.from_dict(_item) for _item in obj.get("data")] if obj.get("data") is not None else None
+            "has_more": obj.get("has_more"),
+            "object": obj.get("object"),
+            "data": [ApiKeyResponse.from_dict(_item) for _item in obj.get("data")] if obj.get("data") is not None else None
         })
         return _obj
 
+
```

### Comparing `conekta-6.0.1/conekta/models/get_order_discount_lines_response_all_of.py` & `conekta-6.0.2/conekta/models/get_order_discount_lines_response_all_of.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,79 +1,96 @@
 # coding: utf-8
 
 """
     Conekta API
 
-    Conekta sdk  # noqa: E501
+    Conekta sdk
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
-"""
+"""  # noqa: E501
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
 
-from typing import List, Optional
-from pydantic import BaseModel, conlist
+from typing import Any, ClassVar, Dict, List, Optional
+from pydantic import BaseModel
 from conekta.models.discount_lines_response import DiscountLinesResponse
+try:
+    from typing import Self
+except ImportError:
+    from typing_extensions import Self
 
 class GetOrderDiscountLinesResponseAllOf(BaseModel):
     """
     GetOrderDiscountLinesResponseAllOf
-    """
-    data: Optional[conlist(DiscountLinesResponse)] = None
-    __properties = ["data"]
+    """ # noqa: E501
+    data: Optional[List[DiscountLinesResponse]] = None
+    __properties: ClassVar[List[str]] = ["data"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True
+    }
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> GetOrderDiscountLinesResponseAllOf:
+    def from_json(cls, json_str: str) -> Self:
         """Create an instance of GetOrderDiscountLinesResponseAllOf from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude={
+            },
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of each item in data (list)
         _items = []
         if self.data:
             for _item in self.data:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['data'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> GetOrderDiscountLinesResponseAllOf:
+    def from_dict(cls, obj: Dict) -> Self:
         """Create an instance of GetOrderDiscountLinesResponseAllOf from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return GetOrderDiscountLinesResponseAllOf.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = GetOrderDiscountLinesResponseAllOf.parse_obj({
+        _obj = cls.model_validate({
             "data": [DiscountLinesResponse.from_dict(_item) for _item in obj.get("data")] if obj.get("data") is not None else None
         })
         return _obj
 
+
```

### Comparing `conekta-6.0.1/conekta/models/get_orders_response.py` & `conekta-6.0.2/conekta/models/payment_method_cash_response_all_of.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,97 +1,96 @@
 # coding: utf-8
 
 """
     Conekta API
 
-    Conekta sdk  # noqa: E501
+    Conekta sdk
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
-"""
+"""  # noqa: E501
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
 
-from typing import List, Optional
-from pydantic import BaseModel, Field, StrictBool, StrictStr, conlist
-from conekta.models.order_response import OrderResponse
+from typing import Any, ClassVar, Dict, List, Optional
+from pydantic import BaseModel, StrictInt, StrictStr
+try:
+    from typing import Self
+except ImportError:
+    from typing_extensions import Self
 
-class GetOrdersResponse(BaseModel):
-    """
-    GetOrdersResponse
+class PaymentMethodCashResponseAllOf(BaseModel):
     """
-    data: conlist(OrderResponse) = Field(...)
-    has_more: StrictBool = Field(..., description="Indicates if there are more pages to be requested")
-    object: StrictStr = Field(..., description="Object type, in this case is list")
-    next_page_url: Optional[StrictStr] = Field(None, description="URL of the next page.")
-    previous_page_url: Optional[StrictStr] = Field(None, description="Url of the previous page.")
-    __properties = ["data", "has_more", "object", "next_page_url", "previous_page_url"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    use for cash responses
+    """ # noqa: E501
+    reference: Optional[StrictStr] = None
+    barcode: Optional[StrictStr] = None
+    barcode_url: Optional[StrictStr] = None
+    expires_at: Optional[StrictInt] = None
+    provider: Optional[StrictStr] = None
+    __properties: ClassVar[List[str]] = ["reference", "barcode", "barcode_url", "expires_at", "provider"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> GetOrdersResponse:
-        """Create an instance of GetOrdersResponse from a JSON string"""
+    def from_json(cls, json_str: str) -> Self:
+        """Create an instance of PaymentMethodCashResponseAllOf from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
-        # override the default output from pydantic by calling `to_dict()` of each item in data (list)
-        _items = []
-        if self.data:
-            for _item in self.data:
-                if _item:
-                    _items.append(_item.to_dict())
-            _dict['data'] = _items
-        # set to None if next_page_url (nullable) is None
-        # and __fields_set__ contains the field
-        if self.next_page_url is None and "next_page_url" in self.__fields_set__:
-            _dict['next_page_url'] = None
-
-        # set to None if previous_page_url (nullable) is None
-        # and __fields_set__ contains the field
-        if self.previous_page_url is None and "previous_page_url" in self.__fields_set__:
-            _dict['previous_page_url'] = None
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
 
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude={
+            },
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> GetOrdersResponse:
-        """Create an instance of GetOrdersResponse from a dict"""
+    def from_dict(cls, obj: Dict) -> Self:
+        """Create an instance of PaymentMethodCashResponseAllOf from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return GetOrdersResponse.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = GetOrdersResponse.parse_obj({
-            "data": [OrderResponse.from_dict(_item) for _item in obj.get("data")] if obj.get("data") is not None else None,
-            "has_more": obj.get("has_more"),
-            "object": obj.get("object"),
-            "next_page_url": obj.get("next_page_url"),
-            "previous_page_url": obj.get("previous_page_url")
+        _obj = cls.model_validate({
+            "reference": obj.get("reference"),
+            "barcode": obj.get("barcode"),
+            "barcode_url": obj.get("barcode_url"),
+            "expires_at": obj.get("expires_at"),
+            "provider": obj.get("provider")
         })
         return _obj
 
+
```

### Comparing `conekta-6.0.1/conekta/models/get_payment_method_response.py` & `conekta-6.0.2/conekta/models/get_payment_method_response.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,97 +1,115 @@
 # coding: utf-8
 
 """
     Conekta API
 
-    Conekta sdk  # noqa: E501
+    Conekta sdk
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
-"""
+"""  # noqa: E501
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
 
-from typing import List, Optional
-from pydantic import BaseModel, Field, StrictBool, StrictStr, conlist
+from typing import Any, ClassVar, Dict, List, Optional
+from pydantic import BaseModel, StrictBool, StrictStr
+from pydantic import Field
 from conekta.models.get_customer_payment_method_data_response import GetCustomerPaymentMethodDataResponse
+try:
+    from typing import Self
+except ImportError:
+    from typing_extensions import Self
 
 class GetPaymentMethodResponse(BaseModel):
     """
     GetPaymentMethodResponse
-    """
-    has_more: StrictBool = Field(..., description="Indicates if there are more pages to be requested")
-    object: StrictStr = Field(..., description="Object type, in this case is list")
-    next_page_url: Optional[StrictStr] = Field(None, description="URL of the next page.")
-    previous_page_url: Optional[StrictStr] = Field(None, description="Url of the previous page.")
-    data: Optional[conlist(GetCustomerPaymentMethodDataResponse)] = None
-    __properties = ["has_more", "object", "next_page_url", "previous_page_url", "data"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    """ # noqa: E501
+    has_more: StrictBool = Field(description="Indicates if there are more pages to be requested")
+    object: StrictStr = Field(description="Object type, in this case is list")
+    next_page_url: Optional[StrictStr] = Field(default=None, description="URL of the next page.")
+    previous_page_url: Optional[StrictStr] = Field(default=None, description="Url of the previous page.")
+    data: Optional[List[GetCustomerPaymentMethodDataResponse]] = None
+    __properties: ClassVar[List[str]] = ["has_more", "object", "next_page_url", "previous_page_url", "data"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> GetPaymentMethodResponse:
+    def from_json(cls, json_str: str) -> Self:
         """Create an instance of GetPaymentMethodResponse from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude={
+            },
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of each item in data (list)
         _items = []
         if self.data:
             for _item in self.data:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['data'] = _items
         # set to None if next_page_url (nullable) is None
-        # and __fields_set__ contains the field
-        if self.next_page_url is None and "next_page_url" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.next_page_url is None and "next_page_url" in self.model_fields_set:
             _dict['next_page_url'] = None
 
         # set to None if previous_page_url (nullable) is None
-        # and __fields_set__ contains the field
-        if self.previous_page_url is None and "previous_page_url" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.previous_page_url is None and "previous_page_url" in self.model_fields_set:
             _dict['previous_page_url'] = None
 
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> GetPaymentMethodResponse:
+    def from_dict(cls, obj: Dict) -> Self:
         """Create an instance of GetPaymentMethodResponse from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return GetPaymentMethodResponse.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = GetPaymentMethodResponse.parse_obj({
+        _obj = cls.model_validate({
             "has_more": obj.get("has_more"),
             "object": obj.get("object"),
             "next_page_url": obj.get("next_page_url"),
             "previous_page_url": obj.get("previous_page_url"),
             "data": [GetCustomerPaymentMethodDataResponse.from_dict(_item) for _item in obj.get("data")] if obj.get("data") is not None else None
         })
         return _obj
 
+
```

### Comparing `conekta-6.0.1/conekta/models/get_payment_method_response_all_of.py` & `conekta-6.0.2/conekta/models/get_payment_method_response_all_of.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,79 +1,96 @@
 # coding: utf-8
 
 """
     Conekta API
 
-    Conekta sdk  # noqa: E501
+    Conekta sdk
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
-"""
+"""  # noqa: E501
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
 
-from typing import List, Optional
-from pydantic import BaseModel, conlist
+from typing import Any, ClassVar, Dict, List, Optional
+from pydantic import BaseModel
 from conekta.models.get_customer_payment_method_data_response import GetCustomerPaymentMethodDataResponse
+try:
+    from typing import Self
+except ImportError:
+    from typing_extensions import Self
 
 class GetPaymentMethodResponseAllOf(BaseModel):
     """
     GetPaymentMethodResponseAllOf
-    """
-    data: Optional[conlist(GetCustomerPaymentMethodDataResponse)] = None
-    __properties = ["data"]
+    """ # noqa: E501
+    data: Optional[List[GetCustomerPaymentMethodDataResponse]] = None
+    __properties: ClassVar[List[str]] = ["data"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True
+    }
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> GetPaymentMethodResponseAllOf:
+    def from_json(cls, json_str: str) -> Self:
         """Create an instance of GetPaymentMethodResponseAllOf from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude={
+            },
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of each item in data (list)
         _items = []
         if self.data:
             for _item in self.data:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['data'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> GetPaymentMethodResponseAllOf:
+    def from_dict(cls, obj: Dict) -> Self:
         """Create an instance of GetPaymentMethodResponseAllOf from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return GetPaymentMethodResponseAllOf.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = GetPaymentMethodResponseAllOf.parse_obj({
+        _obj = cls.model_validate({
             "data": [GetCustomerPaymentMethodDataResponse.from_dict(_item) for _item in obj.get("data")] if obj.get("data") is not None else None
         })
         return _obj
 
+
```

### Comparing `conekta-6.0.1/conekta/models/get_plans_response.py` & `conekta-6.0.2/conekta/models/payment_method_card_response.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,97 +1,116 @@
 # coding: utf-8
 
 """
     Conekta API
 
-    Conekta sdk  # noqa: E501
+    Conekta sdk
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
-"""
+"""  # noqa: E501
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
 
-from typing import List, Optional
-from pydantic import BaseModel, Field, StrictBool, StrictStr, conlist
-from conekta.models.plan_response import PlanResponse
+from typing import Any, ClassVar, Dict, List, Optional
+from pydantic import BaseModel, StrictBool, StrictInt, StrictStr
+try:
+    from typing import Self
+except ImportError:
+    from typing_extensions import Self
 
-class GetPlansResponse(BaseModel):
-    """
-    GetPlansResponse
+class PaymentMethodCardResponse(BaseModel):
     """
-    has_more: StrictBool = Field(..., description="Indicates if there are more pages to be requested")
-    object: StrictStr = Field(..., description="Object type, in this case is list")
-    next_page_url: Optional[StrictStr] = Field(None, description="URL of the next page.")
-    previous_page_url: Optional[StrictStr] = Field(None, description="Url of the previous page.")
-    data: Optional[conlist(PlanResponse)] = None
-    __properties = ["has_more", "object", "next_page_url", "previous_page_url", "data"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    PaymentMethodCardResponse
+    """ # noqa: E501
+    type: StrictStr
+    id: StrictStr
+    object: StrictStr
+    created_at: StrictInt
+    parent_id: Optional[StrictStr] = None
+    last4: Optional[StrictStr] = None
+    bin: Optional[StrictStr] = None
+    card_type: Optional[StrictStr] = None
+    exp_month: Optional[StrictStr] = None
+    exp_year: Optional[StrictStr] = None
+    brand: Optional[StrictStr] = None
+    name: Optional[StrictStr] = None
+    default: Optional[StrictBool] = None
+    visible_on_checkout: Optional[StrictBool] = None
+    payment_source_status: Optional[StrictStr] = None
+    __properties: ClassVar[List[str]] = ["type", "id", "object", "created_at", "parent_id", "last4", "bin", "card_type", "exp_month", "exp_year", "brand", "name", "default", "visible_on_checkout", "payment_source_status"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> GetPlansResponse:
-        """Create an instance of GetPlansResponse from a JSON string"""
+    def from_json(cls, json_str: str) -> Self:
+        """Create an instance of PaymentMethodCardResponse from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
-        # override the default output from pydantic by calling `to_dict()` of each item in data (list)
-        _items = []
-        if self.data:
-            for _item in self.data:
-                if _item:
-                    _items.append(_item.to_dict())
-            _dict['data'] = _items
-        # set to None if next_page_url (nullable) is None
-        # and __fields_set__ contains the field
-        if self.next_page_url is None and "next_page_url" in self.__fields_set__:
-            _dict['next_page_url'] = None
-
-        # set to None if previous_page_url (nullable) is None
-        # and __fields_set__ contains the field
-        if self.previous_page_url is None and "previous_page_url" in self.__fields_set__:
-            _dict['previous_page_url'] = None
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
 
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude={
+            },
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> GetPlansResponse:
-        """Create an instance of GetPlansResponse from a dict"""
+    def from_dict(cls, obj: Dict) -> Self:
+        """Create an instance of PaymentMethodCardResponse from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return GetPlansResponse.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = GetPlansResponse.parse_obj({
-            "has_more": obj.get("has_more"),
+        _obj = cls.model_validate({
+            "type": obj.get("type"),
+            "id": obj.get("id"),
             "object": obj.get("object"),
-            "next_page_url": obj.get("next_page_url"),
-            "previous_page_url": obj.get("previous_page_url"),
-            "data": [PlanResponse.from_dict(_item) for _item in obj.get("data")] if obj.get("data") is not None else None
+            "created_at": obj.get("created_at"),
+            "parent_id": obj.get("parent_id"),
+            "last4": obj.get("last4"),
+            "bin": obj.get("bin"),
+            "card_type": obj.get("card_type"),
+            "exp_month": obj.get("exp_month"),
+            "exp_year": obj.get("exp_year"),
+            "brand": obj.get("brand"),
+            "name": obj.get("name"),
+            "default": obj.get("default"),
+            "visible_on_checkout": obj.get("visible_on_checkout"),
+            "payment_source_status": obj.get("payment_source_status")
         })
         return _obj
 
+
```

### Comparing `conekta-6.0.1/conekta/models/get_plans_response_all_of.py` & `conekta-6.0.2/conekta/models/get_webhook_keys_response_all_of.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,79 +1,96 @@
 # coding: utf-8
 
 """
     Conekta API
 
-    Conekta sdk  # noqa: E501
+    Conekta sdk
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
-"""
+"""  # noqa: E501
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
 
-from typing import List, Optional
-from pydantic import BaseModel, conlist
-from conekta.models.plan_response import PlanResponse
+from typing import Any, ClassVar, Dict, List, Optional
+from pydantic import BaseModel
+from conekta.models.webhook_key_response import WebhookKeyResponse
+try:
+    from typing import Self
+except ImportError:
+    from typing_extensions import Self
 
-class GetPlansResponseAllOf(BaseModel):
-    """
-    GetPlansResponseAllOf
+class GetWebhookKeysResponseAllOf(BaseModel):
     """
-    data: Optional[conlist(PlanResponse)] = None
-    __properties = ["data"]
+    GetWebhookKeysResponseAllOf
+    """ # noqa: E501
+    data: Optional[List[WebhookKeyResponse]] = None
+    __properties: ClassVar[List[str]] = ["data"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True
+    }
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> GetPlansResponseAllOf:
-        """Create an instance of GetPlansResponseAllOf from a JSON string"""
+    def from_json(cls, json_str: str) -> Self:
+        """Create an instance of GetWebhookKeysResponseAllOf from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude={
+            },
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of each item in data (list)
         _items = []
         if self.data:
             for _item in self.data:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['data'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> GetPlansResponseAllOf:
-        """Create an instance of GetPlansResponseAllOf from a dict"""
+    def from_dict(cls, obj: Dict) -> Self:
+        """Create an instance of GetWebhookKeysResponseAllOf from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return GetPlansResponseAllOf.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = GetPlansResponseAllOf.parse_obj({
-            "data": [PlanResponse.from_dict(_item) for _item in obj.get("data")] if obj.get("data") is not None else None
+        _obj = cls.model_validate({
+            "data": [WebhookKeyResponse.from_dict(_item) for _item in obj.get("data")] if obj.get("data") is not None else None
         })
         return _obj
 
+
```

### Comparing `conekta-6.0.1/conekta/models/get_transactions_response.py` & `conekta-6.0.2/conekta/models/get_transactions_response.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,97 +1,115 @@
 # coding: utf-8
 
 """
     Conekta API
 
-    Conekta sdk  # noqa: E501
+    Conekta sdk
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
-"""
+"""  # noqa: E501
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
 
-from typing import List, Optional
-from pydantic import BaseModel, Field, StrictBool, StrictStr, conlist
+from typing import Any, ClassVar, Dict, List, Optional
+from pydantic import BaseModel, StrictBool, StrictStr
+from pydantic import Field
 from conekta.models.transaction_response import TransactionResponse
+try:
+    from typing import Self
+except ImportError:
+    from typing_extensions import Self
 
 class GetTransactionsResponse(BaseModel):
     """
     GetTransactionsResponse
-    """
-    has_more: StrictBool = Field(..., description="Indicates if there are more pages to be requested")
-    object: StrictStr = Field(..., description="Object type, in this case is list")
-    next_page_url: Optional[StrictStr] = Field(None, description="URL of the next page.")
-    previous_page_url: Optional[StrictStr] = Field(None, description="Url of the previous page.")
-    data: Optional[conlist(TransactionResponse)] = Field(None, description="Transactions")
-    __properties = ["has_more", "object", "next_page_url", "previous_page_url", "data"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    """ # noqa: E501
+    has_more: StrictBool = Field(description="Indicates if there are more pages to be requested")
+    object: StrictStr = Field(description="Object type, in this case is list")
+    next_page_url: Optional[StrictStr] = Field(default=None, description="URL of the next page.")
+    previous_page_url: Optional[StrictStr] = Field(default=None, description="Url of the previous page.")
+    data: Optional[List[TransactionResponse]] = Field(default=None, description="Transactions")
+    __properties: ClassVar[List[str]] = ["has_more", "object", "next_page_url", "previous_page_url", "data"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> GetTransactionsResponse:
+    def from_json(cls, json_str: str) -> Self:
         """Create an instance of GetTransactionsResponse from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude={
+            },
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of each item in data (list)
         _items = []
         if self.data:
             for _item in self.data:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['data'] = _items
         # set to None if next_page_url (nullable) is None
-        # and __fields_set__ contains the field
-        if self.next_page_url is None and "next_page_url" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.next_page_url is None and "next_page_url" in self.model_fields_set:
             _dict['next_page_url'] = None
 
         # set to None if previous_page_url (nullable) is None
-        # and __fields_set__ contains the field
-        if self.previous_page_url is None and "previous_page_url" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.previous_page_url is None and "previous_page_url" in self.model_fields_set:
             _dict['previous_page_url'] = None
 
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> GetTransactionsResponse:
+    def from_dict(cls, obj: Dict) -> Self:
         """Create an instance of GetTransactionsResponse from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return GetTransactionsResponse.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = GetTransactionsResponse.parse_obj({
+        _obj = cls.model_validate({
             "has_more": obj.get("has_more"),
             "object": obj.get("object"),
             "next_page_url": obj.get("next_page_url"),
             "previous_page_url": obj.get("previous_page_url"),
             "data": [TransactionResponse.from_dict(_item) for _item in obj.get("data")] if obj.get("data") is not None else None
         })
         return _obj
 
+
```

### Comparing `conekta-6.0.1/conekta/models/get_transfers_response.py` & `conekta-6.0.2/conekta/models/get_webhooks_response.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,97 +1,115 @@
 # coding: utf-8
 
 """
     Conekta API
 
-    Conekta sdk  # noqa: E501
+    Conekta sdk
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
-"""
+"""  # noqa: E501
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
 
-from typing import List, Optional
-from pydantic import BaseModel, Field, StrictBool, StrictStr, conlist
-from conekta.models.transfers_response import TransfersResponse
+from typing import Any, ClassVar, Dict, List, Optional
+from pydantic import BaseModel, StrictBool, StrictStr
+from pydantic import Field
+from conekta.models.webhook_response import WebhookResponse
+try:
+    from typing import Self
+except ImportError:
+    from typing_extensions import Self
 
-class GetTransfersResponse(BaseModel):
-    """
-    GetTransfersResponse
+class GetWebhooksResponse(BaseModel):
     """
-    has_more: StrictBool = Field(..., description="Indicates if there are more pages to be requested")
-    object: StrictStr = Field(..., description="Object type, in this case is list")
-    next_page_url: Optional[StrictStr] = Field(None, description="URL of the next page.")
-    previous_page_url: Optional[StrictStr] = Field(None, description="Url of the previous page.")
-    data: Optional[conlist(TransfersResponse)] = Field(None, description="Transfers")
-    __properties = ["has_more", "object", "next_page_url", "previous_page_url", "data"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    GetWebhooksResponse
+    """ # noqa: E501
+    has_more: StrictBool = Field(description="Indicates if there are more pages to be requested")
+    object: StrictStr = Field(description="Object type, in this case is list")
+    next_page_url: Optional[StrictStr] = Field(default=None, description="URL of the next page.")
+    previous_page_url: Optional[StrictStr] = Field(default=None, description="Url of the previous page.")
+    data: Optional[List[WebhookResponse]] = None
+    __properties: ClassVar[List[str]] = ["has_more", "object", "next_page_url", "previous_page_url", "data"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> GetTransfersResponse:
-        """Create an instance of GetTransfersResponse from a JSON string"""
+    def from_json(cls, json_str: str) -> Self:
+        """Create an instance of GetWebhooksResponse from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude={
+            },
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of each item in data (list)
         _items = []
         if self.data:
             for _item in self.data:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['data'] = _items
         # set to None if next_page_url (nullable) is None
-        # and __fields_set__ contains the field
-        if self.next_page_url is None and "next_page_url" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.next_page_url is None and "next_page_url" in self.model_fields_set:
             _dict['next_page_url'] = None
 
         # set to None if previous_page_url (nullable) is None
-        # and __fields_set__ contains the field
-        if self.previous_page_url is None and "previous_page_url" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.previous_page_url is None and "previous_page_url" in self.model_fields_set:
             _dict['previous_page_url'] = None
 
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> GetTransfersResponse:
-        """Create an instance of GetTransfersResponse from a dict"""
+    def from_dict(cls, obj: Dict) -> Self:
+        """Create an instance of GetWebhooksResponse from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return GetTransfersResponse.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = GetTransfersResponse.parse_obj({
+        _obj = cls.model_validate({
             "has_more": obj.get("has_more"),
             "object": obj.get("object"),
             "next_page_url": obj.get("next_page_url"),
             "previous_page_url": obj.get("previous_page_url"),
-            "data": [TransfersResponse.from_dict(_item) for _item in obj.get("data")] if obj.get("data") is not None else None
+            "data": [WebhookResponse.from_dict(_item) for _item in obj.get("data")] if obj.get("data") is not None else None
         })
         return _obj
 
+
```

### Comparing `conekta-6.0.1/conekta/models/get_webhook_keys_response.py` & `conekta-6.0.2/conekta/models/get_webhook_keys_response.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,97 +1,115 @@
 # coding: utf-8
 
 """
     Conekta API
 
-    Conekta sdk  # noqa: E501
+    Conekta sdk
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
-"""
+"""  # noqa: E501
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
 
-from typing import List, Optional
-from pydantic import BaseModel, Field, StrictBool, StrictStr, conlist
+from typing import Any, ClassVar, Dict, List, Optional
+from pydantic import BaseModel, StrictBool, StrictStr
+from pydantic import Field
 from conekta.models.webhook_key_response import WebhookKeyResponse
+try:
+    from typing import Self
+except ImportError:
+    from typing_extensions import Self
 
 class GetWebhookKeysResponse(BaseModel):
     """
     GetWebhookKeysResponse
-    """
-    has_more: StrictBool = Field(..., description="Indicates if there are more pages to be requested")
-    object: StrictStr = Field(..., description="Object type, in this case is list")
-    next_page_url: Optional[StrictStr] = Field(None, description="URL of the next page.")
-    previous_page_url: Optional[StrictStr] = Field(None, description="Url of the previous page.")
-    data: Optional[conlist(WebhookKeyResponse)] = None
-    __properties = ["has_more", "object", "next_page_url", "previous_page_url", "data"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    """ # noqa: E501
+    has_more: StrictBool = Field(description="Indicates if there are more pages to be requested")
+    object: StrictStr = Field(description="Object type, in this case is list")
+    next_page_url: Optional[StrictStr] = Field(default=None, description="URL of the next page.")
+    previous_page_url: Optional[StrictStr] = Field(default=None, description="Url of the previous page.")
+    data: Optional[List[WebhookKeyResponse]] = None
+    __properties: ClassVar[List[str]] = ["has_more", "object", "next_page_url", "previous_page_url", "data"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> GetWebhookKeysResponse:
+    def from_json(cls, json_str: str) -> Self:
         """Create an instance of GetWebhookKeysResponse from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude={
+            },
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of each item in data (list)
         _items = []
         if self.data:
             for _item in self.data:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['data'] = _items
         # set to None if next_page_url (nullable) is None
-        # and __fields_set__ contains the field
-        if self.next_page_url is None and "next_page_url" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.next_page_url is None and "next_page_url" in self.model_fields_set:
             _dict['next_page_url'] = None
 
         # set to None if previous_page_url (nullable) is None
-        # and __fields_set__ contains the field
-        if self.previous_page_url is None and "previous_page_url" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.previous_page_url is None and "previous_page_url" in self.model_fields_set:
             _dict['previous_page_url'] = None
 
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> GetWebhookKeysResponse:
+    def from_dict(cls, obj: Dict) -> Self:
         """Create an instance of GetWebhookKeysResponse from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return GetWebhookKeysResponse.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = GetWebhookKeysResponse.parse_obj({
+        _obj = cls.model_validate({
             "has_more": obj.get("has_more"),
             "object": obj.get("object"),
             "next_page_url": obj.get("next_page_url"),
             "previous_page_url": obj.get("previous_page_url"),
             "data": [WebhookKeyResponse.from_dict(_item) for _item in obj.get("data")] if obj.get("data") is not None else None
         })
         return _obj
 
+
```

### Comparing `conekta-6.0.1/conekta/models/get_webhooks_response.py` & `conekta-6.0.2/conekta/models/risk_rules_list.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,97 +1,115 @@
 # coding: utf-8
 
 """
     Conekta API
 
-    Conekta sdk  # noqa: E501
+    Conekta sdk
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
-"""
+"""  # noqa: E501
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
 
-from typing import List, Optional
-from pydantic import BaseModel, Field, StrictBool, StrictStr, conlist
-from conekta.models.webhook_response import WebhookResponse
+from typing import Any, ClassVar, Dict, List, Optional
+from pydantic import BaseModel, StrictBool, StrictStr
+from pydantic import Field
+from conekta.models.risk_rules_data import RiskRulesData
+try:
+    from typing import Self
+except ImportError:
+    from typing_extensions import Self
 
-class GetWebhooksResponse(BaseModel):
-    """
-    GetWebhooksResponse
+class RiskRulesList(BaseModel):
     """
-    has_more: StrictBool = Field(..., description="Indicates if there are more pages to be requested")
-    object: StrictStr = Field(..., description="Object type, in this case is list")
-    next_page_url: Optional[StrictStr] = Field(None, description="URL of the next page.")
-    previous_page_url: Optional[StrictStr] = Field(None, description="Url of the previous page.")
-    data: Optional[conlist(WebhookResponse)] = None
-    __properties = ["has_more", "object", "next_page_url", "previous_page_url", "data"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    RiskRulesList
+    """ # noqa: E501
+    has_more: StrictBool = Field(description="Indicates if there are more pages to be requested")
+    object: StrictStr = Field(description="Object type, in this case is list")
+    next_page_url: Optional[StrictStr] = Field(default=None, description="URL of the next page.")
+    previous_page_url: Optional[StrictStr] = Field(default=None, description="Url of the previous page.")
+    data: Optional[List[RiskRulesData]] = None
+    __properties: ClassVar[List[str]] = ["has_more", "object", "next_page_url", "previous_page_url", "data"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> GetWebhooksResponse:
-        """Create an instance of GetWebhooksResponse from a JSON string"""
+    def from_json(cls, json_str: str) -> Self:
+        """Create an instance of RiskRulesList from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude={
+            },
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of each item in data (list)
         _items = []
         if self.data:
             for _item in self.data:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['data'] = _items
         # set to None if next_page_url (nullable) is None
-        # and __fields_set__ contains the field
-        if self.next_page_url is None and "next_page_url" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.next_page_url is None and "next_page_url" in self.model_fields_set:
             _dict['next_page_url'] = None
 
         # set to None if previous_page_url (nullable) is None
-        # and __fields_set__ contains the field
-        if self.previous_page_url is None and "previous_page_url" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.previous_page_url is None and "previous_page_url" in self.model_fields_set:
             _dict['previous_page_url'] = None
 
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> GetWebhooksResponse:
-        """Create an instance of GetWebhooksResponse from a dict"""
+    def from_dict(cls, obj: Dict) -> Self:
+        """Create an instance of RiskRulesList from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return GetWebhooksResponse.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = GetWebhooksResponse.parse_obj({
+        _obj = cls.model_validate({
             "has_more": obj.get("has_more"),
             "object": obj.get("object"),
             "next_page_url": obj.get("next_page_url"),
             "previous_page_url": obj.get("previous_page_url"),
-            "data": [WebhookResponse.from_dict(_item) for _item in obj.get("data")] if obj.get("data") is not None else None
+            "data": [RiskRulesData.from_dict(_item) for _item in obj.get("data")] if obj.get("data") is not None else None
         })
         return _obj
 
+
```

### Comparing `conekta-6.0.1/conekta/models/log_response.py` & `conekta-6.0.2/conekta/models/log_response.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,108 +1,124 @@
 # coding: utf-8
 
 """
     Conekta API
 
-    Conekta sdk  # noqa: E501
+    Conekta sdk
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
-"""
+"""  # noqa: E501
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
 
-from typing import Any, Dict, List, Optional
-from pydantic import BaseModel, Field, StrictBool, StrictInt, StrictStr, conlist
+from typing import Any, ClassVar, Dict, List, Optional, Union
+from pydantic import BaseModel, StrictBool, StrictInt, StrictStr
+try:
+    from typing import Self
+except ImportError:
+    from typing_extensions import Self
 
 class LogResponse(BaseModel):
     """
     log model
-    """
-    created_at: StrictInt = Field(...)
-    id: StrictStr = Field(...)
+    """ # noqa: E501
+    created_at: StrictInt
+    id: StrictStr
     ip_address: Optional[StrictStr] = None
-    livemode: StrictBool = Field(...)
+    livemode: StrictBool
     loggable_id: Optional[StrictStr] = None
     loggable_type: Optional[StrictStr] = None
     method: Optional[StrictStr] = None
     oauth_token_id: Optional[StrictStr] = None
     query_string: Optional[Dict[str, Any]] = None
     related: Optional[StrictStr] = None
-    request_body: Optional[Dict[str, Any]] = None
+    request_body: Optional[Union[str, Any]] = None
     request_headers: Optional[Dict[str, StrictStr]] = None
-    response_body: Optional[Dict[str, Any]] = None
+    response_body: Optional[Union[str, Any]] = None
     response_headers: Optional[Dict[str, StrictStr]] = None
-    searchable_tags: Optional[conlist(StrictStr)] = None
+    searchable_tags: Optional[List[StrictStr]] = None
     status: Optional[StrictStr] = None
     updated_at: Optional[StrictStr] = None
     url: Optional[StrictStr] = None
     user_account_id: Optional[StrictStr] = None
     version: Optional[StrictStr] = None
-    __properties = ["created_at", "id", "ip_address", "livemode", "loggable_id", "loggable_type", "method", "oauth_token_id", "query_string", "related", "request_body", "request_headers", "response_body", "response_headers", "searchable_tags", "status", "updated_at", "url", "user_account_id", "version"]
+    __properties: ClassVar[List[str]] = ["created_at", "id", "ip_address", "livemode", "loggable_id", "loggable_type", "method", "oauth_token_id", "query_string", "related", "request_body", "request_headers", "response_body", "response_headers", "searchable_tags", "status", "updated_at", "url", "user_account_id", "version"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True
+    }
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> LogResponse:
+    def from_json(cls, json_str: str) -> Self:
         """Create an instance of LogResponse from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude={
+            },
+            exclude_none=True,
+        )
         # set to None if loggable_id (nullable) is None
-        # and __fields_set__ contains the field
-        if self.loggable_id is None and "loggable_id" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.loggable_id is None and "loggable_id" in self.model_fields_set:
             _dict['loggable_id'] = None
 
         # set to None if loggable_type (nullable) is None
-        # and __fields_set__ contains the field
-        if self.loggable_type is None and "loggable_type" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.loggable_type is None and "loggable_type" in self.model_fields_set:
             _dict['loggable_type'] = None
 
         # set to None if oauth_token_id (nullable) is None
-        # and __fields_set__ contains the field
-        if self.oauth_token_id is None and "oauth_token_id" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.oauth_token_id is None and "oauth_token_id" in self.model_fields_set:
             _dict['oauth_token_id'] = None
 
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> LogResponse:
+    def from_dict(cls, obj: Dict) -> Self:
         """Create an instance of LogResponse from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return LogResponse.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = LogResponse.parse_obj({
+        _obj = cls.model_validate({
             "created_at": obj.get("created_at"),
             "id": obj.get("id"),
             "ip_address": obj.get("ip_address"),
             "livemode": obj.get("livemode"),
             "loggable_id": obj.get("loggable_id"),
             "loggable_type": obj.get("loggable_type"),
             "method": obj.get("method"),
@@ -118,7 +134,8 @@
             "updated_at": obj.get("updated_at"),
             "url": obj.get("url"),
             "user_account_id": obj.get("user_account_id"),
             "version": obj.get("version")
         })
         return _obj
 
+
```

### Comparing `conekta-6.0.1/conekta/models/logs_response.py` & `conekta-6.0.2/conekta/models/get_plans_response.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,104 +1,115 @@
 # coding: utf-8
 
 """
     Conekta API
 
-    Conekta sdk  # noqa: E501
+    Conekta sdk
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
-"""
+"""  # noqa: E501
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
 
-from typing import List, Optional
-from pydantic import BaseModel, Field, StrictBool, StrictStr, conlist
-from conekta.models.logs_response_data import LogsResponseData
+from typing import Any, ClassVar, Dict, List, Optional
+from pydantic import BaseModel, StrictBool, StrictStr
+from pydantic import Field
+from conekta.models.plan_response import PlanResponse
+try:
+    from typing import Self
+except ImportError:
+    from typing_extensions import Self
 
-class LogsResponse(BaseModel):
-    """
-    logs model
+class GetPlansResponse(BaseModel):
     """
-    has_more: Optional[StrictBool] = Field(None, description="True, if there are more pages.")
-    object: Optional[StrictStr] = Field(None, description="The object type")
-    next_page_url: Optional[StrictStr] = Field(None, description="URL of the next page.")
-    previous_page_url: Optional[StrictStr] = Field(None, description="Url of the previous page.")
-    data: Optional[conlist(LogsResponseData)] = Field(None, description="set to page results.")
-    __properties = ["has_more", "object", "next_page_url", "previous_page_url", "data"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    GetPlansResponse
+    """ # noqa: E501
+    has_more: StrictBool = Field(description="Indicates if there are more pages to be requested")
+    object: StrictStr = Field(description="Object type, in this case is list")
+    next_page_url: Optional[StrictStr] = Field(default=None, description="URL of the next page.")
+    previous_page_url: Optional[StrictStr] = Field(default=None, description="Url of the previous page.")
+    data: Optional[List[PlanResponse]] = None
+    __properties: ClassVar[List[str]] = ["has_more", "object", "next_page_url", "previous_page_url", "data"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> LogsResponse:
-        """Create an instance of LogsResponse from a JSON string"""
+    def from_json(cls, json_str: str) -> Self:
+        """Create an instance of GetPlansResponse from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                            "has_more",
-                            "object",
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude={
+            },
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of each item in data (list)
         _items = []
         if self.data:
             for _item in self.data:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['data'] = _items
         # set to None if next_page_url (nullable) is None
-        # and __fields_set__ contains the field
-        if self.next_page_url is None and "next_page_url" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.next_page_url is None and "next_page_url" in self.model_fields_set:
             _dict['next_page_url'] = None
 
         # set to None if previous_page_url (nullable) is None
-        # and __fields_set__ contains the field
-        if self.previous_page_url is None and "previous_page_url" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.previous_page_url is None and "previous_page_url" in self.model_fields_set:
             _dict['previous_page_url'] = None
 
-        # set to None if data (nullable) is None
-        # and __fields_set__ contains the field
-        if self.data is None and "data" in self.__fields_set__:
-            _dict['data'] = None
-
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> LogsResponse:
-        """Create an instance of LogsResponse from a dict"""
+    def from_dict(cls, obj: Dict) -> Self:
+        """Create an instance of GetPlansResponse from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return LogsResponse.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = LogsResponse.parse_obj({
+        _obj = cls.model_validate({
             "has_more": obj.get("has_more"),
             "object": obj.get("object"),
             "next_page_url": obj.get("next_page_url"),
             "previous_page_url": obj.get("previous_page_url"),
-            "data": [LogsResponseData.from_dict(_item) for _item in obj.get("data")] if obj.get("data") is not None else None
+            "data": [PlanResponse.from_dict(_item) for _item in obj.get("data")] if obj.get("data") is not None else None
         })
         return _obj
 
+
```

### Comparing `conekta-6.0.1/conekta/models/logs_response_data.py` & `conekta-6.0.2/conekta/models/logs_response_data.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,108 +1,124 @@
 # coding: utf-8
 
 """
     Conekta API
 
-    Conekta sdk  # noqa: E501
+    Conekta sdk
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
-"""
+"""  # noqa: E501
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
 
-from typing import Any, Dict, List, Optional
-from pydantic import BaseModel, StrictBool, StrictInt, StrictStr, conlist
+from typing import Any, ClassVar, Dict, List, Optional, Union
+from pydantic import BaseModel, StrictBool, StrictInt, StrictStr
+try:
+    from typing import Self
+except ImportError:
+    from typing_extensions import Self
 
 class LogsResponseData(BaseModel):
     """
     LogsResponseData
-    """
+    """ # noqa: E501
     created_at: Optional[StrictInt] = None
     id: Optional[StrictStr] = None
     ip_address: Optional[StrictStr] = None
     livemode: Optional[StrictBool] = None
     loggable_id: Optional[StrictStr] = None
     loggable_type: Optional[StrictStr] = None
     method: Optional[StrictStr] = None
     oauth_token_id: Optional[StrictStr] = None
     query_string: Optional[Dict[str, Any]] = None
     related: Optional[StrictStr] = None
-    request_body: Optional[Dict[str, Any]] = None
+    request_body: Optional[Union[str, Any]] = None
     request_headers: Optional[Dict[str, StrictStr]] = None
-    response_body: Optional[Dict[str, Any]] = None
+    response_body: Optional[Union[str, Any]] = None
     response_headers: Optional[Dict[str, StrictStr]] = None
-    searchable_tags: Optional[conlist(StrictStr)] = None
+    searchable_tags: Optional[List[StrictStr]] = None
     status: Optional[StrictStr] = None
     updated_at: Optional[StrictStr] = None
     url: Optional[StrictStr] = None
     user_account_id: Optional[StrictStr] = None
     version: Optional[StrictStr] = None
-    __properties = ["created_at", "id", "ip_address", "livemode", "loggable_id", "loggable_type", "method", "oauth_token_id", "query_string", "related", "request_body", "request_headers", "response_body", "response_headers", "searchable_tags", "status", "updated_at", "url", "user_account_id", "version"]
+    __properties: ClassVar[List[str]] = ["created_at", "id", "ip_address", "livemode", "loggable_id", "loggable_type", "method", "oauth_token_id", "query_string", "related", "request_body", "request_headers", "response_body", "response_headers", "searchable_tags", "status", "updated_at", "url", "user_account_id", "version"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True
+    }
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> LogsResponseData:
+    def from_json(cls, json_str: str) -> Self:
         """Create an instance of LogsResponseData from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude={
+            },
+            exclude_none=True,
+        )
         # set to None if loggable_id (nullable) is None
-        # and __fields_set__ contains the field
-        if self.loggable_id is None and "loggable_id" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.loggable_id is None and "loggable_id" in self.model_fields_set:
             _dict['loggable_id'] = None
 
         # set to None if loggable_type (nullable) is None
-        # and __fields_set__ contains the field
-        if self.loggable_type is None and "loggable_type" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.loggable_type is None and "loggable_type" in self.model_fields_set:
             _dict['loggable_type'] = None
 
         # set to None if oauth_token_id (nullable) is None
-        # and __fields_set__ contains the field
-        if self.oauth_token_id is None and "oauth_token_id" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.oauth_token_id is None and "oauth_token_id" in self.model_fields_set:
             _dict['oauth_token_id'] = None
 
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> LogsResponseData:
+    def from_dict(cls, obj: Dict) -> Self:
         """Create an instance of LogsResponseData from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return LogsResponseData.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = LogsResponseData.parse_obj({
+        _obj = cls.model_validate({
             "created_at": obj.get("created_at"),
             "id": obj.get("id"),
             "ip_address": obj.get("ip_address"),
             "livemode": obj.get("livemode"),
             "loggable_id": obj.get("loggable_id"),
             "loggable_type": obj.get("loggable_type"),
             "method": obj.get("method"),
@@ -118,7 +134,8 @@
             "updated_at": obj.get("updated_at"),
             "url": obj.get("url"),
             "user_account_id": obj.get("user_account_id"),
             "version": obj.get("version")
         })
         return _obj
 
+
```

### Comparing `conekta-6.0.1/conekta/models/order_discount_lines_request.py` & `conekta-6.0.2/conekta/models/order_discount_lines_request.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,75 +1,94 @@
 # coding: utf-8
 
 """
     Conekta API
 
-    Conekta sdk  # noqa: E501
+    Conekta sdk
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
-"""
+"""  # noqa: E501
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
 
-
-from pydantic import BaseModel, Field, StrictStr, conint
+from typing import Any, ClassVar, Dict, List
+from pydantic import BaseModel, StrictStr
+from pydantic import Field
+from typing_extensions import Annotated
+try:
+    from typing import Self
+except ImportError:
+    from typing_extensions import Self
 
 class OrderDiscountLinesRequest(BaseModel):
     """
     List of discounts that apply to the order.
-    """
-    amount: conint(strict=True, ge=0) = Field(..., description="The amount to be deducted from the total sum of all payments, in cents.")
-    code: StrictStr = Field(..., description="Discount code.")
-    type: StrictStr = Field(..., description="It can be 'loyalty', 'campaign', 'coupon' o 'sign'")
-    __properties = ["amount", "code", "type"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    """ # noqa: E501
+    amount: Annotated[int, Field(strict=True, ge=0)] = Field(description="The amount to be deducted from the total sum of all payments, in cents.")
+    code: StrictStr = Field(description="Discount code.")
+    type: StrictStr = Field(description="It can be 'loyalty', 'campaign', 'coupon' o 'sign'")
+    __properties: ClassVar[List[str]] = ["amount", "code", "type"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> OrderDiscountLinesRequest:
+    def from_json(cls, json_str: str) -> Self:
         """Create an instance of OrderDiscountLinesRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude={
+            },
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> OrderDiscountLinesRequest:
+    def from_dict(cls, obj: Dict) -> Self:
         """Create an instance of OrderDiscountLinesRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return OrderDiscountLinesRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = OrderDiscountLinesRequest.parse_obj({
+        _obj = cls.model_validate({
             "amount": obj.get("amount"),
             "code": obj.get("code"),
             "type": obj.get("type")
         })
         return _obj
 
+
```

### Comparing `conekta-6.0.1/conekta/models/order_refund_request.py` & `conekta-6.0.2/conekta/models/order_refund_request.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,80 +1,97 @@
 # coding: utf-8
 
 """
     Conekta API
 
-    Conekta sdk  # noqa: E501
+    Conekta sdk
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
-"""
+"""  # noqa: E501
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
 
-from typing import Optional
-from pydantic import BaseModel, Field, StrictInt, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from pydantic import BaseModel, StrictInt, StrictStr
+try:
+    from typing import Self
+except ImportError:
+    from typing_extensions import Self
 
 class OrderRefundRequest(BaseModel):
     """
     OrderRefundRequest
-    """
-    amount: StrictInt = Field(...)
+    """ # noqa: E501
+    amount: StrictInt
     expires_at: Optional[StrictInt] = None
-    reason: StrictStr = Field(...)
-    __properties = ["amount", "expires_at", "reason"]
+    reason: StrictStr
+    __properties: ClassVar[List[str]] = ["amount", "expires_at", "reason"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True
+    }
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> OrderRefundRequest:
+    def from_json(cls, json_str: str) -> Self:
         """Create an instance of OrderRefundRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude={
+            },
+            exclude_none=True,
+        )
         # set to None if expires_at (nullable) is None
-        # and __fields_set__ contains the field
-        if self.expires_at is None and "expires_at" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.expires_at is None and "expires_at" in self.model_fields_set:
             _dict['expires_at'] = None
 
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> OrderRefundRequest:
+    def from_dict(cls, obj: Dict) -> Self:
         """Create an instance of OrderRefundRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return OrderRefundRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = OrderRefundRequest.parse_obj({
+        _obj = cls.model_validate({
             "amount": obj.get("amount"),
             "expires_at": obj.get("expires_at"),
             "reason": obj.get("reason")
         })
         return _obj
 
+
```

### Comparing `conekta-6.0.1/conekta/models/order_request.py` & `conekta-6.0.2/conekta/models/order_update_request.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,82 +1,100 @@
 # coding: utf-8
 
 """
     Conekta API
 
-    Conekta sdk  # noqa: E501
+    Conekta sdk
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
-"""
+"""  # noqa: E501
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
 
-from typing import Any, Dict, List, Optional
-from pydantic import BaseModel, Field, StrictBool, StrictStr, conlist, constr
+from typing import Any, ClassVar, Dict, List, Optional
+from pydantic import BaseModel, StrictBool, StrictStr
+from pydantic import Field
+from typing_extensions import Annotated
 from conekta.models.charge_request import ChargeRequest
 from conekta.models.checkout_request import CheckoutRequest
 from conekta.models.customer_shipping_contacts import CustomerShippingContacts
 from conekta.models.order_discount_lines_request import OrderDiscountLinesRequest
-from conekta.models.order_request_customer_info import OrderRequestCustomerInfo
 from conekta.models.order_tax_request import OrderTaxRequest
+from conekta.models.order_update_fiscal_entity_request import OrderUpdateFiscalEntityRequest
+from conekta.models.order_update_request_customer_info import OrderUpdateRequestCustomerInfo
 from conekta.models.product import Product
 from conekta.models.shipping_request import ShippingRequest
+try:
+    from typing import Self
+except ImportError:
+    from typing_extensions import Self
 
-class OrderRequest(BaseModel):
+class OrderUpdateRequest(BaseModel):
     """
     a order
-    """
-    charges: Optional[conlist(ChargeRequest)] = Field(None, description="List of [charges](https://developers.conekta.com/v2.1.0/reference/orderscreatecharge) that are applied to the order")
+    """ # noqa: E501
+    charges: Optional[List[ChargeRequest]] = None
     checkout: Optional[CheckoutRequest] = None
-    currency: constr(strict=True, max_length=3) = Field(..., description="Currency with which the payment will be made. It uses the 3-letter code of the [International Standard ISO 4217.](https://es.wikipedia.org/wiki/ISO_4217)")
-    customer_info: OrderRequestCustomerInfo = Field(...)
-    discount_lines: Optional[conlist(OrderDiscountLinesRequest)] = Field(None, description="List of [discounts](https://developers.conekta.com/v2.1.0/reference/orderscreatediscountline) that are applied to the order. You must have at least one discount.")
-    line_items: conlist(Product) = Field(..., description="List of [products](https://developers.conekta.com/v2.1.0/reference/orderscreateproduct) that are sold in the order. You must have at least one product.")
-    metadata: Optional[Dict[str, Any]] = Field(None, description="Metadata associated with the order")
-    needs_shipping_contact: Optional[StrictBool] = Field(None, description="Allows you to fill out the shipping information at checkout")
-    pre_authorize: Optional[StrictBool] = Field(False, description="Indicates whether the order charges must be preauthorized")
-    processing_mode: Optional[StrictStr] = Field(None, description="Indicates the processing mode for the order, either ecommerce, recurrent or validation.")
+    currency: Optional[Annotated[str, Field(strict=True, max_length=3)]] = Field(default=None, description="Currency with which the payment will be made. It uses the 3-letter code of the [International Standard ISO 4217.](https://es.wikipedia.org/wiki/ISO_4217)")
+    customer_info: Optional[OrderUpdateRequestCustomerInfo] = None
+    discount_lines: Optional[List[OrderDiscountLinesRequest]] = Field(default=None, description="List of [discounts](https://developers.conekta.com/v2.1.0/reference/orderscreatediscountline) that are applied to the order. You must have at least one discount.")
+    fiscal_entity: Optional[OrderUpdateFiscalEntityRequest] = None
+    line_items: Optional[List[Product]] = Field(default=None, description="List of [products](https://developers.conekta.com/v2.1.0/reference/orderscreateproduct) that are sold in the order. You must have at least one product.")
+    metadata: Optional[Dict[str, StrictStr]] = None
+    pre_authorize: Optional[StrictBool] = Field(default=False, description="Indicates whether the order charges must be preauthorized")
     shipping_contact: Optional[CustomerShippingContacts] = None
-    shipping_lines: Optional[conlist(ShippingRequest)] = Field(None, description="List of [shipping costs](https://developers.conekta.com/v2.1.0/reference/orderscreateshipping). If the online store offers digital products.")
-    tax_lines: Optional[conlist(OrderTaxRequest)] = Field(None, description="List of [taxes](https://developers.conekta.com/v2.1.0/reference/orderscreatetaxes) that are applied to the order.")
-    __properties = ["charges", "checkout", "currency", "customer_info", "discount_lines", "line_items", "metadata", "needs_shipping_contact", "pre_authorize", "processing_mode", "shipping_contact", "shipping_lines", "tax_lines"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    shipping_lines: Optional[List[ShippingRequest]] = Field(default=None, description="List of [shipping costs](https://developers.conekta.com/v2.1.0/reference/orderscreateshipping). If the online store offers digital products.")
+    tax_lines: Optional[List[OrderTaxRequest]] = None
+    __properties: ClassVar[List[str]] = ["charges", "checkout", "currency", "customer_info", "discount_lines", "fiscal_entity", "line_items", "metadata", "pre_authorize", "shipping_contact", "shipping_lines", "tax_lines"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> OrderRequest:
-        """Create an instance of OrderRequest from a JSON string"""
+    def from_json(cls, json_str: str) -> Self:
+        """Create an instance of OrderUpdateRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude={
+            },
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of each item in charges (list)
         _items = []
         if self.charges:
             for _item in self.charges:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['charges'] = _items
@@ -89,14 +107,17 @@
         # override the default output from pydantic by calling `to_dict()` of each item in discount_lines (list)
         _items = []
         if self.discount_lines:
             for _item in self.discount_lines:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['discount_lines'] = _items
+        # override the default output from pydantic by calling `to_dict()` of fiscal_entity
+        if self.fiscal_entity:
+            _dict['fiscal_entity'] = self.fiscal_entity.to_dict()
         # override the default output from pydantic by calling `to_dict()` of each item in line_items (list)
         _items = []
         if self.line_items:
             for _item in self.line_items:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['line_items'] = _items
@@ -116,32 +137,32 @@
             for _item in self.tax_lines:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['tax_lines'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> OrderRequest:
-        """Create an instance of OrderRequest from a dict"""
+    def from_dict(cls, obj: Dict) -> Self:
+        """Create an instance of OrderUpdateRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return OrderRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = OrderRequest.parse_obj({
+        _obj = cls.model_validate({
             "charges": [ChargeRequest.from_dict(_item) for _item in obj.get("charges")] if obj.get("charges") is not None else None,
             "checkout": CheckoutRequest.from_dict(obj.get("checkout")) if obj.get("checkout") is not None else None,
             "currency": obj.get("currency"),
-            "customer_info": OrderRequestCustomerInfo.from_dict(obj.get("customer_info")) if obj.get("customer_info") is not None else None,
+            "customer_info": OrderUpdateRequestCustomerInfo.from_dict(obj.get("customer_info")) if obj.get("customer_info") is not None else None,
             "discount_lines": [OrderDiscountLinesRequest.from_dict(_item) for _item in obj.get("discount_lines")] if obj.get("discount_lines") is not None else None,
+            "fiscal_entity": OrderUpdateFiscalEntityRequest.from_dict(obj.get("fiscal_entity")) if obj.get("fiscal_entity") is not None else None,
             "line_items": [Product.from_dict(_item) for _item in obj.get("line_items")] if obj.get("line_items") is not None else None,
             "metadata": obj.get("metadata"),
-            "needs_shipping_contact": obj.get("needs_shipping_contact"),
             "pre_authorize": obj.get("pre_authorize") if obj.get("pre_authorize") is not None else False,
-            "processing_mode": obj.get("processing_mode"),
             "shipping_contact": CustomerShippingContacts.from_dict(obj.get("shipping_contact")) if obj.get("shipping_contact") is not None else None,
             "shipping_lines": [ShippingRequest.from_dict(_item) for _item in obj.get("shipping_lines")] if obj.get("shipping_lines") is not None else None,
             "tax_lines": [OrderTaxRequest.from_dict(_item) for _item in obj.get("tax_lines")] if obj.get("tax_lines") is not None else None
         })
         return _obj
 
+
```

### Comparing `conekta-6.0.1/conekta/models/order_request_customer_info.py` & `conekta-6.0.2/conekta/models/order_request_customer_info.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,64 +1,71 @@
 # coding: utf-8
 
 """
     Conekta API
 
-    Conekta sdk  # noqa: E501
+    Conekta sdk
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
-"""
+"""  # noqa: E501
 
 
 from __future__ import annotations
 from inspect import getfullargspec
 import json
 import pprint
 import re  # noqa: F401
 
 from typing import Any, List, Optional
-from pydantic import BaseModel, Field, StrictStr, ValidationError, validator
+from pydantic import BaseModel, Field, StrictStr, ValidationError, field_validator
 from conekta.models.customer_info import CustomerInfo
 from conekta.models.customer_info_just_customer_id import CustomerInfoJustCustomerId
-from typing import Any, List
+from typing import Union, Any, List, TYPE_CHECKING, Optional, Dict
+from typing_extensions import Literal
 from pydantic import StrictStr, Field
+try:
+    from typing import Self
+except ImportError:
+    from typing_extensions import Self
 
 ORDERREQUESTCUSTOMERINFO_ONE_OF_SCHEMAS = ["CustomerInfo", "CustomerInfoJustCustomerId"]
 
 class OrderRequestCustomerInfo(BaseModel):
     """
     Customer information
     """
     # data type: CustomerInfo
     oneof_schema_1_validator: Optional[CustomerInfo] = None
     # data type: CustomerInfoJustCustomerId
     oneof_schema_2_validator: Optional[CustomerInfoJustCustomerId] = None
-    actual_instance: Any
-    one_of_schemas: List[str] = Field(ORDERREQUESTCUSTOMERINFO_ONE_OF_SCHEMAS, const=True)
+    actual_instance: Optional[Union[CustomerInfo, CustomerInfoJustCustomerId]] = None
+    one_of_schemas: List[str] = Literal["CustomerInfo", "CustomerInfoJustCustomerId"]
+
+    model_config = {
+        "validate_assignment": True
+    }
 
-    class Config:
-        validate_assignment = True
 
-    def __init__(self, *args, **kwargs):
+    def __init__(self, *args, **kwargs) -> None:
         if args:
             if len(args) > 1:
                 raise ValueError("If a position argument is used, only 1 is allowed to set `actual_instance`")
             if kwargs:
                 raise ValueError("If a position argument is used, keyword arguments cannot be used.")
             super().__init__(actual_instance=args[0])
         else:
             super().__init__(**kwargs)
 
-    @validator('actual_instance')
+    @field_validator('actual_instance')
     def actual_instance_must_validate_oneof(cls, v):
-        instance = OrderRequestCustomerInfo.construct()
+        instance = OrderRequestCustomerInfo.model_construct()
         error_messages = []
         match = 0
         # validate data type: CustomerInfo
         if not isinstance(v, CustomerInfo):
             error_messages.append(f"Error! Input type `{type(v)}` is not `CustomerInfo`")
         else:
             match += 1
@@ -73,21 +80,21 @@
         elif match == 0:
             # no match
             raise ValueError("No match found when setting `actual_instance` in OrderRequestCustomerInfo with oneOf schemas: CustomerInfo, CustomerInfoJustCustomerId. Details: " + ", ".join(error_messages))
         else:
             return v
 
     @classmethod
-    def from_dict(cls, obj: dict) -> OrderRequestCustomerInfo:
+    def from_dict(cls, obj: dict) -> Self:
         return cls.from_json(json.dumps(obj))
 
     @classmethod
-    def from_json(cls, json_str: str) -> OrderRequestCustomerInfo:
+    def from_json(cls, json_str: str) -> Self:
         """Returns the object represented by the json string"""
-        instance = OrderRequestCustomerInfo.construct()
+        instance = cls.model_construct()
         error_messages = []
         match = 0
 
         # deserialize data into CustomerInfo
         try:
             instance.actual_instance = CustomerInfo.from_json(json_str)
             match += 1
@@ -116,23 +123,24 @@
 
         to_json = getattr(self.actual_instance, "to_json", None)
         if callable(to_json):
             return self.actual_instance.to_json()
         else:
             return json.dumps(self.actual_instance)
 
-    def to_dict(self) -> dict:
+    def to_dict(self) -> Dict:
         """Returns the dict representation of the actual instance"""
         if self.actual_instance is None:
             return None
 
         to_dict = getattr(self.actual_instance, "to_dict", None)
         if callable(to_dict):
             return self.actual_instance.to_dict()
         else:
             # primitive type
             return self.actual_instance
 
     def to_str(self) -> str:
         """Returns the string representation of the actual instance"""
-        return pprint.pformat(self.dict())
+        return pprint.pformat(self.model_dump())
+
```

### Comparing `conekta-6.0.1/conekta/models/order_response.py` & `conekta-6.0.2/conekta/models/order_response.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,89 +1,108 @@
 # coding: utf-8
 
 """
     Conekta API
 
-    Conekta sdk  # noqa: E501
+    Conekta sdk
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
-"""
+"""  # noqa: E501
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
 
-from typing import Any, Dict, Optional
-from pydantic import BaseModel, Field, StrictBool, StrictInt, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from pydantic import BaseModel, StrictBool, StrictInt, StrictStr
+from pydantic import Field
 from conekta.models.charge_response_channel import ChargeResponseChannel
+from conekta.models.order_fiscal_entity_response import OrderFiscalEntityResponse
+from conekta.models.order_next_action_response import OrderNextActionResponse
 from conekta.models.order_response_charges import OrderResponseCharges
 from conekta.models.order_response_checkout import OrderResponseCheckout
 from conekta.models.order_response_customer_info import OrderResponseCustomerInfo
 from conekta.models.order_response_discount_lines import OrderResponseDiscountLines
-from conekta.models.order_response_fiscal_entity import OrderResponseFiscalEntity
 from conekta.models.order_response_products import OrderResponseProducts
 from conekta.models.order_response_shipping_contact import OrderResponseShippingContact
+try:
+    from typing import Self
+except ImportError:
+    from typing_extensions import Self
 
 class OrderResponse(BaseModel):
     """
     order response
-    """
-    amount: Optional[StrictInt] = Field(None, description="The total amount to be collected in cents")
-    amount_refunded: Optional[StrictInt] = Field(None, description="The total amount refunded in cents")
+    """ # noqa: E501
+    amount: Optional[StrictInt] = Field(default=None, description="The total amount to be collected in cents")
+    amount_refunded: Optional[StrictInt] = Field(default=None, description="The total amount refunded in cents")
     channel: Optional[ChargeResponseChannel] = None
     charges: Optional[OrderResponseCharges] = None
     checkout: Optional[OrderResponseCheckout] = None
-    created_at: Optional[StrictInt] = Field(None, description="The time at which the object was created in seconds since the Unix epoch")
-    currency: Optional[StrictStr] = Field(None, description="The three-letter ISO 4217 currency code. The currency of the order.")
+    created_at: Optional[StrictInt] = Field(default=None, description="The time at which the object was created in seconds since the Unix epoch")
+    currency: Optional[StrictStr] = Field(default=None, description="The three-letter ISO 4217 currency code. The currency of the order.")
     customer_info: Optional[OrderResponseCustomerInfo] = None
     discount_lines: Optional[OrderResponseDiscountLines] = None
-    fiscal_entity: Optional[OrderResponseFiscalEntity] = None
+    fiscal_entity: Optional[OrderFiscalEntityResponse] = None
     id: Optional[StrictStr] = None
     is_refundable: Optional[StrictBool] = None
     line_items: Optional[OrderResponseProducts] = None
-    livemode: Optional[StrictBool] = Field(None, description="Whether the object exists in live mode or test mode")
-    metadata: Optional[Dict[str, Any]] = Field(None, description="Set of key-value pairs that you can attach to an object. This can be useful for storing additional information about the object in a structured format.")
-    object: Optional[StrictStr] = Field(None, description="String representing the objects type. Objects of the same type share the same value.")
-    payment_status: Optional[StrictStr] = Field(None, description="The payment status of the order.")
-    processing_mode: Optional[StrictStr] = Field(None, description="Indicates the processing mode for the order, either ecommerce, recurrent or validation.")
+    livemode: Optional[StrictBool] = Field(default=None, description="Whether the object exists in live mode or test mode")
+    metadata: Optional[Dict[str, Any]] = Field(default=None, description="Set of key-value pairs that you can attach to an object. This can be useful for storing additional information about the object in a structured format.")
+    next_action: Optional[OrderNextActionResponse] = None
+    object: Optional[StrictStr] = Field(default=None, description="String representing the objects type. Objects of the same type share the same value.")
+    payment_status: Optional[StrictStr] = Field(default=None, description="The payment status of the order.")
+    processing_mode: Optional[StrictStr] = Field(default=None, description="Indicates the processing mode for the order, either ecommerce, recurrent or validation.")
     shipping_contact: Optional[OrderResponseShippingContact] = None
-    updated_at: Optional[StrictInt] = Field(None, description="The time at which the object was last updated in seconds since the Unix epoch")
-    __properties = ["amount", "amount_refunded", "channel", "charges", "checkout", "created_at", "currency", "customer_info", "discount_lines", "fiscal_entity", "id", "is_refundable", "line_items", "livemode", "metadata", "object", "payment_status", "processing_mode", "shipping_contact", "updated_at"]
+    updated_at: Optional[StrictInt] = Field(default=None, description="The time at which the object was last updated in seconds since the Unix epoch")
+    __properties: ClassVar[List[str]] = ["amount", "amount_refunded", "channel", "charges", "checkout", "created_at", "currency", "customer_info", "discount_lines", "fiscal_entity", "id", "is_refundable", "line_items", "livemode", "metadata", "next_action", "object", "payment_status", "processing_mode", "shipping_contact", "updated_at"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True
+    }
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> OrderResponse:
+    def from_json(cls, json_str: str) -> Self:
         """Create an instance of OrderResponse from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude={
+            },
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of channel
         if self.channel:
             _dict['channel'] = self.channel.to_dict()
         # override the default output from pydantic by calling `to_dict()` of charges
         if self.charges:
             _dict['charges'] = self.charges.to_dict()
         # override the default output from pydantic by calling `to_dict()` of checkout
@@ -97,45 +116,55 @@
             _dict['discount_lines'] = self.discount_lines.to_dict()
         # override the default output from pydantic by calling `to_dict()` of fiscal_entity
         if self.fiscal_entity:
             _dict['fiscal_entity'] = self.fiscal_entity.to_dict()
         # override the default output from pydantic by calling `to_dict()` of line_items
         if self.line_items:
             _dict['line_items'] = self.line_items.to_dict()
+        # override the default output from pydantic by calling `to_dict()` of next_action
+        if self.next_action:
+            _dict['next_action'] = self.next_action.to_dict()
         # override the default output from pydantic by calling `to_dict()` of shipping_contact
         if self.shipping_contact:
             _dict['shipping_contact'] = self.shipping_contact.to_dict()
+        # set to None if fiscal_entity (nullable) is None
+        # and model_fields_set contains the field
+        if self.fiscal_entity is None and "fiscal_entity" in self.model_fields_set:
+            _dict['fiscal_entity'] = None
+
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> OrderResponse:
+    def from_dict(cls, obj: Dict) -> Self:
         """Create an instance of OrderResponse from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return OrderResponse.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = OrderResponse.parse_obj({
+        _obj = cls.model_validate({
             "amount": obj.get("amount"),
             "amount_refunded": obj.get("amount_refunded"),
             "channel": ChargeResponseChannel.from_dict(obj.get("channel")) if obj.get("channel") is not None else None,
             "charges": OrderResponseCharges.from_dict(obj.get("charges")) if obj.get("charges") is not None else None,
             "checkout": OrderResponseCheckout.from_dict(obj.get("checkout")) if obj.get("checkout") is not None else None,
             "created_at": obj.get("created_at"),
             "currency": obj.get("currency"),
             "customer_info": OrderResponseCustomerInfo.from_dict(obj.get("customer_info")) if obj.get("customer_info") is not None else None,
             "discount_lines": OrderResponseDiscountLines.from_dict(obj.get("discount_lines")) if obj.get("discount_lines") is not None else None,
-            "fiscal_entity": OrderResponseFiscalEntity.from_dict(obj.get("fiscal_entity")) if obj.get("fiscal_entity") is not None else None,
+            "fiscal_entity": OrderFiscalEntityResponse.from_dict(obj.get("fiscal_entity")) if obj.get("fiscal_entity") is not None else None,
             "id": obj.get("id"),
             "is_refundable": obj.get("is_refundable"),
             "line_items": OrderResponseProducts.from_dict(obj.get("line_items")) if obj.get("line_items") is not None else None,
             "livemode": obj.get("livemode"),
             "metadata": obj.get("metadata"),
+            "next_action": OrderNextActionResponse.from_dict(obj.get("next_action")) if obj.get("next_action") is not None else None,
             "object": obj.get("object"),
             "payment_status": obj.get("payment_status"),
             "processing_mode": obj.get("processing_mode"),
             "shipping_contact": OrderResponseShippingContact.from_dict(obj.get("shipping_contact")) if obj.get("shipping_contact") is not None else None,
             "updated_at": obj.get("updated_at")
         })
         return _obj
 
+
```

### Comparing `conekta-6.0.1/conekta/models/order_response_charges.py` & `conekta-6.0.2/conekta/models/get_events_response_all_of.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,83 +1,96 @@
 # coding: utf-8
 
 """
     Conekta API
 
-    Conekta sdk  # noqa: E501
+    Conekta sdk
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
-"""
+"""  # noqa: E501
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
 
-from typing import List, Optional
-from pydantic import BaseModel, Field, StrictBool, StrictStr, conlist
-from conekta.models.charges_data_response import ChargesDataResponse
+from typing import Any, ClassVar, Dict, List, Optional
+from pydantic import BaseModel
+from conekta.models.event_response import EventResponse
+try:
+    from typing import Self
+except ImportError:
+    from typing_extensions import Self
 
-class OrderResponseCharges(BaseModel):
-    """
-    The charges associated with the order
+class GetEventsResponseAllOf(BaseModel):
     """
-    has_more: StrictBool = Field(..., description="Indicates if there are more pages to be requested")
-    object: StrictStr = Field(..., description="Object type, in this case is list")
-    data: Optional[conlist(ChargesDataResponse)] = None
-    __properties = ["has_more", "object", "data"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    GetEventsResponseAllOf
+    """ # noqa: E501
+    data: Optional[List[EventResponse]] = None
+    __properties: ClassVar[List[str]] = ["data"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> OrderResponseCharges:
-        """Create an instance of OrderResponseCharges from a JSON string"""
+    def from_json(cls, json_str: str) -> Self:
+        """Create an instance of GetEventsResponseAllOf from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude={
+            },
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of each item in data (list)
         _items = []
         if self.data:
             for _item in self.data:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['data'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> OrderResponseCharges:
-        """Create an instance of OrderResponseCharges from a dict"""
+    def from_dict(cls, obj: Dict) -> Self:
+        """Create an instance of GetEventsResponseAllOf from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return OrderResponseCharges.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = OrderResponseCharges.parse_obj({
-            "has_more": obj.get("has_more"),
-            "object": obj.get("object"),
-            "data": [ChargesDataResponse.from_dict(_item) for _item in obj.get("data")] if obj.get("data") is not None else None
+        _obj = cls.model_validate({
+            "data": [EventResponse.from_dict(_item) for _item in obj.get("data")] if obj.get("data") is not None else None
         })
         return _obj
 
+
```

### Comparing `conekta-6.0.1/conekta/models/order_response_charges_all_of.py` & `conekta-6.0.2/conekta/models/order_response_charges_all_of.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,79 +1,96 @@
 # coding: utf-8
 
 """
     Conekta API
 
-    Conekta sdk  # noqa: E501
+    Conekta sdk
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
-"""
+"""  # noqa: E501
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
 
-from typing import List, Optional
-from pydantic import BaseModel, conlist
+from typing import Any, ClassVar, Dict, List, Optional
+from pydantic import BaseModel
 from conekta.models.charges_data_response import ChargesDataResponse
+try:
+    from typing import Self
+except ImportError:
+    from typing_extensions import Self
 
 class OrderResponseChargesAllOf(BaseModel):
     """
     OrderResponseChargesAllOf
-    """
-    data: Optional[conlist(ChargesDataResponse)] = None
-    __properties = ["data"]
+    """ # noqa: E501
+    data: Optional[List[ChargesDataResponse]] = None
+    __properties: ClassVar[List[str]] = ["data"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True
+    }
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> OrderResponseChargesAllOf:
+    def from_json(cls, json_str: str) -> Self:
         """Create an instance of OrderResponseChargesAllOf from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude={
+            },
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of each item in data (list)
         _items = []
         if self.data:
             for _item in self.data:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['data'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> OrderResponseChargesAllOf:
+    def from_dict(cls, obj: Dict) -> Self:
         """Create an instance of OrderResponseChargesAllOf from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return OrderResponseChargesAllOf.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = OrderResponseChargesAllOf.parse_obj({
+        _obj = cls.model_validate({
             "data": [ChargesDataResponse.from_dict(_item) for _item in obj.get("data")] if obj.get("data") is not None else None
         })
         return _obj
 
+
```

### Comparing `conekta-6.0.1/conekta/models/order_response_checkout.py` & `conekta-6.0.2/conekta/models/token_response_checkout.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,126 +1,133 @@
 # coding: utf-8
 
 """
     Conekta API
 
-    Conekta sdk  # noqa: E501
+    Conekta sdk
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
-"""
+"""  # noqa: E501
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
 
-from typing import Any, Dict, List, Optional
-from pydantic import BaseModel, StrictBool, StrictInt, StrictStr, conlist
+from typing import Any, ClassVar, Dict, List, Optional
+from pydantic import BaseModel, StrictBool, StrictInt, StrictStr
+from pydantic import Field
+try:
+    from typing import Self
+except ImportError:
+    from typing_extensions import Self
 
-class OrderResponseCheckout(BaseModel):
-    """
-    OrderResponseCheckout
+class TokenResponseCheckout(BaseModel):
     """
-    allowed_payment_methods: Optional[conlist(StrictStr)] = None
-    can_not_expire: Optional[StrictBool] = None
+    TokenResponseCheckout
+    """ # noqa: E501
+    allowed_payment_methods: Optional[List[StrictStr]] = None
+    can_not_expire: Optional[StrictBool] = Field(default=None, description="Indicates if the checkout can not expire.")
     emails_sent: Optional[StrictInt] = None
-    exclude_card_networks: Optional[conlist(Dict[str, Any])] = None
-    expires_at: Optional[StrictInt] = None
-    failure_url: Optional[StrictStr] = None
-    force_3ds_flow: Optional[StrictBool] = None
+    exclude_card_networks: Optional[List[StrictStr]] = None
+    expires_at: Optional[StrictInt] = Field(default=None, description="Date and time when the checkout expires.")
+    failure_url: Optional[StrictStr] = Field(default=None, description="URL to redirect the customer to if the payment process fails.")
+    force_3ds_flow: Optional[StrictBool] = Field(default=None, description="Indicates if the checkout forces the 3DS flow.")
     id: Optional[StrictStr] = None
-    is_redirect_on_failure: Optional[StrictBool] = None
     livemode: Optional[StrictBool] = None
     metadata: Optional[Dict[str, Any]] = None
-    monthly_installments_enabled: Optional[StrictBool] = None
-    monthly_installments_options: Optional[conlist(StrictInt)] = None
+    monthly_installments_enabled: Optional[StrictBool] = Field(default=None, description="Indicates if the checkout allows monthly installments.")
+    monthly_installments_options: Optional[List[StrictInt]] = Field(default=None, description="List of monthly installments options.")
     name: Optional[StrictStr] = None
     needs_shipping_contact: Optional[StrictBool] = None
-    object: Optional[StrictStr] = None
-    on_demand_enabled: Optional[StrictBool] = None
-    paid_payments_count: Optional[StrictInt] = None
-    recurrent: Optional[StrictBool] = None
-    slug: Optional[StrictStr] = None
+    object: Optional[StrictStr] = Field(default=None, description="Indicates the type of object, in this case checkout.")
+    on_demand_enabled: Optional[StrictBool] = Field(default=None, description="Indicates if the checkout allows on demand payments.")
+    paid_payments_count: Optional[StrictInt] = Field(default=None, description="Number of payments that have been paid.")
+    recurrent: Optional[StrictBool] = Field(default=None, description="Indicates if the checkout is recurrent.")
     sms_sent: Optional[StrictInt] = None
-    success_url: Optional[StrictStr] = None
-    starts_at: Optional[StrictInt] = None
-    status: Optional[StrictStr] = None
-    type: Optional[StrictStr] = None
-    url: Optional[StrictStr] = None
-    __properties = ["allowed_payment_methods", "can_not_expire", "emails_sent", "exclude_card_networks", "expires_at", "failure_url", "force_3ds_flow", "id", "is_redirect_on_failure", "livemode", "metadata", "monthly_installments_enabled", "monthly_installments_options", "name", "needs_shipping_contact", "object", "on_demand_enabled", "paid_payments_count", "recurrent", "slug", "sms_sent", "success_url", "starts_at", "status", "type", "url"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    starts_at: Optional[StrictInt] = Field(default=None, description="Date and time when the checkout starts.")
+    status: Optional[StrictStr] = Field(default=None, description="Status of the checkout.")
+    success_url: Optional[StrictStr] = Field(default=None, description="URL to redirect the customer to after the payment process is completed.")
+    type: Optional[StrictStr] = Field(default=None, description="Type of checkout.")
+    __properties: ClassVar[List[str]] = ["allowed_payment_methods", "can_not_expire", "emails_sent", "exclude_card_networks", "expires_at", "failure_url", "force_3ds_flow", "id", "livemode", "metadata", "monthly_installments_enabled", "monthly_installments_options", "name", "needs_shipping_contact", "object", "on_demand_enabled", "paid_payments_count", "recurrent", "sms_sent", "starts_at", "status", "success_url", "type"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> OrderResponseCheckout:
-        """Create an instance of OrderResponseCheckout from a JSON string"""
+    def from_json(cls, json_str: str) -> Self:
+        """Create an instance of TokenResponseCheckout from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
-        # set to None if on_demand_enabled (nullable) is None
-        # and __fields_set__ contains the field
-        if self.on_demand_enabled is None and "on_demand_enabled" in self.__fields_set__:
-            _dict['on_demand_enabled'] = None
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
 
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude={
+            },
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> OrderResponseCheckout:
-        """Create an instance of OrderResponseCheckout from a dict"""
+    def from_dict(cls, obj: Dict) -> Self:
+        """Create an instance of TokenResponseCheckout from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return OrderResponseCheckout.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = OrderResponseCheckout.parse_obj({
+        _obj = cls.model_validate({
             "allowed_payment_methods": obj.get("allowed_payment_methods"),
             "can_not_expire": obj.get("can_not_expire"),
             "emails_sent": obj.get("emails_sent"),
             "exclude_card_networks": obj.get("exclude_card_networks"),
             "expires_at": obj.get("expires_at"),
             "failure_url": obj.get("failure_url"),
             "force_3ds_flow": obj.get("force_3ds_flow"),
             "id": obj.get("id"),
-            "is_redirect_on_failure": obj.get("is_redirect_on_failure"),
             "livemode": obj.get("livemode"),
             "metadata": obj.get("metadata"),
             "monthly_installments_enabled": obj.get("monthly_installments_enabled"),
             "monthly_installments_options": obj.get("monthly_installments_options"),
             "name": obj.get("name"),
             "needs_shipping_contact": obj.get("needs_shipping_contact"),
             "object": obj.get("object"),
             "on_demand_enabled": obj.get("on_demand_enabled"),
             "paid_payments_count": obj.get("paid_payments_count"),
             "recurrent": obj.get("recurrent"),
-            "slug": obj.get("slug"),
             "sms_sent": obj.get("sms_sent"),
-            "success_url": obj.get("success_url"),
             "starts_at": obj.get("starts_at"),
             "status": obj.get("status"),
-            "type": obj.get("type"),
-            "url": obj.get("url")
+            "success_url": obj.get("success_url"),
+            "type": obj.get("type")
         })
         return _obj
 
+
```

### Comparing `conekta-6.0.1/conekta/models/order_response_discount_lines.py` & `conekta-6.0.2/conekta/models/order_response_discount_lines.py`

 * *Files 25% similar despite different names*

```diff
@@ -1,83 +1,101 @@
 # coding: utf-8
 
 """
     Conekta API
 
-    Conekta sdk  # noqa: E501
+    Conekta sdk
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
-"""
+"""  # noqa: E501
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
 
-from typing import List, Optional
-from pydantic import BaseModel, Field, StrictBool, StrictStr, conlist
+from typing import Any, ClassVar, Dict, List, Optional
+from pydantic import BaseModel, StrictBool, StrictStr
+from pydantic import Field
 from conekta.models.discount_lines_data_response import DiscountLinesDataResponse
+try:
+    from typing import Self
+except ImportError:
+    from typing_extensions import Self
 
 class OrderResponseDiscountLines(BaseModel):
     """
     OrderResponseDiscountLines
-    """
-    has_more: StrictBool = Field(..., description="Indicates if there are more pages to be requested")
-    object: StrictStr = Field(..., description="Object type, in this case is list")
-    data: Optional[conlist(DiscountLinesDataResponse)] = None
-    __properties = ["has_more", "object", "data"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    """ # noqa: E501
+    has_more: StrictBool = Field(description="Indicates if there are more pages to be requested")
+    object: StrictStr = Field(description="Object type, in this case is list")
+    data: Optional[List[DiscountLinesDataResponse]] = None
+    __properties: ClassVar[List[str]] = ["has_more", "object", "data"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> OrderResponseDiscountLines:
+    def from_json(cls, json_str: str) -> Self:
         """Create an instance of OrderResponseDiscountLines from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude={
+            },
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of each item in data (list)
         _items = []
         if self.data:
             for _item in self.data:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['data'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> OrderResponseDiscountLines:
+    def from_dict(cls, obj: Dict) -> Self:
         """Create an instance of OrderResponseDiscountLines from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return OrderResponseDiscountLines.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = OrderResponseDiscountLines.parse_obj({
+        _obj = cls.model_validate({
             "has_more": obj.get("has_more"),
             "object": obj.get("object"),
             "data": [DiscountLinesDataResponse.from_dict(_item) for _item in obj.get("data")] if obj.get("data") is not None else None
         })
         return _obj
 
+
```

### Comparing `conekta-6.0.1/conekta/models/order_response_fiscal_entity_address.py` & `conekta-6.0.2/conekta/models/update_customer_fiscal_entities_response_all_of.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,87 +1,96 @@
 # coding: utf-8
 
 """
     Conekta API
 
-    Conekta sdk  # noqa: E501
+    Conekta sdk
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
-"""
+"""  # noqa: E501
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
 
-from typing import Optional
-from pydantic import BaseModel, Field, StrictBool, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from pydantic import BaseModel, StrictBool, StrictInt, StrictStr
+try:
+    from typing import Self
+except ImportError:
+    from typing_extensions import Self
 
-class OrderResponseFiscalEntityAddress(BaseModel):
-    """
-    OrderResponseFiscalEntityAddress
+class UpdateCustomerFiscalEntitiesResponseAllOf(BaseModel):
     """
-    street1: StrictStr = Field(...)
-    street2: Optional[StrictStr] = None
-    postal_code: StrictStr = Field(...)
-    city: StrictStr = Field(...)
-    state: Optional[StrictStr] = None
-    country: Optional[StrictStr] = Field(None, description="this field follows the [ISO 3166-1 alpha-2 standard](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2)")
-    residential: Optional[StrictBool] = None
-    external_number: Optional[StrictStr] = None
-    object: Optional[StrictStr] = None
-    __properties = ["street1", "street2", "postal_code", "city", "state", "country", "residential", "external_number", "object"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    UpdateCustomerFiscalEntitiesResponseAllOf
+    """ # noqa: E501
+    id: StrictStr
+    object: StrictStr
+    created_at: StrictInt
+    parent_id: Optional[StrictStr] = None
+    default: Optional[StrictBool] = None
+    __properties: ClassVar[List[str]] = ["id", "object", "created_at", "parent_id", "default"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> OrderResponseFiscalEntityAddress:
-        """Create an instance of OrderResponseFiscalEntityAddress from a JSON string"""
+    def from_json(cls, json_str: str) -> Self:
+        """Create an instance of UpdateCustomerFiscalEntitiesResponseAllOf from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude={
+            },
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> OrderResponseFiscalEntityAddress:
-        """Create an instance of OrderResponseFiscalEntityAddress from a dict"""
+    def from_dict(cls, obj: Dict) -> Self:
+        """Create an instance of UpdateCustomerFiscalEntitiesResponseAllOf from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return OrderResponseFiscalEntityAddress.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = OrderResponseFiscalEntityAddress.parse_obj({
-            "street1": obj.get("street1"),
-            "street2": obj.get("street2"),
-            "postal_code": obj.get("postal_code"),
-            "city": obj.get("city"),
-            "state": obj.get("state"),
-            "country": obj.get("country"),
-            "residential": obj.get("residential"),
-            "external_number": obj.get("external_number"),
-            "object": obj.get("object")
+        _obj = cls.model_validate({
+            "id": obj.get("id"),
+            "object": obj.get("object"),
+            "created_at": obj.get("created_at"),
+            "parent_id": obj.get("parent_id"),
+            "default": obj.get("default")
         })
         return _obj
 
+
```

### Comparing `conekta-6.0.1/conekta/models/order_response_fiscal_entity_address_all_of.py` & `conekta-6.0.2/conekta/models/token_checkout.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,71 +1,89 @@
 # coding: utf-8
 
 """
     Conekta API
 
-    Conekta sdk  # noqa: E501
+    Conekta sdk
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
-"""
+"""  # noqa: E501
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
 
-from typing import Optional
+from typing import Any, ClassVar, Dict, List, Optional
 from pydantic import BaseModel, StrictStr
+from pydantic import Field
+try:
+    from typing import Self
+except ImportError:
+    from typing_extensions import Self
 
-class OrderResponseFiscalEntityAddressAllOf(BaseModel):
-    """
-    OrderResponseFiscalEntityAddressAllOf
+class TokenCheckout(BaseModel):
     """
-    object: Optional[StrictStr] = None
-    __properties = ["object"]
+    TokenCheckout
+    """ # noqa: E501
+    returns_control_on: Optional[StrictStr] = Field(default=None, description="It is a value that allows identifying the returns control on.")
+    __properties: ClassVar[List[str]] = ["returns_control_on"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True
+    }
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> OrderResponseFiscalEntityAddressAllOf:
-        """Create an instance of OrderResponseFiscalEntityAddressAllOf from a JSON string"""
+    def from_json(cls, json_str: str) -> Self:
+        """Create an instance of TokenCheckout from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude={
+            },
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> OrderResponseFiscalEntityAddressAllOf:
-        """Create an instance of OrderResponseFiscalEntityAddressAllOf from a dict"""
+    def from_dict(cls, obj: Dict) -> Self:
+        """Create an instance of TokenCheckout from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return OrderResponseFiscalEntityAddressAllOf.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = OrderResponseFiscalEntityAddressAllOf.parse_obj({
-            "object": obj.get("object")
+        _obj = cls.model_validate({
+            "returns_control_on": obj.get("returns_control_on")
         })
         return _obj
 
+
```

### Comparing `conekta-6.0.1/conekta/models/order_response_products.py` & `conekta-6.0.2/conekta/models/get_transfers_response.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,97 +1,115 @@
 # coding: utf-8
 
 """
     Conekta API
 
-    Conekta sdk  # noqa: E501
+    Conekta sdk
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
-"""
+"""  # noqa: E501
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
 
-from typing import List, Optional
-from pydantic import BaseModel, Field, StrictBool, StrictStr, conlist
-from conekta.models.product_data_response import ProductDataResponse
+from typing import Any, ClassVar, Dict, List, Optional
+from pydantic import BaseModel, StrictBool, StrictStr
+from pydantic import Field
+from conekta.models.transfers_response import TransfersResponse
+try:
+    from typing import Self
+except ImportError:
+    from typing_extensions import Self
 
-class OrderResponseProducts(BaseModel):
-    """
-    OrderResponseProducts
+class GetTransfersResponse(BaseModel):
     """
-    has_more: StrictBool = Field(..., description="Indicates if there are more pages to be requested")
-    object: StrictStr = Field(..., description="Object type, in this case is list")
-    next_page_url: Optional[StrictStr] = Field(None, description="URL of the next page.")
-    previous_page_url: Optional[StrictStr] = Field(None, description="Url of the previous page.")
-    data: Optional[conlist(ProductDataResponse)] = None
-    __properties = ["has_more", "object", "next_page_url", "previous_page_url", "data"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    GetTransfersResponse
+    """ # noqa: E501
+    has_more: StrictBool = Field(description="Indicates if there are more pages to be requested")
+    object: StrictStr = Field(description="Object type, in this case is list")
+    next_page_url: Optional[StrictStr] = Field(default=None, description="URL of the next page.")
+    previous_page_url: Optional[StrictStr] = Field(default=None, description="Url of the previous page.")
+    data: Optional[List[TransfersResponse]] = Field(default=None, description="Transfers")
+    __properties: ClassVar[List[str]] = ["has_more", "object", "next_page_url", "previous_page_url", "data"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> OrderResponseProducts:
-        """Create an instance of OrderResponseProducts from a JSON string"""
+    def from_json(cls, json_str: str) -> Self:
+        """Create an instance of GetTransfersResponse from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude={
+            },
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of each item in data (list)
         _items = []
         if self.data:
             for _item in self.data:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['data'] = _items
         # set to None if next_page_url (nullable) is None
-        # and __fields_set__ contains the field
-        if self.next_page_url is None and "next_page_url" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.next_page_url is None and "next_page_url" in self.model_fields_set:
             _dict['next_page_url'] = None
 
         # set to None if previous_page_url (nullable) is None
-        # and __fields_set__ contains the field
-        if self.previous_page_url is None and "previous_page_url" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.previous_page_url is None and "previous_page_url" in self.model_fields_set:
             _dict['previous_page_url'] = None
 
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> OrderResponseProducts:
-        """Create an instance of OrderResponseProducts from a dict"""
+    def from_dict(cls, obj: Dict) -> Self:
+        """Create an instance of GetTransfersResponse from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return OrderResponseProducts.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = OrderResponseProducts.parse_obj({
+        _obj = cls.model_validate({
             "has_more": obj.get("has_more"),
             "object": obj.get("object"),
             "next_page_url": obj.get("next_page_url"),
             "previous_page_url": obj.get("previous_page_url"),
-            "data": [ProductDataResponse.from_dict(_item) for _item in obj.get("data")] if obj.get("data") is not None else None
+            "data": [TransfersResponse.from_dict(_item) for _item in obj.get("data")] if obj.get("data") is not None else None
         })
         return _obj
 
+
```

### Comparing `conekta-6.0.1/conekta/models/order_response_shipping_contact.py` & `conekta-6.0.2/conekta/models/payment_method_cash.py`

 * *Files 21% similar despite different names*

```diff
@@ -1,98 +1,121 @@
 # coding: utf-8
 
 """
     Conekta API
 
-    Conekta sdk  # noqa: E501
+    Conekta sdk
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
-"""
+"""  # noqa: E501
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
 
-from typing import Optional
-from pydantic import BaseModel, StrictBool, StrictInt, StrictStr
-from conekta.models.customer_shipping_contacts_response_address import CustomerShippingContactsResponseAddress
+from typing import Any, ClassVar, Dict, List, Optional
+from pydantic import BaseModel, StrictInt, StrictStr
+try:
+    from typing import Self
+except ImportError:
+    from typing_extensions import Self
 
-class OrderResponseShippingContact(BaseModel):
-    """
-    OrderResponseShippingContact
+class PaymentMethodCash(BaseModel):
     """
-    created_at: Optional[StrictInt] = None
-    id: Optional[StrictStr] = None
-    object: Optional[StrictStr] = None
-    phone: Optional[StrictStr] = None
-    receiver: Optional[StrictStr] = None
-    between_streets: Optional[StrictStr] = None
-    address: Optional[CustomerShippingContactsResponseAddress] = None
-    parent_id: Optional[StrictStr] = None
-    default: Optional[StrictBool] = None
-    deleted: Optional[StrictBool] = None
-    __properties = ["created_at", "id", "object", "phone", "receiver", "between_streets", "address", "parent_id", "default", "deleted"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    PaymentMethodCash
+    """ # noqa: E501
+    type: Optional[StrictStr] = None
+    object: StrictStr
+    auth_code: Optional[StrictInt] = None
+    cashier_id: Optional[StrictStr] = None
+    reference: Optional[StrictStr] = None
+    barcode_url: Optional[StrictStr] = None
+    expires_at: Optional[StrictInt] = None
+    service_name: Optional[StrictStr] = None
+    store: Optional[StrictStr] = None
+    store_name: Optional[StrictStr] = None
+    __properties: ClassVar[List[str]] = ["type", "object", "auth_code", "cashier_id", "reference", "barcode_url", "expires_at", "service_name", "store", "store_name"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> OrderResponseShippingContact:
-        """Create an instance of OrderResponseShippingContact from a JSON string"""
+    def from_json(cls, json_str: str) -> Self:
+        """Create an instance of PaymentMethodCash from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
-        # override the default output from pydantic by calling `to_dict()` of address
-        if self.address:
-            _dict['address'] = self.address.to_dict()
-        # set to None if between_streets (nullable) is None
-        # and __fields_set__ contains the field
-        if self.between_streets is None and "between_streets" in self.__fields_set__:
-            _dict['between_streets'] = None
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude={
+            },
+            exclude_none=True,
+        )
+        # set to None if auth_code (nullable) is None
+        # and model_fields_set contains the field
+        if self.auth_code is None and "auth_code" in self.model_fields_set:
+            _dict['auth_code'] = None
+
+        # set to None if cashier_id (nullable) is None
+        # and model_fields_set contains the field
+        if self.cashier_id is None and "cashier_id" in self.model_fields_set:
+            _dict['cashier_id'] = None
+
+        # set to None if store (nullable) is None
+        # and model_fields_set contains the field
+        if self.store is None and "store" in self.model_fields_set:
+            _dict['store'] = None
 
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> OrderResponseShippingContact:
-        """Create an instance of OrderResponseShippingContact from a dict"""
+    def from_dict(cls, obj: Dict) -> Self:
+        """Create an instance of PaymentMethodCash from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return OrderResponseShippingContact.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = OrderResponseShippingContact.parse_obj({
-            "created_at": obj.get("created_at"),
-            "id": obj.get("id"),
+        _obj = cls.model_validate({
+            "type": obj.get("type"),
             "object": obj.get("object"),
-            "phone": obj.get("phone"),
-            "receiver": obj.get("receiver"),
-            "between_streets": obj.get("between_streets"),
-            "address": CustomerShippingContactsResponseAddress.from_dict(obj.get("address")) if obj.get("address") is not None else None,
-            "parent_id": obj.get("parent_id"),
-            "default": obj.get("default"),
-            "deleted": obj.get("deleted")
+            "auth_code": obj.get("auth_code"),
+            "cashier_id": obj.get("cashier_id"),
+            "reference": obj.get("reference"),
+            "barcode_url": obj.get("barcode_url"),
+            "expires_at": obj.get("expires_at"),
+            "service_name": obj.get("service_name"),
+            "store": obj.get("store"),
+            "store_name": obj.get("store_name")
         })
         return _obj
 
+
```

### Comparing `conekta-6.0.1/conekta/models/order_response_shipping_contact_all_of.py` & `conekta-6.0.2/conekta/models/order_response_customer_info_all_of.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,75 +1,88 @@
 # coding: utf-8
 
 """
     Conekta API
 
-    Conekta sdk  # noqa: E501
+    Conekta sdk
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
-"""
+"""  # noqa: E501
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
 
-from typing import Optional
-from pydantic import BaseModel, StrictInt, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from pydantic import BaseModel, StrictStr
+try:
+    from typing import Self
+except ImportError:
+    from typing_extensions import Self
 
-class OrderResponseShippingContactAllOf(BaseModel):
-    """
-    OrderResponseShippingContactAllOf
+class OrderResponseCustomerInfoAllOf(BaseModel):
     """
-    created_at: Optional[StrictInt] = None
-    id: Optional[StrictStr] = None
+    OrderResponseCustomerInfoAllOf
+    """ # noqa: E501
     object: Optional[StrictStr] = None
-    __properties = ["created_at", "id", "object"]
+    __properties: ClassVar[List[str]] = ["object"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True
+    }
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> OrderResponseShippingContactAllOf:
-        """Create an instance of OrderResponseShippingContactAllOf from a JSON string"""
+    def from_json(cls, json_str: str) -> Self:
+        """Create an instance of OrderResponseCustomerInfoAllOf from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude={
+            },
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> OrderResponseShippingContactAllOf:
-        """Create an instance of OrderResponseShippingContactAllOf from a dict"""
+    def from_dict(cls, obj: Dict) -> Self:
+        """Create an instance of OrderResponseCustomerInfoAllOf from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return OrderResponseShippingContactAllOf.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = OrderResponseShippingContactAllOf.parse_obj({
-            "created_at": obj.get("created_at"),
-            "id": obj.get("id"),
+        _obj = cls.model_validate({
             "object": obj.get("object")
         })
         return _obj
 
+
```

### Comparing `conekta-6.0.1/conekta/models/order_tax_request.py` & `conekta-6.0.2/conekta/models/charge_update_request.py`

 * *Files 25% similar despite different names*

```diff
@@ -1,75 +1,89 @@
 # coding: utf-8
 
 """
     Conekta API
 
-    Conekta sdk  # noqa: E501
+    Conekta sdk
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
-"""
+"""  # noqa: E501
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
 
-from typing import Any, Dict, Optional
-from pydantic import BaseModel, Field, conint, constr
+from typing import Any, ClassVar, Dict, List, Optional
+from pydantic import BaseModel, StrictStr
+from pydantic import Field
+try:
+    from typing import Self
+except ImportError:
+    from typing_extensions import Self
 
-class OrderTaxRequest(BaseModel):
-    """
-    create new taxes for an existing order
+class ChargeUpdateRequest(BaseModel):
     """
-    amount: conint(strict=True, ge=0) = Field(..., description="The amount to be collected for tax in cents")
-    description: constr(strict=True, min_length=2) = Field(..., description="description or tax's name")
-    metadata: Optional[Dict[str, Any]] = None
-    __properties = ["amount", "description", "metadata"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    requested field for update a charge
+    """ # noqa: E501
+    reference_id: Optional[StrictStr] = Field(default=None, description="custom reference id")
+    __properties: ClassVar[List[str]] = ["reference_id"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> OrderTaxRequest:
-        """Create an instance of OrderTaxRequest from a JSON string"""
+    def from_json(cls, json_str: str) -> Self:
+        """Create an instance of ChargeUpdateRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude={
+            },
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> OrderTaxRequest:
-        """Create an instance of OrderTaxRequest from a dict"""
+    def from_dict(cls, obj: Dict) -> Self:
+        """Create an instance of ChargeUpdateRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return OrderTaxRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = OrderTaxRequest.parse_obj({
-            "amount": obj.get("amount"),
-            "description": obj.get("description"),
-            "metadata": obj.get("metadata")
+        _obj = cls.model_validate({
+            "reference_id": obj.get("reference_id")
         })
         return _obj
 
+
```

### Comparing `conekta-6.0.1/conekta/models/order_update_request.py` & `conekta-6.0.2/conekta/models/update_customer.py`

 * *Files 25% similar despite different names*

```diff
@@ -1,143 +1,152 @@
 # coding: utf-8
 
 """
     Conekta API
 
-    Conekta sdk  # noqa: E501
+    Conekta sdk
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
-"""
+"""  # noqa: E501
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
 
-from typing import Dict, List, Optional
-from pydantic import BaseModel, Field, StrictBool, StrictStr, conlist, constr
-from conekta.models.charge_request import ChargeRequest
-from conekta.models.checkout_request import CheckoutRequest
+from typing import Any, ClassVar, Dict, List, Optional
+from pydantic import BaseModel, StrictBool, StrictStr
+from pydantic import Field
+from conekta.models.customer_fiscal_entities_request import CustomerFiscalEntitiesRequest
+from conekta.models.customer_payment_methods_request import CustomerPaymentMethodsRequest
 from conekta.models.customer_shipping_contacts import CustomerShippingContacts
-from conekta.models.order_discount_lines_request import OrderDiscountLinesRequest
-from conekta.models.order_tax_request import OrderTaxRequest
-from conekta.models.order_update_request_customer_info import OrderUpdateRequestCustomerInfo
-from conekta.models.product import Product
-from conekta.models.shipping_request import ShippingRequest
+from conekta.models.subscription_request import SubscriptionRequest
+from conekta.models.update_customer_antifraud_info import UpdateCustomerAntifraudInfo
+try:
+    from typing import Self
+except ImportError:
+    from typing_extensions import Self
 
-class OrderUpdateRequest(BaseModel):
-    """
-    a order
+class UpdateCustomer(BaseModel):
     """
-    charges: Optional[conlist(ChargeRequest)] = None
-    checkout: Optional[CheckoutRequest] = None
-    currency: Optional[constr(strict=True, max_length=3)] = Field(None, description="Currency with which the payment will be made. It uses the 3-letter code of the [International Standard ISO 4217.](https://es.wikipedia.org/wiki/ISO_4217)")
-    customer_info: Optional[OrderUpdateRequestCustomerInfo] = None
-    discount_lines: Optional[conlist(OrderDiscountLinesRequest)] = Field(None, description="List of [discounts](https://developers.conekta.com/v2.1.0/reference/orderscreatediscountline) that are applied to the order. You must have at least one discount.")
-    line_items: Optional[conlist(Product)] = Field(None, description="List of [products](https://developers.conekta.com/v2.1.0/reference/orderscreateproduct) that are sold in the order. You must have at least one product.")
-    metadata: Optional[Dict[str, StrictStr]] = None
-    pre_authorize: Optional[StrictBool] = Field(False, description="Indicates whether the order charges must be preauthorized")
-    shipping_contact: Optional[CustomerShippingContacts] = None
-    shipping_lines: Optional[conlist(ShippingRequest)] = Field(None, description="List of [shipping costs](https://developers.conekta.com/v2.1.0/reference/orderscreateshipping). If the online store offers digital products.")
-    tax_lines: Optional[conlist(OrderTaxRequest)] = None
-    __properties = ["charges", "checkout", "currency", "customer_info", "discount_lines", "line_items", "metadata", "pre_authorize", "shipping_contact", "shipping_lines", "tax_lines"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    update customer
+    """ # noqa: E501
+    antifraud_info: Optional[UpdateCustomerAntifraudInfo] = None
+    default_payment_source_id: Optional[StrictStr] = Field(default=None, description="It is a parameter that allows to identify in the response, the Conekta ID of a payment method (payment_id)")
+    email: Optional[StrictStr] = Field(default=None, description="An email address is a series of customizable characters followed by a universal Internet symbol, the at symbol (@), the name of a host server, and a web domain ending (.mx, .com, .org, . net, etc).")
+    name: Optional[StrictStr] = Field(default=None, description="Client's name")
+    phone: Optional[StrictStr] = Field(default=None, description="Is the customer's phone number")
+    plan_id: Optional[StrictStr] = Field(default=None, description="Contains the ID of a plan, which could together with name, email and phone create a client directly to a subscription")
+    default_shipping_contact_id: Optional[StrictStr] = Field(default=None, description="It is a parameter that allows to identify in the response, the Conekta ID of the shipping address (shipping_contact)")
+    corporate: Optional[StrictBool] = Field(default=False, description="It is a value that allows identifying if the email is corporate or not.")
+    custom_reference: Optional[StrictStr] = Field(default=None, description="It is an undefined value.")
+    fiscal_entities: Optional[List[CustomerFiscalEntitiesRequest]] = None
+    metadata: Optional[Dict[str, Any]] = None
+    payment_sources: Optional[List[CustomerPaymentMethodsRequest]] = Field(default=None, description="Contains details of the payment methods that the customer has active or has used in Conekta")
+    shipping_contacts: Optional[List[CustomerShippingContacts]] = Field(default=None, description="Contains the detail of the shipping addresses that the client has active or has used in Conekta")
+    subscription: Optional[SubscriptionRequest] = None
+    __properties: ClassVar[List[str]] = ["antifraud_info", "default_payment_source_id", "email", "name", "phone", "plan_id", "default_shipping_contact_id", "corporate", "custom_reference", "fiscal_entities", "metadata", "payment_sources", "shipping_contacts", "subscription"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> OrderUpdateRequest:
-        """Create an instance of OrderUpdateRequest from a JSON string"""
+    def from_json(cls, json_str: str) -> Self:
+        """Create an instance of UpdateCustomer from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
-        # override the default output from pydantic by calling `to_dict()` of each item in charges (list)
-        _items = []
-        if self.charges:
-            for _item in self.charges:
-                if _item:
-                    _items.append(_item.to_dict())
-            _dict['charges'] = _items
-        # override the default output from pydantic by calling `to_dict()` of checkout
-        if self.checkout:
-            _dict['checkout'] = self.checkout.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of customer_info
-        if self.customer_info:
-            _dict['customer_info'] = self.customer_info.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of each item in discount_lines (list)
-        _items = []
-        if self.discount_lines:
-            for _item in self.discount_lines:
-                if _item:
-                    _items.append(_item.to_dict())
-            _dict['discount_lines'] = _items
-        # override the default output from pydantic by calling `to_dict()` of each item in line_items (list)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude={
+            },
+            exclude_none=True,
+        )
+        # override the default output from pydantic by calling `to_dict()` of antifraud_info
+        if self.antifraud_info:
+            _dict['antifraud_info'] = self.antifraud_info.to_dict()
+        # override the default output from pydantic by calling `to_dict()` of each item in fiscal_entities (list)
         _items = []
-        if self.line_items:
-            for _item in self.line_items:
+        if self.fiscal_entities:
+            for _item in self.fiscal_entities:
                 if _item:
                     _items.append(_item.to_dict())
-            _dict['line_items'] = _items
-        # override the default output from pydantic by calling `to_dict()` of shipping_contact
-        if self.shipping_contact:
-            _dict['shipping_contact'] = self.shipping_contact.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of each item in shipping_lines (list)
+            _dict['fiscal_entities'] = _items
+        # override the default output from pydantic by calling `to_dict()` of each item in payment_sources (list)
         _items = []
-        if self.shipping_lines:
-            for _item in self.shipping_lines:
+        if self.payment_sources:
+            for _item in self.payment_sources:
                 if _item:
                     _items.append(_item.to_dict())
-            _dict['shipping_lines'] = _items
-        # override the default output from pydantic by calling `to_dict()` of each item in tax_lines (list)
+            _dict['payment_sources'] = _items
+        # override the default output from pydantic by calling `to_dict()` of each item in shipping_contacts (list)
         _items = []
-        if self.tax_lines:
-            for _item in self.tax_lines:
+        if self.shipping_contacts:
+            for _item in self.shipping_contacts:
                 if _item:
                     _items.append(_item.to_dict())
-            _dict['tax_lines'] = _items
+            _dict['shipping_contacts'] = _items
+        # override the default output from pydantic by calling `to_dict()` of subscription
+        if self.subscription:
+            _dict['subscription'] = self.subscription.to_dict()
+        # set to None if antifraud_info (nullable) is None
+        # and model_fields_set contains the field
+        if self.antifraud_info is None and "antifraud_info" in self.model_fields_set:
+            _dict['antifraud_info'] = None
+
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> OrderUpdateRequest:
-        """Create an instance of OrderUpdateRequest from a dict"""
+    def from_dict(cls, obj: Dict) -> Self:
+        """Create an instance of UpdateCustomer from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return OrderUpdateRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = OrderUpdateRequest.parse_obj({
-            "charges": [ChargeRequest.from_dict(_item) for _item in obj.get("charges")] if obj.get("charges") is not None else None,
-            "checkout": CheckoutRequest.from_dict(obj.get("checkout")) if obj.get("checkout") is not None else None,
-            "currency": obj.get("currency"),
-            "customer_info": OrderUpdateRequestCustomerInfo.from_dict(obj.get("customer_info")) if obj.get("customer_info") is not None else None,
-            "discount_lines": [OrderDiscountLinesRequest.from_dict(_item) for _item in obj.get("discount_lines")] if obj.get("discount_lines") is not None else None,
-            "line_items": [Product.from_dict(_item) for _item in obj.get("line_items")] if obj.get("line_items") is not None else None,
+        _obj = cls.model_validate({
+            "antifraud_info": UpdateCustomerAntifraudInfo.from_dict(obj.get("antifraud_info")) if obj.get("antifraud_info") is not None else None,
+            "default_payment_source_id": obj.get("default_payment_source_id"),
+            "email": obj.get("email"),
+            "name": obj.get("name"),
+            "phone": obj.get("phone"),
+            "plan_id": obj.get("plan_id"),
+            "default_shipping_contact_id": obj.get("default_shipping_contact_id"),
+            "corporate": obj.get("corporate") if obj.get("corporate") is not None else False,
+            "custom_reference": obj.get("custom_reference"),
+            "fiscal_entities": [CustomerFiscalEntitiesRequest.from_dict(_item) for _item in obj.get("fiscal_entities")] if obj.get("fiscal_entities") is not None else None,
             "metadata": obj.get("metadata"),
-            "pre_authorize": obj.get("pre_authorize") if obj.get("pre_authorize") is not None else False,
-            "shipping_contact": CustomerShippingContacts.from_dict(obj.get("shipping_contact")) if obj.get("shipping_contact") is not None else None,
-            "shipping_lines": [ShippingRequest.from_dict(_item) for _item in obj.get("shipping_lines")] if obj.get("shipping_lines") is not None else None,
-            "tax_lines": [OrderTaxRequest.from_dict(_item) for _item in obj.get("tax_lines")] if obj.get("tax_lines") is not None else None
+            "payment_sources": [CustomerPaymentMethodsRequest.from_dict(_item) for _item in obj.get("payment_sources")] if obj.get("payment_sources") is not None else None,
+            "shipping_contacts": [CustomerShippingContacts.from_dict(_item) for _item in obj.get("shipping_contacts")] if obj.get("shipping_contacts") is not None else None,
+            "subscription": SubscriptionRequest.from_dict(obj.get("subscription")) if obj.get("subscription") is not None else None
         })
         return _obj
 
+
```

### Comparing `conekta-6.0.1/conekta/models/order_update_request_customer_info.py` & `conekta-6.0.2/conekta/models/checkout_order_template_customer_info.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,93 +1,100 @@
 # coding: utf-8
 
 """
     Conekta API
 
-    Conekta sdk  # noqa: E501
+    Conekta sdk
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
-"""
+"""  # noqa: E501
 
 
 from __future__ import annotations
 from inspect import getfullargspec
 import json
 import pprint
 import re  # noqa: F401
 
 from typing import Any, List, Optional
-from pydantic import BaseModel, Field, StrictStr, ValidationError, validator
+from pydantic import BaseModel, Field, StrictStr, ValidationError, field_validator
 from conekta.models.customer_info import CustomerInfo
 from conekta.models.customer_info_just_customer_id import CustomerInfoJustCustomerId
-from typing import Any, List
+from typing import Union, Any, List, TYPE_CHECKING, Optional, Dict
+from typing_extensions import Literal
 from pydantic import StrictStr, Field
+try:
+    from typing import Self
+except ImportError:
+    from typing_extensions import Self
 
-ORDERUPDATEREQUESTCUSTOMERINFO_ONE_OF_SCHEMAS = ["CustomerInfo", "CustomerInfoJustCustomerId"]
+CHECKOUTORDERTEMPLATECUSTOMERINFO_ONE_OF_SCHEMAS = ["CustomerInfo", "CustomerInfoJustCustomerId"]
 
-class OrderUpdateRequestCustomerInfo(BaseModel):
+class CheckoutOrderTemplateCustomerInfo(BaseModel):
     """
-    OrderUpdateRequestCustomerInfo
+    It is the information of the customer who will be created when receiving a new payment.
     """
     # data type: CustomerInfo
     oneof_schema_1_validator: Optional[CustomerInfo] = None
     # data type: CustomerInfoJustCustomerId
     oneof_schema_2_validator: Optional[CustomerInfoJustCustomerId] = None
-    actual_instance: Any
-    one_of_schemas: List[str] = Field(ORDERUPDATEREQUESTCUSTOMERINFO_ONE_OF_SCHEMAS, const=True)
+    actual_instance: Optional[Union[CustomerInfo, CustomerInfoJustCustomerId]] = None
+    one_of_schemas: List[str] = Literal["CustomerInfo", "CustomerInfoJustCustomerId"]
+
+    model_config = {
+        "validate_assignment": True
+    }
 
-    class Config:
-        validate_assignment = True
 
-    def __init__(self, *args, **kwargs):
+    def __init__(self, *args, **kwargs) -> None:
         if args:
             if len(args) > 1:
                 raise ValueError("If a position argument is used, only 1 is allowed to set `actual_instance`")
             if kwargs:
                 raise ValueError("If a position argument is used, keyword arguments cannot be used.")
             super().__init__(actual_instance=args[0])
         else:
             super().__init__(**kwargs)
 
-    @validator('actual_instance')
+    @field_validator('actual_instance')
     def actual_instance_must_validate_oneof(cls, v):
-        instance = OrderUpdateRequestCustomerInfo.construct()
+        instance = CheckoutOrderTemplateCustomerInfo.model_construct()
         error_messages = []
         match = 0
         # validate data type: CustomerInfo
         if not isinstance(v, CustomerInfo):
             error_messages.append(f"Error! Input type `{type(v)}` is not `CustomerInfo`")
         else:
             match += 1
         # validate data type: CustomerInfoJustCustomerId
         if not isinstance(v, CustomerInfoJustCustomerId):
             error_messages.append(f"Error! Input type `{type(v)}` is not `CustomerInfoJustCustomerId`")
         else:
             match += 1
         if match > 1:
             # more than 1 match
-            raise ValueError("Multiple matches found when setting `actual_instance` in OrderUpdateRequestCustomerInfo with oneOf schemas: CustomerInfo, CustomerInfoJustCustomerId. Details: " + ", ".join(error_messages))
+            raise ValueError("Multiple matches found when setting `actual_instance` in CheckoutOrderTemplateCustomerInfo with oneOf schemas: CustomerInfo, CustomerInfoJustCustomerId. Details: " + ", ".join(error_messages))
         elif match == 0:
             # no match
-            raise ValueError("No match found when setting `actual_instance` in OrderUpdateRequestCustomerInfo with oneOf schemas: CustomerInfo, CustomerInfoJustCustomerId. Details: " + ", ".join(error_messages))
+            raise ValueError("No match found when setting `actual_instance` in CheckoutOrderTemplateCustomerInfo with oneOf schemas: CustomerInfo, CustomerInfoJustCustomerId. Details: " + ", ".join(error_messages))
         else:
             return v
 
     @classmethod
-    def from_dict(cls, obj: dict) -> OrderUpdateRequestCustomerInfo:
+    def from_dict(cls, obj: dict) -> Self:
         return cls.from_json(json.dumps(obj))
 
     @classmethod
-    def from_json(cls, json_str: str) -> OrderUpdateRequestCustomerInfo:
+    def from_json(cls, json_str: str) -> Self:
         """Returns the object represented by the json string"""
-        instance = OrderUpdateRequestCustomerInfo.construct()
+        instance = cls.model_construct()
         error_messages = []
         match = 0
 
         # deserialize data into CustomerInfo
         try:
             instance.actual_instance = CustomerInfo.from_json(json_str)
             match += 1
@@ -98,41 +105,42 @@
             instance.actual_instance = CustomerInfoJustCustomerId.from_json(json_str)
             match += 1
         except (ValidationError, ValueError) as e:
             error_messages.append(str(e))
 
         if match > 1:
             # more than 1 match
-            raise ValueError("Multiple matches found when deserializing the JSON string into OrderUpdateRequestCustomerInfo with oneOf schemas: CustomerInfo, CustomerInfoJustCustomerId. Details: " + ", ".join(error_messages))
+            raise ValueError("Multiple matches found when deserializing the JSON string into CheckoutOrderTemplateCustomerInfo with oneOf schemas: CustomerInfo, CustomerInfoJustCustomerId. Details: " + ", ".join(error_messages))
         elif match == 0:
             # no match
-            raise ValueError("No match found when deserializing the JSON string into OrderUpdateRequestCustomerInfo with oneOf schemas: CustomerInfo, CustomerInfoJustCustomerId. Details: " + ", ".join(error_messages))
+            raise ValueError("No match found when deserializing the JSON string into CheckoutOrderTemplateCustomerInfo with oneOf schemas: CustomerInfo, CustomerInfoJustCustomerId. Details: " + ", ".join(error_messages))
         else:
             return instance
 
     def to_json(self) -> str:
         """Returns the JSON representation of the actual instance"""
         if self.actual_instance is None:
             return "null"
 
         to_json = getattr(self.actual_instance, "to_json", None)
         if callable(to_json):
             return self.actual_instance.to_json()
         else:
             return json.dumps(self.actual_instance)
 
-    def to_dict(self) -> dict:
+    def to_dict(self) -> Dict:
         """Returns the dict representation of the actual instance"""
         if self.actual_instance is None:
             return None
 
         to_dict = getattr(self.actual_instance, "to_dict", None)
         if callable(to_dict):
             return self.actual_instance.to_dict()
         else:
             # primitive type
             return self.actual_instance
 
     def to_str(self) -> str:
         """Returns the string representation of the actual instance"""
-        return pprint.pformat(self.dict())
+        return pprint.pformat(self.model_dump())
+
```

### Comparing `conekta-6.0.1/conekta/models/orders_response.py` & `conekta-6.0.2/conekta/models/get_plans_response_all_of.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,79 +1,96 @@
 # coding: utf-8
 
 """
     Conekta API
 
-    Conekta sdk  # noqa: E501
+    Conekta sdk
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
-"""
+"""  # noqa: E501
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
 
-from typing import List
-from pydantic import BaseModel, Field, conlist
-from conekta.models.order_response import OrderResponse
+from typing import Any, ClassVar, Dict, List, Optional
+from pydantic import BaseModel
+from conekta.models.plan_response import PlanResponse
+try:
+    from typing import Self
+except ImportError:
+    from typing_extensions import Self
 
-class OrdersResponse(BaseModel):
-    """
-    OrdersResponse
+class GetPlansResponseAllOf(BaseModel):
     """
-    data: conlist(OrderResponse) = Field(...)
-    __properties = ["data"]
+    GetPlansResponseAllOf
+    """ # noqa: E501
+    data: Optional[List[PlanResponse]] = None
+    __properties: ClassVar[List[str]] = ["data"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True
+    }
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> OrdersResponse:
-        """Create an instance of OrdersResponse from a JSON string"""
+    def from_json(cls, json_str: str) -> Self:
+        """Create an instance of GetPlansResponseAllOf from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude={
+            },
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of each item in data (list)
         _items = []
         if self.data:
             for _item in self.data:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['data'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> OrdersResponse:
-        """Create an instance of OrdersResponse from a dict"""
+    def from_dict(cls, obj: Dict) -> Self:
+        """Create an instance of GetPlansResponseAllOf from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return OrdersResponse.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = OrdersResponse.parse_obj({
-            "data": [OrderResponse.from_dict(_item) for _item in obj.get("data")] if obj.get("data") is not None else None
+        _obj = cls.model_validate({
+            "data": [PlanResponse.from_dict(_item) for _item in obj.get("data")] if obj.get("data") is not None else None
         })
         return _obj
 
+
```

### Comparing `conekta-6.0.1/conekta/models/page.py` & `conekta-6.0.2/conekta/models/get_companies_response.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,83 +1,115 @@
 # coding: utf-8
 
 """
     Conekta API
 
-    Conekta sdk  # noqa: E501
+    Conekta sdk
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
-"""
+"""  # noqa: E501
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
 
-from typing import Optional
-from pydantic import BaseModel, Field, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from pydantic import BaseModel, StrictBool, StrictStr
+from pydantic import Field
+from conekta.models.company_response import CompanyResponse
+try:
+    from typing import Self
+except ImportError:
+    from typing_extensions import Self
 
-class Page(BaseModel):
-    """
-    page metadata
+class GetCompaniesResponse(BaseModel):
     """
-    next_page_url: Optional[StrictStr] = Field(None, description="URL of the next page.")
-    previous_page_url: Optional[StrictStr] = Field(None, description="Url of the previous page.")
-    __properties = ["next_page_url", "previous_page_url"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    GetCompaniesResponse
+    """ # noqa: E501
+    has_more: StrictBool = Field(description="Indicates if there are more pages to be requested")
+    object: StrictStr = Field(description="Object type, in this case is list")
+    next_page_url: Optional[StrictStr] = Field(default=None, description="URL of the next page.")
+    previous_page_url: Optional[StrictStr] = Field(default=None, description="Url of the previous page.")
+    data: Optional[List[CompanyResponse]] = None
+    __properties: ClassVar[List[str]] = ["has_more", "object", "next_page_url", "previous_page_url", "data"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> Page:
-        """Create an instance of Page from a JSON string"""
+    def from_json(cls, json_str: str) -> Self:
+        """Create an instance of GetCompaniesResponse from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude={
+            },
+            exclude_none=True,
+        )
+        # override the default output from pydantic by calling `to_dict()` of each item in data (list)
+        _items = []
+        if self.data:
+            for _item in self.data:
+                if _item:
+                    _items.append(_item.to_dict())
+            _dict['data'] = _items
         # set to None if next_page_url (nullable) is None
-        # and __fields_set__ contains the field
-        if self.next_page_url is None and "next_page_url" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.next_page_url is None and "next_page_url" in self.model_fields_set:
             _dict['next_page_url'] = None
 
         # set to None if previous_page_url (nullable) is None
-        # and __fields_set__ contains the field
-        if self.previous_page_url is None and "previous_page_url" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.previous_page_url is None and "previous_page_url" in self.model_fields_set:
             _dict['previous_page_url'] = None
 
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> Page:
-        """Create an instance of Page from a dict"""
+    def from_dict(cls, obj: Dict) -> Self:
+        """Create an instance of GetCompaniesResponse from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return Page.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = Page.parse_obj({
+        _obj = cls.model_validate({
+            "has_more": obj.get("has_more"),
+            "object": obj.get("object"),
             "next_page_url": obj.get("next_page_url"),
-            "previous_page_url": obj.get("previous_page_url")
+            "previous_page_url": obj.get("previous_page_url"),
+            "data": [CompanyResponse.from_dict(_item) for _item in obj.get("data")] if obj.get("data") is not None else None
         })
         return _obj
 
+
```

### Comparing `conekta-6.0.1/conekta/models/payment_method.py` & `conekta-6.0.2/conekta/models/payment_method.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,73 +1,90 @@
 # coding: utf-8
 
 """
     Conekta API
 
-    Conekta sdk  # noqa: E501
+    Conekta sdk
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
-"""
+"""  # noqa: E501
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
 
-from typing import Optional
-from pydantic import BaseModel, Field, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from pydantic import BaseModel, StrictStr
+try:
+    from typing import Self
+except ImportError:
+    from typing_extensions import Self
 
 class PaymentMethod(BaseModel):
     """
     PaymentMethod
-    """
+    """ # noqa: E501
     type: Optional[StrictStr] = None
-    object: StrictStr = Field(...)
-    __properties = ["type", "object"]
+    object: StrictStr
+    __properties: ClassVar[List[str]] = ["type", "object"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True
+    }
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PaymentMethod:
+    def from_json(cls, json_str: str) -> Self:
         """Create an instance of PaymentMethod from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude={
+            },
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PaymentMethod:
+    def from_dict(cls, obj: Dict) -> Self:
         """Create an instance of PaymentMethod from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PaymentMethod.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PaymentMethod.parse_obj({
+        _obj = cls.model_validate({
             "type": obj.get("type"),
             "object": obj.get("object")
         })
         return _obj
 
+
```

### Comparing `conekta-6.0.1/conekta/models/payment_method_bank_transfer.py` & `conekta-6.0.2/conekta/models/charge_data_payment_method_bank_transfer_response.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,143 +1,155 @@
 # coding: utf-8
 
 """
     Conekta API
 
-    Conekta sdk  # noqa: E501
+    Conekta sdk
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
-"""
+"""  # noqa: E501
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
 
-from typing import Any, List, Optional
-from pydantic import BaseModel, Field, StrictInt, StrictStr, conlist
+from typing import Any, ClassVar, Dict, List, Optional
+from pydantic import BaseModel, StrictInt, StrictStr
+try:
+    from typing import Self
+except ImportError:
+    from typing_extensions import Self
 
-class PaymentMethodBankTransfer(BaseModel):
-    """
-    PaymentMethodBankTransfer
+class ChargeDataPaymentMethodBankTransferResponse(BaseModel):
     """
-    type: Optional[StrictStr] = None
-    object: StrictStr = Field(...)
+    use for bank transfer responses
+    """ # noqa: E501
     bank: Optional[StrictStr] = None
     clabe: Optional[StrictStr] = None
     description: Optional[StrictStr] = None
     executed_at: Optional[StrictInt] = None
     expires_at: Optional[StrictInt] = None
     issuing_account_bank: Optional[StrictStr] = None
     issuing_account_number: Optional[StrictStr] = None
     issuing_account_holder_name: Optional[StrictStr] = None
     issuing_account_tax_id: Optional[StrictStr] = None
-    payment_attempts: Optional[conlist(Any)] = None
+    payment_attempts: Optional[List[Any]] = None
     receiving_account_holder_name: Optional[StrictStr] = None
     receiving_account_number: Optional[StrictStr] = None
     receiving_account_bank: Optional[StrictStr] = None
     receiving_account_tax_id: Optional[StrictStr] = None
     reference_number: Optional[StrictStr] = None
     tracking_code: Optional[StrictStr] = None
-    __properties = ["type", "object", "bank", "clabe", "description", "executed_at", "expires_at", "issuing_account_bank", "issuing_account_number", "issuing_account_holder_name", "issuing_account_tax_id", "payment_attempts", "receiving_account_holder_name", "receiving_account_number", "receiving_account_bank", "receiving_account_tax_id", "reference_number", "tracking_code"]
+    __properties: ClassVar[List[str]] = ["bank", "clabe", "description", "executed_at", "expires_at", "issuing_account_bank", "issuing_account_number", "issuing_account_holder_name", "issuing_account_tax_id", "payment_attempts", "receiving_account_holder_name", "receiving_account_number", "receiving_account_bank", "receiving_account_tax_id", "reference_number", "tracking_code"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True
+    }
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PaymentMethodBankTransfer:
-        """Create an instance of PaymentMethodBankTransfer from a JSON string"""
+    def from_json(cls, json_str: str) -> Self:
+        """Create an instance of ChargeDataPaymentMethodBankTransferResponse from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude={
+            },
+            exclude_none=True,
+        )
         # set to None if description (nullable) is None
-        # and __fields_set__ contains the field
-        if self.description is None and "description" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.description is None and "description" in self.model_fields_set:
             _dict['description'] = None
 
         # set to None if executed_at (nullable) is None
-        # and __fields_set__ contains the field
-        if self.executed_at is None and "executed_at" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.executed_at is None and "executed_at" in self.model_fields_set:
             _dict['executed_at'] = None
 
         # set to None if issuing_account_bank (nullable) is None
-        # and __fields_set__ contains the field
-        if self.issuing_account_bank is None and "issuing_account_bank" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.issuing_account_bank is None and "issuing_account_bank" in self.model_fields_set:
             _dict['issuing_account_bank'] = None
 
         # set to None if issuing_account_number (nullable) is None
-        # and __fields_set__ contains the field
-        if self.issuing_account_number is None and "issuing_account_number" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.issuing_account_number is None and "issuing_account_number" in self.model_fields_set:
             _dict['issuing_account_number'] = None
 
         # set to None if issuing_account_holder_name (nullable) is None
-        # and __fields_set__ contains the field
-        if self.issuing_account_holder_name is None and "issuing_account_holder_name" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.issuing_account_holder_name is None and "issuing_account_holder_name" in self.model_fields_set:
             _dict['issuing_account_holder_name'] = None
 
         # set to None if issuing_account_tax_id (nullable) is None
-        # and __fields_set__ contains the field
-        if self.issuing_account_tax_id is None and "issuing_account_tax_id" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.issuing_account_tax_id is None and "issuing_account_tax_id" in self.model_fields_set:
             _dict['issuing_account_tax_id'] = None
 
         # set to None if receiving_account_holder_name (nullable) is None
-        # and __fields_set__ contains the field
-        if self.receiving_account_holder_name is None and "receiving_account_holder_name" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.receiving_account_holder_name is None and "receiving_account_holder_name" in self.model_fields_set:
             _dict['receiving_account_holder_name'] = None
 
         # set to None if receiving_account_tax_id (nullable) is None
-        # and __fields_set__ contains the field
-        if self.receiving_account_tax_id is None and "receiving_account_tax_id" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.receiving_account_tax_id is None and "receiving_account_tax_id" in self.model_fields_set:
             _dict['receiving_account_tax_id'] = None
 
         # set to None if reference_number (nullable) is None
-        # and __fields_set__ contains the field
-        if self.reference_number is None and "reference_number" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.reference_number is None and "reference_number" in self.model_fields_set:
             _dict['reference_number'] = None
 
         # set to None if tracking_code (nullable) is None
-        # and __fields_set__ contains the field
-        if self.tracking_code is None and "tracking_code" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.tracking_code is None and "tracking_code" in self.model_fields_set:
             _dict['tracking_code'] = None
 
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PaymentMethodBankTransfer:
-        """Create an instance of PaymentMethodBankTransfer from a dict"""
+    def from_dict(cls, obj: Dict) -> Self:
+        """Create an instance of ChargeDataPaymentMethodBankTransferResponse from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PaymentMethodBankTransfer.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PaymentMethodBankTransfer.parse_obj({
-            "type": obj.get("type"),
-            "object": obj.get("object"),
+        _obj = cls.model_validate({
             "bank": obj.get("bank"),
             "clabe": obj.get("clabe"),
             "description": obj.get("description"),
             "executed_at": obj.get("executed_at"),
             "expires_at": obj.get("expires_at"),
             "issuing_account_bank": obj.get("issuing_account_bank"),
             "issuing_account_number": obj.get("issuing_account_number"),
@@ -149,7 +161,8 @@
             "receiving_account_bank": obj.get("receiving_account_bank"),
             "receiving_account_tax_id": obj.get("receiving_account_tax_id"),
             "reference_number": obj.get("reference_number"),
             "tracking_code": obj.get("tracking_code")
         })
         return _obj
 
+
```

### Comparing `conekta-6.0.1/conekta/models/payment_method_card.py` & `conekta-6.0.2/conekta/models/payment_method_card.py`

 * *Files 11% similar despite different names*

```diff
@@ -1,86 +1,103 @@
 # coding: utf-8
 
 """
     Conekta API
 
-    Conekta sdk  # noqa: E501
+    Conekta sdk
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
-"""
+"""  # noqa: E501
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
 
-from typing import Any, List, Optional
-from pydantic import BaseModel, Field, StrictStr, conlist, constr
+from typing import Any, ClassVar, Dict, List, Optional, Union
+from pydantic import BaseModel, StrictStr
+from pydantic import Field
+try:
+    from typing import Self
+except ImportError:
+    from typing_extensions import Self
 
 class PaymentMethodCard(BaseModel):
     """
     PaymentMethodCard
-    """
+    """ # noqa: E501
     type: Optional[StrictStr] = None
-    object: StrictStr = Field(...)
+    object: StrictStr
     account_type: Optional[StrictStr] = None
     auth_code: Optional[StrictStr] = None
     brand: Optional[StrictStr] = None
-    contract_id: Optional[constr(strict=True, max_length=10, min_length=10)] = Field(None, description="Id sent for recurrent charges.")
+    contract_id: Optional[StrictStr] = Field(default=None, description="Id sent for recurrent charges.")
     country: Optional[StrictStr] = None
     exp_month: Optional[StrictStr] = None
     exp_year: Optional[StrictStr] = None
-    fraud_indicators: Optional[conlist(Any)] = None
+    fraud_indicators: Optional[List[Union[str, Any]]] = None
     issuer: Optional[StrictStr] = None
     last4: Optional[StrictStr] = None
     name: Optional[StrictStr] = None
-    __properties = ["type", "object", "account_type", "auth_code", "brand", "contract_id", "country", "exp_month", "exp_year", "fraud_indicators", "issuer", "last4", "name"]
+    __properties: ClassVar[List[str]] = ["type", "object", "account_type", "auth_code", "brand", "contract_id", "country", "exp_month", "exp_year", "fraud_indicators", "issuer", "last4", "name"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True
+    }
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PaymentMethodCard:
+    def from_json(cls, json_str: str) -> Self:
         """Create an instance of PaymentMethodCard from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude={
+            },
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PaymentMethodCard:
+    def from_dict(cls, obj: Dict) -> Self:
         """Create an instance of PaymentMethodCard from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PaymentMethodCard.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PaymentMethodCard.parse_obj({
+        _obj = cls.model_validate({
             "type": obj.get("type"),
             "object": obj.get("object"),
             "account_type": obj.get("account_type"),
             "auth_code": obj.get("auth_code"),
             "brand": obj.get("brand"),
             "contract_id": obj.get("contract_id"),
             "country": obj.get("country"),
@@ -89,7 +106,8 @@
             "fraud_indicators": obj.get("fraud_indicators"),
             "issuer": obj.get("issuer"),
             "last4": obj.get("last4"),
             "name": obj.get("name")
         })
         return _obj
 
+
```

### Comparing `conekta-6.0.1/conekta/models/payment_method_card_request.py` & `conekta-6.0.2/conekta/models/update_customer_antifraud_info.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,73 +1,90 @@
 # coding: utf-8
 
 """
     Conekta API
 
-    Conekta sdk  # noqa: E501
+    Conekta sdk
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
-"""
+"""  # noqa: E501
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
 
+from typing import Any, ClassVar, Dict, List, Optional
+from pydantic import BaseModel, StrictInt
+try:
+    from typing import Self
+except ImportError:
+    from typing_extensions import Self
 
-from pydantic import BaseModel, Field, StrictStr
-
-class PaymentMethodCardRequest(BaseModel):
+class UpdateCustomerAntifraudInfo(BaseModel):
     """
-    PaymentMethodCardRequest
-    """
-    type: StrictStr = Field(..., description="Type of payment method")
-    token_id: StrictStr = Field(..., description="Token id that will be used to create a \"card\" type payment method. See the (subscriptions)[https://developers.conekta.com/v2.1.0/reference/createsubscription] tutorial for more information on how to tokenize cards.")
-    __properties = ["type", "token_id"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    UpdateCustomerAntifraudInfo
+    """ # noqa: E501
+    account_created_at: Optional[StrictInt] = None
+    first_paid_at: Optional[StrictInt] = None
+    __properties: ClassVar[List[str]] = ["account_created_at", "first_paid_at"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PaymentMethodCardRequest:
-        """Create an instance of PaymentMethodCardRequest from a JSON string"""
+    def from_json(cls, json_str: str) -> Self:
+        """Create an instance of UpdateCustomerAntifraudInfo from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude={
+            },
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PaymentMethodCardRequest:
-        """Create an instance of PaymentMethodCardRequest from a dict"""
+    def from_dict(cls, obj: Dict) -> Self:
+        """Create an instance of UpdateCustomerAntifraudInfo from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PaymentMethodCardRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PaymentMethodCardRequest.parse_obj({
-            "type": obj.get("type"),
-            "token_id": obj.get("token_id")
+        _obj = cls.model_validate({
+            "account_created_at": obj.get("account_created_at"),
+            "first_paid_at": obj.get("first_paid_at")
         })
         return _obj
 
+
```

### Comparing `conekta-6.0.1/conekta/models/payment_method_card_request_all_of.py` & `conekta-6.0.2/conekta/models/webhook_key_request.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,71 +1,89 @@
 # coding: utf-8
 
 """
     Conekta API
 
-    Conekta sdk  # noqa: E501
+    Conekta sdk
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
-"""
+"""  # noqa: E501
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
 
-from typing import Optional
-from pydantic import BaseModel, Field, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from pydantic import BaseModel, StrictBool
+from pydantic import Field
+try:
+    from typing import Self
+except ImportError:
+    from typing_extensions import Self
 
-class PaymentMethodCardRequestAllOf(BaseModel):
-    """
-    PaymentMethodCardRequestAllOf
+class WebhookKeyRequest(BaseModel):
     """
-    token_id: Optional[StrictStr] = Field(None, description="Token id that will be used to create a \"card\" type payment method. See the (subscriptions)[https://developers.conekta.com/v2.1.0/reference/createsubscription] tutorial for more information on how to tokenize cards.")
-    __properties = ["token_id"]
+    WebhookKeyRequest
+    """ # noqa: E501
+    active: Optional[StrictBool] = Field(default=True, description="Indicates if the webhook key is active")
+    __properties: ClassVar[List[str]] = ["active"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True
+    }
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PaymentMethodCardRequestAllOf:
-        """Create an instance of PaymentMethodCardRequestAllOf from a JSON string"""
+    def from_json(cls, json_str: str) -> Self:
+        """Create an instance of WebhookKeyRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude={
+            },
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PaymentMethodCardRequestAllOf:
-        """Create an instance of PaymentMethodCardRequestAllOf from a dict"""
+    def from_dict(cls, obj: Dict) -> Self:
+        """Create an instance of WebhookKeyRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PaymentMethodCardRequestAllOf.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PaymentMethodCardRequestAllOf.parse_obj({
-            "token_id": obj.get("token_id")
+        _obj = cls.model_validate({
+            "active": obj.get("active") if obj.get("active") is not None else True
         })
         return _obj
 
+
```

### Comparing `conekta-6.0.1/conekta/models/payment_method_card_response.py` & `conekta-6.0.2/conekta/models/charge_data_payment_method_card_response.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,99 +1,109 @@
 # coding: utf-8
 
 """
     Conekta API
 
-    Conekta sdk  # noqa: E501
+    Conekta sdk
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
-"""
+"""  # noqa: E501
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
 
-from typing import Optional
-from pydantic import BaseModel, Field, StrictBool, StrictInt, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from pydantic import BaseModel, StrictStr
+from pydantic import Field
+try:
+    from typing import Self
+except ImportError:
+    from typing_extensions import Self
 
-class PaymentMethodCardResponse(BaseModel):
-    """
-    PaymentMethodCardResponse
+class ChargeDataPaymentMethodCardResponse(BaseModel):
     """
-    type: StrictStr = Field(...)
-    id: StrictStr = Field(...)
-    object: StrictStr = Field(...)
-    created_at: StrictInt = Field(...)
-    parent_id: Optional[StrictStr] = None
-    last4: Optional[StrictStr] = None
-    bin: Optional[StrictStr] = None
-    card_type: Optional[StrictStr] = None
+    use for card responses
+    """ # noqa: E501
+    account_type: Optional[StrictStr] = None
+    auth_code: Optional[StrictStr] = None
+    brand: Optional[StrictStr] = None
+    contract_id: Optional[StrictStr] = Field(default=None, description="Id sent for recurrent charges.")
+    country: Optional[StrictStr] = None
     exp_month: Optional[StrictStr] = None
     exp_year: Optional[StrictStr] = None
-    brand: Optional[StrictStr] = None
+    fraud_indicators: Optional[List[Any]] = None
+    issuer: Optional[StrictStr] = None
+    last4: Optional[StrictStr] = None
     name: Optional[StrictStr] = None
-    default: Optional[StrictBool] = None
-    visible_on_checkout: Optional[StrictBool] = None
-    payment_source_status: Optional[StrictStr] = None
-    __properties = ["type", "id", "object", "created_at", "parent_id", "last4", "bin", "card_type", "exp_month", "exp_year", "brand", "name", "default", "visible_on_checkout", "payment_source_status"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    __properties: ClassVar[List[str]] = ["account_type", "auth_code", "brand", "contract_id", "country", "exp_month", "exp_year", "fraud_indicators", "issuer", "last4", "name"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PaymentMethodCardResponse:
-        """Create an instance of PaymentMethodCardResponse from a JSON string"""
+    def from_json(cls, json_str: str) -> Self:
+        """Create an instance of ChargeDataPaymentMethodCardResponse from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude={
+            },
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PaymentMethodCardResponse:
-        """Create an instance of PaymentMethodCardResponse from a dict"""
+    def from_dict(cls, obj: Dict) -> Self:
+        """Create an instance of ChargeDataPaymentMethodCardResponse from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PaymentMethodCardResponse.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PaymentMethodCardResponse.parse_obj({
-            "type": obj.get("type"),
-            "id": obj.get("id"),
-            "object": obj.get("object"),
-            "created_at": obj.get("created_at"),
-            "parent_id": obj.get("parent_id"),
-            "last4": obj.get("last4"),
-            "bin": obj.get("bin"),
-            "card_type": obj.get("card_type"),
+        _obj = cls.model_validate({
+            "account_type": obj.get("account_type"),
+            "auth_code": obj.get("auth_code"),
+            "brand": obj.get("brand"),
+            "contract_id": obj.get("contract_id"),
+            "country": obj.get("country"),
             "exp_month": obj.get("exp_month"),
             "exp_year": obj.get("exp_year"),
-            "brand": obj.get("brand"),
-            "name": obj.get("name"),
-            "default": obj.get("default"),
-            "visible_on_checkout": obj.get("visible_on_checkout"),
-            "payment_source_status": obj.get("payment_source_status")
+            "fraud_indicators": obj.get("fraud_indicators"),
+            "issuer": obj.get("issuer"),
+            "last4": obj.get("last4"),
+            "name": obj.get("name")
         })
         return _obj
 
+
```

### Comparing `conekta-6.0.1/conekta/models/payment_method_card_response_all_of.py` & `conekta-6.0.2/conekta/models/update_product.py`

 * *Files 23% similar despite different names*

```diff
@@ -1,89 +1,106 @@
 # coding: utf-8
 
 """
     Conekta API
 
-    Conekta sdk  # noqa: E501
+    Conekta sdk
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
-"""
+"""  # noqa: E501
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
 
-from typing import Optional
-from pydantic import BaseModel, StrictBool, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional, Union
+from pydantic import BaseModel, StrictStr
+from pydantic import Field
+from typing_extensions import Annotated
+try:
+    from typing import Self
+except ImportError:
+    from typing_extensions import Self
 
-class PaymentMethodCardResponseAllOf(BaseModel):
-    """
-    use for card responses
+class UpdateProduct(BaseModel):
     """
-    last4: Optional[StrictStr] = None
-    bin: Optional[StrictStr] = None
-    card_type: Optional[StrictStr] = None
-    exp_month: Optional[StrictStr] = None
-    exp_year: Optional[StrictStr] = None
-    brand: Optional[StrictStr] = None
+    UpdateProduct
+    """ # noqa: E501
+    antifraud_info: Optional[Dict[str, Union[str, Any]]] = None
+    description: Optional[Annotated[str, Field(strict=True, max_length=250)]] = None
+    sku: Optional[StrictStr] = None
     name: Optional[StrictStr] = None
-    default: Optional[StrictBool] = None
-    visible_on_checkout: Optional[StrictBool] = None
-    payment_source_status: Optional[StrictStr] = None
-    __properties = ["last4", "bin", "card_type", "exp_month", "exp_year", "brand", "name", "default", "visible_on_checkout", "payment_source_status"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    unit_price: Optional[Annotated[int, Field(strict=True, ge=0)]] = None
+    quantity: Optional[Annotated[int, Field(strict=True, ge=1)]] = None
+    tags: Optional[List[StrictStr]] = None
+    brand: Optional[StrictStr] = None
+    metadata: Optional[Dict[str, StrictStr]] = None
+    __properties: ClassVar[List[str]] = ["antifraud_info", "description", "sku", "name", "unit_price", "quantity", "tags", "brand", "metadata"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PaymentMethodCardResponseAllOf:
-        """Create an instance of PaymentMethodCardResponseAllOf from a JSON string"""
+    def from_json(cls, json_str: str) -> Self:
+        """Create an instance of UpdateProduct from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude={
+            },
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PaymentMethodCardResponseAllOf:
-        """Create an instance of PaymentMethodCardResponseAllOf from a dict"""
+    def from_dict(cls, obj: Dict) -> Self:
+        """Create an instance of UpdateProduct from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PaymentMethodCardResponseAllOf.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PaymentMethodCardResponseAllOf.parse_obj({
-            "last4": obj.get("last4"),
-            "bin": obj.get("bin"),
-            "card_type": obj.get("card_type"),
-            "exp_month": obj.get("exp_month"),
-            "exp_year": obj.get("exp_year"),
-            "brand": obj.get("brand"),
+        _obj = cls.model_validate({
+            "antifraud_info": obj.get("antifraud_info"),
+            "description": obj.get("description"),
+            "sku": obj.get("sku"),
             "name": obj.get("name"),
-            "default": obj.get("default"),
-            "visible_on_checkout": obj.get("visible_on_checkout"),
-            "payment_source_status": obj.get("payment_source_status")
+            "unit_price": obj.get("unit_price"),
+            "quantity": obj.get("quantity"),
+            "tags": obj.get("tags"),
+            "brand": obj.get("brand"),
+            "metadata": obj.get("metadata")
         })
         return _obj
 
+
```

### Comparing `conekta-6.0.1/conekta/models/payment_method_cash_request.py` & `conekta-6.0.2/conekta/models/payment_method_cash_request_all_of.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,73 +1,88 @@
 # coding: utf-8
 
 """
     Conekta API
 
-    Conekta sdk  # noqa: E501
+    Conekta sdk
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
-"""
+"""  # noqa: E501
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
 
-from typing import Optional
-from pydantic import BaseModel, Field, StrictInt, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from pydantic import BaseModel, StrictInt
+try:
+    from typing import Self
+except ImportError:
+    from typing_extensions import Self
 
-class PaymentMethodCashRequest(BaseModel):
-    """
-    PaymentMethodCashRequest
+class PaymentMethodCashRequestAllOf(BaseModel):
     """
-    type: StrictStr = Field(..., description="Type of payment method")
+    PaymentMethodCashRequestAllOf
+    """ # noqa: E501
     expires_at: Optional[StrictInt] = None
-    __properties = ["type", "expires_at"]
+    __properties: ClassVar[List[str]] = ["expires_at"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True
+    }
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PaymentMethodCashRequest:
-        """Create an instance of PaymentMethodCashRequest from a JSON string"""
+    def from_json(cls, json_str: str) -> Self:
+        """Create an instance of PaymentMethodCashRequestAllOf from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude={
+            },
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PaymentMethodCashRequest:
-        """Create an instance of PaymentMethodCashRequest from a dict"""
+    def from_dict(cls, obj: Dict) -> Self:
+        """Create an instance of PaymentMethodCashRequestAllOf from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PaymentMethodCashRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PaymentMethodCashRequest.parse_obj({
-            "type": obj.get("type"),
+        _obj = cls.model_validate({
             "expires_at": obj.get("expires_at")
         })
         return _obj
 
+
```

### Comparing `conekta-6.0.1/conekta/models/payment_method_cash_response.py` & `conekta-6.0.2/conekta/models/product_data_response_all_of.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,89 +1,92 @@
 # coding: utf-8
 
 """
     Conekta API
 
-    Conekta sdk  # noqa: E501
+    Conekta sdk
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
-"""
+"""  # noqa: E501
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
 
-from typing import Optional
-from pydantic import BaseModel, Field, StrictInt, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from pydantic import BaseModel, StrictStr
+try:
+    from typing import Self
+except ImportError:
+    from typing_extensions import Self
 
-class PaymentMethodCashResponse(BaseModel):
-    """
-    PaymentMethodCashResponse
+class ProductDataResponseAllOf(BaseModel):
     """
-    type: StrictStr = Field(...)
-    id: StrictStr = Field(...)
-    object: StrictStr = Field(...)
-    created_at: StrictInt = Field(...)
+    ProductDataResponseAllOf
+    """ # noqa: E501
+    id: Optional[StrictStr] = None
+    object: Optional[StrictStr] = None
     parent_id: Optional[StrictStr] = None
-    reference: Optional[StrictStr] = None
-    barcode: Optional[StrictStr] = None
-    barcode_url: Optional[StrictStr] = None
-    expires_at: Optional[StrictInt] = None
-    provider: Optional[StrictStr] = None
-    __properties = ["type", "id", "object", "created_at", "parent_id", "reference", "barcode", "barcode_url", "expires_at", "provider"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    __properties: ClassVar[List[str]] = ["id", "object", "parent_id"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PaymentMethodCashResponse:
-        """Create an instance of PaymentMethodCashResponse from a JSON string"""
+    def from_json(cls, json_str: str) -> Self:
+        """Create an instance of ProductDataResponseAllOf from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude={
+            },
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PaymentMethodCashResponse:
-        """Create an instance of PaymentMethodCashResponse from a dict"""
+    def from_dict(cls, obj: Dict) -> Self:
+        """Create an instance of ProductDataResponseAllOf from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PaymentMethodCashResponse.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PaymentMethodCashResponse.parse_obj({
-            "type": obj.get("type"),
+        _obj = cls.model_validate({
             "id": obj.get("id"),
             "object": obj.get("object"),
-            "created_at": obj.get("created_at"),
-            "parent_id": obj.get("parent_id"),
-            "reference": obj.get("reference"),
-            "barcode": obj.get("barcode"),
-            "barcode_url": obj.get("barcode_url"),
-            "expires_at": obj.get("expires_at"),
-            "provider": obj.get("provider")
+            "parent_id": obj.get("parent_id")
         })
         return _obj
 
+
```

### Comparing `conekta-6.0.1/conekta/models/payment_method_cash_response_all_of.py` & `conekta-6.0.2/conekta/models/create_risk_rules_data.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,79 +1,93 @@
 # coding: utf-8
 
 """
     Conekta API
 
-    Conekta sdk  # noqa: E501
+    Conekta sdk
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
-"""
+"""  # noqa: E501
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
 
-from typing import Optional
-from pydantic import BaseModel, StrictInt, StrictStr
+from typing import Any, ClassVar, Dict, List
+from pydantic import BaseModel, StrictStr
+from pydantic import Field
+try:
+    from typing import Self
+except ImportError:
+    from typing_extensions import Self
 
-class PaymentMethodCashResponseAllOf(BaseModel):
-    """
-    use for cash responses
+class CreateRiskRulesData(BaseModel):
     """
-    reference: Optional[StrictStr] = None
-    barcode: Optional[StrictStr] = None
-    barcode_url: Optional[StrictStr] = None
-    expires_at: Optional[StrictInt] = None
-    provider: Optional[StrictStr] = None
-    __properties = ["reference", "barcode", "barcode_url", "expires_at", "provider"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    CreateRiskRulesData
+    """ # noqa: E501
+    description: StrictStr = Field(description="Description of the rule")
+    field: StrictStr = Field(description="Field to be used for the rule")
+    value: StrictStr = Field(description="Value to be used for the rule")
+    __properties: ClassVar[List[str]] = ["description", "field", "value"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PaymentMethodCashResponseAllOf:
-        """Create an instance of PaymentMethodCashResponseAllOf from a JSON string"""
+    def from_json(cls, json_str: str) -> Self:
+        """Create an instance of CreateRiskRulesData from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude={
+            },
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PaymentMethodCashResponseAllOf:
-        """Create an instance of PaymentMethodCashResponseAllOf from a dict"""
+    def from_dict(cls, obj: Dict) -> Self:
+        """Create an instance of CreateRiskRulesData from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PaymentMethodCashResponseAllOf.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PaymentMethodCashResponseAllOf.parse_obj({
-            "reference": obj.get("reference"),
-            "barcode": obj.get("barcode"),
-            "barcode_url": obj.get("barcode_url"),
-            "expires_at": obj.get("expires_at"),
-            "provider": obj.get("provider")
+        _obj = cls.model_validate({
+            "description": obj.get("description"),
+            "field": obj.get("field"),
+            "value": obj.get("value")
         })
         return _obj
 
+
```

### Comparing `conekta-6.0.1/conekta/models/payment_method_spei_recurrent.py` & `conekta-6.0.2/conekta/models/payment_method_spei_recurrent_all_of.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,83 +1,90 @@
 # coding: utf-8
 
 """
     Conekta API
 
-    Conekta sdk  # noqa: E501
+    Conekta sdk
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
-"""
+"""  # noqa: E501
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
 
-from typing import Optional
-from pydantic import BaseModel, Field, StrictInt, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from pydantic import BaseModel, StrictStr
+try:
+    from typing import Self
+except ImportError:
+    from typing_extensions import Self
 
-class PaymentMethodSpeiRecurrent(BaseModel):
-    """
-    PaymentMethodSpeiRecurrent
+class PaymentMethodSpeiRecurrentAllOf(BaseModel):
     """
-    type: StrictStr = Field(...)
-    id: StrictStr = Field(...)
-    object: StrictStr = Field(...)
-    created_at: StrictInt = Field(...)
-    parent_id: Optional[StrictStr] = None
+    use for spei responses
+    """ # noqa: E501
     reference: Optional[StrictStr] = None
     expires_at: Optional[StrictStr] = None
-    __properties = ["type", "id", "object", "created_at", "parent_id", "reference", "expires_at"]
+    __properties: ClassVar[List[str]] = ["reference", "expires_at"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True
+    }
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PaymentMethodSpeiRecurrent:
-        """Create an instance of PaymentMethodSpeiRecurrent from a JSON string"""
+    def from_json(cls, json_str: str) -> Self:
+        """Create an instance of PaymentMethodSpeiRecurrentAllOf from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude={
+            },
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PaymentMethodSpeiRecurrent:
-        """Create an instance of PaymentMethodSpeiRecurrent from a dict"""
+    def from_dict(cls, obj: Dict) -> Self:
+        """Create an instance of PaymentMethodSpeiRecurrentAllOf from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PaymentMethodSpeiRecurrent.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PaymentMethodSpeiRecurrent.parse_obj({
-            "type": obj.get("type"),
-            "id": obj.get("id"),
-            "object": obj.get("object"),
-            "created_at": obj.get("created_at"),
-            "parent_id": obj.get("parent_id"),
+        _obj = cls.model_validate({
             "reference": obj.get("reference"),
             "expires_at": obj.get("expires_at")
         })
         return _obj
 
+
```

### Comparing `conekta-6.0.1/conekta/models/plan_request.py` & `conekta-6.0.2/conekta/models/plan_request.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,92 +1,111 @@
 # coding: utf-8
 
 """
     Conekta API
 
-    Conekta sdk  # noqa: E501
+    Conekta sdk
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
-"""
+"""  # noqa: E501
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
 
-from typing import Optional
-from pydantic import BaseModel, Field, StrictInt, StrictStr, conint, constr, validator
+from typing import Any, ClassVar, Dict, List, Optional
+from pydantic import BaseModel, StrictInt, StrictStr, field_validator
+from pydantic import Field
+from typing_extensions import Annotated
+try:
+    from typing import Self
+except ImportError:
+    from typing_extensions import Self
 
 class PlanRequest(BaseModel):
     """
     a plan
-    """
-    amount: conint(strict=True, ge=1) = Field(..., description="The amount in cents that will be charged on the interval specified.")
-    currency: Optional[constr(strict=True, max_length=3)] = Field(None, description="ISO 4217 for currencies, for the Mexican peso it is MXN/USD")
-    expiry_count: Optional[StrictInt] = Field(None, description="Number of repetitions of the frequency NUMBER OF CHARGES TO BE MADE, considering the interval and frequency, this evolves over time, but is subject to the expiration count.")
-    frequency: conint(strict=True, ge=1) = Field(..., description="Frequency of the charge, which together with the interval, can be every 3 weeks, every 4 months, every 2 years, every 5 fortnights")
-    id: Optional[StrictStr] = Field(None, description="internal reference id")
-    interval: StrictStr = Field(..., description="The interval of time between each charge.")
-    name: StrictStr = Field(..., description="The name of the plan.")
-    trial_period_days: Optional[StrictInt] = Field(None, description="The number of days the customer will have a free trial.")
-    __properties = ["amount", "currency", "expiry_count", "frequency", "id", "interval", "name", "trial_period_days"]
+    """ # noqa: E501
+    amount: Annotated[int, Field(strict=True, ge=1)] = Field(description="The amount in cents that will be charged on the interval specified.")
+    currency: Optional[Annotated[str, Field(strict=True, max_length=3)]] = Field(default=None, description="ISO 4217 for currencies, for the Mexican peso it is MXN/USD")
+    expiry_count: Optional[StrictInt] = Field(default=None, description="Number of repetitions of the frequency NUMBER OF CHARGES TO BE MADE, considering the interval and frequency, this evolves over time, but is subject to the expiration count.")
+    frequency: Annotated[int, Field(strict=True, ge=1)] = Field(description="Frequency of the charge, which together with the interval, can be every 3 weeks, every 4 months, every 2 years, every 5 fortnights")
+    id: Optional[StrictStr] = Field(default=None, description="internal reference id")
+    interval: StrictStr = Field(description="The interval of time between each charge.")
+    name: StrictStr = Field(description="The name of the plan.")
+    trial_period_days: Optional[StrictInt] = Field(default=None, description="The number of days the customer will have a free trial.")
+    __properties: ClassVar[List[str]] = ["amount", "currency", "expiry_count", "frequency", "id", "interval", "name", "trial_period_days"]
 
-    @validator('interval')
+    @field_validator('interval')
     def interval_validate_enum(cls, value):
         """Validates the enum"""
         if value not in ('week', 'half_month', 'month', 'year'):
             raise ValueError("must be one of enum values ('week', 'half_month', 'month', 'year')")
         return value
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PlanRequest:
+    def from_json(cls, json_str: str) -> Self:
         """Create an instance of PlanRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude={
+            },
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PlanRequest:
+    def from_dict(cls, obj: Dict) -> Self:
         """Create an instance of PlanRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PlanRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PlanRequest.parse_obj({
+        _obj = cls.model_validate({
             "amount": obj.get("amount"),
             "currency": obj.get("currency"),
             "expiry_count": obj.get("expiry_count"),
             "frequency": obj.get("frequency"),
             "id": obj.get("id"),
             "interval": obj.get("interval"),
             "name": obj.get("name"),
             "trial_period_days": obj.get("trial_period_days")
         })
         return _obj
 
+
```

### Comparing `conekta-6.0.1/conekta/models/plan_response.py` & `conekta-6.0.2/conekta/models/plan_response.py`

 * *Files 23% similar despite different names*

```diff
@@ -1,101 +1,120 @@
 # coding: utf-8
 
 """
     Conekta API
 
-    Conekta sdk  # noqa: E501
+    Conekta sdk
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
-"""
+"""  # noqa: E501
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
 
-from typing import Optional
-from pydantic import BaseModel, StrictBool, StrictInt, StrictStr, constr
+from typing import Any, ClassVar, Dict, List, Optional
+from pydantic import BaseModel, StrictBool, StrictInt, StrictStr
+from pydantic import Field
+from typing_extensions import Annotated
+try:
+    from typing import Self
+except ImportError:
+    from typing_extensions import Self
 
 class PlanResponse(BaseModel):
     """
     plans model
-    """
+    """ # noqa: E501
     amount: Optional[StrictInt] = None
     created_at: Optional[StrictInt] = None
-    currency: Optional[constr(strict=True, max_length=3)] = None
+    currency: Optional[Annotated[str, Field(strict=True, max_length=3)]] = None
     expiry_count: Optional[StrictInt] = None
     frequency: Optional[StrictInt] = None
     id: Optional[StrictStr] = None
     interval: Optional[StrictStr] = None
     livemode: Optional[StrictBool] = None
     name: Optional[StrictStr] = None
     object: Optional[StrictStr] = None
     trial_period_days: Optional[StrictInt] = None
-    __properties = ["amount", "created_at", "currency", "expiry_count", "frequency", "id", "interval", "livemode", "name", "object", "trial_period_days"]
+    __properties: ClassVar[List[str]] = ["amount", "created_at", "currency", "expiry_count", "frequency", "id", "interval", "livemode", "name", "object", "trial_period_days"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True
+    }
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PlanResponse:
+    def from_json(cls, json_str: str) -> Self:
         """Create an instance of PlanResponse from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude={
+            },
+            exclude_none=True,
+        )
         # set to None if expiry_count (nullable) is None
-        # and __fields_set__ contains the field
-        if self.expiry_count is None and "expiry_count" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.expiry_count is None and "expiry_count" in self.model_fields_set:
             _dict['expiry_count'] = None
 
         # set to None if trial_period_days (nullable) is None
-        # and __fields_set__ contains the field
-        if self.trial_period_days is None and "trial_period_days" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.trial_period_days is None and "trial_period_days" in self.model_fields_set:
             _dict['trial_period_days'] = None
 
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PlanResponse:
+    def from_dict(cls, obj: Dict) -> Self:
         """Create an instance of PlanResponse from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PlanResponse.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PlanResponse.parse_obj({
+        _obj = cls.model_validate({
             "amount": obj.get("amount"),
             "created_at": obj.get("created_at"),
             "currency": obj.get("currency"),
             "expiry_count": obj.get("expiry_count"),
             "frequency": obj.get("frequency"),
             "id": obj.get("id"),
             "interval": obj.get("interval"),
             "livemode": obj.get("livemode"),
             "name": obj.get("name"),
             "object": obj.get("object"),
             "trial_period_days": obj.get("trial_period_days")
         })
         return _obj
 
+
```

### Comparing `conekta-6.0.1/conekta/models/plan_update_request.py` & `conekta-6.0.2/conekta/models/plan_update_request.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,77 +1,96 @@
 # coding: utf-8
 
 """
     Conekta API
 
-    Conekta sdk  # noqa: E501
+    Conekta sdk
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
-"""
+"""  # noqa: E501
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
 
-from typing import Optional
-from pydantic import BaseModel, Field, StrictInt, StrictStr, conint, constr
+from typing import Any, ClassVar, Dict, List, Optional
+from pydantic import BaseModel, StrictInt, StrictStr
+from pydantic import Field
+from typing_extensions import Annotated
+try:
+    from typing import Self
+except ImportError:
+    from typing_extensions import Self
 
 class PlanUpdateRequest(BaseModel):
     """
     a plan
-    """
-    amount: Optional[conint(strict=True, ge=1)] = Field(None, description="The amount in cents that will be charged on the interval specified.")
-    currency: Optional[constr(strict=True, max_length=3)] = Field(None, description="ISO 4217 for currencies, for the Mexican peso it is MXN/USD")
-    expiry_count: Optional[StrictInt] = Field(None, description="Number of repetitions of the frequency NUMBER OF CHARGES TO BE MADE, considering the interval and frequency, this evolves over time, but is subject to the expiration count.")
-    name: Optional[StrictStr] = Field(None, description="The name of the plan.")
-    __properties = ["amount", "currency", "expiry_count", "name"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    """ # noqa: E501
+    amount: Optional[Annotated[int, Field(strict=True, ge=1)]] = Field(default=None, description="The amount in cents that will be charged on the interval specified.")
+    currency: Optional[Annotated[str, Field(strict=True, max_length=3)]] = Field(default=None, description="ISO 4217 for currencies, for the Mexican peso it is MXN/USD")
+    expiry_count: Optional[StrictInt] = Field(default=None, description="Number of repetitions of the frequency NUMBER OF CHARGES TO BE MADE, considering the interval and frequency, this evolves over time, but is subject to the expiration count.")
+    name: Optional[StrictStr] = Field(default=None, description="The name of the plan.")
+    __properties: ClassVar[List[str]] = ["amount", "currency", "expiry_count", "name"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PlanUpdateRequest:
+    def from_json(cls, json_str: str) -> Self:
         """Create an instance of PlanUpdateRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude={
+            },
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PlanUpdateRequest:
+    def from_dict(cls, obj: Dict) -> Self:
         """Create an instance of PlanUpdateRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PlanUpdateRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PlanUpdateRequest.parse_obj({
+        _obj = cls.model_validate({
             "amount": obj.get("amount"),
             "currency": obj.get("currency"),
             "expiry_count": obj.get("expiry_count"),
             "name": obj.get("name")
         })
         return _obj
 
+
```

### Comparing `conekta-6.0.1/conekta/models/product.py` & `conekta-6.0.2/conekta/models/transfer_method_response.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,87 +1,103 @@
 # coding: utf-8
 
 """
     Conekta API
 
-    Conekta sdk  # noqa: E501
+    Conekta sdk
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
-"""
+"""  # noqa: E501
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
 
-from typing import Any, Dict, List, Optional
-from pydantic import BaseModel, Field, StrictStr, conint, conlist, constr
+from typing import Any, ClassVar, Dict, List, Optional
+from pydantic import BaseModel, StrictInt, StrictStr
+from pydantic import Field
+try:
+    from typing import Self
+except ImportError:
+    from typing_extensions import Self
 
-class Product(BaseModel):
-    """
-    Product
+class TransferMethodResponse(BaseModel):
     """
-    antifraud_info: Optional[Dict[str, Any]] = None
-    brand: Optional[StrictStr] = Field(None, description="The brand of the item.")
-    description: Optional[constr(strict=True, max_length=250)] = Field(None, description="Short description of the item")
-    metadata: Optional[Dict[str, StrictStr]] = Field(None, description="It is a key/value hash that can hold custom fields. Maximum 100 elements and allows special characters.")
-    name: StrictStr = Field(..., description="The name of the item. It will be displayed in the order.")
-    quantity: conint(strict=True, ge=1) = Field(..., description="The quantity of the item in the order.")
-    sku: Optional[StrictStr] = Field(None, description="The stock keeping unit for the item. It is used to identify the item in the order.")
-    tags: Optional[conlist(StrictStr)] = Field(None, description="List of tags for the item. It is used to identify the item in the order.")
-    unit_price: conint(strict=True, ge=0) = Field(..., description="The price of the item in cents.")
-    __properties = ["antifraud_info", "brand", "description", "metadata", "name", "quantity", "sku", "tags", "unit_price"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    Method used to make the transfer.
+    """ # noqa: E501
+    account_holder: Optional[StrictStr] = Field(default=None, description="Name of the account holder.")
+    account_number: Optional[StrictStr] = Field(default=None, description="Account number of the bank account.")
+    bank: Optional[StrictStr] = Field(default=None, description="Name of the bank.")
+    created_at: Optional[StrictInt] = Field(default=None, description="Date and time of creation of the transfer.")
+    id: Optional[StrictStr] = Field(default=None, description="Unique identifier of the transfer.")
+    object: Optional[StrictStr] = Field(default=None, description="Object name, which is bank_transfer_payout_method.")
+    payee_id: Optional[StrictStr] = Field(default=None, description="Unique identifier of the payee.")
+    type: Optional[StrictStr] = Field(default=None, description="Type of the payee.")
+    __properties: ClassVar[List[str]] = ["account_holder", "account_number", "bank", "created_at", "id", "object", "payee_id", "type"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> Product:
-        """Create an instance of Product from a JSON string"""
+    def from_json(cls, json_str: str) -> Self:
+        """Create an instance of TransferMethodResponse from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude={
+            },
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> Product:
-        """Create an instance of Product from a dict"""
+    def from_dict(cls, obj: Dict) -> Self:
+        """Create an instance of TransferMethodResponse from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return Product.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = Product.parse_obj({
-            "antifraud_info": obj.get("antifraud_info"),
-            "brand": obj.get("brand"),
-            "description": obj.get("description"),
-            "metadata": obj.get("metadata"),
-            "name": obj.get("name"),
-            "quantity": obj.get("quantity"),
-            "sku": obj.get("sku"),
-            "tags": obj.get("tags"),
-            "unit_price": obj.get("unit_price")
+        _obj = cls.model_validate({
+            "account_holder": obj.get("account_holder"),
+            "account_number": obj.get("account_number"),
+            "bank": obj.get("bank"),
+            "created_at": obj.get("created_at"),
+            "id": obj.get("id"),
+            "object": obj.get("object"),
+            "payee_id": obj.get("payee_id"),
+            "type": obj.get("type")
         })
         return _obj
 
+
```

### Comparing `conekta-6.0.1/conekta/models/product_data_response.py` & `conekta-6.0.2/conekta/models/product.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,93 +1,106 @@
 # coding: utf-8
 
 """
     Conekta API
 
-    Conekta sdk  # noqa: E501
+    Conekta sdk
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
-"""
+"""  # noqa: E501
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
 
-from typing import Any, Dict, List, Optional
-from pydantic import BaseModel, Field, StrictStr, conint, conlist, constr
+from typing import Any, ClassVar, Dict, List, Optional
+from pydantic import BaseModel, StrictStr
+from pydantic import Field
+from typing_extensions import Annotated
+try:
+    from typing import Self
+except ImportError:
+    from typing_extensions import Self
 
-class ProductDataResponse(BaseModel):
-    """
-    ProductDataResponse
+class Product(BaseModel):
     """
+    Product
+    """ # noqa: E501
     antifraud_info: Optional[Dict[str, Any]] = None
-    brand: Optional[StrictStr] = Field(None, description="The brand of the item.")
-    description: Optional[constr(strict=True, max_length=250)] = Field(None, description="Short description of the item")
-    metadata: Optional[Dict[str, StrictStr]] = Field(None, description="It is a key/value hash that can hold custom fields. Maximum 100 elements and allows special characters.")
-    name: StrictStr = Field(..., description="The name of the item. It will be displayed in the order.")
-    quantity: conint(strict=True, ge=1) = Field(..., description="The quantity of the item in the order.")
-    sku: Optional[StrictStr] = Field(None, description="The stock keeping unit for the item. It is used to identify the item in the order.")
-    tags: Optional[conlist(StrictStr)] = Field(None, description="List of tags for the item. It is used to identify the item in the order.")
-    unit_price: conint(strict=True, ge=0) = Field(..., description="The price of the item in cents.")
-    id: Optional[StrictStr] = None
-    object: Optional[StrictStr] = None
-    parent_id: Optional[StrictStr] = None
-    __properties = ["antifraud_info", "brand", "description", "metadata", "name", "quantity", "sku", "tags", "unit_price", "id", "object", "parent_id"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    brand: Optional[StrictStr] = Field(default=None, description="The brand of the item.")
+    description: Optional[Annotated[str, Field(strict=True, max_length=250)]] = Field(default=None, description="Short description of the item")
+    metadata: Optional[Dict[str, StrictStr]] = Field(default=None, description="It is a key/value hash that can hold custom fields. Maximum 100 elements and allows special characters.")
+    name: StrictStr = Field(description="The name of the item. It will be displayed in the order.")
+    quantity: Annotated[int, Field(strict=True, ge=1)] = Field(description="The quantity of the item in the order.")
+    sku: Optional[StrictStr] = Field(default=None, description="The stock keeping unit for the item. It is used to identify the item in the order.")
+    tags: Optional[List[StrictStr]] = Field(default=None, description="List of tags for the item. It is used to identify the item in the order.")
+    unit_price: Annotated[int, Field(strict=True, ge=0)] = Field(description="The price of the item in cents.")
+    __properties: ClassVar[List[str]] = ["antifraud_info", "brand", "description", "metadata", "name", "quantity", "sku", "tags", "unit_price"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> ProductDataResponse:
-        """Create an instance of ProductDataResponse from a JSON string"""
+    def from_json(cls, json_str: str) -> Self:
+        """Create an instance of Product from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude={
+            },
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> ProductDataResponse:
-        """Create an instance of ProductDataResponse from a dict"""
+    def from_dict(cls, obj: Dict) -> Self:
+        """Create an instance of Product from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return ProductDataResponse.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = ProductDataResponse.parse_obj({
+        _obj = cls.model_validate({
             "antifraud_info": obj.get("antifraud_info"),
             "brand": obj.get("brand"),
             "description": obj.get("description"),
             "metadata": obj.get("metadata"),
             "name": obj.get("name"),
             "quantity": obj.get("quantity"),
             "sku": obj.get("sku"),
             "tags": obj.get("tags"),
-            "unit_price": obj.get("unit_price"),
-            "id": obj.get("id"),
-            "object": obj.get("object"),
-            "parent_id": obj.get("parent_id")
+            "unit_price": obj.get("unit_price")
         })
         return _obj
 
+
```

### Comparing `conekta-6.0.1/conekta/models/product_data_response_all_of.py` & `conekta-6.0.2/conekta/models/events_resend_response.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,75 +1,98 @@
 # coding: utf-8
 
 """
     Conekta API
 
-    Conekta sdk  # noqa: E501
+    Conekta sdk
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
-"""
+"""  # noqa: E501
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
 
-from typing import Optional
-from pydantic import BaseModel, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from pydantic import BaseModel, StrictInt, StrictStr
+try:
+    from typing import Self
+except ImportError:
+    from typing_extensions import Self
 
-class ProductDataResponseAllOf(BaseModel):
-    """
-    ProductDataResponseAllOf
+class EventsResendResponse(BaseModel):
     """
+    event model
+    """ # noqa: E501
+    failed_attempts: Optional[StrictInt] = None
     id: Optional[StrictStr] = None
-    object: Optional[StrictStr] = None
-    parent_id: Optional[StrictStr] = None
-    __properties = ["id", "object", "parent_id"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    last_attempted_at: Optional[StrictInt] = None
+    last_http_response_status: Optional[StrictInt] = None
+    response_data: Optional[Dict[str, Any]] = None
+    url: Optional[StrictStr] = None
+    __properties: ClassVar[List[str]] = ["failed_attempts", "id", "last_attempted_at", "last_http_response_status", "response_data", "url"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> ProductDataResponseAllOf:
-        """Create an instance of ProductDataResponseAllOf from a JSON string"""
+    def from_json(cls, json_str: str) -> Self:
+        """Create an instance of EventsResendResponse from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude={
+            },
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> ProductDataResponseAllOf:
-        """Create an instance of ProductDataResponseAllOf from a dict"""
+    def from_dict(cls, obj: Dict) -> Self:
+        """Create an instance of EventsResendResponse from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return ProductDataResponseAllOf.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = ProductDataResponseAllOf.parse_obj({
+        _obj = cls.model_validate({
+            "failed_attempts": obj.get("failed_attempts"),
             "id": obj.get("id"),
-            "object": obj.get("object"),
-            "parent_id": obj.get("parent_id")
+            "last_attempted_at": obj.get("last_attempted_at"),
+            "last_http_response_status": obj.get("last_http_response_status"),
+            "response_data": obj.get("response_data"),
+            "url": obj.get("url")
         })
         return _obj
 
+
```

### Comparing `conekta-6.0.1/conekta/models/product_order_response.py` & `conekta-6.0.2/conekta/models/company_fiscal_info_address_response.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,93 +1,115 @@
 # coding: utf-8
 
 """
     Conekta API
 
-    Conekta sdk  # noqa: E501
+    Conekta sdk
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
-"""
+"""  # noqa: E501
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
 
-from typing import Any, Dict, List, Optional
-from pydantic import BaseModel, Field, StrictStr, conint, conlist, constr
+from typing import Any, ClassVar, Dict, List, Optional
+from pydantic import BaseModel, StrictStr, field_validator
+from pydantic import Field
+try:
+    from typing import Self
+except ImportError:
+    from typing_extensions import Self
 
-class ProductOrderResponse(BaseModel):
-    """
-    ProductOrderResponse
+class CompanyFiscalInfoAddressResponse(BaseModel):
     """
-    antifraud_info: Optional[Dict[str, Any]] = None
-    brand: Optional[StrictStr] = Field(None, description="The brand of the item.")
-    description: Optional[constr(strict=True, max_length=250)] = Field(None, description="Short description of the item")
-    metadata: Optional[Dict[str, StrictStr]] = Field(None, description="It is a key/value hash that can hold custom fields. Maximum 100 elements and allows special characters.")
-    name: StrictStr = Field(..., description="The name of the item. It will be displayed in the order.")
-    quantity: conint(strict=True, ge=1) = Field(..., description="The quantity of the item in the order.")
-    sku: Optional[StrictStr] = Field(None, description="The stock keeping unit for the item. It is used to identify the item in the order.")
-    tags: Optional[conlist(StrictStr)] = Field(None, description="List of tags for the item. It is used to identify the item in the order.")
-    unit_price: conint(strict=True, ge=0) = Field(..., description="The price of the item in cents.")
-    id: Optional[StrictStr] = None
-    object: Optional[StrictStr] = None
-    parent_id: Optional[StrictStr] = None
-    __properties = ["antifraud_info", "brand", "description", "metadata", "name", "quantity", "sku", "tags", "unit_price", "id", "object", "parent_id"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    Company fiscal info address model
+    """ # noqa: E501
+    object: Optional[StrictStr] = Field(default=None, description="The resource's type")
+    street1: Optional[StrictStr] = Field(default=None, description="Street Address")
+    street2: Optional[StrictStr] = Field(default=None, description="Colonia")
+    city: Optional[StrictStr] = Field(default=None, description="City")
+    state: Optional[StrictStr] = Field(default=None, description="State")
+    country: Optional[StrictStr] = Field(default=None, description="Country")
+    postal_code: Optional[StrictStr] = Field(default=None, description="Postal code")
+    external_number: Optional[StrictStr] = Field(default=None, description="Street number")
+    internal_number: Optional[StrictStr] = Field(default=None, description="Unit / apartment number")
+    __properties: ClassVar[List[str]] = ["object", "street1", "street2", "city", "state", "country", "postal_code", "external_number", "internal_number"]
+
+    @field_validator('object')
+    def object_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ('address'):
+            raise ValueError("must be one of enum values ('address')")
+        return value
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> ProductOrderResponse:
-        """Create an instance of ProductOrderResponse from a JSON string"""
+    def from_json(cls, json_str: str) -> Self:
+        """Create an instance of CompanyFiscalInfoAddressResponse from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude={
+            },
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> ProductOrderResponse:
-        """Create an instance of ProductOrderResponse from a dict"""
+    def from_dict(cls, obj: Dict) -> Self:
+        """Create an instance of CompanyFiscalInfoAddressResponse from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return ProductOrderResponse.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = ProductOrderResponse.parse_obj({
-            "antifraud_info": obj.get("antifraud_info"),
-            "brand": obj.get("brand"),
-            "description": obj.get("description"),
-            "metadata": obj.get("metadata"),
-            "name": obj.get("name"),
-            "quantity": obj.get("quantity"),
-            "sku": obj.get("sku"),
-            "tags": obj.get("tags"),
-            "unit_price": obj.get("unit_price"),
-            "id": obj.get("id"),
+        _obj = cls.model_validate({
             "object": obj.get("object"),
-            "parent_id": obj.get("parent_id")
+            "street1": obj.get("street1"),
+            "street2": obj.get("street2"),
+            "city": obj.get("city"),
+            "state": obj.get("state"),
+            "country": obj.get("country"),
+            "postal_code": obj.get("postal_code"),
+            "external_number": obj.get("external_number"),
+            "internal_number": obj.get("internal_number")
         })
         return _obj
 
+
```

### Comparing `conekta-6.0.1/conekta/models/product_order_response_all_of.py` & `conekta-6.0.2/conekta/models/product_order_response_all_of.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,75 +1,92 @@
 # coding: utf-8
 
 """
     Conekta API
 
-    Conekta sdk  # noqa: E501
+    Conekta sdk
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
-"""
+"""  # noqa: E501
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
 
-from typing import Optional
+from typing import Any, ClassVar, Dict, List, Optional
 from pydantic import BaseModel, StrictStr
+try:
+    from typing import Self
+except ImportError:
+    from typing_extensions import Self
 
 class ProductOrderResponseAllOf(BaseModel):
     """
     ProductOrderResponseAllOf
-    """
+    """ # noqa: E501
     id: Optional[StrictStr] = None
     object: Optional[StrictStr] = None
     parent_id: Optional[StrictStr] = None
-    __properties = ["id", "object", "parent_id"]
+    __properties: ClassVar[List[str]] = ["id", "object", "parent_id"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True
+    }
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> ProductOrderResponseAllOf:
+    def from_json(cls, json_str: str) -> Self:
         """Create an instance of ProductOrderResponseAllOf from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude={
+            },
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> ProductOrderResponseAllOf:
+    def from_dict(cls, obj: Dict) -> Self:
         """Create an instance of ProductOrderResponseAllOf from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return ProductOrderResponseAllOf.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = ProductOrderResponseAllOf.parse_obj({
+        _obj = cls.model_validate({
             "id": obj.get("id"),
             "object": obj.get("object"),
             "parent_id": obj.get("parent_id")
         })
         return _obj
 
+
```

### Comparing `conekta-6.0.1/conekta/models/risk_rules.py` & `conekta-6.0.2/conekta/models/risk_rules.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,79 +1,96 @@
 # coding: utf-8
 
 """
     Conekta API
 
-    Conekta sdk  # noqa: E501
+    Conekta sdk
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
-"""
+"""  # noqa: E501
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
 
-from typing import List, Optional
-from pydantic import BaseModel, conlist
+from typing import Any, ClassVar, Dict, List, Optional
+from pydantic import BaseModel
 from conekta.models.risk_rules_data import RiskRulesData
+try:
+    from typing import Self
+except ImportError:
+    from typing_extensions import Self
 
 class RiskRules(BaseModel):
     """
     RiskRules
-    """
-    data: Optional[conlist(RiskRulesData)] = None
-    __properties = ["data"]
+    """ # noqa: E501
+    data: Optional[List[RiskRulesData]] = None
+    __properties: ClassVar[List[str]] = ["data"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True
+    }
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> RiskRules:
+    def from_json(cls, json_str: str) -> Self:
         """Create an instance of RiskRules from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude={
+            },
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of each item in data (list)
         _items = []
         if self.data:
             for _item in self.data:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['data'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> RiskRules:
+    def from_dict(cls, obj: Dict) -> Self:
         """Create an instance of RiskRules from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return RiskRules.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = RiskRules.parse_obj({
+        _obj = cls.model_validate({
             "data": [RiskRulesData.from_dict(_item) for _item in obj.get("data")] if obj.get("data") is not None else None
         })
         return _obj
 
+
```

### Comparing `conekta-6.0.1/conekta/models/risk_rules_list.py` & `conekta-6.0.2/conekta/models/update_order_tax_response.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,97 +1,100 @@
 # coding: utf-8
 
 """
     Conekta API
 
-    Conekta sdk  # noqa: E501
+    Conekta sdk
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
-"""
+"""  # noqa: E501
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
 
-from typing import List, Optional
-from pydantic import BaseModel, Field, StrictBool, StrictStr, conlist
-from conekta.models.risk_rules_data import RiskRulesData
+from typing import Any, ClassVar, Dict, List, Optional
+from pydantic import BaseModel, StrictStr
+from pydantic import Field
+from typing_extensions import Annotated
+try:
+    from typing import Self
+except ImportError:
+    from typing_extensions import Self
 
-class RiskRulesList(BaseModel):
-    """
-    RiskRulesList
+class UpdateOrderTaxResponse(BaseModel):
     """
-    has_more: StrictBool = Field(..., description="Indicates if there are more pages to be requested")
-    object: StrictStr = Field(..., description="Object type, in this case is list")
-    next_page_url: Optional[StrictStr] = Field(None, description="URL of the next page.")
-    previous_page_url: Optional[StrictStr] = Field(None, description="Url of the previous page.")
-    data: Optional[conlist(RiskRulesData)] = None
-    __properties = ["has_more", "object", "next_page_url", "previous_page_url", "data"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    create new taxes for an existing order response
+    """ # noqa: E501
+    amount: Annotated[int, Field(strict=True, ge=0)] = Field(description="The amount to be collected for tax in cents")
+    description: Annotated[str, Field(min_length=2, strict=True)] = Field(description="description or tax's name")
+    metadata: Optional[Dict[str, Any]] = None
+    id: StrictStr
+    object: Optional[StrictStr] = None
+    parent_id: Optional[StrictStr] = None
+    __properties: ClassVar[List[str]] = ["amount", "description", "metadata", "id", "object", "parent_id"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> RiskRulesList:
-        """Create an instance of RiskRulesList from a JSON string"""
+    def from_json(cls, json_str: str) -> Self:
+        """Create an instance of UpdateOrderTaxResponse from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
-        # override the default output from pydantic by calling `to_dict()` of each item in data (list)
-        _items = []
-        if self.data:
-            for _item in self.data:
-                if _item:
-                    _items.append(_item.to_dict())
-            _dict['data'] = _items
-        # set to None if next_page_url (nullable) is None
-        # and __fields_set__ contains the field
-        if self.next_page_url is None and "next_page_url" in self.__fields_set__:
-            _dict['next_page_url'] = None
-
-        # set to None if previous_page_url (nullable) is None
-        # and __fields_set__ contains the field
-        if self.previous_page_url is None and "previous_page_url" in self.__fields_set__:
-            _dict['previous_page_url'] = None
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
 
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude={
+            },
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> RiskRulesList:
-        """Create an instance of RiskRulesList from a dict"""
+    def from_dict(cls, obj: Dict) -> Self:
+        """Create an instance of UpdateOrderTaxResponse from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return RiskRulesList.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = RiskRulesList.parse_obj({
-            "has_more": obj.get("has_more"),
+        _obj = cls.model_validate({
+            "amount": obj.get("amount"),
+            "description": obj.get("description"),
+            "metadata": obj.get("metadata"),
+            "id": obj.get("id"),
             "object": obj.get("object"),
-            "next_page_url": obj.get("next_page_url"),
-            "previous_page_url": obj.get("previous_page_url"),
-            "data": [RiskRulesData.from_dict(_item) for _item in obj.get("data")] if obj.get("data") is not None else None
+            "parent_id": obj.get("parent_id")
         })
         return _obj
 
+
```

### Comparing `conekta-6.0.1/conekta/models/shipping_order_response.py` & `conekta-6.0.2/conekta/models/shipping_request.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,85 +1,98 @@
 # coding: utf-8
 
 """
     Conekta API
 
-    Conekta sdk  # noqa: E501
+    Conekta sdk
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
-"""
+"""  # noqa: E501
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
 
-from typing import Any, Dict, Optional
-from pydantic import BaseModel, Field, StrictStr, conint
+from typing import Any, ClassVar, Dict, List, Optional
+from pydantic import BaseModel, StrictStr
+from pydantic import Field
+from typing_extensions import Annotated
+try:
+    from typing import Self
+except ImportError:
+    from typing_extensions import Self
 
-class ShippingOrderResponse(BaseModel):
-    """
-    ShippingOrderResponse
+class ShippingRequest(BaseModel):
     """
-    amount: conint(strict=True, ge=0) = Field(..., description="Shipping amount in cents")
-    carrier: Optional[StrictStr] = Field(None, description="Carrier name for the shipment")
-    tracking_number: Optional[StrictStr] = Field(None, description="Tracking number can be used to track the shipment")
-    method: Optional[StrictStr] = Field(None, description="Method of shipment")
-    metadata: Optional[Dict[str, Any]] = Field(None, description="Hash where the user can send additional information for each 'shipping'.")
-    id: Optional[StrictStr] = None
-    object: Optional[StrictStr] = None
-    parent_id: Optional[StrictStr] = None
-    __properties = ["amount", "carrier", "tracking_number", "method", "metadata", "id", "object", "parent_id"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    ShippingRequest
+    """ # noqa: E501
+    amount: Annotated[int, Field(strict=True, ge=0)] = Field(description="Shipping amount in cents")
+    carrier: Optional[StrictStr] = Field(default=None, description="Carrier name for the shipment")
+    tracking_number: Optional[StrictStr] = Field(default=None, description="Tracking number can be used to track the shipment")
+    method: Optional[StrictStr] = Field(default=None, description="Method of shipment")
+    metadata: Optional[Dict[str, Any]] = Field(default=None, description="Hash where the user can send additional information for each 'shipping'.")
+    __properties: ClassVar[List[str]] = ["amount", "carrier", "tracking_number", "method", "metadata"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> ShippingOrderResponse:
-        """Create an instance of ShippingOrderResponse from a JSON string"""
+    def from_json(cls, json_str: str) -> Self:
+        """Create an instance of ShippingRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude={
+            },
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> ShippingOrderResponse:
-        """Create an instance of ShippingOrderResponse from a dict"""
+    def from_dict(cls, obj: Dict) -> Self:
+        """Create an instance of ShippingRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return ShippingOrderResponse.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = ShippingOrderResponse.parse_obj({
+        _obj = cls.model_validate({
             "amount": obj.get("amount"),
             "carrier": obj.get("carrier"),
             "tracking_number": obj.get("tracking_number"),
             "method": obj.get("method"),
-            "metadata": obj.get("metadata"),
-            "id": obj.get("id"),
-            "object": obj.get("object"),
-            "parent_id": obj.get("parent_id")
+            "metadata": obj.get("metadata")
         })
         return _obj
 
+
```

### Comparing `conekta-6.0.1/conekta/models/subscription_events_response.py` & `conekta-6.0.2/conekta/models/order_response_products.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,97 +1,115 @@
 # coding: utf-8
 
 """
     Conekta API
 
-    Conekta sdk  # noqa: E501
+    Conekta sdk
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
-"""
+"""  # noqa: E501
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
 
-from typing import List, Optional
-from pydantic import BaseModel, Field, StrictBool, StrictStr, conlist
-from conekta.models.event_response import EventResponse
+from typing import Any, ClassVar, Dict, List, Optional
+from pydantic import BaseModel, StrictBool, StrictStr
+from pydantic import Field
+from conekta.models.product_data_response import ProductDataResponse
+try:
+    from typing import Self
+except ImportError:
+    from typing_extensions import Self
 
-class SubscriptionEventsResponse(BaseModel):
-    """
-    SubscriptionEventsResponse
+class OrderResponseProducts(BaseModel):
     """
-    has_more: StrictBool = Field(..., description="Indicates if there are more pages to be requested")
-    object: StrictStr = Field(..., description="Object type, in this case is list")
-    next_page_url: Optional[StrictStr] = Field(None, description="URL of the next page.")
-    previous_page_url: Optional[StrictStr] = Field(None, description="Url of the previous page.")
-    data: Optional[conlist(EventResponse)] = None
-    __properties = ["has_more", "object", "next_page_url", "previous_page_url", "data"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    OrderResponseProducts
+    """ # noqa: E501
+    has_more: StrictBool = Field(description="Indicates if there are more pages to be requested")
+    object: StrictStr = Field(description="Object type, in this case is list")
+    next_page_url: Optional[StrictStr] = Field(default=None, description="URL of the next page.")
+    previous_page_url: Optional[StrictStr] = Field(default=None, description="Url of the previous page.")
+    data: Optional[List[ProductDataResponse]] = None
+    __properties: ClassVar[List[str]] = ["has_more", "object", "next_page_url", "previous_page_url", "data"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> SubscriptionEventsResponse:
-        """Create an instance of SubscriptionEventsResponse from a JSON string"""
+    def from_json(cls, json_str: str) -> Self:
+        """Create an instance of OrderResponseProducts from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude={
+            },
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of each item in data (list)
         _items = []
         if self.data:
             for _item in self.data:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['data'] = _items
         # set to None if next_page_url (nullable) is None
-        # and __fields_set__ contains the field
-        if self.next_page_url is None and "next_page_url" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.next_page_url is None and "next_page_url" in self.model_fields_set:
             _dict['next_page_url'] = None
 
         # set to None if previous_page_url (nullable) is None
-        # and __fields_set__ contains the field
-        if self.previous_page_url is None and "previous_page_url" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.previous_page_url is None and "previous_page_url" in self.model_fields_set:
             _dict['previous_page_url'] = None
 
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> SubscriptionEventsResponse:
-        """Create an instance of SubscriptionEventsResponse from a dict"""
+    def from_dict(cls, obj: Dict) -> Self:
+        """Create an instance of OrderResponseProducts from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return SubscriptionEventsResponse.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = SubscriptionEventsResponse.parse_obj({
+        _obj = cls.model_validate({
             "has_more": obj.get("has_more"),
             "object": obj.get("object"),
             "next_page_url": obj.get("next_page_url"),
             "previous_page_url": obj.get("previous_page_url"),
-            "data": [EventResponse.from_dict(_item) for _item in obj.get("data")] if obj.get("data") is not None else None
+            "data": [ProductDataResponse.from_dict(_item) for _item in obj.get("data")] if obj.get("data") is not None else None
         })
         return _obj
 
+
```

### Comparing `conekta-6.0.1/conekta/models/subscription_response.py` & `conekta-6.0.2/conekta/models/subscription_response.py`

 * *Files 11% similar despite different names*

```diff
@@ -1,35 +1,39 @@
 # coding: utf-8
 
 """
     Conekta API
 
-    Conekta sdk  # noqa: E501
+    Conekta sdk
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
-"""
+"""  # noqa: E501
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
 
-from typing import Optional
+from typing import Any, ClassVar, Dict, List, Optional
 from pydantic import BaseModel, StrictInt, StrictStr
+try:
+    from typing import Self
+except ImportError:
+    from typing_extensions import Self
 
 class SubscriptionResponse(BaseModel):
     """
     subscription model
-    """
+    """ # noqa: E501
     billing_cycle_start: Optional[StrictInt] = None
     billing_cycle_end: Optional[StrictInt] = None
     canceled_at: Optional[StrictInt] = None
     card_id: Optional[StrictStr] = None
     charge_id: Optional[StrictStr] = None
     created_at: Optional[StrictInt] = None
     customer_custom_reference: Optional[StrictStr] = None
@@ -39,87 +43,99 @@
     object: Optional[StrictStr] = None
     paused_at: Optional[StrictInt] = None
     plan_id: Optional[StrictStr] = None
     status: Optional[StrictStr] = None
     subscription_start: Optional[StrictInt] = None
     trial_start: Optional[StrictInt] = None
     trial_end: Optional[StrictInt] = None
-    __properties = ["billing_cycle_start", "billing_cycle_end", "canceled_at", "card_id", "charge_id", "created_at", "customer_custom_reference", "customer_id", "id", "last_billing_cycle_order_id", "object", "paused_at", "plan_id", "status", "subscription_start", "trial_start", "trial_end"]
+    __properties: ClassVar[List[str]] = ["billing_cycle_start", "billing_cycle_end", "canceled_at", "card_id", "charge_id", "created_at", "customer_custom_reference", "customer_id", "id", "last_billing_cycle_order_id", "object", "paused_at", "plan_id", "status", "subscription_start", "trial_start", "trial_end"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True
+    }
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> SubscriptionResponse:
+    def from_json(cls, json_str: str) -> Self:
         """Create an instance of SubscriptionResponse from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude={
+            },
+            exclude_none=True,
+        )
         # set to None if billing_cycle_start (nullable) is None
-        # and __fields_set__ contains the field
-        if self.billing_cycle_start is None and "billing_cycle_start" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.billing_cycle_start is None and "billing_cycle_start" in self.model_fields_set:
             _dict['billing_cycle_start'] = None
 
         # set to None if billing_cycle_end (nullable) is None
-        # and __fields_set__ contains the field
-        if self.billing_cycle_end is None and "billing_cycle_end" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.billing_cycle_end is None and "billing_cycle_end" in self.model_fields_set:
             _dict['billing_cycle_end'] = None
 
         # set to None if canceled_at (nullable) is None
-        # and __fields_set__ contains the field
-        if self.canceled_at is None and "canceled_at" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.canceled_at is None and "canceled_at" in self.model_fields_set:
             _dict['canceled_at'] = None
 
         # set to None if charge_id (nullable) is None
-        # and __fields_set__ contains the field
-        if self.charge_id is None and "charge_id" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.charge_id is None and "charge_id" in self.model_fields_set:
             _dict['charge_id'] = None
 
         # set to None if paused_at (nullable) is None
-        # and __fields_set__ contains the field
-        if self.paused_at is None and "paused_at" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.paused_at is None and "paused_at" in self.model_fields_set:
             _dict['paused_at'] = None
 
         # set to None if trial_start (nullable) is None
-        # and __fields_set__ contains the field
-        if self.trial_start is None and "trial_start" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.trial_start is None and "trial_start" in self.model_fields_set:
             _dict['trial_start'] = None
 
         # set to None if trial_end (nullable) is None
-        # and __fields_set__ contains the field
-        if self.trial_end is None and "trial_end" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.trial_end is None and "trial_end" in self.model_fields_set:
             _dict['trial_end'] = None
 
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> SubscriptionResponse:
+    def from_dict(cls, obj: Dict) -> Self:
         """Create an instance of SubscriptionResponse from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return SubscriptionResponse.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = SubscriptionResponse.parse_obj({
+        _obj = cls.model_validate({
             "billing_cycle_start": obj.get("billing_cycle_start"),
             "billing_cycle_end": obj.get("billing_cycle_end"),
             "canceled_at": obj.get("canceled_at"),
             "card_id": obj.get("card_id"),
             "charge_id": obj.get("charge_id"),
             "created_at": obj.get("created_at"),
             "customer_custom_reference": obj.get("customer_custom_reference"),
@@ -132,7 +148,8 @@
             "status": obj.get("status"),
             "subscription_start": obj.get("subscription_start"),
             "trial_start": obj.get("trial_start"),
             "trial_end": obj.get("trial_end")
         })
         return _obj
 
+
```

### Comparing `conekta-6.0.1/conekta/models/token.py` & `conekta-6.0.2/conekta/models/customer_address.py`

 * *Files 27% similar despite different names*

```diff
@@ -1,91 +1,103 @@
 # coding: utf-8
 
 """
     Conekta API
 
-    Conekta sdk  # noqa: E501
+    Conekta sdk
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
-"""
+"""  # noqa: E501
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
 
-from typing import Optional
-from pydantic import BaseModel
-from conekta.models.token_card import TokenCard
-from conekta.models.token_checkout import TokenCheckout
+from typing import Any, ClassVar, Dict, List, Optional
+from pydantic import BaseModel, StrictBool, StrictStr
+from pydantic import Field
+try:
+    from typing import Self
+except ImportError:
+    from typing_extensions import Self
 
-class Token(BaseModel):
-    """
-    a token
+class CustomerAddress(BaseModel):
     """
-    card: Optional[TokenCard] = None
-    checkout: Optional[TokenCheckout] = None
-    __properties = ["card", "checkout"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    CustomerAddress
+    """ # noqa: E501
+    street1: StrictStr
+    street2: Optional[StrictStr] = None
+    postal_code: StrictStr
+    city: StrictStr
+    state: Optional[StrictStr] = None
+    country: Optional[StrictStr] = Field(default=None, description="this field follows the [ISO 3166-1 alpha-2 standard](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2)")
+    residential: Optional[StrictBool] = False
+    external_number: Optional[StrictStr] = None
+    __properties: ClassVar[List[str]] = ["street1", "street2", "postal_code", "city", "state", "country", "residential", "external_number"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> Token:
-        """Create an instance of Token from a JSON string"""
+    def from_json(cls, json_str: str) -> Self:
+        """Create an instance of CustomerAddress from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
-        # override the default output from pydantic by calling `to_dict()` of card
-        if self.card:
-            _dict['card'] = self.card.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of checkout
-        if self.checkout:
-            _dict['checkout'] = self.checkout.to_dict()
-        # set to None if card (nullable) is None
-        # and __fields_set__ contains the field
-        if self.card is None and "card" in self.__fields_set__:
-            _dict['card'] = None
-
-        # set to None if checkout (nullable) is None
-        # and __fields_set__ contains the field
-        if self.checkout is None and "checkout" in self.__fields_set__:
-            _dict['checkout'] = None
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
 
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude={
+            },
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> Token:
-        """Create an instance of Token from a dict"""
+    def from_dict(cls, obj: Dict) -> Self:
+        """Create an instance of CustomerAddress from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return Token.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = Token.parse_obj({
-            "card": TokenCard.from_dict(obj.get("card")) if obj.get("card") is not None else None,
-            "checkout": TokenCheckout.from_dict(obj.get("checkout")) if obj.get("checkout") is not None else None
+        _obj = cls.model_validate({
+            "street1": obj.get("street1"),
+            "street2": obj.get("street2"),
+            "postal_code": obj.get("postal_code"),
+            "city": obj.get("city"),
+            "state": obj.get("state"),
+            "country": obj.get("country"),
+            "residential": obj.get("residential") if obj.get("residential") is not None else False,
+            "external_number": obj.get("external_number")
         })
         return _obj
 
+
```

### Comparing `conekta-6.0.1/conekta/models/token_card.py` & `conekta-6.0.2/conekta/models/token_card.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,81 +1,100 @@
 # coding: utf-8
 
 """
     Conekta API
 
-    Conekta sdk  # noqa: E501
+    Conekta sdk
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
-"""
+"""  # noqa: E501
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
 
-from typing import Optional
-from pydantic import BaseModel, Field, StrictStr, constr
+from typing import Any, ClassVar, Dict, List, Optional
+from pydantic import BaseModel, StrictStr
+from pydantic import Field
+from typing_extensions import Annotated
+try:
+    from typing import Self
+except ImportError:
+    from typing_extensions import Self
 
 class TokenCard(BaseModel):
     """
     TokenCard
-    """
-    cvc: constr(strict=True, max_length=4) = Field(..., description="It is a value that allows identifying the security code of the card.")
-    device_fingerprint: Optional[StrictStr] = Field(None, description="It is a value that allows identifying the device fingerprint.")
-    exp_month: constr(strict=True, max_length=2) = Field(..., description="It is a value that allows identifying the expiration month of the card.")
-    exp_year: constr(strict=True, max_length=2) = Field(..., description="It is a value that allows identifying the expiration year of the card.")
-    name: StrictStr = Field(..., description="It is a value that allows identifying the name of the cardholder.")
-    number: StrictStr = Field(..., description="It is a value that allows identifying the number of the card.")
-    __properties = ["cvc", "device_fingerprint", "exp_month", "exp_year", "name", "number"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    """ # noqa: E501
+    cvc: Annotated[str, Field(strict=True, max_length=4)] = Field(description="It is a value that allows identifying the security code of the card.")
+    device_fingerprint: Optional[StrictStr] = Field(default=None, description="It is a value that allows identifying the device fingerprint.")
+    exp_month: Annotated[str, Field(strict=True, max_length=2)] = Field(description="It is a value that allows identifying the expiration month of the card.")
+    exp_year: Annotated[str, Field(strict=True, max_length=2)] = Field(description="It is a value that allows identifying the expiration year of the card.")
+    name: StrictStr = Field(description="It is a value that allows identifying the name of the cardholder.")
+    number: StrictStr = Field(description="It is a value that allows identifying the number of the card.")
+    __properties: ClassVar[List[str]] = ["cvc", "device_fingerprint", "exp_month", "exp_year", "name", "number"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> TokenCard:
+    def from_json(cls, json_str: str) -> Self:
         """Create an instance of TokenCard from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude={
+            },
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> TokenCard:
+    def from_dict(cls, obj: Dict) -> Self:
         """Create an instance of TokenCard from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return TokenCard.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = TokenCard.parse_obj({
+        _obj = cls.model_validate({
             "cvc": obj.get("cvc"),
             "device_fingerprint": obj.get("device_fingerprint"),
             "exp_month": obj.get("exp_month"),
             "exp_year": obj.get("exp_year"),
             "name": obj.get("name"),
             "number": obj.get("number")
         })
         return _obj
 
+
```

### Comparing `conekta-6.0.1/conekta/models/transaction_response.py` & `conekta-6.0.2/conekta/models/transaction_response.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,91 +1,110 @@
 # coding: utf-8
 
 """
     Conekta API
 
-    Conekta sdk  # noqa: E501
+    Conekta sdk
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
-"""
+"""  # noqa: E501
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
 
-
-from pydantic import BaseModel, Field, StrictBool, StrictInt, StrictStr, constr
+from typing import Any, ClassVar, Dict, List
+from pydantic import BaseModel, StrictBool, StrictInt, StrictStr
+from pydantic import Field
+from typing_extensions import Annotated
+try:
+    from typing import Self
+except ImportError:
+    from typing_extensions import Self
 
 class TransactionResponse(BaseModel):
     """
     The Transaction object represents the actions or steps of an order. Statuses can be: unprocessed, pending, available, owen, paid_out, voided, capture, capture_reversal, liquidation, liquidation_reversal, payout, payout_reversal, refund, refund_reversal, chargeback, chargeback_reversal, rounding_adjustment, won_chargeback, transferred, and transferred.
-    """
-    amount: StrictInt = Field(..., description="The amount of the transaction.")
-    charge: StrictStr = Field(..., description="Randomly assigned unique order identifier associated with the charge.")
-    created_at: StrictInt = Field(..., description="Date and time of creation of the transaction in Unix format.")
-    currency: constr(strict=True, max_length=3) = Field(..., description="The currency of the transaction. It uses the 3-letter code of the [International Standard ISO 4217.](https://es.wikipedia.org/wiki/ISO_4217)")
-    fee: StrictInt = Field(..., description="The amount to be deducted for taxes and commissions.")
-    id: StrictStr = Field(..., description="Unique identifier of the transaction.")
-    livemode: StrictBool = Field(..., description="Indicates whether the transaction was created in live mode or test mode.")
-    net: StrictInt = Field(..., description="The net amount after deducting commissions and taxes.")
-    object: StrictStr = Field(..., description="Object name, which is transaction.")
-    status: StrictStr = Field(..., description="Code indicating transaction status.")
-    type: StrictStr = Field(..., description="Transaction Type")
-    __properties = ["amount", "charge", "created_at", "currency", "fee", "id", "livemode", "net", "object", "status", "type"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    """ # noqa: E501
+    amount: StrictInt = Field(description="The amount of the transaction.")
+    charge: StrictStr = Field(description="Randomly assigned unique order identifier associated with the charge.")
+    created_at: StrictInt = Field(description="Date and time of creation of the transaction in Unix format.")
+    currency: Annotated[str, Field(strict=True, max_length=3)] = Field(description="The currency of the transaction. It uses the 3-letter code of the [International Standard ISO 4217.](https://es.wikipedia.org/wiki/ISO_4217)")
+    fee: StrictInt = Field(description="The amount to be deducted for taxes and commissions.")
+    id: StrictStr = Field(description="Unique identifier of the transaction.")
+    livemode: StrictBool = Field(description="Indicates whether the transaction was created in live mode or test mode.")
+    net: StrictInt = Field(description="The net amount after deducting commissions and taxes.")
+    object: StrictStr = Field(description="Object name, which is transaction.")
+    status: StrictStr = Field(description="Code indicating transaction status.")
+    type: StrictStr = Field(description="Transaction Type")
+    __properties: ClassVar[List[str]] = ["amount", "charge", "created_at", "currency", "fee", "id", "livemode", "net", "object", "status", "type"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> TransactionResponse:
+    def from_json(cls, json_str: str) -> Self:
         """Create an instance of TransactionResponse from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude={
+            },
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> TransactionResponse:
+    def from_dict(cls, obj: Dict) -> Self:
         """Create an instance of TransactionResponse from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return TransactionResponse.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = TransactionResponse.parse_obj({
+        _obj = cls.model_validate({
             "amount": obj.get("amount"),
             "charge": obj.get("charge"),
             "created_at": obj.get("created_at"),
             "currency": obj.get("currency"),
             "fee": obj.get("fee"),
             "id": obj.get("id"),
             "livemode": obj.get("livemode"),
             "net": obj.get("net"),
             "object": obj.get("object"),
             "status": obj.get("status"),
             "type": obj.get("type")
         })
         return _obj
 
+
```

### Comparing `conekta-6.0.1/conekta/models/transfer_response.py` & `conekta-6.0.2/conekta/models/transfer_response.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,93 +1,112 @@
 # coding: utf-8
 
 """
     Conekta API
 
-    Conekta sdk  # noqa: E501
+    Conekta sdk
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
-"""
+"""  # noqa: E501
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
 
-from typing import Optional
-from pydantic import BaseModel, Field, StrictBool, StrictInt, StrictStr, constr
+from typing import Any, ClassVar, Dict, List, Optional
+from pydantic import BaseModel, StrictBool, StrictInt, StrictStr
+from pydantic import Field
+from typing_extensions import Annotated
 from conekta.models.transfer_destination_response import TransferDestinationResponse
+try:
+    from typing import Self
+except ImportError:
+    from typing_extensions import Self
 
 class TransferResponse(BaseModel):
     """
     A transfer represents the action of sending an amount to a business bank account including the status, amount and method used to make the transfer.
-    """
-    amount: Optional[StrictInt] = Field(None, description="Amount in cents of the transfer.")
-    created_at: Optional[StrictInt] = Field(None, description="Date and time of creation of the transfer in Unix format.")
-    currency: Optional[constr(strict=True, max_length=3)] = Field(None, description="The currency of the transfer. It uses the 3-letter code of the [International Standard ISO 4217.](https://es.wikipedia.org/wiki/ISO_4217)")
-    id: Optional[StrictStr] = Field(None, description="Unique identifier of the transfer.")
-    livemode: Optional[StrictBool] = Field(None, description="Indicates whether the transfer was created in live mode or test mode.")
+    """ # noqa: E501
+    amount: Optional[StrictInt] = Field(default=None, description="Amount in cents of the transfer.")
+    created_at: Optional[StrictInt] = Field(default=None, description="Date and time of creation of the transfer in Unix format.")
+    currency: Optional[Annotated[str, Field(strict=True, max_length=3)]] = Field(default=None, description="The currency of the transfer. It uses the 3-letter code of the [International Standard ISO 4217.](https://es.wikipedia.org/wiki/ISO_4217)")
+    id: Optional[StrictStr] = Field(default=None, description="Unique identifier of the transfer.")
+    livemode: Optional[StrictBool] = Field(default=None, description="Indicates whether the transfer was created in live mode or test mode.")
     destination: Optional[TransferDestinationResponse] = None
-    object: Optional[StrictStr] = Field(None, description="Object name, which is transfer.")
-    statement_description: Optional[StrictStr] = Field(None, description="Description of the transfer.")
-    statement_reference: Optional[StrictStr] = Field(None, description="Reference number of the transfer.")
-    status: Optional[StrictStr] = Field(None, description="Code indicating transfer status.")
-    __properties = ["amount", "created_at", "currency", "id", "livemode", "destination", "object", "statement_description", "statement_reference", "status"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    object: Optional[StrictStr] = Field(default=None, description="Object name, which is transfer.")
+    statement_description: Optional[StrictStr] = Field(default=None, description="Description of the transfer.")
+    statement_reference: Optional[StrictStr] = Field(default=None, description="Reference number of the transfer.")
+    status: Optional[StrictStr] = Field(default=None, description="Code indicating transfer status.")
+    __properties: ClassVar[List[str]] = ["amount", "created_at", "currency", "id", "livemode", "destination", "object", "statement_description", "statement_reference", "status"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> TransferResponse:
+    def from_json(cls, json_str: str) -> Self:
         """Create an instance of TransferResponse from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude={
+            },
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of destination
         if self.destination:
             _dict['destination'] = self.destination.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> TransferResponse:
+    def from_dict(cls, obj: Dict) -> Self:
         """Create an instance of TransferResponse from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return TransferResponse.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = TransferResponse.parse_obj({
+        _obj = cls.model_validate({
             "amount": obj.get("amount"),
             "created_at": obj.get("created_at"),
             "currency": obj.get("currency"),
             "id": obj.get("id"),
             "livemode": obj.get("livemode"),
             "destination": TransferDestinationResponse.from_dict(obj.get("destination")) if obj.get("destination") is not None else None,
             "object": obj.get("object"),
             "statement_description": obj.get("statement_description"),
             "statement_reference": obj.get("statement_reference"),
             "status": obj.get("status")
         })
         return _obj
 
+
```

### Comparing `conekta-6.0.1/conekta/models/update_customer.py` & `conekta-6.0.2/conekta/models/order_request.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,134 +1,176 @@
 # coding: utf-8
 
 """
     Conekta API
 
-    Conekta sdk  # noqa: E501
+    Conekta sdk
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
-"""
+"""  # noqa: E501
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
 
-from typing import Any, Dict, List, Optional
-from pydantic import BaseModel, Field, StrictBool, StrictStr, conlist
-from conekta.models.customer_fiscal_entities_request import CustomerFiscalEntitiesRequest
-from conekta.models.customer_payment_methods_request import CustomerPaymentMethodsRequest
+from typing import Any, ClassVar, Dict, List, Optional
+from pydantic import BaseModel, StrictBool, StrictStr
+from pydantic import Field
+from typing_extensions import Annotated
+from conekta.models.charge_request import ChargeRequest
+from conekta.models.checkout_request import CheckoutRequest
 from conekta.models.customer_shipping_contacts import CustomerShippingContacts
-from conekta.models.subscription_request import SubscriptionRequest
-from conekta.models.update_customer_antifraud_info import UpdateCustomerAntifraudInfo
+from conekta.models.order_discount_lines_request import OrderDiscountLinesRequest
+from conekta.models.order_fiscal_entity_request import OrderFiscalEntityRequest
+from conekta.models.order_request_customer_info import OrderRequestCustomerInfo
+from conekta.models.order_tax_request import OrderTaxRequest
+from conekta.models.product import Product
+from conekta.models.shipping_request import ShippingRequest
+try:
+    from typing import Self
+except ImportError:
+    from typing_extensions import Self
 
-class UpdateCustomer(BaseModel):
-    """
-    update customer
+class OrderRequest(BaseModel):
     """
-    antifraud_info: Optional[UpdateCustomerAntifraudInfo] = None
-    default_payment_source_id: Optional[StrictStr] = Field(None, description="It is a parameter that allows to identify in the response, the Conekta ID of a payment method (payment_id)")
-    email: Optional[StrictStr] = Field(None, description="An email address is a series of customizable characters followed by a universal Internet symbol, the at symbol (@), the name of a host server, and a web domain ending (.mx, .com, .org, . net, etc).")
-    name: Optional[StrictStr] = Field(None, description="Client's name")
-    phone: Optional[StrictStr] = Field(None, description="Is the customer's phone number")
-    plan_id: Optional[StrictStr] = Field(None, description="Contains the ID of a plan, which could together with name, email and phone create a client directly to a subscription")
-    default_shipping_contact_id: Optional[StrictStr] = Field(None, description="It is a parameter that allows to identify in the response, the Conekta ID of the shipping address (shipping_contact)")
-    corporate: Optional[StrictBool] = Field(False, description="It is a value that allows identifying if the email is corporate or not.")
-    custom_reference: Optional[StrictStr] = Field(None, description="It is an undefined value.")
-    fiscal_entities: Optional[conlist(CustomerFiscalEntitiesRequest)] = None
-    metadata: Optional[Dict[str, Any]] = None
-    payment_sources: Optional[conlist(CustomerPaymentMethodsRequest)] = Field(None, description="Contains details of the payment methods that the customer has active or has used in Conekta")
-    shipping_contacts: Optional[conlist(CustomerShippingContacts)] = Field(None, description="Contains the detail of the shipping addresses that the client has active or has used in Conekta")
-    subscription: Optional[SubscriptionRequest] = None
-    __properties = ["antifraud_info", "default_payment_source_id", "email", "name", "phone", "plan_id", "default_shipping_contact_id", "corporate", "custom_reference", "fiscal_entities", "metadata", "payment_sources", "shipping_contacts", "subscription"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    a order
+    """ # noqa: E501
+    charges: Optional[List[ChargeRequest]] = Field(default=None, description="List of [charges](https://developers.conekta.com/v2.1.0/reference/orderscreatecharge) that are applied to the order")
+    checkout: Optional[CheckoutRequest] = None
+    currency: Annotated[str, Field(strict=True, max_length=3)] = Field(description="Currency with which the payment will be made. It uses the 3-letter code of the [International Standard ISO 4217.](https://es.wikipedia.org/wiki/ISO_4217)")
+    customer_info: OrderRequestCustomerInfo
+    discount_lines: Optional[List[OrderDiscountLinesRequest]] = Field(default=None, description="List of [discounts](https://developers.conekta.com/v2.1.0/reference/orderscreatediscountline) that are applied to the order. You must have at least one discount.")
+    fiscal_entity: Optional[OrderFiscalEntityRequest] = None
+    line_items: List[Product] = Field(description="List of [products](https://developers.conekta.com/v2.1.0/reference/orderscreateproduct) that are sold in the order. You must have at least one product.")
+    metadata: Optional[Dict[str, Any]] = Field(default=None, description="Metadata associated with the order")
+    needs_shipping_contact: Optional[StrictBool] = Field(default=None, description="Allows you to fill out the shipping information at checkout")
+    pre_authorize: Optional[StrictBool] = Field(default=False, description="Indicates whether the order charges must be preauthorized")
+    processing_mode: Optional[StrictStr] = Field(default=None, description="Indicates the processing mode for the order, either ecommerce, recurrent or validation.")
+    return_url: Optional[StrictStr] = Field(default=None, description="Indicates the redirection callback upon completion of the 3DS2 flow.")
+    shipping_contact: Optional[CustomerShippingContacts] = None
+    shipping_lines: Optional[List[ShippingRequest]] = Field(default=None, description="List of [shipping costs](https://developers.conekta.com/v2.1.0/reference/orderscreateshipping). If the online store offers digital products.")
+    tax_lines: Optional[List[OrderTaxRequest]] = Field(default=None, description="List of [taxes](https://developers.conekta.com/v2.1.0/reference/orderscreatetaxes) that are applied to the order.")
+    three_ds_mode: Optional[StrictStr] = Field(default=None, description="Indicates the 3DS2 mode for the order, either smart or strict.")
+    __properties: ClassVar[List[str]] = ["charges", "checkout", "currency", "customer_info", "discount_lines", "fiscal_entity", "line_items", "metadata", "needs_shipping_contact", "pre_authorize", "processing_mode", "return_url", "shipping_contact", "shipping_lines", "tax_lines", "three_ds_mode"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> UpdateCustomer:
-        """Create an instance of UpdateCustomer from a JSON string"""
+    def from_json(cls, json_str: str) -> Self:
+        """Create an instance of OrderRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
-        # override the default output from pydantic by calling `to_dict()` of antifraud_info
-        if self.antifraud_info:
-            _dict['antifraud_info'] = self.antifraud_info.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of each item in fiscal_entities (list)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude={
+            },
+            exclude_none=True,
+        )
+        # override the default output from pydantic by calling `to_dict()` of each item in charges (list)
         _items = []
-        if self.fiscal_entities:
-            for _item in self.fiscal_entities:
+        if self.charges:
+            for _item in self.charges:
                 if _item:
                     _items.append(_item.to_dict())
-            _dict['fiscal_entities'] = _items
-        # override the default output from pydantic by calling `to_dict()` of each item in payment_sources (list)
+            _dict['charges'] = _items
+        # override the default output from pydantic by calling `to_dict()` of checkout
+        if self.checkout:
+            _dict['checkout'] = self.checkout.to_dict()
+        # override the default output from pydantic by calling `to_dict()` of customer_info
+        if self.customer_info:
+            _dict['customer_info'] = self.customer_info.to_dict()
+        # override the default output from pydantic by calling `to_dict()` of each item in discount_lines (list)
         _items = []
-        if self.payment_sources:
-            for _item in self.payment_sources:
+        if self.discount_lines:
+            for _item in self.discount_lines:
                 if _item:
                     _items.append(_item.to_dict())
-            _dict['payment_sources'] = _items
-        # override the default output from pydantic by calling `to_dict()` of each item in shipping_contacts (list)
+            _dict['discount_lines'] = _items
+        # override the default output from pydantic by calling `to_dict()` of fiscal_entity
+        if self.fiscal_entity:
+            _dict['fiscal_entity'] = self.fiscal_entity.to_dict()
+        # override the default output from pydantic by calling `to_dict()` of each item in line_items (list)
         _items = []
-        if self.shipping_contacts:
-            for _item in self.shipping_contacts:
+        if self.line_items:
+            for _item in self.line_items:
                 if _item:
                     _items.append(_item.to_dict())
-            _dict['shipping_contacts'] = _items
-        # override the default output from pydantic by calling `to_dict()` of subscription
-        if self.subscription:
-            _dict['subscription'] = self.subscription.to_dict()
-        # set to None if antifraud_info (nullable) is None
-        # and __fields_set__ contains the field
-        if self.antifraud_info is None and "antifraud_info" in self.__fields_set__:
-            _dict['antifraud_info'] = None
-
+            _dict['line_items'] = _items
+        # override the default output from pydantic by calling `to_dict()` of shipping_contact
+        if self.shipping_contact:
+            _dict['shipping_contact'] = self.shipping_contact.to_dict()
+        # override the default output from pydantic by calling `to_dict()` of each item in shipping_lines (list)
+        _items = []
+        if self.shipping_lines:
+            for _item in self.shipping_lines:
+                if _item:
+                    _items.append(_item.to_dict())
+            _dict['shipping_lines'] = _items
+        # override the default output from pydantic by calling `to_dict()` of each item in tax_lines (list)
+        _items = []
+        if self.tax_lines:
+            for _item in self.tax_lines:
+                if _item:
+                    _items.append(_item.to_dict())
+            _dict['tax_lines'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> UpdateCustomer:
-        """Create an instance of UpdateCustomer from a dict"""
+    def from_dict(cls, obj: Dict) -> Self:
+        """Create an instance of OrderRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return UpdateCustomer.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = UpdateCustomer.parse_obj({
-            "antifraud_info": UpdateCustomerAntifraudInfo.from_dict(obj.get("antifraud_info")) if obj.get("antifraud_info") is not None else None,
-            "default_payment_source_id": obj.get("default_payment_source_id"),
-            "email": obj.get("email"),
-            "name": obj.get("name"),
-            "phone": obj.get("phone"),
-            "plan_id": obj.get("plan_id"),
-            "default_shipping_contact_id": obj.get("default_shipping_contact_id"),
-            "corporate": obj.get("corporate") if obj.get("corporate") is not None else False,
-            "custom_reference": obj.get("custom_reference"),
-            "fiscal_entities": [CustomerFiscalEntitiesRequest.from_dict(_item) for _item in obj.get("fiscal_entities")] if obj.get("fiscal_entities") is not None else None,
+        _obj = cls.model_validate({
+            "charges": [ChargeRequest.from_dict(_item) for _item in obj.get("charges")] if obj.get("charges") is not None else None,
+            "checkout": CheckoutRequest.from_dict(obj.get("checkout")) if obj.get("checkout") is not None else None,
+            "currency": obj.get("currency"),
+            "customer_info": OrderRequestCustomerInfo.from_dict(obj.get("customer_info")) if obj.get("customer_info") is not None else None,
+            "discount_lines": [OrderDiscountLinesRequest.from_dict(_item) for _item in obj.get("discount_lines")] if obj.get("discount_lines") is not None else None,
+            "fiscal_entity": OrderFiscalEntityRequest.from_dict(obj.get("fiscal_entity")) if obj.get("fiscal_entity") is not None else None,
+            "line_items": [Product.from_dict(_item) for _item in obj.get("line_items")] if obj.get("line_items") is not None else None,
             "metadata": obj.get("metadata"),
-            "payment_sources": [CustomerPaymentMethodsRequest.from_dict(_item) for _item in obj.get("payment_sources")] if obj.get("payment_sources") is not None else None,
-            "shipping_contacts": [CustomerShippingContacts.from_dict(_item) for _item in obj.get("shipping_contacts")] if obj.get("shipping_contacts") is not None else None,
-            "subscription": SubscriptionRequest.from_dict(obj.get("subscription")) if obj.get("subscription") is not None else None
+            "needs_shipping_contact": obj.get("needs_shipping_contact"),
+            "pre_authorize": obj.get("pre_authorize") if obj.get("pre_authorize") is not None else False,
+            "processing_mode": obj.get("processing_mode"),
+            "return_url": obj.get("return_url"),
+            "shipping_contact": CustomerShippingContacts.from_dict(obj.get("shipping_contact")) if obj.get("shipping_contact") is not None else None,
+            "shipping_lines": [ShippingRequest.from_dict(_item) for _item in obj.get("shipping_lines")] if obj.get("shipping_lines") is not None else None,
+            "tax_lines": [OrderTaxRequest.from_dict(_item) for _item in obj.get("tax_lines")] if obj.get("tax_lines") is not None else None,
+            "three_ds_mode": obj.get("three_ds_mode")
         })
         return _obj
 
+
```

### Comparing `conekta-6.0.1/conekta/models/update_customer_payment_methods_response.py` & `conekta-6.0.2/conekta/models/create_customer_payment_methods_response.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,70 +1,77 @@
 # coding: utf-8
 
 """
     Conekta API
 
-    Conekta sdk  # noqa: E501
+    Conekta sdk
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
-"""
+"""  # noqa: E501
 
 
 from __future__ import annotations
 from inspect import getfullargspec
 import json
 import pprint
 import re  # noqa: F401
 
 from typing import Any, List, Optional
-from pydantic import BaseModel, Field, StrictStr, ValidationError, validator
+from pydantic import BaseModel, Field, StrictStr, ValidationError, field_validator
 from conekta.models.payment_method_card_response import PaymentMethodCardResponse
 from conekta.models.payment_method_cash_response import PaymentMethodCashResponse
 from conekta.models.payment_method_spei_recurrent import PaymentMethodSpeiRecurrent
-from typing import Any, List
+from typing import Union, Any, List, TYPE_CHECKING, Optional, Dict
+from typing_extensions import Literal
 from pydantic import StrictStr, Field
+try:
+    from typing import Self
+except ImportError:
+    from typing_extensions import Self
 
-UPDATECUSTOMERPAYMENTMETHODSRESPONSE_ONE_OF_SCHEMAS = ["PaymentMethodCardResponse", "PaymentMethodCashResponse", "PaymentMethodSpeiRecurrent"]
+CREATECUSTOMERPAYMENTMETHODSRESPONSE_ONE_OF_SCHEMAS = ["PaymentMethodCardResponse", "PaymentMethodCashResponse", "PaymentMethodSpeiRecurrent"]
 
-class UpdateCustomerPaymentMethodsResponse(BaseModel):
+class CreateCustomerPaymentMethodsResponse(BaseModel):
     """
-    UpdateCustomerPaymentMethodsResponse
+    CreateCustomerPaymentMethodsResponse
     """
     # data type: PaymentMethodCashResponse
     oneof_schema_1_validator: Optional[PaymentMethodCashResponse] = None
     # data type: PaymentMethodCardResponse
     oneof_schema_2_validator: Optional[PaymentMethodCardResponse] = None
     # data type: PaymentMethodSpeiRecurrent
     oneof_schema_3_validator: Optional[PaymentMethodSpeiRecurrent] = None
-    actual_instance: Any
-    one_of_schemas: List[str] = Field(UPDATECUSTOMERPAYMENTMETHODSRESPONSE_ONE_OF_SCHEMAS, const=True)
+    actual_instance: Optional[Union[PaymentMethodCardResponse, PaymentMethodCashResponse, PaymentMethodSpeiRecurrent]] = None
+    one_of_schemas: List[str] = Literal["PaymentMethodCardResponse", "PaymentMethodCashResponse", "PaymentMethodSpeiRecurrent"]
+
+    model_config = {
+        "validate_assignment": True
+    }
 
-    class Config:
-        validate_assignment = True
 
-    discriminator_value_class_map = {
+    discriminator_value_class_map: Dict[str, str] = {
     }
 
-    def __init__(self, *args, **kwargs):
+    def __init__(self, *args, **kwargs) -> None:
         if args:
             if len(args) > 1:
                 raise ValueError("If a position argument is used, only 1 is allowed to set `actual_instance`")
             if kwargs:
                 raise ValueError("If a position argument is used, keyword arguments cannot be used.")
             super().__init__(actual_instance=args[0])
         else:
             super().__init__(**kwargs)
 
-    @validator('actual_instance')
+    @field_validator('actual_instance')
     def actual_instance_must_validate_oneof(cls, v):
-        instance = UpdateCustomerPaymentMethodsResponse.construct()
+        instance = CreateCustomerPaymentMethodsResponse.model_construct()
         error_messages = []
         match = 0
         # validate data type: PaymentMethodCashResponse
         if not isinstance(v, PaymentMethodCashResponse):
             error_messages.append(f"Error! Input type `{type(v)}` is not `PaymentMethodCashResponse`")
         else:
             match += 1
@@ -76,29 +83,29 @@
         # validate data type: PaymentMethodSpeiRecurrent
         if not isinstance(v, PaymentMethodSpeiRecurrent):
             error_messages.append(f"Error! Input type `{type(v)}` is not `PaymentMethodSpeiRecurrent`")
         else:
             match += 1
         if match > 1:
             # more than 1 match
-            raise ValueError("Multiple matches found when setting `actual_instance` in UpdateCustomerPaymentMethodsResponse with oneOf schemas: PaymentMethodCardResponse, PaymentMethodCashResponse, PaymentMethodSpeiRecurrent. Details: " + ", ".join(error_messages))
+            raise ValueError("Multiple matches found when setting `actual_instance` in CreateCustomerPaymentMethodsResponse with oneOf schemas: PaymentMethodCardResponse, PaymentMethodCashResponse, PaymentMethodSpeiRecurrent. Details: " + ", ".join(error_messages))
         elif match == 0:
             # no match
-            raise ValueError("No match found when setting `actual_instance` in UpdateCustomerPaymentMethodsResponse with oneOf schemas: PaymentMethodCardResponse, PaymentMethodCashResponse, PaymentMethodSpeiRecurrent. Details: " + ", ".join(error_messages))
+            raise ValueError("No match found when setting `actual_instance` in CreateCustomerPaymentMethodsResponse with oneOf schemas: PaymentMethodCardResponse, PaymentMethodCashResponse, PaymentMethodSpeiRecurrent. Details: " + ", ".join(error_messages))
         else:
             return v
 
     @classmethod
-    def from_dict(cls, obj: dict) -> UpdateCustomerPaymentMethodsResponse:
+    def from_dict(cls, obj: dict) -> Self:
         return cls.from_json(json.dumps(obj))
 
     @classmethod
-    def from_json(cls, json_str: str) -> UpdateCustomerPaymentMethodsResponse:
+    def from_json(cls, json_str: str) -> Self:
         """Returns the object represented by the json string"""
-        instance = UpdateCustomerPaymentMethodsResponse.construct()
+        instance = cls.model_construct()
         error_messages = []
         match = 0
 
         # use oneOf discriminator to lookup the data type
         _data_type = json.loads(json_str).get("type")
         if not _data_type:
             raise ValueError("Failed to lookup data type from the field `type` in the input.")
@@ -114,14 +121,19 @@
             return instance
 
         # check if data type is `PaymentMethodCashResponse`
         if _data_type == "oxxo_recurrent":
             instance.actual_instance = PaymentMethodCashResponse.from_json(json_str)
             return instance
 
+        # check if data type is `PaymentMethodSpeiRecurrent`
+        if _data_type == "spei_recurrent":
+            instance.actual_instance = PaymentMethodSpeiRecurrent.from_json(json_str)
+            return instance
+
         # check if data type is `PaymentMethodCardResponse`
         if _data_type == "payment_method_card_response":
             instance.actual_instance = PaymentMethodCardResponse.from_json(json_str)
             return instance
 
         # check if data type is `PaymentMethodCashResponse`
         if _data_type == "payment_method_cash_response":
@@ -129,19 +141,14 @@
             return instance
 
         # check if data type is `PaymentMethodSpeiRecurrent`
         if _data_type == "payment_method_spei_recurrent":
             instance.actual_instance = PaymentMethodSpeiRecurrent.from_json(json_str)
             return instance
 
-        # check if data type is `PaymentMethodSpeiRecurrent`
-        if _data_type == "spei_recurrent":
-            instance.actual_instance = PaymentMethodSpeiRecurrent.from_json(json_str)
-            return instance
-
         # deserialize data into PaymentMethodCashResponse
         try:
             instance.actual_instance = PaymentMethodCashResponse.from_json(json_str)
             match += 1
         except (ValidationError, ValueError) as e:
             error_messages.append(str(e))
         # deserialize data into PaymentMethodCardResponse
@@ -155,41 +162,42 @@
             instance.actual_instance = PaymentMethodSpeiRecurrent.from_json(json_str)
             match += 1
         except (ValidationError, ValueError) as e:
             error_messages.append(str(e))
 
         if match > 1:
             # more than 1 match
-            raise ValueError("Multiple matches found when deserializing the JSON string into UpdateCustomerPaymentMethodsResponse with oneOf schemas: PaymentMethodCardResponse, PaymentMethodCashResponse, PaymentMethodSpeiRecurrent. Details: " + ", ".join(error_messages))
+            raise ValueError("Multiple matches found when deserializing the JSON string into CreateCustomerPaymentMethodsResponse with oneOf schemas: PaymentMethodCardResponse, PaymentMethodCashResponse, PaymentMethodSpeiRecurrent. Details: " + ", ".join(error_messages))
         elif match == 0:
             # no match
-            raise ValueError("No match found when deserializing the JSON string into UpdateCustomerPaymentMethodsResponse with oneOf schemas: PaymentMethodCardResponse, PaymentMethodCashResponse, PaymentMethodSpeiRecurrent. Details: " + ", ".join(error_messages))
+            raise ValueError("No match found when deserializing the JSON string into CreateCustomerPaymentMethodsResponse with oneOf schemas: PaymentMethodCardResponse, PaymentMethodCashResponse, PaymentMethodSpeiRecurrent. Details: " + ", ".join(error_messages))
         else:
             return instance
 
     def to_json(self) -> str:
         """Returns the JSON representation of the actual instance"""
         if self.actual_instance is None:
             return "null"
 
         to_json = getattr(self.actual_instance, "to_json", None)
         if callable(to_json):
             return self.actual_instance.to_json()
         else:
             return json.dumps(self.actual_instance)
 
-    def to_dict(self) -> dict:
+    def to_dict(self) -> Dict:
         """Returns the dict representation of the actual instance"""
         if self.actual_instance is None:
             return None
 
         to_dict = getattr(self.actual_instance, "to_dict", None)
         if callable(to_dict):
             return self.actual_instance.to_dict()
         else:
             # primitive type
             return self.actual_instance
 
     def to_str(self) -> str:
         """Returns the string representation of the actual instance"""
-        return pprint.pformat(self.dict())
+        return pprint.pformat(self.model_dump())
+
```

### Comparing `conekta-6.0.1/conekta/models/update_order_discount_lines_request.py` & `conekta-6.0.2/conekta/models/update_order_discount_lines_request.py`

 * *Files 23% similar despite different names*

```diff
@@ -1,75 +1,94 @@
 # coding: utf-8
 
 """
     Conekta API
 
-    Conekta sdk  # noqa: E501
+    Conekta sdk
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
-"""
+"""  # noqa: E501
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
 
-from typing import Optional
-from pydantic import BaseModel, Field, StrictStr, conint
+from typing import Any, ClassVar, Dict, List, Optional
+from pydantic import BaseModel, StrictStr
+from pydantic import Field
+from typing_extensions import Annotated
+try:
+    from typing import Self
+except ImportError:
+    from typing_extensions import Self
 
 class UpdateOrderDiscountLinesRequest(BaseModel):
     """
     List of discounts that apply to the order.
-    """
-    amount: Optional[conint(strict=True, ge=0)] = None
-    code: Optional[StrictStr] = Field(None, description="Discount code.")
+    """ # noqa: E501
+    amount: Optional[Annotated[int, Field(strict=True, ge=0)]] = None
+    code: Optional[StrictStr] = Field(default=None, description="Discount code.")
     type: Optional[StrictStr] = None
-    __properties = ["amount", "code", "type"]
+    __properties: ClassVar[List[str]] = ["amount", "code", "type"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True
+    }
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> UpdateOrderDiscountLinesRequest:
+    def from_json(cls, json_str: str) -> Self:
         """Create an instance of UpdateOrderDiscountLinesRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude={
+            },
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> UpdateOrderDiscountLinesRequest:
+    def from_dict(cls, obj: Dict) -> Self:
         """Create an instance of UpdateOrderDiscountLinesRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return UpdateOrderDiscountLinesRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = UpdateOrderDiscountLinesRequest.parse_obj({
+        _obj = cls.model_validate({
             "amount": obj.get("amount"),
             "code": obj.get("code"),
             "type": obj.get("type")
         })
         return _obj
 
+
```

### Comparing `conekta-6.0.1/conekta/models/update_order_tax_response.py` & `conekta-6.0.2/conekta/models/discount_lines_data_response.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,81 +1,100 @@
 # coding: utf-8
 
 """
     Conekta API
 
-    Conekta sdk  # noqa: E501
+    Conekta sdk
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
-"""
+"""  # noqa: E501
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
 
-from typing import Any, Dict, Optional
-from pydantic import BaseModel, Field, StrictStr, conint, constr
+from typing import Any, ClassVar, Dict, List
+from pydantic import BaseModel, StrictStr
+from pydantic import Field
+from typing_extensions import Annotated
+try:
+    from typing import Self
+except ImportError:
+    from typing_extensions import Self
 
-class UpdateOrderTaxResponse(BaseModel):
-    """
-    create new taxes for an existing order response
+class DiscountLinesDataResponse(BaseModel):
     """
-    amount: conint(strict=True, ge=0) = Field(..., description="The amount to be collected for tax in cents")
-    description: constr(strict=True, min_length=2) = Field(..., description="description or tax's name")
-    metadata: Optional[Dict[str, Any]] = None
-    id: StrictStr = Field(...)
-    object: Optional[StrictStr] = None
-    parent_id: Optional[StrictStr] = None
-    __properties = ["amount", "description", "metadata", "id", "object", "parent_id"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    DiscountLinesDataResponse
+    """ # noqa: E501
+    amount: Annotated[int, Field(strict=True, ge=0)] = Field(description="The amount to be deducted from the total sum of all payments, in cents.")
+    code: StrictStr = Field(description="Discount code.")
+    type: StrictStr = Field(description="It can be 'loyalty', 'campaign', 'coupon' o 'sign'")
+    id: StrictStr = Field(description="The discount line id")
+    object: StrictStr = Field(description="The object name")
+    parent_id: StrictStr = Field(description="The order id")
+    __properties: ClassVar[List[str]] = ["amount", "code", "type", "id", "object", "parent_id"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> UpdateOrderTaxResponse:
-        """Create an instance of UpdateOrderTaxResponse from a JSON string"""
+    def from_json(cls, json_str: str) -> Self:
+        """Create an instance of DiscountLinesDataResponse from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude={
+            },
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> UpdateOrderTaxResponse:
-        """Create an instance of UpdateOrderTaxResponse from a dict"""
+    def from_dict(cls, obj: Dict) -> Self:
+        """Create an instance of DiscountLinesDataResponse from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return UpdateOrderTaxResponse.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = UpdateOrderTaxResponse.parse_obj({
+        _obj = cls.model_validate({
             "amount": obj.get("amount"),
-            "description": obj.get("description"),
-            "metadata": obj.get("metadata"),
+            "code": obj.get("code"),
+            "type": obj.get("type"),
             "id": obj.get("id"),
             "object": obj.get("object"),
             "parent_id": obj.get("parent_id")
         })
         return _obj
 
+
```

### Comparing `conekta-6.0.1/conekta/models/webhook_key_create_response.py` & `conekta-6.0.2/conekta/models/api_key_create_response_all_of.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,81 +1,89 @@
 # coding: utf-8
 
 """
     Conekta API
 
-    Conekta sdk  # noqa: E501
+    Conekta sdk
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
-"""
+"""  # noqa: E501
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
 
-from typing import Optional
-from pydantic import BaseModel, Field, StrictBool, StrictInt, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from pydantic import BaseModel, StrictStr
+from pydantic import Field
+try:
+    from typing import Self
+except ImportError:
+    from typing_extensions import Self
 
-class WebhookKeyCreateResponse(BaseModel):
-    """
-    webhook keys model
+class ApiKeyCreateResponseAllOf(BaseModel):
     """
-    active: Optional[StrictBool] = Field(None, description="Indicates if the webhook key is active")
-    created_at: Optional[StrictInt] = Field(None, description="Unix timestamp in seconds with the creation date of the webhook key")
-    id: Optional[StrictStr] = Field(None, description="Unique identifier of the webhook key")
-    livemode: Optional[StrictBool] = Field(None, description="Indicates if the webhook key is in live mode")
-    object: Optional[StrictStr] = Field(None, description="Object name, value is webhook_key")
-    public_key: Optional[StrictStr] = Field(None, description="Public key to be used in the webhook")
-    __properties = ["active", "created_at", "id", "livemode", "object", "public_key"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    ApiKeyCreateResponseAllOf
+    """ # noqa: E501
+    authentication_token: Optional[StrictStr] = Field(default=None, description="It is occupied as a user when authenticated with basic authentication, with a blank password. This value will only appear once, in the request to create a new key. Copy and save it in a safe place.")
+    __properties: ClassVar[List[str]] = ["authentication_token"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> WebhookKeyCreateResponse:
-        """Create an instance of WebhookKeyCreateResponse from a JSON string"""
+    def from_json(cls, json_str: str) -> Self:
+        """Create an instance of ApiKeyCreateResponseAllOf from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude={
+            },
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> WebhookKeyCreateResponse:
-        """Create an instance of WebhookKeyCreateResponse from a dict"""
+    def from_dict(cls, obj: Dict) -> Self:
+        """Create an instance of ApiKeyCreateResponseAllOf from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return WebhookKeyCreateResponse.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = WebhookKeyCreateResponse.parse_obj({
-            "active": obj.get("active"),
-            "created_at": obj.get("created_at"),
-            "id": obj.get("id"),
-            "livemode": obj.get("livemode"),
-            "object": obj.get("object"),
-            "public_key": obj.get("public_key")
+        _obj = cls.model_validate({
+            "authentication_token": obj.get("authentication_token")
         })
         return _obj
 
+
```

### Comparing `conekta-6.0.1/conekta/models/webhook_key_delete_response.py` & `conekta-6.0.2/conekta/models/webhook_key_delete_response.py`

 * *Files 11% similar despite different names*

```diff
@@ -1,81 +1,99 @@
 # coding: utf-8
 
 """
     Conekta API
 
-    Conekta sdk  # noqa: E501
+    Conekta sdk
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
-"""
+"""  # noqa: E501
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
 
-from typing import Optional
-from pydantic import BaseModel, Field, StrictBool, StrictInt, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from pydantic import BaseModel, StrictBool, StrictInt, StrictStr
+from pydantic import Field
+try:
+    from typing import Self
+except ImportError:
+    from typing_extensions import Self
 
 class WebhookKeyDeleteResponse(BaseModel):
     """
     webhook keys model
-    """
-    active: Optional[StrictBool] = Field(None, description="Indicates if the webhook key is active")
-    created_at: Optional[StrictInt] = Field(None, description="Unix timestamp in seconds with the creation date of the webhook key")
-    deleted: Optional[StrictBool] = Field(None, description="Indicates if the webhook key is deleted")
-    id: Optional[StrictStr] = Field(None, description="Unique identifier of the webhook key")
-    livemode: Optional[StrictBool] = Field(None, description="Indicates if the webhook key is in live mode")
-    object: Optional[StrictStr] = Field(None, description="Object name, value is webhook_key")
-    __properties = ["active", "created_at", "deleted", "id", "livemode", "object"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    """ # noqa: E501
+    active: Optional[StrictBool] = Field(default=None, description="Indicates if the webhook key is active")
+    created_at: Optional[StrictInt] = Field(default=None, description="Unix timestamp in seconds with the creation date of the webhook key")
+    deleted: Optional[StrictBool] = Field(default=None, description="Indicates if the webhook key is deleted")
+    id: Optional[StrictStr] = Field(default=None, description="Unique identifier of the webhook key")
+    livemode: Optional[StrictBool] = Field(default=None, description="Indicates if the webhook key is in live mode")
+    object: Optional[StrictStr] = Field(default=None, description="Object name, value is webhook_key")
+    __properties: ClassVar[List[str]] = ["active", "created_at", "deleted", "id", "livemode", "object"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> WebhookKeyDeleteResponse:
+    def from_json(cls, json_str: str) -> Self:
         """Create an instance of WebhookKeyDeleteResponse from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude={
+            },
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> WebhookKeyDeleteResponse:
+    def from_dict(cls, obj: Dict) -> Self:
         """Create an instance of WebhookKeyDeleteResponse from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return WebhookKeyDeleteResponse.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = WebhookKeyDeleteResponse.parse_obj({
+        _obj = cls.model_validate({
             "active": obj.get("active"),
             "created_at": obj.get("created_at"),
             "deleted": obj.get("deleted"),
             "id": obj.get("id"),
             "livemode": obj.get("livemode"),
             "object": obj.get("object")
         })
         return _obj
 
+
```

### Comparing `conekta-6.0.1/conekta/models/webhook_key_request.py` & `conekta-6.0.2/conekta/models/webhook_key_update_request.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,71 +1,89 @@
 # coding: utf-8
 
 """
     Conekta API
 
-    Conekta sdk  # noqa: E501
+    Conekta sdk
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
-"""
+"""  # noqa: E501
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
 
-from typing import Optional
-from pydantic import BaseModel, Field, StrictBool
+from typing import Any, ClassVar, Dict, List, Optional
+from pydantic import BaseModel, StrictBool
+from pydantic import Field
+try:
+    from typing import Self
+except ImportError:
+    from typing_extensions import Self
 
-class WebhookKeyRequest(BaseModel):
-    """
-    WebhookKeyRequest
+class WebhookKeyUpdateRequest(BaseModel):
     """
-    active: Optional[StrictBool] = Field(True, description="Indicates if the webhook key is active")
-    __properties = ["active"]
+    WebhookKeyUpdateRequest
+    """ # noqa: E501
+    active: Optional[StrictBool] = Field(default=False, description="Indicates if the webhook key is active")
+    __properties: ClassVar[List[str]] = ["active"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True
+    }
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> WebhookKeyRequest:
-        """Create an instance of WebhookKeyRequest from a JSON string"""
+    def from_json(cls, json_str: str) -> Self:
+        """Create an instance of WebhookKeyUpdateRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude={
+            },
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> WebhookKeyRequest:
-        """Create an instance of WebhookKeyRequest from a dict"""
+    def from_dict(cls, obj: Dict) -> Self:
+        """Create an instance of WebhookKeyUpdateRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return WebhookKeyRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = WebhookKeyRequest.parse_obj({
-            "active": obj.get("active") if obj.get("active") is not None else True
+        _obj = cls.model_validate({
+            "active": obj.get("active") if obj.get("active") is not None else False
         })
         return _obj
 
+
```

### Comparing `conekta-6.0.1/conekta/models/webhook_key_response.py` & `conekta-6.0.2/conekta/models/webhook_key_response.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,88 +1,106 @@
 # coding: utf-8
 
 """
     Conekta API
 
-    Conekta sdk  # noqa: E501
+    Conekta sdk
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
-"""
+"""  # noqa: E501
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
 
-from typing import Optional
-from pydantic import BaseModel, Field, StrictBool, StrictInt, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from pydantic import BaseModel, StrictBool, StrictInt, StrictStr
+from pydantic import Field
+try:
+    from typing import Self
+except ImportError:
+    from typing_extensions import Self
 
 class WebhookKeyResponse(BaseModel):
     """
     webhook keys model
-    """
-    id: Optional[StrictStr] = Field(None, description="Unique identifier of the webhook key")
-    active: Optional[StrictBool] = Field(None, description="Indicates if the webhook key is active")
-    created_at: Optional[StrictInt] = Field(None, description="Unix timestamp in seconds with the creation date of the webhook key")
-    deactivated_at: Optional[StrictInt] = Field(None, description="Unix timestamp in seconds with the deactivation date of the webhook key")
-    public_key: Optional[StrictStr] = Field(None, description="Public key to be used in the webhook")
-    livemode: Optional[StrictBool] = Field(None, description="Indicates if the webhook key is in live mode")
-    object: Optional[StrictStr] = Field(None, description="Object name, value is webhook_key")
-    __properties = ["id", "active", "created_at", "deactivated_at", "public_key", "livemode", "object"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    """ # noqa: E501
+    id: Optional[StrictStr] = Field(default=None, description="Unique identifier of the webhook key")
+    active: Optional[StrictBool] = Field(default=None, description="Indicates if the webhook key is active")
+    created_at: Optional[StrictInt] = Field(default=None, description="Unix timestamp in seconds with the creation date of the webhook key")
+    deactivated_at: Optional[StrictInt] = Field(default=None, description="Unix timestamp in seconds with the deactivation date of the webhook key")
+    public_key: Optional[StrictStr] = Field(default=None, description="Public key to be used in the webhook")
+    livemode: Optional[StrictBool] = Field(default=None, description="Indicates if the webhook key is in live mode")
+    object: Optional[StrictStr] = Field(default=None, description="Object name, value is webhook_key")
+    __properties: ClassVar[List[str]] = ["id", "active", "created_at", "deactivated_at", "public_key", "livemode", "object"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> WebhookKeyResponse:
+    def from_json(cls, json_str: str) -> Self:
         """Create an instance of WebhookKeyResponse from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude={
+            },
+            exclude_none=True,
+        )
         # set to None if deactivated_at (nullable) is None
-        # and __fields_set__ contains the field
-        if self.deactivated_at is None and "deactivated_at" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.deactivated_at is None and "deactivated_at" in self.model_fields_set:
             _dict['deactivated_at'] = None
 
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> WebhookKeyResponse:
+    def from_dict(cls, obj: Dict) -> Self:
         """Create an instance of WebhookKeyResponse from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return WebhookKeyResponse.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = WebhookKeyResponse.parse_obj({
+        _obj = cls.model_validate({
             "id": obj.get("id"),
             "active": obj.get("active"),
             "created_at": obj.get("created_at"),
             "deactivated_at": obj.get("deactivated_at"),
             "public_key": obj.get("public_key"),
             "livemode": obj.get("livemode"),
             "object": obj.get("object")
         })
         return _obj
 
+
```

### Comparing `conekta-6.0.1/conekta/models/webhook_key_update_request.py` & `conekta-6.0.2/conekta/models/api_key_update_request.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,71 +1,91 @@
 # coding: utf-8
 
 """
     Conekta API
 
-    Conekta sdk  # noqa: E501
+    Conekta sdk
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
-"""
+"""  # noqa: E501
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
 
-from typing import Optional
-from pydantic import BaseModel, Field, StrictBool
+from typing import Any, ClassVar, Dict, List, Optional
+from pydantic import BaseModel, StrictBool, StrictStr
+from pydantic import Field
+try:
+    from typing import Self
+except ImportError:
+    from typing_extensions import Self
 
-class WebhookKeyUpdateRequest(BaseModel):
-    """
-    WebhookKeyUpdateRequest
+class ApiKeyUpdateRequest(BaseModel):
     """
-    active: Optional[StrictBool] = Field(False, description="Indicates if the webhook key is active")
-    __properties = ["active"]
+    ApiKeyUpdateRequest
+    """ # noqa: E501
+    active: Optional[StrictBool] = Field(default=None, description="Indicates if the webhook key is active")
+    description: Optional[StrictStr] = Field(default=None, description="A name or brief explanation of what this api key is used for")
+    __properties: ClassVar[List[str]] = ["active", "description"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True
+    }
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> WebhookKeyUpdateRequest:
-        """Create an instance of WebhookKeyUpdateRequest from a JSON string"""
+    def from_json(cls, json_str: str) -> Self:
+        """Create an instance of ApiKeyUpdateRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude={
+            },
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> WebhookKeyUpdateRequest:
-        """Create an instance of WebhookKeyUpdateRequest from a dict"""
+    def from_dict(cls, obj: Dict) -> Self:
+        """Create an instance of ApiKeyUpdateRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return WebhookKeyUpdateRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = WebhookKeyUpdateRequest.parse_obj({
-            "active": obj.get("active") if obj.get("active") is not None else False
+        _obj = cls.model_validate({
+            "active": obj.get("active"),
+            "description": obj.get("description")
         })
         return _obj
 
+
```

### Comparing `conekta-6.0.1/conekta/models/webhook_log.py` & `conekta-6.0.2/conekta/models/webhook_log.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,83 +1,100 @@
 # coding: utf-8
 
 """
     Conekta API
 
-    Conekta sdk  # noqa: E501
+    Conekta sdk
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
-"""
+"""  # noqa: E501
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
 
-from typing import Any, Dict, Optional
+from typing import Any, ClassVar, Dict, List, Optional
 from pydantic import BaseModel, StrictInt, StrictStr
+try:
+    from typing import Self
+except ImportError:
+    from typing_extensions import Self
 
 class WebhookLog(BaseModel):
     """
     WebhookLog
-    """
+    """ # noqa: E501
     failed_attempts: Optional[StrictInt] = None
     id: Optional[StrictStr] = None
     last_attempted_at: Optional[StrictInt] = None
     last_http_response_status: Optional[StrictInt] = None
     object: Optional[StrictStr] = None
     response_data: Optional[Dict[str, Any]] = None
     url: Optional[StrictStr] = None
-    __properties = ["failed_attempts", "id", "last_attempted_at", "last_http_response_status", "object", "response_data", "url"]
+    __properties: ClassVar[List[str]] = ["failed_attempts", "id", "last_attempted_at", "last_http_response_status", "object", "response_data", "url"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True
+    }
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> WebhookLog:
+    def from_json(cls, json_str: str) -> Self:
         """Create an instance of WebhookLog from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude={
+            },
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> WebhookLog:
+    def from_dict(cls, obj: Dict) -> Self:
         """Create an instance of WebhookLog from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return WebhookLog.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = WebhookLog.parse_obj({
+        _obj = cls.model_validate({
             "failed_attempts": obj.get("failed_attempts"),
             "id": obj.get("id"),
             "last_attempted_at": obj.get("last_attempted_at"),
             "last_http_response_status": obj.get("last_http_response_status"),
             "object": obj.get("object"),
             "response_data": obj.get("response_data"),
             "url": obj.get("url")
         })
         return _obj
 
+
```

### Comparing `conekta-6.0.1/conekta/models/webhook_request.py` & `conekta-6.0.2/conekta/models/webhook_update_request.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,80 +1,101 @@
 # coding: utf-8
 
 """
     Conekta API
 
-    Conekta sdk  # noqa: E501
+    Conekta sdk
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
-"""
+"""  # noqa: E501
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
 
+from typing import Any, ClassVar, Dict, List, Optional
+from pydantic import BaseModel, StrictBool, StrictStr, field_validator
+from pydantic import Field
+from typing_extensions import Annotated
+try:
+    from typing import Self
+except ImportError:
+    from typing_extensions import Self
 
-from pydantic import BaseModel, Field, StrictBool, constr, validator
-
-class WebhookRequest(BaseModel):
+class WebhookUpdateRequest(BaseModel):
     """
-    a webhook
-    """
-    url: constr(strict=True) = Field(..., description="Here you must place the URL of your Webhook remember that you must program what you will do with the events received. Also do not forget to handle the HTTPS protocol for greater security.")
-    synchronous: StrictBool = Field(..., description="It is a value that allows to decide if the events will be synchronous or asynchronous. We recommend asynchronous = false")
-    __properties = ["url", "synchronous"]
+    an updated webhook
+    """ # noqa: E501
+    url: Annotated[str, Field(strict=True)] = Field(description="Here you must place the URL of your Webhook remember that you must program what you will do with the events received. Also do not forget to handle the HTTPS protocol for greater security.")
+    synchronous: Optional[StrictBool] = Field(default=False, description="It is a value that allows to decide if the events will be synchronous or asynchronous. We recommend asynchronous = false")
+    events: Optional[List[StrictStr]] = None
+    __properties: ClassVar[List[str]] = ["url", "synchronous", "events"]
 
-    @validator('url')
+    @field_validator('url')
     def url_validate_regular_expression(cls, value):
         """Validates the regular expression"""
         if not re.match(r"^(?!.*(localhost|127\.0\.0\.1)).*$", value):
             raise ValueError(r"must validate the regular expression /^(?!.*(localhost|127\.0\.0\.1)).*$/")
         return value
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> WebhookRequest:
-        """Create an instance of WebhookRequest from a JSON string"""
+    def from_json(cls, json_str: str) -> Self:
+        """Create an instance of WebhookUpdateRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude={
+            },
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> WebhookRequest:
-        """Create an instance of WebhookRequest from a dict"""
+    def from_dict(cls, obj: Dict) -> Self:
+        """Create an instance of WebhookUpdateRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return WebhookRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = WebhookRequest.parse_obj({
+        _obj = cls.model_validate({
             "url": obj.get("url"),
-            "synchronous": obj.get("synchronous") if obj.get("synchronous") is not None else False
+            "synchronous": obj.get("synchronous") if obj.get("synchronous") is not None else False,
+            "events": obj.get("events")
         })
         return _obj
 
+
```

### Comparing `conekta-6.0.1/conekta/models/webhook_update_request.py` & `conekta-6.0.2/conekta/models/api_key_request.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,82 +1,91 @@
 # coding: utf-8
 
 """
     Conekta API
 
-    Conekta sdk  # noqa: E501
+    Conekta sdk
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
-"""
+"""  # noqa: E501
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
 
-from typing import List, Optional
-from pydantic import BaseModel, Field, StrictBool, StrictStr, conlist, constr, validator
+from typing import Any, ClassVar, Dict, List, Optional
+from pydantic import BaseModel, StrictStr
+from pydantic import Field
+try:
+    from typing import Self
+except ImportError:
+    from typing_extensions import Self
 
-class WebhookUpdateRequest(BaseModel):
-    """
-    an updated webhook
+class ApiKeyRequest(BaseModel):
     """
-    url: constr(strict=True) = Field(..., description="Here you must place the URL of your Webhook remember that you must program what you will do with the events received. Also do not forget to handle the HTTPS protocol for greater security.")
-    synchronous: Optional[StrictBool] = Field(False, description="It is a value that allows to decide if the events will be synchronous or asynchronous. We recommend asynchronous = false")
-    subscribed_events: Optional[conlist(StrictStr)] = None
-    __properties = ["url", "synchronous", "subscribed_events"]
-
-    @validator('url')
-    def url_validate_regular_expression(cls, value):
-        """Validates the regular expression"""
-        if not re.match(r"^(?!.*(localhost|127\.0\.0\.1)).*$", value):
-            raise ValueError(r"must validate the regular expression /^(?!.*(localhost|127\.0\.0\.1)).*$/")
-        return value
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    ApiKeyRequest
+    """ # noqa: E501
+    description: Optional[StrictStr] = Field(default=None, description="A name or brief explanation of what this api key is used for")
+    role: StrictStr
+    __properties: ClassVar[List[str]] = ["description", "role"]
+
+    model_config = {
+        "populate_by_name": True,
+        "validate_assignment": True
+    }
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> WebhookUpdateRequest:
-        """Create an instance of WebhookUpdateRequest from a JSON string"""
+    def from_json(cls, json_str: str) -> Self:
+        """Create an instance of ApiKeyRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude={
+            },
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> WebhookUpdateRequest:
-        """Create an instance of WebhookUpdateRequest from a dict"""
+    def from_dict(cls, obj: Dict) -> Self:
+        """Create an instance of ApiKeyRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return WebhookUpdateRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = WebhookUpdateRequest.parse_obj({
-            "url": obj.get("url"),
-            "synchronous": obj.get("synchronous") if obj.get("synchronous") is not None else False,
-            "subscribed_events": obj.get("subscribed_events")
+        _obj = cls.model_validate({
+            "description": obj.get("description"),
+            "role": obj.get("role")
         })
         return _obj
 
+
```

### Comparing `conekta-6.0.1/conekta.egg-info/SOURCES.txt` & `conekta-6.0.2/conekta.egg-info/SOURCES.txt`

 * *Files 2% similar despite different names*

```diff
@@ -6,14 +6,15 @@
 setup.cfg
 setup.py
 conekta/__init__.py
 conekta/api_client.py
 conekta/api_response.py
 conekta/configuration.py
 conekta/exceptions.py
+conekta/py.typed
 conekta/rest.py
 conekta.egg-info/PKG-INFO
 conekta.egg-info/SOURCES.txt
 conekta.egg-info/dependency_links.txt
 conekta.egg-info/requires.txt
 conekta.egg-info/top_level.txt
 conekta/api/__init__.py
@@ -59,14 +60,15 @@
 conekta/models/charge_request_payment_method.py
 conekta/models/charge_response.py
 conekta/models/charge_response_channel.py
 conekta/models/charge_response_payment_method.py
 conekta/models/charge_response_refunds.py
 conekta/models/charge_response_refunds_all_of.py
 conekta/models/charge_response_refunds_data.py
+conekta/models/charge_update_request.py
 conekta/models/charges_data_response.py
 conekta/models/checkout.py
 conekta/models/checkout_order_template.py
 conekta/models/checkout_order_template_customer_info.py
 conekta/models/checkout_request.py
 conekta/models/checkout_response.py
 conekta/models/checkouts_response.py
@@ -88,15 +90,14 @@
 conekta/models/customer_fiscal_entities_request.py
 conekta/models/customer_fiscal_entities_request_address.py
 conekta/models/customer_fiscal_entities_response.py
 conekta/models/customer_fiscal_entities_response_all_of.py
 conekta/models/customer_info.py
 conekta/models/customer_info_just_customer_id.py
 conekta/models/customer_info_just_customer_id_response.py
-conekta/models/customer_info_response.py
 conekta/models/customer_payment_method_request.py
 conekta/models/customer_payment_methods.py
 conekta/models/customer_payment_methods_data.py
 conekta/models/customer_payment_methods_request.py
 conekta/models/customer_payment_methods_response.py
 conekta/models/customer_response.py
 conekta/models/customer_response_shipping_contacts.py
@@ -121,14 +122,15 @@
 conekta/models/discount_lines_response.py
 conekta/models/discount_lines_response_all_of.py
 conekta/models/email_checkout_request.py
 conekta/models/error.py
 conekta/models/error_all_of.py
 conekta/models/event_response.py
 conekta/models/events_resend_response.py
+conekta/models/fiscal_entity_address.py
 conekta/models/get_api_keys_response.py
 conekta/models/get_api_keys_response_all_of.py
 conekta/models/get_charges_response.py
 conekta/models/get_charges_response_all_of.py
 conekta/models/get_companies_response.py
 conekta/models/get_companies_response_all_of.py
 conekta/models/get_customer_payment_method_data_response.py
@@ -149,34 +151,39 @@
 conekta/models/get_webhook_keys_response_all_of.py
 conekta/models/get_webhooks_response.py
 conekta/models/get_webhooks_response_all_of.py
 conekta/models/log_response.py
 conekta/models/logs_response.py
 conekta/models/logs_response_data.py
 conekta/models/order_capture_request.py
+conekta/models/order_customer_info_response.py
 conekta/models/order_discount_lines_request.py
+conekta/models/order_fiscal_entity_address_response.py
+conekta/models/order_fiscal_entity_address_response_all_of.py
+conekta/models/order_fiscal_entity_request.py
+conekta/models/order_fiscal_entity_response.py
+conekta/models/order_next_action_response.py
+conekta/models/order_next_action_response_redirect_to_url.py
 conekta/models/order_refund_request.py
 conekta/models/order_request.py
 conekta/models/order_request_customer_info.py
 conekta/models/order_response.py
 conekta/models/order_response_charges.py
 conekta/models/order_response_charges_all_of.py
 conekta/models/order_response_checkout.py
 conekta/models/order_response_customer_info.py
 conekta/models/order_response_customer_info_all_of.py
 conekta/models/order_response_discount_lines.py
 conekta/models/order_response_discount_lines_all_of.py
-conekta/models/order_response_fiscal_entity.py
-conekta/models/order_response_fiscal_entity_address.py
-conekta/models/order_response_fiscal_entity_address_all_of.py
 conekta/models/order_response_products.py
 conekta/models/order_response_products_all_of.py
 conekta/models/order_response_shipping_contact.py
 conekta/models/order_response_shipping_contact_all_of.py
 conekta/models/order_tax_request.py
+conekta/models/order_update_fiscal_entity_request.py
 conekta/models/order_update_request.py
 conekta/models/order_update_request_customer_info.py
 conekta/models/orders_response.py
 conekta/models/page.py
 conekta/models/pagination.py
 conekta/models/payment_method.py
 conekta/models/payment_method_bank_transfer.py
```

### Comparing `conekta-6.0.1/setup.py` & `conekta-6.0.2/setup.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,38 +1,38 @@
 # coding: utf-8
 
 """
     Conekta API
 
-    Conekta sdk  # noqa: E501
+    Conekta sdk
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
-"""
+"""  # noqa: E501
 
 
 from setuptools import setup, find_packages  # noqa: H301
 
 # To install the library, run the following
 #
 # python setup.py install
 #
 # prerequisite: setuptools
 # http://pypi.python.org/pypi/setuptools
 NAME = "conekta"
-VERSION = "6.0.1"
+VERSION = "6.0.2"
 PYTHON_REQUIRES = ">=3.7"
 REQUIRES = [
-    "urllib3 >= 1.25.3",
+    "urllib3 >= 1.25.3, < 2.1.0",
     "python-dateutil",
-    "pydantic >= 1.10.5, < 2",
-    "aenum"
+    "pydantic >= 2",
+    "typing-extensions >= 4.7.1",
 ]
 
 setup(
     name=NAME,
     version=VERSION,
     description="Conekta API",
     author="Engineering Conekta",
@@ -41,10 +41,11 @@
     keywords=["OpenAPI", "OpenAPI-Generator", "Conekta API"],
     install_requires=REQUIRES,
     packages=find_packages(exclude=["test", "tests"]),
     include_package_data=True,
     license="MIT-LICENSE",
     long_description_content_type='text/markdown',
     long_description="""\
-    Conekta sdk  # noqa: E501
-    """
+    Conekta sdk
+    """,  # noqa: E501
+    package_data={"conekta": ["py.typed"]},
 )
```

### Comparing `conekta-6.0.1/test/test_antifraud_api.py` & `conekta-6.0.2/test/test_antifraud_api.py`

 * *Files identical despite different names*

### Comparing `conekta-6.0.1/test/test_api_keys_api.py` & `conekta-6.0.2/test/test_api_keys_api.py`

 * *Files identical despite different names*

### Comparing `conekta-6.0.1/test/test_balances_api.py` & `conekta-6.0.2/test/test_balances_api.py`

 * *Files identical despite different names*

### Comparing `conekta-6.0.1/test/test_charges_api.py` & `conekta-6.0.2/test/test_charges_api.py`

 * *Files identical despite different names*

### Comparing `conekta-6.0.1/test/test_companies_api.py` & `conekta-6.0.2/test/test_companies_api.py`

 * *Files identical despite different names*

### Comparing `conekta-6.0.1/test/test_customers_api.py` & `conekta-6.0.2/test/test_customers_api.py`

 * *Files identical despite different names*

### Comparing `conekta-6.0.1/test/test_discounts_api.py` & `conekta-6.0.2/test/test_discounts_api.py`

 * *Files identical despite different names*

### Comparing `conekta-6.0.1/test/test_events_api.py` & `conekta-6.0.2/test/test_events_api.py`

 * *Files identical despite different names*

### Comparing `conekta-6.0.1/test/test_logs_api.py` & `conekta-6.0.2/test/test_logs_api.py`

 * *Files identical despite different names*

### Comparing `conekta-6.0.1/test/test_orders_api.py` & `conekta-6.0.2/test/test_orders_api.py`

 * *Files 17% similar despite different names*

```diff
@@ -54,15 +54,37 @@
                     customer_id='cus_2tYENskzTjjgkGQLt'
                 )
             ),
             line_items=[conekta.Product(
                 name='product',
                 quantity=1,
                 unit_price=1000
-            )]
+            )],
+            shipping_contact=conekta.CustomerShippingContacts(
+                address=conekta.CustomerShippingContactsAddress(
+                        street1='Calle 123, int 2',
+                        street2='Col. Condesa',
+                        city='Cuauhtmoc',
+                        state='Ciudad de Mxico',
+                        country='MX',
+                    ),
+                metadata={}
+                ),
+            fiscal_entity=conekta.OrderFiscalEntityRequest(
+                address=conekta.FiscalEntityAddress(
+                        state='Ciudad de Mxico',
+                        street1='Calle 123, int 2',
+                        street2='Col. Condesa',
+                        city='Cuauhtmoc',
+                        country='MX',
+                        postal_code='06100',
+                        external_number='123',
+                    ),
+                metadata={},
+            )
         )
         response = self.api.create_order(rq, accept_language)
         self.assertIsNotNone(response)
 
     def test_get_order_by_id(self):
         """Test case for get_order_by_id
```

#### encoding

```diff
@@ -1 +1 @@
-us-ascii
+utf-8
```

### Comparing `conekta-6.0.1/test/test_payment_link_api.py` & `conekta-6.0.2/test/test_payment_link_api.py`

 * *Files identical despite different names*

### Comparing `conekta-6.0.1/test/test_payment_methods_api.py` & `conekta-6.0.2/test/test_payment_methods_api.py`

 * *Files identical despite different names*

### Comparing `conekta-6.0.1/test/test_plans_api.py` & `conekta-6.0.2/test/test_plans_api.py`

 * *Files identical despite different names*

### Comparing `conekta-6.0.1/test/test_products_api.py` & `conekta-6.0.2/test/test_products_api.py`

 * *Files identical despite different names*

### Comparing `conekta-6.0.1/test/test_shipping_contacts_api.py` & `conekta-6.0.2/test/test_shipping_contacts_api.py`

 * *Files identical despite different names*

### Comparing `conekta-6.0.1/test/test_shippings_api.py` & `conekta-6.0.2/test/test_shippings_api.py`

 * *Files identical despite different names*

### Comparing `conekta-6.0.1/test/test_subscriptions_api.py` & `conekta-6.0.2/test/test_subscriptions_api.py`

 * *Files identical despite different names*

### Comparing `conekta-6.0.1/test/test_taxes_api.py` & `conekta-6.0.2/test/test_taxes_api.py`

 * *Files identical despite different names*

### Comparing `conekta-6.0.1/test/test_tokens_api.py` & `conekta-6.0.2/test/test_tokens_api.py`

 * *Files identical despite different names*

### Comparing `conekta-6.0.1/test/test_transactions_api.py` & `conekta-6.0.2/test/test_transactions_api.py`

 * *Files identical despite different names*

### Comparing `conekta-6.0.1/test/test_transfers_api.py` & `conekta-6.0.2/test/test_transfers_api.py`

 * *Files identical despite different names*

### Comparing `conekta-6.0.1/test/test_webhook_keys_api.py` & `conekta-6.0.2/test/test_webhook_keys_api.py`

 * *Files 2% similar despite different names*

```diff
@@ -6,15 +6,14 @@
     Conekta sdk  # noqa: E501
 
     The version of the OpenAPI document: 2.1.0
     Contact: engineering@conekta.com
     Generated by: https://openapi-generator.tech
 """
 
-
 from __future__ import absolute_import
 
 import unittest
 
 import conekta
 from conekta import ApiClient
 from conekta.api.webhook_keys_api import WebhookKeysApi  # noqa: E501
@@ -23,15 +22,15 @@
 
 
 class TestWebhookKeysApi(unittest.TestCase):
     """WebhookKeysApi unit test stubs"""
 
     def setUp(self):
         self.api = conekta.api.webhook_keys_api.WebhookKeysApi(ApiClient(
-            configuration=conekta.Configuration(host=get_base_path())
+            configuration=conekta.Configuration(host=get_base_path(), access_token="key_xxx")
         ))  # noqa: E501
 
     def tearDown(self):
         pass
 
     def test_create_webhook_key(self):
         """Test case for create_webhook_key
```

### Comparing `conekta-6.0.1/test/test_webhooks_api.py` & `conekta-6.0.2/test/test_webhooks_api.py`

 * *Files identical despite different names*

