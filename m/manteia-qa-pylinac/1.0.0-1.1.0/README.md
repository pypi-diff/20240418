# Comparing `tmp/manteia_qa_pylinac-1.0.0.tar.gz` & `tmp/manteia_qa_pylinac-1.1.0.tar.gz`

## filetype from file(1)

```diff
@@ -1 +1 @@
-gzip compressed data, was "manteia_qa_pylinac-1.0.0.tar", last modified: Tue Apr  2 03:37:52 2024, max compression
+gzip compressed data, was "manteia_qa_pylinac-1.1.0.tar", last modified: Thu Apr 18 07:21:23 2024, max compression
```

## Comparing `manteia_qa_pylinac-1.0.0.tar` & `manteia_qa_pylinac-1.1.0.tar`

### file list

```diff
@@ -1,62 +1,68 @@
-drwxrwxrwx   0        0        0        0 2024-04-02 03:37:52.982319 manteia_qa_pylinac-1.0.0/
--rw-rw-rw-   0        0        0     1060 2024-01-04 20:28:42.000000 manteia_qa_pylinac-1.0.0/LICENSE.txt
--rw-rw-rw-   0        0        0    25897 2024-04-02 03:37:52.981322 manteia_qa_pylinac-1.0.0/PKG-INFO
--rw-rw-rw-   0        0        0    24650 2024-01-04 20:28:42.000000 manteia_qa_pylinac-1.0.0/README.rst
-drwxrwxrwx   0        0        0        0 2024-04-02 03:37:52.979328 manteia_qa_pylinac-1.0.0/manteia_qa_pylinac.egg-info/
--rw-rw-rw-   0        0        0    25897 2024-04-02 03:37:52.000000 manteia_qa_pylinac-1.0.0/manteia_qa_pylinac.egg-info/PKG-INFO
--rw-rw-rw-   0        0        0     1326 2024-04-02 03:37:52.000000 manteia_qa_pylinac-1.0.0/manteia_qa_pylinac.egg-info/SOURCES.txt
--rw-rw-rw-   0        0        0        1 2024-04-02 03:37:52.000000 manteia_qa_pylinac-1.0.0/manteia_qa_pylinac.egg-info/dependency_links.txt
--rw-rw-rw-   0        0        0        8 2024-04-02 03:37:52.000000 manteia_qa_pylinac-1.0.0/manteia_qa_pylinac.egg-info/top_level.txt
-drwxrwxrwx   0        0        0        0 2024-04-02 03:37:52.926468 manteia_qa_pylinac-1.0.0/pylinac/
--rw-rw-rw-   0        0        0     1504 2024-01-08 01:22:30.000000 manteia_qa_pylinac-1.0.0/pylinac/__init__.py
--rw-rw-rw-   0        0        0    50600 2024-01-08 01:22:30.000000 manteia_qa_pylinac-1.0.0/pylinac/acr.py
-drwxrwxrwx   0        0        0        0 2024-04-02 03:37:52.931455 manteia_qa_pylinac-1.0.0/pylinac/calibration/
--rw-rw-rw-   0        0        0        0 2024-01-08 01:22:30.000000 manteia_qa_pylinac-1.0.0/pylinac/calibration/__init__.py
--rw-rw-rw-   0        0        0    47870 2024-01-08 01:22:30.000000 manteia_qa_pylinac-1.0.0/pylinac/calibration/tg51.py
--rw-rw-rw-   0        0        0    33154 2024-01-08 01:22:30.000000 manteia_qa_pylinac-1.0.0/pylinac/calibration/trs398.py
--rw-rw-rw-   0        0        0    21969 2024-01-08 01:22:30.000000 manteia_qa_pylinac-1.0.0/pylinac/cheese.py
-drwxrwxrwx   0        0        0        0 2024-04-02 03:37:52.957385 manteia_qa_pylinac-1.0.0/pylinac/core/
--rw-rw-rw-   0        0        0        0 2024-01-08 01:22:30.000000 manteia_qa_pylinac-1.0.0/pylinac/core/__init__.py
--rw-rw-rw-   0        0        0    11926 2024-01-08 01:22:30.000000 manteia_qa_pylinac-1.0.0/pylinac/core/array_utils.py
--rw-rw-rw-   0        0        0     5265 2024-01-08 01:22:30.000000 manteia_qa_pylinac-1.0.0/pylinac/core/contrast.py
--rw-rw-rw-   0        0        0     1980 2024-01-08 01:22:30.000000 manteia_qa_pylinac-1.0.0/pylinac/core/decorators.py
--rw-rw-rw-   0        0        0       42 2024-01-08 01:22:30.000000 manteia_qa_pylinac-1.0.0/pylinac/core/exceptions.py
--rw-rw-rw-   0        0        0    17468 2024-01-08 01:22:30.000000 manteia_qa_pylinac-1.0.0/pylinac/core/geometry.py
--rw-rw-rw-   0        0        0     2591 2024-01-08 01:22:30.000000 manteia_qa_pylinac-1.0.0/pylinac/core/hill.py
--rw-rw-rw-   0        0        0    73364 2024-01-08 01:22:30.000000 manteia_qa_pylinac-1.0.0/pylinac/core/image.py
-drwxrwxrwx   0        0        0        0 2024-04-02 03:37:52.970350 manteia_qa_pylinac-1.0.0/pylinac/core/image_generator/
--rw-rw-rw-   0        0        0      511 2024-01-08 01:22:30.000000 manteia_qa_pylinac-1.0.0/pylinac/core/image_generator/__init__.py
--rw-rw-rw-   0        0        0    12466 2024-01-08 01:22:30.000000 manteia_qa_pylinac-1.0.0/pylinac/core/image_generator/layers.py
--rw-rw-rw-   0        0        0    11433 2024-01-08 01:22:30.000000 manteia_qa_pylinac-1.0.0/pylinac/core/image_generator/simulators.py
--rw-rw-rw-   0        0        0    23727 2024-01-08 01:22:30.000000 manteia_qa_pylinac-1.0.0/pylinac/core/image_generator/utils.py
--rw-rw-rw-   0        0        0    10668 2024-01-08 01:22:30.000000 manteia_qa_pylinac-1.0.0/pylinac/core/io.py
--rw-rw-rw-   0        0        0      431 2024-01-08 01:22:30.000000 manteia_qa_pylinac-1.0.0/pylinac/core/mask.py
--rw-rw-rw-   0        0        0      295 2024-01-08 01:22:30.000000 manteia_qa_pylinac-1.0.0/pylinac/core/metrics.py
--rw-rw-rw-   0        0        0     4078 2024-01-08 01:22:30.000000 manteia_qa_pylinac-1.0.0/pylinac/core/mtf.py
--rw-rw-rw-   0        0        0     4579 2024-01-08 01:22:30.000000 manteia_qa_pylinac-1.0.0/pylinac/core/pdf.py
--rw-rw-rw-   0        0        0    96077 2024-01-08 01:22:30.000000 manteia_qa_pylinac-1.0.0/pylinac/core/profile.py
--rw-rw-rw-   0        0        0    14427 2024-01-08 01:22:30.000000 manteia_qa_pylinac-1.0.0/pylinac/core/roi.py
--rw-rw-rw-   0        0        0     3082 2024-01-08 01:22:30.000000 manteia_qa_pylinac-1.0.0/pylinac/core/scale.py
--rw-rw-rw-   0        0        0      175 2024-01-08 01:22:30.000000 manteia_qa_pylinac-1.0.0/pylinac/core/typing.py
--rw-rw-rw-   0        0        0     6242 2024-01-08 01:22:30.000000 manteia_qa_pylinac-1.0.0/pylinac/core/utilities.py
--rw-rw-rw-   0        0        0      473 2024-01-08 01:22:30.000000 manteia_qa_pylinac-1.0.0/pylinac/core/validators.py
--rw-rw-rw-   0        0        0    93089 2024-01-08 01:22:30.000000 manteia_qa_pylinac-1.0.0/pylinac/ct.py
--rw-rw-rw-   0        0        0     5220 2024-01-08 01:22:30.000000 manteia_qa_pylinac-1.0.0/pylinac/dlg.py
--rw-rw-rw-   0        0        0    65267 2024-04-02 02:53:19.000000 manteia_qa_pylinac-1.0.0/pylinac/field_analysis.py
--rw-rw-rw-   0        0        0   111699 2024-01-08 01:22:30.000000 manteia_qa_pylinac-1.0.0/pylinac/log_analyzer.py
-drwxrwxrwx   0        0        0        0 2024-04-02 03:37:52.977331 manteia_qa_pylinac-1.0.0/pylinac/metrics/
--rw-rw-rw-   0        0        0        0 2024-01-08 01:22:30.000000 manteia_qa_pylinac-1.0.0/pylinac/metrics/__init__.py
--rw-rw-rw-   0        0        0     5040 2024-01-08 01:22:30.000000 manteia_qa_pylinac-1.0.0/pylinac/metrics/features.py
--rw-rw-rw-   0        0        0    27440 2024-01-08 01:22:30.000000 manteia_qa_pylinac-1.0.0/pylinac/metrics/image.py
--rw-rw-rw-   0        0        0    19914 2024-01-08 01:22:30.000000 manteia_qa_pylinac-1.0.0/pylinac/metrics/profile.py
--rw-rw-rw-   0        0        0     2344 2024-01-08 01:22:30.000000 manteia_qa_pylinac-1.0.0/pylinac/metrics/utils.py
--rw-rw-rw-   0        0        0    63812 2024-01-09 08:03:54.000000 manteia_qa_pylinac-1.0.0/pylinac/picketfence.py
--rw-rw-rw-   0        0        0   107402 2024-01-09 05:54:41.000000 manteia_qa_pylinac-1.0.0/pylinac/planar_imaging.py
--rw-rw-rw-   0        0        0    23250 2024-01-08 01:22:30.000000 manteia_qa_pylinac-1.0.0/pylinac/quart.py
--rw-rw-rw-   0        0        0      642 2024-01-08 01:22:30.000000 manteia_qa_pylinac-1.0.0/pylinac/settings.py
--rw-rw-rw-   0        0        0    28234 2024-01-08 01:22:30.000000 manteia_qa_pylinac-1.0.0/pylinac/starshot.py
--rw-rw-rw-   0        0        0       24 2024-01-08 01:22:30.000000 manteia_qa_pylinac-1.0.0/pylinac/version.py
--rw-rw-rw-   0        0        0    23079 2024-01-08 01:22:30.000000 manteia_qa_pylinac-1.0.0/pylinac/vmat.py
--rw-rw-rw-   0        0        0    91520 2024-01-08 01:22:30.000000 manteia_qa_pylinac-1.0.0/pylinac/winston_lutz.py
--rw-rw-rw-   0        0        0       42 2024-04-02 03:37:52.982319 manteia_qa_pylinac-1.0.0/setup.cfg
--rw-rw-rw-   0        0        0      916 2024-04-02 03:37:48.000000 manteia_qa_pylinac-1.0.0/setup.py
+drwxrwxrwx   0        0        0        0 2024-04-18 07:21:23.112604 manteia_qa_pylinac-1.1.0/
+-rw-rw-rw-   0        0        0     1060 2024-01-04 20:28:42.000000 manteia_qa_pylinac-1.1.0/LICENSE.txt
+-rw-rw-rw-   0        0        0    25897 2024-04-18 07:21:23.111589 manteia_qa_pylinac-1.1.0/PKG-INFO
+-rw-rw-rw-   0        0        0    24650 2024-01-04 20:28:42.000000 manteia_qa_pylinac-1.1.0/README.rst
+drwxrwxrwx   0        0        0        0 2024-04-18 07:21:23.109585 manteia_qa_pylinac-1.1.0/manteia_qa_pylinac.egg-info/
+-rw-rw-rw-   0        0        0    25897 2024-04-18 07:21:22.000000 manteia_qa_pylinac-1.1.0/manteia_qa_pylinac.egg-info/PKG-INFO
+-rw-rw-rw-   0        0        0     1452 2024-04-18 07:21:22.000000 manteia_qa_pylinac-1.1.0/manteia_qa_pylinac.egg-info/SOURCES.txt
+-rw-rw-rw-   0        0        0        1 2024-04-18 07:21:22.000000 manteia_qa_pylinac-1.1.0/manteia_qa_pylinac.egg-info/dependency_links.txt
+-rw-rw-rw-   0        0        0        8 2024-04-18 07:21:22.000000 manteia_qa_pylinac-1.1.0/manteia_qa_pylinac.egg-info/top_level.txt
+drwxrwxrwx   0        0        0        0 2024-04-18 07:21:23.062734 manteia_qa_pylinac-1.1.0/pylinac/
+-rw-rw-rw-   0        0        0     1473 2024-04-15 17:19:05.000000 manteia_qa_pylinac-1.1.0/pylinac/__init__.py
+-rw-rw-rw-   0        0        0    49289 2024-04-15 17:19:05.000000 manteia_qa_pylinac-1.1.0/pylinac/acr.py
+drwxrwxrwx   0        0        0        0 2024-04-18 07:21:23.067698 manteia_qa_pylinac-1.1.0/pylinac/calibration/
+-rw-rw-rw-   0        0        0        0 2024-04-15 17:19:05.000000 manteia_qa_pylinac-1.1.0/pylinac/calibration/__init__.py
+-rw-rw-rw-   0        0        0    46451 2024-04-15 17:19:05.000000 manteia_qa_pylinac-1.1.0/pylinac/calibration/tg51.py
+-rw-rw-rw-   0        0        0    31948 2024-04-15 17:19:05.000000 manteia_qa_pylinac-1.1.0/pylinac/calibration/trs398.py
+-rw-rw-rw-   0        0        0    21050 2024-04-15 17:19:05.000000 manteia_qa_pylinac-1.1.0/pylinac/cheese.py
+drwxrwxrwx   0        0        0        0 2024-04-18 07:21:23.071690 manteia_qa_pylinac-1.1.0/pylinac/contrib/
+-rw-rw-rw-   0        0        0        0 2024-04-15 17:19:05.000000 manteia_qa_pylinac-1.1.0/pylinac/contrib/__init__.py
+-rw-rw-rw-   0        0        0     4171 2024-04-15 17:19:05.000000 manteia_qa_pylinac-1.1.0/pylinac/contrib/orthogonality.py
+-rw-rw-rw-   0        0        0     2489 2024-04-15 17:19:05.000000 manteia_qa_pylinac-1.1.0/pylinac/contrib/quasar.py
+drwxrwxrwx   0        0        0        0 2024-04-18 07:21:23.096621 manteia_qa_pylinac-1.1.0/pylinac/core/
+-rw-rw-rw-   0        0        0        0 2024-04-15 17:19:05.000000 manteia_qa_pylinac-1.1.0/pylinac/core/__init__.py
+-rw-rw-rw-   0        0        0    11596 2024-04-15 17:19:05.000000 manteia_qa_pylinac-1.1.0/pylinac/core/array_utils.py
+-rw-rw-rw-   0        0        0     5138 2024-04-15 17:19:05.000000 manteia_qa_pylinac-1.1.0/pylinac/core/contrast.py
+-rw-rw-rw-   0        0        0     1912 2024-04-15 17:19:05.000000 manteia_qa_pylinac-1.1.0/pylinac/core/decorators.py
+-rw-rw-rw-   0        0        0       40 2024-04-15 17:19:05.000000 manteia_qa_pylinac-1.1.0/pylinac/core/exceptions.py
+-rw-rw-rw-   0        0        0    19128 2024-04-15 17:19:05.000000 manteia_qa_pylinac-1.1.0/pylinac/core/geometry.py
+-rw-rw-rw-   0        0        0     2514 2024-04-15 17:19:05.000000 manteia_qa_pylinac-1.1.0/pylinac/core/hill.py
+-rw-rw-rw-   0        0        0    76035 2024-04-15 17:19:05.000000 manteia_qa_pylinac-1.1.0/pylinac/core/image.py
+drwxrwxrwx   0        0        0        0 2024-04-18 07:21:23.101583 manteia_qa_pylinac-1.1.0/pylinac/core/image_generator/
+-rw-rw-rw-   0        0        0      508 2024-04-15 17:19:05.000000 manteia_qa_pylinac-1.1.0/pylinac/core/image_generator/__init__.py
+-rw-rw-rw-   0        0        0    17020 2024-04-15 17:19:05.000000 manteia_qa_pylinac-1.1.0/pylinac/core/image_generator/layers.py
+-rw-rw-rw-   0        0        0    11121 2024-04-15 17:19:05.000000 manteia_qa_pylinac-1.1.0/pylinac/core/image_generator/simulators.py
+-rw-rw-rw-   0        0        0    23401 2024-04-15 17:19:05.000000 manteia_qa_pylinac-1.1.0/pylinac/core/image_generator/utils.py
+-rw-rw-rw-   0        0        0    10730 2024-04-15 17:19:05.000000 manteia_qa_pylinac-1.1.0/pylinac/core/io.py
+-rw-rw-rw-   0        0        0      419 2024-04-15 17:19:05.000000 manteia_qa_pylinac-1.1.0/pylinac/core/mask.py
+-rw-rw-rw-   0        0        0      285 2024-04-15 17:19:05.000000 manteia_qa_pylinac-1.1.0/pylinac/core/metrics.py
+-rw-rw-rw-   0        0        0     8825 2024-04-15 17:19:05.000000 manteia_qa_pylinac-1.1.0/pylinac/core/mtf.py
+-rw-rw-rw-   0        0        0     4572 2024-04-15 17:19:05.000000 manteia_qa_pylinac-1.1.0/pylinac/core/nps.py
+-rw-rw-rw-   0        0        0     4425 2024-04-15 17:19:05.000000 manteia_qa_pylinac-1.1.0/pylinac/core/pdf.py
+-rw-rw-rw-   0        0        0    96866 2024-04-15 17:19:05.000000 manteia_qa_pylinac-1.1.0/pylinac/core/profile.py
+-rw-rw-rw-   0        0        0    14273 2024-04-15 17:19:05.000000 manteia_qa_pylinac-1.1.0/pylinac/core/roi.py
+-rw-rw-rw-   0        0        0     2959 2024-04-15 17:19:05.000000 manteia_qa_pylinac-1.1.0/pylinac/core/scale.py
+-rw-rw-rw-   0        0        0      166 2024-04-15 17:19:05.000000 manteia_qa_pylinac-1.1.0/pylinac/core/typing.py
+-rw-rw-rw-   0        0        0     7302 2024-04-15 17:19:05.000000 manteia_qa_pylinac-1.1.0/pylinac/core/utilities.py
+-rw-rw-rw-   0        0        0      664 2024-04-15 17:19:05.000000 manteia_qa_pylinac-1.1.0/pylinac/core/validators.py
+-rw-rw-rw-   0        0        0    96900 2024-04-15 17:19:05.000000 manteia_qa_pylinac-1.1.0/pylinac/ct.py
+-rw-rw-rw-   0        0        0     5093 2024-04-15 17:19:05.000000 manteia_qa_pylinac-1.1.0/pylinac/dlg.py
+-rw-rw-rw-   0        0        0    62890 2024-04-18 07:17:14.000000 manteia_qa_pylinac-1.1.0/pylinac/field_analysis.py
+-rw-rw-rw-   0        0        0   108765 2024-04-15 17:19:05.000000 manteia_qa_pylinac-1.1.0/pylinac/log_analyzer.py
+drwxrwxrwx   0        0        0        0 2024-04-18 07:21:23.108589 manteia_qa_pylinac-1.1.0/pylinac/metrics/
+-rw-rw-rw-   0        0        0        0 2024-04-15 17:19:05.000000 manteia_qa_pylinac-1.1.0/pylinac/metrics/__init__.py
+-rw-rw-rw-   0        0        0     4939 2024-04-15 17:19:05.000000 manteia_qa_pylinac-1.1.0/pylinac/metrics/features.py
+-rw-rw-rw-   0        0        0    25876 2024-04-15 17:19:05.000000 manteia_qa_pylinac-1.1.0/pylinac/metrics/image.py
+-rw-rw-rw-   0        0        0    22606 2024-04-15 17:19:05.000000 manteia_qa_pylinac-1.1.0/pylinac/metrics/profile.py
+-rw-rw-rw-   0        0        0     7907 2024-04-15 17:19:05.000000 manteia_qa_pylinac-1.1.0/pylinac/metrics/utils.py
+-rw-rw-rw-   0        0        0    61009 2024-04-15 17:19:05.000000 manteia_qa_pylinac-1.1.0/pylinac/nuclear.py
+-rw-rw-rw-   0        0        0    63506 2024-04-18 07:09:48.000000 manteia_qa_pylinac-1.1.0/pylinac/picketfence.py
+-rw-rw-rw-   0        0        0   105605 2024-04-15 17:19:05.000000 manteia_qa_pylinac-1.1.0/pylinac/planar_imaging.py
+-rw-rw-rw-   0        0        0    22496 2024-04-15 17:19:05.000000 manteia_qa_pylinac-1.1.0/pylinac/quart.py
+-rw-rw-rw-   0        0        0      624 2024-04-15 17:19:05.000000 manteia_qa_pylinac-1.1.0/pylinac/settings.py
+-rw-rw-rw-   0        0        0    27420 2024-04-15 17:19:05.000000 manteia_qa_pylinac-1.1.0/pylinac/starshot.py
+-rw-rw-rw-   0        0        0       23 2024-04-15 17:19:05.000000 manteia_qa_pylinac-1.1.0/pylinac/version.py
+-rw-rw-rw-   0        0        0    23182 2024-04-15 17:19:05.000000 manteia_qa_pylinac-1.1.0/pylinac/vmat.py
+-rw-rw-rw-   0        0        0   110064 2024-04-15 17:19:05.000000 manteia_qa_pylinac-1.1.0/pylinac/winston_lutz.py
+-rw-rw-rw-   0        0        0       42 2024-04-18 07:21:23.112604 manteia_qa_pylinac-1.1.0/setup.cfg
+-rw-rw-rw-   0        0        0      916 2024-04-18 07:07:50.000000 manteia_qa_pylinac-1.1.0/setup.py
```

### Comparing `manteia_qa_pylinac-1.0.0/LICENSE.txt` & `manteia_qa_pylinac-1.1.0/LICENSE.txt`

 * *Files identical despite different names*

### Comparing `manteia_qa_pylinac-1.0.0/PKG-INFO` & `manteia_qa_pylinac-1.1.0/PKG-INFO`

 * *Files 0% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: manteia_qa_pylinac
-Version: 1.0.0
+Version: 1.1.0
 Summary: pylinac custom made by manteia
 Home-page: 
 Author: dengjianping
 Author-email: 1601246283@qq.com
 License: BSD License
 Platform: all
 Classifier: Intended Audience :: Developers
```

### Comparing `manteia_qa_pylinac-1.0.0/README.rst` & `manteia_qa_pylinac-1.1.0/README.rst`

 * *Files identical despite different names*

### Comparing `manteia_qa_pylinac-1.0.0/manteia_qa_pylinac.egg-info/PKG-INFO` & `manteia_qa_pylinac-1.1.0/manteia_qa_pylinac.egg-info/PKG-INFO`

 * *Files 0% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: manteia_qa_pylinac
-Version: 1.0.0
+Version: 1.1.0
 Summary: pylinac custom made by manteia
 Home-page: 
 Author: dengjianping
 Author-email: 1601246283@qq.com
 License: BSD License
 Platform: all
 Classifier: Intended Audience :: Developers
```

### Comparing `manteia_qa_pylinac-1.0.0/manteia_qa_pylinac.egg-info/SOURCES.txt` & `manteia_qa_pylinac-1.1.0/manteia_qa_pylinac.egg-info/SOURCES.txt`

 * *Files 7% similar despite different names*

```diff
@@ -8,37 +8,42 @@
 pylinac/__init__.py
 pylinac/acr.py
 pylinac/cheese.py
 pylinac/ct.py
 pylinac/dlg.py
 pylinac/field_analysis.py
 pylinac/log_analyzer.py
+pylinac/nuclear.py
 pylinac/picketfence.py
 pylinac/planar_imaging.py
 pylinac/quart.py
 pylinac/settings.py
 pylinac/starshot.py
 pylinac/version.py
 pylinac/vmat.py
 pylinac/winston_lutz.py
 pylinac/calibration/__init__.py
 pylinac/calibration/tg51.py
 pylinac/calibration/trs398.py
+pylinac/contrib/__init__.py
+pylinac/contrib/orthogonality.py
+pylinac/contrib/quasar.py
 pylinac/core/__init__.py
 pylinac/core/array_utils.py
 pylinac/core/contrast.py
 pylinac/core/decorators.py
 pylinac/core/exceptions.py
 pylinac/core/geometry.py
 pylinac/core/hill.py
 pylinac/core/image.py
 pylinac/core/io.py
 pylinac/core/mask.py
 pylinac/core/metrics.py
 pylinac/core/mtf.py
+pylinac/core/nps.py
 pylinac/core/pdf.py
 pylinac/core/profile.py
 pylinac/core/roi.py
 pylinac/core/scale.py
 pylinac/core/typing.py
 pylinac/core/utilities.py
 pylinac/core/validators.py
```

### Comparing `manteia_qa_pylinac-1.0.0/pylinac/__init__.py` & `manteia_qa_pylinac-1.1.0/pylinac/__init__.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,56 +1,56 @@
-import sys
-
-from pylinac.version import __version__
-
-# check python version
-if sys.version_info[0] < 3 or sys.version_info[1] < 7:
-    raise ValueError(
-        "Pylinac is only supported on Python 3.7+. Please update your environment."
-    )
-
-# alphabetized modules
-from .acr import ACRCT, ACRMRILarge
-from .calibration import tg51, trs398
-from .cheese import TomoCheese
-
-# import shortcuts
-# core first
-from .core import decorators, geometry, image, io, mask, profile, roi, utilities
-from .core.profile import Centering
-from .core.utilities import assign2machine, clear_data_files
-from .ct import CatPhan503, CatPhan504, CatPhan600, CatPhan604
-from .field_analysis import (
-    Device,
-    DeviceFieldAnalysis,
-    Edge,
-    FieldAnalysis,
-    Interpolation,
-    Normalization,
-    Protocol,
-)
-from .log_analyzer import Dynalog, MachineLogs, TrajectoryLog, load_log
-from .picketfence import PicketFence  # must be after log analyzer
-from .planar_imaging import (
-    PTWEPIDQC,
-    SNCFSQA,
-    SNCMV,
-    SNCMV12510,
-    DoselabMC2kV,
-    DoselabMC2MV,
-    DoselabRLf,
-    ElektaLasVegas,
-    IBAPrimusA,
-    IMTLRad,
-    IsoAlign,
-    LasVegas,
-    LeedsTOR,
-    LeedsTORBlue,
-    SNCkV,
-    StandardImagingFC2,
-    StandardImagingQC3,
-    StandardImagingQCkV,
-)
-from .quart import HypersightQuartDVT, QuartDVT
-from .starshot import Starshot
-from .vmat import DRGS, DRMLC
-from .winston_lutz import WinstonLutz, WinstonLutzMultiTargetMultiField
+import sys
+
+from pylinac.version import __version__
+
+# check python version
+if sys.version_info[0] < 3 or sys.version_info[1] < 7:
+    raise ValueError(
+        "Pylinac is only supported on Python 3.7+. Please update your environment."
+    )
+
+# alphabetized modules
+from .acr import ACRCT, ACRMRILarge
+from .calibration import tg51, trs398
+from .cheese import CIRS062M, TomoCheese
+
+# import shortcuts
+# core first
+from .core import decorators, geometry, image, io, mask, profile, roi, utilities
+from .core.profile import Centering
+from .core.utilities import assign2machine, clear_data_files
+from .ct import CatPhan503, CatPhan504, CatPhan600, CatPhan604
+from .field_analysis import (
+    Device,
+    DeviceFieldAnalysis,
+    Edge,
+    FieldAnalysis,
+    Interpolation,
+    Normalization,
+    Protocol,
+)
+from .log_analyzer import Dynalog, MachineLogs, TrajectoryLog, load_log
+from .picketfence import PicketFence  # must be after log analyzer
+from .planar_imaging import (
+    PTWEPIDQC,
+    SNCFSQA,
+    SNCMV,
+    SNCMV12510,
+    DoselabMC2kV,
+    DoselabMC2MV,
+    DoselabRLf,
+    ElektaLasVegas,
+    IBAPrimusA,
+    IMTLRad,
+    IsoAlign,
+    LasVegas,
+    LeedsTOR,
+    LeedsTORBlue,
+    SNCkV,
+    StandardImagingFC2,
+    StandardImagingQC3,
+    StandardImagingQCkV,
+)
+from .quart import HypersightQuartDVT, QuartDVT
+from .starshot import Starshot
+from .vmat import DRGS, DRMLC
+from .winston_lutz import WinstonLutz, WinstonLutz2D, WinstonLutzMultiTargetMultiField
```

### Comparing `manteia_qa_pylinac-1.0.0/pylinac/acr.py` & `manteia_qa_pylinac-1.1.0/pylinac/acr.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,1303 +1,1289 @@
-from __future__ import annotations
-
-import dataclasses
-import io
-import math
-import textwrap
-import warnings
-import webbrowser
-from dataclasses import dataclass
-from io import BytesIO
-from pathlib import Path
-
-import numpy as np
-from matplotlib import pyplot as plt
-from scipy import ndimage
-
-from .core import pdf
-from .core.array_utils import find_nearest_idx
-from .core.geometry import Line, Point
-from .core.image import DicomImage
-from .core.mtf import MTF
-from .core.profile import FWXMProfilePhysical
-from .core.roi import HighContrastDiskROI, RectangleROI
-from .core.utilities import ResultBase
-from .ct import (
-    CatPhanBase,
-    CatPhanModule,
-    Slice,
-    ThicknessROI,
-    get_regions,
-    rois_to_results,
-)
-
-# CT
-CT_UNIFORMITY_MODULE_OFFSET_MM = 70
-CT_SPATIAL_RESOLUTION_MODULE_OFFSET_MM = 100
-CT_LOW_CONTRAST_MODULE_OFFSET_MM = 30
-
-# MR
-MR_SLICE11_MODULE_OFFSET_MM = 100
-MR_GEOMETRIC_DISTORTION_MODULE_OFFSET_MM = 40
-MR_UNIFORMITY_MODULE_OFFSET_MM = 60
-
-
-class CTModule(CatPhanModule):
-    attr_name = "ct_calibration_module"
-    roi_dist_mm = 63
-    roi_radius_mm = 10
-    roi_settings = {
-        "Air": {"angle": 45, "distance": roi_dist_mm, "radius": roi_radius_mm},
-        "Poly": {"angle": 225, "distance": roi_dist_mm, "radius": roi_radius_mm},
-        "Acrylic": {"angle": 135, "distance": roi_dist_mm, "radius": roi_radius_mm},
-        "Bone": {"angle": -45, "distance": roi_dist_mm, "radius": roi_radius_mm},
-        "Water": {"angle": 180, "distance": roi_dist_mm, "radius": roi_radius_mm},
-    }
-    window_min = -200
-    window_max = 200
-
-
-@dataclass
-class CTModuleOutput:
-    """This class should not be called directly. It is returned by the ``results_data()`` method.
-    It is a dataclass under the hood and thus comes with all the dunder magic.
-
-    Use the following attributes as normal class attributes."""
-
-    offset: int
-    roi_distance_from_center_mm: int
-    roi_radius_mm: int
-    roi_settings: dict
-    rois: dict
-
-
-class UniformityModule(CatPhanModule):
-    """Class for analysis of the Uniformity slice of the CTP module. Measures 5 ROIs around the slice that
-    should all be close to the same value.
-    """
-
-    attr_name = "uniformity_module"
-    common_name = "HU Uniformity"
-    roi_dist_mm = 66
-    roi_radius_mm = 11
-    roi_settings = {
-        "Top": {"angle": -90, "distance": roi_dist_mm, "radius": roi_radius_mm},
-        "Right": {"angle": 0, "distance": roi_dist_mm, "radius": roi_radius_mm},
-        "Bottom": {"angle": 90, "distance": roi_dist_mm, "radius": roi_radius_mm},
-        "Left": {"angle": 180, "distance": roi_dist_mm, "radius": roi_radius_mm},
-        "Center": {"angle": 0, "distance": 0, "radius": roi_radius_mm},
-    }
-    window_min = -50
-    window_max = 50
-
-
-@dataclass
-class UniformityModuleOutput(CTModuleOutput):
-    """This class should not be called directly. It is returned by the ``results_data()`` method.
-    It is a dataclass under the hood and thus comes with all the dunder magic.
-
-    Use the following attributes as normal class attributes."""
-
-    center_roi_stdev: float  #:
-
-
-class SpatialResolutionModule(CatPhanModule):
-    """Class for analysis of the Uniformity slice of the CTP module. Measures 5 ROIs around the slice that
-    should all be close to the same value.
-    """
-
-    attr_name = "spatial_resolution_module"
-    common_name = "Spatial Resolution"
-    rois: dict[str, HighContrastDiskROI]
-    roi_dist_mm = 70
-    roi_radius_mm = 6
-    roi_settings = {
-        "10oclock": {
-            "angle": -135,
-            "distance": roi_dist_mm,
-            "radius": roi_radius_mm,
-            "lp/mm": 0.4,
-        },
-        "9oclock": {
-            "angle": -180,
-            "distance": roi_dist_mm,
-            "radius": roi_radius_mm,
-            "lp/mm": 0.5,
-        },
-        "7oclock": {
-            "angle": 135,
-            "distance": roi_dist_mm,
-            "radius": roi_radius_mm,
-            "lp/mm": 0.6,
-        },
-        "6oclock": {
-            "angle": 90,
-            "distance": roi_dist_mm,
-            "radius": roi_radius_mm,
-            "lp/mm": 0.7,
-        },
-        "4oclock": {
-            "angle": 45,
-            "distance": roi_dist_mm,
-            "radius": roi_radius_mm,
-            "lp/mm": 0.8,
-        },
-        "3oclock": {
-            "angle": 0,
-            "distance": roi_dist_mm,
-            "radius": roi_radius_mm,
-            "lp/mm": 0.9,
-        },
-        "2oclock": {
-            "angle": -45,
-            "distance": roi_dist_mm,
-            "radius": roi_radius_mm,
-            "lp/mm": 1.0,
-        },
-        "12oclock": {
-            "angle": -90,
-            "distance": roi_dist_mm,
-            "radius": roi_radius_mm,
-            "lp/mm": 1.2,
-        },
-    }
-
-    def _setup_rois(self) -> None:
-        for name, setting in self.roi_settings.items():
-            self.rois[name] = HighContrastDiskROI(
-                self.image,
-                setting["angle_corrected"],
-                setting["radius_pixels"],
-                setting["distance_pixels"],
-                self.phan_center,
-                contrast_threshold=1.0,  # fixed to 1 so everything passes. We aren't evaluating pass/fail here
-            )
-
-    @property
-    def mtf(self) -> MTF:
-        spacings = [roi["lp/mm"] for roi in self.roi_settings.values()]
-        return MTF.from_high_contrast_diskset(
-            spacings=spacings, diskset=list(self.rois.values())
-        )
-
-    def plot_rois(self, axis: plt.Axes) -> None:
-        """Plot the ROIs to the axis. Override to set the color"""
-        for roi, mtf in zip(self.rois.values(), self.mtf.norm_mtfs.values()):
-            roi.plot2axes(axis, edgecolor="g")
-
-
-@dataclass
-class SpatialResolutionModuleOutput(CTModuleOutput):
-    """This class should not be called directly. It is returned by the ``results_data()`` method.
-    It is a dataclass under the hood and thus comes with all the dunder magic.
-
-    Use the following attributes as normal class attributes."""
-
-    lpmm_to_rmtf: dict  #:
-
-
-class LowContrastModule(CatPhanModule):
-    """Class for analysis of the Uniformity slice of the CTP module. Measures 5 ROIs around the slice that
-    should all be close to the same value.
-    """
-
-    attr_name = "low_contrast_module"
-    common_name = "Low Contrast"
-    roi_dist_mm = 60
-    roi_radius_mm = 6
-    nominal_value = 0
-    roi_settings = {
-        "ROI": {"angle": -90, "distance": roi_dist_mm, "radius": roi_radius_mm},
-    }
-    background_roi_settings = {
-        "ROI": {"angle": -115, "distance": roi_dist_mm, "radius": roi_radius_mm},
-    }
-    window_min = 50
-    window_max = 150
-
-    def cnr(self) -> float:
-        """Given in the guidance doc as |A-B|/SD where A is the contrast ROI, B is the background, and SD is stdev of B"""
-        return (
-            abs(self.rois["ROI"].pixel_value - self.background_rois["ROI"].pixel_value)
-            / self.background_rois["ROI"].std
-        )
-
-
-@dataclass
-class LowContrastModuleOutput(CTModuleOutput):
-    """This class should not be called directly. It is returned by the ``results_data()`` method.
-    It is a dataclass under the hood and thus comes with all the dunder magic.
-
-    Use the following attributes as normal class attributes."""
-
-    cnr: float  #:
-
-
-@dataclass
-class ACRCTResult(ResultBase):
-    """This class should not be called directly. It is returned by the ``results_data()`` method.
-    It is a dataclass under the hood and thus comes with all the dunder magic.
-
-    Use the following attributes as normal class attributes."""
-
-    phantom_model: str  #:
-    phantom_roll_deg: float  #:
-    origin_slice: int  #:
-    num_images: int  #:
-    ct_module: CTModuleOutput  #:
-    uniformity_module: UniformityModuleOutput  #:
-    low_contrast_module: LowContrastModuleOutput  #:
-    spatial_resolution_module: SpatialResolutionModuleOutput  #:
-
-
-class ACRCT(CatPhanBase):
-    _model = "ACR CT 464"
-    catphan_radius_mm = 100
-    air_bubble_radius_mm = 14
-    min_num_images = 4
-    localization_radius = 70
-    ct_calibration_module = CTModule
-    low_contrast_module = LowContrastModule
-    spatial_resolution_module = SpatialResolutionModule
-    uniformity_module = UniformityModule
-    clear_borders = False
-
-    def _detected_modules(self) -> list[CatPhanModule]:
-        return [
-            self.ct_calibration_module,
-            self.low_contrast_module,
-            self.spatial_resolution_module,
-            self.uniformity_module,
-        ]
-
-    def plot_analyzed_subimage(self, *args, **kwargs):
-        raise NotImplementedError("Use `plot_images`")
-
-    def save_analyzed_subimage(self, *args, **kwargs):
-        raise NotImplementedError("Use `save_images`")
-
-    def analyze(self) -> None:
-        """Analyze the ACR CT phantom"""
-        self.localize()
-        self.ct_calibration_module = self.ct_calibration_module(
-            self, offset=0, clear_borders=self.clear_borders
-        )
-        self.uniformity_module = self.uniformity_module(
-            self,
-            offset=CT_UNIFORMITY_MODULE_OFFSET_MM,
-            clear_borders=self.clear_borders,
-        )
-        self.spatial_resolution_module = self.spatial_resolution_module(
-            self,
-            offset=CT_SPATIAL_RESOLUTION_MODULE_OFFSET_MM,
-            clear_borders=self.clear_borders,
-        )
-        self.low_contrast_module = self.low_contrast_module(
-            self,
-            offset=CT_LOW_CONTRAST_MODULE_OFFSET_MM,
-            clear_borders=self.clear_borders,
-        )
-
-    def plot_analyzed_image(self, show: bool = True, **plt_kwargs) -> plt.Figure:
-        """Plot the analyzed image
-
-        Parameters
-        ----------
-        show
-            Whether to show the image.
-        plt_kwargs
-            Keywords to pass to matplotlib for figure customization.
-        """
-        # set up grid and axes
-        fig = plt.figure(**plt_kwargs)
-        grid_size = (2, 3)
-        hu_ax = plt.subplot2grid(grid_size, (0, 0))
-        self.ct_calibration_module.plot(hu_ax)
-        unif_ax = plt.subplot2grid(grid_size, (0, 1))
-        self.uniformity_module.plot(unif_ax)
-        sr_ax = plt.subplot2grid(grid_size, (0, 2))
-        self.spatial_resolution_module.plot(sr_ax)
-        locon_ax = plt.subplot2grid(grid_size, (1, 0))
-        self.low_contrast_module.plot(locon_ax)
-        spatial_res_graph = plt.subplot2grid(grid_size, (1, 2))
-        self.spatial_resolution_module.mtf.plot(spatial_res_graph)
-        side_ax = plt.subplot2grid(grid_size, (1, 1))
-        self.plot_side_view(side_ax)
-
-        # finish up
-        plt.tight_layout()
-        if show:
-            plt.show()
-        return fig
-
-    def save_analyzed_image(self, filename: str | Path | BytesIO, **plt_kwargs) -> None:
-        """Save the analyzed image to disk or stream
-
-        Parameters
-        ----------
-        filename
-            Where to save the image to
-        plt_kwargs
-            Keywords to pass to matplotlib for figure customization.
-        """
-        fig = self.plot_analyzed_image(show=False, **plt_kwargs)
-        fig.savefig(filename)
-
-    def plot_images(self, show: bool = True, **plt_kwargs) -> dict[str, plt.Figure]:
-        """Plot all the individual images separately
-
-        Parameters
-        ----------
-        show
-            Whether to show the images.
-        plt_kwargs
-            Keywords to pass to matplotlib for figure customization.
-        """
-        figs = {}
-        # plot the images
-        modules = {
-            "hu": self.ct_calibration_module,
-            "uniformity": self.uniformity_module,
-            "spatial resolution": self.spatial_resolution_module,
-            "low contrast": self.low_contrast_module,
-        }
-        for key, module in modules.items():
-            fig, ax = plt.subplots(**plt_kwargs)
-            module.plot(ax)
-            figs[key] = fig
-        # plot the one-off MTF image
-        fig, ax = plt.subplots(**plt_kwargs)
-        figs["mtf"] = fig
-        self.spatial_resolution_module.mtf.plot(ax)
-        # plot the side view
-        fig, ax = plt.subplots(**plt_kwargs)
-        figs["side"] = fig
-        self.plot_side_view(ax)
-
-        plt.tight_layout()
-
-        if show:
-            plt.show()
-        return figs
-
-    def save_images(
-        self,
-        directory: Path | str | None = None,
-        to_stream: bool = False,
-        **plt_kwargs,
-    ) -> list[Path | BytesIO]:
-        """Save separate images to disk or stream.
-
-        Parameters
-        ----------
-        directory
-            The directory to write the images to. If None, will use current working directory
-        to_stream
-            Whether to write to stream or disk. If True, will return streams. Directory is ignored in that scenario.
-        plt_kwargs
-            Keywords to pass to matplotlib for figure customization.
-        """
-        figs = self.plot_images(show=False, **plt_kwargs)
-        paths = []
-        for name, fig in figs.items():
-            if to_stream:
-                path = io.BytesIO()
-            else:
-                destination = Path(directory) or Path.cwd()
-                path = (destination / name).with_suffix(".png").absolute()
-            fig.savefig(path)
-            paths.append(path)
-        return paths
-
-    def find_phantom_roll(self, func=lambda roi: roi.bbox_area) -> float:
-        """Determine the "roll" of the phantom.
-
-        Only difference of base method is that we sort the ROIs by size,
-        not by being in the center since the two we're looking for are both right-sided.
-        """
-        return super().find_phantom_roll(func)
-
-    def results(self) -> str:
-        """Return the results of the analysis as a string. Use with print()."""
-        string = (
-            f"\n - ACR CT 464 QA Test - \n"
-            f"HU ROIs: {self.ct_calibration_module.roi_vals_as_str}\n"
-            f"Contrast to Noise Ratio: {self.low_contrast_module.cnr():2.2f}\n"
-            f"Uniformity ROIs: {self.uniformity_module.roi_vals_as_str}\n"
-            f'Uniformity Center ROI standard deviation: {self.uniformity_module.rois["Center"].std:2.2f}\n'
-            f"MTF 50% (lp/mm): {self.spatial_resolution_module.mtf.relative_resolution(50):2.2f}\n"
-        )
-        return string
-
-    def results_data(self, as_dict=False) -> ACRCTResult | dict:
-        data = ACRCTResult(
-            phantom_model="ACR CT 464",
-            phantom_roll_deg=self.catphan_roll,
-            origin_slice=self.origin_slice,
-            num_images=self.num_images,
-            ct_module=CTModuleOutput(
-                offset=0,
-                roi_distance_from_center_mm=self.ct_calibration_module.roi_dist_mm,
-                roi_radius_mm=self.ct_calibration_module.roi_radius_mm,
-                roi_settings=self.ct_calibration_module.roi_settings,
-                rois={
-                    name: roi.pixel_value
-                    for name, roi in self.ct_calibration_module.rois.items()
-                },
-            ),
-            uniformity_module=UniformityModuleOutput(
-                offset=CT_UNIFORMITY_MODULE_OFFSET_MM,
-                roi_distance_from_center_mm=self.uniformity_module.roi_dist_mm,
-                roi_radius_mm=self.uniformity_module.roi_radius_mm,
-                roi_settings=self.uniformity_module.roi_settings,
-                rois={
-                    name: roi.pixel_value
-                    for name, roi in self.uniformity_module.rois.items()
-                },
-                center_roi_stdev=self.uniformity_module.rois["Center"].std,
-            ),
-            spatial_resolution_module=SpatialResolutionModuleOutput(
-                offset=CT_SPATIAL_RESOLUTION_MODULE_OFFSET_MM,
-                roi_distance_from_center_mm=self.spatial_resolution_module.roi_dist_mm,
-                roi_radius_mm=self.spatial_resolution_module.roi_radius_mm,
-                roi_settings=self.spatial_resolution_module.roi_settings,
-                rois={
-                    name: roi.pixel_value
-                    for name, roi in self.spatial_resolution_module.rois.items()
-                },
-                lpmm_to_rmtf=self.spatial_resolution_module.mtf.norm_mtfs,
-            ),
-            low_contrast_module=LowContrastModuleOutput(
-                offset=CT_LOW_CONTRAST_MODULE_OFFSET_MM,
-                roi_distance_from_center_mm=self.low_contrast_module.roi_dist_mm,
-                roi_radius_mm=self.low_contrast_module.roi_radius_mm,
-                roi_settings=self.low_contrast_module.roi_settings,
-                rois={
-                    name: roi.pixel_value
-                    for name, roi in self.low_contrast_module.rois.items()
-                },
-                cnr=self.low_contrast_module.cnr(),
-            ),
-        )
-        if as_dict:
-            return dataclasses.asdict(data)
-        return data
-
-    def publish_pdf(
-        self,
-        filename: str | Path,
-        notes: str | None = None,
-        open_file: bool = False,
-        metadata: dict | None = None,
-        logo: Path | str | None = None,
-    ) -> None:
-        """Publish (print) a PDF containing the analysis and quantitative results.
-
-        Parameters
-        ----------
-        filename : (str, file-like object}
-            The file to write the results to.
-        notes : str, list of strings
-            Text; if str, prints single line.
-            If list of strings, each list item is printed on its own line.
-        open_file : bool
-            Whether to open the file using the default program after creation.
-        metadata : dict
-            Extra data to be passed and shown in the PDF. The key and value will be shown with a colon.
-            E.g. passing {'Author': 'James', 'Unit': 'TrueBeam'} would result in text in the PDF like:
-            --------------
-            Author: James
-            Unit: TrueBeam
-            --------------
-        logo: Path, str
-            A custom logo to use in the PDF report. If nothing is passed, the default pylinac logo is used.
-        """
-        analysis_title = f"{self._model} Analysis"
-        texts = [
-            " - ACR CT 464 Results - ",
-            f"HU Linearity ROIs: {self.ct_calibration_module.roi_vals_as_str}",
-            f"Low contrast visibility: {self.low_contrast_module.cnr():2.2f}",
-            f"Uniformity ROIs: {self.uniformity_module.roi_vals_as_str}",
-        ]
-        analysis_images = self.save_images(to_stream=True)
-
-        canvas = pdf.PylinacCanvas(
-            filename, page_title=analysis_title, metadata=metadata, logo=logo
-        )
-        if notes is not None:
-            canvas.add_text(text="Notes:", location=(1, 4.5), font_size=14)
-            canvas.add_text(text=notes, location=(1, 4))
-
-        for idx, text in enumerate(texts):
-            canvas.add_text(text=text, location=(1.5, 23 - idx * 0.5))
-        for page, img in enumerate(analysis_images):
-            canvas.add_new_page()
-            canvas.add_image(img, location=(1, 5), dimensions=(18, 18))
-        canvas.finish()
-
-        if open_file:
-            webbrowser.open(filename)
-
-    def _module_offsets(self) -> list[float]:
-        absolute_origin_position = self.dicom_stack[self.origin_slice].z_position
-        relative_offsets_mm = [
-            0,
-            CT_UNIFORMITY_MODULE_OFFSET_MM,
-            CT_LOW_CONTRAST_MODULE_OFFSET_MM,
-            CT_SPATIAL_RESOLUTION_MODULE_OFFSET_MM,
-        ]
-        return [
-            absolute_origin_position + offset_mm for offset_mm in relative_offsets_mm
-        ]
-
-
-class MRSlice11PositionModule(CatPhanModule):
-    common_name = "Slice Position, Slice 11"
-    roi_settings = {
-        "Left": {"width": 2, "height": 25, "distance": 65, "angle": 2.5},
-        "Right": {"width": 2, "height": 25, "distance": 65, "angle": -2.5},
-    }
-    rois: dict = {}
-
-    def _setup_rois(self) -> None:
-        for name, setting in self.roi_settings.items():
-            # angle is +90 because pointing right is 0, and these rois move downward, not rightward
-            self.rois[name] = RectangleROI(
-                self.image,
-                setting["width_pixels"],
-                setting["height_pixels"],
-                self.catphan_roll - 90 + setting["angle"],
-                setting["distance_pixels"],
-                self.phan_center,
-            )
-
-    @property
-    def bar_difference_mm(self) -> float:
-        """The difference in height between the two angled bars"""
-        idxs = []
-        for roi in (self.rois["Right"], self.rois["Left"]):
-            prof = roi.pixel_array.max(axis=np.argmin(roi.pixel_array.shape))
-            mid_height = (prof.max() - prof.min()) / 2 + prof.min()
-            idx = find_nearest_idx(prof, mid_height)
-            idxs.append(idx)
-        return (idxs[0] - idxs[1]) * self.mm_per_pixel
-
-    @property
-    def slice_shift_mm(self) -> float:
-        """The effective shift in phantom position in the S/I direction. Because bars are at 45 degrees, the shift is half the bar difference"""
-        return self.bar_difference_mm / 2
-
-    def plot_rois(self, axis: plt.Axes) -> None:
-        """Plot the ROIs to the axis.
-
-        We overload because simple rectangle ROIs don't have a pass/fail color.
-        """
-        for roi in self.rois.values():
-            roi.plot2axes(axis, edgecolor="blue")
-
-
-@dataclass
-class MRSlice11ModuleOutput:
-    """This class should not be called directly. It is returned by the ``results_data()`` method.
-    It is a dataclass under the hood and thus comes with all the dunder magic.
-
-    Use the following attributes as normal class attributes."""
-
-    offset: int  #:
-    roi_settings: dict  #:
-    rois: dict  #:
-    bar_difference_mm: float  #:
-    slice_shift_mm: float  #:
-
-
-class MRSlice1Module(CatPhanModule):
-    common_name = "Slice 1 (Thickness, Offset, Resolution)"
-    slice_lines: dict[str, Line]
-    thickness_rois: dict[str, ThicknessROI] = {}
-    thickness_roi_settings = {
-        "Top": {"width": 100, "height": 3, "distance": -3},
-        "Bottom": {"width": 100, "height": 3, "distance": 2.5},
-    }
-    roi_settings = {
-        "Row Reference": {"radius": 9, "distance": 58, "angle": 135, "lp/mm": 0},
-        "Col Reference": {"radius": 9, "distance": 58, "angle": 135, "lp/mm": 0},
-        "Row 1.1": {"radius": 3, "distance": 40, "angle": 116, "lp/mm": 1 / 1.1},
-        "Col 1.1": {"radius": 3, "distance": 44, "angle": 104, "lp/mm": 1 / 1.1},
-        "Row 1.0": {"radius": 3, "distance": 36, "angle": 81, "lp/mm": 1.0},
-        "Col 1.0": {"radius": 3, "distance": 44, "angle": 74, "lp/mm": 1.0},
-        "Row 0.9": {"radius": 2, "distance": 46, "angle": 52, "lp/mm": 1 / 0.9},
-        "Col 0.9": {"radius": 2, "distance": 55, "angle": 51, "lp/mm": 1 / 0.9},
-    }
-    position_roi_settings = {
-        "Left": {"width": 2, "height": 25, "distance": 65, "angle": 2.5},
-        "Right": {"width": 2, "height": 25, "distance": 65, "angle": -2.5},
-    }
-    position_rois: dict = {}
-    rois: dict[str, HighContrastDiskROI]
-    spacings = [0, 1 / 1.1, 1, 1 / 0.9]
-
-    def _setup_rois(self) -> None:
-        # thickness
-        for name, setting in self.thickness_roi_settings.items():
-            # angle is +90 because pointing right is 0, and these rois move downward, not rightward
-            self.thickness_rois[name] = ThicknessROI(
-                self.image,
-                setting["width_pixels"],
-                setting["height_pixels"],
-                self.catphan_roll + 90,
-                setting["distance_pixels"],
-                self.phan_center,
-            )
-        # spatial res
-        for name, setting in self.roi_settings.items():
-            self.rois[name] = HighContrastDiskROI(
-                self.image,
-                setting["angle_corrected"],
-                setting["radius_pixels"],
-                setting["distance_pixels"],
-                self.phan_center,
-                contrast_threshold=1.0,  # fixed to 1 so everything passes. We aren't evaluating pass/fail here
-            )
-        # slice position
-        for name, setting in self.position_roi_settings.items():
-            # angle is +90 because pointing right is 0, and these rois move downward, not rightward
-            self.position_rois[name] = ThicknessROI(
-                self.image,
-                setting["width_pixels"],
-                setting["height_pixels"],
-                self.catphan_roll - 90 + setting["angle"],
-                setting["distance_pixels"],
-                self.phan_center,
-            )
-
-    def plot_rois(self, axis: plt.Axes) -> None:
-        for roi in self.position_rois.values():
-            roi.plot2axes(axis, edgecolor="blue")
-        for roi in self.thickness_rois.values():
-            roi.plot2axes(axis, edgecolor="blue")
-        for roi, mtf in zip(self.rois.values(), self.rois.values()):
-            roi.plot2axes(axis, edgecolor="g")
-
-    @property
-    def bar_difference_mm(self) -> float:
-        """The difference in height between the two angled bars"""
-        left_array = self.position_rois["Left"].long_profile.values
-        left_mid_height = (left_array.max() - left_array.min()) / 2 + left_array.min()
-        left_idx = find_nearest_idx(left_array, left_mid_height)
-        right_array = self.position_rois["Right"].long_profile.values
-        right_mid_height = (
-            right_array.max() - right_array.min()
-        ) / 2 + right_array.min()
-        right_idx = find_nearest_idx(right_array, right_mid_height)
-        return (right_idx - left_idx) * self.mm_per_pixel
-
-    @property
-    def slice_shift_mm(self) -> float:
-        """The effective shift in phantom position in the S/I direction. Because bars are at 45 degrees, the shift is half the bar difference"""
-        return self.bar_difference_mm / 2
-
-    @property
-    def measured_slice_thickness_mm(self) -> float:
-        """The slice thickness as determined by the two angled ROIs in the center of Slice 1"""
-        top = self.thickness_rois["Top"].wire_fwhm * self.mm_per_pixel
-        bottom = self.thickness_rois["Bottom"].wire_fwhm * self.mm_per_pixel
-        return 0.2 * (top * bottom) / (top + bottom)
-
-    @property
-    def row_mtf(self) -> MTF:
-        """The MTF of the spatial resolution module looking at the row-wise ROIs"""
-        return MTF.from_high_contrast_diskset(
-            spacings=self.spacings,
-            diskset=list(roi for name, roi in self.rois.items() if "Row" in name),
-        )
-
-    @property
-    def col_mtf(self) -> MTF:
-        """The MTF of the spatial resolution module looking at the column-wise ROIs"""
-        return MTF.from_high_contrast_diskset(
-            spacings=self.spacings,
-            diskset=list(roi for name, roi in self.rois.items() if "Col" in name),
-        )
-
-
-@dataclass
-class MRSlice1ModuleOutput:
-    """This class should not be called directly. It is returned by the ``results_data()`` method.
-    It is a dataclass under the hood and thus comes with all the dunder magic.
-
-    Use the following attributes as normal class attributes."""
-
-    offset: int  #:
-    roi_settings: dict  #:
-    rois: dict  #:
-    bar_difference_mm: float  #:
-    slice_shift_mm: float  #:
-    measured_slice_thickness_mm: float  #:
-    row_mtf_50: float  #:
-    col_mtf_50: float  #:
-
-
-class MRUniformityModule(CatPhanModule):
-    """Class for analysis of the Uniformity slice of the CTP module. Measures 5 ROIs around the slice that
-    should all be close to the same value.
-    """
-
-    common_name = "Signal Uniformity"
-    roi_settings = {
-        "Center": {
-            "angle": 90,
-            "distance": 5,
-            "radius": 80,
-        },  # 80 radius ~= 200cm2, per the manual
-    }
-    ghost_roi_settings = {
-        # size of ~900mm2 per the manual
-        "Top": {"angle": -90, "distance": 110, "width": 60, "height": 15},
-        "Bottom": {"angle": 90, "distance": 110, "width": 60, "height": 15},
-        "Left": {"angle": 180, "distance": 110, "width": 15, "height": 60},
-        "Right": {"angle": 0, "distance": 110, "width": 15, "height": 60},
-    }
-    ghost_rois: dict = {}
-
-    def __init__(self, catphan, offset):
-        self.tesla = float(catphan.dicom_stack.metadata.MagneticFieldStrength)
-        super().__init__(catphan, tolerance=None, offset=offset)
-
-    def _setup_rois(self) -> None:
-        super()._setup_rois()
-        for name, roi in self.ghost_roi_settings.items():
-            self.ghost_rois[name] = RectangleROI(
-                self.image,
-                roi["width_pixels"],
-                roi["height_pixels"],
-                roi["angle"] + self.catphan_roll,
-                roi["distance_pixels"],
-                self.phan_center,
-            )
-
-    def plot_rois(self, axis: plt.Axes) -> None:
-        super().plot_rois(axis)
-        for roi in self.ghost_rois.values():
-            roi.plot2axes(axis, edgecolor="yellow")
-
-    @property
-    def percent_image_uniformity(self) -> float:
-        """PIU value calculated via section 5.3 of the manual"""
-        piu_high = np.percentile(self.rois["Center"].pixel_values, 99)
-        piu_low = np.percentile(self.rois["Center"].pixel_values, 1)
-        return 100 * (1 - ((piu_high - piu_low) / (piu_high + piu_low)))
-
-    @property
-    def piu_passed(self) -> bool:
-        """Section 5.4"""
-        if self.tesla < 3:
-            return self.percent_image_uniformity > 85
-        else:
-            return self.percent_image_uniformity > 80
-
-    @property
-    def ghosting_ratio(self) -> float:
-        """Ghosting ratio of section 6.3 of the manual"""
-        top = self.ghost_rois["Top"].pixel_value
-        bottom = self.ghost_rois["Bottom"].pixel_value
-        left = self.ghost_rois["Left"].pixel_value
-        right = self.ghost_rois["Right"].pixel_value
-        return abs(
-            ((top + bottom) - (left + right)) / (2 * self.rois["Center"].pixel_value)
-        )
-
-    @property
-    def psg(self) -> float:
-        """Percent Signal Ghosting"""
-        return self.ghosting_ratio * 100
-
-    @property
-    def psg_passed(self) -> bool:
-        """Whether the PSG is within tolerance"""
-        return self.psg < 3.0
-
-
-@dataclass
-class MRUniformityModuleOutput:
-    """This class should not be called directly. It is returned by the ``results_data()`` method.
-    It is a dataclass under the hood and thus comes with all the dunder magic.
-
-    Use the following attributes as normal class attributes."""
-
-    offset: int  #:
-    roi_settings: dict  #:
-    rois: dict  #:
-    ghost_roi_settings: dict  #:
-    ghost_rois: dict  #:
-    psg: float  #:
-    ghosting_ratio: float  #:
-    piu_passed: bool  #:
-    piu: float  #:
-
-
-class GeometricDistortionModule(CatPhanModule):
-    """Class for analysis of the Uniformity slice of the CTP module. Measures 5 ROIs around the slice that
-    should all be close to the same value.
-    """
-
-    common_name = "Geometric Distortion"
-    profiles: dict
-
-    def _setup_rois(self) -> None:
-        self.profiles = {}
-        bin_image = self.image.as_binary(threshold=np.percentile(self.image, 60))
-        bin_image = ndimage.binary_fill_holes(bin_image).astype(float)
-        # calculate horizontal
-        data = bin_image[int(self.phan_center.y), :]
-        prof = FWXMProfilePhysical(values=data, dpmm=1 / self.mm_per_pixel)
-        line = Line(
-            Point(prof.field_edge_idx(side="left"), self.phan_center.y),
-            Point(prof.field_edge_idx(side="right"), self.phan_center.y),
-        )
-
-        self.profiles["horizontal"] = {
-            "width (mm)": prof.field_width_mm,
-            "line": line,
-        }
-        # calculate vertical
-        data = bin_image[:, int(self.phan_center.x)]
-        prof = FWXMProfilePhysical(values=data, dpmm=1 / self.mm_per_pixel)
-        line = Line(
-            Point(self.phan_center.x, prof.field_edge_idx(side="left")),
-            Point(self.phan_center.x, prof.field_edge_idx(side="right")),
-        )
-        self.profiles["vertical"] = {
-            "width (mm)": prof.field_width_mm,
-            "line": line,
-        }
-        # calculate negative diagonal
-        # calculate slope equation intercept
-        # b = y - (+1)x
-        b = self.phan_center.y - self.phan_center.x
-        xs = np.arange(0, self.image.shape[1])
-        ys = xs + b
-        coords = ndimage.map_coordinates(bin_image, [ys, xs], order=1, mode="mirror")
-        # pixels are now diagonal and thus spacing between pixels is now the hypotenuse
-        prof = FWXMProfilePhysical(
-            values=coords, dpmm=1 / (self.mm_per_pixel * math.sqrt(2))
-        )
-        line = Line(
-            Point(
-                xs[int(round(prof.field_edge_idx(side="left")))],
-                ys[int(round(prof.field_edge_idx(side="left")))],
-            ),
-            Point(
-                xs[int(round(prof.field_edge_idx(side="right")))],
-                ys[int(round(prof.field_edge_idx(side="right")))],
-            ),
-        )
-        self.profiles["negative diagonal"] = {
-            "width (mm)": prof.field_width_mm,
-            "line": line,
-        }
-        # calculate positive diagonal
-        # calculate slope equation intercept
-        # b = y - (-1)x
-        b = self.phan_center.y + self.phan_center.x
-        ys = -xs + b
-        coords = ndimage.map_coordinates(bin_image, [ys, xs], order=1, mode="mirror")
-        prof = FWXMProfilePhysical(
-            values=coords, dpmm=1 / (self.mm_per_pixel * math.sqrt(2))
-        )
-        line = Line(
-            Point(
-                xs[int(round(prof.field_edge_idx(side="left")))],
-                ys[int(round(prof.field_edge_idx(side="left")))],
-            ),
-            Point(
-                xs[int(round(prof.field_edge_idx(side="right")))],
-                ys[int(round(prof.field_edge_idx(side="right")))],
-            ),
-        )
-        self.profiles["positive diagonal"] = {
-            "width (mm)": prof.field_width_mm,
-            "line": line,
-        }
-
-    def plot_rois(self, axis: plt.Axes):
-        for name, profile_data in self.profiles.items():
-            profile_data["line"].plot2axes(axis, width=2, color="blue")
-
-    def distances(self) -> dict:
-        """The measurements of the phantom size for all 4 lines in mm"""
-        return {name: f"{p['width (mm)']:2.2f}mm" for name, p in self.profiles.items()}
-
-
-@dataclass
-class MRGeometricDistortionModuleOutput:
-    """This class should not be called directly. It is returned by the ``results_data()`` method.
-    It is a dataclass under the hood and thus comes with all the dunder magic.
-
-    Use the following attributes as normal class attributes."""
-
-    offset: int  #:
-    profiles: dict  #:
-    distances: dict  #:
-
-
-@dataclass
-class ACRMRIResult(ResultBase):
-    """This class should not be called directly. It is returned by the ``results_data()`` method.
-    It is a dataclass under the hood and thus comes with all the dunder magic.
-
-    Use the following attributes as normal class attributes."""
-
-    phantom_model: str  #:
-    phantom_roll_deg: float  #:
-    origin_slice: int  #:
-    num_images: int  #:
-    slice1: MRSlice1ModuleOutput  #:
-    slice11: MRSlice11ModuleOutput  #:
-    uniformity_module: MRUniformityModuleOutput  #:
-    geometric_distortion_module: MRGeometricDistortionModuleOutput  #:
-
-
-class ACRMRILarge(CatPhanBase):
-    _model = "ACR MRI Large"
-    catphan_radius_mm = 100
-    min_num_images = 4
-    air_bubble_radius_mm = 20
-    slice1 = MRSlice1Module
-    geometric_distortion = GeometricDistortionModule
-    uniformity_module = MRUniformityModule
-    slice11 = MRSlice11PositionModule
-
-    def plot_analyzed_subimage(self, *args, **kwargs):
-        raise NotImplementedError("Use `plot_images`")
-
-    def save_analyzed_subimage(self, *args, **kwargs):
-        raise NotImplementedError("Use `save_images`")
-
-    def localize(self) -> None:
-        self._phantom_center_func = self.find_phantom_axis()
-        self.catphan_roll = self.find_phantom_roll()
-        # now that we have the origin slice, ensure we have scanned all linked modules
-        if not self._ensure_physical_scan_extent():
-            raise ValueError(
-                "The physical scan extent does not cover the extent of module configuration. "
-                "This means not all modules were included in the scan. Rescan the phantom to include all "
-                "relevant modules, or change the offset values."
-            )
-
-    def _module_offsets(self) -> list[float]:
-        absolute_origin_position = self.dicom_stack[self.origin_slice].z_position
-        relative_offsets_mm = [
-            0,
-            MR_GEOMETRIC_DISTORTION_MODULE_OFFSET_MM,
-            MR_UNIFORMITY_MODULE_OFFSET_MM,
-            MR_SLICE11_MODULE_OFFSET_MM,
-        ]
-        return [
-            absolute_origin_position + offset_mm for offset_mm in relative_offsets_mm
-        ]
-
-    def find_phantom_roll(self) -> float:
-        """Determine the "roll" of the phantom. This algorithm uses the circular left-upper hole on slice 1 as the reference
-
-        Returns
-        -------
-        float : the angle of the phantom in **degrees**.
-        """
-        # get edges and make ROIs from it
-        slice = Slice(self, self.origin_slice)
-        larr, regions, _ = get_regions(slice)
-        try:
-            # find appropriate ROIs and grab the two most centrally positioned ones
-            circle_bubbles = [
-                r
-                for r in regions
-                if (self._is_right_area(r) and self._is_right_eccentricity(r))
-            ]
-            exact_size = np.pi * ((self.air_bubble_radius_mm / self.mm_per_pixel) ** 2)
-            most_similar_bubble = sorted(
-                circle_bubbles, key=lambda r: abs(r.filled_area - exact_size)
-            )[0]
-            y_dist = most_similar_bubble.centroid[0] - slice.phan_center.y
-            x_dist = most_similar_bubble.centroid[1] - slice.phan_center.x
-            phan_roll = np.arctan2(y_dist, x_dist)
-            corrected_roll = (
-                np.rad2deg(phan_roll) + 135
-            )  # bubble is at top-left. perfect placement is -135
-            return corrected_roll
-        except:
-            raise RuntimeError(
-                "Could not determine the roll of the phantom. Ensure the 20mm top-left circle is visible on Slice 1"
-            )
-
-    def analyze(self, echo_number: int | None = None) -> None:
-        """Analyze the ACR CT phantom
-
-        Parameters
-        ----------
-        echo_number:
-            The echo to analyze. If not passed, uses the minimum echo number found.
-        """
-        self.dicom_stack.images = self._select_echo_images(echo_number)
-        self.localize()
-        self.slice1 = self.slice1(self, offset=0)
-        self.geometric_distortion = self.geometric_distortion(
-            self, offset=MR_GEOMETRIC_DISTORTION_MODULE_OFFSET_MM
-        )
-        self.uniformity_module = self.uniformity_module(
-            self, offset=MR_UNIFORMITY_MODULE_OFFSET_MM
-        )
-        self.slice11 = self.slice11(self, offset=MR_SLICE11_MODULE_OFFSET_MM)
-
-    def _select_echo_images(self, echo_number: int | None) -> list[DicomImage]:
-        """Get the image indices that match the given echo number"""
-        # we check for multiple echos. We only pick the first echo found.
-        # this is probably not the best logic but we somehow have to pick
-        # Echo Numbers is an int; https://dicom.innolitics.com/ciods/mr-image/mr-image/00180086
-
-        # in case EchoNumbers isn't there, return all
-        try:
-            all_echos = {int(i.metadata.EchoNumbers) for i in self.dicom_stack.images}
-        except AttributeError:
-            return self.dicom_stack.images
-        if echo_number is None:
-            echo_number = min(all_echos)
-            if len(all_echos) > 1:
-                warnings.warn(
-                    f"Multiple echoes found ({all_echos}) and no echo number was passed. Using echo # {echo_number}"
-                )
-        if echo_number not in all_echos:
-            raise ValueError(
-                f"Echo number {echo_number} was passed but not found in the dataset. Found echo numbers: {all_echos}. Remove the echo_number parameter or pick a valid echo number."
-            )
-        return [
-            image
-            for image in self.dicom_stack.images
-            if int(image.metadata.EchoNumbers) == echo_number
-        ]
-
-    def plot_analyzed_image(self, show: bool = True, **plt_kwargs) -> plt.Figure:
-        """Plot the analyzed image
-
-        Parameters
-        ----------
-        show
-            Whether to show the image.
-        plt_kwargs
-            Keywords to pass to matplotlib for figure customization.
-        """
-        # set up grid and axes
-        fig = plt.figure(**plt_kwargs)
-        grid_size = (2, 3)
-        slice1_ax = plt.subplot2grid(grid_size, (0, 0))
-        self.slice1.plot(slice1_ax)
-        geom_ax = plt.subplot2grid(grid_size, (0, 1))
-        self.geometric_distortion.plot(geom_ax)
-        unif_ax = plt.subplot2grid(grid_size, (0, 2))
-        self.uniformity_module.plot(unif_ax)
-        position_ax = plt.subplot2grid(grid_size, (1, 0))
-        self.slice11.plot(position_ax)
-
-        side_view_ax = plt.subplot2grid(grid_size, (1, 1))
-        self.plot_side_view(side_view_ax)
-        spatial_res_graph = plt.subplot2grid(grid_size, (1, 2))
-        self.slice1.row_mtf.plot(spatial_res_graph, label="Row-wise rMTF")
-        self.slice1.col_mtf.plot(spatial_res_graph, label="Column-wise rMTF")
-        spatial_res_graph.legend()
-
-        # finish up
-        plt.tight_layout()
-        if show:
-            plt.show()
-        return fig
-
-    def plot_images(self, show: bool = True, **plt_kwargs) -> dict[str, plt.Figure]:
-        """Plot all the individual images separately
-
-        Parameters
-        ----------
-        show
-            Whether to show the images.
-        plt_kwargs
-            Keywords to pass to matplotlib for figure customization.
-        """
-        figs = {}
-        # plot the images
-        modules = {
-            "geometric": self.geometric_distortion,
-            "slice 1": self.slice1,
-            "signal uniformity": self.uniformity_module,
-            "slice 11": self.slice11,
-        }
-        for key, module in modules.items():
-            fig, ax = plt.subplots(**plt_kwargs)
-            module.plot(ax)
-            figs[key] = fig
-        # plot rMTF
-        fig, ax = plt.subplots(**plt_kwargs)
-        self.slice1.row_mtf.plot(ax, label="Row-wise rMTF")
-        self.slice1.col_mtf.plot(ax, label="Column-wise rMTF")
-        ax.legend()
-        figs["rMTF"] = fig
-        # plot the side view
-        fig, ax = plt.subplots(**plt_kwargs)
-        figs["side"] = fig
-        self.plot_side_view(ax)
-
-        if show:
-            plt.show()
-        return figs
-
-    def _detected_modules(self) -> list[CatPhanModule]:
-        return [
-            self.slice1,
-            self.slice11,
-            self.uniformity_module,
-            self.geometric_distortion,
-        ]
-
-    def save_images(
-        self,
-        directory: Path | str | None = None,
-        to_stream: bool = False,
-        **plt_kwargs,
-    ) -> list[Path | BytesIO]:
-        """Save separate images to disk or stream.
-
-        Parameters
-        ----------
-        directory
-            The directory to write the images to. If None, will use current working directory
-        to_stream
-            Whether to write to stream or disk. If True, will return streams. Directory is ignored in that scenario.
-        plt_kwargs
-            Keywords to pass to matplotlib for figure customization.
-        """
-        figs = self.plot_images(show=False, **plt_kwargs)
-        paths = []
-        for name, fig in figs.items():
-            if to_stream:
-                path = io.BytesIO()
-            else:
-                destination = Path(directory) or Path.cwd()
-                path = (destination / name).with_suffix(".png").absolute()
-            fig.savefig(path)
-            paths.append(path)
-        return paths
-
-    def publish_pdf(
-        self,
-        filename: str | Path,
-        notes: str | None = None,
-        open_file: bool = False,
-        metadata: dict | None = None,
-        logo: Path | str | None = None,
-    ) -> None:
-        """Publish (print) a PDF containing the analysis and quantitative results.
-
-        Parameters
-        ----------
-        filename : (str, file-like object}
-            The file to write the results to.
-        notes : str, list of strings
-            Text; if str, prints single line.
-            If list of strings, each list item is printed on its own line.
-        open_file : bool
-            Whether to open the file using the default program after creation.
-        metadata : dict
-            Extra data to be passed and shown in the PDF. The key and value will be shown with a colon.
-            E.g. passing {'Author': 'James', 'Unit': 'TrueBeam'} would result in text in the PDF like:
-            --------------
-            Author: James
-            Unit: TrueBeam
-            --------------
-        logo: Path, str
-            A custom logo to use in the PDF report. If nothing is passed, the default pylinac logo is used.
-        """
-        analysis_title = f"{self._model} Analysis"
-        analysis_images = self.save_images(to_stream=True)
-
-        canvas = pdf.PylinacCanvas(
-            filename, page_title=analysis_title, metadata=metadata
-        )
-        if notes is not None:
-            canvas.add_text(text="Notes:", location=(1, 4.5), font_size=14)
-            canvas.add_text(text=notes, location=(1, 4))
-
-        shortened_texts = [
-            textwrap.wrap(r, width=110) for r in self.results(as_str=False)
-        ]
-        idx = 0
-        for items in enumerate(shortened_texts):
-            for text in items:
-                canvas.add_text(text=text, location=(1.5, 25 - idx * 0.5))
-                idx += 1
-        for page, img in enumerate(analysis_images):
-            canvas.add_new_page()
-            canvas.add_image(img, location=(1, 5), dimensions=(18, 18))
-        canvas.finish()
-
-        if open_file:
-            webbrowser.open(filename)
-
-    def results(self, as_str: bool = True) -> str | tuple:
-        """Return the results of the analysis as a string. Use with print()."""
-        string = (
-            f" - {self._model} Results - ",
-            f"Geometric Distortions: {self.geometric_distortion.distances()}",
-            f"Slice Thickness: {self.slice1.slice_thickness:2.2f}mm",
-            f"Slice 1 S/I Position shift: {self.slice1.slice_shift_mm:2.2f}mm",
-            f"Slice 11 S/I Position shift: {self.slice11.slice_shift_mm:2.2f}mm",
-            f"Uniformity PIU: {self.uniformity_module.percent_image_uniformity:2.2f}",
-            f"Percent-signal ghosting: {self.uniformity_module.psg:2.2f}%",
-            f'Uniformity Center ROI standard deviation: {self.uniformity_module.rois["Center"].std:2.2f}',
-            f"Row-wise MTF 50% (lp/mm): {self.slice1.row_mtf.relative_resolution(50):2.2f}",
-            f"Column-wise MTF 50% (lp/mm): {self.slice1.col_mtf.relative_resolution(50):2.2f}",
-        )
-        if as_str:
-            return "\n".join(string)
-        else:
-            return string
-
-    def results_data(self, as_dict: bool = False) -> ACRMRIResult | dict:
-        data = ACRMRIResult(
-            phantom_model=self._model,
-            phantom_roll_deg=self.catphan_roll,
-            origin_slice=self.origin_slice,
-            num_images=self.num_images,
-            slice1=MRSlice1ModuleOutput(
-                offset=0,
-                roi_settings=self.slice1.roi_settings,
-                rois=rois_to_results(self.slice1.rois),
-                bar_difference_mm=self.slice1.bar_difference_mm,
-                slice_shift_mm=self.slice1.slice_shift_mm,
-                measured_slice_thickness_mm=self.slice1.measured_slice_thickness_mm,
-                row_mtf_50=self.slice1.row_mtf.relative_resolution(50),
-                col_mtf_50=self.slice1.col_mtf.relative_resolution(50),
-            ),
-            slice11=MRSlice11ModuleOutput(
-                offset=MR_SLICE11_MODULE_OFFSET_MM,
-                bar_difference_mm=self.slice11.bar_difference_mm,
-                slice_shift_mm=self.slice11.slice_shift_mm,
-                rois=rois_to_results(self.slice11.rois),
-                roi_settings=self.slice11.roi_settings,
-            ),
-            geometric_distortion_module=MRGeometricDistortionModuleOutput(
-                offset=MR_GEOMETRIC_DISTORTION_MODULE_OFFSET_MM,
-                profiles=self.geometric_distortion.profiles,
-                distances=self.geometric_distortion.distances(),
-            ),
-            uniformity_module=MRUniformityModuleOutput(
-                offset=0,
-                roi_settings=self.uniformity_module.roi_settings,
-                rois=rois_to_results(self.uniformity_module.rois),
-                ghost_roi_settings=self.uniformity_module.ghost_roi_settings,
-                ghost_rois=rois_to_results(self.uniformity_module.ghost_rois),
-                psg=self.uniformity_module.psg,
-                ghosting_ratio=self.uniformity_module.ghosting_ratio,
-                piu=self.uniformity_module.percent_image_uniformity,
-                piu_passed=self.uniformity_module.piu_passed,
-            ),
-        )
-        if as_dict:
-            return dataclasses.asdict(data)
-        return data
+from __future__ import annotations
+
+import io
+import math
+import textwrap
+import warnings
+import webbrowser
+from io import BytesIO
+from pathlib import Path
+
+import numpy as np
+from matplotlib import pyplot as plt
+from pydantic import BaseModel
+from scipy import ndimage
+
+from .core import pdf
+from .core.array_utils import find_nearest_idx
+from .core.geometry import Line, Point
+from .core.mtf import MTF
+from .core.profile import FWXMProfilePhysical
+from .core.roi import HighContrastDiskROI, RectangleROI
+from .core.utilities import ResultBase, ResultsDataMixin
+from .ct import (
+    CatPhanBase,
+    CatPhanModule,
+    Slice,
+    ThicknessROI,
+    get_regions,
+    rois_to_results,
+)
+
+# CT
+CT_UNIFORMITY_MODULE_OFFSET_MM = 70
+CT_SPATIAL_RESOLUTION_MODULE_OFFSET_MM = 100
+CT_LOW_CONTRAST_MODULE_OFFSET_MM = 30
+
+# MR
+MR_SLICE11_MODULE_OFFSET_MM = 100
+MR_GEOMETRIC_DISTORTION_MODULE_OFFSET_MM = 40
+MR_UNIFORMITY_MODULE_OFFSET_MM = 60
+
+
+class CTModule(CatPhanModule):
+    attr_name = "ct_calibration_module"
+    roi_dist_mm = 63
+    roi_radius_mm = 10
+    roi_settings = {
+        "Air": {"angle": 45, "distance": roi_dist_mm, "radius": roi_radius_mm},
+        "Poly": {"angle": 225, "distance": roi_dist_mm, "radius": roi_radius_mm},
+        "Acrylic": {"angle": 135, "distance": roi_dist_mm, "radius": roi_radius_mm},
+        "Bone": {"angle": -45, "distance": roi_dist_mm, "radius": roi_radius_mm},
+        "Water": {"angle": 180, "distance": roi_dist_mm, "radius": roi_radius_mm},
+    }
+    window_min = -200
+    window_max = 200
+
+
+class CTModuleOutput(BaseModel):
+    """This class should not be called directly. It is returned by the ``results_data()`` method.
+    It is a dataclass under the hood and thus comes with all the dunder magic.
+
+    Use the following attributes as normal class attributes."""
+
+    offset: int
+    roi_distance_from_center_mm: int
+    roi_radius_mm: int
+    roi_settings: dict
+    rois: dict
+
+
+class UniformityModule(CatPhanModule):
+    """Class for analysis of the Uniformity slice of the CTP module. Measures 5 ROIs around the slice that
+    should all be close to the same value.
+    """
+
+    attr_name = "uniformity_module"
+    common_name = "HU Uniformity"
+    roi_dist_mm = 66
+    roi_radius_mm = 11
+    roi_settings = {
+        "Top": {"angle": -90, "distance": roi_dist_mm, "radius": roi_radius_mm},
+        "Right": {"angle": 0, "distance": roi_dist_mm, "radius": roi_radius_mm},
+        "Bottom": {"angle": 90, "distance": roi_dist_mm, "radius": roi_radius_mm},
+        "Left": {"angle": 180, "distance": roi_dist_mm, "radius": roi_radius_mm},
+        "Center": {"angle": 0, "distance": 0, "radius": roi_radius_mm},
+    }
+    window_min = -50
+    window_max = 50
+
+
+class UniformityModuleOutput(CTModuleOutput):
+    """This class should not be called directly. It is returned by the ``results_data()`` method.
+    It is a dataclass under the hood and thus comes with all the dunder magic.
+
+    Use the following attributes as normal class attributes."""
+
+    center_roi_stdev: float  #:
+
+
+class SpatialResolutionModule(CatPhanModule):
+    """Class for analysis of the Uniformity slice of the CTP module. Measures 5 ROIs around the slice that
+    should all be close to the same value.
+    """
+
+    attr_name = "spatial_resolution_module"
+    common_name = "Spatial Resolution"
+    rois: dict[str, HighContrastDiskROI]
+    roi_dist_mm = 70
+    roi_radius_mm = 6
+    roi_settings = {
+        "10oclock": {
+            "angle": -135,
+            "distance": roi_dist_mm,
+            "radius": roi_radius_mm,
+            "lp/mm": 0.4,
+        },
+        "9oclock": {
+            "angle": -180,
+            "distance": roi_dist_mm,
+            "radius": roi_radius_mm,
+            "lp/mm": 0.5,
+        },
+        "7oclock": {
+            "angle": 135,
+            "distance": roi_dist_mm,
+            "radius": roi_radius_mm,
+            "lp/mm": 0.6,
+        },
+        "6oclock": {
+            "angle": 90,
+            "distance": roi_dist_mm,
+            "radius": roi_radius_mm,
+            "lp/mm": 0.7,
+        },
+        "4oclock": {
+            "angle": 45,
+            "distance": roi_dist_mm,
+            "radius": roi_radius_mm,
+            "lp/mm": 0.8,
+        },
+        "3oclock": {
+            "angle": 0,
+            "distance": roi_dist_mm,
+            "radius": roi_radius_mm,
+            "lp/mm": 0.9,
+        },
+        "2oclock": {
+            "angle": -45,
+            "distance": roi_dist_mm,
+            "radius": roi_radius_mm,
+            "lp/mm": 1.0,
+        },
+        "12oclock": {
+            "angle": -90,
+            "distance": roi_dist_mm,
+            "radius": roi_radius_mm,
+            "lp/mm": 1.2,
+        },
+    }
+
+    def _setup_rois(self) -> None:
+        for name, setting in self.roi_settings.items():
+            self.rois[name] = HighContrastDiskROI(
+                self.image,
+                setting["angle_corrected"],
+                setting["radius_pixels"],
+                setting["distance_pixels"],
+                self.phan_center,
+                contrast_threshold=1.0,  # fixed to 1 so everything passes. We aren't evaluating pass/fail here
+            )
+
+    @property
+    def mtf(self) -> MTF:
+        spacings = [roi["lp/mm"] for roi in self.roi_settings.values()]
+        return MTF.from_high_contrast_diskset(
+            spacings=spacings, diskset=list(self.rois.values())
+        )
+
+    def plot_rois(self, axis: plt.Axes) -> None:
+        """Plot the ROIs to the axis. Override to set the color"""
+        for roi, mtf in zip(self.rois.values(), self.mtf.norm_mtfs.values()):
+            roi.plot2axes(axis, edgecolor="g")
+
+
+class SpatialResolutionModuleOutput(CTModuleOutput):
+    """This class should not be called directly. It is returned by the ``results_data()`` method.
+    It is a dataclass under the hood and thus comes with all the dunder magic.
+
+    Use the following attributes as normal class attributes."""
+
+    lpmm_to_rmtf: dict  #:
+
+
+class LowContrastModule(CatPhanModule):
+    """Class for analysis of the Uniformity slice of the CTP module. Measures 5 ROIs around the slice that
+    should all be close to the same value.
+    """
+
+    attr_name = "low_contrast_module"
+    common_name = "Low Contrast"
+    roi_dist_mm = 60
+    roi_radius_mm = 6
+    nominal_value = 0
+    roi_settings = {
+        "ROI": {"angle": -90, "distance": roi_dist_mm, "radius": roi_radius_mm},
+    }
+    background_roi_settings = {
+        "ROI": {"angle": -115, "distance": roi_dist_mm, "radius": roi_radius_mm},
+    }
+    window_min = 50
+    window_max = 150
+
+    def cnr(self) -> float:
+        """Given in the guidance doc as |A-B|/SD where A is the contrast ROI, B is the background, and SD is stdev of B"""
+        return (
+            abs(self.rois["ROI"].pixel_value - self.background_rois["ROI"].pixel_value)
+            / self.background_rois["ROI"].std
+        )
+
+
+class LowContrastModuleOutput(CTModuleOutput):
+    """This class should not be called directly. It is returned by the ``results_data()`` method.
+    It is a dataclass under the hood and thus comes with all the dunder magic.
+
+    Use the following attributes as normal class attributes."""
+
+    cnr: float  #:
+
+
+class ACRCTResult(ResultBase):
+    """This class should not be called directly. It is returned by the ``results_data()`` method.
+    It is a dataclass under the hood and thus comes with all the dunder magic.
+
+    Use the following attributes as normal class attributes."""
+
+    phantom_model: str  #:
+    phantom_roll_deg: float  #:
+    origin_slice: int  #:
+    num_images: int  #:
+    ct_module: CTModuleOutput  #:
+    uniformity_module: UniformityModuleOutput  #:
+    low_contrast_module: LowContrastModuleOutput  #:
+    spatial_resolution_module: SpatialResolutionModuleOutput  #:
+
+
+class ACRCT(CatPhanBase, ResultsDataMixin[ACRCTResult]):
+    _model = "ACR CT 464"
+    catphan_radius_mm = 100
+    air_bubble_radius_mm = 14
+    min_num_images = 4
+    localization_radius = 70
+    ct_calibration_module = CTModule
+    low_contrast_module = LowContrastModule
+    spatial_resolution_module = SpatialResolutionModule
+    uniformity_module = UniformityModule
+    clear_borders = False
+
+    def _detected_modules(self) -> list[CatPhanModule]:
+        return [
+            self.ct_calibration_module,
+            self.low_contrast_module,
+            self.spatial_resolution_module,
+            self.uniformity_module,
+        ]
+
+    def plot_analyzed_subimage(self, *args, **kwargs):
+        raise NotImplementedError("Use `plot_images`")
+
+    def save_analyzed_subimage(self, *args, **kwargs):
+        raise NotImplementedError("Use `save_images`")
+
+    def analyze(self) -> None:
+        """Analyze the ACR CT phantom"""
+        self.localize()
+        self.ct_calibration_module = self.ct_calibration_module(
+            self, offset=0, clear_borders=self.clear_borders
+        )
+        self.uniformity_module = self.uniformity_module(
+            self,
+            offset=CT_UNIFORMITY_MODULE_OFFSET_MM,
+            clear_borders=self.clear_borders,
+        )
+        self.spatial_resolution_module = self.spatial_resolution_module(
+            self,
+            offset=CT_SPATIAL_RESOLUTION_MODULE_OFFSET_MM,
+            clear_borders=self.clear_borders,
+        )
+        self.low_contrast_module = self.low_contrast_module(
+            self,
+            offset=CT_LOW_CONTRAST_MODULE_OFFSET_MM,
+            clear_borders=self.clear_borders,
+        )
+
+    def plot_analyzed_image(self, show: bool = True, **plt_kwargs) -> plt.Figure:
+        """Plot the analyzed image
+
+        Parameters
+        ----------
+        show
+            Whether to show the image.
+        plt_kwargs
+            Keywords to pass to matplotlib for figure customization.
+        """
+        # set up grid and axes
+        fig = plt.figure(**plt_kwargs)
+        grid_size = (2, 3)
+        hu_ax = plt.subplot2grid(grid_size, (0, 0))
+        self.ct_calibration_module.plot(hu_ax)
+        unif_ax = plt.subplot2grid(grid_size, (0, 1))
+        self.uniformity_module.plot(unif_ax)
+        sr_ax = plt.subplot2grid(grid_size, (0, 2))
+        self.spatial_resolution_module.plot(sr_ax)
+        locon_ax = plt.subplot2grid(grid_size, (1, 0))
+        self.low_contrast_module.plot(locon_ax)
+        spatial_res_graph = plt.subplot2grid(grid_size, (1, 2))
+        self.spatial_resolution_module.mtf.plot(spatial_res_graph)
+        side_ax = plt.subplot2grid(grid_size, (1, 1))
+        self.plot_side_view(side_ax)
+
+        # finish up
+        plt.tight_layout()
+        if show:
+            plt.show()
+        return fig
+
+    def save_analyzed_image(self, filename: str | Path | BytesIO, **plt_kwargs) -> None:
+        """Save the analyzed image to disk or stream
+
+        Parameters
+        ----------
+        filename
+            Where to save the image to
+        plt_kwargs
+            Keywords to pass to matplotlib for figure customization.
+        """
+        fig = self.plot_analyzed_image(show=False, **plt_kwargs)
+        fig.savefig(filename)
+
+    def plot_images(self, show: bool = True, **plt_kwargs) -> dict[str, plt.Figure]:
+        """Plot all the individual images separately
+
+        Parameters
+        ----------
+        show
+            Whether to show the images.
+        plt_kwargs
+            Keywords to pass to matplotlib for figure customization.
+        """
+        figs = {}
+        # plot the images
+        modules = {
+            "hu": self.ct_calibration_module,
+            "uniformity": self.uniformity_module,
+            "spatial resolution": self.spatial_resolution_module,
+            "low contrast": self.low_contrast_module,
+        }
+        for key, module in modules.items():
+            fig, ax = plt.subplots(**plt_kwargs)
+            module.plot(ax)
+            figs[key] = fig
+        # plot the one-off MTF image
+        fig, ax = plt.subplots(**plt_kwargs)
+        figs["mtf"] = fig
+        self.spatial_resolution_module.mtf.plot(ax)
+        # plot the side view
+        fig, ax = plt.subplots(**plt_kwargs)
+        figs["side"] = fig
+        self.plot_side_view(ax)
+
+        plt.tight_layout()
+
+        if show:
+            plt.show()
+        return figs
+
+    def save_images(
+        self,
+        directory: Path | str | None = None,
+        to_stream: bool = False,
+        **plt_kwargs,
+    ) -> list[Path | BytesIO]:
+        """Save separate images to disk or stream.
+
+        Parameters
+        ----------
+        directory
+            The directory to write the images to. If None, will use current working directory
+        to_stream
+            Whether to write to stream or disk. If True, will return streams. Directory is ignored in that scenario.
+        plt_kwargs
+            Keywords to pass to matplotlib for figure customization.
+        """
+        figs = self.plot_images(show=False, **plt_kwargs)
+        paths = []
+        for name, fig in figs.items():
+            if to_stream:
+                path = io.BytesIO()
+            else:
+                destination = Path(directory) or Path.cwd()
+                path = (destination / name).with_suffix(".png").absolute()
+            fig.savefig(path)
+            paths.append(path)
+        return paths
+
+    def find_phantom_roll(self, func=lambda roi: roi.bbox_area) -> float:
+        """Determine the "roll" of the phantom.
+
+        Only difference of base method is that we sort the ROIs by size,
+        not by being in the center since the two we're looking for are both right-sided.
+        """
+        return super().find_phantom_roll(func)
+
+    def results(self) -> str:
+        """Return the results of the analysis as a string. Use with print()."""
+        string = (
+            f"\n - ACR CT 464 QA Test - \n"
+            f"HU ROIs: {self.ct_calibration_module.roi_vals_as_str}\n"
+            f"Contrast to Noise Ratio: {self.low_contrast_module.cnr():2.2f}\n"
+            f"Uniformity ROIs: {self.uniformity_module.roi_vals_as_str}\n"
+            f'Uniformity Center ROI standard deviation: {self.uniformity_module.rois["Center"].std:2.2f}\n'
+            f"MTF 50% (lp/mm): {self.spatial_resolution_module.mtf.relative_resolution(50):2.2f}\n"
+        )
+        return string
+
+    def _generate_results_data(self) -> ACRCTResult:
+        return ACRCTResult(
+            phantom_model="ACR CT 464",
+            phantom_roll_deg=self.catphan_roll,
+            origin_slice=self.origin_slice,
+            num_images=self.num_images,
+            ct_module=CTModuleOutput(
+                offset=0,
+                roi_distance_from_center_mm=self.ct_calibration_module.roi_dist_mm,
+                roi_radius_mm=self.ct_calibration_module.roi_radius_mm,
+                roi_settings=self.ct_calibration_module.roi_settings,
+                rois={
+                    name: roi.pixel_value
+                    for name, roi in self.ct_calibration_module.rois.items()
+                },
+            ),
+            uniformity_module=UniformityModuleOutput(
+                offset=CT_UNIFORMITY_MODULE_OFFSET_MM,
+                roi_distance_from_center_mm=self.uniformity_module.roi_dist_mm,
+                roi_radius_mm=self.uniformity_module.roi_radius_mm,
+                roi_settings=self.uniformity_module.roi_settings,
+                rois={
+                    name: roi.pixel_value
+                    for name, roi in self.uniformity_module.rois.items()
+                },
+                center_roi_stdev=self.uniformity_module.rois["Center"].std,
+            ),
+            spatial_resolution_module=SpatialResolutionModuleOutput(
+                offset=CT_SPATIAL_RESOLUTION_MODULE_OFFSET_MM,
+                roi_distance_from_center_mm=self.spatial_resolution_module.roi_dist_mm,
+                roi_radius_mm=self.spatial_resolution_module.roi_radius_mm,
+                roi_settings=self.spatial_resolution_module.roi_settings,
+                rois={
+                    name: roi.pixel_value
+                    for name, roi in self.spatial_resolution_module.rois.items()
+                },
+                lpmm_to_rmtf=self.spatial_resolution_module.mtf.norm_mtfs,
+            ),
+            low_contrast_module=LowContrastModuleOutput(
+                offset=CT_LOW_CONTRAST_MODULE_OFFSET_MM,
+                roi_distance_from_center_mm=self.low_contrast_module.roi_dist_mm,
+                roi_radius_mm=self.low_contrast_module.roi_radius_mm,
+                roi_settings=self.low_contrast_module.roi_settings,
+                rois={
+                    name: roi.pixel_value
+                    for name, roi in self.low_contrast_module.rois.items()
+                },
+                cnr=self.low_contrast_module.cnr(),
+            ),
+        )
+
+    def publish_pdf(
+        self,
+        filename: str | Path,
+        notes: str | None = None,
+        open_file: bool = False,
+        metadata: dict | None = None,
+        logo: Path | str | None = None,
+    ) -> None:
+        """Publish (print) a PDF containing the analysis and quantitative results.
+
+        Parameters
+        ----------
+        filename : (str, file-like object}
+            The file to write the results to.
+        notes : str, list of strings
+            Text; if str, prints single line.
+            If list of strings, each list item is printed on its own line.
+        open_file : bool
+            Whether to open the file using the default program after creation.
+        metadata : dict
+            Extra data to be passed and shown in the PDF. The key and value will be shown with a colon.
+            E.g. passing {'Author': 'James', 'Unit': 'TrueBeam'} would result in text in the PDF like:
+            --------------
+            Author: James
+            Unit: TrueBeam
+            --------------
+        logo: Path, str
+            A custom logo to use in the PDF report. If nothing is passed, the default pylinac logo is used.
+        """
+        analysis_title = f"{self._model} Analysis"
+        texts = [
+            " - ACR CT 464 Results - ",
+            f"HU Linearity ROIs: {self.ct_calibration_module.roi_vals_as_str}",
+            f"Low contrast visibility: {self.low_contrast_module.cnr():2.2f}",
+            f"Uniformity ROIs: {self.uniformity_module.roi_vals_as_str}",
+        ]
+        analysis_images = self.save_images(to_stream=True)
+
+        canvas = pdf.PylinacCanvas(
+            filename, page_title=analysis_title, metadata=metadata, logo=logo
+        )
+        if notes is not None:
+            canvas.add_text(text="Notes:", location=(1, 4.5), font_size=14)
+            canvas.add_text(text=notes, location=(1, 4))
+
+        for idx, text in enumerate(texts):
+            canvas.add_text(text=text, location=(1.5, 23 - idx * 0.5))
+        for page, img in enumerate(analysis_images):
+            canvas.add_new_page()
+            canvas.add_image(img, location=(1, 5), dimensions=(18, 18))
+        canvas.finish()
+
+        if open_file:
+            webbrowser.open(filename)
+
+    def _module_offsets(self) -> list[float]:
+        absolute_origin_position = self.dicom_stack[self.origin_slice].z_position
+        relative_offsets_mm = [
+            0,
+            CT_UNIFORMITY_MODULE_OFFSET_MM,
+            CT_LOW_CONTRAST_MODULE_OFFSET_MM,
+            CT_SPATIAL_RESOLUTION_MODULE_OFFSET_MM,
+        ]
+        return [
+            absolute_origin_position + offset_mm for offset_mm in relative_offsets_mm
+        ]
+
+
+class MRSlice11PositionModule(CatPhanModule):
+    common_name = "Slice Position, Slice 11"
+    roi_settings = {
+        "Left": {"width": 2, "height": 25, "distance": 65, "angle": 2.5},
+        "Right": {"width": 2, "height": 25, "distance": 65, "angle": -2.5},
+    }
+    rois: dict = {}
+
+    def _setup_rois(self) -> None:
+        for name, setting in self.roi_settings.items():
+            # angle is +90 because pointing right is 0, and these rois move downward, not rightward
+            self.rois[name] = RectangleROI(
+                self.image,
+                setting["width_pixels"],
+                setting["height_pixels"],
+                self.catphan_roll - 90 + setting["angle"],
+                setting["distance_pixels"],
+                self.phan_center,
+            )
+
+    @property
+    def bar_difference_mm(self) -> float:
+        """The difference in height between the two angled bars"""
+        idxs = []
+        for roi in (self.rois["Right"], self.rois["Left"]):
+            prof = roi.pixel_array.max(axis=np.argmin(roi.pixel_array.shape))
+            mid_height = (prof.max() - prof.min()) / 2 + prof.min()
+            idx = find_nearest_idx(prof, mid_height)
+            idxs.append(idx)
+        return (idxs[0] - idxs[1]) * self.mm_per_pixel
+
+    @property
+    def slice_shift_mm(self) -> float:
+        """The effective shift in phantom position in the S/I direction. Because bars are at 45 degrees, the shift is half the bar difference"""
+        return self.bar_difference_mm / 2
+
+    def plot_rois(self, axis: plt.Axes) -> None:
+        """Plot the ROIs to the axis.
+
+        We overload because simple rectangle ROIs don't have a pass/fail color.
+        """
+        for roi in self.rois.values():
+            roi.plot2axes(axis, edgecolor="blue")
+
+
+class MRSlice11ModuleOutput(BaseModel):
+    """This class should not be called directly. It is returned by the ``results_data()`` method.
+    It is a dataclass under the hood and thus comes with all the dunder magic.
+
+    Use the following attributes as normal class attributes."""
+
+    offset: int  #:
+    roi_settings: dict  #:
+    rois: dict  #:
+    bar_difference_mm: float  #:
+    slice_shift_mm: float  #:
+
+
+class MRSlice1Module(CatPhanModule):
+    common_name = "Slice 1 (Thickness, Offset, Resolution)"
+    slice_lines: dict[str, Line]
+    thickness_rois: dict[str, ThicknessROI] = {}
+    thickness_roi_settings = {
+        "Top": {"width": 100, "height": 3, "distance": -3},
+        "Bottom": {"width": 100, "height": 3, "distance": 2.5},
+    }
+    roi_settings = {
+        "Row Reference": {"radius": 9, "distance": 58, "angle": 135, "lp/mm": 0},
+        "Col Reference": {"radius": 9, "distance": 58, "angle": 135, "lp/mm": 0},
+        "Row 1.1": {"radius": 3, "distance": 40, "angle": 116, "lp/mm": 1 / 1.1},
+        "Col 1.1": {"radius": 3, "distance": 44, "angle": 104, "lp/mm": 1 / 1.1},
+        "Row 1.0": {"radius": 3, "distance": 36, "angle": 81, "lp/mm": 1.0},
+        "Col 1.0": {"radius": 3, "distance": 44, "angle": 74, "lp/mm": 1.0},
+        "Row 0.9": {"radius": 2, "distance": 46, "angle": 52, "lp/mm": 1 / 0.9},
+        "Col 0.9": {"radius": 2, "distance": 55, "angle": 51, "lp/mm": 1 / 0.9},
+    }
+    position_roi_settings = {
+        "Left": {"width": 2, "height": 25, "distance": 65, "angle": 2.5},
+        "Right": {"width": 2, "height": 25, "distance": 65, "angle": -2.5},
+    }
+    position_rois: dict = {}
+    rois: dict[str, HighContrastDiskROI]
+    spacings = [0, 1 / 1.1, 1, 1 / 0.9]
+
+    def _setup_rois(self) -> None:
+        # thickness
+        for name, setting in self.thickness_roi_settings.items():
+            # angle is +90 because pointing right is 0, and these rois move downward, not rightward
+            self.thickness_rois[name] = ThicknessROI(
+                self.image,
+                setting["width_pixels"],
+                setting["height_pixels"],
+                self.catphan_roll + 90,
+                setting["distance_pixels"],
+                self.phan_center,
+            )
+        # spatial res
+        for name, setting in self.roi_settings.items():
+            self.rois[name] = HighContrastDiskROI(
+                self.image,
+                setting["angle_corrected"],
+                setting["radius_pixels"],
+                setting["distance_pixels"],
+                self.phan_center,
+                contrast_threshold=1.0,  # fixed to 1 so everything passes. We aren't evaluating pass/fail here
+            )
+        # slice position
+        for name, setting in self.position_roi_settings.items():
+            # angle is +90 because pointing right is 0, and these rois move downward, not rightward
+            self.position_rois[name] = ThicknessROI(
+                self.image,
+                setting["width_pixels"],
+                setting["height_pixels"],
+                self.catphan_roll - 90 + setting["angle"],
+                setting["distance_pixels"],
+                self.phan_center,
+            )
+
+    def plot_rois(self, axis: plt.Axes) -> None:
+        for roi in self.position_rois.values():
+            roi.plot2axes(axis, edgecolor="blue")
+        for roi in self.thickness_rois.values():
+            roi.plot2axes(axis, edgecolor="blue")
+        for roi, mtf in zip(self.rois.values(), self.rois.values()):
+            roi.plot2axes(axis, edgecolor="g")
+
+    @property
+    def bar_difference_mm(self) -> float:
+        """The difference in height between the two angled bars"""
+        left_array = self.position_rois["Left"].long_profile.values
+        left_mid_height = (left_array.max() - left_array.min()) / 2 + left_array.min()
+        left_idx = find_nearest_idx(left_array, left_mid_height)
+        right_array = self.position_rois["Right"].long_profile.values
+        right_mid_height = (
+            right_array.max() - right_array.min()
+        ) / 2 + right_array.min()
+        right_idx = find_nearest_idx(right_array, right_mid_height)
+        return (right_idx - left_idx) * self.mm_per_pixel
+
+    @property
+    def slice_shift_mm(self) -> float:
+        """The effective shift in phantom position in the S/I direction. Because bars are at 45 degrees, the shift is half the bar difference"""
+        return self.bar_difference_mm / 2
+
+    @property
+    def measured_slice_thickness_mm(self) -> float:
+        """The slice thickness as determined by the two angled ROIs in the center of Slice 1"""
+        top = self.thickness_rois["Top"].wire_fwhm * self.mm_per_pixel
+        bottom = self.thickness_rois["Bottom"].wire_fwhm * self.mm_per_pixel
+        return 0.2 * (top * bottom) / (top + bottom)
+
+    @property
+    def row_mtf(self) -> MTF:
+        """The MTF of the spatial resolution module looking at the row-wise ROIs"""
+        return MTF.from_high_contrast_diskset(
+            spacings=self.spacings,
+            diskset=list(roi for name, roi in self.rois.items() if "Row" in name),
+        )
+
+    @property
+    def col_mtf(self) -> MTF:
+        """The MTF of the spatial resolution module looking at the column-wise ROIs"""
+        return MTF.from_high_contrast_diskset(
+            spacings=self.spacings,
+            diskset=list(roi for name, roi in self.rois.items() if "Col" in name),
+        )
+
+
+class MRSlice1ModuleOutput(BaseModel):
+    """This class should not be called directly. It is returned by the ``results_data()`` method.
+    It is a dataclass under the hood and thus comes with all the dunder magic.
+
+    Use the following attributes as normal class attributes."""
+
+    offset: int  #:
+    roi_settings: dict  #:
+    rois: dict  #:
+    bar_difference_mm: float  #:
+    slice_shift_mm: float  #:
+    measured_slice_thickness_mm: float  #:
+    row_mtf_50: float  #:
+    col_mtf_50: float  #:
+
+
+class MRUniformityModule(CatPhanModule):
+    """Class for analysis of the Uniformity slice of the CTP module. Measures 5 ROIs around the slice that
+    should all be close to the same value.
+    """
+
+    common_name = "Signal Uniformity"
+    roi_settings = {
+        "Center": {
+            "angle": 90,
+            "distance": 5,
+            "radius": 80,
+        },  # 80 radius ~= 200cm2, per the manual
+    }
+    ghost_roi_settings = {
+        # size of ~900mm2 per the manual
+        "Top": {"angle": -90, "distance": 110, "width": 60, "height": 15},
+        "Bottom": {"angle": 90, "distance": 110, "width": 60, "height": 15},
+        "Left": {"angle": 180, "distance": 110, "width": 15, "height": 60},
+        "Right": {"angle": 0, "distance": 110, "width": 15, "height": 60},
+    }
+    ghost_rois: dict = {}
+
+    def __init__(self, catphan, offset):
+        self.tesla = float(catphan.dicom_stack.metadata.MagneticFieldStrength)
+        super().__init__(catphan, tolerance=None, offset=offset)
+
+    def _setup_rois(self) -> None:
+        super()._setup_rois()
+        for name, roi in self.ghost_roi_settings.items():
+            self.ghost_rois[name] = RectangleROI(
+                self.image,
+                roi["width_pixels"],
+                roi["height_pixels"],
+                roi["angle"] + self.catphan_roll,
+                roi["distance_pixels"],
+                self.phan_center,
+            )
+
+    def plot_rois(self, axis: plt.Axes) -> None:
+        super().plot_rois(axis)
+        for roi in self.ghost_rois.values():
+            roi.plot2axes(axis, edgecolor="yellow")
+
+    @property
+    def percent_image_uniformity(self) -> float:
+        """PIU value calculated via section 5.3 of the manual"""
+        piu_high = np.percentile(self.rois["Center"].pixel_values, 99)
+        piu_low = np.percentile(self.rois["Center"].pixel_values, 1)
+        return 100 * (1 - ((piu_high - piu_low) / (piu_high + piu_low)))
+
+    @property
+    def piu_passed(self) -> bool:
+        """Section 5.4"""
+        if self.tesla < 3:
+            return self.percent_image_uniformity > 85
+        else:
+            return self.percent_image_uniformity > 80
+
+    @property
+    def ghosting_ratio(self) -> float:
+        """Ghosting ratio of section 6.3 of the manual"""
+        top = self.ghost_rois["Top"].pixel_value
+        bottom = self.ghost_rois["Bottom"].pixel_value
+        left = self.ghost_rois["Left"].pixel_value
+        right = self.ghost_rois["Right"].pixel_value
+        return abs(
+            ((top + bottom) - (left + right)) / (2 * self.rois["Center"].pixel_value)
+        )
+
+    @property
+    def psg(self) -> float:
+        """Percent Signal Ghosting"""
+        return self.ghosting_ratio * 100
+
+    @property
+    def psg_passed(self) -> bool:
+        """Whether the PSG is within tolerance"""
+        return self.psg < 3.0
+
+
+class MRUniformityModuleOutput(BaseModel):
+    """This class should not be called directly. It is returned by the ``results_data()`` method.
+    It is a dataclass under the hood and thus comes with all the dunder magic.
+
+    Use the following attributes as normal class attributes."""
+
+    offset: int  #:
+    roi_settings: dict  #:
+    rois: dict  #:
+    ghost_roi_settings: dict  #:
+    ghost_rois: dict  #:
+    psg: float  #:
+    ghosting_ratio: float  #:
+    piu_passed: bool  #:
+    piu: float  #:
+
+
+class GeometricDistortionModule(CatPhanModule):
+    """Class for analysis of the Uniformity slice of the CTP module. Measures 5 ROIs around the slice that
+    should all be close to the same value.
+    """
+
+    common_name = "Geometric Distortion"
+    profiles: dict
+
+    def _setup_rois(self) -> None:
+        self.profiles = {}
+        bin_image = self.image.as_binary(threshold=np.percentile(self.image, 60))
+        bin_image = ndimage.binary_fill_holes(bin_image).astype(float)
+        # calculate horizontal
+        data = bin_image[int(self.phan_center.y), :]
+        prof = FWXMProfilePhysical(values=data, dpmm=1 / self.mm_per_pixel)
+        line = Line(
+            Point(prof.field_edge_idx(side="left"), self.phan_center.y),
+            Point(prof.field_edge_idx(side="right"), self.phan_center.y),
+        )
+
+        self.profiles["horizontal"] = {
+            "width (mm)": prof.field_width_mm,
+            "line": line,
+        }
+        # calculate vertical
+        data = bin_image[:, int(self.phan_center.x)]
+        prof = FWXMProfilePhysical(values=data, dpmm=1 / self.mm_per_pixel)
+        line = Line(
+            Point(self.phan_center.x, prof.field_edge_idx(side="left")),
+            Point(self.phan_center.x, prof.field_edge_idx(side="right")),
+        )
+        self.profiles["vertical"] = {
+            "width (mm)": prof.field_width_mm,
+            "line": line,
+        }
+        # calculate negative diagonal
+        # calculate slope equation intercept
+        # b = y - (+1)x
+        b = self.phan_center.y - self.phan_center.x
+        xs = np.arange(0, self.image.shape[1])
+        ys = xs + b
+        coords = ndimage.map_coordinates(bin_image, [ys, xs], order=1, mode="mirror")
+        # pixels are now diagonal and thus spacing between pixels is now the hypotenuse
+        prof = FWXMProfilePhysical(
+            values=coords, dpmm=1 / (self.mm_per_pixel * math.sqrt(2))
+        )
+        line = Line(
+            Point(
+                xs[int(round(prof.field_edge_idx(side="left")))],
+                ys[int(round(prof.field_edge_idx(side="left")))],
+            ),
+            Point(
+                xs[int(round(prof.field_edge_idx(side="right")))],
+                ys[int(round(prof.field_edge_idx(side="right")))],
+            ),
+        )
+        self.profiles["negative diagonal"] = {
+            "width (mm)": prof.field_width_mm,
+            "line": line,
+        }
+        # calculate positive diagonal
+        # calculate slope equation intercept
+        # b = y - (-1)x
+        b = self.phan_center.y + self.phan_center.x
+        ys = -xs + b
+        coords = ndimage.map_coordinates(bin_image, [ys, xs], order=1, mode="mirror")
+        prof = FWXMProfilePhysical(
+            values=coords, dpmm=1 / (self.mm_per_pixel * math.sqrt(2))
+        )
+        line = Line(
+            Point(
+                xs[int(round(prof.field_edge_idx(side="left")))],
+                ys[int(round(prof.field_edge_idx(side="left")))],
+            ),
+            Point(
+                xs[int(round(prof.field_edge_idx(side="right")))],
+                ys[int(round(prof.field_edge_idx(side="right")))],
+            ),
+        )
+        self.profiles["positive diagonal"] = {
+            "width (mm)": prof.field_width_mm,
+            "line": line,
+        }
+
+    def plot_rois(self, axis: plt.Axes):
+        for name, profile_data in self.profiles.items():
+            profile_data["line"].plot2axes(axis, width=2, color="blue")
+
+    def distances(self) -> dict:
+        """The measurements of the phantom size for all 4 lines in mm"""
+        return {name: f"{p['width (mm)']:2.2f}mm" for name, p in self.profiles.items()}
+
+
+class MRGeometricDistortionModuleOutput(BaseModel):
+    """This class should not be called directly. It is returned by the ``results_data()`` method.
+    It is a dataclass under the hood and thus comes with all the dunder magic.
+
+    Use the following attributes as normal class attributes."""
+
+    offset: int  #:
+    profiles: dict  #:
+    distances: dict  #:
+
+
+class ACRMRIResult(ResultBase):
+    """This class should not be called directly. It is returned by the ``results_data()`` method.
+    It is a dataclass under the hood and thus comes with all the dunder magic.
+
+    Use the following attributes as normal class attributes."""
+
+    phantom_model: str  #:
+    phantom_roll_deg: float  #:
+    origin_slice: int  #:
+    num_images: int  #:
+    slice1: MRSlice1ModuleOutput  #:
+    slice11: MRSlice11ModuleOutput  #:
+    uniformity_module: MRUniformityModuleOutput  #:
+    geometric_distortion_module: MRGeometricDistortionModuleOutput  #:
+
+
+class ACRMRILarge(CatPhanBase, ResultsDataMixin[ACRMRIResult]):
+    _model = "ACR MRI Large"
+    catphan_radius_mm = 100
+    min_num_images = 4
+    air_bubble_radius_mm = 20
+    slice1 = MRSlice1Module
+    geometric_distortion = GeometricDistortionModule
+    uniformity_module = MRUniformityModule
+    slice11 = MRSlice11PositionModule
+
+    def plot_analyzed_subimage(self, *args, **kwargs):
+        raise NotImplementedError("Use `plot_images`")
+
+    def save_analyzed_subimage(self, *args, **kwargs):
+        raise NotImplementedError("Use `save_images`")
+
+    def localize(self) -> None:
+        self._phantom_center_func = self.find_phantom_axis()
+        self.catphan_roll = self.find_phantom_roll()
+        # now that we have the origin slice, ensure we have scanned all linked modules
+        if not self._ensure_physical_scan_extent():
+            raise ValueError(
+                "The physical scan extent does not cover the extent of module configuration. "
+                "This means not all modules were included in the scan. Rescan the phantom to include all "
+                "relevant modules, or change the offset values."
+            )
+
+    def _module_offsets(self) -> list[float]:
+        absolute_origin_position = self.dicom_stack[self.origin_slice].z_position
+        relative_offsets_mm = [
+            0,
+            MR_GEOMETRIC_DISTORTION_MODULE_OFFSET_MM,
+            MR_UNIFORMITY_MODULE_OFFSET_MM,
+            MR_SLICE11_MODULE_OFFSET_MM,
+        ]
+        return [
+            absolute_origin_position + offset_mm for offset_mm in relative_offsets_mm
+        ]
+
+    def find_phantom_roll(self) -> float:
+        """Determine the "roll" of the phantom. This algorithm uses the circular left-upper hole on slice 1 as the reference
+
+        Returns
+        -------
+        float : the angle of the phantom in **degrees**.
+        """
+        # get edges and make ROIs from it
+        slice = Slice(self, self.origin_slice)
+        larr, regions, _ = get_regions(slice)
+        try:
+            # find appropriate ROIs and grab the two most centrally positioned ones
+            circle_bubbles = [
+                r
+                for r in regions
+                if (self._is_right_area(r) and self._is_right_eccentricity(r))
+            ]
+            exact_size = np.pi * ((self.air_bubble_radius_mm / self.mm_per_pixel) ** 2)
+            most_similar_bubble = sorted(
+                circle_bubbles, key=lambda r: abs(r.filled_area - exact_size)
+            )[0]
+            y_dist = most_similar_bubble.centroid[0] - slice.phan_center.y
+            x_dist = most_similar_bubble.centroid[1] - slice.phan_center.x
+            phan_roll = np.arctan2(y_dist, x_dist)
+            corrected_roll = (
+                np.rad2deg(phan_roll) + 135
+            )  # bubble is at top-left. perfect placement is -135
+            return corrected_roll
+        except Exception:
+            raise RuntimeError(
+                "Could not determine the roll of the phantom. Ensure the 20mm top-left circle is visible on Slice 1"
+            )
+
+    def analyze(self, echo_number: int | None = None) -> None:
+        """Analyze the ACR CT phantom
+
+        Parameters
+        ----------
+        echo_number:
+            The echo to analyze. If not passed, uses the minimum echo number found.
+        """
+        self._select_echo_images(echo_number)
+        self.localize()
+        self.slice1 = self.slice1(self, offset=0)
+        self.geometric_distortion = self.geometric_distortion(
+            self, offset=MR_GEOMETRIC_DISTORTION_MODULE_OFFSET_MM
+        )
+        self.uniformity_module = self.uniformity_module(
+            self, offset=MR_UNIFORMITY_MODULE_OFFSET_MM
+        )
+        self.slice11 = self.slice11(self, offset=MR_SLICE11_MODULE_OFFSET_MM)
+
+    def _select_echo_images(self, echo_number: int | None) -> None:
+        """Select out the images that match the given echo number"""
+        # we check for multiple echos. We only pick the first echo found.
+        # this is probably not the best logic but we somehow have to pick
+        # Echo Numbers is an int; https://dicom.innolitics.com/ciods/mr-image/mr-image/00180086
+
+        # in case EchoNumbers isn't there, use all
+        try:
+            all_echos = {int(i.metadata.EchoNumbers) for i in self.dicom_stack}
+        except AttributeError:
+            # no manipulation; use all images
+            return
+        if echo_number is None:
+            echo_number = min(all_echos)
+            if len(all_echos) > 1:
+                warnings.warn(
+                    f"Multiple echoes found ({all_echos}) and no echo number was passed. Using echo # {echo_number}"
+                )
+        if echo_number not in all_echos:
+            raise ValueError(
+                f"Echo number {echo_number} was passed but not found in the dataset. Found echo numbers: {all_echos}. Remove the echo_number parameter or pick a valid echo number."
+            )
+        # drop images that don't have the same echo number
+        to_pop = []
+        for idx, img in enumerate([i for i in self.dicom_stack].copy()):
+            if int(img.metadata.EchoNumbers) != echo_number:
+                to_pop.append(idx)
+        for idx in sorted(to_pop, reverse=True):
+            del self.dicom_stack[idx]
+            del self.dicom_stack.metadatas[idx]
+
+    def plot_analyzed_image(self, show: bool = True, **plt_kwargs) -> plt.Figure:
+        """Plot the analyzed image
+
+        Parameters
+        ----------
+        show
+            Whether to show the image.
+        plt_kwargs
+            Keywords to pass to matplotlib for figure customization.
+        """
+        # set up grid and axes
+        fig = plt.figure(**plt_kwargs)
+        grid_size = (2, 3)
+        slice1_ax = plt.subplot2grid(grid_size, (0, 0))
+        self.slice1.plot(slice1_ax)
+        geom_ax = plt.subplot2grid(grid_size, (0, 1))
+        self.geometric_distortion.plot(geom_ax)
+        unif_ax = plt.subplot2grid(grid_size, (0, 2))
+        self.uniformity_module.plot(unif_ax)
+        position_ax = plt.subplot2grid(grid_size, (1, 0))
+        self.slice11.plot(position_ax)
+
+        side_view_ax = plt.subplot2grid(grid_size, (1, 1))
+        self.plot_side_view(side_view_ax)
+        spatial_res_graph = plt.subplot2grid(grid_size, (1, 2))
+        self.slice1.row_mtf.plot(spatial_res_graph, label="Row-wise rMTF")
+        self.slice1.col_mtf.plot(spatial_res_graph, label="Column-wise rMTF")
+        spatial_res_graph.legend()
+
+        # finish up
+        plt.tight_layout()
+        if show:
+            plt.show()
+        return fig
+
+    def plot_images(self, show: bool = True, **plt_kwargs) -> dict[str, plt.Figure]:
+        """Plot all the individual images separately
+
+        Parameters
+        ----------
+        show
+            Whether to show the images.
+        plt_kwargs
+            Keywords to pass to matplotlib for figure customization.
+        """
+        figs = {}
+        # plot the images
+        modules = {
+            "geometric": self.geometric_distortion,
+            "slice 1": self.slice1,
+            "signal uniformity": self.uniformity_module,
+            "slice 11": self.slice11,
+        }
+        for key, module in modules.items():
+            fig, ax = plt.subplots(**plt_kwargs)
+            module.plot(ax)
+            figs[key] = fig
+        # plot rMTF
+        fig, ax = plt.subplots(**plt_kwargs)
+        self.slice1.row_mtf.plot(ax, label="Row-wise rMTF")
+        self.slice1.col_mtf.plot(ax, label="Column-wise rMTF")
+        ax.legend()
+        figs["rMTF"] = fig
+        # plot the side view
+        fig, ax = plt.subplots(**plt_kwargs)
+        figs["side"] = fig
+        self.plot_side_view(ax)
+
+        if show:
+            plt.show()
+        return figs
+
+    def _detected_modules(self) -> list[CatPhanModule]:
+        return [
+            self.slice1,
+            self.slice11,
+            self.uniformity_module,
+            self.geometric_distortion,
+        ]
+
+    def save_images(
+        self,
+        directory: Path | str | None = None,
+        to_stream: bool = False,
+        **plt_kwargs,
+    ) -> list[Path | BytesIO]:
+        """Save separate images to disk or stream.
+
+        Parameters
+        ----------
+        directory
+            The directory to write the images to. If None, will use current working directory
+        to_stream
+            Whether to write to stream or disk. If True, will return streams. Directory is ignored in that scenario.
+        plt_kwargs
+            Keywords to pass to matplotlib for figure customization.
+        """
+        figs = self.plot_images(show=False, **plt_kwargs)
+        paths = []
+        for name, fig in figs.items():
+            if to_stream:
+                path = io.BytesIO()
+            else:
+                destination = Path(directory) or Path.cwd()
+                path = (destination / name).with_suffix(".png").absolute()
+            fig.savefig(path)
+            paths.append(path)
+        return paths
+
+    def publish_pdf(
+        self,
+        filename: str | Path,
+        notes: str | None = None,
+        open_file: bool = False,
+        metadata: dict | None = None,
+        logo: Path | str | None = None,
+    ) -> None:
+        """Publish (print) a PDF containing the analysis and quantitative results.
+
+        Parameters
+        ----------
+        filename : (str, file-like object}
+            The file to write the results to.
+        notes : str, list of strings
+            Text; if str, prints single line.
+            If list of strings, each list item is printed on its own line.
+        open_file : bool
+            Whether to open the file using the default program after creation.
+        metadata : dict
+            Extra data to be passed and shown in the PDF. The key and value will be shown with a colon.
+            E.g. passing {'Author': 'James', 'Unit': 'TrueBeam'} would result in text in the PDF like:
+            --------------
+            Author: James
+            Unit: TrueBeam
+            --------------
+        logo: Path, str
+            A custom logo to use in the PDF report. If nothing is passed, the default pylinac logo is used.
+        """
+        analysis_title = f"{self._model} Analysis"
+        analysis_images = self.save_images(to_stream=True)
+
+        canvas = pdf.PylinacCanvas(
+            filename, page_title=analysis_title, metadata=metadata
+        )
+        if notes is not None:
+            canvas.add_text(text="Notes:", location=(1, 4.5), font_size=14)
+            canvas.add_text(text=notes, location=(1, 4))
+
+        shortened_texts = [
+            textwrap.wrap(r, width=110) for r in self.results(as_str=False)
+        ]
+        idx = 0
+        for items in enumerate(shortened_texts):
+            for text in items:
+                canvas.add_text(text=text, location=(1.5, 25 - idx * 0.5))
+                idx += 1
+        for page, img in enumerate(analysis_images):
+            canvas.add_new_page()
+            canvas.add_image(img, location=(1, 5), dimensions=(18, 18))
+        canvas.finish()
+
+        if open_file:
+            webbrowser.open(filename)
+
+    def results(self, as_str: bool = True) -> str | tuple:
+        """Return the results of the analysis as a string. Use with print()."""
+        string = (
+            f" - {self._model} Results - ",
+            f"Geometric Distortions: {self.geometric_distortion.distances()}",
+            f"Slice Thickness: {self.slice1.measured_slice_thickness_mm:2.2f}mm",
+            f"Slice 1 S/I Position shift: {self.slice1.slice_shift_mm:2.2f}mm",
+            f"Slice 11 S/I Position shift: {self.slice11.slice_shift_mm:2.2f}mm",
+            f"Uniformity PIU: {self.uniformity_module.percent_image_uniformity:2.2f}",
+            f"Percent-signal ghosting: {self.uniformity_module.psg:2.2f}%",
+            f'Uniformity Center ROI standard deviation: {self.uniformity_module.rois["Center"].std:2.2f}',
+            f"Row-wise MTF 50% (lp/mm): {self.slice1.row_mtf.relative_resolution(50):2.2f}",
+            f"Column-wise MTF 50% (lp/mm): {self.slice1.col_mtf.relative_resolution(50):2.2f}",
+        )
+        if as_str:
+            return "\n".join(string)
+        else:
+            return string
+
+    def _generate_results_data(self) -> ACRMRIResult:
+        return ACRMRIResult(
+            phantom_model=self._model,
+            phantom_roll_deg=self.catphan_roll,
+            origin_slice=self.origin_slice,
+            num_images=self.num_images,
+            slice1=MRSlice1ModuleOutput(
+                offset=0,
+                roi_settings=self.slice1.roi_settings,
+                rois=rois_to_results(self.slice1.rois),
+                bar_difference_mm=self.slice1.bar_difference_mm,
+                slice_shift_mm=self.slice1.slice_shift_mm,
+                measured_slice_thickness_mm=self.slice1.measured_slice_thickness_mm,
+                row_mtf_50=self.slice1.row_mtf.relative_resolution(50),
+                col_mtf_50=self.slice1.col_mtf.relative_resolution(50),
+            ),
+            slice11=MRSlice11ModuleOutput(
+                offset=MR_SLICE11_MODULE_OFFSET_MM,
+                bar_difference_mm=self.slice11.bar_difference_mm,
+                slice_shift_mm=self.slice11.slice_shift_mm,
+                rois=rois_to_results(self.slice11.rois),
+                roi_settings=self.slice11.roi_settings,
+            ),
+            geometric_distortion_module=MRGeometricDistortionModuleOutput(
+                offset=MR_GEOMETRIC_DISTORTION_MODULE_OFFSET_MM,
+                profiles=self.geometric_distortion.profiles,
+                distances=self.geometric_distortion.distances(),
+            ),
+            uniformity_module=MRUniformityModuleOutput(
+                offset=0,
+                roi_settings=self.uniformity_module.roi_settings,
+                rois=rois_to_results(self.uniformity_module.rois),
+                ghost_roi_settings=self.uniformity_module.ghost_roi_settings,
+                ghost_rois=rois_to_results(self.uniformity_module.ghost_rois),
+                psg=self.uniformity_module.psg,
+                ghosting_ratio=self.uniformity_module.ghosting_ratio,
+                piu=self.uniformity_module.percent_image_uniformity,
+                piu_passed=self.uniformity_module.piu_passed,
+            ),
+        )
```

### Comparing `manteia_qa_pylinac-1.0.0/pylinac/calibration/tg51.py` & `manteia_qa_pylinac-1.1.0/pylinac/calibration/tg51.py`

 * *Ordering differences only*

 * *Files 26% similar despite different names*

```diff
@@ -1,1419 +1,1419 @@
-"""
-The TG-51 module contains a number of helper functions and classes that can calculate parameters for performing the
-TG-51 absolute linac dose calibration although there are some modifications from the original TG-51. The modifications
-include updated kQ and kecal values from Muir and Rogers' set of papers.
-Functions include all relevant calculations for TG-51 including PDDx, kQ,
-Dref, and chamber reading corrections. Where Muir & Rogers' values/equations are used they are specified in the documentation.
-
-Classes include photon and electron calibrations using cylindrical chambers. Pass all the relevant raw measurements
-and the class will compute all corrections and corrected readings and dose at 10cm and dmax/dref.
-"""
-import webbrowser
-from datetime import datetime
-from typing import Optional
-
-import argue
-import numpy as np
-
-from ..core.pdf import PylinacCanvas
-from ..core.typing import NumberOrArray
-from ..core.utilities import Structure
-
-MIN_TEMP = 15
-MAX_TEMP = 35
-MIN_PRESSURE = 90
-MAX_PRESSURE = 115
-MIN_PION = 1
-MAX_PION = 1.05
-MIN_PTP = 0.9
-MAX_PTP = 1.1
-MIN_PELEC = 0.98
-MAX_PELEC = 1.02
-MIN_PPOL = 0.98
-MAX_PPOL = 1.02
-
-
-KQ_PHOTONS = {
-    # Exradin
-    "A12": {
-        "a": 1.0146,
-        "b": 0.777e-3,
-        "c": -1.666e-5,
-        "a'": 2.6402,
-        "b'": -7.2304,
-        "c'": 10.7573,
-        "d'": -5.4294,
-    },
-    "A19": {
-        "a": 0.9934,
-        "b": 1.384e-3,
-        "c": -2.125e-5,
-        "a'": 3.0907,
-        "b'": -9.1930,
-        "c'": 13.5957,
-        "d'": -6.7969,
-    },
-    "A2": {
-        "a": 0.9819,
-        "b": 1.609e-3,
-        "c": -2.184e-5,
-        "a'": 2.8458,
-        "b'": -8.1619,
-        "c'": 12.1411,
-        "d'": -6.1041,
-    },
-    "T2": {
-        "a": 1.0173,
-        "b": 0.854e-3,
-        "c": -1.941e-5,
-        "a'": 3.3433,
-        "b'": -10.2649,
-        "c'": 15.1247,
-        "d'": -7.5415,
-    },
-    "A12S": {
-        "a": 0.9692,
-        "b": 1.974e-3,
-        "c": -2.448e-5,
-        "a'": 2.9597,
-        "b'": -8.6777,
-        "c'": 12.9155,
-        "d'": -6.4903,
-    },
-    "A18": {
-        "a": 0.9944,
-        "b": 1.286e-3,
-        "c": -1.980e-5,
-        "a'": 2.5167,
-        "b'": -6.7567,
-        "c'": 10.1519,
-        "d'": -5.1709,
-    },
-    "A1": {
-        "a": 1.0029,
-        "b": 1.023e-3,
-        "c": -1.803e-5,
-        "a'": 2.0848,
-        "b'": -4.9174,
-        "c'": 7.5446,
-        "d'": -3.9441,
-    },
-    "T1": {
-        "a": 1.0552,
-        "b": -0.196e-3,
-        "c": -1.275e-5,
-        "a'": 2.8060,
-        "b'": -7.9273,
-        "c'": 11.7541,
-        "d'": -5.9263,
-    },
-    "A1SL": {
-        "a": 0.9896,
-        "b": 1.410e-3,
-        "c": -2.049e-5,
-        "a'": 2.8029,
-        "b'": -7.9648,
-        "c'": 11.8445,
-        "d'": -5.9568,
-    },
-    "A14": {
-        "a": 0.9285,
-        "b": 2.706e-3,
-        "c": -2.599e-5,
-        "a'": 5.4677,
-        "b'": -19.1795,
-        "c'": 27.4542,
-        "d'": -13.1336,
-    },
-    "T14": {
-        "a": 0.9622,
-        "b": 2.009e-3,
-        "c": -2.401e-5,
-        "a'": 4.9690,
-        "b'": -17.1074,
-        "c'": 24.6292,
-        "d'": -11.8877,
-    },
-    "A14SL": {
-        "a": 0.9017,
-        "b": 3.454e-3,
-        "c": -3.083e-5,
-        "a'": 5.1205,
-        "b'": -17.7884,
-        "c'": 25.6123,
-        "d'": -12.3232,
-    },
-    "A16": {
-        "a": 0.8367,
-        "b": 4.987e-3,
-        "c": -3.877e-5,
-        "a'": 6.0571,
-        "b'": -21.7829,
-        "c'": 31.2289,
-        "d'": -14.9168,
-    },
-    # PTW
-    "30010": {
-        "a": 1.0093,
-        "b": 0.926e-3,
-        "c": -1.771e-5,
-        "a'": 2.5318,
-        "b'": -6.7948,
-        "c'": 10.1779,
-        "d'": -5.1746,
-    },
-    "30011": {
-        "a": 0.9676,
-        "b": 2.061e-3,
-        "c": -2.528e-5,
-        "a'": 2.9044,
-        "b'": -8.4576,
-        "c'": 12.6339,
-        "d'": -6.3742,
-    },
-    "30012": {
-        "a": 0.9537,
-        "b": 2.440e-3,
-        "c": -2.750e-5,
-        "a'": 3.2836,
-        "b'": -10.0610,
-        "c'": 14.8867,
-        "d'": -7.4212,
-    },
-    "30013": {
-        "a": 0.9652,
-        "b": 2.141e-3,
-        "c": -2.623e-5,
-        "a'": 3.2012,
-        "b'": -9.7211,
-        "c'": 14.4211,
-        "d'": -7.2184,
-    },
-    "31010": {
-        "a": 0.9590,
-        "b": 2.265e-3,
-        "c": -2.684e-5,
-        "a'": 3.1578,
-        "b'": -9.5422,
-        "c'": 14.1676,
-        "d'": -7.0964,
-    },
-    "31016": {
-        "a": 1.0085,
-        "b": 1.028e-3,
-        "c": -1.968e-5,
-        "a'": 2.9524,
-        "b'": -8.6054,
-        "c'": 12.7757,
-        "d'": -6.4265,
-    },
-    "31014": {
-        "a": 1.0071,
-        "b": 1.048e-3,
-        "c": -1.967e-5,
-        "a'": 3.0178,
-        "b'": -8.8735,
-        "c'": 13.1372,
-        "d'": -6.5867,
-    },
-    # IBA
-    "CC25": {
-        "a": 0.9551,
-        "b": 2.353e-3,
-        "c": -2.687e-5,
-        "a'": 2.4567,
-        "b'": -6.5932,
-        "c'": 10.0471,
-        "d'": -5.1775,
-    },
-    "CC13": {
-        "a": 0.9515,
-        "b": 2.455e-3,
-        "c": -2.768e-5,
-        "a'": 3.1982,
-        "b'": -9.7182,
-        "c'": 14.4210,
-        "d'": -7.2121,
-    },
-    "CC08": {
-        "a": 0.9430,
-        "b": 2.637e-3,
-        "c": -2.884e-5,
-        "a'": 3.7328,
-        "b'": -11.9800,
-        "c'": 17.5884,
-        "d'": -8.6843,
-    },
-    "CC04": {
-        "a": 0.9714,
-        "b": 1.938e-3,
-        "c": -2.432e-5,
-        "a'": 3.0054,
-        "b'": -8.8633,
-        "c'": 13.1704,
-        "d'": -6.6075,
-    },
-    "CC01": {
-        "a": 0.9116,
-        "b": 3.358e-3,
-        "c": -3.177e-5,
-        "a'": 4.3376,
-        "b'": -14.4935,
-        "c'": 21.0293,
-        "d'": -10.2208,
-    },
-    "FC65-G": {
-        "a": 0.9708,
-        "b": 1.972e-3,
-        "c": -2.480e-5,
-        "a'": 3.3221,
-        "b'": -10.2012,
-        "c'": 15.0497,
-        "d'": -7.4872,
-    },
-    "FC65-P": {
-        "a": 0.9828,
-        "b": 1.664e-3,
-        "c": -2.296e-5,
-        "a'": 3.0872,
-        "b'": -9.1919,
-        "c'": 13.6137,
-        "d'": -6.8118,
-    },
-    "FC23-C": {
-        "a": 0.9820,
-        "b": 1.579e-3,
-        "c": -2.166e-5,
-        "a'": 3.0511,
-        "b'": -9.0243,
-        "c'": 13.3378,
-        "d'": -6.6559,
-    },
-    # Other
-    "NE2581": {
-        "a": 1.0318,
-        "b": 0.488e-3,
-        "c": -1.731e-5,
-        "a'": 2.9190,
-        "b'": -8.4561,
-        "c'": 12.5690,
-        "d'": -6.3468,
-    },
-    "NE2571": {
-        "a": 0.9882,
-        "b": 1.486e-3,
-        "c": -2.140e-5,
-        "a'": 2.2328,
-        "b'": -5.5779,
-        "c'": 8.5325,
-        "d'": -4.4352,
-    },
-    "NE2561": {
-        "a": 1.0200,
-        "b": 0.596e-3,
-        "c": -1.551e-5,
-        "a'": 2.4235,
-        "b'": -6.3179,
-        "c'": 9.4737,
-        "d'": -4.8307,
-    },
-    "PR06C/G": {
-        "a": 0.9519,
-        "b": 2.432e-3,
-        "c": -2.704e-5,
-        "a'": 2.9110,
-        "b'": -8.4916,
-        "c'": 12.6817,
-        "d'": -6.3874,
-    },
-}
-
-KQ_ELECTRONS = {
-    # Exradin
-    "A12": {"kQ,ecal": 0.907, "a": 0.965, "b": 0.119, "c": 0.607},
-    "A19": {"kQ,ecal": 0.904, "a": 0.957, "b": 0.119, "c": 0.505},
-    "A12S": {"kQ,ecal": 0.907, "a": 0.937, "b": 0.136, "c": 0.378},
-    "A18": {"kQ,ecal": 0.914, "a": 0.352, "b": 0.711, "c": 0.046},
-    "A1SL": {"kQ,ecal": 0.914, "a": 0.205, "b": 0.854, "c": 0.036},
-    # PTW
-    "30010": {"kQ,ecal": 0.904, "a": 0.980, "b": 0.119, "c": 0.891},
-    "30011": {"kQ,ecal": 0.901, "a": 0.976, "b": 0.120, "c": 0.793},
-    "30012": {"kQ,ecal": 0.908, "a": 0.972, "b": 0.121, "c": 0.728},
-    "30013": {"kQ,ecal": 0.901, "a": 0.978, "b": 0.112, "c": 0.816},
-    "31013": {"kQ,ecal": 0.902, "a": 0.945, "b": 0.133, "c": 0.441},
-    # IBA
-    "FC65-G": {"kQ,ecal": 0.904, "a": 0.971, "b": 0.113, "c": 0.680},
-    "FC65-P": {"kQ,ecal": 0.902, "a": 0.973, "b": 0.110, "c": 0.692},
-    "FC23-C": {"kQ,ecal": 0.904, "a": 0.971, "b": 0.097, "c": 0.591},
-    "CC25": {"kQ,ecal": 0.904, "a": 0.964, "b": 0.105, "c": 0.539},
-    "CC13": {"kQ,ecal": 0.904, "a": 0.926, "b": 0.129, "c": 0.279},
-    # Other
-    "PR06C/G": {"kQ,ecal": 0.906, "a": 0.972, "b": 0.122, "c": 0.729},
-    "NE2571": {"kQ,ecal": 0.903, "a": 0.977, "b": 0.117, "c": 0.817},
-    "NE2611": {"kQ,ecal": 0.896, "a": 0.979, "b": 0.120, "c": 0.875},
-}
-
-LEAD_OPTIONS = {"None": None, "30cm": "30cm", "50cm": "50cm"}
-
-
-def mmHg2kPa(mmHg: float) -> float:
-    """Utility function to convert from mmHg to kPa."""
-    return mmHg * 101.33 / 760
-
-
-def mbar2kPa(mbar: float) -> float:
-    """Utility function to convert from millibars to kPa."""
-    return mbar / 10
-
-
-def fahrenheit2celsius(f: float) -> float:
-    """Utility function to convert from Fahrenheit to Celsius."""
-    return (f - 32) * 5 / 9
-
-
-@argue.bounds(pdd2010=(0.5, 1))
-def tpr2010_from_pdd2010(*, pdd2010: float) -> float:
-    """Calculate TPR20,10 from PDD20,10. From TRS-398 footnote 25, section 6.3.1, p.68 (https://www-pub.iaea.org/MTCD/Publications/PDF/TRS398_scr.pdf),
-    and Followill et al 1998 eqn 1."""
-    return 1.2661 * pdd2010 - 0.0595
-
-
-def p_tp(*, temp: float, press: float) -> float:
-    """Calculate the temperature & pressure correction.
-
-    Parameters
-    ----------
-    temp : float (17-27)
-        The temperature in degrees Celsius.
-    press : float (91-111)
-        The value of pressure in kPa. Can be converted from mmHg and mbar;
-        see :func:`~pylinac.calibration.tg51.mmHg2kPa` and :func:`~pylinac.calibration.tg51.mbar2kPa`.
-    """
-    argue.verify_bounds(
-        temp,
-        bounds=(MIN_TEMP, MAX_TEMP),
-        message="Temperature {:2.2f} out of range. Did you use Fahrenheit? Consider using the utility function fahrenheit2celsius()",
-    )
-    argue.verify_bounds(
-        press,
-        bounds=(MIN_PRESSURE, MAX_PRESSURE),
-        message="Pressure {:2.2f} out of range. Did you use kPa? Consider using the utility functions mmHg2kPa() or mbar2kPa()",
-    )
-    return ((273.2 + temp) / 295.2) * (101.33 / press)
-
-
-def p_pol(*, m_reference: NumberOrArray, m_opposite: NumberOrArray) -> float:
-    """Calculate the polarity correction.
-
-    Parameters
-    ----------
-    m_reference : number, array
-        The readings of the ion chamber at the reference polarity and voltage.
-    m_opposite : number, array
-        The readings of the ion chamber at the polarity opposite the reference. The sign does not make a difference.
-
-    Raises
-    ------
-    BoundsError if calculated Ppol is >1% from 1.0.
-    """
-    mref_avg = np.mean(m_reference)
-    mopp_avg = np.mean(m_opposite)
-    polarity = (abs(mref_avg) + abs(mopp_avg)) / abs(2 * mref_avg)
-    argue.verify_bounds(
-        polarity,
-        bounds=(MIN_PPOL, MAX_PPOL),
-        message="Polarity correction {:2.2f} out of range (+/-2%). Verify inputs",
-    )
-    return float(polarity)
-
-
-def p_ion(
-    *,
-    voltage_reference: int,
-    voltage_reduced: int,
-    m_reference: NumberOrArray,
-    m_reduced: NumberOrArray,
-) -> float:
-    """Calculate the ion chamber collection correction.
-
-    Parameters
-    ----------
-    voltage_reference : int
-        The "high" voltage; same as the TG51 measurement voltage.
-    voltage_reduced : int
-        The "low" voltage; usually half of the high voltage.
-    m_reference : float, iterable
-        The readings of the ion chamber at the "high" voltage.
-    m_reduced : float, iterable
-        The readings of the ion chamber at the "low" voltage.
-
-    Raises
-    ------
-    BoundsError if calculated Pion is outside the range 1.00-1.05.
-    """
-    ion = (1 - voltage_reference / voltage_reduced) / (
-        np.mean(m_reference) / np.mean(m_reduced) - voltage_reference / voltage_reduced
-    )
-    argue.verify_bounds(
-        ion,
-        bounds=(MIN_PION, MAX_PION),
-        message="Pion out of range (1.00-1.05). Check inputs or chamber",
-    )
-    return float(ion)
-
-
-def d_ref(*, i_50: float) -> float:
-    """Calculate the dref of an electron beam based on the I50 depth.
-
-    Parameters
-    ----------
-    i_50 : float
-        The value of I50 in cm.
-    """
-    argue.verify_bounds(i_50, bounds=argue.POSITIVE, message="i50 should be positive")
-    r50 = r_50(i_50=i_50)
-    return 0.6 * r50 - 0.1
-
-
-def r_50(*, i_50: float) -> float:
-    """Calculate the R50 depth of an electron beam based on the I50 depth.
-
-    Parameters
-    ----------
-    i_50 : float
-        The value of I50 in cm.
-    """
-    argue.verify_bounds(i_50, bounds=argue.POSITIVE, message="i50 should be positive")
-    if i_50 < 10:
-        r50 = 1.029 * i_50 - 0.06
-    else:
-        r50 = 1.59 * i_50 - 0.37
-    return r50
-
-
-def kp_r50(*, r_50: float) -> float:
-    """Calculate k'R50 for Farmer-like chambers.
-
-    Parameters
-    ----------
-    r_50 : float (2-9)
-        The R50 value in cm.
-    """
-    argue.verify_bounds(r_50, bounds=(2, 9))
-    return 0.9905 + 0.071 * np.exp(-r_50 / 3.67)
-
-
-def pq_gr(*, m_dref_plus: NumberOrArray, m_dref: NumberOrArray) -> float:
-    """Calculate PQ_gradient for a cylindrical chamber.
-
-    Parameters
-    ----------
-    m_dref_plus : float, iterable
-        The readings of the ion chamber at dref + 0.5rcav.
-    m_dref : float, iterable
-        The readings of the ion chamber at dref.
-    """
-    return float(np.mean(m_dref_plus) / np.mean(m_dref))
-
-
-def m_corrected(
-    *,
-    p_ion: float,
-    p_tp: float,
-    p_elec: float,
-    p_pol: float,
-    m_reference: NumberOrArray,
-) -> float:
-    """Calculate M_corrected, the ion chamber reading with all corrections applied.
-
-    Parameters
-    ----------
-    p_ion : float (1.00-1.05)
-        The ion collection correction.
-    p_tp : float (0.92-1.08)
-        The temperature & pressure correction.
-    p_elec : float (0.98-1.02)
-        The electrometer correction.
-    p_pol : float (0.98-1.02)
-        The polarity correction.
-    m_reference : float, iterable
-        The raw ion chamber reading(s).
-
-    Returns
-    -------
-    float
-    """
-    argue.verify_bounds(p_ion, bounds=(MIN_PION, MAX_PION))
-    argue.verify_bounds(p_tp, bounds=(MIN_PTP, MAX_PTP))
-    argue.verify_bounds(p_elec, bounds=(MIN_PELEC, MAX_PELEC))
-    argue.verify_bounds(p_pol, bounds=(MIN_PPOL, MAX_PPOL))
-    return float(p_ion * p_tp * p_elec * p_pol * np.mean(m_reference))
-
-
-@argue.bounds(pdd=(62.7, 89.0))
-@argue.options(lead_foil=LEAD_OPTIONS.values())
-def pddx(*, pdd: float, energy: int, lead_foil: Optional[str] = None) -> float:
-    """Calculate PDDx based on the PDD.
-
-    Parameters
-    ----------
-    pdd : {>62.7, <89.0}
-        The measured PDD. If lead foil was used, this assumes the pdd as measured with the lead in place.
-    energy : int
-        The nominal energy in MV.
-    lead_foil : {None, '30cm', '50cm'}
-        Applicable only for energies >10MV.
-        Whether a lead foil was used to acquire the pdd.
-        Use ``None`` if no lead foil was used and the interim equation should be used. This is the default
-        Use ``50cm`` if the lead foil was set to 50cm from the phantom surface.
-        Use ``30cm`` if the lead foil was set to 30cm from the phantom surface.
-    """
-    if energy < 10:
-        return pdd
-    elif energy >= 10:
-        if lead_foil is None:
-            if pdd <= 75:
-                return pdd
-            elif 75 < pdd <= 89:
-                return 1.267 * pdd - 20
-            else:
-                raise ValueError(f"PDD value of {pdd} was outside the bound of 89%")
-        elif lead_foil == LEAD_OPTIONS["50cm"]:
-            if pdd < 73:
-                return pdd
-            else:
-                return (0.8905 + 0.0015 * pdd) * pdd
-        elif lead_foil == LEAD_OPTIONS["30cm"]:
-            if pdd < 71:
-                return pdd
-            else:
-                return (0.8116 + 0.00264 * pdd) * pdd
-
-
-@argue.bounds(pddx=(63.0, 86.0))
-@argue.options(chamber=KQ_PHOTONS.keys())
-def kq_photon_pddx(*, chamber: str, pddx: float) -> float:
-    """Calculate kQ based on the chamber and clinical measurements of PDD(10)x. This will calculate kQ for photons
-    for *CYLINDRICAL* chambers only.
-
-    Parameters
-    ----------
-    chamber : str
-        The chamber of the chamber. Valid values are those listed in
-        Table III of Muir and Rogers and Table I of the TG-51 Addendum.
-    pddx : {>63.0, <86.0}
-        The **PHOTON-ONLY** PDD measurement at 10cm depth for a 10x10cm2 field.
-
-        .. note:: Use the :func:`~pylinac.calibration.tg51.pddx` function to convert PDD to PDDx as needed.
-
-        .. note:: Muir and Rogers state limits of 0.627 - 0.861. The TG-51 addendum states them as 0.63 and 0.86.
-                  The TG-51 addendum limits are used here.
-    """
-    ch = KQ_PHOTONS[chamber]
-    return ch["a"] + ch["b"] * pddx + ch["c"] * (pddx**2)
-
-
-@argue.bounds(tpr=(0.623, 0.805))
-@argue.options(chamber=KQ_PHOTONS.keys())
-def kq_photon_tpr(*, chamber: str, tpr: float) -> float:
-    """Calculate kQ based on the chamber and clinical measurements of TPR20,10. This will calculate kQ for photons
-    for *CYLINDRICAL* chambers only.
-
-    Parameters
-    ----------
-    chamber : str
-        The chamber of the chamber. Valid values are those listed in
-        Table III of Muir and Rogers and Table I of the TG-51 Addendum.
-    tpr : {>0.630, <0.860}
-        The TPR(20,10) value.
-
-        .. note::
-         Use the :func:`~pylinac.calibration.tg51.tpr2010_from_pdd2010` function to convert from PDD without needing to take TPR measurements.
-    """
-    ch = KQ_PHOTONS[chamber]
-    return ch["a'"] + ch["b'"] * tpr + ch["c'"] * (tpr**2) + ch["d'"] * (tpr**3)
-
-
-@argue.options(chamber=KQ_ELECTRONS.keys())
-def kq_electron(*, chamber: str, r_50: float) -> float:
-    """Calculate kQ based on the chamber and clinical measurements. This will calculate kQ for electrons
-    for *CYLINDRICAL* chambers only according to Muir & Rogers.
-
-    Parameters
-    ----------
-    chamber : str
-        The chamber of the chamber. Valid values are those listed in
-        Tables VI and VII of Muir and Rogers 2014.
-    r_50 : float
-        The R50 value in cm of an electron beam.
-    """
-    ch = KQ_ELECTRONS[chamber]
-    return (ch["a"] + ch["b"] * r_50 ** -ch["c"]) * ch["kQ,ecal"]
-
-
-class TG51Base(Structure):
-    @property
-    def p_tp(self) -> float:
-        """Temperature/Pressure correction."""
-        return p_tp(temp=self.temp, press=self.press)
-
-    @property
-    def p_ion(self) -> float:
-        """Ionization collection correction."""
-        return p_ion(
-            voltage_reference=self.voltage_reference,
-            voltage_reduced=self.voltage_reduced,
-            m_reference=self.m_reference,
-            m_reduced=self.m_reduced,
-        )
-
-    @property
-    def p_pol(self) -> float:
-        """Polarity correction."""
-        return p_pol(m_reference=self.m_reference, m_opposite=self.m_opposite)
-
-    @property
-    def m_corrected(self) -> float:
-        """Corrected chamber reading."""
-        return m_corrected(
-            p_ion=self.p_ion,
-            p_tp=self.p_tp,
-            p_elec=self.p_elec,
-            p_pol=self.p_pol,
-            m_reference=self.m_reference,
-        )
-
-    @property
-    def m_corrected_adjustment(self) -> float:
-        """Corrected chamber reading after adjusting the output."""
-        if self.m_reference_adjusted is not None:
-            return m_corrected(
-                p_ion=self.p_ion,
-                p_tp=self.p_tp,
-                p_elec=self.p_elec,
-                p_pol=self.p_pol,
-                m_reference=self.m_reference_adjusted,
-            )
-
-    @property
-    def output_was_adjusted(self) -> float:
-        """Boolean specifiying if output was adjusted."""
-        return self.m_reference_adjusted is not None
-
-
-class TG51Photon(TG51Base):
-    """Class for calculating absolute dose to water using a cylindrical chamber in a photon beam.
-
-    Parameters
-    ----------
-    institution : str
-        Institution name.
-    physicist : str
-        Physicist performing calibration.
-    unit : str
-        Unit name; e.g. TrueBeam1.
-    measurement_date : str
-        Date of measurement. E.g. 10/22/2018.
-    temp : float
-        The temperature in Celsius. Use :func:`~pylinac.calibration.tg51.fahrenheit2celsius` to convert if necessary.
-    press : float
-        The value of pressure in kPa. Can be converted from mmHg and mbar; see :func:`~pylinac.calibration.tg51.mmHg2kPa` and :func:`~pylinac.calibration.tg51.mbar2kPa`.
-    energy : float
-        Nominal energy of the beam in MV.
-    chamber : str
-        Chamber model. Must be one of the listed chambers in TG-51 Addendum.
-    n_dw : float
-        NDW value in Gy/nC.
-    p_elec : float
-        Electrometer correction factor; given by the calibration laboratory.
-    measured_pdd10 : float
-        The measured value of PDD(10); will be converted to PDDx(10) and used for calculating kq.
-    lead_foil : {None, '50cm', '30cm'}
-        Whether a lead foil was used to acquire PDD(10)x and where its position was. Used to calculate kq.
-    clinical_pdd10 : float
-        The PDD used to correct the dose at 10cm back to dmax. Usually the TPS PDD(10) value.
-    voltage_reference : int
-        Reference voltage; i.e. voltage when taking the calibration measurement.
-    voltage_reduced : int
-        Reduced voltage; usually half of the reference voltage.
-    m_reference : float, tuple
-        Ion chamber reading(s) at the reference voltage.
-    m_opposite : float, tuple
-        Ion chamber reading(s) at the opposite voltage of reference.
-    m_reduced : float, tuple
-        Ion chamber reading(s) at the reduced voltage.
-    mu : int
-        The MU delivered to measure the reference reading. E.g. 200.
-    fff : bool
-        Whether the beam is FFF or flat.
-    tissue_correction : float
-        Correction value to calibration to, e.g., muscle. A value of 1.0 means no correction (i.e. water).
-    """
-
-    @argue.options(chamber=KQ_PHOTONS.keys(), lead_foil=LEAD_OPTIONS.values())
-    def __init__(
-        self,
-        *,
-        institution: str = "",
-        physicist: str = "",
-        unit: str,
-        measurement_date: str = "",
-        temp: float,
-        press: float,
-        chamber: str,
-        n_dw: float,
-        p_elec: float,
-        electrometer: str = "",
-        measured_pdd10: Optional[float] = None,
-        lead_foil: Optional[str] = None,
-        clinical_pdd10: float,
-        energy: int,
-        fff: bool = False,
-        voltage_reference: int,
-        voltage_reduced: int,
-        m_reference: NumberOrArray,
-        m_opposite: NumberOrArray,
-        m_reduced: NumberOrArray,
-        mu: int,
-        tissue_correction: float = 1.0,
-        m_reference_adjusted: Optional[NumberOrArray] = None,
-    ):
-        super().__init__(
-            temp=temp,
-            press=press,
-            chamber=chamber,
-            n_dw=n_dw,
-            p_elec=p_elec,
-            measured_pdd10=measured_pdd10,
-            energy=energy,
-            voltage_reference=voltage_reference,
-            voltage_reduced=voltage_reduced,
-            m_reference=m_reference,
-            m_opposite=m_opposite,
-            m_reduced=m_reduced,
-            clinical_pdd10=clinical_pdd10,
-            mu=mu,
-            tissue_correction=tissue_correction,
-            lead_foil=lead_foil,
-            electrometer=electrometer,
-            m_reference_adjusted=m_reference_adjusted,
-            institution=institution,
-            physicist=physicist,
-            unit=unit,
-            measurement_date=measurement_date,
-            fff=fff,
-        )
-        # add check for tpr vs pdd
-
-    @property
-    def pddx(self) -> float:
-        """The photon-only PDD(10) value."""
-        return pddx(
-            pdd=self.measured_pdd10, energy=self.energy, lead_foil=self.lead_foil
-        )
-
-    @property
-    def kq(self) -> float:
-        """The chamber-specific beam quality correction factor."""
-        return kq_photon_pddx(chamber=self.chamber, pddx=self.pddx)
-
-    @property
-    def dose_mu_10(self) -> float:
-        """cGy/MU at a depth of 10cm."""
-        return self.tissue_correction * self.m_corrected * self.kq * self.n_dw / self.mu
-
-    @property
-    def dose_mu_dmax(self) -> float:
-        """cGy/MU at a depth of dmax."""
-        return self.dose_mu_10 / (self.clinical_pdd10 / 100)
-
-    @property
-    def dose_mu_10_adjusted(self) -> float:
-        """The dose/mu at 10cm depth after adjustment."""
-        return (
-            self.tissue_correction
-            * self.m_corrected_adjustment
-            * self.kq
-            * self.n_dw
-            / self.mu
-        )
-
-    @property
-    def dose_mu_dmax_adjusted(self) -> float:
-        """The dose/mu at dmax depth after adjustment."""
-        return self.dose_mu_10_adjusted / (self.clinical_pdd10 / 100)
-
-    def publish_pdf(
-        self,
-        filename: str,
-        notes: Optional[list] = None,
-        open_file: bool = False,
-        metadata: Optional[dict] = None,
-    ):
-        """Publish (print) a PDF containing the analysis and quantitative results.
-
-        Parameters
-        ----------
-        filename : str, file-like object
-            The file to write the results to.
-        notes : str, list
-            Any notes to be added to the report. If a string, adds everything as one line.
-            If a list, must be a list of strings; each string item will be a new line.
-        open_file : bool
-            Whether to open the file after creation. Will use the default PDF program.
-        metadata : dict
-            Any data that should be appended to every page of the report. This differs from notes in that
-            metadata is at the top of every page while notes is at the bottom of the report.
-        """
-        was_adjusted = "Yes" if self.output_was_adjusted else "No"
-        title = [
-            "TG-51 Photon Report",
-            f"{self.unit} - {self.energy} MV{' FFF' if self.fff else ''}",
-        ]
-
-        canvas = PylinacCanvas(filename, page_title=title, metadata=metadata)
-        text = [
-            "Site Data:",
-            f"Institution: {self.institution}",
-            f"Performed by: {self.physicist}",
-            f"Measurement Date: {self.measurement_date}",
-            f'Date of Report: {datetime.now().strftime("%A, %B %d, %Y")}',
-            f"Unit: {self.unit}",
-            f"Energy: {self.energy} MV {'FFF' if self.fff else ''}",
-            "",
-            "Instrumentation:",
-            f"Chamber: {self.chamber}",
-            f"Chamber Calibration Factor Ndw (cGy/nC): {self.n_dw:2.3f}",
-            f"Electrometer: {self.electrometer}",
-            f"Pelec: {self.p_elec:2.3f}",
-            f"MU: {self.mu}",
-            "",
-            "Beam Quality:",
-            f"Lead foil: {'No' if self.lead_foil is None else self.lead_foil}",
-            f"Measured PDD(10){'' if self.lead_foil is None else 'Pb'} {self.measured_pdd10:2.2f}",
-            f"Calculated PDD(10)x: {self.pddx:2.2f}",
-            f"Determined kQ: {self.kq:2.3f}",
-            "",
-            "Chamber Corrections/Measurements:",
-            f"Temperature (\N{DEGREE SIGN}C): {self.temp:2.1f}",
-            f"Pressure (kPa): {self.press:2.1f}",
-            f"Mraw @ ({self.voltage_reference}V, Reference) (nC): {self.m_reference}",
-            f"Mraw @ ({self.voltage_reduced}V, Reduced) (nC): {self.m_reduced}",
-            f"Mraw @ ({-self.voltage_reference}V, Opposite) (nC): {self.m_opposite}",
-            f"Ptp: {self.p_tp:2.3f}",
-            f"Pion: {self.p_ion:2.3f}",
-            f"Ppol: {self.p_pol:2.3f}",
-            "",
-            "Dose Determination:",
-            f"Fully corrected M (nC): {self.m_corrected:2.3f}",
-            f"Tissue correction (e.g. muscle): {self.tissue_correction:2.3f}",
-            f"Dose/MU @ 10cm depth (cGy): {self.dose_mu_10:2.3f}",
-            f"Clinical PDD (%): {self.clinical_pdd10:2.2f}",
-            f"Dose/MU @ dmax (cGy): {self.dose_mu_dmax:2.3f}",
-            "",
-            f"Output Adjustment?: {was_adjusted}",
-        ]
-        if was_adjusted == "Yes":
-            text.append(
-                f"Adjusted Mraw @ reference voltage (nC): {self.m_reference_adjusted}"
-            )
-            text.append(
-                f"Adjusted fully corrected M (nC): {self.m_corrected_adjustment:2.3f}"
-            )
-            text.append(
-                f"Adjusted Dose/MU @ 10cm depth (cGy): {self.dose_mu_10_adjusted:2.3f}"
-            )
-            text.append(
-                f"Adjusted Dose/MU @ dmax (cGy): {self.dose_mu_dmax_adjusted:2.3f}"
-            )
-        canvas.add_text(text=text, location=(2, 25.5), font_size=12)
-        if notes is not None:
-            canvas.add_text(text="Notes:", location=(12, 6.5), font_size=14)
-            canvas.add_text(text=notes, location=(12, 6))
-
-        canvas.finish()
-
-        if open_file:
-            webbrowser.open(filename)
-
-
-class TG51ElectronLegacy(TG51Base):
-    """Class for calculating absolute dose to water using a cylindrical chamber in an electron beam.
-
-    Parameters
-    ----------
-    institution : str
-        Institution name.
-    physicist : str
-        Physicist performing calibration.
-    unit : str
-        Unit name; e.g. TrueBeam1.
-    measurement_date : str
-        Date of measurement. E.g. 10/22/2018.
-    temp : float (17-27)
-        The temperature in degrees Celsius.
-    press : float (91-111)
-        The value of pressure in kPa. Can be converted from mmHg and mbar; see :func:`~pylinac.calibration.tg51.mmHg2kPa` and :func:`~pylinac.calibration.tg51.mbar2kPa`.
-    chamber : str
-        Chamber model; only for bookkeeping.
-    n_dw : float
-        NDW value in Gy/nC. Given by the calibration laboratory.
-    k_ecal : float
-        Kecal value which is chamber specific. This value is the major difference between the legacy class and modern class where no kecal is needed.
-    p_elec : float
-        Electrometer correction factor; given by the calibration laboratory.
-    clinical_pdd : float
-        The PDD used to correct the dose back to dref.
-    voltage_reference : float
-        Reference voltage; i.e. voltage when taking the calibration measurement.
-    voltage_reduced : float
-        Reduced voltage; usually half of the reference voltage.
-    m_reference : float, tuple
-        Ion chamber reading(s) at the reference voltage.
-    m_opposite : float, tuple
-        Ion chamber reading(s) at the opposite voltage of reference.
-    m_reduced : float, tuple
-        Ion chamber reading(s) at the reduced voltage.
-    mu : int
-        The MU delivered to measure the reference reading. E.g. 200.
-    i_50 : float
-        Depth of 50% ionization.
-    tissue_correction : float
-        Correction value to calibration to, e.g., muscle. A value of 1.0 means no correction (i.e. water).
-    """
-
-    def __init__(
-        self,
-        *,
-        institution: str = "",
-        physicist: str = "",
-        unit: str = "",
-        measurement_date: str = "",
-        energy: int,
-        temp: float,
-        press: float,
-        chamber: str,
-        k_ecal: float,
-        n_dw: float,
-        electrometer: str = "",
-        p_elec: float,
-        clinical_pdd: float,
-        voltage_reference: int,
-        voltage_reduced: int,
-        m_reference: NumberOrArray,
-        m_opposite: NumberOrArray,
-        m_reduced: NumberOrArray,
-        m_gradient: NumberOrArray,
-        cone: str,
-        mu: int,
-        i_50: float,
-        tissue_correction: float = 1.0,
-        m_reference_adjusted=None,
-    ):
-        super().__init__(
-            temp=temp,
-            press=press,
-            chamber=chamber,
-            n_dw=n_dw,
-            p_elec=p_elec,
-            voltage_reference=voltage_reference,
-            voltage_reduced=voltage_reduced,
-            m_reference=m_reference,
-            m_opposite=m_opposite,
-            m_reduced=m_reduced,
-            clinical_pdd=clinical_pdd,
-            mu=mu,
-            i_50=i_50,
-            tissue_correction=tissue_correction,
-            institution=institution,
-            physicist=physicist,
-            unit=unit,
-            measurement_date=measurement_date,
-            electrometer=electrometer,
-            m_reference_adjusted=m_reference_adjusted,
-            cone=cone,
-            energy=energy,
-            k_ecal=k_ecal,
-            m_gradient=m_gradient,
-        )
-
-    @property
-    def r_50(self) -> float:
-        """Depth of the 50% dose value."""
-        return r_50(i_50=self.i_50)
-
-    @property
-    def dref(self) -> float:
-        """Depth of the reference point."""
-        return d_ref(i_50=self.i_50)
-
-    @property
-    def pq_gr(self):
-        """Gradient factor"""
-        return pq_gr(m_dref_plus=self.m_gradient, m_dref=self.m_reference)
-
-    @property
-    def kq(self) -> float:
-        """The kQ value using classic TG-51"""
-        return self.k_ecal * kp_r50(r_50=self.r_50)
-
-    @property
-    def dose_mu_dref(self) -> float:
-        """cGy/MU at the depth of Dref."""
-        return (
-            self.tissue_correction
-            * self.m_corrected
-            * self.kq
-            * self.n_dw
-            * self.pq_gr
-            / self.mu
-        )
-
-    @property
-    def dose_mu_dmax(self) -> float:
-        """cGy/MU at the depth of dmax."""
-        return self.dose_mu_dref / (self.clinical_pdd / 100)
-
-    @property
-    def dose_mu_dref_adjusted(self) -> float:
-        """cGy/MU at the depth of Dref."""
-        return (
-            self.tissue_correction
-            * self.m_corrected_adjustment
-            * self.kq
-            * self.n_dw
-            * self.pq_gr
-            / self.mu
-        )
-
-    @property
-    def dose_mu_dmax_adjusted(self) -> float:
-        """cGy/MU at the depth of dmax."""
-        return self.dose_mu_dref_adjusted / (self.clinical_pdd / 100)
-
-    def publish_pdf(
-        self,
-        filename: str,
-        notes: Optional[list] = None,
-        open_file: bool = False,
-        metadata: Optional[dict] = None,
-    ):
-        """Publish (print) a PDF containing the analysis and quantitative results.
-
-        Parameters
-        ----------
-        filename : str, file-like object
-            The file to write the results to.
-        notes : str, list
-            Any notes to be added to the report. If a string, adds everything as one line.
-            If a list, must be a list of strings; each string item will be a new line.
-        open_file : bool
-            Whether to open the file after creation. Will use the default PDF program.
-        metadata : dict
-            Any data that should be appended to every page of the report. This differs from notes in that
-            metadata is at the top of every page while notes is at the bottom of the report.
-        """
-        was_adjusted = "Yes" if self.output_was_adjusted else "No"
-        title = ["TG-51 Electron Report (Legacy)", f"{self.unit} - {self.energy} MeV"]
-
-        canvas = PylinacCanvas(filename, page_title=title, metadata=metadata)
-        text = [
-            "Site Data:",
-            f"Institution: {self.institution}",
-            f"Performed by: {self.physicist}",
-            f"Measurement Date: {self.measurement_date}",
-            f'Date of Report: {datetime.now().strftime("%A, %B %d, %Y")}',
-            f"Unit: {self.unit}",
-            f"Energy: {self.energy} MeV",
-            f"Cone: {self.cone}",
-            f"MU: {self.mu}",
-            "",
-            "Instrumentation:",
-            f"Chamber chamber: {self.chamber}",
-            f"Chamber Calibration Factor Ndw (cGy/nC): {self.n_dw:2.3f}",
-            f"Electrometer: {self.electrometer}",
-            f"Pelec: {self.p_elec:2.2f}",
-            "",
-            "Beam Quality:",
-            f"I50 (cm): {self.i_50:2.2f}",
-            f"R50 (cm): {self.r_50:2.2f}",
-            f"Dref (cm): {self.dref:2.2f}",
-            f"Kecal: {self.k_ecal:2.3f}",
-            f"kQ: {self.kq:2.3f}",
-            "",
-            "Chamber Corrections/Measurements:",
-            f"Temperature (\N{DEGREE SIGN}C): {self.temp:2.1f}",
-            f"Pressure (kPa): {self.press:2.1f}",
-            f"Mraw @ ({self.voltage_reference}V, Reference) (nC): {self.m_reference}",
-            f"Mraw @ ({self.voltage_reduced}V, Reduced) (nC): {self.m_reduced}",
-            f"Mraw @ ({-self.voltage_reference}V, Opposite) (nC): {self.m_opposite}",
-            f"Ptp: {self.p_tp:2.3f}",
-            f"Pion: {self.p_ion:2.3f}",
-            f"Ppol: {self.p_pol:2.3f}",
-            f"Mraw @ Dref + 0.5rcav (nC): {self.m_gradient}",
-            "",
-            "Dose Determination:",
-            f"Fully corrected M (nC): {self.m_corrected:2.3f}",
-            f"Tissue correction (e.g. muscle): {self.tissue_correction:2.3f}",
-            f"Dose/MU @ Dref depth (cGy): {self.dose_mu_dref:2.3f}",
-            f"Clinical PDD (%): {self.clinical_pdd:2.2f}",
-            f"Dose/MU @ dmax (cGy): {self.dose_mu_dmax:2.3f}",
-            "",
-            f"Output Adjustment?: {was_adjusted}",
-        ]
-        if was_adjusted == "Yes":
-            text.append(
-                f"Adjusted Mraw @ reference voltage (nC): {self.m_reference_adjustment}"
-            )
-            text.append(
-                f"Adjusted fully corrected M (nC): {self.m_corrected_adjustment:2.3f}"
-            )
-            text.append(
-                f"Adjusted Dose/MU @ dref depth (cGy): {self.dose_mu_dref_adjusted:2.3f}"
-            )
-            text.append(
-                f"Adjusted Dose/MU @ dmax (cGy): {self.dose_mu_dmax_adjusted:2.3f}"
-            )
-        canvas.add_text(text=text, location=(2, 25.5), font_size=11)
-        if notes is not None:
-            canvas.add_text(text="Notes:", location=(12, 6.5), font_size=14)
-            canvas.add_text(text=notes, location=(12, 6))
-
-        canvas.finish()
-
-        if open_file:
-            webbrowser.open(filename)
-
-
-class TG51ElectronModern(TG51Base):
-    """Class for calculating absolute dose to water using a cylindrical chamber in an electron beam.
-
-    .. warning::
-        This class uses the values of Muir & Rogers. These values are likely to be included in the new TG-51
-        addendum, but are not official. The results can be up to 1% different. Physicists should use their own
-        judgement when deciding which class to use. To use a manual kecal value, Pgradient and the classic TG-51 equations use
-        the :class:`~pylinac.calibration.tg51.TG51ElectronLegacy` class.
-
-    Parameters
-    ----------
-    institution : str
-        Institution name.
-    physicist : str
-        Physicist performing calibration.
-    unit : str
-        Unit name; e.g. TrueBeam1.
-    measurement_date : str
-        Date of measurement. E.g. 10/22/2018.
-    press : float
-        The value of pressure in kPa. Can be converted from mmHg and mbar; see :func:`~pylinac.calibration.tg51.mmHg2kPa` and :func:`~pylinac.calibration.tg51.mbar2kPa`.
-    temp : float
-        The temperature in Celsius.
-    voltage_reference : int
-        The reference voltage; i.e. the voltage for the calibration reading (e.g. 300V).
-    voltage_reduced : int
-        The reduced voltage, usually a fraction of the reference voltage (e.g. 150V).
-    m_reference : array, float
-        The reading(s) of the chamber at reference voltage.
-    m_reduced : array, float
-        The reading(s) of the chamber at the reduced voltage.
-    m_opposite : array, float
-        The reading(s) of the chamber at the opposite voltage from reference. Sign of the reading does not matter.
-    chamber : str
-        Ion chamber model.
-    n_dw : float
-        NDW value in Gy/nC
-    p_elec : float
-        Electrometer correction given by the calibration laboratory.
-    clinical_pdd : float
-        The PDD used to correct the dose back to dref.
-    mu : int
-        MU delivered.
-    i_50 : float
-        Depth of 50% ionization
-    tissue_correction : float
-        Correction value to calibration to, e.g., muscle. A value of 1.0 means no correction (i.e. water).
-    """
-
-    def __init__(
-        self,
-        *,
-        institution: str = "",
-        physicist: str = "",
-        unit: str = "",
-        measurement_date: str = "",
-        energy: int,
-        temp: float,
-        press: float,
-        chamber: str,
-        n_dw: float,
-        electrometer: str = "",
-        p_elec: float,
-        clinical_pdd: float,
-        voltage_reference: int,
-        voltage_reduced: int,
-        m_reference: NumberOrArray,
-        m_opposite: NumberOrArray,
-        m_reduced: NumberOrArray,
-        cone: str,
-        mu: int,
-        i_50: float,
-        tissue_correction: float,
-        m_reference_adjusted=None,
-    ):
-        super().__init__(
-            temp=temp,
-            press=press,
-            chamber=chamber,
-            n_dw=n_dw,
-            p_elec=p_elec,
-            voltage_reference=voltage_reference,
-            voltage_reduced=voltage_reduced,
-            m_reference=m_reference,
-            m_opposite=m_opposite,
-            m_reduced=m_reduced,
-            clinical_pdd=clinical_pdd,
-            mu=mu,
-            i_50=i_50,
-            tissue_correction=tissue_correction,
-            institution=institution,
-            physicist=physicist,
-            unit=unit,
-            measurement_date=measurement_date,
-            electrometer=electrometer,
-            m_reference_adjusted=m_reference_adjusted,
-            cone=cone,
-            energy=energy,
-        )
-
-    @property
-    def r_50(self) -> float:
-        """Depth of the 50% dose value."""
-        return r_50(i_50=self.i_50)
-
-    @property
-    def dref(self) -> float:
-        """Depth of the reference point."""
-        return d_ref(i_50=self.i_50)
-
-    @property
-    def kq(self) -> float:
-        """The kQ value using the updated Muir & Rogers values from their 2014 paper, equation 11, or classically
-        if kecal is passed."""
-        return kq_electron(chamber=self.chamber, r_50=self.r_50)
-
-    @property
-    def dose_mu_dref(self) -> float:
-        """cGy/MU at the depth of Dref."""
-        return self.tissue_correction * self.m_corrected * self.kq * self.n_dw / self.mu
-
-    @property
-    def dose_mu_dmax(self) -> float:
-        """cGy/MU at the depth of dmax."""
-        return self.dose_mu_dref / (self.clinical_pdd / 100)
-
-    @property
-    def dose_mu_dref_adjusted(self) -> float:
-        """cGy/MU at the depth of Dref."""
-        return (
-            self.tissue_correction
-            * self.m_corrected_adjusted
-            * self.kq
-            * self.n_dw
-            / self.mu
-        )
-
-    @property
-    def dose_mu_dmax_adjusted(self) -> float:
-        """cGy/MU at the depth of dmax."""
-        return self.dose_mu_dref_adjusted / (self.clinical_pdd / 100)
-
-    def publish_pdf(
-        self,
-        filename: str,
-        notes: Optional[list] = None,
-        open_file: bool = False,
-        metadata: Optional[dict] = None,
-    ):
-        """Publish (print) a PDF containing the analysis and quantitative results.
-
-        Parameters
-        ----------
-        filename : str, file-like object
-            The file to write the results to.
-        notes : str, list
-            Any notes to be added to the report. If a string, adds everything as one line.
-            If a list, must be a list of strings; each string item will be a new line.
-        open_file : bool
-            Whether to open the file after creation. Will use the default PDF program.
-        metadata : dict
-            Any data that should be appended to every page of the report. This differs from notes in that
-            metadata is at the top of every page while notes is at the bottom of the report.
-        """
-        was_adjusted = "Yes" if self.output_was_adjusted else "No"
-        title = ["TG-51 Electron Report (Modern)", f"{self.unit} - {self.energy} MeV"]
-
-        canvas = PylinacCanvas(filename, page_title=title, metadata=metadata)
-        text = [
-            "Site Data:",
-            f"Institution: {self.institution}",
-            f"Performed by: {self.physicist}",
-            f"Measurement Date: {self.measurement_date}",
-            f'Date of Report: {datetime.now().strftime("%A, %B %d, %Y")}',
-            f"Unit: {self.unit}",
-            f"Energy: {self.energy} MeV",
-            f"Cone: {self.cone}",
-            f"MU: {self.mu}",
-            "",
-            "Instrumentation:",
-            f"Chamber: {self.chamber}",
-            f"Chamber Calibration Factor Ndw (cGy/nC): {self.n_dw:2.3f}",
-            f"Electrometer: {self.electrometer}",
-            f"Pelec: {self.p_elec:2.2f}",
-            "",
-            "Beam Quality:",
-            f"I50 (cm): {self.i_50:2.2f}",
-            f"R50 (cm): {self.r_50:2.2f}",
-            f"Dref (cm): {self.dref:2.2f}",
-            f"Calculated kQ: {self.kq:2.3f}",
-            "",
-            "Chamber Corrections/Measurements:",
-            f"Temperature (\N{DEGREE SIGN}C): {self.temp:2.1f}",
-            f"Pressure (kPa): {self.press:2.1f}",
-            f"Mraw @ ({self.voltage_reference}V, Reference) (nC): {self.m_reference}",
-            f"Mraw @ ({self.voltage_reduced}V, Reduced) (nC): {self.m_reduced}",
-            f"Mraw @ ({-self.voltage_reference}V, Opposite) (nC): {self.m_opposite}",
-            f"Ptp: {self.p_tp:2.3f}",
-            f"Pion: {self.p_ion:2.3f}",
-            f"Ppol: {self.p_pol:2.3f}",
-            "",
-            "Dose Determination:",
-            f"Fully corrected M (nC): {self.m_corrected:2.3f}",
-            f"Tissue correction (e.g. muscle): {self.tissue_correction:2.3f}",
-            f"Dose/MU @ Dref depth (cGy): {self.dose_mu_dref:2.3f}",
-            f"Clinical PDD (%): {self.clinical_pdd:2.2f}",
-            f"Dose/MU @ dmax (cGy): {self.dose_mu_dmax:2.3f}",
-            "",
-            f"Output Adjustment?: {was_adjusted}",
-        ]
-        if was_adjusted == "Yes":
-            text.append(
-                f"Adjusted corrected M @ reference voltage (nC): {self.m_corrected_adjustment}"
-            )
-            text.append(
-                f"Adjusted fully corrected M (nC): {self.m_corrected_adjustment:2.3f}"
-            )
-            text.append(
-                f"Adjusted Dose/MU @ dref depth (cGy): {self.dose_mu_dref_adjusted:2.3f}"
-            )
-            text.append(
-                f"Adjusted Dose/MU @ dmax (cGy): {self.dose_mu_dmax_adjusted:2.3f}"
-            )
-        canvas.add_text(text=text, location=(2, 25.5), font_size=11)
-        if notes is not None:
-            canvas.add_text(text="Notes:", location=(12, 6.5), font_size=14)
-            canvas.add_text(text=notes, location=(12, 6))
-
-        canvas.finish()
-
-        if open_file:
-            webbrowser.open(filename)
+"""
+The TG-51 module contains a number of helper functions and classes that can calculate parameters for performing the
+TG-51 absolute linac dose calibration although there are some modifications from the original TG-51. The modifications
+include updated kQ and kecal values from Muir and Rogers' set of papers.
+Functions include all relevant calculations for TG-51 including PDDx, kQ,
+Dref, and chamber reading corrections. Where Muir & Rogers' values/equations are used they are specified in the documentation.
+
+Classes include photon and electron calibrations using cylindrical chambers. Pass all the relevant raw measurements
+and the class will compute all corrections and corrected readings and dose at 10cm and dmax/dref.
+"""
+import webbrowser
+from datetime import datetime
+from typing import Optional
+
+import argue
+import numpy as np
+
+from ..core.pdf import PylinacCanvas
+from ..core.typing import NumberOrArray
+from ..core.utilities import Structure
+
+MIN_TEMP = 15
+MAX_TEMP = 35
+MIN_PRESSURE = 90
+MAX_PRESSURE = 115
+MIN_PION = 1
+MAX_PION = 1.05
+MIN_PTP = 0.9
+MAX_PTP = 1.1
+MIN_PELEC = 0.98
+MAX_PELEC = 1.02
+MIN_PPOL = 0.98
+MAX_PPOL = 1.02
+
+
+KQ_PHOTONS = {
+    # Exradin
+    "A12": {
+        "a": 1.0146,
+        "b": 0.777e-3,
+        "c": -1.666e-5,
+        "a'": 2.6402,
+        "b'": -7.2304,
+        "c'": 10.7573,
+        "d'": -5.4294,
+    },
+    "A19": {
+        "a": 0.9934,
+        "b": 1.384e-3,
+        "c": -2.125e-5,
+        "a'": 3.0907,
+        "b'": -9.1930,
+        "c'": 13.5957,
+        "d'": -6.7969,
+    },
+    "A2": {
+        "a": 0.9819,
+        "b": 1.609e-3,
+        "c": -2.184e-5,
+        "a'": 2.8458,
+        "b'": -8.1619,
+        "c'": 12.1411,
+        "d'": -6.1041,
+    },
+    "T2": {
+        "a": 1.0173,
+        "b": 0.854e-3,
+        "c": -1.941e-5,
+        "a'": 3.3433,
+        "b'": -10.2649,
+        "c'": 15.1247,
+        "d'": -7.5415,
+    },
+    "A12S": {
+        "a": 0.9692,
+        "b": 1.974e-3,
+        "c": -2.448e-5,
+        "a'": 2.9597,
+        "b'": -8.6777,
+        "c'": 12.9155,
+        "d'": -6.4903,
+    },
+    "A18": {
+        "a": 0.9944,
+        "b": 1.286e-3,
+        "c": -1.980e-5,
+        "a'": 2.5167,
+        "b'": -6.7567,
+        "c'": 10.1519,
+        "d'": -5.1709,
+    },
+    "A1": {
+        "a": 1.0029,
+        "b": 1.023e-3,
+        "c": -1.803e-5,
+        "a'": 2.0848,
+        "b'": -4.9174,
+        "c'": 7.5446,
+        "d'": -3.9441,
+    },
+    "T1": {
+        "a": 1.0552,
+        "b": -0.196e-3,
+        "c": -1.275e-5,
+        "a'": 2.8060,
+        "b'": -7.9273,
+        "c'": 11.7541,
+        "d'": -5.9263,
+    },
+    "A1SL": {
+        "a": 0.9896,
+        "b": 1.410e-3,
+        "c": -2.049e-5,
+        "a'": 2.8029,
+        "b'": -7.9648,
+        "c'": 11.8445,
+        "d'": -5.9568,
+    },
+    "A14": {
+        "a": 0.9285,
+        "b": 2.706e-3,
+        "c": -2.599e-5,
+        "a'": 5.4677,
+        "b'": -19.1795,
+        "c'": 27.4542,
+        "d'": -13.1336,
+    },
+    "T14": {
+        "a": 0.9622,
+        "b": 2.009e-3,
+        "c": -2.401e-5,
+        "a'": 4.9690,
+        "b'": -17.1074,
+        "c'": 24.6292,
+        "d'": -11.8877,
+    },
+    "A14SL": {
+        "a": 0.9017,
+        "b": 3.454e-3,
+        "c": -3.083e-5,
+        "a'": 5.1205,
+        "b'": -17.7884,
+        "c'": 25.6123,
+        "d'": -12.3232,
+    },
+    "A16": {
+        "a": 0.8367,
+        "b": 4.987e-3,
+        "c": -3.877e-5,
+        "a'": 6.0571,
+        "b'": -21.7829,
+        "c'": 31.2289,
+        "d'": -14.9168,
+    },
+    # PTW
+    "30010": {
+        "a": 1.0093,
+        "b": 0.926e-3,
+        "c": -1.771e-5,
+        "a'": 2.5318,
+        "b'": -6.7948,
+        "c'": 10.1779,
+        "d'": -5.1746,
+    },
+    "30011": {
+        "a": 0.9676,
+        "b": 2.061e-3,
+        "c": -2.528e-5,
+        "a'": 2.9044,
+        "b'": -8.4576,
+        "c'": 12.6339,
+        "d'": -6.3742,
+    },
+    "30012": {
+        "a": 0.9537,
+        "b": 2.440e-3,
+        "c": -2.750e-5,
+        "a'": 3.2836,
+        "b'": -10.0610,
+        "c'": 14.8867,
+        "d'": -7.4212,
+    },
+    "30013": {
+        "a": 0.9652,
+        "b": 2.141e-3,
+        "c": -2.623e-5,
+        "a'": 3.2012,
+        "b'": -9.7211,
+        "c'": 14.4211,
+        "d'": -7.2184,
+    },
+    "31010": {
+        "a": 0.9590,
+        "b": 2.265e-3,
+        "c": -2.684e-5,
+        "a'": 3.1578,
+        "b'": -9.5422,
+        "c'": 14.1676,
+        "d'": -7.0964,
+    },
+    "31016": {
+        "a": 1.0085,
+        "b": 1.028e-3,
+        "c": -1.968e-5,
+        "a'": 2.9524,
+        "b'": -8.6054,
+        "c'": 12.7757,
+        "d'": -6.4265,
+    },
+    "31014": {
+        "a": 1.0071,
+        "b": 1.048e-3,
+        "c": -1.967e-5,
+        "a'": 3.0178,
+        "b'": -8.8735,
+        "c'": 13.1372,
+        "d'": -6.5867,
+    },
+    # IBA
+    "CC25": {
+        "a": 0.9551,
+        "b": 2.353e-3,
+        "c": -2.687e-5,
+        "a'": 2.4567,
+        "b'": -6.5932,
+        "c'": 10.0471,
+        "d'": -5.1775,
+    },
+    "CC13": {
+        "a": 0.9515,
+        "b": 2.455e-3,
+        "c": -2.768e-5,
+        "a'": 3.1982,
+        "b'": -9.7182,
+        "c'": 14.4210,
+        "d'": -7.2121,
+    },
+    "CC08": {
+        "a": 0.9430,
+        "b": 2.637e-3,
+        "c": -2.884e-5,
+        "a'": 3.7328,
+        "b'": -11.9800,
+        "c'": 17.5884,
+        "d'": -8.6843,
+    },
+    "CC04": {
+        "a": 0.9714,
+        "b": 1.938e-3,
+        "c": -2.432e-5,
+        "a'": 3.0054,
+        "b'": -8.8633,
+        "c'": 13.1704,
+        "d'": -6.6075,
+    },
+    "CC01": {
+        "a": 0.9116,
+        "b": 3.358e-3,
+        "c": -3.177e-5,
+        "a'": 4.3376,
+        "b'": -14.4935,
+        "c'": 21.0293,
+        "d'": -10.2208,
+    },
+    "FC65-G": {
+        "a": 0.9708,
+        "b": 1.972e-3,
+        "c": -2.480e-5,
+        "a'": 3.3221,
+        "b'": -10.2012,
+        "c'": 15.0497,
+        "d'": -7.4872,
+    },
+    "FC65-P": {
+        "a": 0.9828,
+        "b": 1.664e-3,
+        "c": -2.296e-5,
+        "a'": 3.0872,
+        "b'": -9.1919,
+        "c'": 13.6137,
+        "d'": -6.8118,
+    },
+    "FC23-C": {
+        "a": 0.9820,
+        "b": 1.579e-3,
+        "c": -2.166e-5,
+        "a'": 3.0511,
+        "b'": -9.0243,
+        "c'": 13.3378,
+        "d'": -6.6559,
+    },
+    # Other
+    "NE2581": {
+        "a": 1.0318,
+        "b": 0.488e-3,
+        "c": -1.731e-5,
+        "a'": 2.9190,
+        "b'": -8.4561,
+        "c'": 12.5690,
+        "d'": -6.3468,
+    },
+    "NE2571": {
+        "a": 0.9882,
+        "b": 1.486e-3,
+        "c": -2.140e-5,
+        "a'": 2.2328,
+        "b'": -5.5779,
+        "c'": 8.5325,
+        "d'": -4.4352,
+    },
+    "NE2561": {
+        "a": 1.0200,
+        "b": 0.596e-3,
+        "c": -1.551e-5,
+        "a'": 2.4235,
+        "b'": -6.3179,
+        "c'": 9.4737,
+        "d'": -4.8307,
+    },
+    "PR06C/G": {
+        "a": 0.9519,
+        "b": 2.432e-3,
+        "c": -2.704e-5,
+        "a'": 2.9110,
+        "b'": -8.4916,
+        "c'": 12.6817,
+        "d'": -6.3874,
+    },
+}
+
+KQ_ELECTRONS = {
+    # Exradin
+    "A12": {"kQ,ecal": 0.907, "a": 0.965, "b": 0.119, "c": 0.607},
+    "A19": {"kQ,ecal": 0.904, "a": 0.957, "b": 0.119, "c": 0.505},
+    "A12S": {"kQ,ecal": 0.907, "a": 0.937, "b": 0.136, "c": 0.378},
+    "A18": {"kQ,ecal": 0.914, "a": 0.352, "b": 0.711, "c": 0.046},
+    "A1SL": {"kQ,ecal": 0.914, "a": 0.205, "b": 0.854, "c": 0.036},
+    # PTW
+    "30010": {"kQ,ecal": 0.904, "a": 0.980, "b": 0.119, "c": 0.891},
+    "30011": {"kQ,ecal": 0.901, "a": 0.976, "b": 0.120, "c": 0.793},
+    "30012": {"kQ,ecal": 0.908, "a": 0.972, "b": 0.121, "c": 0.728},
+    "30013": {"kQ,ecal": 0.901, "a": 0.978, "b": 0.112, "c": 0.816},
+    "31013": {"kQ,ecal": 0.902, "a": 0.945, "b": 0.133, "c": 0.441},
+    # IBA
+    "FC65-G": {"kQ,ecal": 0.904, "a": 0.971, "b": 0.113, "c": 0.680},
+    "FC65-P": {"kQ,ecal": 0.902, "a": 0.973, "b": 0.110, "c": 0.692},
+    "FC23-C": {"kQ,ecal": 0.904, "a": 0.971, "b": 0.097, "c": 0.591},
+    "CC25": {"kQ,ecal": 0.904, "a": 0.964, "b": 0.105, "c": 0.539},
+    "CC13": {"kQ,ecal": 0.904, "a": 0.926, "b": 0.129, "c": 0.279},
+    # Other
+    "PR06C/G": {"kQ,ecal": 0.906, "a": 0.972, "b": 0.122, "c": 0.729},
+    "NE2571": {"kQ,ecal": 0.903, "a": 0.977, "b": 0.117, "c": 0.817},
+    "NE2611": {"kQ,ecal": 0.896, "a": 0.979, "b": 0.120, "c": 0.875},
+}
+
+LEAD_OPTIONS = {"None": None, "30cm": "30cm", "50cm": "50cm"}
+
+
+def mmHg2kPa(mmHg: float) -> float:
+    """Utility function to convert from mmHg to kPa."""
+    return mmHg * 101.33 / 760
+
+
+def mbar2kPa(mbar: float) -> float:
+    """Utility function to convert from millibars to kPa."""
+    return mbar / 10
+
+
+def fahrenheit2celsius(f: float) -> float:
+    """Utility function to convert from Fahrenheit to Celsius."""
+    return (f - 32) * 5 / 9
+
+
+@argue.bounds(pdd2010=(0.5, 1))
+def tpr2010_from_pdd2010(*, pdd2010: float) -> float:
+    """Calculate TPR20,10 from PDD20,10. From TRS-398 footnote 25, section 6.3.1, p.68 (https://www-pub.iaea.org/MTCD/Publications/PDF/TRS398_scr.pdf),
+    and Followill et al 1998 eqn 1."""
+    return 1.2661 * pdd2010 - 0.0595
+
+
+def p_tp(*, temp: float, press: float) -> float:
+    """Calculate the temperature & pressure correction.
+
+    Parameters
+    ----------
+    temp : float (17-27)
+        The temperature in degrees Celsius.
+    press : float (91-111)
+        The value of pressure in kPa. Can be converted from mmHg and mbar;
+        see :func:`~pylinac.calibration.tg51.mmHg2kPa` and :func:`~pylinac.calibration.tg51.mbar2kPa`.
+    """
+    argue.verify_bounds(
+        temp,
+        bounds=(MIN_TEMP, MAX_TEMP),
+        message="Temperature {:2.2f} out of range. Did you use Fahrenheit? Consider using the utility function fahrenheit2celsius()",
+    )
+    argue.verify_bounds(
+        press,
+        bounds=(MIN_PRESSURE, MAX_PRESSURE),
+        message="Pressure {:2.2f} out of range. Did you use kPa? Consider using the utility functions mmHg2kPa() or mbar2kPa()",
+    )
+    return ((273.2 + temp) / 295.2) * (101.33 / press)
+
+
+def p_pol(*, m_reference: NumberOrArray, m_opposite: NumberOrArray) -> float:
+    """Calculate the polarity correction.
+
+    Parameters
+    ----------
+    m_reference : number, array
+        The readings of the ion chamber at the reference polarity and voltage.
+    m_opposite : number, array
+        The readings of the ion chamber at the polarity opposite the reference. The sign does not make a difference.
+
+    Raises
+    ------
+    BoundsError if calculated Ppol is >1% from 1.0.
+    """
+    mref_avg = np.mean(m_reference)
+    mopp_avg = np.mean(m_opposite)
+    polarity = (abs(mref_avg) + abs(mopp_avg)) / abs(2 * mref_avg)
+    argue.verify_bounds(
+        polarity,
+        bounds=(MIN_PPOL, MAX_PPOL),
+        message="Polarity correction {:2.2f} out of range (+/-2%). Verify inputs",
+    )
+    return float(polarity)
+
+
+def p_ion(
+    *,
+    voltage_reference: int,
+    voltage_reduced: int,
+    m_reference: NumberOrArray,
+    m_reduced: NumberOrArray,
+) -> float:
+    """Calculate the ion chamber collection correction.
+
+    Parameters
+    ----------
+    voltage_reference : int
+        The "high" voltage; same as the TG51 measurement voltage.
+    voltage_reduced : int
+        The "low" voltage; usually half of the high voltage.
+    m_reference : float, iterable
+        The readings of the ion chamber at the "high" voltage.
+    m_reduced : float, iterable
+        The readings of the ion chamber at the "low" voltage.
+
+    Raises
+    ------
+    BoundsError if calculated Pion is outside the range 1.00-1.05.
+    """
+    ion = (1 - voltage_reference / voltage_reduced) / (
+        np.mean(m_reference) / np.mean(m_reduced) - voltage_reference / voltage_reduced
+    )
+    argue.verify_bounds(
+        ion,
+        bounds=(MIN_PION, MAX_PION),
+        message="Pion out of range (1.00-1.05). Check inputs or chamber",
+    )
+    return float(ion)
+
+
+def d_ref(*, i_50: float) -> float:
+    """Calculate the dref of an electron beam based on the I50 depth.
+
+    Parameters
+    ----------
+    i_50 : float
+        The value of I50 in cm.
+    """
+    argue.verify_bounds(i_50, bounds=argue.POSITIVE, message="i50 should be positive")
+    r50 = r_50(i_50=i_50)
+    return 0.6 * r50 - 0.1
+
+
+def r_50(*, i_50: float) -> float:
+    """Calculate the R50 depth of an electron beam based on the I50 depth.
+
+    Parameters
+    ----------
+    i_50 : float
+        The value of I50 in cm.
+    """
+    argue.verify_bounds(i_50, bounds=argue.POSITIVE, message="i50 should be positive")
+    if i_50 < 10:
+        r50 = 1.029 * i_50 - 0.06
+    else:
+        r50 = 1.59 * i_50 - 0.37
+    return r50
+
+
+def kp_r50(*, r_50: float) -> float:
+    """Calculate k'R50 for Farmer-like chambers.
+
+    Parameters
+    ----------
+    r_50 : float (2-9)
+        The R50 value in cm.
+    """
+    argue.verify_bounds(r_50, bounds=(2, 9))
+    return 0.9905 + 0.071 * np.exp(-r_50 / 3.67)
+
+
+def pq_gr(*, m_dref_plus: NumberOrArray, m_dref: NumberOrArray) -> float:
+    """Calculate PQ_gradient for a cylindrical chamber.
+
+    Parameters
+    ----------
+    m_dref_plus : float, iterable
+        The readings of the ion chamber at dref + 0.5rcav.
+    m_dref : float, iterable
+        The readings of the ion chamber at dref.
+    """
+    return float(np.mean(m_dref_plus) / np.mean(m_dref))
+
+
+def m_corrected(
+    *,
+    p_ion: float,
+    p_tp: float,
+    p_elec: float,
+    p_pol: float,
+    m_reference: NumberOrArray,
+) -> float:
+    """Calculate M_corrected, the ion chamber reading with all corrections applied.
+
+    Parameters
+    ----------
+    p_ion : float (1.00-1.05)
+        The ion collection correction.
+    p_tp : float (0.92-1.08)
+        The temperature & pressure correction.
+    p_elec : float (0.98-1.02)
+        The electrometer correction.
+    p_pol : float (0.98-1.02)
+        The polarity correction.
+    m_reference : float, iterable
+        The raw ion chamber reading(s).
+
+    Returns
+    -------
+    float
+    """
+    argue.verify_bounds(p_ion, bounds=(MIN_PION, MAX_PION))
+    argue.verify_bounds(p_tp, bounds=(MIN_PTP, MAX_PTP))
+    argue.verify_bounds(p_elec, bounds=(MIN_PELEC, MAX_PELEC))
+    argue.verify_bounds(p_pol, bounds=(MIN_PPOL, MAX_PPOL))
+    return float(p_ion * p_tp * p_elec * p_pol * np.mean(m_reference))
+
+
+@argue.bounds(pdd=(62.7, 89.0))
+@argue.options(lead_foil=LEAD_OPTIONS.values())
+def pddx(*, pdd: float, energy: int, lead_foil: Optional[str] = None) -> float:
+    """Calculate PDDx based on the PDD.
+
+    Parameters
+    ----------
+    pdd : {>62.7, <89.0}
+        The measured PDD. If lead foil was used, this assumes the pdd as measured with the lead in place.
+    energy : int
+        The nominal energy in MV.
+    lead_foil : {None, '30cm', '50cm'}
+        Applicable only for energies >10MV.
+        Whether a lead foil was used to acquire the pdd.
+        Use ``None`` if no lead foil was used and the interim equation should be used. This is the default
+        Use ``50cm`` if the lead foil was set to 50cm from the phantom surface.
+        Use ``30cm`` if the lead foil was set to 30cm from the phantom surface.
+    """
+    if energy < 10:
+        return pdd
+    elif energy >= 10:
+        if lead_foil is None:
+            if pdd <= 75:
+                return pdd
+            elif 75 < pdd <= 89:
+                return 1.267 * pdd - 20
+            else:
+                raise ValueError(f"PDD value of {pdd} was outside the bound of 89%")
+        elif lead_foil == LEAD_OPTIONS["50cm"]:
+            if pdd < 73:
+                return pdd
+            else:
+                return (0.8905 + 0.0015 * pdd) * pdd
+        elif lead_foil == LEAD_OPTIONS["30cm"]:
+            if pdd < 71:
+                return pdd
+            else:
+                return (0.8116 + 0.00264 * pdd) * pdd
+
+
+@argue.bounds(pddx=(63.0, 86.0))
+@argue.options(chamber=KQ_PHOTONS.keys())
+def kq_photon_pddx(*, chamber: str, pddx: float) -> float:
+    """Calculate kQ based on the chamber and clinical measurements of PDD(10)x. This will calculate kQ for photons
+    for *CYLINDRICAL* chambers only.
+
+    Parameters
+    ----------
+    chamber : str
+        The chamber of the chamber. Valid values are those listed in
+        Table III of Muir and Rogers and Table I of the TG-51 Addendum.
+    pddx : {>63.0, <86.0}
+        The **PHOTON-ONLY** PDD measurement at 10cm depth for a 10x10cm2 field.
+
+        .. note:: Use the :func:`~pylinac.calibration.tg51.pddx` function to convert PDD to PDDx as needed.
+
+        .. note:: Muir and Rogers state limits of 0.627 - 0.861. The TG-51 addendum states them as 0.63 and 0.86.
+                  The TG-51 addendum limits are used here.
+    """
+    ch = KQ_PHOTONS[chamber]
+    return ch["a"] + ch["b"] * pddx + ch["c"] * (pddx**2)
+
+
+@argue.bounds(tpr=(0.623, 0.805))
+@argue.options(chamber=KQ_PHOTONS.keys())
+def kq_photon_tpr(*, chamber: str, tpr: float) -> float:
+    """Calculate kQ based on the chamber and clinical measurements of TPR20,10. This will calculate kQ for photons
+    for *CYLINDRICAL* chambers only.
+
+    Parameters
+    ----------
+    chamber : str
+        The chamber of the chamber. Valid values are those listed in
+        Table III of Muir and Rogers and Table I of the TG-51 Addendum.
+    tpr : {>0.630, <0.860}
+        The TPR(20,10) value.
+
+        .. note::
+         Use the :func:`~pylinac.calibration.tg51.tpr2010_from_pdd2010` function to convert from PDD without needing to take TPR measurements.
+    """
+    ch = KQ_PHOTONS[chamber]
+    return ch["a'"] + ch["b'"] * tpr + ch["c'"] * (tpr**2) + ch["d'"] * (tpr**3)
+
+
+@argue.options(chamber=KQ_ELECTRONS.keys())
+def kq_electron(*, chamber: str, r_50: float) -> float:
+    """Calculate kQ based on the chamber and clinical measurements. This will calculate kQ for electrons
+    for *CYLINDRICAL* chambers only according to Muir & Rogers.
+
+    Parameters
+    ----------
+    chamber : str
+        The chamber of the chamber. Valid values are those listed in
+        Tables VI and VII of Muir and Rogers 2014.
+    r_50 : float
+        The R50 value in cm of an electron beam.
+    """
+    ch = KQ_ELECTRONS[chamber]
+    return (ch["a"] + ch["b"] * r_50 ** -ch["c"]) * ch["kQ,ecal"]
+
+
+class TG51Base(Structure):
+    @property
+    def p_tp(self) -> float:
+        """Temperature/Pressure correction."""
+        return p_tp(temp=self.temp, press=self.press)
+
+    @property
+    def p_ion(self) -> float:
+        """Ionization collection correction."""
+        return p_ion(
+            voltage_reference=self.voltage_reference,
+            voltage_reduced=self.voltage_reduced,
+            m_reference=self.m_reference,
+            m_reduced=self.m_reduced,
+        )
+
+    @property
+    def p_pol(self) -> float:
+        """Polarity correction."""
+        return p_pol(m_reference=self.m_reference, m_opposite=self.m_opposite)
+
+    @property
+    def m_corrected(self) -> float:
+        """Corrected chamber reading."""
+        return m_corrected(
+            p_ion=self.p_ion,
+            p_tp=self.p_tp,
+            p_elec=self.p_elec,
+            p_pol=self.p_pol,
+            m_reference=self.m_reference,
+        )
+
+    @property
+    def m_corrected_adjustment(self) -> float:
+        """Corrected chamber reading after adjusting the output."""
+        if self.m_reference_adjusted is not None:
+            return m_corrected(
+                p_ion=self.p_ion,
+                p_tp=self.p_tp,
+                p_elec=self.p_elec,
+                p_pol=self.p_pol,
+                m_reference=self.m_reference_adjusted,
+            )
+
+    @property
+    def output_was_adjusted(self) -> float:
+        """Boolean specifiying if output was adjusted."""
+        return self.m_reference_adjusted is not None
+
+
+class TG51Photon(TG51Base):
+    """Class for calculating absolute dose to water using a cylindrical chamber in a photon beam.
+
+    Parameters
+    ----------
+    institution : str
+        Institution name.
+    physicist : str
+        Physicist performing calibration.
+    unit : str
+        Unit name; e.g. TrueBeam1.
+    measurement_date : str
+        Date of measurement. E.g. 10/22/2018.
+    temp : float
+        The temperature in Celsius. Use :func:`~pylinac.calibration.tg51.fahrenheit2celsius` to convert if necessary.
+    press : float
+        The value of pressure in kPa. Can be converted from mmHg and mbar; see :func:`~pylinac.calibration.tg51.mmHg2kPa` and :func:`~pylinac.calibration.tg51.mbar2kPa`.
+    energy : float
+        Nominal energy of the beam in MV.
+    chamber : str
+        Chamber model. Must be one of the listed chambers in TG-51 Addendum.
+    n_dw : float
+        NDW value in Gy/nC.
+    p_elec : float
+        Electrometer correction factor; given by the calibration laboratory.
+    measured_pdd10 : float
+        The measured value of PDD(10); will be converted to PDDx(10) and used for calculating kq.
+    lead_foil : {None, '50cm', '30cm'}
+        Whether a lead foil was used to acquire PDD(10)x and where its position was. Used to calculate kq.
+    clinical_pdd10 : float
+        The PDD used to correct the dose at 10cm back to dmax. Usually the TPS PDD(10) value.
+    voltage_reference : int
+        Reference voltage; i.e. voltage when taking the calibration measurement.
+    voltage_reduced : int
+        Reduced voltage; usually half of the reference voltage.
+    m_reference : float, tuple
+        Ion chamber reading(s) at the reference voltage.
+    m_opposite : float, tuple
+        Ion chamber reading(s) at the opposite voltage of reference.
+    m_reduced : float, tuple
+        Ion chamber reading(s) at the reduced voltage.
+    mu : int
+        The MU delivered to measure the reference reading. E.g. 200.
+    fff : bool
+        Whether the beam is FFF or flat.
+    tissue_correction : float
+        Correction value to calibration to, e.g., muscle. A value of 1.0 means no correction (i.e. water).
+    """
+
+    @argue.options(chamber=KQ_PHOTONS.keys(), lead_foil=LEAD_OPTIONS.values())
+    def __init__(
+        self,
+        *,
+        institution: str = "",
+        physicist: str = "",
+        unit: str,
+        measurement_date: str = "",
+        temp: float,
+        press: float,
+        chamber: str,
+        n_dw: float,
+        p_elec: float,
+        electrometer: str = "",
+        measured_pdd10: Optional[float] = None,
+        lead_foil: Optional[str] = None,
+        clinical_pdd10: float,
+        energy: int,
+        fff: bool = False,
+        voltage_reference: int,
+        voltage_reduced: int,
+        m_reference: NumberOrArray,
+        m_opposite: NumberOrArray,
+        m_reduced: NumberOrArray,
+        mu: int,
+        tissue_correction: float = 1.0,
+        m_reference_adjusted: Optional[NumberOrArray] = None,
+    ):
+        super().__init__(
+            temp=temp,
+            press=press,
+            chamber=chamber,
+            n_dw=n_dw,
+            p_elec=p_elec,
+            measured_pdd10=measured_pdd10,
+            energy=energy,
+            voltage_reference=voltage_reference,
+            voltage_reduced=voltage_reduced,
+            m_reference=m_reference,
+            m_opposite=m_opposite,
+            m_reduced=m_reduced,
+            clinical_pdd10=clinical_pdd10,
+            mu=mu,
+            tissue_correction=tissue_correction,
+            lead_foil=lead_foil,
+            electrometer=electrometer,
+            m_reference_adjusted=m_reference_adjusted,
+            institution=institution,
+            physicist=physicist,
+            unit=unit,
+            measurement_date=measurement_date,
+            fff=fff,
+        )
+        # add check for tpr vs pdd
+
+    @property
+    def pddx(self) -> float:
+        """The photon-only PDD(10) value."""
+        return pddx(
+            pdd=self.measured_pdd10, energy=self.energy, lead_foil=self.lead_foil
+        )
+
+    @property
+    def kq(self) -> float:
+        """The chamber-specific beam quality correction factor."""
+        return kq_photon_pddx(chamber=self.chamber, pddx=self.pddx)
+
+    @property
+    def dose_mu_10(self) -> float:
+        """cGy/MU at a depth of 10cm."""
+        return self.tissue_correction * self.m_corrected * self.kq * self.n_dw / self.mu
+
+    @property
+    def dose_mu_dmax(self) -> float:
+        """cGy/MU at a depth of dmax."""
+        return self.dose_mu_10 / (self.clinical_pdd10 / 100)
+
+    @property
+    def dose_mu_10_adjusted(self) -> float:
+        """The dose/mu at 10cm depth after adjustment."""
+        return (
+            self.tissue_correction
+            * self.m_corrected_adjustment
+            * self.kq
+            * self.n_dw
+            / self.mu
+        )
+
+    @property
+    def dose_mu_dmax_adjusted(self) -> float:
+        """The dose/mu at dmax depth after adjustment."""
+        return self.dose_mu_10_adjusted / (self.clinical_pdd10 / 100)
+
+    def publish_pdf(
+        self,
+        filename: str,
+        notes: Optional[list] = None,
+        open_file: bool = False,
+        metadata: Optional[dict] = None,
+    ):
+        """Publish (print) a PDF containing the analysis and quantitative results.
+
+        Parameters
+        ----------
+        filename : str, file-like object
+            The file to write the results to.
+        notes : str, list
+            Any notes to be added to the report. If a string, adds everything as one line.
+            If a list, must be a list of strings; each string item will be a new line.
+        open_file : bool
+            Whether to open the file after creation. Will use the default PDF program.
+        metadata : dict
+            Any data that should be appended to every page of the report. This differs from notes in that
+            metadata is at the top of every page while notes is at the bottom of the report.
+        """
+        was_adjusted = "Yes" if self.output_was_adjusted else "No"
+        title = [
+            "TG-51 Photon Report",
+            f"{self.unit} - {self.energy} MV{' FFF' if self.fff else ''}",
+        ]
+
+        canvas = PylinacCanvas(filename, page_title=title, metadata=metadata)
+        text = [
+            "Site Data:",
+            f"Institution: {self.institution}",
+            f"Performed by: {self.physicist}",
+            f"Measurement Date: {self.measurement_date}",
+            f'Date of Report: {datetime.now().strftime("%A, %B %d, %Y")}',
+            f"Unit: {self.unit}",
+            f"Energy: {self.energy} MV {'FFF' if self.fff else ''}",
+            "",
+            "Instrumentation:",
+            f"Chamber: {self.chamber}",
+            f"Chamber Calibration Factor Ndw (cGy/nC): {self.n_dw:2.3f}",
+            f"Electrometer: {self.electrometer}",
+            f"Pelec: {self.p_elec:2.3f}",
+            f"MU: {self.mu}",
+            "",
+            "Beam Quality:",
+            f"Lead foil: {'No' if self.lead_foil is None else self.lead_foil}",
+            f"Measured PDD(10){'' if self.lead_foil is None else 'Pb'} {self.measured_pdd10:2.2f}",
+            f"Calculated PDD(10)x: {self.pddx:2.2f}",
+            f"Determined kQ: {self.kq:2.3f}",
+            "",
+            "Chamber Corrections/Measurements:",
+            f"Temperature (\N{DEGREE SIGN}C): {self.temp:2.1f}",
+            f"Pressure (kPa): {self.press:2.1f}",
+            f"Mraw @ ({self.voltage_reference}V, Reference) (nC): {self.m_reference}",
+            f"Mraw @ ({self.voltage_reduced}V, Reduced) (nC): {self.m_reduced}",
+            f"Mraw @ ({-self.voltage_reference}V, Opposite) (nC): {self.m_opposite}",
+            f"Ptp: {self.p_tp:2.3f}",
+            f"Pion: {self.p_ion:2.3f}",
+            f"Ppol: {self.p_pol:2.3f}",
+            "",
+            "Dose Determination:",
+            f"Fully corrected M (nC): {self.m_corrected:2.3f}",
+            f"Tissue correction (e.g. muscle): {self.tissue_correction:2.3f}",
+            f"Dose/MU @ 10cm depth (cGy): {self.dose_mu_10:2.3f}",
+            f"Clinical PDD (%): {self.clinical_pdd10:2.2f}",
+            f"Dose/MU @ dmax (cGy): {self.dose_mu_dmax:2.3f}",
+            "",
+            f"Output Adjustment?: {was_adjusted}",
+        ]
+        if was_adjusted == "Yes":
+            text.append(
+                f"Adjusted Mraw @ reference voltage (nC): {self.m_reference_adjusted}"
+            )
+            text.append(
+                f"Adjusted fully corrected M (nC): {self.m_corrected_adjustment:2.3f}"
+            )
+            text.append(
+                f"Adjusted Dose/MU @ 10cm depth (cGy): {self.dose_mu_10_adjusted:2.3f}"
+            )
+            text.append(
+                f"Adjusted Dose/MU @ dmax (cGy): {self.dose_mu_dmax_adjusted:2.3f}"
+            )
+        canvas.add_text(text=text, location=(2, 25.5), font_size=12)
+        if notes is not None:
+            canvas.add_text(text="Notes:", location=(12, 6.5), font_size=14)
+            canvas.add_text(text=notes, location=(12, 6))
+
+        canvas.finish()
+
+        if open_file:
+            webbrowser.open(filename)
+
+
+class TG51ElectronLegacy(TG51Base):
+    """Class for calculating absolute dose to water using a cylindrical chamber in an electron beam.
+
+    Parameters
+    ----------
+    institution : str
+        Institution name.
+    physicist : str
+        Physicist performing calibration.
+    unit : str
+        Unit name; e.g. TrueBeam1.
+    measurement_date : str
+        Date of measurement. E.g. 10/22/2018.
+    temp : float (17-27)
+        The temperature in degrees Celsius.
+    press : float (91-111)
+        The value of pressure in kPa. Can be converted from mmHg and mbar; see :func:`~pylinac.calibration.tg51.mmHg2kPa` and :func:`~pylinac.calibration.tg51.mbar2kPa`.
+    chamber : str
+        Chamber model; only for bookkeeping.
+    n_dw : float
+        NDW value in Gy/nC. Given by the calibration laboratory.
+    k_ecal : float
+        Kecal value which is chamber specific. This value is the major difference between the legacy class and modern class where no kecal is needed.
+    p_elec : float
+        Electrometer correction factor; given by the calibration laboratory.
+    clinical_pdd : float
+        The PDD used to correct the dose back to dref.
+    voltage_reference : float
+        Reference voltage; i.e. voltage when taking the calibration measurement.
+    voltage_reduced : float
+        Reduced voltage; usually half of the reference voltage.
+    m_reference : float, tuple
+        Ion chamber reading(s) at the reference voltage.
+    m_opposite : float, tuple
+        Ion chamber reading(s) at the opposite voltage of reference.
+    m_reduced : float, tuple
+        Ion chamber reading(s) at the reduced voltage.
+    mu : int
+        The MU delivered to measure the reference reading. E.g. 200.
+    i_50 : float
+        Depth of 50% ionization.
+    tissue_correction : float
+        Correction value to calibration to, e.g., muscle. A value of 1.0 means no correction (i.e. water).
+    """
+
+    def __init__(
+        self,
+        *,
+        institution: str = "",
+        physicist: str = "",
+        unit: str = "",
+        measurement_date: str = "",
+        energy: int,
+        temp: float,
+        press: float,
+        chamber: str,
+        k_ecal: float,
+        n_dw: float,
+        electrometer: str = "",
+        p_elec: float,
+        clinical_pdd: float,
+        voltage_reference: int,
+        voltage_reduced: int,
+        m_reference: NumberOrArray,
+        m_opposite: NumberOrArray,
+        m_reduced: NumberOrArray,
+        m_gradient: NumberOrArray,
+        cone: str,
+        mu: int,
+        i_50: float,
+        tissue_correction: float = 1.0,
+        m_reference_adjusted=None,
+    ):
+        super().__init__(
+            temp=temp,
+            press=press,
+            chamber=chamber,
+            n_dw=n_dw,
+            p_elec=p_elec,
+            voltage_reference=voltage_reference,
+            voltage_reduced=voltage_reduced,
+            m_reference=m_reference,
+            m_opposite=m_opposite,
+            m_reduced=m_reduced,
+            clinical_pdd=clinical_pdd,
+            mu=mu,
+            i_50=i_50,
+            tissue_correction=tissue_correction,
+            institution=institution,
+            physicist=physicist,
+            unit=unit,
+            measurement_date=measurement_date,
+            electrometer=electrometer,
+            m_reference_adjusted=m_reference_adjusted,
+            cone=cone,
+            energy=energy,
+            k_ecal=k_ecal,
+            m_gradient=m_gradient,
+        )
+
+    @property
+    def r_50(self) -> float:
+        """Depth of the 50% dose value."""
+        return r_50(i_50=self.i_50)
+
+    @property
+    def dref(self) -> float:
+        """Depth of the reference point."""
+        return d_ref(i_50=self.i_50)
+
+    @property
+    def pq_gr(self):
+        """Gradient factor"""
+        return pq_gr(m_dref_plus=self.m_gradient, m_dref=self.m_reference)
+
+    @property
+    def kq(self) -> float:
+        """The kQ value using classic TG-51"""
+        return self.k_ecal * kp_r50(r_50=self.r_50)
+
+    @property
+    def dose_mu_dref(self) -> float:
+        """cGy/MU at the depth of Dref."""
+        return (
+            self.tissue_correction
+            * self.m_corrected
+            * self.kq
+            * self.n_dw
+            * self.pq_gr
+            / self.mu
+        )
+
+    @property
+    def dose_mu_dmax(self) -> float:
+        """cGy/MU at the depth of dmax."""
+        return self.dose_mu_dref / (self.clinical_pdd / 100)
+
+    @property
+    def dose_mu_dref_adjusted(self) -> float:
+        """cGy/MU at the depth of Dref."""
+        return (
+            self.tissue_correction
+            * self.m_corrected_adjustment
+            * self.kq
+            * self.n_dw
+            * self.pq_gr
+            / self.mu
+        )
+
+    @property
+    def dose_mu_dmax_adjusted(self) -> float:
+        """cGy/MU at the depth of dmax."""
+        return self.dose_mu_dref_adjusted / (self.clinical_pdd / 100)
+
+    def publish_pdf(
+        self,
+        filename: str,
+        notes: Optional[list] = None,
+        open_file: bool = False,
+        metadata: Optional[dict] = None,
+    ):
+        """Publish (print) a PDF containing the analysis and quantitative results.
+
+        Parameters
+        ----------
+        filename : str, file-like object
+            The file to write the results to.
+        notes : str, list
+            Any notes to be added to the report. If a string, adds everything as one line.
+            If a list, must be a list of strings; each string item will be a new line.
+        open_file : bool
+            Whether to open the file after creation. Will use the default PDF program.
+        metadata : dict
+            Any data that should be appended to every page of the report. This differs from notes in that
+            metadata is at the top of every page while notes is at the bottom of the report.
+        """
+        was_adjusted = "Yes" if self.output_was_adjusted else "No"
+        title = ["TG-51 Electron Report (Legacy)", f"{self.unit} - {self.energy} MeV"]
+
+        canvas = PylinacCanvas(filename, page_title=title, metadata=metadata)
+        text = [
+            "Site Data:",
+            f"Institution: {self.institution}",
+            f"Performed by: {self.physicist}",
+            f"Measurement Date: {self.measurement_date}",
+            f'Date of Report: {datetime.now().strftime("%A, %B %d, %Y")}',
+            f"Unit: {self.unit}",
+            f"Energy: {self.energy} MeV",
+            f"Cone: {self.cone}",
+            f"MU: {self.mu}",
+            "",
+            "Instrumentation:",
+            f"Chamber chamber: {self.chamber}",
+            f"Chamber Calibration Factor Ndw (cGy/nC): {self.n_dw:2.3f}",
+            f"Electrometer: {self.electrometer}",
+            f"Pelec: {self.p_elec:2.2f}",
+            "",
+            "Beam Quality:",
+            f"I50 (cm): {self.i_50:2.2f}",
+            f"R50 (cm): {self.r_50:2.2f}",
+            f"Dref (cm): {self.dref:2.2f}",
+            f"Kecal: {self.k_ecal:2.3f}",
+            f"kQ: {self.kq:2.3f}",
+            "",
+            "Chamber Corrections/Measurements:",
+            f"Temperature (\N{DEGREE SIGN}C): {self.temp:2.1f}",
+            f"Pressure (kPa): {self.press:2.1f}",
+            f"Mraw @ ({self.voltage_reference}V, Reference) (nC): {self.m_reference}",
+            f"Mraw @ ({self.voltage_reduced}V, Reduced) (nC): {self.m_reduced}",
+            f"Mraw @ ({-self.voltage_reference}V, Opposite) (nC): {self.m_opposite}",
+            f"Ptp: {self.p_tp:2.3f}",
+            f"Pion: {self.p_ion:2.3f}",
+            f"Ppol: {self.p_pol:2.3f}",
+            f"Mraw @ Dref + 0.5rcav (nC): {self.m_gradient}",
+            "",
+            "Dose Determination:",
+            f"Fully corrected M (nC): {self.m_corrected:2.3f}",
+            f"Tissue correction (e.g. muscle): {self.tissue_correction:2.3f}",
+            f"Dose/MU @ Dref depth (cGy): {self.dose_mu_dref:2.3f}",
+            f"Clinical PDD (%): {self.clinical_pdd:2.2f}",
+            f"Dose/MU @ dmax (cGy): {self.dose_mu_dmax:2.3f}",
+            "",
+            f"Output Adjustment?: {was_adjusted}",
+        ]
+        if was_adjusted == "Yes":
+            text.append(
+                f"Adjusted Mraw @ reference voltage (nC): {self.m_reference_adjustment}"
+            )
+            text.append(
+                f"Adjusted fully corrected M (nC): {self.m_corrected_adjustment:2.3f}"
+            )
+            text.append(
+                f"Adjusted Dose/MU @ dref depth (cGy): {self.dose_mu_dref_adjusted:2.3f}"
+            )
+            text.append(
+                f"Adjusted Dose/MU @ dmax (cGy): {self.dose_mu_dmax_adjusted:2.3f}"
+            )
+        canvas.add_text(text=text, location=(2, 25.5), font_size=11)
+        if notes is not None:
+            canvas.add_text(text="Notes:", location=(12, 6.5), font_size=14)
+            canvas.add_text(text=notes, location=(12, 6))
+
+        canvas.finish()
+
+        if open_file:
+            webbrowser.open(filename)
+
+
+class TG51ElectronModern(TG51Base):
+    """Class for calculating absolute dose to water using a cylindrical chamber in an electron beam.
+
+    .. warning::
+        This class uses the values of Muir & Rogers. These values are likely to be included in the new TG-51
+        addendum, but are not official. The results can be up to 1% different. Physicists should use their own
+        judgement when deciding which class to use. To use a manual kecal value, Pgradient and the classic TG-51 equations use
+        the :class:`~pylinac.calibration.tg51.TG51ElectronLegacy` class.
+
+    Parameters
+    ----------
+    institution : str
+        Institution name.
+    physicist : str
+        Physicist performing calibration.
+    unit : str
+        Unit name; e.g. TrueBeam1.
+    measurement_date : str
+        Date of measurement. E.g. 10/22/2018.
+    press : float
+        The value of pressure in kPa. Can be converted from mmHg and mbar; see :func:`~pylinac.calibration.tg51.mmHg2kPa` and :func:`~pylinac.calibration.tg51.mbar2kPa`.
+    temp : float
+        The temperature in Celsius.
+    voltage_reference : int
+        The reference voltage; i.e. the voltage for the calibration reading (e.g. 300V).
+    voltage_reduced : int
+        The reduced voltage, usually a fraction of the reference voltage (e.g. 150V).
+    m_reference : array, float
+        The reading(s) of the chamber at reference voltage.
+    m_reduced : array, float
+        The reading(s) of the chamber at the reduced voltage.
+    m_opposite : array, float
+        The reading(s) of the chamber at the opposite voltage from reference. Sign of the reading does not matter.
+    chamber : str
+        Ion chamber model.
+    n_dw : float
+        NDW value in Gy/nC
+    p_elec : float
+        Electrometer correction given by the calibration laboratory.
+    clinical_pdd : float
+        The PDD used to correct the dose back to dref.
+    mu : int
+        MU delivered.
+    i_50 : float
+        Depth of 50% ionization
+    tissue_correction : float
+        Correction value to calibration to, e.g., muscle. A value of 1.0 means no correction (i.e. water).
+    """
+
+    def __init__(
+        self,
+        *,
+        institution: str = "",
+        physicist: str = "",
+        unit: str = "",
+        measurement_date: str = "",
+        energy: int,
+        temp: float,
+        press: float,
+        chamber: str,
+        n_dw: float,
+        electrometer: str = "",
+        p_elec: float,
+        clinical_pdd: float,
+        voltage_reference: int,
+        voltage_reduced: int,
+        m_reference: NumberOrArray,
+        m_opposite: NumberOrArray,
+        m_reduced: NumberOrArray,
+        cone: str,
+        mu: int,
+        i_50: float,
+        tissue_correction: float,
+        m_reference_adjusted=None,
+    ):
+        super().__init__(
+            temp=temp,
+            press=press,
+            chamber=chamber,
+            n_dw=n_dw,
+            p_elec=p_elec,
+            voltage_reference=voltage_reference,
+            voltage_reduced=voltage_reduced,
+            m_reference=m_reference,
+            m_opposite=m_opposite,
+            m_reduced=m_reduced,
+            clinical_pdd=clinical_pdd,
+            mu=mu,
+            i_50=i_50,
+            tissue_correction=tissue_correction,
+            institution=institution,
+            physicist=physicist,
+            unit=unit,
+            measurement_date=measurement_date,
+            electrometer=electrometer,
+            m_reference_adjusted=m_reference_adjusted,
+            cone=cone,
+            energy=energy,
+        )
+
+    @property
+    def r_50(self) -> float:
+        """Depth of the 50% dose value."""
+        return r_50(i_50=self.i_50)
+
+    @property
+    def dref(self) -> float:
+        """Depth of the reference point."""
+        return d_ref(i_50=self.i_50)
+
+    @property
+    def kq(self) -> float:
+        """The kQ value using the updated Muir & Rogers values from their 2014 paper, equation 11, or classically
+        if kecal is passed."""
+        return kq_electron(chamber=self.chamber, r_50=self.r_50)
+
+    @property
+    def dose_mu_dref(self) -> float:
+        """cGy/MU at the depth of Dref."""
+        return self.tissue_correction * self.m_corrected * self.kq * self.n_dw / self.mu
+
+    @property
+    def dose_mu_dmax(self) -> float:
+        """cGy/MU at the depth of dmax."""
+        return self.dose_mu_dref / (self.clinical_pdd / 100)
+
+    @property
+    def dose_mu_dref_adjusted(self) -> float:
+        """cGy/MU at the depth of Dref."""
+        return (
+            self.tissue_correction
+            * self.m_corrected_adjusted
+            * self.kq
+            * self.n_dw
+            / self.mu
+        )
+
+    @property
+    def dose_mu_dmax_adjusted(self) -> float:
+        """cGy/MU at the depth of dmax."""
+        return self.dose_mu_dref_adjusted / (self.clinical_pdd / 100)
+
+    def publish_pdf(
+        self,
+        filename: str,
+        notes: Optional[list] = None,
+        open_file: bool = False,
+        metadata: Optional[dict] = None,
+    ):
+        """Publish (print) a PDF containing the analysis and quantitative results.
+
+        Parameters
+        ----------
+        filename : str, file-like object
+            The file to write the results to.
+        notes : str, list
+            Any notes to be added to the report. If a string, adds everything as one line.
+            If a list, must be a list of strings; each string item will be a new line.
+        open_file : bool
+            Whether to open the file after creation. Will use the default PDF program.
+        metadata : dict
+            Any data that should be appended to every page of the report. This differs from notes in that
+            metadata is at the top of every page while notes is at the bottom of the report.
+        """
+        was_adjusted = "Yes" if self.output_was_adjusted else "No"
+        title = ["TG-51 Electron Report (Modern)", f"{self.unit} - {self.energy} MeV"]
+
+        canvas = PylinacCanvas(filename, page_title=title, metadata=metadata)
+        text = [
+            "Site Data:",
+            f"Institution: {self.institution}",
+            f"Performed by: {self.physicist}",
+            f"Measurement Date: {self.measurement_date}",
+            f'Date of Report: {datetime.now().strftime("%A, %B %d, %Y")}',
+            f"Unit: {self.unit}",
+            f"Energy: {self.energy} MeV",
+            f"Cone: {self.cone}",
+            f"MU: {self.mu}",
+            "",
+            "Instrumentation:",
+            f"Chamber: {self.chamber}",
+            f"Chamber Calibration Factor Ndw (cGy/nC): {self.n_dw:2.3f}",
+            f"Electrometer: {self.electrometer}",
+            f"Pelec: {self.p_elec:2.2f}",
+            "",
+            "Beam Quality:",
+            f"I50 (cm): {self.i_50:2.2f}",
+            f"R50 (cm): {self.r_50:2.2f}",
+            f"Dref (cm): {self.dref:2.2f}",
+            f"Calculated kQ: {self.kq:2.3f}",
+            "",
+            "Chamber Corrections/Measurements:",
+            f"Temperature (\N{DEGREE SIGN}C): {self.temp:2.1f}",
+            f"Pressure (kPa): {self.press:2.1f}",
+            f"Mraw @ ({self.voltage_reference}V, Reference) (nC): {self.m_reference}",
+            f"Mraw @ ({self.voltage_reduced}V, Reduced) (nC): {self.m_reduced}",
+            f"Mraw @ ({-self.voltage_reference}V, Opposite) (nC): {self.m_opposite}",
+            f"Ptp: {self.p_tp:2.3f}",
+            f"Pion: {self.p_ion:2.3f}",
+            f"Ppol: {self.p_pol:2.3f}",
+            "",
+            "Dose Determination:",
+            f"Fully corrected M (nC): {self.m_corrected:2.3f}",
+            f"Tissue correction (e.g. muscle): {self.tissue_correction:2.3f}",
+            f"Dose/MU @ Dref depth (cGy): {self.dose_mu_dref:2.3f}",
+            f"Clinical PDD (%): {self.clinical_pdd:2.2f}",
+            f"Dose/MU @ dmax (cGy): {self.dose_mu_dmax:2.3f}",
+            "",
+            f"Output Adjustment?: {was_adjusted}",
+        ]
+        if was_adjusted == "Yes":
+            text.append(
+                f"Adjusted corrected M @ reference voltage (nC): {self.m_corrected_adjustment}"
+            )
+            text.append(
+                f"Adjusted fully corrected M (nC): {self.m_corrected_adjustment:2.3f}"
+            )
+            text.append(
+                f"Adjusted Dose/MU @ dref depth (cGy): {self.dose_mu_dref_adjusted:2.3f}"
+            )
+            text.append(
+                f"Adjusted Dose/MU @ dmax (cGy): {self.dose_mu_dmax_adjusted:2.3f}"
+            )
+        canvas.add_text(text=text, location=(2, 25.5), font_size=11)
+        if notes is not None:
+            canvas.add_text(text="Notes:", location=(12, 6.5), font_size=14)
+            canvas.add_text(text=notes, location=(12, 6))
+
+        canvas.finish()
+
+        if open_file:
+            webbrowser.open(filename)
```

### Comparing `manteia_qa_pylinac-1.0.0/pylinac/calibration/trs398.py` & `manteia_qa_pylinac-1.1.0/pylinac/calibration/trs398.py`

 * *Ordering differences only*

 * *Files 16% similar despite different names*

```diff
@@ -1,1206 +1,1206 @@
-import webbrowser
-from abc import ABC
-from datetime import datetime
-from typing import Optional, Union
-
-import argue
-import numpy as np
-
-from ..core.pdf import PylinacCanvas
-from ..core.typing import NumberOrArray
-from ..core.utilities import Structure, is_close
-from . import tg51 as _tg51
-from .tg51 import MAX_PPOL  # make available to module
-from .tg51 import (
-    MAX_PELEC,
-    MAX_PION,
-    MAX_PTP,
-    MIN_PELEC,
-    MIN_PION,
-    MIN_PPOL,
-    MIN_PTP,
-    fahrenheit2celsius,
-    mbar2kPa,
-    mmHg2kPa,
-    tpr2010_from_pdd2010,
-)
-
-V1_V2_FITS = {
-    2.0: {"a0": 2.337, "a1": -3.636, "a2": 2.299},
-    2.5: {"a0": 1.474, "a1": -1.587, "a2": 1.114},
-    3.0: {"a0": 1.198, "a1": -0.875, "a2": 0.677},
-    3.5: {"a0": 1.080, "a1": -0.542, "a2": 0.463},
-    4.0: {"a0": 1.022, "a1": -0.363, "a2": 0.341},
-    5.0: {"a0": 0.975, "a1": -0.188, "a2": 0.214},
-}
-
-KQ_PHOTON_TPRS = (
-    0.50,
-    0.53,
-    0.56,
-    0.59,
-    0.62,
-    0.65,
-    0.68,
-    0.70,
-    0.72,
-    0.74,
-    0.76,
-    0.78,
-    0.80,
-    0.82,
-    0.84,
-)
-
-# chamber kQ values from table 6.III
-KQ_PHOTON_CHAMBERS = {
-    # Capintec
-    "PR-06C/G": (
-        1.001,
-        1.001,
-        1.000,
-        0.998,
-        0.998,
-        0.995,
-        0.992,
-        0.990,
-        0.988,
-        0.984,
-        0.980,
-        0.972,
-        0.965,
-        0.956,
-        0.944,
-    ),
-    # Exradin
-    "A12": (
-        1.001,
-        1.001,
-        1.000,
-        1.000,
-        0.999,
-        0.997,
-        0.994,
-        0.992,
-        0.990,
-        0.986,
-        0.981,
-        0.974,
-        0.966,
-        0.957,
-        0.944,
-    ),
-    # Nuclear Associates
-    "30-751": (
-        1.002,
-        1.002,
-        1.000,
-        0.999,
-        0.997,
-        0.994,
-        0.991,
-        0.989,
-        0.985,
-        0.981,
-        0.977,
-        0.969,
-        0.961,
-        0.953,
-        0.940,
-    ),
-    "30-752": (
-        1.004,
-        1.003,
-        1.001,
-        1.000,
-        0.998,
-        0.996,
-        0.993,
-        0.991,
-        0.989,
-        0.985,
-        0.981,
-        0.974,
-        0.967,
-        0.959,
-        0.947,
-    ),
-    # NE
-    "2505": (
-        1.001,
-        1.001,
-        1.000,
-        0.999,
-        0.997,
-        0.994,
-        0.991,
-        0.988,
-        0.984,
-        0.980,
-        0.975,
-        0.967,
-        0.959,
-        0.950,
-        0.937,
-    ),
-    "2505/A": (
-        1.005,
-        1.003,
-        1.001,
-        0.997,
-        0.995,
-        0.990,
-        0.985,
-        0.982,
-        0.978,
-        0.974,
-        0.969,
-        0.962,
-        0.955,
-        0.947,
-        0.936,
-    ),
-    "2505/3, 3A": (
-        1.005,
-        1.004,
-        1.002,
-        1.000,
-        0.998,
-        0.995,
-        0.993,
-        0.991,
-        0.989,
-        0.986,
-        0.982,
-        0.975,
-        0.969,
-        0.961,
-        0.949,
-    ),
-    "2505/3, 3B": (
-        1.006,
-        1.004,
-        1.001,
-        0.999,
-        0.996,
-        0.991,
-        0.987,
-        0.984,
-        0.980,
-        0.976,
-        0.971,
-        0.964,
-        0.957,
-        0.950,
-        0.938,
-    ),
-    "2571": (
-        1.005,
-        1.004,
-        1.002,
-        1.000,
-        0.998,
-        0.995,
-        0.993,
-        0.991,
-        0.989,
-        0.986,
-        0.982,
-        0.975,
-        0.969,
-        0.961,
-        0.949,
-    ),
-    "2581": (
-        1.005,
-        1.003,
-        1.001,
-        0.998,
-        0.995,
-        0.991,
-        0.986,
-        0.983,
-        0.980,
-        0.975,
-        0.970,
-        0.963,
-        0.956,
-        0.949,
-        0.937,
-    ),
-    # PTW
-    "30001": (
-        1.004,
-        1.003,
-        1.001,
-        0.999,
-        0.997,
-        0.994,
-        0.990,
-        0.988,
-        0.985,
-        0.981,
-        0.976,
-        0.969,
-        0.962,
-        0.955,
-        0.943,
-    ),
-    "30010": (
-        1.004,
-        1.003,
-        1.001,
-        0.999,
-        0.997,
-        0.994,
-        0.990,
-        0.988,
-        0.985,
-        0.981,
-        0.976,
-        0.969,
-        0.962,
-        0.955,
-        0.943,
-    ),
-    "30002": (
-        1.006,
-        1.004,
-        1.001,
-        0.999,
-        0.997,
-        0.994,
-        0.992,
-        0.990,
-        0.987,
-        0.984,
-        0.980,
-        0.973,
-        0.967,
-        0.959,
-        0.948,
-    ),
-    "30011": (
-        1.006,
-        1.004,
-        1.001,
-        0.999,
-        0.997,
-        0.994,
-        0.992,
-        0.990,
-        0.987,
-        0.984,
-        0.980,
-        0.973,
-        0.967,
-        0.959,
-        0.948,
-    ),
-    "30004": (
-        1.006,
-        1.005,
-        1.002,
-        1.000,
-        0.999,
-        0.996,
-        0.994,
-        0.992,
-        0.989,
-        0.986,
-        0.982,
-        0.976,
-        0.969,
-        0.962,
-        0.950,
-    ),
-    "30012": (
-        1.006,
-        1.005,
-        1.002,
-        1.000,
-        0.999,
-        0.996,
-        0.994,
-        0.992,
-        0.989,
-        0.986,
-        0.982,
-        0.976,
-        0.969,
-        0.962,
-        0.950,
-    ),
-    "30006": (
-        1.002,
-        1.002,
-        1.000,
-        0.999,
-        0.997,
-        0.994,
-        0.990,
-        0.988,
-        0.984,
-        0.980,
-        0.975,
-        0.968,
-        0.960,
-        0.952,
-        0.940,
-    ),
-    "30013": (
-        1.002,
-        1.002,
-        1.000,
-        0.999,
-        0.997,
-        0.994,
-        0.990,
-        0.988,
-        0.984,
-        0.980,
-        0.975,
-        0.968,
-        0.960,
-        0.952,
-        0.940,
-    ),
-}
-
-KQ_ELECTRON_R50S = (4.0, 4.5, 5.0, 5.5, 6.0, 7.0, 8.0, 10.0, 13.0, 16.0, 20.0)
-
-KQ_ELECTRON_CHAMBERS = {
-    # Capintec
-    "PR06C": (
-        0.916,
-        0.914,
-        0.912,
-        0.911,
-        0.909,
-        0.906,
-        0.904,
-        0.899,
-        0.891,
-        0.884,
-        0.874,
-    ),
-    # Exradin
-    "A12": (
-        0.921,
-        0.919,
-        0.918,
-        0.916,
-        0.914,
-        0.911,
-        0.909,
-        0.903,
-        0.896,
-        0.888,
-        0.878,
-    ),
-    # NE
-    "2571": (
-        0.918,
-        0.916,
-        0.915,
-        0.913,
-        0.911,
-        0.909,
-        0.906,
-        0.901,
-        0.893,
-        0.886,
-        0.876,
-    ),
-    "2581": (
-        0.899,
-        0.898,
-        0.896,
-        0.894,
-        0.893,
-        0.890,
-        0.888,
-        0.882,
-        0.875,
-        0.868,
-        0.859,
-    ),
-    # PTW
-    "30001": (
-        0.911,
-        0.909,
-        0.907,
-        0.905,
-        0.904,
-        0.901,
-        0.898,
-        0.893,
-        0.885,
-        0.877,
-        0.868,
-    ),
-    "30010": (
-        0.911,
-        0.909,
-        0.907,
-        0.905,
-        0.904,
-        0.901,
-        0.898,
-        0.893,
-        0.885,
-        0.877,
-        0.868,
-    ),
-    "30002": (
-        0.916,
-        0.914,
-        0.912,
-        0.910,
-        0.909,
-        0.906,
-        0.903,
-        0.897,
-        0.890,
-        0.882,
-        0.873,
-    ),
-    "30011": (
-        0.916,
-        0.914,
-        0.912,
-        0.910,
-        0.909,
-        0.906,
-        0.903,
-        0.897,
-        0.890,
-        0.882,
-        0.873,
-    ),
-    "30004": (
-        0.920,
-        0.918,
-        0.916,
-        0.915,
-        0.913,
-        0.910,
-        0.907,
-        0.902,
-        0.894,
-        0.887,
-        0.877,
-    ),
-    "30012": (
-        0.920,
-        0.918,
-        0.916,
-        0.915,
-        0.913,
-        0.910,
-        0.907,
-        0.902,
-        0.894,
-        0.887,
-        0.877,
-    ),
-    "30006": (
-        0.911,
-        0.909,
-        0.907,
-        0.906,
-        0.904,
-        0.901,
-        0.898,
-        0.893,
-        0.885,
-        0.878,
-        0.868,
-    ),
-    "30013": (
-        0.911,
-        0.909,
-        0.907,
-        0.906,
-        0.904,
-        0.901,
-        0.898,
-        0.893,
-        0.885,
-        0.878,
-        0.868,
-    ),
-    # Wellhofer
-    "FC65-P": (
-        0.914,
-        0.912,
-        0.911,
-        0.909,
-        0.907,
-        0.904,
-        0.902,
-        0.896,
-        0.889,
-        0.881,
-        0.872,
-    ),
-    "FC65-G": (
-        0.920,
-        0.918,
-        0.916,
-        0.914,
-        0.913,
-        0.910,
-        0.907,
-        0.902,
-        0.894,
-        0.887,
-        0.877,
-    ),
-}
-
-# Rename common functions from TG-51
-k_tp = _tg51.p_tp
-k_pol = _tg51.p_pol
-z_ref = _tg51.d_ref
-r_50 = _tg51.r_50
-
-
-def k_s(
-    *,
-    voltage_reference: int,
-    voltage_reduced: int,
-    m_reference: NumberOrArray,
-    m_reduced: NumberOrArray,
-) -> float:
-    """Calculate the ion recombination effect using readings at two voltages. The voltages should have
-    a ratio of 2, 2.5, 3, 3.5, 4, or 5.
-
-    Parameters
-    ----------
-    voltage_reference : int
-        The voltage at which calibration will be performed (e.g. 300V)
-    voltage_reduced : int
-        The voltage which is lower than reference (e.g. 150V)
-    m_reference : array, float
-        The reading(s) at the reference voltage.
-    m_reduced : array, float
-        The reading(s) at the reduced voltage.
-
-    Returns
-    -------
-    k_s : float
-        The ion recombination factor.
-
-    Raises
-    ------
-    ValueError
-        If the voltage ratio is not valid.
-    ValueError
-        If the calculated ks value is outside the range (1.0, 1.05).
-    """
-    v_ratio = voltage_reference / voltage_reduced
-    _verify_voltage_ratio_is_valid(v_ratio)
-    a = V1_V2_FITS[v_ratio]
-    m_ratio = np.mean(m_reference) / np.mean(m_reduced)
-    argue.verify_bounds(
-        m_ratio,
-        bounds=(MIN_PION, MAX_PION),
-        message="Ks is out of bounds. Verify inputs or check chamber",
-    )
-    return float(a["a0"] + a["a1"] * m_ratio + a["a2"] * (m_ratio**2))
-
-
-def _verify_voltage_ratio_is_valid(voltage_ratio):
-    """Helper function to verify the voltage ratio of high/low is one of a valid set as defined by TRS-398 Table 4.VII"""
-    if not is_close(voltage_ratio, target=(2, 2.5, 3, 3.5, 4, 5), delta=0.001):
-        raise ValueError(
-            "voltage_reference and voltage_reduced are not a valid ratio. Valid ratios are: 2, 2.5, 3, 3.5, 4, 5"
-        )
-
-
-@argue.options(chamber=KQ_PHOTON_CHAMBERS.keys())
-@argue.bounds(tpr=(KQ_PHOTON_TPRS[0], KQ_PHOTON_TPRS[-1]))
-def kq_photon(*, chamber: str, tpr: float) -> float:
-    """Calculate the kQ factor for a photon beam given the chamber model and TPR20/10 using Table 6.III.
-    Linear interpolation is used between given TPR ratios.
-
-    Parameters
-    ----------
-    chamber : str
-        Allowable chambers are those listed in Table 6.III that are also Farmer-type (e.g. Exradin A14 Farmer).
-    tpr : float
-        The ratio of measured TPR(20cm) / TPR(10cm). Note that this can also be calculated from PDD. See :func:`~pylinac.calibration.tg51.tpr2010_from_pdd2010`.
-
-    Returns
-    -------
-    kQ : float
-        The calculated kQ given table Table 6.III
-
-    Raises
-    ------
-    KeyError
-        If the passed chamber is not within the acceptable list.
-    ValueError
-        If the TPR is not within the range defined by Table 6.III
-    """
-    return np.interp([tpr], KQ_PHOTON_TPRS, KQ_PHOTON_CHAMBERS[chamber])[0]
-
-
-@argue.options(chamber=KQ_ELECTRON_CHAMBERS.keys())
-@argue.bounds(r_50=(KQ_ELECTRON_R50S[0], KQ_ELECTRON_R50S[-1]))
-def kq_electron(*, chamber: str, r_50: float) -> float:
-    """Calculate the kQ factor for an electron beam given the chamber model and R50 using Table 7.III.
-    Linear interpolation is used between given R50 values.
-
-    Parameters
-    ----------
-    chamber : str
-        The Farmer-type chambers listed in Table 7.III (e.g. PTW 30004/30012).
-    r_50 : float
-        The depth of R50 in cm in water.
-
-    Returns
-    -------
-    kQ : float
-        The calculated kQ from Table 7.III
-
-    Raises
-    ------
-    KeyError
-        If the passed chamber is not within the acceptable list.
-    ValueError
-        If the R50 is not within the range defined by Table 7.III
-    """
-    return np.interp([r_50], KQ_ELECTRON_R50S, KQ_ELECTRON_CHAMBERS[chamber])[0]
-
-
-def m_corrected(*, m_reference, k_tp, k_elec, k_pol, k_s) -> float:
-    """The fully corrected chamber reading.
-
-    Parameters
-    ----------
-    m_reference : array, float
-        The chamber reading(s) at the calibration position.
-    k_tp : float
-        Temperature/Pressure correction. See :func:`~pylinac.calibration.tg51.p_tp`.
-    k_elec : float
-        Electrometer correction; given by the calibration laboratory.
-    k_pol : float
-        Polarity correction. See :func:`~pylinac.calibration.tg51.p_pol`.
-    k_s : float
-        Ion recombination correction. See :func:`~pylinac.calibration.trs398.k_s`.
-
-    Returns
-    -------
-    m : float
-        The fully corrected chamber reading.
-    """
-    argue.verify_bounds(k_tp, bounds=(MIN_PTP, MAX_PTP))
-    argue.verify_bounds(k_elec, bounds=(MIN_PELEC, MAX_PELEC))
-    argue.verify_bounds(k_pol, bounds=(MIN_PPOL, MAX_PPOL))
-    argue.verify_bounds(k_s, bounds=(MIN_PION, MAX_PION))
-    return float(np.mean(m_reference) * k_tp * k_elec * k_pol * k_s)
-
-
-class TRS398Base(ABC, Structure):
-    @property
-    def k_tp(self):
-        """Temperature/Pressure correction"""
-        return k_tp(temp=self.temp, press=self.press)
-
-    @property
-    def k_pol(self):
-        """Polarity correction"""
-        return k_pol(m_reference=self.m_reference, m_opposite=self.m_opposite)
-
-    @property
-    def k_s(self):
-        """Ionization collection correction."""
-        return k_s(
-            voltage_reference=self.voltage_reference,
-            voltage_reduced=self.voltage_reduced,
-            m_reference=self.m_reference,
-            m_reduced=self.m_reduced,
-        )
-
-    @property
-    def m_corrected(self):
-        """Corrected chamber reading."""
-        return m_corrected(
-            m_reference=self.m_reference,
-            k_tp=self.k_tp,
-            k_elec=self.k_elec,
-            k_pol=self.k_pol,
-            k_s=self.k_s,
-        )
-
-    @property
-    def dose_mu_zref(self):
-        """cGy/MU at a zref depth."""
-        return self.tissue_correction * self.m_corrected * self.n_dw * self.kq / self.mu
-
-    @property
-    def m_corrected_adjusted(self):
-        """Corrected chamber reading after adjusting the output."""
-        # TODO: add check for m adjusted != None
-        return m_corrected(
-            m_reference=self.m_reference_adjusted,
-            k_tp=self.k_tp,
-            k_elec=self.k_elec,
-            k_pol=self.k_pol,
-            k_s=self.k_s,
-        )
-
-    @property
-    def dose_mu_zref_adjusted(self):
-        """The dose/mu at 10cm depth after adjustment."""
-        return (
-            self.tissue_correction
-            * self.m_corrected_adjusted
-            * self.n_dw
-            * self.kq
-            / self.mu
-        )
-
-    @property
-    def output_was_adjusted(self):
-        """Boolean specifiying if output was adjusted."""
-        return self.m_reference_adjusted is not None
-
-
-class TRS398Photon(TRS398Base):
-    """Calculation of dose to water at zmax and zref from a high energy photon beam. Setup can be SSD or SAD.
-
-    Parameters
-    ----------
-    setup : {'SSD', 'SAD'}
-        The physical setup of the calibration.
-    institution : str
-        Institution name.
-    physicist : str
-        Physicist performing calibration.
-    unit : str
-        Unit name; e.g. TrueBeam1.
-    measurement_date : str
-        Date of measurement. E.g. 10/22/2018.
-    chamber : str
-        Farmer-type chamber model from Table 6.III.
-    n_dw : float
-        NDw of the chamber given by the calibration laboratory.
-    mu : float, int
-        The number of MU given per reading
-    energy : int
-        Nominal energy of the linac in MV; e.g. 6. Bookkeeping only.
-    fff : bool
-        Whether the beam is FFF or flat. Bookkeeping only.
-    tpr2010 : float
-        The value of TPR(20)/TPR(10). Can be derived from PDD; see :func:`~pylinac.calibration.tg51.tpr2010_from_pdd2010`.
-    press : float
-        The value of pressure in kPa. Can be converted from mmHg and mbar; see :func:`~pylinac.calibration.tg51.mmHg2kPa` and :func:`~pylinac.calibration.tg51.mbar2kPa`.
-    temp : float
-        The temperature in Celsius.
-    voltage_reference : int
-        The reference voltage; i.e. the voltage for the calibration reading (e.g. 300V).
-    voltage_reduced : int
-        The reduced voltage, usually a fraction of the reference voltage (e.g. 150V).
-    m_reference : array, float
-        The reading(s) of the chamber at reference voltage.
-    m_reduced : array, float
-        The reading(s) of the chamber at the reduced voltage.
-    m_opposite : array, float
-        The reading(s) of the chamber at the opposite voltage from reference. Sign of the reading does not matter.
-    k_elec : float
-        The electrometer correction value given by the calibration laboratory.
-    clinical_pdd_zref : optional, float
-        The PDD at the depth of calibration. Use the actual percentage (e.g. 66.7 not 0.667). If not supplied the clinical_tmr_zref value must be supplied.
-    clinical_tmr_zref : optional, float
-        The TMR at the depth of calibration. If not supplied the clinical_pdd_zref value must be supplied.
-    tissue_correction : float
-        The correction of calibration to a medium other than water. Default value is 1 which is water. E.g. use 0.99 if calibrating to muscle.
-    """
-
-    @argue.options(setup=("SSD", "SAD"))
-    @argue.options(chamber=KQ_PHOTON_CHAMBERS.keys())
-    @argue.bounds(tpr2010=(KQ_PHOTON_TPRS[0], KQ_PHOTON_TPRS[-1]))
-    def __init__(
-        self,
-        *,
-        institution: str = "",
-        physicist: str = "",
-        unit: str = "",
-        measurement_date: str = "",
-        electrometer: str = "",
-        setup: str,
-        chamber: str,
-        n_dw: float,
-        mu: int,
-        tpr2010: float,
-        energy: int,
-        fff: bool,
-        press: float,
-        temp: float,
-        voltage_reference: int,
-        voltage_reduced: int,
-        m_reference: Union[tuple, float],
-        m_reduced: Union[tuple, float],
-        m_opposite: Union[tuple, float],
-        k_elec: float,
-        clinical_pdd_zref: Optional[float] = None,
-        clinical_tmr_zref: Optional[float] = None,
-        tissue_correction: float = 1.0,
-    ):
-        super().__init__(
-            chamber=chamber,
-            tpr2010=tpr2010,
-            press=press,
-            temp=temp,
-            voltage_reference=voltage_reference,
-            voltage_reduced=voltage_reduced,
-            m_reference=m_reference,
-            m_reduced=m_reduced,
-            m_opposite=m_opposite,
-            k_elec=k_elec,
-            clinical_pdd_zref=clinical_pdd_zref,
-            clinical_tmr_zref=clinical_tmr_zref,
-            n_dw=n_dw,
-            setup=setup,
-            mu=mu,
-            tissue_correction=tissue_correction,
-            fff=fff,
-            energy=energy,
-            institution=institution,
-            physicist=physicist,
-            unit=unit,
-            measurement_date=measurement_date,
-            electrometer=electrometer,
-        )
-        self.m_reference_adjusted = None
-
-    @property
-    def kq(self):
-        """kQ of the chamber and TPR."""
-        return kq_photon(chamber=self.chamber, tpr=self.tpr2010)
-
-    @property
-    def dose_mu_zmax(self):
-        """cGy/MU at a depth of zmax."""
-        if self.setup == "SSD":
-            return (100 * self.dose_mu_zref) / self.clinical_pdd_zref
-        else:
-            return self.dose_mu_zref / self.clinical_tmr_zref
-
-    @property
-    def dose_mu_zmax_adjusted(self):
-        """The dose/mu at dmax depth after adjustment."""
-        if self.setup == "SSD":
-            return (100 * self.dose_mu_zref_adjusted) / self.clinical_pdd_zref
-        else:
-            return self.dose_mu_zref_adjusted / self.clinical_tmr_zref
-
-    def publish_pdf(
-        self,
-        filename: str,
-        notes: Optional[list] = None,
-        open_file: bool = False,
-        metadata: Optional[dict] = None,
-    ):
-        """Publish (print) a PDF containing the analysis and quantitative results.
-
-        Parameters
-        ----------
-        filename : str, file-like object
-            The file to write the results to.
-        notes : str, list
-            Any notes to be added to the report. If a string, adds everything as one line.
-            If a list, must be a list of strings; each string item will be a new line.
-        open_file : bool
-            Whether to open the file after creation. Will use the default PDF program.
-        metadata : dict
-            Any data that should be appended to every page of the report. This differs from notes in that
-            metadata is at the top of every page while notes is at the bottom of the report.
-        """
-        was_adjusted = "Yes" if self.output_was_adjusted else "No"
-        title = f"TRS-398 Photon Report - {self.energy} MV"
-        if self.fff:
-            title += " FFF"
-
-        canvas = PylinacCanvas(filename, page_title=title, metadata=metadata)
-        text = [
-            "Site Data:",
-            f"Institution: {self.institution}",
-            f"Performed by: {self.physicist}",
-            f"Measurement Date: {self.measurement_date}",
-            f'Date of Report: {datetime.now().strftime("%A, %B %d, %Y")}',
-            f"Unit: {self.unit}",
-            f"Energy: {self.energy} MV {'FFF' if self.fff else ''}",
-            "",
-            "Instrumentation:",
-            f"Chamber: {self.chamber}",
-            f"Chamber Calibration Factor Ndw (cGy/nC): {self.n_dw:2.3f}",
-            f"Electrometer: {self.electrometer}",
-            f"Kelec: {self.k_elec:2.3f}",
-            f"MU: {self.mu}",
-            "",
-            "Beam Quality:",
-            f"TPR(20)/TPR(10): {self.tpr2010:2.3f}",
-            f"Determined kQ: {self.kq:2.3f}",
-            "",
-            "Chamber Corrections/Measurements:",
-            f"Temperature (\N{DEGREE SIGN}C): {self.temp:2.1f}",
-            f"Pressure (kPa): {self.press:2.1f}",
-            f"Mraw @ ({self.voltage_reference}V, Reference) (nC): {self.m_reference}",
-            f"Mraw @ ({self.voltage_reduced}V, Reduced) (nC): {self.m_reduced}",
-            f"Mraw @ ({-self.voltage_reference}V, Opposite) (nC): {self.m_opposite}",
-            f"Ktp: {self.k_tp:2.3f}",
-            f"Ks: {self.k_s:2.3f}",
-            f"Kpol: {self.k_pol:2.3f}",
-            "",
-            "Dose Determination:",
-            f"Fully corrected M (nC): {self.m_corrected:2.3f}",
-            f"Tissue correction (e.g. muscle): {self.tissue_correction:2.3f}",
-            f"Dose/MU @ zref depth (cGy): {self.dose_mu_zref:2.3f}",
-        ]
-        if self.setup == "SSD":
-            text.append(
-                f"Clinical PDD (%): {self.clinical_pdd_zref:2.2f}",
-            )
-        else:
-            text.append(
-                f"Clinical TMR (%): {self.clinical_tmr_zref:2.2f}",
-            )
-        text.append(f"Dose/MU @ zmax (cGy): {self.dose_mu_zmax:2.3f}")
-        text.append("")
-        text.append(f"Output Adjustment?: {was_adjusted}")
-        if was_adjusted == "Yes":
-            text.append(
-                f"Adjusted Mraw @ reference voltage (nC): {self.m_reference_adjusted}"
-            )
-            text.append(
-                f"Adjusted fully corrected M (nC): {self.m_corrected_adjusted:2.3f}"
-            )
-            text.append(
-                f"Adjusted Dose/MU @ zref depth (cGy): {self.dose_mu_zref_adjusted:2.3f}"
-            )
-            text.append(
-                f"Adjusted Dose/MU @ zmax (cGy): {self.dose_mu_zmax_adjusted:2.3f}"
-            )
-        canvas.add_text(text=text, location=(2, 25.5), font_size=12)
-        if notes is not None:
-            canvas.add_text(text="Notes:", location=(12, 6.5), font_size=14)
-            canvas.add_text(text=notes, location=(12, 6))
-
-        canvas.finish()
-
-        if open_file:
-            webbrowser.open(filename)
-
-
-class TRS398Electron(TRS398Base):
-    """Calculation of dose to water at zmax and zref from a high energy electron beam.
-
-    Parameters
-    ----------
-    institution : str
-        Institution name.
-    physicist : str
-        Physicist performing calibration.
-    unit : str
-        Unit name; e.g. TrueBeam1.
-    measurement_date : str
-        Date of measurement. E.g. 10/22/2018.
-    chamber : str
-        Farmer-type chamber model from Table 6.III.
-    n_dw : float
-        NDw of the chamber given by the calibration laboratory.
-    mu : float, int
-        The number of MU given per reading.
-    i_50 : float
-        The depth of ionization 50% in cm.
-    press : float
-        The value of pressure in kPa. Can be converted from mmHg and mbar; see :func:`~pylinac.calibration.tg51.mmHg2kPa` and :func:`~pylinac.calibration.tg51.mbar2kPa`.
-    temp : float
-        The temperature in Celsius.
-    voltage_reference : int
-        The reference voltage; i.e. the voltage for the calibration reading (e.g. 300V).
-    voltage_reduced : int
-        The reduced voltage, usually a fraction of the reference voltage (e.g. 150V).
-    m_reference : array, float
-        The reading(s) of the chamber at reference voltage.
-    m_reduced : array, float
-        The reading(s) of the chamber at the reduced voltage.
-    m_opposite : array, float
-        The reading(s) of the chamber at the opposite voltage from reference. Sign of the reading does not matter.
-    k_elec : float
-        The electrometer correction value given by the calibration laboratory.
-    pdd_zref : optional, float
-        The PDD at the depth of calibration. Use the actual percentage (e.g. 66.7 not 0.667). If not supplied the tmr_zref value should be supplied.
-    tissue_correction : float
-        The correction of calibration to a medium other than water. Default value is 1 which is water. E.g. use 0.99 if calibrating to muscle.
-    """
-
-    def __init__(
-        self,
-        *,
-        institution: str = "",
-        physicist: str = "",
-        unit: str = "",
-        measurement_date: str = "",
-        electrometer: str = "",
-        energy: str,
-        cone: str,
-        chamber: str,
-        n_dw: float,
-        mu: int,
-        i_50: float,
-        press: float,
-        temp: float,
-        voltage_reference: int,
-        voltage_reduced: int,
-        m_reference: tuple,
-        m_reduced: tuple,
-        m_opposite: tuple,
-        k_elec: float,
-        clinical_pdd_zref: float,
-        tissue_correction: float = 1.0,
-    ):
-        super().__init__(
-            chamber=chamber,
-            i_50=i_50,
-            press=press,
-            temp=temp,
-            energy=energy,
-            institution=institution,
-            voltage_reference=voltage_reference,
-            voltage_reduced=voltage_reduced,
-            m_reference=m_reference,
-            m_reduced=m_reduced,
-            m_opposite=m_opposite,
-            k_elec=k_elec,
-            clinical_pdd_zref=clinical_pdd_zref,
-            n_dw=n_dw,
-            mu=mu,
-            tissue_correction=tissue_correction,
-            physicist=physicist,
-            unit=unit,
-            measurement_date=measurement_date,
-            electrometer=electrometer,
-            cone=cone,
-        )
-        self.m_reference_adjusted = None
-
-    @property
-    def r_50(self) -> float:
-        """The depth of R50 in cm, derived from I50."""
-        return r_50(i_50=self.i_50)
-
-    @property
-    def zref(self) -> float:
-        """Depth of the reference point."""
-        return z_ref(i_50=self.i_50)
-
-    @property
-    def kq(self):
-        """kQ given the chamber and R50."""
-        return kq_electron(chamber=self.chamber, r_50=self.r_50)
-
-    @property
-    def dose_mu_zmax(self):
-        """cGy/MU at a depth of zmax."""
-        return (100 * self.dose_mu_zref) / self.clinical_pdd_zref
-
-    @property
-    def dose_mu_zmax_adjusted(self):
-        """The dose/mu at dmax depth after adjustment."""
-        return (100 * self.dose_mu_zref_adjusted) / self.clinical_pdd_zref
-
-    def publish_pdf(
-        self,
-        filename: str,
-        notes: Optional[list] = None,
-        open_file: bool = False,
-        metadata: Optional[dict] = None,
-    ):
-        """Publish (print) a PDF containing the analysis and quantitative results.
-
-        Parameters
-        ----------
-        filename : str, file-like object
-            The file to write the results to.
-        notes : str, list
-            Any notes to be added to the report. If a string, adds everything as one line.
-            If a list, must be a list of strings; each string item will be a new line.
-        open_file : bool
-            Whether to open the file after creation. Will use the default PDF program.
-        metadata : dict
-            Any data that should be appended to every page of the report. This differs from notes in that
-            metadata is at the top of every page while notes is at the bottom of the report.
-        """
-        was_adjusted = "Yes" if self.output_was_adjusted else "No"
-        title = f"TRS-398 Electron Report - {self.energy} MV"
-
-        canvas = PylinacCanvas(filename, page_title=title, metadata=metadata)
-        text = [
-            "Site Data:",
-            f"Institution: {self.institution}",
-            f"Performed by: {self.physicist}",
-            f"Measurement Date: {self.measurement_date}",
-            f'Date of Report: {datetime.now().strftime("%A, %B %d, %Y")}',
-            f"Unit: {self.unit}",
-            f"Energy: {self.energy} MeV",
-            f"Cone: {self.cone}",
-            f"MU: {self.mu}",
-            "",
-            "Instrumentation:",
-            f"Chamber: {self.chamber}",
-            f"Chamber Calibration Factor Ndw (cGy/nC): {self.n_dw:2.3f}",
-            f"Electrometer: {self.electrometer}",
-            f"Kelec: {self.k_elec:2.3f}",
-            "",
-            "Beam Quality:",
-            f"I50 (cm): {self.i_50:2.2f}",
-            f"R50 (cm): {self.r_50:2.2f}",
-            f"Zref (cm): {self.zref:2.2f}",
-            f"Calculated kQ: {self.kq:2.3f}",
-            "",
-            "Chamber Corrections/Measurements:",
-            f"Temperature (\N{DEGREE SIGN}C): {self.temp:2.1f}",
-            f"Pressure (kPa): {self.press:2.1f}",
-            f"Mraw @ ({self.voltage_reference}V, Reference) (nC): {self.m_reference}",
-            f"Mraw @ ({self.voltage_reduced}V, Reduced) (nC): {self.m_reduced}",
-            f"Mraw @ ({-self.voltage_reference}V, Opposite) (nC): {self.m_opposite}",
-            f"Ktp: {self.k_tp:2.3f}",
-            f"Ks: {self.k_s:2.3f}",
-            f"Kpol: {self.k_pol:2.3f}",
-            "",
-            "Dose Determination:",
-            f"Fully corrected M (nC): {self.m_corrected:2.3f}",
-            f"Tissue correction (e.g. muscle): {self.tissue_correction:2.3f}",
-            f"Dose/MU @ zref (cGy): {self.dose_mu_zref:2.3f}",
-            f"Clinical PDD (%): {self.clinical_pdd_zref:2.2f}",
-            f"Dose/MU @ zmax (cGy): {self.dose_mu_zmax:2.3f}",
-            "",
-            f"Output Adjustment?: {was_adjusted}",
-        ]
-        if was_adjusted == "Yes":
-            text.append(
-                f"Adjusted Mraw @ reference voltage (nC): {self.m_reference_adjusted}"
-            )
-            text.append(
-                f"Adjusted fully corrected M (nC): {self.m_corrected_adjusted:2.3f}"
-            )
-            text.append(
-                f"Adjusted Dose/MU @ zref depth (cGy): {self.dose_mu_zref_adjusted:2.3f}"
-            )
-            text.append(
-                f"Adjusted Dose/MU @ zmax (cGy): {self.dose_mu_zmax_adjusted:2.3f}"
-            )
-        canvas.add_text(text=text, location=(2, 25.5), font_size=12)
-        if notes is not None:
-            canvas.add_text(text="Notes:", location=(12, 6.5), font_size=14)
-            canvas.add_text(text=notes, location=(12, 6))
-
-        canvas.finish()
-
-        if open_file:
-            webbrowser.open(filename)
+import webbrowser
+from abc import ABC
+from datetime import datetime
+from typing import Optional, Union
+
+import argue
+import numpy as np
+
+from ..core.pdf import PylinacCanvas
+from ..core.typing import NumberOrArray
+from ..core.utilities import Structure, is_close
+from . import tg51 as _tg51
+from .tg51 import MAX_PPOL  # make available to module
+from .tg51 import (
+    MAX_PELEC,
+    MAX_PION,
+    MAX_PTP,
+    MIN_PELEC,
+    MIN_PION,
+    MIN_PPOL,
+    MIN_PTP,
+    fahrenheit2celsius,
+    mbar2kPa,
+    mmHg2kPa,
+    tpr2010_from_pdd2010,
+)
+
+V1_V2_FITS = {
+    2.0: {"a0": 2.337, "a1": -3.636, "a2": 2.299},
+    2.5: {"a0": 1.474, "a1": -1.587, "a2": 1.114},
+    3.0: {"a0": 1.198, "a1": -0.875, "a2": 0.677},
+    3.5: {"a0": 1.080, "a1": -0.542, "a2": 0.463},
+    4.0: {"a0": 1.022, "a1": -0.363, "a2": 0.341},
+    5.0: {"a0": 0.975, "a1": -0.188, "a2": 0.214},
+}
+
+KQ_PHOTON_TPRS = (
+    0.50,
+    0.53,
+    0.56,
+    0.59,
+    0.62,
+    0.65,
+    0.68,
+    0.70,
+    0.72,
+    0.74,
+    0.76,
+    0.78,
+    0.80,
+    0.82,
+    0.84,
+)
+
+# chamber kQ values from table 6.III
+KQ_PHOTON_CHAMBERS = {
+    # Capintec
+    "PR-06C/G": (
+        1.001,
+        1.001,
+        1.000,
+        0.998,
+        0.998,
+        0.995,
+        0.992,
+        0.990,
+        0.988,
+        0.984,
+        0.980,
+        0.972,
+        0.965,
+        0.956,
+        0.944,
+    ),
+    # Exradin
+    "A12": (
+        1.001,
+        1.001,
+        1.000,
+        1.000,
+        0.999,
+        0.997,
+        0.994,
+        0.992,
+        0.990,
+        0.986,
+        0.981,
+        0.974,
+        0.966,
+        0.957,
+        0.944,
+    ),
+    # Nuclear Associates
+    "30-751": (
+        1.002,
+        1.002,
+        1.000,
+        0.999,
+        0.997,
+        0.994,
+        0.991,
+        0.989,
+        0.985,
+        0.981,
+        0.977,
+        0.969,
+        0.961,
+        0.953,
+        0.940,
+    ),
+    "30-752": (
+        1.004,
+        1.003,
+        1.001,
+        1.000,
+        0.998,
+        0.996,
+        0.993,
+        0.991,
+        0.989,
+        0.985,
+        0.981,
+        0.974,
+        0.967,
+        0.959,
+        0.947,
+    ),
+    # NE
+    "2505": (
+        1.001,
+        1.001,
+        1.000,
+        0.999,
+        0.997,
+        0.994,
+        0.991,
+        0.988,
+        0.984,
+        0.980,
+        0.975,
+        0.967,
+        0.959,
+        0.950,
+        0.937,
+    ),
+    "2505/A": (
+        1.005,
+        1.003,
+        1.001,
+        0.997,
+        0.995,
+        0.990,
+        0.985,
+        0.982,
+        0.978,
+        0.974,
+        0.969,
+        0.962,
+        0.955,
+        0.947,
+        0.936,
+    ),
+    "2505/3, 3A": (
+        1.005,
+        1.004,
+        1.002,
+        1.000,
+        0.998,
+        0.995,
+        0.993,
+        0.991,
+        0.989,
+        0.986,
+        0.982,
+        0.975,
+        0.969,
+        0.961,
+        0.949,
+    ),
+    "2505/3, 3B": (
+        1.006,
+        1.004,
+        1.001,
+        0.999,
+        0.996,
+        0.991,
+        0.987,
+        0.984,
+        0.980,
+        0.976,
+        0.971,
+        0.964,
+        0.957,
+        0.950,
+        0.938,
+    ),
+    "2571": (
+        1.005,
+        1.004,
+        1.002,
+        1.000,
+        0.998,
+        0.995,
+        0.993,
+        0.991,
+        0.989,
+        0.986,
+        0.982,
+        0.975,
+        0.969,
+        0.961,
+        0.949,
+    ),
+    "2581": (
+        1.005,
+        1.003,
+        1.001,
+        0.998,
+        0.995,
+        0.991,
+        0.986,
+        0.983,
+        0.980,
+        0.975,
+        0.970,
+        0.963,
+        0.956,
+        0.949,
+        0.937,
+    ),
+    # PTW
+    "30001": (
+        1.004,
+        1.003,
+        1.001,
+        0.999,
+        0.997,
+        0.994,
+        0.990,
+        0.988,
+        0.985,
+        0.981,
+        0.976,
+        0.969,
+        0.962,
+        0.955,
+        0.943,
+    ),
+    "30010": (
+        1.004,
+        1.003,
+        1.001,
+        0.999,
+        0.997,
+        0.994,
+        0.990,
+        0.988,
+        0.985,
+        0.981,
+        0.976,
+        0.969,
+        0.962,
+        0.955,
+        0.943,
+    ),
+    "30002": (
+        1.006,
+        1.004,
+        1.001,
+        0.999,
+        0.997,
+        0.994,
+        0.992,
+        0.990,
+        0.987,
+        0.984,
+        0.980,
+        0.973,
+        0.967,
+        0.959,
+        0.948,
+    ),
+    "30011": (
+        1.006,
+        1.004,
+        1.001,
+        0.999,
+        0.997,
+        0.994,
+        0.992,
+        0.990,
+        0.987,
+        0.984,
+        0.980,
+        0.973,
+        0.967,
+        0.959,
+        0.948,
+    ),
+    "30004": (
+        1.006,
+        1.005,
+        1.002,
+        1.000,
+        0.999,
+        0.996,
+        0.994,
+        0.992,
+        0.989,
+        0.986,
+        0.982,
+        0.976,
+        0.969,
+        0.962,
+        0.950,
+    ),
+    "30012": (
+        1.006,
+        1.005,
+        1.002,
+        1.000,
+        0.999,
+        0.996,
+        0.994,
+        0.992,
+        0.989,
+        0.986,
+        0.982,
+        0.976,
+        0.969,
+        0.962,
+        0.950,
+    ),
+    "30006": (
+        1.002,
+        1.002,
+        1.000,
+        0.999,
+        0.997,
+        0.994,
+        0.990,
+        0.988,
+        0.984,
+        0.980,
+        0.975,
+        0.968,
+        0.960,
+        0.952,
+        0.940,
+    ),
+    "30013": (
+        1.002,
+        1.002,
+        1.000,
+        0.999,
+        0.997,
+        0.994,
+        0.990,
+        0.988,
+        0.984,
+        0.980,
+        0.975,
+        0.968,
+        0.960,
+        0.952,
+        0.940,
+    ),
+}
+
+KQ_ELECTRON_R50S = (4.0, 4.5, 5.0, 5.5, 6.0, 7.0, 8.0, 10.0, 13.0, 16.0, 20.0)
+
+KQ_ELECTRON_CHAMBERS = {
+    # Capintec
+    "PR06C": (
+        0.916,
+        0.914,
+        0.912,
+        0.911,
+        0.909,
+        0.906,
+        0.904,
+        0.899,
+        0.891,
+        0.884,
+        0.874,
+    ),
+    # Exradin
+    "A12": (
+        0.921,
+        0.919,
+        0.918,
+        0.916,
+        0.914,
+        0.911,
+        0.909,
+        0.903,
+        0.896,
+        0.888,
+        0.878,
+    ),
+    # NE
+    "2571": (
+        0.918,
+        0.916,
+        0.915,
+        0.913,
+        0.911,
+        0.909,
+        0.906,
+        0.901,
+        0.893,
+        0.886,
+        0.876,
+    ),
+    "2581": (
+        0.899,
+        0.898,
+        0.896,
+        0.894,
+        0.893,
+        0.890,
+        0.888,
+        0.882,
+        0.875,
+        0.868,
+        0.859,
+    ),
+    # PTW
+    "30001": (
+        0.911,
+        0.909,
+        0.907,
+        0.905,
+        0.904,
+        0.901,
+        0.898,
+        0.893,
+        0.885,
+        0.877,
+        0.868,
+    ),
+    "30010": (
+        0.911,
+        0.909,
+        0.907,
+        0.905,
+        0.904,
+        0.901,
+        0.898,
+        0.893,
+        0.885,
+        0.877,
+        0.868,
+    ),
+    "30002": (
+        0.916,
+        0.914,
+        0.912,
+        0.910,
+        0.909,
+        0.906,
+        0.903,
+        0.897,
+        0.890,
+        0.882,
+        0.873,
+    ),
+    "30011": (
+        0.916,
+        0.914,
+        0.912,
+        0.910,
+        0.909,
+        0.906,
+        0.903,
+        0.897,
+        0.890,
+        0.882,
+        0.873,
+    ),
+    "30004": (
+        0.920,
+        0.918,
+        0.916,
+        0.915,
+        0.913,
+        0.910,
+        0.907,
+        0.902,
+        0.894,
+        0.887,
+        0.877,
+    ),
+    "30012": (
+        0.920,
+        0.918,
+        0.916,
+        0.915,
+        0.913,
+        0.910,
+        0.907,
+        0.902,
+        0.894,
+        0.887,
+        0.877,
+    ),
+    "30006": (
+        0.911,
+        0.909,
+        0.907,
+        0.906,
+        0.904,
+        0.901,
+        0.898,
+        0.893,
+        0.885,
+        0.878,
+        0.868,
+    ),
+    "30013": (
+        0.911,
+        0.909,
+        0.907,
+        0.906,
+        0.904,
+        0.901,
+        0.898,
+        0.893,
+        0.885,
+        0.878,
+        0.868,
+    ),
+    # Wellhofer
+    "FC65-P": (
+        0.914,
+        0.912,
+        0.911,
+        0.909,
+        0.907,
+        0.904,
+        0.902,
+        0.896,
+        0.889,
+        0.881,
+        0.872,
+    ),
+    "FC65-G": (
+        0.920,
+        0.918,
+        0.916,
+        0.914,
+        0.913,
+        0.910,
+        0.907,
+        0.902,
+        0.894,
+        0.887,
+        0.877,
+    ),
+}
+
+# Rename common functions from TG-51
+k_tp = _tg51.p_tp
+k_pol = _tg51.p_pol
+z_ref = _tg51.d_ref
+r_50 = _tg51.r_50
+
+
+def k_s(
+    *,
+    voltage_reference: int,
+    voltage_reduced: int,
+    m_reference: NumberOrArray,
+    m_reduced: NumberOrArray,
+) -> float:
+    """Calculate the ion recombination effect using readings at two voltages. The voltages should have
+    a ratio of 2, 2.5, 3, 3.5, 4, or 5.
+
+    Parameters
+    ----------
+    voltage_reference : int
+        The voltage at which calibration will be performed (e.g. 300V)
+    voltage_reduced : int
+        The voltage which is lower than reference (e.g. 150V)
+    m_reference : array, float
+        The reading(s) at the reference voltage.
+    m_reduced : array, float
+        The reading(s) at the reduced voltage.
+
+    Returns
+    -------
+    k_s : float
+        The ion recombination factor.
+
+    Raises
+    ------
+    ValueError
+        If the voltage ratio is not valid.
+    ValueError
+        If the calculated ks value is outside the range (1.0, 1.05).
+    """
+    v_ratio = voltage_reference / voltage_reduced
+    _verify_voltage_ratio_is_valid(v_ratio)
+    a = V1_V2_FITS[v_ratio]
+    m_ratio = np.mean(m_reference) / np.mean(m_reduced)
+    argue.verify_bounds(
+        m_ratio,
+        bounds=(MIN_PION, MAX_PION),
+        message="Ks is out of bounds. Verify inputs or check chamber",
+    )
+    return float(a["a0"] + a["a1"] * m_ratio + a["a2"] * (m_ratio**2))
+
+
+def _verify_voltage_ratio_is_valid(voltage_ratio):
+    """Helper function to verify the voltage ratio of high/low is one of a valid set as defined by TRS-398 Table 4.VII"""
+    if not is_close(voltage_ratio, target=(2, 2.5, 3, 3.5, 4, 5), delta=0.001):
+        raise ValueError(
+            "voltage_reference and voltage_reduced are not a valid ratio. Valid ratios are: 2, 2.5, 3, 3.5, 4, 5"
+        )
+
+
+@argue.options(chamber=KQ_PHOTON_CHAMBERS.keys())
+@argue.bounds(tpr=(KQ_PHOTON_TPRS[0], KQ_PHOTON_TPRS[-1]))
+def kq_photon(*, chamber: str, tpr: float) -> float:
+    """Calculate the kQ factor for a photon beam given the chamber model and TPR20/10 using Table 6.III.
+    Linear interpolation is used between given TPR ratios.
+
+    Parameters
+    ----------
+    chamber : str
+        Allowable chambers are those listed in Table 6.III that are also Farmer-type (e.g. Exradin A14 Farmer).
+    tpr : float
+        The ratio of measured TPR(20cm) / TPR(10cm). Note that this can also be calculated from PDD. See :func:`~pylinac.calibration.tg51.tpr2010_from_pdd2010`.
+
+    Returns
+    -------
+    kQ : float
+        The calculated kQ given table Table 6.III
+
+    Raises
+    ------
+    KeyError
+        If the passed chamber is not within the acceptable list.
+    ValueError
+        If the TPR is not within the range defined by Table 6.III
+    """
+    return np.interp([tpr], KQ_PHOTON_TPRS, KQ_PHOTON_CHAMBERS[chamber])[0]
+
+
+@argue.options(chamber=KQ_ELECTRON_CHAMBERS.keys())
+@argue.bounds(r_50=(KQ_ELECTRON_R50S[0], KQ_ELECTRON_R50S[-1]))
+def kq_electron(*, chamber: str, r_50: float) -> float:
+    """Calculate the kQ factor for an electron beam given the chamber model and R50 using Table 7.III.
+    Linear interpolation is used between given R50 values.
+
+    Parameters
+    ----------
+    chamber : str
+        The Farmer-type chambers listed in Table 7.III (e.g. PTW 30004/30012).
+    r_50 : float
+        The depth of R50 in cm in water.
+
+    Returns
+    -------
+    kQ : float
+        The calculated kQ from Table 7.III
+
+    Raises
+    ------
+    KeyError
+        If the passed chamber is not within the acceptable list.
+    ValueError
+        If the R50 is not within the range defined by Table 7.III
+    """
+    return np.interp([r_50], KQ_ELECTRON_R50S, KQ_ELECTRON_CHAMBERS[chamber])[0]
+
+
+def m_corrected(*, m_reference, k_tp, k_elec, k_pol, k_s) -> float:
+    """The fully corrected chamber reading.
+
+    Parameters
+    ----------
+    m_reference : array, float
+        The chamber reading(s) at the calibration position.
+    k_tp : float
+        Temperature/Pressure correction. See :func:`~pylinac.calibration.tg51.p_tp`.
+    k_elec : float
+        Electrometer correction; given by the calibration laboratory.
+    k_pol : float
+        Polarity correction. See :func:`~pylinac.calibration.tg51.p_pol`.
+    k_s : float
+        Ion recombination correction. See :func:`~pylinac.calibration.trs398.k_s`.
+
+    Returns
+    -------
+    m : float
+        The fully corrected chamber reading.
+    """
+    argue.verify_bounds(k_tp, bounds=(MIN_PTP, MAX_PTP))
+    argue.verify_bounds(k_elec, bounds=(MIN_PELEC, MAX_PELEC))
+    argue.verify_bounds(k_pol, bounds=(MIN_PPOL, MAX_PPOL))
+    argue.verify_bounds(k_s, bounds=(MIN_PION, MAX_PION))
+    return float(np.mean(m_reference) * k_tp * k_elec * k_pol * k_s)
+
+
+class TRS398Base(ABC, Structure):
+    @property
+    def k_tp(self):
+        """Temperature/Pressure correction"""
+        return k_tp(temp=self.temp, press=self.press)
+
+    @property
+    def k_pol(self):
+        """Polarity correction"""
+        return k_pol(m_reference=self.m_reference, m_opposite=self.m_opposite)
+
+    @property
+    def k_s(self):
+        """Ionization collection correction."""
+        return k_s(
+            voltage_reference=self.voltage_reference,
+            voltage_reduced=self.voltage_reduced,
+            m_reference=self.m_reference,
+            m_reduced=self.m_reduced,
+        )
+
+    @property
+    def m_corrected(self):
+        """Corrected chamber reading."""
+        return m_corrected(
+            m_reference=self.m_reference,
+            k_tp=self.k_tp,
+            k_elec=self.k_elec,
+            k_pol=self.k_pol,
+            k_s=self.k_s,
+        )
+
+    @property
+    def dose_mu_zref(self):
+        """cGy/MU at a zref depth."""
+        return self.tissue_correction * self.m_corrected * self.n_dw * self.kq / self.mu
+
+    @property
+    def m_corrected_adjusted(self):
+        """Corrected chamber reading after adjusting the output."""
+        # TODO: add check for m adjusted != None
+        return m_corrected(
+            m_reference=self.m_reference_adjusted,
+            k_tp=self.k_tp,
+            k_elec=self.k_elec,
+            k_pol=self.k_pol,
+            k_s=self.k_s,
+        )
+
+    @property
+    def dose_mu_zref_adjusted(self):
+        """The dose/mu at 10cm depth after adjustment."""
+        return (
+            self.tissue_correction
+            * self.m_corrected_adjusted
+            * self.n_dw
+            * self.kq
+            / self.mu
+        )
+
+    @property
+    def output_was_adjusted(self):
+        """Boolean specifiying if output was adjusted."""
+        return self.m_reference_adjusted is not None
+
+
+class TRS398Photon(TRS398Base):
+    """Calculation of dose to water at zmax and zref from a high energy photon beam. Setup can be SSD or SAD.
+
+    Parameters
+    ----------
+    setup : {'SSD', 'SAD'}
+        The physical setup of the calibration.
+    institution : str
+        Institution name.
+    physicist : str
+        Physicist performing calibration.
+    unit : str
+        Unit name; e.g. TrueBeam1.
+    measurement_date : str
+        Date of measurement. E.g. 10/22/2018.
+    chamber : str
+        Farmer-type chamber model from Table 6.III.
+    n_dw : float
+        NDw of the chamber given by the calibration laboratory.
+    mu : float, int
+        The number of MU given per reading
+    energy : int
+        Nominal energy of the linac in MV; e.g. 6. Bookkeeping only.
+    fff : bool
+        Whether the beam is FFF or flat. Bookkeeping only.
+    tpr2010 : float
+        The value of TPR(20)/TPR(10). Can be derived from PDD; see :func:`~pylinac.calibration.tg51.tpr2010_from_pdd2010`.
+    press : float
+        The value of pressure in kPa. Can be converted from mmHg and mbar; see :func:`~pylinac.calibration.tg51.mmHg2kPa` and :func:`~pylinac.calibration.tg51.mbar2kPa`.
+    temp : float
+        The temperature in Celsius.
+    voltage_reference : int
+        The reference voltage; i.e. the voltage for the calibration reading (e.g. 300V).
+    voltage_reduced : int
+        The reduced voltage, usually a fraction of the reference voltage (e.g. 150V).
+    m_reference : array, float
+        The reading(s) of the chamber at reference voltage.
+    m_reduced : array, float
+        The reading(s) of the chamber at the reduced voltage.
+    m_opposite : array, float
+        The reading(s) of the chamber at the opposite voltage from reference. Sign of the reading does not matter.
+    k_elec : float
+        The electrometer correction value given by the calibration laboratory.
+    clinical_pdd_zref : optional, float
+        The PDD at the depth of calibration. Use the actual percentage (e.g. 66.7 not 0.667). If not supplied the clinical_tmr_zref value must be supplied.
+    clinical_tmr_zref : optional, float
+        The TMR at the depth of calibration. If not supplied the clinical_pdd_zref value must be supplied.
+    tissue_correction : float
+        The correction of calibration to a medium other than water. Default value is 1 which is water. E.g. use 0.99 if calibrating to muscle.
+    """
+
+    @argue.options(setup=("SSD", "SAD"))
+    @argue.options(chamber=KQ_PHOTON_CHAMBERS.keys())
+    @argue.bounds(tpr2010=(KQ_PHOTON_TPRS[0], KQ_PHOTON_TPRS[-1]))
+    def __init__(
+        self,
+        *,
+        institution: str = "",
+        physicist: str = "",
+        unit: str = "",
+        measurement_date: str = "",
+        electrometer: str = "",
+        setup: str,
+        chamber: str,
+        n_dw: float,
+        mu: int,
+        tpr2010: float,
+        energy: int,
+        fff: bool,
+        press: float,
+        temp: float,
+        voltage_reference: int,
+        voltage_reduced: int,
+        m_reference: Union[tuple, float],
+        m_reduced: Union[tuple, float],
+        m_opposite: Union[tuple, float],
+        k_elec: float,
+        clinical_pdd_zref: Optional[float] = None,
+        clinical_tmr_zref: Optional[float] = None,
+        tissue_correction: float = 1.0,
+    ):
+        super().__init__(
+            chamber=chamber,
+            tpr2010=tpr2010,
+            press=press,
+            temp=temp,
+            voltage_reference=voltage_reference,
+            voltage_reduced=voltage_reduced,
+            m_reference=m_reference,
+            m_reduced=m_reduced,
+            m_opposite=m_opposite,
+            k_elec=k_elec,
+            clinical_pdd_zref=clinical_pdd_zref,
+            clinical_tmr_zref=clinical_tmr_zref,
+            n_dw=n_dw,
+            setup=setup,
+            mu=mu,
+            tissue_correction=tissue_correction,
+            fff=fff,
+            energy=energy,
+            institution=institution,
+            physicist=physicist,
+            unit=unit,
+            measurement_date=measurement_date,
+            electrometer=electrometer,
+        )
+        self.m_reference_adjusted = None
+
+    @property
+    def kq(self):
+        """kQ of the chamber and TPR."""
+        return kq_photon(chamber=self.chamber, tpr=self.tpr2010)
+
+    @property
+    def dose_mu_zmax(self):
+        """cGy/MU at a depth of zmax."""
+        if self.setup == "SSD":
+            return (100 * self.dose_mu_zref) / self.clinical_pdd_zref
+        else:
+            return self.dose_mu_zref / self.clinical_tmr_zref
+
+    @property
+    def dose_mu_zmax_adjusted(self):
+        """The dose/mu at dmax depth after adjustment."""
+        if self.setup == "SSD":
+            return (100 * self.dose_mu_zref_adjusted) / self.clinical_pdd_zref
+        else:
+            return self.dose_mu_zref_adjusted / self.clinical_tmr_zref
+
+    def publish_pdf(
+        self,
+        filename: str,
+        notes: Optional[list] = None,
+        open_file: bool = False,
+        metadata: Optional[dict] = None,
+    ):
+        """Publish (print) a PDF containing the analysis and quantitative results.
+
+        Parameters
+        ----------
+        filename : str, file-like object
+            The file to write the results to.
+        notes : str, list
+            Any notes to be added to the report. If a string, adds everything as one line.
+            If a list, must be a list of strings; each string item will be a new line.
+        open_file : bool
+            Whether to open the file after creation. Will use the default PDF program.
+        metadata : dict
+            Any data that should be appended to every page of the report. This differs from notes in that
+            metadata is at the top of every page while notes is at the bottom of the report.
+        """
+        was_adjusted = "Yes" if self.output_was_adjusted else "No"
+        title = f"TRS-398 Photon Report - {self.energy} MV"
+        if self.fff:
+            title += " FFF"
+
+        canvas = PylinacCanvas(filename, page_title=title, metadata=metadata)
+        text = [
+            "Site Data:",
+            f"Institution: {self.institution}",
+            f"Performed by: {self.physicist}",
+            f"Measurement Date: {self.measurement_date}",
+            f'Date of Report: {datetime.now().strftime("%A, %B %d, %Y")}',
+            f"Unit: {self.unit}",
+            f"Energy: {self.energy} MV {'FFF' if self.fff else ''}",
+            "",
+            "Instrumentation:",
+            f"Chamber: {self.chamber}",
+            f"Chamber Calibration Factor Ndw (cGy/nC): {self.n_dw:2.3f}",
+            f"Electrometer: {self.electrometer}",
+            f"Kelec: {self.k_elec:2.3f}",
+            f"MU: {self.mu}",
+            "",
+            "Beam Quality:",
+            f"TPR(20)/TPR(10): {self.tpr2010:2.3f}",
+            f"Determined kQ: {self.kq:2.3f}",
+            "",
+            "Chamber Corrections/Measurements:",
+            f"Temperature (\N{DEGREE SIGN}C): {self.temp:2.1f}",
+            f"Pressure (kPa): {self.press:2.1f}",
+            f"Mraw @ ({self.voltage_reference}V, Reference) (nC): {self.m_reference}",
+            f"Mraw @ ({self.voltage_reduced}V, Reduced) (nC): {self.m_reduced}",
+            f"Mraw @ ({-self.voltage_reference}V, Opposite) (nC): {self.m_opposite}",
+            f"Ktp: {self.k_tp:2.3f}",
+            f"Ks: {self.k_s:2.3f}",
+            f"Kpol: {self.k_pol:2.3f}",
+            "",
+            "Dose Determination:",
+            f"Fully corrected M (nC): {self.m_corrected:2.3f}",
+            f"Tissue correction (e.g. muscle): {self.tissue_correction:2.3f}",
+            f"Dose/MU @ zref depth (cGy): {self.dose_mu_zref:2.3f}",
+        ]
+        if self.setup == "SSD":
+            text.append(
+                f"Clinical PDD (%): {self.clinical_pdd_zref:2.2f}",
+            )
+        else:
+            text.append(
+                f"Clinical TMR (%): {self.clinical_tmr_zref:2.2f}",
+            )
+        text.append(f"Dose/MU @ zmax (cGy): {self.dose_mu_zmax:2.3f}")
+        text.append("")
+        text.append(f"Output Adjustment?: {was_adjusted}")
+        if was_adjusted == "Yes":
+            text.append(
+                f"Adjusted Mraw @ reference voltage (nC): {self.m_reference_adjusted}"
+            )
+            text.append(
+                f"Adjusted fully corrected M (nC): {self.m_corrected_adjusted:2.3f}"
+            )
+            text.append(
+                f"Adjusted Dose/MU @ zref depth (cGy): {self.dose_mu_zref_adjusted:2.3f}"
+            )
+            text.append(
+                f"Adjusted Dose/MU @ zmax (cGy): {self.dose_mu_zmax_adjusted:2.3f}"
+            )
+        canvas.add_text(text=text, location=(2, 25.5), font_size=12)
+        if notes is not None:
+            canvas.add_text(text="Notes:", location=(12, 6.5), font_size=14)
+            canvas.add_text(text=notes, location=(12, 6))
+
+        canvas.finish()
+
+        if open_file:
+            webbrowser.open(filename)
+
+
+class TRS398Electron(TRS398Base):
+    """Calculation of dose to water at zmax and zref from a high energy electron beam.
+
+    Parameters
+    ----------
+    institution : str
+        Institution name.
+    physicist : str
+        Physicist performing calibration.
+    unit : str
+        Unit name; e.g. TrueBeam1.
+    measurement_date : str
+        Date of measurement. E.g. 10/22/2018.
+    chamber : str
+        Farmer-type chamber model from Table 6.III.
+    n_dw : float
+        NDw of the chamber given by the calibration laboratory.
+    mu : float, int
+        The number of MU given per reading.
+    i_50 : float
+        The depth of ionization 50% in cm.
+    press : float
+        The value of pressure in kPa. Can be converted from mmHg and mbar; see :func:`~pylinac.calibration.tg51.mmHg2kPa` and :func:`~pylinac.calibration.tg51.mbar2kPa`.
+    temp : float
+        The temperature in Celsius.
+    voltage_reference : int
+        The reference voltage; i.e. the voltage for the calibration reading (e.g. 300V).
+    voltage_reduced : int
+        The reduced voltage, usually a fraction of the reference voltage (e.g. 150V).
+    m_reference : array, float
+        The reading(s) of the chamber at reference voltage.
+    m_reduced : array, float
+        The reading(s) of the chamber at the reduced voltage.
+    m_opposite : array, float
+        The reading(s) of the chamber at the opposite voltage from reference. Sign of the reading does not matter.
+    k_elec : float
+        The electrometer correction value given by the calibration laboratory.
+    pdd_zref : optional, float
+        The PDD at the depth of calibration. Use the actual percentage (e.g. 66.7 not 0.667). If not supplied the tmr_zref value should be supplied.
+    tissue_correction : float
+        The correction of calibration to a medium other than water. Default value is 1 which is water. E.g. use 0.99 if calibrating to muscle.
+    """
+
+    def __init__(
+        self,
+        *,
+        institution: str = "",
+        physicist: str = "",
+        unit: str = "",
+        measurement_date: str = "",
+        electrometer: str = "",
+        energy: str,
+        cone: str,
+        chamber: str,
+        n_dw: float,
+        mu: int,
+        i_50: float,
+        press: float,
+        temp: float,
+        voltage_reference: int,
+        voltage_reduced: int,
+        m_reference: tuple,
+        m_reduced: tuple,
+        m_opposite: tuple,
+        k_elec: float,
+        clinical_pdd_zref: float,
+        tissue_correction: float = 1.0,
+    ):
+        super().__init__(
+            chamber=chamber,
+            i_50=i_50,
+            press=press,
+            temp=temp,
+            energy=energy,
+            institution=institution,
+            voltage_reference=voltage_reference,
+            voltage_reduced=voltage_reduced,
+            m_reference=m_reference,
+            m_reduced=m_reduced,
+            m_opposite=m_opposite,
+            k_elec=k_elec,
+            clinical_pdd_zref=clinical_pdd_zref,
+            n_dw=n_dw,
+            mu=mu,
+            tissue_correction=tissue_correction,
+            physicist=physicist,
+            unit=unit,
+            measurement_date=measurement_date,
+            electrometer=electrometer,
+            cone=cone,
+        )
+        self.m_reference_adjusted = None
+
+    @property
+    def r_50(self) -> float:
+        """The depth of R50 in cm, derived from I50."""
+        return r_50(i_50=self.i_50)
+
+    @property
+    def zref(self) -> float:
+        """Depth of the reference point."""
+        return z_ref(i_50=self.i_50)
+
+    @property
+    def kq(self):
+        """kQ given the chamber and R50."""
+        return kq_electron(chamber=self.chamber, r_50=self.r_50)
+
+    @property
+    def dose_mu_zmax(self):
+        """cGy/MU at a depth of zmax."""
+        return (100 * self.dose_mu_zref) / self.clinical_pdd_zref
+
+    @property
+    def dose_mu_zmax_adjusted(self):
+        """The dose/mu at dmax depth after adjustment."""
+        return (100 * self.dose_mu_zref_adjusted) / self.clinical_pdd_zref
+
+    def publish_pdf(
+        self,
+        filename: str,
+        notes: Optional[list] = None,
+        open_file: bool = False,
+        metadata: Optional[dict] = None,
+    ):
+        """Publish (print) a PDF containing the analysis and quantitative results.
+
+        Parameters
+        ----------
+        filename : str, file-like object
+            The file to write the results to.
+        notes : str, list
+            Any notes to be added to the report. If a string, adds everything as one line.
+            If a list, must be a list of strings; each string item will be a new line.
+        open_file : bool
+            Whether to open the file after creation. Will use the default PDF program.
+        metadata : dict
+            Any data that should be appended to every page of the report. This differs from notes in that
+            metadata is at the top of every page while notes is at the bottom of the report.
+        """
+        was_adjusted = "Yes" if self.output_was_adjusted else "No"
+        title = f"TRS-398 Electron Report - {self.energy} MV"
+
+        canvas = PylinacCanvas(filename, page_title=title, metadata=metadata)
+        text = [
+            "Site Data:",
+            f"Institution: {self.institution}",
+            f"Performed by: {self.physicist}",
+            f"Measurement Date: {self.measurement_date}",
+            f'Date of Report: {datetime.now().strftime("%A, %B %d, %Y")}',
+            f"Unit: {self.unit}",
+            f"Energy: {self.energy} MeV",
+            f"Cone: {self.cone}",
+            f"MU: {self.mu}",
+            "",
+            "Instrumentation:",
+            f"Chamber: {self.chamber}",
+            f"Chamber Calibration Factor Ndw (cGy/nC): {self.n_dw:2.3f}",
+            f"Electrometer: {self.electrometer}",
+            f"Kelec: {self.k_elec:2.3f}",
+            "",
+            "Beam Quality:",
+            f"I50 (cm): {self.i_50:2.2f}",
+            f"R50 (cm): {self.r_50:2.2f}",
+            f"Zref (cm): {self.zref:2.2f}",
+            f"Calculated kQ: {self.kq:2.3f}",
+            "",
+            "Chamber Corrections/Measurements:",
+            f"Temperature (\N{DEGREE SIGN}C): {self.temp:2.1f}",
+            f"Pressure (kPa): {self.press:2.1f}",
+            f"Mraw @ ({self.voltage_reference}V, Reference) (nC): {self.m_reference}",
+            f"Mraw @ ({self.voltage_reduced}V, Reduced) (nC): {self.m_reduced}",
+            f"Mraw @ ({-self.voltage_reference}V, Opposite) (nC): {self.m_opposite}",
+            f"Ktp: {self.k_tp:2.3f}",
+            f"Ks: {self.k_s:2.3f}",
+            f"Kpol: {self.k_pol:2.3f}",
+            "",
+            "Dose Determination:",
+            f"Fully corrected M (nC): {self.m_corrected:2.3f}",
+            f"Tissue correction (e.g. muscle): {self.tissue_correction:2.3f}",
+            f"Dose/MU @ zref (cGy): {self.dose_mu_zref:2.3f}",
+            f"Clinical PDD (%): {self.clinical_pdd_zref:2.2f}",
+            f"Dose/MU @ zmax (cGy): {self.dose_mu_zmax:2.3f}",
+            "",
+            f"Output Adjustment?: {was_adjusted}",
+        ]
+        if was_adjusted == "Yes":
+            text.append(
+                f"Adjusted Mraw @ reference voltage (nC): {self.m_reference_adjusted}"
+            )
+            text.append(
+                f"Adjusted fully corrected M (nC): {self.m_corrected_adjusted:2.3f}"
+            )
+            text.append(
+                f"Adjusted Dose/MU @ zref depth (cGy): {self.dose_mu_zref_adjusted:2.3f}"
+            )
+            text.append(
+                f"Adjusted Dose/MU @ zmax (cGy): {self.dose_mu_zmax_adjusted:2.3f}"
+            )
+        canvas.add_text(text=text, location=(2, 25.5), font_size=12)
+        if notes is not None:
+            canvas.add_text(text="Notes:", location=(12, 6.5), font_size=14)
+            canvas.add_text(text=notes, location=(12, 6))
+
+        canvas.finish()
+
+        if open_file:
+            webbrowser.open(filename)
```

### Comparing `manteia_qa_pylinac-1.0.0/pylinac/core/array_utils.py` & `manteia_qa_pylinac-1.1.0/pylinac/core/array_utils.py`

 * *Ordering differences only*

 * *Files 12% similar despite different names*

```diff
@@ -1,330 +1,330 @@
-from __future__ import annotations
-
-import tempfile
-from pathlib import Path
-
-import numpy as np
-from pydicom import Dataset
-from pydicom.dataset import FileMetaDataset
-from pydicom.multival import MultiValue
-from pydicom.uid import UID, generate_uid
-from scipy import ndimage
-
-from .decorators import validate
-
-
-def array_not_empty(array: np.ndarray) -> None:
-    """Check an array isn't empty"""
-    if not array.size:
-        raise ValueError("Array must not be empty")
-
-
-def single_dimension(array: np.ndarray) -> None:
-    """Check an array is a single dimension"""
-    if array.ndim > 1:
-        raise ValueError(
-            f"Array was multidimensional. Must pass 1D array; found {array.ndim}"
-        )
-
-
-@validate(array=(array_not_empty, single_dimension))
-def geometric_center_idx(array: np.ndarray) -> float:
-    """Returns the center index and value of the profile.
-
-    If the profile has an even number of array the centre lies between the two centre indices and the centre
-    value is the average of the two centre array else the centre index and value are returned.
-    """
-    return (array.shape[0] - 1) / 2.0
-
-
-@validate(array=(array_not_empty, single_dimension))
-def geometric_center_value(array: np.ndarray) -> float:
-    """Returns the center value of the profile.
-
-    If the profile has an even number of elements the center lies between the two centre indices and the centre
-    value is the average of the two center elements else the center index and value are returned.
-    """
-    arr_len = array.shape[0]
-    # buffer overflow can cause the below addition to give strange results
-    if arr_len % 2 == 0:  # array is even and central detectors straddle CAX
-        cax = (array[int(arr_len / 2)] + array[int(arr_len / 2) - 1]) / 2.0
-    else:  # array is odd and we have a central detector
-        cax = array[int((arr_len - 1) / 2)]
-    return cax
-
-
-@validate(array=array_not_empty)
-def normalize(array: np.ndarray, value: float | None = None) -> np.ndarray:
-    """Normalize an array to the passed value. If not value is passed, normalize to the maximum value"""
-    if value is None:
-        val = array.max()
-    else:
-        val = value
-    array = array / val
-    return array
-
-
-@validate(array=array_not_empty)
-def invert(array: np.ndarray) -> np.ndarray:
-    """Invert the array. Makes the max the min and vice versa. Does NOT account for datatype"""
-    return -array + array.max() + array.min()
-
-
-@validate(array=array_not_empty)
-def bit_invert(array: np.ndarray) -> np.ndarray:
-    """Invert the array, ACCOUNTING for the datatype. I.e. 0 for an uint8 array goes to 255, whereas it goes to 65535 for unint16.
-    I.e. this is a datatype-specific inversion."""
-    try:
-        return np.invert(array)
-    except TypeError:
-        raise ValueError(
-            f"The datatype {array.dtype} could not be safely inverted. This usually means the array is a float-like datatype. Cast to an integer-like datatype first."
-        )
-
-
-@validate(array=array_not_empty)
-def ground(array: np.ndarray, value: float = 0) -> np.ndarray:
-    """Ground the profile. Note this will also work on profiles with negative values. I.e. this will always
-    move the minimum value to 'value', regardless of whether the profile minimum was positive or negative
-
-    Parameters
-    ----------
-    value
-        The value to set the minimum value as.
-    """
-    return array - array.min() + value
-
-
-@validate(array=array_not_empty)
-def filter(
-    array: np.ndarray, size: float | int = 0.05, kind: str = "median"
-) -> np.ndarray:
-    """Filter the profile.
-
-    Parameters
-    ----------
-    array: np.ndarray
-        The array to filter.
-    size : float, int
-        Size of the median filter to apply.
-        If a float, the size is the ratio of the length. Must be in the range 0-1.
-        E.g. if size=0.1 for a 1000-element array, the filter will be 100 elements.
-        If an int, the filter is the size passed.
-    kind : {'median', 'gaussian'}
-        The kind of filter to apply. If gaussian, `size` is the sigma value.
-    """
-    if isinstance(size, float):
-        if 0 < size < 1:
-            size = int(round(len(array) * size))
-            size = max(size, 1)
-        else:
-            raise ValueError("Float was passed but was not between 0 and 1")
-
-    if kind == "median":
-        filtered_array = ndimage.median_filter(array, size=size)
-    elif kind == "gaussian":
-        filtered_array = ndimage.gaussian_filter(array, sigma=size)
-    else:
-        raise ValueError(
-            f"Filter type {kind} unsupported. Use one of 'median', 'gaussian'"
-        )
-    return filtered_array
-
-
-@validate(array=array_not_empty)
-def stretch(array: np.ndarray, min: int = 0, max: int = 1) -> np.array:
-    """'Stretch' the profile to the fit a new min and max value. This is a utility for grounding + normalizing.
-
-    Parameters
-    ----------
-    array: numpy.ndarray
-        The numpy array to stretch.
-    min : number
-        The new minimum of the array.
-    max : number
-        The new maximum value of the array.
-    """
-    if max <= min:
-        raise ValueError(
-            f"Max must be larger than min. Passed max of {max} was <= {min}"
-        )
-    dtype_info = get_dtype_info(array.dtype)
-    if max > dtype_info.max:
-        raise ValueError(
-            f"Max of {max} was larger than the allowed datatype maximum of {dtype_info.max}"
-        )
-    if min < dtype_info.min:
-        raise ValueError(
-            f"Min of {min} was smaller than the allowed datatype minimum of {dtype_info.min}"
-        )
-
-    return ground(normalize(ground(array)) * (max - min), value=min)
-
-
-@validate(array=array_not_empty)
-def convert_to_dtype(array: np.array, dtype: type[np.dtype]) -> np.array:
-    """Convert an array to another datatype, accounting for the array values.
-    A normal numpy dtype conversion simply changes the datatype and leaves the values alone.
-    This will convert an array and also convert the values to the same relative value of the new datatype.
-    E.g. an element of value 100 on an uint8 array to be converted to an uint16 array will become ~25,690 (100/255 = 0.392 = x/65535, x = 25,690)
-
-    .. note::
-
-        Float-like input arrays will be normalized. This is because realistic float values are never near the datatype max.
-        This can cause casting to an int-like datatype being 0's for the array. Thus, all float-like
-        inputs will have outputs at the max value of the output datatype. Float-to-float conversion is discouraged.
-    """
-    # original array info
-    old_dtype_info = get_dtype_info(array.dtype)
-    # float range is so large that it's better to normalize
-    if isinstance(old_dtype_info, np.finfo):
-        relative_values = stretch(array, min=0, max=1)
-    else:
-        # we have an int-like array.
-        # the float conversion is to avoid integer division
-        # this can help when the values are very small
-        # we will cast back to int later
-        relative_values = array.astype(float) / old_dtype_info.max
-    # new array info
-    dtype_info = get_dtype_info(dtype)
-    dtype_range = dtype_info.max - dtype_info.min
-    return np.array(relative_values * dtype_range - dtype_info.max - 1, dtype=dtype)
-
-
-def get_dtype_info(dtype: type[np.dtype]) -> np.iinfo | np.finfo:
-    """Get the datatype of the array"""
-    try:
-        dtype_info = np.iinfo(dtype)
-    except ValueError:
-        dtype_info = np.finfo(dtype)
-    return dtype_info
-
-
-def find_nearest_idx(array: np.array, value: float) -> int:
-    """Find the nearest index to the target value"""
-    return (np.abs(array - value)).argmin()
-
-
-def array_to_dicom(
-    array: np.ndarray,
-    sid: float,
-    gantry: float,
-    coll: float,
-    couch: float,
-    dpi: float | None = None,
-    **kwargs,
-) -> Dataset:
-    """Converts a numpy array into a **simplistic** DICOM file. Not meant to be a full-featured converter. This
-    allows for the creation of DICOM files from numpy arrays usually for internal use or image analysis.
-
-    .. note::
-
-        This will convert the image into an uint16 datatype to match the native EPID datatype.
-
-    Parameters
-    ----------
-    array
-        The numpy array to be converted. Must be 2 dimensions.
-    sid
-        The Source-to-Image distance in mm.
-    dpi
-        The dots-per-inch value of the TIFF image.
-    gantry
-        The gantry value that the image was taken at.
-    coll
-        The collimator value that the image was taken at.
-    couch
-        The couch value that the image was taken at.
-    """
-    from pylinac.core.image import ArrayImage
-
-    arr_img = ArrayImage(array, dpi=dpi, sid=sid)
-    if not arr_img.dpmm:
-        raise ValueError(
-            "Automatic detection of `dpi` failed. A `dpi` value must be passed to the constructor."
-        )
-    uint_array = convert_to_dtype(arr_img.array, np.uint16)
-    mm_pixel = 25.4 / arr_img.dpi
-    file_meta = FileMetaDataset()
-    # Main data elements
-    ds = Dataset()
-    ds.SOPClassUID = UID("1.2.840.10008.5.1.4.1.1.481.1")
-    ds.SOPInstanceUID = generate_uid()
-    ds.SeriesInstanceUID = generate_uid()
-    ds.Modality = "RTIMAGE"
-    ds.ConversionType = "WSD"
-    ds.PatientName = "Pylinac numpy array"
-    ds.PatientID = "123456789"
-    ds.SamplesPerPixel = 1
-    ds.PhotometricInterpretation = "MONOCHROME2"
-    ds.Rows = arr_img.shape[0]
-    ds.Columns = arr_img.shape[1]
-    ds.BitsAllocated = 16
-    ds.BitsStored = 16
-    ds.HighBit = 15
-    ds.PixelRepresentation = 0
-    ds.ImagePlanePixelSpacing = [mm_pixel, mm_pixel]
-    ds.RadiationMachineSAD = "1000.0"
-    ds.RTImageSID = sid
-    ds.PrimaryDosimeterUnit = "MU"
-    ds.GantryAngle = str(gantry)
-    ds.BeamLimitingDeviceAngle = str(coll)
-    ds.PatientSupportAngle = str(couch)
-    ds.PixelData = uint_array
-
-    ds.file_meta = file_meta
-    ds.is_implicit_VR = True
-    ds.is_little_endian = True
-    for key, value in kwargs.items():
-        setattr(ds, key, value)
-    return ds
-
-
-def create_dicom_files_from_3d_array(
-    array: np.ndarray,
-    out_dir: Path | None = None,
-    slice_thickness: float = 1,
-    pixel_size: float = 1,
-) -> Path:
-    """Create a stack of DICOM files from a 3D numpy array. This creates a pseudo-CT scan.
-
-    Parameters
-    ----------
-
-    array : np.ndarray
-        The 3D array
-    out_dir : Path, optional
-        The directory to save the DICOM files to. If None, a temporary directory is created.
-    slice_thickness : float, optional
-        The slice thickness in mm. Default is 1.
-    pixel_size : float, optional
-        The pixel size in mm. Default is 1.
-    """
-    # we iterate over the array in the last dimension and
-    # create a dicom image from it.
-    series_uid = generate_uid()
-    pixel_spacing = MultiValue(
-        iterable=(pixel_size, pixel_size), type_constructor=float
-    )
-    out_dir = out_dir or Path(tempfile.mkdtemp())
-    out_dir.mkdir(exist_ok=True, parents=True)
-    for i in range(array.shape[-1]):
-        arr = array[..., i].astype(np.uint16)
-        image_patient_position = MultiValue(
-            iterable=(0, 0, i * slice_thickness), type_constructor=float
-        )
-        ds = array_to_dicom(
-            arr,
-            dicom_file=out_dir / f"{i}.dcm",
-            sid=1000,
-            gantry=0,
-            coll=0,
-            couch=0,
-            dpi=25.4,
-            SeriesInstanceUID=series_uid,
-            ImagePositionPatient=image_patient_position,
-            SliceThickness=slice_thickness,
-            PixelSpacing=pixel_spacing,
-        )
-        ds.save_as(out_dir / f"{i}.dcm", write_like_original=False)
-    return out_dir
+from __future__ import annotations
+
+import tempfile
+from pathlib import Path
+
+import numpy as np
+from pydicom import Dataset
+from pydicom.dataset import FileMetaDataset
+from pydicom.multival import MultiValue
+from pydicom.uid import UID, generate_uid
+from scipy import ndimage
+
+from .decorators import validate
+
+
+def array_not_empty(array: np.ndarray) -> None:
+    """Check an array isn't empty"""
+    if not array.size:
+        raise ValueError("Array must not be empty")
+
+
+def single_dimension(array: np.ndarray) -> None:
+    """Check an array is a single dimension"""
+    if array.ndim > 1:
+        raise ValueError(
+            f"Array was multidimensional. Must pass 1D array; found {array.ndim}"
+        )
+
+
+@validate(array=(array_not_empty, single_dimension))
+def geometric_center_idx(array: np.ndarray) -> float:
+    """Returns the center index and value of the profile.
+
+    If the profile has an even number of array the centre lies between the two centre indices and the centre
+    value is the average of the two centre array else the centre index and value are returned.
+    """
+    return (array.shape[0] - 1) / 2.0
+
+
+@validate(array=(array_not_empty, single_dimension))
+def geometric_center_value(array: np.ndarray) -> float:
+    """Returns the center value of the profile.
+
+    If the profile has an even number of elements the center lies between the two centre indices and the centre
+    value is the average of the two center elements else the center index and value are returned.
+    """
+    arr_len = array.shape[0]
+    # buffer overflow can cause the below addition to give strange results
+    if arr_len % 2 == 0:  # array is even and central detectors straddle CAX
+        cax = (array[int(arr_len / 2)] + array[int(arr_len / 2) - 1]) / 2.0
+    else:  # array is odd and we have a central detector
+        cax = array[int((arr_len - 1) / 2)]
+    return cax
+
+
+@validate(array=array_not_empty)
+def normalize(array: np.ndarray, value: float | None = None) -> np.ndarray:
+    """Normalize an array to the passed value. If not value is passed, normalize to the maximum value"""
+    if value is None:
+        val = array.max()
+    else:
+        val = value
+    array = array / val
+    return array
+
+
+@validate(array=array_not_empty)
+def invert(array: np.ndarray) -> np.ndarray:
+    """Invert the array. Makes the max the min and vice versa. Does NOT account for datatype"""
+    return -array + array.max() + array.min()
+
+
+@validate(array=array_not_empty)
+def bit_invert(array: np.ndarray) -> np.ndarray:
+    """Invert the array, ACCOUNTING for the datatype. I.e. 0 for an uint8 array goes to 255, whereas it goes to 65535 for unint16.
+    I.e. this is a datatype-specific inversion."""
+    try:
+        return np.invert(array)
+    except TypeError:
+        raise ValueError(
+            f"The datatype {array.dtype} could not be safely inverted. This usually means the array is a float-like datatype. Cast to an integer-like datatype first."
+        )
+
+
+@validate(array=array_not_empty)
+def ground(array: np.ndarray, value: float = 0) -> np.ndarray:
+    """Ground the profile. Note this will also work on profiles with negative values. I.e. this will always
+    move the minimum value to 'value', regardless of whether the profile minimum was positive or negative
+
+    Parameters
+    ----------
+    value
+        The value to set the minimum value as.
+    """
+    return array - array.min() + value
+
+
+@validate(array=array_not_empty)
+def filter(
+    array: np.ndarray, size: float | int = 0.05, kind: str = "median"
+) -> np.ndarray:
+    """Filter the profile.
+
+    Parameters
+    ----------
+    array: np.ndarray
+        The array to filter.
+    size : float, int
+        Size of the median filter to apply.
+        If a float, the size is the ratio of the length. Must be in the range 0-1.
+        E.g. if size=0.1 for a 1000-element array, the filter will be 100 elements.
+        If an int, the filter is the size passed.
+    kind : {'median', 'gaussian'}
+        The kind of filter to apply. If gaussian, `size` is the sigma value.
+    """
+    if isinstance(size, float):
+        if 0 < size < 1:
+            size = int(round(len(array) * size))
+            size = max(size, 1)
+        else:
+            raise ValueError("Float was passed but was not between 0 and 1")
+
+    if kind == "median":
+        filtered_array = ndimage.median_filter(array, size=size)
+    elif kind == "gaussian":
+        filtered_array = ndimage.gaussian_filter(array, sigma=size)
+    else:
+        raise ValueError(
+            f"Filter type {kind} unsupported. Use one of 'median', 'gaussian'"
+        )
+    return filtered_array
+
+
+@validate(array=array_not_empty)
+def stretch(array: np.ndarray, min: int = 0, max: int = 1) -> np.array:
+    """'Stretch' the profile to the fit a new min and max value. This is a utility for grounding + normalizing.
+
+    Parameters
+    ----------
+    array: numpy.ndarray
+        The numpy array to stretch.
+    min : number
+        The new minimum of the array.
+    max : number
+        The new maximum value of the array.
+    """
+    if max <= min:
+        raise ValueError(
+            f"Max must be larger than min. Passed max of {max} was <= {min}"
+        )
+    dtype_info = get_dtype_info(array.dtype)
+    if max > dtype_info.max:
+        raise ValueError(
+            f"Max of {max} was larger than the allowed datatype maximum of {dtype_info.max}"
+        )
+    if min < dtype_info.min:
+        raise ValueError(
+            f"Min of {min} was smaller than the allowed datatype minimum of {dtype_info.min}"
+        )
+
+    return ground(normalize(ground(array)) * (max - min), value=min)
+
+
+@validate(array=array_not_empty)
+def convert_to_dtype(array: np.array, dtype: type[np.dtype]) -> np.array:
+    """Convert an array to another datatype, accounting for the array values.
+    A normal numpy dtype conversion simply changes the datatype and leaves the values alone.
+    This will convert an array and also convert the values to the same relative value of the new datatype.
+    E.g. an element of value 100 on an uint8 array to be converted to an uint16 array will become ~25,690 (100/255 = 0.392 = x/65535, x = 25,690)
+
+    .. note::
+
+        Float-like input arrays will be normalized. This is because realistic float values are never near the datatype max.
+        This can cause casting to an int-like datatype being 0's for the array. Thus, all float-like
+        inputs will have outputs at the max value of the output datatype. Float-to-float conversion is discouraged.
+    """
+    # original array info
+    old_dtype_info = get_dtype_info(array.dtype)
+    # float range is so large that it's better to normalize
+    if isinstance(old_dtype_info, np.finfo):
+        relative_values = stretch(array, min=0, max=1)
+    else:
+        # we have an int-like array.
+        # the float conversion is to avoid integer division
+        # this can help when the values are very small
+        # we will cast back to int later
+        relative_values = array.astype(float) / old_dtype_info.max
+    # new array info
+    dtype_info = get_dtype_info(dtype)
+    dtype_range = dtype_info.max - dtype_info.min
+    return np.array(relative_values * dtype_range - dtype_info.max - 1, dtype=dtype)
+
+
+def get_dtype_info(dtype: type[np.dtype]) -> np.iinfo | np.finfo:
+    """Get the datatype of the array"""
+    try:
+        dtype_info = np.iinfo(dtype)
+    except ValueError:
+        dtype_info = np.finfo(dtype)
+    return dtype_info
+
+
+def find_nearest_idx(array: np.array, value: float) -> int:
+    """Find the nearest index to the target value"""
+    return (np.abs(array - value)).argmin()
+
+
+def array_to_dicom(
+    array: np.ndarray,
+    sid: float,
+    gantry: float,
+    coll: float,
+    couch: float,
+    dpi: float | None = None,
+    **kwargs,
+) -> Dataset:
+    """Converts a numpy array into a **simplistic** DICOM file. Not meant to be a full-featured converter. This
+    allows for the creation of DICOM files from numpy arrays usually for internal use or image analysis.
+
+    .. note::
+
+        This will convert the image into an uint16 datatype to match the native EPID datatype.
+
+    Parameters
+    ----------
+    array
+        The numpy array to be converted. Must be 2 dimensions.
+    sid
+        The Source-to-Image distance in mm.
+    dpi
+        The dots-per-inch value of the TIFF image.
+    gantry
+        The gantry value that the image was taken at.
+    coll
+        The collimator value that the image was taken at.
+    couch
+        The couch value that the image was taken at.
+    """
+    from pylinac.core.image import ArrayImage
+
+    arr_img = ArrayImage(array, dpi=dpi, sid=sid)
+    if not arr_img.dpmm:
+        raise ValueError(
+            "Automatic detection of `dpi` failed. A `dpi` value must be passed to the constructor."
+        )
+    uint_array = convert_to_dtype(arr_img.array, np.uint16)
+    mm_pixel = 25.4 / arr_img.dpi
+    file_meta = FileMetaDataset()
+    # Main data elements
+    ds = Dataset()
+    ds.SOPClassUID = UID("1.2.840.10008.5.1.4.1.1.481.1")
+    ds.SOPInstanceUID = generate_uid()
+    ds.SeriesInstanceUID = generate_uid()
+    ds.Modality = "RTIMAGE"
+    ds.ConversionType = "WSD"
+    ds.PatientName = "Pylinac numpy array"
+    ds.PatientID = "123456789"
+    ds.SamplesPerPixel = 1
+    ds.PhotometricInterpretation = "MONOCHROME2"
+    ds.Rows = arr_img.shape[0]
+    ds.Columns = arr_img.shape[1]
+    ds.BitsAllocated = 16
+    ds.BitsStored = 16
+    ds.HighBit = 15
+    ds.PixelRepresentation = 0
+    ds.ImagePlanePixelSpacing = [mm_pixel, mm_pixel]
+    ds.RadiationMachineSAD = "1000.0"
+    ds.RTImageSID = sid
+    ds.PrimaryDosimeterUnit = "MU"
+    ds.GantryAngle = str(gantry)
+    ds.BeamLimitingDeviceAngle = str(coll)
+    ds.PatientSupportAngle = str(couch)
+    ds.PixelData = uint_array
+
+    ds.file_meta = file_meta
+    ds.is_implicit_VR = True
+    ds.is_little_endian = True
+    for key, value in kwargs.items():
+        setattr(ds, key, value)
+    return ds
+
+
+def create_dicom_files_from_3d_array(
+    array: np.ndarray,
+    out_dir: Path | None = None,
+    slice_thickness: float = 1,
+    pixel_size: float = 1,
+) -> Path:
+    """Create a stack of DICOM files from a 3D numpy array. This creates a pseudo-CT scan.
+
+    Parameters
+    ----------
+
+    array : np.ndarray
+        The 3D array
+    out_dir : Path, optional
+        The directory to save the DICOM files to. If None, a temporary directory is created.
+    slice_thickness : float, optional
+        The slice thickness in mm. Default is 1.
+    pixel_size : float, optional
+        The pixel size in mm. Default is 1.
+    """
+    # we iterate over the array in the last dimension and
+    # create a dicom image from it.
+    series_uid = generate_uid()
+    pixel_spacing = MultiValue(
+        iterable=(pixel_size, pixel_size), type_constructor=float
+    )
+    out_dir = out_dir or Path(tempfile.mkdtemp())
+    out_dir.mkdir(exist_ok=True, parents=True)
+    for i in range(array.shape[-1]):
+        arr = array[..., i].astype(np.uint16)
+        image_patient_position = MultiValue(
+            iterable=(0, 0, i * slice_thickness), type_constructor=float
+        )
+        ds = array_to_dicom(
+            arr,
+            dicom_file=out_dir / f"{i}.dcm",
+            sid=1000,
+            gantry=0,
+            coll=0,
+            couch=0,
+            dpi=25.4,
+            SeriesInstanceUID=series_uid,
+            ImagePositionPatient=image_patient_position,
+            SliceThickness=slice_thickness,
+            PixelSpacing=pixel_spacing,
+        )
+        ds.save_as(out_dir / f"{i}.dcm", write_like_original=False)
+    return out_dir
```

### Comparing `manteia_qa_pylinac-1.0.0/pylinac/core/decorators.py` & `manteia_qa_pylinac-1.1.0/pylinac/core/decorators.py`

 * *Ordering differences only*

 * *Files 24% similar despite different names*

```diff
@@ -1,68 +1,68 @@
-from __future__ import annotations
-
-import functools
-import inspect
-import weakref
-from typing import Iterable
-
-
-def lru_cache(*lru_args, **lru_kwargs):
-    """Method-safe LRU cache; https://stackoverflow.com/a/33672499"""
-
-    def decorator(func):
-        @functools.wraps(func)
-        def wrapped_func(self, *args, **kwargs):
-            # We're storing the wrapped method inside the instance. If we had
-            # a strong reference to self the instance would never die.
-            self_weak = weakref.ref(self)
-
-            @functools.wraps(func)
-            @functools.lru_cache(*lru_args, **lru_kwargs)
-            def cached_method(*args, **kwargs):
-                return func(self_weak(), *args, **kwargs)
-
-            setattr(self, func.__name__, cached_method)
-            return cached_method(*args, **kwargs)
-
-        return wrapped_func
-
-    return decorator
-
-
-def validate(**validate_kwargs):
-    """Validate arguments to a function with validator-like functions.
-
-    def is_float(value):
-        if not isinstance(value, float):
-            raise ValueError
-
-    @validate(a=is_float)
-    def add(a, b):
-        return a + b
-
-    # this will fail
-    add(3, 4.4)
-
-    # this is fine
-    add(1.1, 2)  # b is not checked
-    """
-
-    def decorator(func):
-        sig = inspect.signature(func)
-
-        @functools.wraps(func)
-        def wrapper(*args, **kwargs):
-            passed_values = sig.bind(*args, **kwargs).arguments
-            for arg, value in passed_values.items():
-                if arg in validate_kwargs.keys():
-                    if isinstance(validate_kwargs[arg], Iterable):
-                        for validator in validate_kwargs[arg]:
-                            validator(value)
-                    else:
-                        validate_kwargs[arg](value)
-            res = func(*args, **kwargs)
-            return res
-
-        return wrapper
-
-    return decorator
+from __future__ import annotations
+
+import functools
+import inspect
+import weakref
+from typing import Iterable
+
+
+def lru_cache(*lru_args, **lru_kwargs):
+    """Method-safe LRU cache; https://stackoverflow.com/a/33672499"""
+
+    def decorator(func):
+        @functools.wraps(func)
+        def wrapped_func(self, *args, **kwargs):
+            # We're storing the wrapped method inside the instance. If we had
+            # a strong reference to self the instance would never die.
+            self_weak = weakref.ref(self)
+
+            @functools.wraps(func)
+            @functools.lru_cache(*lru_args, **lru_kwargs)
+            def cached_method(*args, **kwargs):
+                return func(self_weak(), *args, **kwargs)
+
+            setattr(self, func.__name__, cached_method)
+            return cached_method(*args, **kwargs)
+
+        return wrapped_func
+
+    return decorator
+
+
+def validate(**validate_kwargs):
+    """Validate arguments to a function with validator-like functions.
+
+    def is_float(value):
+        if not isinstance(value, float):
+            raise ValueError
+
+    @validate(a=is_float)
+    def add(a, b):
+        return a + b
+
+    # this will fail
+    add(3, 4.4)
+
+    # this is fine
+    add(1.1, 2)  # b is not checked
+    """
+
+    def decorator(func):
+        sig = inspect.signature(func)
+
+        @functools.wraps(func)
+        def wrapper(*args, **kwargs):
+            passed_values = sig.bind(*args, **kwargs).arguments
+            for arg, value in passed_values.items():
+                if arg in validate_kwargs.keys():
+                    if isinstance(validate_kwargs[arg], Iterable):
+                        for validator in validate_kwargs[arg]:
+                            validator(value)
+                    else:
+                        validate_kwargs[arg](value)
+            res = func(*args, **kwargs)
+            return res
+
+        return wrapper
+
+    return decorator
```

### Comparing `manteia_qa_pylinac-1.0.0/pylinac/core/geometry.py` & `manteia_qa_pylinac-1.1.0/pylinac/core/geometry.py`

 * *Files 23% similar despite different names*

```diff
@@ -1,554 +1,633 @@
-"""Module for classes that represent common geometric objects or patterns."""
-from __future__ import annotations
-
-import math
-from itertools import zip_longest
-from typing import Iterable
-
-import argue
-import matplotlib.pyplot as plt
-import numpy as np
-from matplotlib.patches import Circle as mpl_Circle
-from matplotlib.patches import Rectangle as mpl_Rectangle
-from mpl_toolkits.mplot3d.art3d import Line3D
-
-from .utilities import is_iterable
-
-
-def tan(degrees: float) -> float:
-    """Calculate the tangent of the given degrees."""
-    return math.tan(math.radians(degrees))
-
-
-def atan(x: float, y: float) -> float:
-    """Calculate the degrees of a given x/y from the origin"""
-    return math.degrees(math.atan2(x, y))
-
-
-def cos(degrees: float) -> float:
-    """Calculate the cosine of the given degrees."""
-    return math.cos(math.radians(degrees))
-
-
-def sin(degrees: float) -> float:
-    """Calculate the sine of the given degrees."""
-    return math.sin(math.radians(degrees))
-
-
-class Point:
-    """A geometric point with x, y, and z coordinates/attributes."""
-
-    z: float
-    y: float
-    x: float
-    _attr_list: list[str] = ["x", "y", "z", "idx", "value"]
-    _coord_list: list[str] = ["x", "y", "z"]
-
-    def __init__(
-        self,
-        x: float | tuple | Point = 0,
-        y: float = 0,
-        z: float = 0,
-        idx: int | None = None,
-        value: float | None = None,
-        as_int: bool = False,
-    ):
-        """
-        Parameters
-        ----------
-        x : number-like, Point, iterable
-            x-coordinate or iterable type containing all coordinates. If iterable, values are assumed to be in order: (x,y,z).
-        y : number-like, optional
-            y-coordinate
-        idx : int, optional
-            Index of point. Useful for sequential coordinates; e.g. a point on a circle profile is sometimes easier to describe
-            in terms of its index rather than x,y coords.
-        value : number-like, optional
-            value at point location (e.g. pixel value of an image)
-        as_int : boolean
-            If True, coordinates are converted to integers.
-        """
-        if isinstance(x, Point):
-            for attr in self._attr_list:
-                item = getattr(x, attr, None)
-                setattr(self, attr, item)
-        elif is_iterable(x):
-            for attr, item in zip_longest(self._attr_list, x, fillvalue=0):
-                setattr(self, attr, item)
-        else:
-            self.x = x
-            self.y = y
-            self.z = z
-            self.idx = idx
-            self.value = value
-
-        if as_int:
-            self.x = int(round(self.x))
-            self.y = int(round(self.y))
-            self.z = int(round(self.z))
-
-    def distance_to(self, thing: Point | Circle) -> float:
-        """Calculate the distance to the given point.
-
-        Parameters
-        ----------
-        thing : Circle, Point, 2 element iterable
-            The other thing to calculate distance to.
-        """
-        if isinstance(thing, Circle):
-            return abs(
-                np.sqrt((self.x - thing.center.x) ** 2 + (self.y - thing.center.y) ** 2)
-                - thing.radius
-            )
-        p = Point(thing)
-        return math.sqrt(
-            (self.x - p.x) ** 2 + (self.y - p.y) ** 2 + (self.z - p.z) ** 2
-        )
-
-    def as_array(self, only_coords: bool = True) -> np.ndarray:
-        """Return the point as a numpy array."""
-        if only_coords:
-            return np.array([getattr(self, item) for item in self._coord_list])
-        else:
-            return np.array(
-                [
-                    getattr(self, item)
-                    for item in self._attr_list
-                    if (getattr(self, item) is not None)
-                ]
-            )
-
-    def as_vector(self) -> Vector:
-        return Vector(x=self.x, y=self.y, z=self.z)
-
-    def __repr__(self) -> str:
-        return f"Point(x={self.x:3.2f}, y={self.y:3.2f}, z={self.z:3.2f})"
-
-    def __eq__(self, other) -> bool:
-        # if all attrs equal, points considered equal
-        return all(
-            getattr(self, attr) == getattr(other, attr) for attr in self._attr_list
-        )
-
-    def __sub__(self, other) -> Vector:
-        p = Vector()
-        for attr in self._attr_list:
-            try:
-                diff = getattr(self, attr) - getattr(other, attr)
-            except TypeError:
-                diff = None
-            setattr(p, attr, diff)
-        return p
-
-    def __mul__(self, other: int | float) -> None:
-        for attr in self._attr_list:
-            try:
-                self.__dict__[attr] *= other
-            except TypeError:
-                pass
-
-    def __truediv__(self, other: int | float) -> Point:
-        for attr in self._attr_list:
-            val = getattr(self, attr)
-            # sometimes not all attrs are defined (like index or value and only x,y,z). Skip dividing those.
-            if val is not None:
-                setattr(self, attr, val / other)
-        return self
-
-
-class Circle:
-    """A geometric circle with center Point, radius, and diameter."""
-
-    center: Point
-    radius: float
-
-    def __init__(self, center_point: Point | Iterable = (0, 0), radius: float = 0):
-        """
-        Parameters
-        ----------
-        center_point : Point, optional
-            Center point of the wobble circle.
-        radius : float, optional
-            Radius of the wobble circle.
-        """
-        if center_point is None:
-            center_point = Point()
-        elif isinstance(center_point, Point) or is_iterable(center_point):
-            center_point = Point(center_point)
-        else:
-            raise TypeError("Circle center must be of type Point or iterable")
-
-        self.center = center_point
-        self.radius = radius
-
-    @property
-    def diameter(self) -> float:
-        """Get the diameter of the circle."""
-        return self.radius * 2
-
-    def plot2axes(
-        self,
-        axes: plt.Axes,
-        edgecolor: str = "black",
-        fill: bool = False,
-        text: str = "",
-        fontsize: str = "medium",
-    ) -> None:
-        """Plot the Circle on the axes.
-
-        Parameters
-        ----------
-        axes : matplotlib.axes.Axes
-            An MPL axes to plot to.
-        edgecolor : str
-            The color of the circle.
-        fill : bool
-            Whether to fill the circle with color or leave hollow.
-        text: str
-            If provided, plots the given text at the center. Useful for identifying ROIs on a plotted image apart.
-        fontsize: str
-            The size of the text, if provided. See https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.text.html
-            for options.
-        """
-        axes.add_patch(
-            mpl_Circle(
-                (self.center.x, self.center.y),
-                edgecolor=edgecolor,
-                radius=self.radius,
-                fill=fill,
-            )
-        )
-        if text:
-            axes.text(
-                x=self.center.x,
-                y=self.center.y,
-                s=text,
-                fontsize=fontsize,
-                color=edgecolor,
-            )
-
-    def as_dict(self) -> dict:
-        """Convert to dict. Useful for dataclasses/Result"""
-        return {
-            "center_x": self.center.x,
-            "center_y": self.center.y,
-            "diameter": self.diameter,
-        }
-
-
-class Vector:
-    """A vector with x, y, and z coordinates."""
-
-    x: float
-    y: float
-    z: float
-
-    def __init__(self, x: float = 0, y: float = 0, z: float = 0):
-        self.x = x
-        self.y = y
-        self.z = z
-
-    def __repr__(self):
-        return f"Vector(x={self.x:.2f}, y={self.y:.2f}, z={self.z:.2f})"
-
-    def as_scalar(self) -> float:
-        """Return the scalar equivalent of the vector."""
-        return math.sqrt(self.x**2 + self.y**2 + self.z**2)
-
-    def distance_to(self, thing: Circle | Point) -> float:
-        """Calculate the distance to the given point.
-
-        Parameters
-        ----------
-        thing : Circle, Point, 2 element iterable
-            The other point to calculate distance to.
-        """
-        if isinstance(thing, Circle):
-            return abs(
-                np.sqrt((self.x - thing.center.x) ** 2 + (self.y - thing.center.y) ** 2)
-                - thing.radius
-            )
-        else:
-            p = Point(thing)
-            return math.sqrt(
-                (self.x - p.x) ** 2 + (self.y - p.y) ** 2 + (self.z - p.z) ** 2
-            )
-
-    def __sub__(self, other: Vector) -> Vector:
-        new_x = self.x - other.x
-        new_y = self.y - other.y
-        new_z = self.z - other.z
-        return Vector(x=new_x, y=new_y, z=new_z)
-
-    def __add__(self, other: Vector) -> Vector:
-        new_x = self.x + other.x
-        new_y = self.y + other.y
-        new_z = self.z + other.z
-        return Vector(x=new_x, y=new_y, z=new_z)
-
-    def __truediv__(self, other: float) -> Vector:
-        for attr in ("x", "y", "z"):
-            val = getattr(self, attr)
-            setattr(self, attr, val / other)
-        return self
-
-
-def vector_is_close(vector1: Vector, vector2: Vector, delta: float = 0.1) -> bool:
-    """Determine if two vectors are with delta of each other; this is a simple coordinate comparison check."""
-    for attr in ("x", "y", "z"):
-        if np.isnan(getattr(vector1, attr)) and np.isnan(getattr(vector2, attr)):
-            continue
-        if (
-            not getattr(vector2, attr) + delta
-            >= getattr(vector1, attr)
-            >= getattr(vector2, attr) - delta
-        ):
-            return False
-    return True
-
-
-class Line:
-    """A line that is represented by two points or by m*x+b.
-
-    Notes
-    -----
-    Calculations of slope, etc are from here:
-    http://en.wikipedia.org/wiki/Linear_equation
-    and here:
-    http://www.mathsisfun.com/algebra/line-equation-2points.html
-    """
-
-    point1: Point
-    point2: Point
-
-    def __init__(
-        self,
-        point1: Point | tuple[float, float],
-        point2: Point | tuple[float, float],
-    ):
-        """
-        Parameters
-        ----------
-        point1 : Point
-            One point of the line
-        point2 : Point
-            Second point along the line.
-        """
-        self.point1 = Point(point1)
-        self.point2 = Point(point2)
-
-    def __repr__(self) -> str:
-        return (
-            f"Line: p1:(x={self.point1.x:.1f}, y={self.point1.y:.1f}, z={self.point1.z:.1f}), "
-            f"p2:(x={self.point2.x:.1f}, y={self.point2.y:.1f}, z={self.point2.z:.1f})"
-        )
-
-    @property
-    def m(self) -> float:
-        """Return the slope of the line.
-
-        m = (y1 - y2)/(x1 - x2)
-
-        From: http://www.purplemath.com/modules/slope.htm
-        """
-        return (self.point1.y - self.point2.y) / (self.point1.x - self.point2.x)
-
-    @property
-    def b(self) -> float:
-        """Return the y-intercept of the line.
-
-        b = y - m*x
-        """
-        return self.point1.y - (self.m * self.point1.x)
-
-    def y(self, x) -> float:
-        """Return y-value along line at position x."""
-        return self.m * x + self.b
-
-    def x(self, y) -> float:
-        """Return x-value along line at position y."""
-        return (y - self.b) / self.m
-
-    @property
-    def center(self) -> Point:
-        """Return the center of the line as a Point."""
-        mid_x = np.abs((self.point2.x - self.point1.x) / 2 + self.point1.x)
-        mid_y = (self.point2.y - self.point1.y) / 2 + self.point1.y
-        return Point(mid_x, mid_y)
-
-    @property
-    def length(self) -> float:
-        """Return length of the line, if finite."""
-        return self.point1.distance_to(self.point2)
-
-    def distance_to(self, point: Point) -> float:
-        """Calculate the minimum distance from the line to a point.
-
-        Equations are from here: http://mathworld.wolfram.com/Point-LineDistance2-Dimensional.html #14
-
-        Parameters
-        ----------
-        point : Point, iterable
-            The point to calculate distance to.
-        """
-        point = Point(point).as_array()
-        lp1 = self.point1.as_array()
-        lp2 = self.point2.as_array()
-        numerator = np.sqrt(np.sum(np.power(np.cross((lp2 - lp1), (lp1 - point)), 2)))
-        denominator = np.sqrt(np.sum(np.power(lp2 - lp1, 2)))
-        return numerator / denominator
-
-    def plot2axes(
-        self, axes: plt.Axes, width: float = 1, color: str = "w", **kwargs
-    ) -> Line3D:
-        """Plot the line to an axes.
-
-        Parameters
-        ----------
-        axes : matplotlib.axes.Axes
-            An MPL axes to plot to.
-        color : str
-            The color of the line.
-        """
-        lines = axes.plot(
-            (self.point1.x, self.point2.x),
-            (self.point1.y, self.point2.y),
-            (self.point1.z, self.point2.z),
-            linewidth=width,
-            color=color,
-            **kwargs,
-        )
-        return lines[0]
-
-
-class Rectangle:
-    """A rectangle with width, height, center Point, top-left corner Point, and bottom-left corner Point."""
-
-    width: int | float
-    height: int | float
-    _as_int: bool
-    center: Point
-
-    def __init__(
-        self,
-        width: float,
-        height: float,
-        center: Point | tuple,
-        as_int: bool = False,
-    ):
-        """
-        Parameters
-        ----------
-        width : number
-            Width of the rectangle. Must be positive
-        height : number
-            Height of the rectangle. Must be positive.
-        center : Point, iterable, optional
-            Center point of rectangle.
-        as_int : bool
-            If False (default), inputs are left as-is. If True, all inputs are converted to integers.
-        """
-        argue.verify_bounds(width, argue.POSITIVE)
-        argue.verify_bounds(height, argue.POSITIVE)
-        if as_int:
-            self.width = int(np.round(width))
-            self.height = int(np.round(height))
-        else:
-            self.width = width
-            self.height = height
-        self._as_int = as_int
-        self.center = Point(center, as_int=as_int)
-
-    @property
-    def br_corner(self) -> Point:
-        """The location of the bottom right corner."""
-        return Point(
-            self.center.x + self.width / 2,
-            self.center.y - self.height / 2,
-            as_int=self._as_int,
-        )
-
-    @property
-    def bl_corner(self) -> Point:
-        """The location of the bottom left corner."""
-        return Point(
-            self.center.x - self.width / 2,
-            self.center.y - self.height / 2,
-            as_int=self._as_int,
-        )
-
-    @property
-    def tl_corner(self) -> Point:
-        """The location of the top left corner."""
-        return Point(
-            self.center.x - self.width / 2,
-            self.center.y + self.height / 2,
-            as_int=self._as_int,
-        )
-
-    @property
-    def tr_corner(self) -> Point:
-        """The location of the top right corner."""
-        return Point(
-            self.center.x + self.width / 2,
-            self.center.y + self.height / 2,
-            as_int=self._as_int,
-        )
-
-    def plot2axes(
-        self,
-        axes: plt.Axes,
-        edgecolor: str = "black",
-        angle: float = 0.0,
-        fill: bool = False,
-        alpha: float = 1,
-        facecolor: str = "g",
-        label=None,
-        text: str = "",
-        fontsize: str = "medium",
-        text_rotation: float = 0,
-    ):
-        """Plot the Rectangle to the axes.
-
-        Parameters
-        ----------
-        axes : matplotlib.axes.Axes
-            An MPL axes to plot to.
-        edgecolor : str
-            The color of the circle.
-        angle : float
-            Angle of the rectangle.
-        fill : bool
-            Whether to fill the rectangle with color or leave hollow.
-        text: str
-            If provided, plots the given text at the center. Useful for identifying ROIs on a plotted image apart.
-        fontsize: str
-            The size of the text, if provided. See https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.text.html
-            for options.
-        text_rotation: float
-            The rotation of the text in degrees.
-        """
-        axes.add_patch(
-            mpl_Rectangle(
-                (self.bl_corner.x, self.bl_corner.y),
-                width=self.width,
-                height=self.height,
-                angle=angle,
-                edgecolor=edgecolor,
-                alpha=alpha,
-                facecolor=facecolor,
-                fill=fill,
-                label=label,
-            )
-        )
-        if text:
-            axes.text(
-                x=self.center.x,
-                y=self.center.y,
-                s=text,
-                fontsize=fontsize,
-                color=edgecolor,
-                rotation=text_rotation,
-                horizontalalignment="center",
-                verticalalignment="center",
-            )
+"""Module for classes that represent common geometric objects or patterns."""
+from __future__ import annotations
+
+import math
+from itertools import zip_longest
+from typing import Iterable
+
+import argue
+import matplotlib.pyplot as plt
+import numpy as np
+from matplotlib.patches import Circle as mpl_Circle
+from matplotlib.patches import Rectangle as mpl_Rectangle
+from mpl_toolkits.mplot3d.art3d import Line3D
+from pydantic import PlainSerializer
+from typing_extensions import Annotated
+
+from .utilities import is_iterable
+
+
+def tan(degrees: float) -> float:
+    """Calculate the tangent of the given degrees."""
+    return math.tan(math.radians(degrees))
+
+
+def atan(x: float, y: float) -> float:
+    """Calculate the degrees of a given x/y from the origin"""
+    return math.degrees(math.atan2(x, y))
+
+
+def cos(degrees: float) -> float:
+    """Calculate the cosine of the given degrees."""
+    return math.cos(math.radians(degrees))
+
+
+def sin(degrees: float) -> float:
+    """Calculate the sine of the given degrees."""
+    return math.sin(math.radians(degrees))
+
+
+def direction_to_coords(
+    start_x: float, start_y: float, distance: float, angle_degrees: float
+) -> (float, float):
+    """Calculate destination coordinates given a start position, distance, and angle.
+
+    The 0-angle position is pointing to the right (i.e. unit circle)
+
+    Parameters
+    ----------
+    start_x : float
+        Starting x position
+    start_y : float
+        Starting y position
+    distance : float
+        Distance to travel
+    angle_degrees : float
+        Angle to travel in degrees.
+    """
+    # Convert angle from degrees to radians
+    angle_radians = math.radians(angle_degrees)
+
+    # Calculate destination coordinates
+    end_x = start_x + distance * math.cos(angle_radians)
+    end_y = start_y + distance * math.sin(angle_radians)
+    return end_x, end_y
+
+
+class Point:
+    """A geometric point with x, y, and z coordinates/attributes."""
+
+    z: float
+    y: float
+    x: float
+    _attr_list: list[str] = ["x", "y", "z", "idx", "value"]
+    _coord_list: list[str] = ["x", "y", "z"]
+
+    def __init__(
+        self,
+        x: float | tuple | Point = 0,
+        y: float = 0,
+        z: float = 0,
+        idx: int | None = None,
+        value: float | None = None,
+        as_int: bool = False,
+    ):
+        """
+        Parameters
+        ----------
+        x : number-like, Point, iterable
+            x-coordinate or iterable type containing all coordinates. If iterable, values are assumed to be in order: (x,y,z).
+        y : number-like, optional
+            y-coordinate
+        idx : int, optional
+            Index of point. Useful for sequential coordinates; e.g. a point on a circle profile is sometimes easier to describe
+            in terms of its index rather than x,y coords.
+        value : number-like, optional
+            value at point location (e.g. pixel value of an image)
+        as_int : boolean
+            If True, coordinates are converted to integers.
+        """
+        if isinstance(x, Point):
+            for attr in self._attr_list:
+                item = getattr(x, attr, None)
+                setattr(self, attr, item)
+        elif is_iterable(x):
+            for attr, item in zip_longest(self._attr_list, x, fillvalue=0):
+                setattr(self, attr, item)
+        else:
+            self.x = x
+            self.y = y
+            self.z = z
+            self.idx = idx
+            self.value = value
+
+        if as_int:
+            self.x = int(round(self.x))
+            self.y = int(round(self.y))
+            self.z = int(round(self.z))
+
+    def distance_to(self, thing: Point | Circle) -> float:
+        """Calculate the distance to the given point.
+
+        Parameters
+        ----------
+        thing : Circle, Point, 2 element iterable
+            The other thing to calculate distance to.
+        """
+        if isinstance(thing, Circle):
+            return abs(
+                np.sqrt((self.x - thing.center.x) ** 2 + (self.y - thing.center.y) ** 2)
+                - thing.radius
+            )
+        p = Point(thing)
+        return math.sqrt(
+            (self.x - p.x) ** 2 + (self.y - p.y) ** 2 + (self.z - p.z) ** 2
+        )
+
+    def as_array(self, only_coords: bool = True) -> np.ndarray:
+        """Return the point as a numpy array."""
+        if only_coords:
+            return np.array([getattr(self, item) for item in self._coord_list])
+        else:
+            return np.array(
+                [
+                    getattr(self, item)
+                    for item in self._attr_list
+                    if (getattr(self, item) is not None)
+                ]
+            )
+
+    def as_vector(self) -> Vector:
+        return Vector(x=self.x, y=self.y, z=self.z)
+
+    def dict(self) -> dict:
+        """Convert to dict. Shim until convert to dataclass"""
+        return {
+            attr: getattr(self, attr)
+            for attr in self._attr_list
+            if getattr(self, attr) is not None
+        }
+
+    def __repr__(self) -> str:
+        return f"Point(x={self.x:3.2f}, y={self.y:3.2f}, z={self.z:3.2f})"
+
+    def __eq__(self, other) -> bool:
+        # if all attrs equal, points considered equal
+        return all(
+            getattr(self, attr) == getattr(other, attr) for attr in self._attr_list
+        )
+
+    def __add__(self, other) -> Vector:
+        p = Vector()
+        for attr in self._attr_list:
+            try:
+                sum = getattr(self, attr) + getattr(other, attr)
+            except TypeError:
+                sum = None
+            setattr(p, attr, sum)
+        return p
+
+    def __sub__(self, other) -> Vector:
+        p = Vector()
+        for attr in self._attr_list:
+            try:
+                diff = getattr(self, attr) - getattr(other, attr)
+            except TypeError:
+                diff = None
+            setattr(p, attr, diff)
+        return p
+
+    def __mul__(self, other: int | float) -> None:
+        for attr in self._attr_list:
+            try:
+                self.__dict__[attr] *= other
+            except TypeError:
+                pass
+
+    def __truediv__(self, other: int | float) -> Point:
+        for attr in self._attr_list:
+            val = getattr(self, attr)
+            # sometimes not all attrs are defined (like index or value and only x,y,z). Skip dividing those.
+            if val is not None:
+                setattr(self, attr, val / other)
+        return self
+
+
+def to_json(data: Point | Vector):
+    """Simple serialization call"""
+    return data.dict()
+
+
+PointSerialized = Annotated[Point, PlainSerializer(to_json)]
+
+
+class Circle:
+    """A geometric circle with center Point, radius, and diameter."""
+
+    center: Point
+    radius: float
+
+    def __init__(self, center_point: Point | Iterable = (0, 0), radius: float = 0):
+        """
+        Parameters
+        ----------
+        center_point : Point, optional
+            Center point of the wobble circle.
+        radius : float, optional
+            Radius of the wobble circle.
+        """
+        if center_point is None:
+            center_point = Point()
+        elif isinstance(center_point, Point) or is_iterable(center_point):
+            center_point = Point(center_point)
+        else:
+            raise TypeError("Circle center must be of type Point or iterable")
+
+        self.center = center_point
+        self.radius = radius
+
+    @property
+    def area(self) -> float:
+        """The area of the circle."""
+        return math.pi * self.radius**2
+
+    @property
+    def diameter(self) -> float:
+        """Get the diameter of the circle."""
+        return self.radius * 2
+
+    def plot2axes(
+        self,
+        axes: plt.Axes,
+        edgecolor: str = "black",
+        fill: bool = False,
+        text: str = "",
+        fontsize: str = "medium",
+        **kwargs,
+    ) -> None:
+        """Plot the Circle on the axes.
+
+        Parameters
+        ----------
+        axes : matplotlib.axes.Axes
+            An MPL axes to plot to.
+        edgecolor : str
+            The color of the circle.
+        fill : bool
+            Whether to fill the circle with color or leave hollow.
+        text: str
+            If provided, plots the given text at the center. Useful for identifying ROIs on a plotted image apart.
+        fontsize: str
+            The size of the text, if provided. See https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.text.html
+            for options.
+        """
+        axes.add_patch(
+            mpl_Circle(
+                (self.center.x, self.center.y),
+                edgecolor=edgecolor,
+                radius=self.radius,
+                fill=fill,
+                **kwargs,
+            )
+        )
+        if text:
+            axes.text(
+                x=self.center.x,
+                y=self.center.y,
+                s=text,
+                fontsize=fontsize,
+                color=edgecolor,
+            )
+
+    def as_dict(self) -> dict:
+        """Convert to dict. Useful for dataclasses/Result"""
+        return {
+            "center_x": self.center.x,
+            "center_y": self.center.y,
+            "diameter": self.diameter,
+        }
+
+
+class Vector:
+    """A vector with x, y, and z coordinates."""
+
+    x: float
+    y: float
+    z: float
+
+    def __init__(self, x: float = 0, y: float = 0, z: float = 0):
+        self.x = x
+        self.y = y
+        self.z = z
+
+    def __repr__(self):
+        return f"Vector(x={self.x:.2f}, y={self.y:.2f}, z={self.z:.2f})"
+
+    def as_scalar(self) -> float:
+        """Return the scalar equivalent of the vector."""
+        return math.sqrt(self.x**2 + self.y**2 + self.z**2)
+
+    def dict(self) -> dict:
+        """Convert to a dict. Shim until converting to dataclass"""
+        return {attr: getattr(self, attr) for attr in ("x", "y", "z")}
+
+    def distance_to(self, thing: Circle | Point) -> float:
+        """Calculate the distance to the given point.
+
+        Parameters
+        ----------
+        thing : Circle, Point, 2 element iterable
+            The other point to calculate distance to.
+        """
+        if isinstance(thing, Circle):
+            return abs(
+                np.sqrt((self.x - thing.center.x) ** 2 + (self.y - thing.center.y) ** 2)
+                - thing.radius
+            )
+        else:
+            p = Point(thing)
+            return math.sqrt(
+                (self.x - p.x) ** 2 + (self.y - p.y) ** 2 + (self.z - p.z) ** 2
+            )
+
+    def __sub__(self, other: Vector) -> Vector:
+        new_x = self.x - other.x
+        new_y = self.y - other.y
+        new_z = self.z - other.z
+        return Vector(x=new_x, y=new_y, z=new_z)
+
+    def __add__(self, other: Vector) -> Vector:
+        new_x = self.x + other.x
+        new_y = self.y + other.y
+        new_z = self.z + other.z
+        return Vector(x=new_x, y=new_y, z=new_z)
+
+    def __neg__(self) -> Vector:
+        return Vector(-self.x, -self.y, -self.z)
+
+    def __truediv__(self, other: float) -> Vector:
+        for attr in ("x", "y", "z"):
+            val = getattr(self, attr)
+            setattr(self, attr, val / other)
+        return self
+
+
+def vector_is_close(vector1: Vector, vector2: Vector, delta: float = 0.1) -> bool:
+    """Determine if two vectors are with delta of each other; this is a simple coordinate comparison check."""
+    for attr in ("x", "y", "z"):
+        if np.isnan(getattr(vector1, attr)) and np.isnan(getattr(vector2, attr)):
+            continue
+        if (
+            not getattr(vector2, attr) + delta
+            >= getattr(vector1, attr)
+            >= getattr(vector2, attr) - delta
+        ):
+            return False
+    return True
+
+
+VectorSerialized = Annotated[Vector, PlainSerializer(to_json)]
+
+
+class Line:
+    """A line that is represented by two points or by m*x+b.
+
+    Notes
+    -----
+    Calculations of slope, etc are from here:
+    http://en.wikipedia.org/wiki/Linear_equation
+    and here:
+    http://www.mathsisfun.com/algebra/line-equation-2points.html
+    """
+
+    point1: Point
+    point2: Point
+
+    def __init__(
+        self,
+        point1: Point | tuple[float, float],
+        point2: Point | tuple[float, float],
+    ):
+        """
+        Parameters
+        ----------
+        point1 : Point
+            One point of the line
+        point2 : Point
+            Second point along the line.
+        """
+        self.point1 = Point(point1)
+        self.point2 = Point(point2)
+
+    def __repr__(self) -> str:
+        return (
+            f"Line: p1:(x={self.point1.x:.1f}, y={self.point1.y:.1f}, z={self.point1.z:.1f}), "
+            f"p2:(x={self.point2.x:.1f}, y={self.point2.y:.1f}, z={self.point2.z:.1f})"
+        )
+
+    @property
+    def m(self) -> float:
+        """Return the slope of the line.
+
+        m = (y1 - y2)/(x1 - x2)
+
+        From: http://www.purplemath.com/modules/slope.htm
+        """
+        return (self.point1.y - self.point2.y) / (self.point1.x - self.point2.x)
+
+    @property
+    def b(self) -> float:
+        """Return the y-intercept of the line.
+
+        b = y - m*x
+        """
+        return self.point1.y - (self.m * self.point1.x)
+
+    def y(self, x) -> float:
+        """Return y-value along line at position x."""
+        return self.m * x + self.b
+
+    def x(self, y) -> float:
+        """Return x-value along line at position y."""
+        return (y - self.b) / self.m
+
+    @property
+    def center(self) -> Point:
+        """Return the center of the line as a Point."""
+        mid_x = np.abs((self.point2.x - self.point1.x) / 2 + self.point1.x)
+        mid_y = (self.point2.y - self.point1.y) / 2 + self.point1.y
+        return Point(mid_x, mid_y)
+
+    @property
+    def length(self) -> float:
+        """Return length of the line, if finite."""
+        return self.point1.distance_to(self.point2)
+
+    def distance_to(self, point: Point) -> float:
+        """Calculate the minimum distance from the line to a point.
+
+        Equations are from here: http://mathworld.wolfram.com/Point-LineDistance2-Dimensional.html #14
+
+        Parameters
+        ----------
+        point : Point, iterable
+            The point to calculate distance to.
+        """
+        point = Point(point).as_array()
+        lp1 = self.point1.as_array()
+        lp2 = self.point2.as_array()
+        numerator = np.sqrt(np.sum(np.power(np.cross((lp2 - lp1), (lp1 - point)), 2)))
+        denominator = np.sqrt(np.sum(np.power(lp2 - lp1, 2)))
+        return numerator / denominator
+
+    def plot2axes(
+        self, axes: plt.Axes, width: float = 1, color: str = "w", **kwargs
+    ) -> Line3D:
+        """Plot the line to an axes.
+
+        Parameters
+        ----------
+        axes : matplotlib.axes.Axes
+            An MPL axes to plot to.
+        color : str
+            The color of the line.
+        """
+        lines = axes.plot(
+            (self.point1.x, self.point2.x),
+            (self.point1.y, self.point2.y),
+            (self.point1.z, self.point2.z),
+            linewidth=width,
+            color=color,
+            **kwargs,
+        )
+        return lines[0]
+
+
+class Rectangle:
+    """A rectangle with width, height, center Point, top-left corner Point, and bottom-left corner Point."""
+
+    width: int | float
+    height: int | float
+    _as_int: bool
+    center: Point
+
+    def __init__(
+        self,
+        width: float,
+        height: float,
+        center: Point | tuple,
+        as_int: bool = False,
+    ):
+        """
+        Parameters
+        ----------
+        width : number
+            Width of the rectangle. Must be positive
+        height : number
+            Height of the rectangle. Must be positive.
+        center : Point, iterable, optional
+            Center point of rectangle.
+        as_int : bool
+            If False (default), inputs are left as-is. If True, all inputs are converted to integers.
+        """
+        argue.verify_bounds(width, argue.POSITIVE)
+        argue.verify_bounds(height, argue.POSITIVE)
+        if as_int:
+            self.width = int(np.round(width))
+            self.height = int(np.round(height))
+        else:
+            self.width = width
+            self.height = height
+        self._as_int = as_int
+        self.center = Point(center, as_int=as_int)
+
+    @property
+    def area(self) -> float:
+        """The area of the rectangle."""
+        return self.width * self.height
+
+    @property
+    def br_corner(self) -> Point:
+        """The location of the bottom right corner."""
+        return Point(
+            self.center.x + self.width / 2,
+            self.center.y - self.height / 2,
+            as_int=self._as_int,
+        )
+
+    @property
+    def bl_corner(self) -> Point:
+        """The location of the bottom left corner."""
+        return Point(
+            self.center.x - self.width / 2,
+            self.center.y - self.height / 2,
+            as_int=self._as_int,
+        )
+
+    @property
+    def tl_corner(self) -> Point:
+        """The location of the top left corner."""
+        return Point(
+            self.center.x - self.width / 2,
+            self.center.y + self.height / 2,
+            as_int=self._as_int,
+        )
+
+    @property
+    def tr_corner(self) -> Point:
+        """The location of the top right corner."""
+        return Point(
+            self.center.x + self.width / 2,
+            self.center.y + self.height / 2,
+            as_int=self._as_int,
+        )
+
+    def plot2axes(
+        self,
+        axes: plt.Axes,
+        edgecolor: str = "black",
+        angle: float = 0.0,
+        fill: bool = False,
+        alpha: float = 1,
+        facecolor: str = "g",
+        label=None,
+        text: str = "",
+        fontsize: str = "medium",
+        text_rotation: float = 0,
+        **kwargs,
+    ):
+        """Plot the Rectangle to the axes.
+
+        Parameters
+        ----------
+        axes : matplotlib.axes.Axes
+            An MPL axes to plot to.
+        edgecolor : str
+            The color of the circle.
+        angle : float
+            Angle of the rectangle.
+        fill : bool
+            Whether to fill the rectangle with color or leave hollow.
+        text: str
+            If provided, plots the given text at the center. Useful for identifying ROIs on a plotted image apart.
+        fontsize: str
+            The size of the text, if provided. See https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.text.html
+            for options.
+        text_rotation: float
+            The rotation of the text in degrees.
+        """
+        axes.add_patch(
+            mpl_Rectangle(
+                (self.bl_corner.x, self.bl_corner.y),
+                width=self.width,
+                height=self.height,
+                angle=angle,
+                edgecolor=edgecolor,
+                alpha=alpha,
+                facecolor=facecolor,
+                fill=fill,
+                label=label,
+                **kwargs,
+            )
+        )
+        if text:
+            axes.text(
+                x=self.center.x,
+                y=self.center.y,
+                s=text,
+                fontsize=fontsize,
+                color=edgecolor,
+                rotation=text_rotation,
+                horizontalalignment="center",
+                verticalalignment="center",
+            )
```

### Comparing `manteia_qa_pylinac-1.0.0/pylinac/core/hill.py` & `manteia_qa_pylinac-1.1.0/pylinac/core/hill.py`

 * *Ordering differences only*

 * *Files 19% similar despite different names*

```diff
@@ -1,77 +1,77 @@
-"""Perform non-linear regression using a Hill function."""
-from __future__ import annotations
-
-import math
-
-import numpy as np
-from scipy.optimize import curve_fit
-
-
-class Hill:
-    """A Hill function is for modeling a field falloff (i.e. penumbra). It's not a perfect model, but it fits to a
-    function, which is not limited by resolution issues as may be experienced on low-res devices like ion chamber arrays.
-    """
-
-    params: np.ndarray
-
-    @classmethod
-    def fit(cls, x_data: np.ndarray, y_data: np.ndarray) -> Hill:
-        """Fit x & y data to a Hill function."""
-        fitted_parameters, _ = curve_fit(
-            hill_func,
-            x_data,
-            y_data,
-            p0=(min(y_data), max(y_data), np.median(x_data), 0),
-        )
-        instance = cls()
-        instance.params = fitted_parameters
-        return instance
-
-    def inflection_idx(self) -> dict:
-        """Determine the x-value inflection point of the fitted Hill function."""
-        idx = self.params[2] * math.pow(
-            (self.params[3] - 1) / (self.params[3] + 1), 1 / self.params[3]
-        )
-        return {"index (exact)": idx, "index (rounded)": int(round(idx))}
-
-    @classmethod
-    def from_params(cls, params) -> Hill:
-        """Create a Hill function from pre-determined parameters. Useful to recreate a Hill function"""
-        instance = cls()
-        instance.params = params
-        return instance
-
-    def gradient_at(self, x: float) -> float:
-        """Return the gradient of the Hill function at a given x-value"""
-        cxd = math.pow(self.params[2] / x, self.params[3])
-        return (
-            (self.params[1] - self.params[0])
-            * self.params[3]
-            * cxd
-            / (math.pow(cxd + 1, 2) * x)
-        )
-
-    def x(self, y: float) -> float:
-        """Return the x-value given a y-value"""
-        return self.params[2] * math.pow(
-            (y - self.params[0]) / (self.params[1] - y), 1 / self.params[3]
-        )
-
-    def y(self, x: float) -> float:
-        """Return the y-value given an x-value."""
-        return self.params[0] + (self.params[1] - self.params[0]) / (
-            1 + (self.params[2] / x) ** self.params[3]
-        )
-
-
-def hill_func(
-    x: float, a: float, b: float, c: float, d: float
-) -> float:  # Hill function
-    """Calculates the Hill function at x.
-
-    a : sigmoid low level
-    b : sigmoid high level
-    c : approximate inflection point
-    d : slope of the sigmoid
-    """
-    return a + (b - a) / (1.0 + (c / x) ** d)
+"""Perform non-linear regression using a Hill function."""
+from __future__ import annotations
+
+import math
+
+import numpy as np
+from scipy.optimize import curve_fit
+
+
+class Hill:
+    """A Hill function is for modeling a field falloff (i.e. penumbra). It's not a perfect model, but it fits to a
+    function, which is not limited by resolution issues as may be experienced on low-res devices like ion chamber arrays.
+    """
+
+    params: np.ndarray
+
+    @classmethod
+    def fit(cls, x_data: np.ndarray, y_data: np.ndarray) -> Hill:
+        """Fit x & y data to a Hill function."""
+        fitted_parameters, _ = curve_fit(
+            hill_func,
+            x_data,
+            y_data,
+            p0=(min(y_data), max(y_data), np.median(x_data), 0),
+        )
+        instance = cls()
+        instance.params = fitted_parameters
+        return instance
+
+    def inflection_idx(self) -> dict:
+        """Determine the x-value inflection point of the fitted Hill function."""
+        idx = self.params[2] * math.pow(
+            (self.params[3] - 1) / (self.params[3] + 1), 1 / self.params[3]
+        )
+        return {"index (exact)": idx, "index (rounded)": int(round(idx))}
+
+    @classmethod
+    def from_params(cls, params) -> Hill:
+        """Create a Hill function from pre-determined parameters. Useful to recreate a Hill function"""
+        instance = cls()
+        instance.params = params
+        return instance
+
+    def gradient_at(self, x: float) -> float:
+        """Return the gradient of the Hill function at a given x-value"""
+        cxd = math.pow(self.params[2] / x, self.params[3])
+        return (
+            (self.params[1] - self.params[0])
+            * self.params[3]
+            * cxd
+            / (math.pow(cxd + 1, 2) * x)
+        )
+
+    def x(self, y: float) -> float:
+        """Return the x-value given a y-value"""
+        return self.params[2] * math.pow(
+            (y - self.params[0]) / (self.params[1] - y), 1 / self.params[3]
+        )
+
+    def y(self, x: float) -> float:
+        """Return the y-value given an x-value."""
+        return self.params[0] + (self.params[1] - self.params[0]) / (
+            1 + (self.params[2] / x) ** self.params[3]
+        )
+
+
+def hill_func(
+    x: float, a: float, b: float, c: float, d: float
+) -> float:  # Hill function
+    """Calculates the Hill function at x.
+
+    a : sigmoid low level
+    b : sigmoid high level
+    c : approximate inflection point
+    d : slope of the sigmoid
+    """
+    return a + (b - a) / (1.0 + (c / x) ** d)
```

### Comparing `manteia_qa_pylinac-1.0.0/pylinac/core/image.py` & `manteia_qa_pylinac-1.1.0/pylinac/core/image.py`

 * *Files 23% similar despite different names*

```diff
@@ -1,1920 +1,2045 @@
-"""This module holds classes for image loading and manipulation."""
-from __future__ import annotations
-
-import copy
-import io
-import json
-import math
-import os
-import os.path as osp
-import re
-import warnings
-from collections import Counter
-from datetime import datetime
-from functools import cached_property
-from io import BufferedReader, BytesIO
-from pathlib import Path
-from typing import Any, BinaryIO, Iterable, Sequence, Union
-
-import argue
-import matplotlib.pyplot as plt
-import numpy as np
-import pydicom
-import scipy.ndimage as spf
-from PIL import Image as pImage
-from PIL.PngImagePlugin import PngInfo
-from PIL.TiffTags import TAGS
-from pydicom.dataset import Dataset, FileMetaDataset
-from pydicom.errors import InvalidDicomError
-from pydicom.uid import UID, generate_uid
-from scipy import ndimage
-from skimage.draw import disk
-from skimage.transform import rotate
-
-from ..metrics.image import MetricBase
-from ..settings import PATH_TRUNCATION_LENGTH, get_dicom_cmap
-from .array_utils import (
-    bit_invert,
-    convert_to_dtype,
-    filter,
-    get_dtype_info,
-    ground,
-    invert,
-    normalize,
-)
-from .geometry import Point
-from .io import (
-    TemporaryZipDirectory,
-    get_url,
-    is_dicom_image,
-    retrieve_dicom_file,
-    retrieve_filenames,
-)
-from .profile import stretch as stretcharray
-from .scale import wrap360
-from .utilities import decode_binary, is_close, simple_round
-
-ARRAY = "Array"
-DICOM = "DICOM"
-IMAGE = "Image"
-
-FILE_TYPE = "file"
-STREAM_TYPE = "stream"
-
-XIM_PROP_INT = 0
-XIM_PROP_DOUBLE = 1
-XIM_PROP_STRING = 2
-XIM_PROP_DOUBLE_ARRAY = 4
-XIM_PROP_INT_ARRAY = 5
-
-MM_PER_INCH = 25.4
-
-ImageLike = Union["DicomImage", "ArrayImage", "FileImage", "LinacDicomImage"]
-
-
-def equate_images(image1: ImageLike, image2: ImageLike) -> tuple[ImageLike, ImageLike]:
-    """Crop and resize two images to make them:
-      * The same pixel dimensions
-      * The same DPI
-
-    The usefulness of the function comes when trying to compare images from different sources.
-    The best example is calculating gamma on a machine log fluence and EPID image. The physical
-    and pixel dimensions must be normalized, the SID normalized
-
-    Parameters
-    ----------
-    image1 : {:class:`~pylinac.core.image.ArrayImage`, :class:`~pylinac.core.image.DicomImage`, :class:`~pylinac.core.image.FileImage`}
-        Must have DPI and SID.
-    image2 : {:class:`~pylinac.core.image.ArrayImage`, :class:`~pylinac.core.image.DicomImage`, :class:`~pylinac.core.image.FileImage`}
-        Must have DPI and SID.
-
-    Returns
-    -------
-    image1 : :class:`~pylinac.core.image.ArrayImage`
-        The first image equated.
-    image2 : :class:`~pylinac.core.image.ArrayImage`
-        The second image equated.
-    """
-    image1 = copy.deepcopy(image1)
-    image2 = copy.deepcopy(image2)
-    # crop images to be the same physical size
-    # ...crop height
-    physical_height_diff = image1.physical_shape[0] - image2.physical_shape[0]
-    if physical_height_diff < 0:  # image2 is bigger
-        img = image2
-    else:
-        img = image1
-    pixel_height_diff = abs(int(round(-physical_height_diff * img.dpmm / 2)))
-    if pixel_height_diff > 0:
-        img.crop(pixel_height_diff, edges=("top", "bottom"))
-
-    # ...crop width
-    physical_width_diff = image1.physical_shape[1] - image2.physical_shape[1]
-    if physical_width_diff > 0:
-        img = image1
-    else:
-        img = image2
-    pixel_width_diff = abs(int(round(physical_width_diff * img.dpmm / 2)))
-    if pixel_width_diff > 0:
-        img.crop(pixel_width_diff, edges=("left", "right"))
-
-    # resize images to be of the same shape
-    zoom_factor = image1.shape[1] / image2.shape[1]
-    image2_array = ndimage.interpolation.zoom(image2.as_type(float), zoom_factor)
-    image2 = load(image2_array, dpi=image2.dpi * zoom_factor)
-
-    return image1, image2
-
-
-def is_image(path: str | io.BytesIO | ImageLike | np.ndarray) -> bool:
-    """Determine whether the path is a valid image file.
-
-    Returns
-    -------
-    bool
-    """
-    return any((_is_array(path), _is_dicom(path), _is_image_file(path)))
-
-
-def retrieve_image_files(path: str) -> list[str]:
-    """Retrieve the file names of all the valid image files in the path.
-
-    Returns
-    -------
-    list
-        Contains strings pointing to valid image paths.
-    """
-    return retrieve_filenames(directory=path, func=is_image)
-
-
-def load(path: str | Path | ImageLike | np.ndarray | BinaryIO, **kwargs) -> ImageLike:
-    r"""Load a DICOM image, JPG/TIF/BMP image, or numpy 2D array.
-
-    Parameters
-    ----------
-    path : str, file-object
-        The path to the image file or data stream or array.
-    kwargs
-        See :class:`~pylinac.core.image.FileImage`, :class:`~pylinac.core.image.DicomImage`,
-        or :class:`~pylinac.core.image.ArrayImage` for keyword arguments.
-
-    Returns
-    -------
-    ::class:`~pylinac.core.image.FileImage`, :class:`~pylinac.core.image.ArrayImage`, or :class:`~pylinac.core.image.DicomImage`
-        Return type depends on input image.
-
-    Examples
-    --------
-    Load an image from a file and then apply a filter::
-
-        >>> from pylinac.core.image import load
-        >>> my_image = r"C:\QA\image.tif"
-        >>> img = load(my_image)  # returns a FileImage
-        >>> img.filter(5)
-
-    Loading from an array is just like loading from a file::
-
-        >>> arr = np.arange(36).reshape(6, 6)
-        >>> img = load(arr)  # returns an ArrayImage
-    """
-    if isinstance(path, BaseImage):
-        return path
-
-    if _is_array(path):
-        return ArrayImage(path, **kwargs)
-    elif _is_dicom(path):
-        return DicomImage(path, **kwargs)
-    elif _is_image_file(path):
-        return FileImage(path, **kwargs)
-    else:
-        raise TypeError(
-            f"The argument `{path}` was not found to be a valid DICOM file, Image file, or array"
-        )
-
-
-def load_url(url: str, progress_bar: bool = True, **kwargs) -> ImageLike:
-    """Load an image from a URL.
-
-    Parameters
-    ----------
-    url : str
-        A string pointing to a valid URL that points to a file.
-
-        .. note:: For some images (e.g. Github), the raw binary URL must be used, not simply the basic link.
-
-    progress_bar: bool
-        Whether to display a progress bar of download status.
-    """
-    filename = get_url(url, progress_bar=progress_bar)
-    return load(filename, **kwargs)
-
-
-def load_multiples(
-    image_file_list: Sequence,
-    method: str = "mean",
-    stretch_each: bool = True,
-    **kwargs,
-) -> ImageLike:
-    """Combine multiple image files into one superimposed image.
-
-    Parameters
-    ----------
-    image_file_list : list
-        A list of the files to be superimposed.
-    method : {'mean', 'max', 'sum'}
-        A string specifying how the image values should be combined.
-    stretch_each : bool
-        Whether to normalize the images being combined by stretching their high/low values to the same values across images.
-    kwargs :
-        Further keyword arguments are passed to the load function and stretch function.
-
-    Examples
-    --------
-    Load multiple images::
-
-        >>> from pylinac.core.image import load_multiples
-        >>> paths = ['starshot1.tif', 'starshot2.tif']
-        >>> superimposed_img = load_multiples(paths)
-    """
-    # load images
-    img_list = [load(path, **kwargs) for path in image_file_list]
-    first_img = img_list[0]
-
-    # check that all images are the same size and stretch if need be
-    for img in img_list:
-        if img.shape != first_img.shape:
-            raise ValueError("Images were not the same shape")
-        if stretch_each:
-            img.array = stretcharray(img.array, fill_dtype=kwargs.get("dtype"))
-
-    # stack and combine arrays
-    new_array = np.dstack(tuple(img.array for img in img_list))
-    if method == "mean":
-        combined_arr = np.mean(new_array, axis=2)
-    elif method == "max":
-        combined_arr = np.max(new_array, axis=2)
-    elif method == "sum":
-        combined_arr = np.sum(new_array, axis=2)
-
-    # replace array of first object and return
-    first_img.array = combined_arr
-    # set the raw pixels flag; this will mark the image to be converted if we save out
-    first_img._raw_pixels = True
-    return first_img
-
-
-def _rescale_dicom_values(
-    unscaled_array: np.ndarray, metadata: Dataset, raw_pixels: bool
-) -> np.ndarray:
-    """Rescale the DICOM pixel values depending on the tags available.
-
-    See Also
-    --------
-    https://pylinac.readthedocs.io/en/latest/topics/images.html#pixel-data-inversion
-    """
-    has_all_rescale_tags = (
-        hasattr(metadata, "RescaleSlope")
-        and hasattr(metadata, "RescaleIntercept")
-        and hasattr(metadata, "PixelIntensityRelationshipSign")
-    )
-    has_some_rescale_tags = hasattr(metadata, "RescaleSlope") and hasattr(
-        metadata, "RescaleIntercept"
-    )
-    is_ct_storage = metadata.SOPClassUID.name == "CT Image Storage"
-    is_mr_storage = metadata.SOPClassUID.name == "MR Image Storage"
-    if raw_pixels:
-        return unscaled_array
-    elif has_all_rescale_tags:
-        scaled_array = (
-            (metadata.RescaleSlope * unscaled_array) + metadata.RescaleIntercept
-        ) * metadata.PixelIntensityRelationshipSign
-    elif is_ct_storage or has_some_rescale_tags:
-        scaled_array = (
-            metadata.RescaleSlope * unscaled_array
-        ) + metadata.RescaleIntercept
-    elif is_mr_storage:
-        # signal is usually correct as-is, no inversion needed
-        scaled_array = unscaled_array
-    else:
-        # invert it
-        orig_array = unscaled_array
-        scaled_array = -orig_array + orig_array.max() + orig_array.min()
-    return scaled_array
-
-
-def _unscale_dicom_values(
-    scaled_array: np.ndarray, metadata: Dataset, raw_pixels: bool
-) -> np.ndarray:
-    """Unscale the DICOM pixel values depending on the tags available.
-
-    This is the inverse of _rescale_dicom_values; specifically, when we
-    want to save the DICOM image we want to save the raw values
-    back to such that when re-importing and rescaling we will get the same array.
-    """
-    has_all_rescale_tags = (
-        hasattr(metadata, "RescaleSlope")
-        and hasattr(metadata, "RescaleIntercept")
-        and hasattr(metadata, "PixelIntensityRelationshipSign")
-    )
-    has_some_rescale_tags = hasattr(metadata, "RescaleSlope") and hasattr(
-        metadata, "RescaleIntercept"
-    )
-    is_ct_storage = metadata.SOPClassUID.name == "CT Image Storage"
-    is_mr_storage = metadata.SOPClassUID.name == "MR Image Storage"
-    if raw_pixels:
-        return scaled_array
-    elif has_all_rescale_tags:
-        unscaled_array = scaled_array * metadata.PixelIntensityRelationshipSign
-        unscaled_array = (
-            unscaled_array - metadata.RescaleIntercept
-        ) / metadata.RescaleSlope
-    elif is_ct_storage or has_some_rescale_tags:
-        unscaled_array = (
-            scaled_array - metadata.RescaleIntercept
-        ) / metadata.RescaleSlope
-    elif is_mr_storage:
-        # signal is usually correct as-is, no inversion needed
-        unscaled_array = scaled_array
-    else:
-        # invert it
-        orig_array = scaled_array
-        unscaled_array = -orig_array + orig_array.max() + orig_array.min()
-    return unscaled_array
-
-
-def _is_dicom(path: str | Path | io.BytesIO | ImageLike | np.ndarray) -> bool:
-    """Whether the file is a readable DICOM file via pydicom."""
-    return is_dicom_image(file=path)
-
-
-def _is_image_file(path: str | Path) -> bool:
-    """Whether the file is a readable image file via Pillow."""
-    try:
-        with pImage.open(path):
-            return True
-    except:
-        return False
-
-
-def _is_array(obj: Any) -> bool:
-    """Whether the object is a numpy array."""
-    return isinstance(obj, np.ndarray)
-
-
-class BaseImage:
-    """Base class for the Image classes.
-
-    Attributes
-    ----------
-    path : str
-        The path to the image file.
-    array : numpy.ndarray
-        The actual image pixel array.
-    """
-
-    array: np.ndarray
-    path: str | Path
-    metrics: list[MetricBase]
-    metric_values: dict[str, Any]
-
-    def __init__(
-        self, path: str | Path | BytesIO | ImageLike | np.ndarray | BufferedReader
-    ):
-        """
-        Parameters
-        ----------
-        path : str
-            The path to the image.
-        """
-        source: FILE_TYPE | STREAM_TYPE
-        self.metrics = []
-        self.metric_values = {}
-        if isinstance(path, (str, Path)) and not osp.isfile(path):
-            raise FileExistsError(
-                f"File `{path}` does not exist. Verify the file path name."
-            )
-        elif isinstance(path, (str, Path)) and osp.isfile(path):
-            self.path = path
-            self.base_path = osp.basename(path)
-            self.source = FILE_TYPE
-        else:
-            self.source = STREAM_TYPE
-            path.seek(0)
-            try:
-                self.path = str(Path(path.name))
-            except AttributeError:
-                self.path = ""
-
-    @property
-    def truncated_path(
-        self,
-    ) -> str:  # TODO: Use textwrap or pull out into util function
-        if self.source == FILE_TYPE:
-            path = str(self.path)
-            if len(path) > PATH_TRUNCATION_LENGTH:
-                return (
-                    path[: PATH_TRUNCATION_LENGTH // 2]
-                    + "..."
-                    + path[-PATH_TRUNCATION_LENGTH // 2 :]
-                )
-            else:
-                return path
-        else:
-            return ""  # was from stream, no path
-
-    @classmethod
-    def from_multiples(
-        cls,
-        filelist: list[str],
-        method: str = "mean",
-        stretch: bool = True,
-        **kwargs,
-    ) -> ImageLike:
-        """Load an instance from multiple image items. See :func:`~pylinac.core.image.load_multiples`."""
-        return load_multiples(filelist, method, stretch, **kwargs)
-
-    @property
-    def center(self) -> Point:
-        """Return the center position of the image array as a Point.
-        Even-length arrays will return the midpoint between central two indices. Odd will return the central index.
-        """
-        x_center = (self.shape[1] / 2) - 0.5
-        y_center = (self.shape[0] / 2) - 0.5
-        return Point(x_center, y_center)
-
-    @property
-    def physical_shape(self) -> (float, float):
-        """The physical size of the image in mm."""
-        return self.shape[0] / self.dpmm, self.shape[1] / self.dpmm
-
-    def date_created(self, format: str = "%A, %B %d, %Y") -> str:
-        """The date the file was created. Tries DICOM data before falling back on OS timestamp.
-        The method use one or more inputs of formatted code, where % means a placeholder and the letter the time unit of interest.
-        For a full description of the several formatting codes see `strftime() documentation. <https://docs.python.org/3/library/datetime.html#strftime-and-strptime-format-codes>`_
-
-        Parameters
-        ----------
-        format : str
-            %A means weekday full name, %B month full name, %d day of the month as a zero-padded decimal number and %Y year with century as a decimal number.
-
-        Returns
-        -------
-        str
-            The date the file was created.
-        """
-        date = None
-        try:
-            date = datetime.strptime(
-                self.metadata.InstanceCreationDate
-                + str(round(float(self.metadata.InstanceCreationTime))),
-                "%Y%m%d%H%M%S",
-            )
-            date = date.strftime(format)
-        except (AttributeError, ValueError):
-            try:
-                date = datetime.strptime(self.metadata.StudyDate, "%Y%m%d")
-                date = date.strftime(format)
-            except:
-                pass
-        if date is None:
-            try:
-                date = datetime.fromtimestamp(osp.getctime(self.path)).strftime(format)
-            except AttributeError:
-                date = "Unknown"
-        return date
-
-    def plot(
-        self,
-        ax: plt.Axes = None,
-        show: bool = True,
-        clear_fig: bool = False,
-        metric_kwargs: dict | None = None,
-        **kwargs,
-    ) -> plt.Axes:
-        """Plot the image.
-
-        Parameters
-        ----------
-        ax : matplotlib.Axes instance
-            The axis to plot the image to. If None, creates a new figure.
-        show : bool
-            Whether to actually show the image. Set to false when plotting multiple items.
-        clear_fig : bool
-            Whether to clear the prior items on the figure before plotting.
-        metric_kwargs : dict
-            kwargs passed to the metric plot method.
-        kwargs
-            kwargs passed to plt.imshow()
-        """
-        if metric_kwargs is None:
-            metric_kwargs = {}
-        if ax is None:
-            fig, ax = plt.subplots()
-        if clear_fig:
-            plt.clf()
-        ax.imshow(self.array, cmap=get_dicom_cmap(), **kwargs)
-        # plot the metrics
-        for metric in self.metrics:
-            metric.plot(axis=ax, **metric_kwargs)
-        if show:
-            plt.show()
-        return ax
-
-    def plot_metrics(self, show: bool = True) -> list[plt.figure]:
-        """Plot any additional figures from the metrics.
-
-        Returns a list of figures of the metrics. These metrics are not
-        drawn on the original image but rather are something complete separate.
-        E.g. a profile plot or a histogram of the metric."""
-        figs = []
-        for metric in self.metrics:
-            figs.append(metric.additional_plots())
-        if show:
-            plt.show()
-        return figs
-
-    def filter(
-        self,
-        size: float | int = 0.05,
-        kind: str = "median",
-    ) -> None:
-        """Filter the profile in place.
-
-        Parameters
-        ----------
-        size : int, float
-            Size of the median filter to apply.
-            If a float, the size is the ratio of the length. Must be in the range 0-1.
-            E.g. if size=0.1 for a 1000-element array, the filter will be 100 elements.
-            If an int, the filter is the size passed.
-        kind : {'median', 'gaussian'}
-            The kind of filter to apply. If gaussian, *size* is the sigma value.
-        """
-        self.array = filter(self.array, size=size, kind=kind)
-
-    def crop(
-        self,
-        pixels: int = 15,
-        edges: tuple[str, ...] = ("top", "bottom", "left", "right"),
-    ) -> None:
-        """Removes pixels on all edges of the image in-place.
-
-        Parameters
-        ----------
-        pixels : int
-            Number of pixels to cut off all sides of the image.
-        edges : tuple
-            Which edges to remove from. Can be any combination of the four edges.
-        """
-        if pixels <= 0:
-            raise ValueError("Pixels to remove must be a positive number")
-        if "top" in edges:
-            self.array = self.array[pixels:, :]
-        if "bottom" in edges:
-            self.array = self.array[:-pixels, :]
-        if "left" in edges:
-            self.array = self.array[:, pixels:]
-        if "right" in edges:
-            self.array = self.array[:, :-pixels]
-
-    def flipud(self) -> None:
-        """Flip the image array upside down in-place. Wrapper for np.flipud()"""
-        self.array = np.flipud(self.array)
-
-    def fliplr(self) -> None:
-        """Flip the image array upside down in-place. Wrapper for np.fliplr()"""
-        self.array = np.fliplr(self.array)
-
-    def invert(self) -> None:
-        """Invert (imcomplement) the image."""
-        self.array = invert(self.array)
-
-    def bit_invert(self) -> None:
-        """Invert the image bit-wise"""
-        self.array = bit_invert(self.array)
-
-    def roll(self, direction: str = "x", amount: int = 1) -> None:
-        """Roll the image array around in-place. Wrapper for np.roll().
-
-        Parameters
-        ----------
-        direction : {'x', 'y'}
-            The axis to roll over.
-        amount : int
-            The amount of elements to roll over.
-        """
-        axis = 1 if direction == "x" else 0
-        self.array = np.roll(self.array, amount, axis=axis)
-
-    def rot90(self, n: int = 1) -> None:
-        """Wrapper for numpy.rot90; rotate the array by 90 degrees CCW n times."""
-        self.array = np.rot90(self.array, n)
-
-    def rotate(self, angle: float, mode: str = "edge", *args, **kwargs):
-        """Rotate the image counter-clockwise. Simple wrapper for scikit-image. See https://scikit-image.org/docs/stable/api/skimage.transform.html#skimage.transform.rotate.
-        All parameters are passed to that function."""
-        self.array = rotate(self.array, angle, mode=mode, *args, **kwargs)
-
-    def threshold(self, threshold: float, kind: str = "high") -> None:
-        """Apply a high- or low-pass threshold filter.
-
-        Parameters
-        ----------
-        threshold : int
-            The cutoff value.
-        kind : str
-            If ``high`` (default), will apply a high-pass threshold. All values above the cutoff are left as-is.
-            Remaining points are set to 0.
-            If ``low``, will apply a low-pass threshold.
-        """
-        if kind == "high":
-            self.array = np.where(self.array >= threshold, self, 0)
-        else:
-            self.array = np.where(self.array <= threshold, self, 0)
-
-    def as_binary(self, threshold: int) -> ImageLike:
-        """Return a binary (black & white) image based on the given threshold.
-
-        Parameters
-        ----------
-        threshold : int, float
-            The threshold value. If the value is above or equal to the threshold it is set to 1, otherwise to 0.
-
-        Returns
-        -------
-        ArrayImage
-        """
-        array = np.where(self.array >= threshold, 1, 0)
-        return ArrayImage(array)
-
-    def dist2edge_min(self, point: Point | tuple) -> float:
-        """Calculates distance from given point to the closest edge.
-
-        Parameters
-        ----------
-        point : geometry.Point, tuple
-
-        Returns
-        -------
-        float
-        """
-        if isinstance(point, tuple):
-            point = Point(point)
-        rows = self.shape[0]
-        cols = self.shape[1]
-        disttoedge = np.zeros(4)
-        disttoedge[0] = rows - point.y
-        disttoedge[1] = cols - point.x
-        disttoedge[2] = point.y
-        disttoedge[3] = point.x
-        return min(disttoedge)
-
-    def ground(self) -> float:
-        """Ground the profile in place such that the lowest value is 0.
-
-        .. note::
-            This will also "ground" profiles that are negative or partially-negative.
-            For such profiles, be careful that this is the behavior you desire.
-
-        Returns
-        -------
-        float
-            The amount subtracted from the image.
-        """
-        min_val = self.array.min()
-        self.array = ground(self.array)
-        return min_val
-
-    def normalize(self, norm_val: str | float | None = None) -> None:
-        """Normalize the profile to the given value.
-
-        Parameters
-        ----------
-        value : number or None
-            If a number, normalize the array to that number. If None, normalizes to the maximum value.
-        """
-        # backwards compatibility
-        if norm_val == "max":
-            norm_val = None
-        self.array = normalize(self.array, value=norm_val)
-
-    def check_inversion(
-        self, box_size: int = 20, position: (float, float) = (0.0, 0.0)
-    ) -> None:
-        """Check the image for inversion by sampling the 4 image corners.
-        If the average value of the four corners is above the average pixel value, then it is very likely inverted.
-
-        Parameters
-        ----------
-        box_size : int
-            The size in pixels of the corner box to detect inversion.
-        position : 2-element sequence
-            The location of the sampling boxes.
-        """
-        row_pos = max(int(position[0] * self.array.shape[0]), 1)
-        col_pos = max(int(position[1] * self.array.shape[1]), 1)
-        lt_upper = self.array[
-            row_pos : row_pos + box_size, col_pos : col_pos + box_size
-        ]
-        rt_upper = self.array[
-            row_pos : row_pos + box_size, -col_pos - box_size : -col_pos
-        ]
-        lt_lower = self.array[
-            -row_pos - box_size : -row_pos, col_pos : col_pos + box_size
-        ]
-        rt_lower = self.array[
-            -row_pos - box_size : -row_pos, -col_pos - box_size : -col_pos
-        ]
-        avg = np.mean((lt_upper, lt_lower, rt_upper, rt_lower))
-        if avg > np.mean(self.array.flatten()):
-            self.invert()
-
-    def check_inversion_by_histogram(
-        self, percentiles: (float, float, float) = (5, 50, 95)
-    ) -> bool:
-        """Check the inversion of the image using histogram analysis. The assumption is that the image
-        is mostly background-like values and that there is a relatively small amount of dose getting to the image
-        (e.g. a picket fence image). This function looks at the distance from one percentile to another to determine
-        if the image should be inverted.
-
-        Parameters
-        ----------
-        percentiles : 3-element tuple
-            The 3 percentiles to compare. Default is (5, 50, 95). Recommend using (x, 50, y). To invert the other way
-            (where pixel value is *decreasing* with dose, reverse the percentiles, e.g. (95, 50, 5).
-
-        Returns
-        -------
-        bool: Whether an inversion was performed.
-        """
-        was_inverted = False
-        p_low = np.percentile(self.array, percentiles[0])
-        p_mid = np.percentile(self.array, percentiles[1])
-        p_high = np.percentile(self.array, percentiles[2])
-        mid_to_low = abs(p_mid - p_low)
-        mid_to_high = abs(p_mid - p_high)
-        if mid_to_low > mid_to_high:
-            was_inverted = True
-            self.invert()
-        return was_inverted
-
-    @argue.bounds(threshold=(0.0, 1.0))
-    def gamma(
-        self,
-        comparison_image: ImageLike,
-        doseTA: float = 1,
-        distTA: float = 1,
-        threshold: float = 0.1,
-        ground: bool = True,
-        normalize: bool = True,
-    ) -> np.ndarray:
-        """Calculate the gamma between the current image (reference) and a comparison image.
-
-        .. versionadded:: 1.2
-
-        The gamma calculation is based on `Bakai et al
-        <http://iopscience.iop.org/0031-9155/48/21/006/>`_ eq.6,
-        which is a quicker alternative to the standard Low gamma equation.
-
-        Parameters
-        ----------
-        comparison_image : {:class:`~pylinac.core.image.ArrayImage`, :class:`~pylinac.core.image.DicomImage`, or :class:`~pylinac.core.image.FileImage`}
-            The comparison image. The image must have the same DPI/DPMM to be comparable.
-            The size of the images must also be the same.
-        doseTA : int, float
-            Dose-to-agreement in percent; e.g. 2 is 2%.
-        distTA : int, float
-            Distance-to-agreement in mm.
-        threshold : float
-            The dose threshold percentage of the maximum dose, below which is not analyzed.
-            Must be between 0 and 1.
-        ground : bool
-            Whether to "ground" the image values. If true, this sets both datasets to have the minimum value at 0.
-            This can fix offset errors in the data.
-        normalize : bool
-            Whether to normalize the images. This sets the max value of each image to the same value.
-
-        Returns
-        -------
-        gamma_map : numpy.ndarray
-            The calculated gamma map.
-
-        See Also
-        --------
-        :func:`~pylinac.core.image.equate_images`
-        """
-        # error checking
-        if not is_close(self.dpi, comparison_image.dpi, delta=0.1):
-            raise AttributeError(
-                f"The image DPIs to not match: {self.dpi:.2f} vs. {comparison_image.dpi:.2f}"
-            )
-        same_x = is_close(self.shape[1], comparison_image.shape[1], delta=1.1)
-        same_y = is_close(self.shape[0], comparison_image.shape[0], delta=1.1)
-        if not (same_x and same_y):
-            raise AttributeError(
-                f"The images are not the same size: {self.shape} vs. {comparison_image.shape}"
-            )
-
-        # set up reference and comparison images
-        ref_img = ArrayImage(copy.copy(self.array))
-        ref_img.check_inversion_by_histogram()
-        if ground:
-            ref_img.ground()
-        if normalize:
-            ref_img.normalize()
-        comp_img = ArrayImage(copy.copy(comparison_image.array))
-        comp_img.check_inversion_by_histogram()
-        if ground:
-            comp_img.ground()
-        if normalize:
-            comp_img.normalize()
-
-        # invalidate dose values below threshold so gamma doesn't calculate over it
-        ref_img.array[ref_img < threshold * np.max(ref_img)] = np.NaN
-
-        # convert distance value from mm to pixels
-        distTA_pixels = self.dpmm * distTA
-
-        # construct image gradient using sobel filter
-        img_x = spf.sobel(ref_img.as_type(np.float32), 1)
-        img_y = spf.sobel(ref_img.as_type(np.float32), 0)
-        grad_img = np.hypot(img_x, img_y)
-
-        # equation: (measurement - reference) / sqrt ( doseTA^2 + distTA^2 * image_gradient^2 )
-        subtracted_img = np.abs(comp_img - ref_img)
-        denominator = np.sqrt(
-            ((doseTA / 100.0) ** 2) + ((distTA_pixels**2) * (grad_img**2))
-        )
-        gamma_map = subtracted_img / denominator
-
-        return gamma_map
-
-    def as_type(self, dtype: np.dtype) -> np.ndarray:
-        return self.array.astype(dtype)
-
-    def compute(self, metrics: list[MetricBase] | MetricBase) -> Any | dict[str, Any]:
-        """Compute the given metrics on the image.
-
-        This can be called multiple times to compute different metrics.
-        Metrics are appended on each call. This allows for modification
-        of the image between metric calls as well as the ability to compute
-        different metrics on the same image that might depend on
-        earlier metrics.
-
-        Metrics are both returned and stored in the ``metrics`` attribute.
-        The ``metrics`` attribute will store all metrics every calculated.
-        The metrics returned are only those passed in the ``metrics`` argument.
-
-        Parameters
-        ----------
-        metrics : list[MetricBase] | MetricBase
-            The metric(s) to compute.
-        """
-        metric_data = {}
-        if isinstance(metrics, MetricBase):
-            metrics = [metrics]
-        for metric in metrics:
-            metric.inject_image(self)
-            self.metrics.append(metric)
-            value = metric.context_calculate()
-            metric_data[metric.name] = value
-        self.metric_values |= metric_data
-        if len(metrics) == 1:
-            return metric_data[metrics[0].name]
-        return metric_data
-
-    @property
-    def shape(self) -> (int, int):
-        return self.array.shape
-
-    @property
-    def size(self) -> int:
-        return self.array.size
-
-    @property
-    def ndim(self) -> int:
-        return self.array.ndim
-
-    @property
-    def dtype(self) -> np.dtype:
-        return self.array.dtype
-
-    def sum(self) -> float:
-        return self.array.sum()
-
-    def ravel(self) -> np.ndarray:
-        return self.array.ravel()
-
-    @property
-    def flat(self) -> np.ndarray:
-        return self.array.flat
-
-    def __len__(self):
-        return len(self.array)
-
-    def __getitem__(self, item):
-        return self.array[item]
-
-
-class XIM(BaseImage):
-    """A class to open, read, and/or export an .xim image, Varian's custom image format which is 99.999% PNG
-
-    This had inspiration from a number of places:
-    - https://gist.github.com/1328/7da697c71f9c4ef12e1e
-    - https://medium.com/@duhroach/how-png-works-f1174e3cc7b7
-    - https://www.mathworks.com/matlabcentral/answers/419228-how-to-write-for-loop-and-execute-data
-    - https://www.w3.org/TR/PNG-Filters.html
-    - https://bitbucket.org/dmoderesearchtools/ximreader/src/master/
-    """
-
-    array: np.ndarray  #:
-    properties: dict  #:
-
-    def __init__(self, file_path: str | Path, read_pixels: bool = True):
-        """
-        Parameters
-        ----------
-        file_path
-            The path to the file of interest.
-        read_pixels
-            Whether to read and parse the pixel information. Doing so is quite slow.
-            Set this to false if, e.g., you are searching for images only via tags or doing
-            a pre-filtering of image selection.
-        """
-        super().__init__(path=file_path)
-        with open(self.path, "rb") as xim:
-            self.format_id = decode_binary(xim, str, 8)
-            self.format_version = decode_binary(xim, int)
-            self.img_width_px = decode_binary(xim, int)
-            self.img_height_px = decode_binary(xim, int)
-            self.bits_per_pixel = decode_binary(xim, int)
-            self.bytes_per_pixel = decode_binary(xim, int)
-            self.compression = decode_binary(xim, int)
-            if not self.compression:
-                pixel_buffer_size = decode_binary(xim, int)
-                self.pixel_buffer = decode_binary(
-                    xim, str, num_values=pixel_buffer_size
-                )
-            else:
-                lookup_table_size = decode_binary(xim, int)
-                self.lookup_table = decode_binary(
-                    xim, "B", num_values=lookup_table_size
-                )
-                comp_pixel_buffer_size = decode_binary(xim, int)
-                if read_pixels:
-                    lookup_keys = self._parse_lookup_table(self.lookup_table)
-                    self.array = self._parse_compressed_bytes(
-                        xim, lookup_table=lookup_keys
-                    )
-                else:
-                    _ = decode_binary(xim, "c", num_values=comp_pixel_buffer_size)
-                decode_binary(xim, int)
-            self.num_hist_bins = decode_binary(xim, int)
-            self.histogram = decode_binary(xim, int, num_values=self.num_hist_bins)
-            self.num_properties = decode_binary(xim, int)
-            self.properties = {}
-            for prop in range(self.num_properties):
-                name_length = decode_binary(xim, int)
-                name = decode_binary(xim, str, num_values=name_length)
-                tipe = decode_binary(xim, int)
-                if tipe == XIM_PROP_INT:
-                    value = decode_binary(xim, int)
-                elif tipe == XIM_PROP_DOUBLE:
-                    value = decode_binary(xim, "d")
-                elif tipe == XIM_PROP_STRING:
-                    num_bytes = decode_binary(xim, int)
-                    value = decode_binary(xim, str, num_values=num_bytes)
-                elif tipe == XIM_PROP_DOUBLE_ARRAY:
-                    num_bytes = decode_binary(xim, int)
-                    value = decode_binary(
-                        xim, "d", num_values=int(num_bytes // 8)
-                    )  # doubles are 8 bytes
-                elif tipe == XIM_PROP_INT_ARRAY:
-                    num_bytes = decode_binary(xim, int)
-                    value = decode_binary(
-                        xim, int, num_values=int(num_bytes // 4)
-                    )  # ints are 4 bytes
-                self.properties[name] = value
-
-    @staticmethod
-    def _parse_lookup_table(lookup_table_bytes: np.ndarray) -> np.ndarray:
-        """The lookup table doesn't follow normal structure conventions like 1, 2, or 4 byte values. They
-        got smart and said each value is 2 bits. Yes, bits. This means each byte is actually 4 values.
-        Python only reads things as granular as bytes. To get around this the general logic is:
-
-        1) interpret the data as integers at the single byte level
-        2) convert those integers back into bit representation; e.g. 115 => 01110011. Note the representation must contain the full byte. I.e. 3 => 11 does not work.
-        3) split the binary representation into the 2-bit representations; generates 4x the number of elements. 01110011 => (01, 11, 00, 11)
-        4) Convert the 2-bit representation back into integers (01, 11, 00, 11) => (1, 3, 0, 3)
-
-        .. note::
-
-            This is ripe for optimization, but brevity and clarity won out. Options include bit-shifting (fastest)
-            and numpy.packbits/unpackbits.
-        """
-        table = []
-        extend = table.extend  # prevent python having to do a lookup on each iteration
-        for byte in lookup_table_bytes:
-            byte_repr = f"{byte:08b}"
-            # didn't actually check these indexes but I think they're right.
-            extend(
-                [
-                    int(byte_repr[6:8], 2),
-                    int(byte_repr[4:6], 2),
-                    int(byte_repr[2:4], 2),
-                    int(byte_repr[0:2], 2),
-                ]
-            )
-        return np.asarray(table, dtype=np.int8)
-
-    def _parse_compressed_bytes(
-        self, xim: BinaryIO, lookup_table: np.ndarray
-    ) -> np.ndarray:
-        """Parse the compressed pixels. We have to do this pixel-by-pixel because each
-        pixel can have a different number of bytes representing it
-
-        Per the readme:
-
-        1) The first row is uncompressed
-        2) The first element of the second row is uncompressed
-        3) all other elements are represented by 1, 2, or 4 bytes of data (the annoying part)
-        4) The byte size of the element is given in the lookup table
-
-        So, we have to read in 1, 2, or 4 bytes and convert to an integer depending on
-        the lookup table, which tells us how many bytes to read in
-
-        .. note::
-
-            Optimization can help here. A few ideas:
-
-            - reading in groups of data of the same byte size. I already tried this, and I think it will work, but I couldn't get it going.
-            - reading in rows of data where no byte change occurred in that row. Similar to above.
-            - Using joblib or a processpool
-        """
-        img_height = self.img_height_px
-        img_width = self.img_width_px
-        dtype = np.int8 if self.bytes_per_pixel == 1 else np.int16
-        compressed_array = a = np.zeros((img_height * img_width), dtype=dtype)
-        # first row and 1st element, 2nd row is uncompressed
-        # this SHOULD work by reading the # of bytes specified in the header but AFAICT this is just a standard int (4 bytes)
-        compressed_array[: img_width + 1] = decode_binary(
-            xim, int, num_values=img_width + 1
-        )
-        diffs = self._get_diffs(lookup_table, xim)
-        for diff, idx in zip(diffs, range(img_width + 1, img_width * img_height)):
-            # intermediate math can cause overflow errors. Use float for intermediate, then back to int
-            left = float(a[idx - 1])
-            above = float(a[idx - img_width])
-            upper_left = float(a[idx - img_width - 1])
-            a[idx] = np.asarray(diff + left + above - upper_left, dtype=dtype)
-        return a.reshape((img_height, img_width))
-
-    @staticmethod
-    def _get_diffs(lookup_table: np.ndarray, xim: BinaryIO):
-        """Read in all the pixel value 'diffs'. These can be 1, 2, or 4 bytes in size,
-        so instead of just reading N pixels of M bytes which would be SOOOO easy, we have to read dynamically
-
-        We optimize here by reading bytes in clumps, which is way faster than reading one at a time.
-        Knowing that most values are single bytes with an occasional 2-byte element
-        we read chunks that all look like (n 1-bytes and 1 2-byte)
-        """
-        byte_changes = lookup_table.nonzero()
-        byte_changes = np.insert(byte_changes, 0, -1)
-        byte_changes = np.append(byte_changes, len(lookup_table) - 1)
-        diffs = [5000] * (
-            len(lookup_table) - 1
-        )  # pre-allocate for speed; 5000 is just for debugging
-        LOOKUP_CONVERSION = {0: "b", 1: "h", 2: "i"}
-        for start, stop in zip(byte_changes[:-1], byte_changes[1:]):
-            if stop - start > 1:
-                vals = decode_binary(xim, "b", num_values=stop - start - 1)
-                if not isinstance(vals, Iterable):
-                    vals = [
-                        vals,
-                    ]
-                diffs[start + 1 : stop] = vals
-            if stop != byte_changes[-1]:
-                diffs[stop] = decode_binary(xim, LOOKUP_CONVERSION[lookup_table[stop]])
-        return np.asarray(diffs, dtype=float)
-
-    @property
-    def dpmm(self) -> float:
-        """The dots/mm value of the XIM images. The value appears to be in cm in the file."""
-        if self.properties["PixelWidth"] != self.properties["PixelHeight"]:
-            raise ValueError(
-                "The XIM image does not have the same pixel height and width"
-            )
-        return 1 / (10 * self.properties["PixelHeight"])
-
-    def save_as(self, file: str, format: str | None = None) -> None:
-        """Save the image to a NORMAL format. PNG is highly suggested. Accepts any format supported by Pillow.
-        Ironically, an equivalent PNG image (w/ metadata) is ~50% smaller than an .xim image.
-
-        .. warning::
-
-            Any format other than PNG will not include the properties included in the .xim image!
-
-        Parameters
-        ----------
-        file
-            The file to save the image to. E.g. my_xim.png
-        format
-            The format to save the image as. Uses the Pillow logic, which will infer the format if the file name has one.
-        """
-        img = pImage.fromarray(self.array)
-        # we construct the custom PNG tags; it won't be included for tiff or jpeg, etc but it won't error it either.
-        metadata = PngInfo()
-        for prop, value in self.properties.items():
-            if isinstance(value, np.ndarray):
-                value = value.tolist()
-            if not isinstance(value, str):
-                value = json.dumps(value)
-            metadata.add_text(prop, value)
-        img.save(file, format=format, pnginfo=metadata)
-
-
-class DicomImage(BaseImage):
-    """An image from a DICOM RTImage file.
-
-    Attributes
-    ----------
-    metadata : pydicom Dataset
-        The dataset of the file as returned by pydicom without pixel data.
-    """
-
-    metadata: pydicom.FileDataset
-    _sid: float
-    _dpi: float
-    _sad: float
-
-    def __init__(
-        self,
-        path: str | Path | BytesIO | BufferedReader,
-        *,
-        dtype: np.dtype | None = None,
-        dpi: float = None,
-        sid: float = None,
-        sad: float = 1000,
-        raw_pixels: bool = False,
-    ):
-        """
-        Parameters
-        ----------
-        path : str, file-object
-            The path to the file or the data stream.
-        dtype : dtype, None, optional
-            The data type to cast the image data as. If None, will use whatever raw image format is.
-        dpi : int, float
-            The dots-per-inch of the image, defined at isocenter.
-
-            .. note:: If a DPI tag is found in the image, that value will override the parameter, otherwise this one
-                will be used.
-
-        sid : int, float
-            The Source-to-Image distance in mm.
-        sad : float
-            The Source-to-Axis distance in mm.
-        raw_pixels : bool
-            Whether to apply pixel intensity correction to the DICOM data.
-            Typically, Rescale Slope, Rescale Intercept, and other tags
-            are included and meant to be applied to the raw pixel data, which
-            is potentially compressed.
-            If True, no correction will be applied. This is typically used
-            for scenarios when you want to match behavior to older or different
-            software.
-        """
-        super().__init__(path)
-        self._sid = sid
-        self._dpi = dpi
-        self._sad = sad
-        # read the file once to get just the DICOM metadata
-        self.metadata = retrieve_dicom_file(path)
-        self._original_dtype = self.metadata.pixel_array.dtype
-        self._raw_pixels = raw_pixels
-        # read a second time to get pixel data
-        try:
-            path.seek(0)
-        except AttributeError:
-            pass
-        ds = retrieve_dicom_file(path)
-        if dtype is not None:
-            self.array = ds.pixel_array.astype(dtype)
-        else:
-            self.array = ds.pixel_array.copy()
-        # convert values to HU or CU
-        self.array = _rescale_dicom_values(self.array, ds, raw_pixels=raw_pixels)
-
-    @classmethod
-    def from_dataset(cls, dataset: Dataset):
-        """Create a DICOM image instance from a pydicom Dataset."""
-        stream = io.BytesIO()
-        dataset.save_as(stream)
-        return cls(path=stream)
-
-    def save(self, filename: str | Path) -> str | Path:
-        """Save the image instance back out to a .dcm file.
-
-        Parameters
-        ----------
-        filename : str, Path
-            The filename to save the DICOM file as.
-
-        Returns
-        -------
-        A string pointing to the new filename.
-        """
-        unscaled_array = _unscale_dicom_values(
-            self.array, self.metadata, self._raw_pixels
-        )
-        # if we will have bit overflows, stretch instead
-        max_is_too_high = (
-            unscaled_array.max() > get_dtype_info(self._original_dtype).max
-        )
-        min_is_too_low = unscaled_array.min() < get_dtype_info(self._original_dtype).min
-        if min_is_too_low or max_is_too_high:
-            warnings.warn(
-                "The pixel values of image were detected to be outside"
-                f"the range of {self._original_dtype} values and will be normalized to fit the original dtype. "
-                f"The maximum value will be the maximum value of the original datatype: ({get_dtype_info(self._original_dtype).max})."
-            )
-            unscaled_array = convert_to_dtype(unscaled_array, self._original_dtype)
-        if self._raw_pixels:
-            # for raw pixels, often the values are wacky; convert them to a normal range
-            # e.g. the range might be 0-1 for a float array. This will convert to the original dtype
-            # This prevents such arrays from being converted to only 0s and 1s for an int dtype.
-            unscaled_array = convert_to_dtype(unscaled_array, self._original_dtype)
-        self.metadata.PixelData = unscaled_array.astype(self._original_dtype).tobytes()
-        self.metadata.Columns = unscaled_array.shape[1]
-        self.metadata.Rows = unscaled_array.shape[0]
-        self.metadata.save_as(filename)
-        return filename
-
-    @property
-    def z_position(self) -> float:
-        """The z-position of the slice. Relevant for CT and MR images."""
-        return z_position(self.metadata)
-
-    @property
-    def slice_spacing(self) -> float:
-        """Determine the distance between slices. The spacing can be greater than the slice thickness (i.e. gaps).
-        Uses the absolute version as it can apparently be negative: https://dicom.innolitics.com/ciods/nm-image/nm-reconstruction/00180088
-
-        This attempts to use the slice spacing attr and if it doesn't exist, use the slice thickness attr
-        """
-
-        try:
-            return abs(self.metadata.SpacingBetweenSlices)
-        except AttributeError:
-            return self.metadata.SliceThickness
-
-    @property
-    def sid(self) -> float:
-        """The Source-to-Image in mm."""
-        try:
-            return float(self.metadata.RTImageSID)
-        except (AttributeError, ValueError, TypeError):
-            return self._sid
-
-    @property
-    def sad(self) -> float:
-        """The source to axis (iso) in mm"""
-        try:
-            return float(self.metadata.RadiationMachineSAD)
-        except (AttributeError, ValueError, TypeError):
-            return self._sad
-
-    @property
-    def dpi(self) -> float:
-        """The dots-per-inch of the image, defined at isocenter."""
-        try:
-            return self.dpmm * MM_PER_INCH
-        except:
-            return self._dpi
-
-    @property
-    def dpmm(self) -> float:
-        """The Dots-per-mm of the image, defined at isocenter. E.g. if an EPID image is taken at 150cm SID,
-        the dpmm will scale back to 100cm."""
-        dpmm = None
-        for tag in ("PixelSpacing", "ImagePlanePixelSpacing"):
-            mmpd = self.metadata.get(tag)
-            if mmpd is not None:
-                dpmm = 1 / mmpd[0]
-                break
-        if dpmm is not None and self.sid is not None:
-            dpmm *= self.sid / self.sad
-        elif dpmm is None and self._dpi is not None:
-            dpmm = self._dpi / MM_PER_INCH
-        return dpmm
-
-    @property
-    def cax(self) -> Point:
-        """The position of the beam central axis. If no DICOM translation tags are found then the center is returned.
-        Uses this tag: https://dicom.innolitics.com/ciods/rt-beams-delivery-instruction/rt-beams-delivery-instruction/00741020/00741030/3002000d
-        """
-        try:
-            x = self.center.x - self.metadata.XRayImageReceptorTranslation[0]
-            y = self.center.y - self.metadata.XRayImageReceptorTranslation[1]
-        except (AttributeError, ValueError, TypeError):
-            return self.center
-        else:
-            return Point(x, y)
-
-
-class LinacDicomImage(DicomImage):
-    """DICOM image taken on a linac. Also allows passing of gantry/coll/couch values via the filename."""
-
-    gantry_keyword = "Gantry"
-    collimator_keyword = "Coll"
-    couch_keyword = "Couch"
-
-    _use_filenames: bool
-
-    def __init__(
-        self,
-        path: str | Path | BinaryIO,
-        use_filenames: bool = False,
-        axes_precision: int | None = None,
-        **kwargs,
-    ):
-        self._gantry = kwargs.pop("gantry", None)
-        self._coll = kwargs.pop("coll", None)
-        self._couch = kwargs.pop("couch", None)
-        self._axes_precision = axes_precision
-        super().__init__(path, **kwargs)
-        self._use_filenames = use_filenames
-
-    @property
-    def gantry_angle(self) -> float:
-        """Gantry angle of the irradiation."""
-        if self._gantry is not None:
-            g = self._gantry
-        else:
-            g = self._get_axis_value(self.gantry_keyword, "GantryAngle")
-        return wrap360(simple_round(g, self._axes_precision))
-
-    @property
-    def collimator_angle(self) -> float:
-        """Collimator angle of the irradiation."""
-        if self._coll is not None:
-            c = self._coll
-        else:
-            c = self._get_axis_value(self.collimator_keyword, "BeamLimitingDeviceAngle")
-        return wrap360(simple_round(c, self._axes_precision))
-
-    @property
-    def couch_angle(self) -> float:
-        """Couch angle of the irradiation."""
-        if self._couch is not None:
-            c = self._couch
-        else:
-            c = self._get_axis_value(self.couch_keyword, "PatientSupportAngle")
-        return wrap360(simple_round(c, self._axes_precision))
-
-    def _get_axis_value(self, axis_str: str, axis_dcm_attr: str) -> float:
-        """Retrieve the value of the axis. This will first look in the file name for the value.
-        If not in the filename then it will look in the DICOM metadata. If the value can be found in neither
-        then a value of 0 is assumed.
-
-        Parameters
-        ----------
-        axis_str : str
-            The string to look for in the filename.
-        axis_dcm_attr : str
-            The DICOM attribute that should contain the axis value.
-
-        Returns
-        -------
-        float
-        """
-        axis_found = False
-        if self._use_filenames:
-            filename = osp.basename(self.path)
-            # see if the keyword is in the filename
-            keyword_in_filename = axis_str.lower() in filename.lower()
-            # if it's not there, then assume it's zero
-            if not keyword_in_filename:
-                axis = 0
-                axis_found = True
-            # if it is, then make sure it follows the naming convention of <axis###>
-            else:
-                match = re.search(rf"(?<={axis_str.lower()})\d+", filename.lower())
-                if match is None:
-                    raise ValueError(
-                        f"The filename contains '{axis_str}' but could not read a number following it. Use the format '...{axis_str}<#>...'"
-                    )
-                else:
-                    axis = float(match.group())
-                    axis_found = True
-        # try to interpret from DICOM data
-        if not axis_found:
-            try:
-                axis = float(getattr(self.metadata, axis_dcm_attr))
-            except AttributeError:
-                axis = 0
-        return axis
-
-
-class FileImage(BaseImage):
-    """An image from a "regular" file (.tif, .jpg, .bmp).
-
-    Attributes
-    ----------
-    info : dict
-        The info dictionary as generated by Pillow.
-    sid : float
-        The SID value as passed in upon construction.
-    """
-
-    def __init__(
-        self,
-        path: str | Path | BinaryIO,
-        *,
-        dpi: float | None = None,
-        sid: float | None = None,
-        dtype: np.dtype | None = None,
-    ):
-        """
-        Parameters
-        ----------
-        path : str, file-object
-            The path to the file or a data stream.
-        dpi : int, float
-            The dots-per-inch of the image, defined at isocenter.
-
-            .. note:: If a DPI tag is found in the image, that value will override the parameter, otherwise this one
-                will be used.
-        sid : int, float
-            The Source-to-Image distance in mm.
-        dtype : numpy.dtype
-            The data type to cast the array as. If None, will use the datatype stored in the file.
-            If the file is multi-channel (e.g. RGB), it will be converted to int32
-        """
-        super().__init__(path)
-        pil_image = pImage.open(path)
-        # convert from multichannel if need be
-        if len(pil_image.getbands()) > 1:
-            pil_image = pil_image.convert(
-                "I"
-            )  # int32; uint16 preferred but not reliable using PIL
-        self.info = pil_image.info
-        try:  # tiff tags
-            self.tags = {TAGS[key]: pil_image.tag_v2[key] for key in pil_image.tag_v2}
-        except AttributeError:
-            pass
-        self.array = np.array(pil_image, dtype=dtype)
-        self._dpi = dpi
-        self.sid = sid
-
-    @property
-    def dpi(self) -> float | None:
-        """The dots-per-inch of the image, defined at isocenter."""
-        dpi = None
-        for key in ("dpi", "resolution"):
-            dpi = self.info.get(key)
-            if dpi is not None:
-                dpi = float(dpi[0])
-                if dpi < 3 and not self._dpi:
-                    raise ValueError(
-                        f"The DPI setting is abnormal or nonsensical. Got resolution of {dpi}. Pass in the dpi manually."
-                    )
-                if dpi < 3:
-                    dpi = None
-                break
-        if dpi is None:
-            dpi = self._dpi
-        if self.sid is not None and dpi is not None:
-            dpi *= self.sid / 1000
-        return dpi
-
-    @property
-    def dpmm(self) -> float | None:
-        """The Dots-per-mm of the image, defined at isocenter. E.g. if an EPID image is taken at 150cm SID,
-        the dpmm will scale back to 100cm."""
-        try:
-            return self.dpi / MM_PER_INCH
-        except TypeError:
-            return
-
-
-class ArrayImage(BaseImage):
-    """An image constructed solely from a numpy array."""
-
-    def __init__(
-        self,
-        array: np.ndarray,
-        *,
-        dpi: float = None,
-        sid: float = None,
-        dtype=None,
-    ):
-        """
-        Parameters
-        ----------
-        array : numpy.ndarray
-            The image array.
-        dpi : int, float
-            The dots-per-inch of the image, defined at isocenter.
-
-            .. note:: If a DPI tag is found in the image, that value will override the parameter, otherwise this one
-                will be used.
-        sid : int, float
-            The Source-to-Image distance in mm.
-        dtype : dtype, None, optional
-            The data type to cast the image data as. If None, will use whatever raw image format is.
-        """
-        if dtype is not None:
-            self.array = np.array(array, dtype=dtype)
-        else:
-            self.array = array
-        self._dpi = dpi
-        self.sid = sid
-        self.metrics = []
-        self.metric_values = {}
-
-    @property
-    def dpmm(self) -> float | None:
-        """The Dots-per-mm of the image, defined at isocenter. E.g. if an EPID image is taken at 150cm SID,
-        the dpmm will scale back to 100cm."""
-        try:
-            return self.dpi / MM_PER_INCH
-        except:
-            return
-
-    @property
-    def dpi(self) -> float | None:
-        """The dots-per-inch of the image, defined at isocenter."""
-        dpi = None
-        if self._dpi is not None:
-            dpi = self._dpi
-            if self.sid is not None:
-                dpi *= self.sid / 1000
-        return dpi
-
-    def __sub__(self, other):
-        return ArrayImage(self.array - other.array)
-
-
-class LazyDicomImageStack:
-    _image_path_keys: list[Path]
-    metadatas: list[pydicom.Dataset]
-
-    def __init__(
-        self,
-        folder: str | Path,
-        dtype: np.dtype | None = None,
-        min_number: int = 39,
-        check_uid: bool = True,
-    ):
-        """Load a folder with DICOM CT images. This variant is more memory efficient than the standard DicomImageStack.
-
-        This is done by loading images from disk on the fly. This assumes all images remain on disk for the lifetime of the instance. This does not
-        need to be true for the original implementation.
-
-        See the documentation for DicomImageStack for parameter descriptions.
-        """
-        self.dtype = dtype
-        paths = []
-        # load in images in their received order
-        if isinstance(folder, (list, tuple)):
-            paths = folder
-        elif osp.isdir(folder):
-            for pdir, sdir, files in os.walk(folder):
-                for file in files:
-                    paths.append(osp.join(pdir, file))
-        # we only want to read the metadata once
-        # so we read it here and then filter and sort
-        metadatas, paths = self._get_path_metadatas(paths)
-
-        # check that at least 1 image was loaded
-        if len(paths) < 1:
-            raise FileNotFoundError(
-                f"No files were found in the specified location: {folder}"
-            )
-
-        # error checking
-        if check_uid:
-            most_common_uid = self._get_common_uid_imgs(metadatas, min_number)
-            metadatas = [m for m in metadatas if m.SeriesInstanceUID == most_common_uid]
-        # sort according to physical order
-        order = np.argsort([m.ImagePositionPatient[-1] for m in metadatas])
-        self.metadatas = [metadatas[i] for i in order]
-        self._image_path_keys = [paths[i] for i in order]
-
-    @classmethod
-    def from_zip(cls, zip_path: str | Path, dtype: np.dtype | None = None):
-        """Load a DICOM ZIP archive.
-
-        Parameters
-        ----------
-        zip_path : str
-            Path to the ZIP archive.
-        dtype : dtype, None, optional
-            The data type to cast the image data as. If None, will use whatever raw image format is.
-        """
-        with TemporaryZipDirectory(zip_path, delete=False) as tmpzip:
-            obj = cls(tmpzip, dtype)
-        return obj
-
-    def _get_common_uid_imgs(
-        self, metadata: list[pydicom.Dataset], min_number: int
-    ) -> pydicom.DataElement:
-        """Check that all the images are from the same study."""
-        most_common_uid = Counter(i.SeriesInstanceUID for i in metadata).most_common(1)[
-            0
-        ]
-        if most_common_uid[1] < min_number:
-            raise ValueError(
-                "The minimum number images from the same study were not found"
-            )
-        return most_common_uid[0]
-
-    def _get_path_metadatas(
-        self, paths: list[Path]
-    ) -> (list[pydicom.Dataset], list[Path]):
-        """Get the metadata for the images. This also filters out non-image files."""
-        metadata = []
-        matched_paths = []
-        for path in paths:
-            try:
-                ds = pydicom.dcmread(path, force=True, stop_before_pixels=True)
-                if "Image Storage" in ds.SOPClassUID.name:
-                    metadata.append(ds)
-                    matched_paths.append(path)
-            except (InvalidDicomError, AttributeError, MemoryError):
-                pass
-        return metadata, matched_paths
-
-    def side_view(self, axis: int) -> np.ndarray:
-        """Return the side view of the stack. E.g. if axis=0, return the maximum value along the 0th axis."""
-        return np.stack([i for i in self], axis=-1).max(axis=axis)
-
-    @cached_property
-    def metadata(self) -> pydicom.FileDataset:
-        """The metadata of the first image; shortcut attribute. Only attributes that are common throughout the stack should be used,
-        otherwise the individual image metadata should be used."""
-        return self[0].metadata
-
-    def __getitem__(self, item: int) -> DicomImage:
-        return DicomImage(self._image_path_keys[item], dtype=self.dtype)
-
-    def __len__(self):
-        return len(self._image_path_keys)
-
-
-class DicomImageStack(LazyDicomImageStack):
-    """A class that loads and holds a stack of DICOM images (e.g. a CT dataset). The class can take
-    a folder or zip file and will read CT images. The images must all be the same size. Supports
-    indexing to individual images.
-
-    Attributes
-    ----------
-    images : list
-        Holds instances of :class:`~pylinac.core.image.DicomImage`. Can be accessed via index;
-        i.e. self[0] == self.images[0].
-
-    Examples
-    --------
-    Load a folder of Dicom images
-    >>> from pylinac import image
-    >>> img_folder = r"folder/qa/cbct/june"
-    >>> dcm_stack = image.DicomImageStack(img_folder)  # loads and sorts the images
-    >>> dcm_stack.plot(3)  # plot the 3rd image
-
-    Load a zip archive
-    >>> img_folder_zip = r"archive/qa/cbct/june.zip"  # save space and zip your CBCTs
-    >>> dcm_stack = image.DicomImageStack.from_zip(img_folder_zip)
-
-    Load as a certain data type
-    >>> dcm_stack_uint32 = image.DicomImageStack(img_folder, dtype=np.uint32)
-    """
-
-    images: list[ImageLike]
-
-    def __init__(
-        self,
-        folder: str | Path,
-        dtype: np.dtype | None = None,
-        min_number: int = 39,
-        check_uid: bool = True,
-        raw_pixels: bool = False,
-    ):
-        """Load a folder with DICOM CT images.
-
-        Parameters
-        ----------
-        folder : str
-            Path to the folder.
-        dtype : dtype, None, optional
-            The data type to cast the image data as. If None, will use whatever raw image format is.
-        """
-        super().__init__(folder, dtype, min_number, check_uid)
-        self.images = [
-            DicomImage(path, dtype=dtype, raw_pixels=raw_pixels)
-            for path in self._image_path_keys
-        ]
-
-    @classmethod
-    def from_zip(cls, zip_path: str | Path, dtype: np.dtype | None = None):
-        """Load a DICOM ZIP archive.
-
-        Parameters
-        ----------
-        zip_path : str
-            Path to the ZIP archive.
-        dtype : dtype, None, optional
-            The data type to cast the image data as. If None, will use whatever raw image format is.
-        """
-        with TemporaryZipDirectory(zip_path) as tmpzip:
-            obj = cls(tmpzip, dtype)
-        return obj
-
-    def plot_3view(self):
-        """Plot the stack in 3 views: axial, coronal, and sagittal."""
-        fig, axes = plt.subplots(1, 3)
-        names = ("Coronal", "Sagittal", "Axial")
-        for idx, (ax, name) in enumerate(zip(axes, names)):
-            arry = self.side_view(idx)
-            ax.imshow(arry, cmap="gray", aspect="equal")
-            ax.set_title(name)
-        plt.show()
-
-    def roll(self, direction: str, amount: int):
-        for img in self.images:
-            img.roll(direction, amount)
-
-    def __getitem__(self, item) -> DicomImage:
-        return self.images[item]
-
-    def __setitem__(self, key, value: DicomImage):
-        self.images[key] = value
-
-    def __len__(self):
-        return len(self.images)
-
-
-def tiff_to_dicom(
-    tiff_file: str | Path | BytesIO,
-    sid: float,
-    gantry: float,
-    coll: float,
-    couch: float,
-    dpi: float | None = None,
-) -> Dataset:
-    """Converts a TIFF file into a **simplistic** DICOM file. Not meant to be a full-fledged tool. Used for conversion so that tools that are traditionally oriented
-    towards DICOM have a path to accept TIFF. Currently used to convert files for WL.
-
-    .. note::
-
-        This will convert the image into an uint16 datatype to match the native EPID datatype.
-
-    Parameters
-    ----------
-    tiff_file
-        The TIFF file to be converted.
-    sid
-        The Source-to-Image distance in mm.
-    dpi
-        The dots-per-inch value of the TIFF image.
-    gantry
-        The gantry value that the image was taken at.
-    coll
-        The collimator value that the image was taken at.
-    couch
-        The couch value that the image was taken at.
-    """
-    tiff_img = FileImage(tiff_file, dpi=dpi, sid=sid)
-    if not tiff_img.dpmm:
-        raise ValueError(
-            "Automatic detection of `dpi` failed. A `dpi` value must be passed to the constructor."
-        )
-    uint_array = convert_to_dtype(tiff_img.array, np.uint16)
-    mm_pixel = 25.4 / tiff_img.dpi
-    file_meta = FileMetaDataset()
-    # Main data elements
-    ds = Dataset()
-    ds.SOPClassUID = UID("1.2.840.10008.5.1.4.1.1.481.1")
-    ds.SOPInstanceUID = generate_uid()
-    ds.SeriesInstanceUID = generate_uid()
-    ds.Modality = "RTIMAGE"
-    ds.ConversionType = "WSD"
-    ds.PatientName = "Lutz^Test Tool"
-    ds.PatientID = "Someone Important"
-    ds.SamplesPerPixel = 1
-    ds.PhotometricInterpretation = "MONOCHROME2"
-    ds.Rows = tiff_img.shape[0]
-    ds.Columns = tiff_img.shape[1]
-    ds.BitsAllocated = 16
-    ds.BitsStored = 16
-    ds.HighBit = 15
-    ds.PixelRepresentation = 0
-    ds.ImagePlanePixelSpacing = [mm_pixel, mm_pixel]
-    ds.RadiationMachineSAD = "1000.0"
-    ds.RTImageSID = sid
-    ds.PrimaryDosimeterUnit = "MU"
-    ds.GantryAngle = str(gantry)
-    ds.BeamLimitingDeviceAngle = str(coll)
-    ds.PatientSupportAngle = str(couch)
-    ds.PixelData = uint_array
-
-    ds.file_meta = file_meta
-    ds.is_implicit_VR = True
-    ds.is_little_endian = True
-    return ds
-
-
-def gamma_2d(
-    reference: np.ndarray,
-    evaluation: np.ndarray,
-    dose_to_agreement: float = 1,
-    distance_to_agreement: int = 1,
-    gamma_cap_value: float = 2,
-    global_dose: bool = True,
-    dose_threshold: float = 5,
-    fill_value: float = np.nan,
-) -> np.ndarray:
-    """Compute a 2D gamma of two 2D numpy arrays. This does NOT do size or spatial resolution checking.
-    It performs an element-by-element evaluation. It is the responsibility
-    of the caller to ensure the reference and evaluation have comparable spatial resolution.
-
-    The algorithm follows Table I of D. Low's 2004 paper: Evaluation of the gamma dose distribution comparison method: https://aapm.onlinelibrary.wiley.com/doi/epdf/10.1118/1.1598711
-
-    This is similar to the gamma_1d function for profiles, except we must search a 2D grid around the reference point.
-
-    Parameters
-    ----------
-    reference
-        The reference 2D array.
-    evaluation
-        The evaluation 2D array.
-    dose_to_agreement
-        The dose to agreement in %. E.g. 1 is 1% of global reference max dose.
-    distance_to_agreement
-        The distance to agreement in **elements**. E.g. if the value is 4 this means 4 elements from the reference point under calculation.
-        Must be >0
-    gamma_cap_value
-        The value to cap the gamma at. E.g. a gamma of 5.3 will get capped to 2. Useful for displaying data with a consistent range.
-    global_dose
-        Whether to evaluate the dose to agreement threshold based on the global max or the dose point under evaluation.
-    dose_threshold
-        The dose threshold as a number between 0 and 100 of the % of max dose under which a gamma is not calculated.
-        This is not affected by the global/local dose normalization and the threshold value is evaluated against the global max dose, period.
-    fill_value
-        The value to give pixels that were not calculated because they were under the dose threshold. Default
-        is NaN, but another option would be 0. If NaN, allows the user to calculate mean/median gamma over just the
-        evaluated portion and not be skewed by 0's that should not be considered.
-    """
-    if reference.ndim != 2 or evaluation.ndim != 2:
-        raise ValueError(
-            f"Reference and evaluation arrays must be 2D. Got reference: {reference.ndim} and evaluation: {evaluation.ndim}"
-        )
-    threshold = reference.max() / 100 * dose_threshold
-    # convert dose to agreement to % of global max; ignored later if local dose
-    dose_ta = dose_to_agreement / 100 * reference.max()
-    # pad eval array on both edges so our search does not go out of bounds
-    eval_padded = np.pad(evaluation, distance_to_agreement, mode="edge")
-    # iterate over each reference element, computing distance value and dose value
-    gamma = np.zeros(reference.shape)
-    for row_idx, row in enumerate(reference):
-        for col_idx, ref_point in enumerate(row):
-            # skip if below dose threshold
-            if ref_point < threshold:
-                gamma[row_idx, col_idx] = fill_value
-                continue
-            # use scikit-image to compute the indices of a disk around the reference point
-            # we can then compute gamma over the eval points at these indices
-            # unlike the 1D computation, we have to search at an index offset by the distance to agreement
-            # we use DTA+1 in disk because it looks like the results are exclusive of edges.
-            # https://scikit-image.org/docs/stable/api/skimage.draw.html#disk
-            rs, cs = disk(
-                (row_idx + distance_to_agreement, col_idx + distance_to_agreement),
-                distance_to_agreement + 1,
-            )
-
-            capital_gammas = []
-            for r, c in zip(rs, cs):
-                eval_point = eval_padded[r, c]
-                # for the distance, we compare the ref row/col to the eval padded matrix
-                # but remember the padded array is padded by DTA, so to compare distances, we
-                # have to cancel the offset we used for dose purposes.
-                dist = math.dist(
-                    (row_idx, col_idx),
-                    (r - distance_to_agreement, c - distance_to_agreement),
-                )
-                dose = eval_point - ref_point
-                if not global_dose:
-                    dose_ta = dose_to_agreement / 100 * ref_point
-                capital_gamma = math.sqrt(
-                    dist**2 / distance_to_agreement**2 + dose**2 / dose_ta**2
-                )
-                capital_gammas.append(capital_gamma)
-            gamma[row_idx, col_idx] = min(np.nanmin(capital_gammas), gamma_cap_value)
-    return np.asarray(gamma)
-
-
-def z_position(metadata: pydicom.Dataset) -> float:
-    """The 'z-position' of the image. Relevant for CT and MR images."""
-    try:
-        return metadata.ImagePositionPatient[-1]
-    except AttributeError:
-        return metadata.SliceLocation
+"""This module holds classes for image loading and manipulation."""
+from __future__ import annotations
+
+import copy
+import io
+import json
+import math
+import os
+import os.path as osp
+import re
+import warnings
+from collections import Counter
+from datetime import datetime
+from functools import cached_property
+from io import BufferedReader, BytesIO
+from pathlib import Path
+from typing import Any, BinaryIO, Iterable, Sequence, Union
+
+import argue
+import matplotlib.pyplot as plt
+import numpy as np
+import pydicom
+import scipy.ndimage as spf
+from PIL import Image as pImage
+from PIL.PngImagePlugin import PngInfo
+from PIL.TiffTags import TAGS
+from pydicom.dataset import Dataset, FileMetaDataset
+from pydicom.errors import InvalidDicomError
+from pydicom.uid import UID, generate_uid
+from scipy import ndimage
+from skimage.draw import disk
+from skimage.transform import rotate
+
+from ..metrics.image import MetricBase
+from ..settings import PATH_TRUNCATION_LENGTH, get_dicom_cmap
+from .array_utils import (
+    bit_invert,
+    convert_to_dtype,
+    filter,
+    get_dtype_info,
+    ground,
+    invert,
+    normalize,
+)
+from .geometry import Point
+from .io import (
+    TemporaryZipDirectory,
+    get_url,
+    is_dicom_image,
+    retrieve_dicom_file,
+    retrieve_filenames,
+)
+from .profile import stretch as stretcharray
+from .scale import MachineScale, convert, wrap360
+from .utilities import decode_binary, is_close, simple_round
+
+ARRAY = "Array"
+DICOM = "DICOM"
+IMAGE = "Image"
+
+FILE_TYPE = "file"
+STREAM_TYPE = "stream"
+
+XIM_PROP_INT = 0
+XIM_PROP_DOUBLE = 1
+XIM_PROP_STRING = 2
+XIM_PROP_DOUBLE_ARRAY = 4
+XIM_PROP_INT_ARRAY = 5
+
+MM_PER_INCH = 25.4
+
+ImageLike = Union["DicomImage", "ArrayImage", "FileImage", "LinacDicomImage"]
+
+
+def equate_images(image1: ImageLike, image2: ImageLike) -> tuple[ImageLike, ImageLike]:
+    """Crop and resize two images to make them:
+      * The same pixel dimensions
+      * The same DPI
+
+    The usefulness of the function comes when trying to compare images from different sources.
+    The best example is calculating gamma on a machine log fluence and EPID image. The physical
+    and pixel dimensions must be normalized, the SID normalized
+
+    Parameters
+    ----------
+    image1 : {:class:`~pylinac.core.image.ArrayImage`, :class:`~pylinac.core.image.DicomImage`, :class:`~pylinac.core.image.FileImage`}
+        Must have DPI and SID.
+    image2 : {:class:`~pylinac.core.image.ArrayImage`, :class:`~pylinac.core.image.DicomImage`, :class:`~pylinac.core.image.FileImage`}
+        Must have DPI and SID.
+
+    Returns
+    -------
+    image1 : :class:`~pylinac.core.image.ArrayImage`
+        The first image equated.
+    image2 : :class:`~pylinac.core.image.ArrayImage`
+        The second image equated.
+    """
+    image1 = copy.deepcopy(image1)
+    image2 = copy.deepcopy(image2)
+    # crop images to be the same physical size
+    # ...crop height
+    physical_height_diff = image1.physical_shape[0] - image2.physical_shape[0]
+    if physical_height_diff < 0:  # image2 is bigger
+        img = image2
+    else:
+        img = image1
+    pixel_height_diff = abs(int(round(-physical_height_diff * img.dpmm / 2)))
+    if pixel_height_diff > 0:
+        img.crop(pixel_height_diff, edges=("top", "bottom"))
+
+    # ...crop width
+    physical_width_diff = image1.physical_shape[1] - image2.physical_shape[1]
+    if physical_width_diff > 0:
+        img = image1
+    else:
+        img = image2
+    pixel_width_diff = abs(int(round(physical_width_diff * img.dpmm / 2)))
+    if pixel_width_diff > 0:
+        img.crop(pixel_width_diff, edges=("left", "right"))
+
+    # resize images to be of the same shape
+    zoom_factor = image1.shape[1] / image2.shape[1]
+    image2_array = ndimage.interpolation.zoom(image2.as_type(float), zoom_factor)
+    image2 = load(image2_array, dpi=image2.dpi * zoom_factor)
+
+    return image1, image2
+
+
+def is_image(path: str | io.BytesIO | ImageLike | np.ndarray) -> bool:
+    """Determine whether the path is a valid image file.
+
+    Returns
+    -------
+    bool
+    """
+    return any((_is_array(path), _is_dicom(path), _is_image_file(path), _is_xim(path)))
+
+
+def retrieve_image_files(path: str) -> list[str]:
+    """Retrieve the file names of all the valid image files in the path.
+
+    Returns
+    -------
+    list
+        Contains strings pointing to valid image paths.
+    """
+    return retrieve_filenames(directory=path, func=is_image)
+
+
+def load(path: str | Path | ImageLike | np.ndarray | BinaryIO, **kwargs) -> ImageLike:
+    r"""Load a DICOM image, JPG/TIF/BMP image, or numpy 2D array.
+
+    Parameters
+    ----------
+    path : str, file-object
+        The path to the image file or data stream or array.
+    kwargs
+        See :class:`~pylinac.core.image.FileImage`, :class:`~pylinac.core.image.DicomImage`,
+        or :class:`~pylinac.core.image.ArrayImage` for keyword arguments.
+
+    Returns
+    -------
+    ::class:`~pylinac.core.image.FileImage`, :class:`~pylinac.core.image.ArrayImage`, or :class:`~pylinac.core.image.DicomImage`
+        Return type depends on input image.
+
+    Examples
+    --------
+    Load an image from a file and then apply a filter::
+
+        >>> from pylinac.core.image import load
+        >>> my_image = r"C:\QA\image.tif"
+        >>> img = load(my_image)  # returns a FileImage
+        >>> img.filter(5)
+
+    Loading from an array is just like loading from a file::
+
+        >>> arr = np.arange(36).reshape(6, 6)
+        >>> img = load(arr)  # returns an ArrayImage
+    """
+    if isinstance(path, BaseImage):
+        return path
+
+    if _is_array(path):
+        return ArrayImage(path, **kwargs)
+    elif _is_dicom(path):
+        return DicomImage(path, **kwargs)
+    elif _is_image_file(path):
+        return FileImage(path, **kwargs)
+    else:
+        raise TypeError(
+            f"The argument `{path}` was not found to be a valid DICOM file, Image file, or array"
+        )
+
+
+def load_url(url: str, progress_bar: bool = True, **kwargs) -> ImageLike:
+    """Load an image from a URL.
+
+    Parameters
+    ----------
+    url : str
+        A string pointing to a valid URL that points to a file.
+
+        .. note:: For some images (e.g. Github), the raw binary URL must be used, not simply the basic link.
+
+    progress_bar: bool
+        Whether to display a progress bar of download status.
+    """
+    filename = get_url(url, progress_bar=progress_bar)
+    return load(filename, **kwargs)
+
+
+def load_multiples(
+    image_file_list: Sequence,
+    method: str = "mean",
+    stretch_each: bool = True,
+    loader: callable = load,
+    **kwargs,
+) -> ImageLike:
+    """Combine multiple image files into one superimposed image.
+
+    Parameters
+    ----------
+    image_file_list : list
+        A list of the files to be superimposed.
+    method : {'mean', 'max', 'sum'}
+        A string specifying how the image values should be combined.
+    stretch_each : bool
+        Whether to normalize the images being combined by stretching their high/low values to the same values across images.
+    loader: callable
+        The function to use to load the images. If a special image subclass is used, this is how it can be passed.
+    kwargs :
+        Further keyword arguments are passed to the load function and stretch function.
+
+    Examples
+    --------
+    Load multiple images::
+
+        >>> from pylinac.core.image import load_multiples
+        >>> paths = ['starshot1.tif', 'starshot2.tif']
+        >>> superimposed_img = load_multiples(paths)
+    """
+    # load images
+    img_list = [loader(path, **kwargs) for path in image_file_list]
+    first_img = img_list[0]
+
+    # check that all images are the same size and stretch if need be
+    for img in img_list:
+        if img.shape != first_img.shape:
+            raise ValueError("Images were not the same shape")
+        if stretch_each:
+            img.array = stretcharray(img.array, fill_dtype=kwargs.get("dtype"))
+
+    # stack and combine arrays
+    new_array = np.dstack(tuple(img.array for img in img_list))
+    if method == "mean":
+        combined_arr = np.mean(new_array, axis=2)
+    elif method == "max":
+        combined_arr = np.max(new_array, axis=2)
+    elif method == "sum":
+        combined_arr = np.sum(new_array, axis=2)
+
+    # replace array of first object and return
+    first_img.array = combined_arr
+    # set the raw pixels flag; this will mark the image to be converted if we save out
+    first_img._raw_pixels = True
+    return first_img
+
+
+def _rescale_dicom_values(
+    unscaled_array: np.ndarray, metadata: Dataset, raw_pixels: bool
+) -> np.ndarray:
+    """Rescale the DICOM pixel values depending on the tags available.
+
+    See Also
+    --------
+    https://pylinac.readthedocs.io/en/latest/topics/images.html#pixel-data-inversion
+    """
+    has_all_rescale_tags = (
+        hasattr(metadata, "RescaleSlope")
+        and hasattr(metadata, "RescaleIntercept")
+        and hasattr(metadata, "PixelIntensityRelationshipSign")
+    )
+    has_some_rescale_tags = hasattr(metadata, "RescaleSlope") and hasattr(
+        metadata, "RescaleIntercept"
+    )
+    is_ct_storage = metadata.SOPClassUID.name == "CT Image Storage"
+    is_mr_storage = metadata.SOPClassUID.name == "MR Image Storage"
+    if raw_pixels:
+        return unscaled_array
+    elif has_all_rescale_tags:
+        scaled_array = (
+            (metadata.RescaleSlope * unscaled_array) + metadata.RescaleIntercept
+        ) * metadata.PixelIntensityRelationshipSign
+    elif is_ct_storage or has_some_rescale_tags:
+        scaled_array = (
+            metadata.RescaleSlope * unscaled_array
+        ) + metadata.RescaleIntercept
+    elif is_mr_storage:
+        # signal is usually correct as-is, no inversion needed
+        scaled_array = unscaled_array
+    else:
+        # invert it
+        orig_array = unscaled_array
+        scaled_array = -orig_array + orig_array.max() + orig_array.min()
+    return scaled_array
+
+
+def _unscale_dicom_values(
+    scaled_array: np.ndarray, metadata: Dataset, raw_pixels: bool
+) -> np.ndarray:
+    """Unscale the DICOM pixel values depending on the tags available.
+
+    This is the inverse of _rescale_dicom_values; specifically, when we
+    want to save the DICOM image we want to save the raw values
+    back to such that when re-importing and rescaling we will get the same array.
+    """
+    has_all_rescale_tags = (
+        hasattr(metadata, "RescaleSlope")
+        and hasattr(metadata, "RescaleIntercept")
+        and hasattr(metadata, "PixelIntensityRelationshipSign")
+    )
+    has_some_rescale_tags = hasattr(metadata, "RescaleSlope") and hasattr(
+        metadata, "RescaleIntercept"
+    )
+    is_ct_storage = metadata.SOPClassUID.name == "CT Image Storage"
+    is_mr_storage = metadata.SOPClassUID.name == "MR Image Storage"
+    if raw_pixels:
+        return scaled_array
+    elif has_all_rescale_tags:
+        unscaled_array = scaled_array * metadata.PixelIntensityRelationshipSign
+        unscaled_array = (
+            unscaled_array - metadata.RescaleIntercept
+        ) / metadata.RescaleSlope
+    elif is_ct_storage or has_some_rescale_tags:
+        unscaled_array = (
+            scaled_array - metadata.RescaleIntercept
+        ) / metadata.RescaleSlope
+    elif is_mr_storage:
+        # signal is usually correct as-is, no inversion needed
+        unscaled_array = scaled_array
+    else:
+        # invert it
+        orig_array = scaled_array
+        unscaled_array = -orig_array + orig_array.max() + orig_array.min()
+    return unscaled_array
+
+
+def _is_dicom(path: str | Path | io.BytesIO | ImageLike | np.ndarray) -> bool:
+    """Whether the file is a readable DICOM file via pydicom."""
+    return is_dicom_image(file=path)
+
+
+def _is_image_file(path: str | Path) -> bool:
+    """Whether the file is a readable image file via Pillow."""
+    try:
+        with pImage.open(path):
+            return True
+    except Exception:
+        return False
+
+
+def _is_xim(path: str | Path) -> bool:
+    """Whether the file is a readable XIM file."""
+    try:
+        with open(path, "rb") as xim:
+            format_id = decode_binary(xim, str, 8)
+        return format_id == "VMS.XI"
+    except Exception:
+        return False
+
+
+def _is_array(obj: Any) -> bool:
+    """Whether the object is a numpy array."""
+    return isinstance(obj, np.ndarray)
+
+
+class BaseImage:
+    """Base class for the Image classes.
+
+    Attributes
+    ----------
+    path : str
+        The path to the image file.
+    array : numpy.ndarray
+        The actual image pixel array.
+    """
+
+    array: np.ndarray
+    path: str | Path
+    metrics: list[MetricBase]
+    metric_values: dict[str, Any]
+    source: FILE_TYPE | STREAM_TYPE
+
+    def __init__(
+        self, path: str | Path | BytesIO | ImageLike | np.ndarray | BufferedReader
+    ):
+        """
+        Parameters
+        ----------
+        path : str
+            The path to the image.
+        """
+        self.metrics = []
+        self.metric_values = {}
+        if isinstance(path, (str, Path)) and not osp.isfile(path):
+            raise FileExistsError(
+                f"File `{path}` does not exist. Verify the file path name."
+            )
+        elif isinstance(path, (str, Path)) and osp.isfile(path):
+            self.path = path
+            self.base_path = osp.basename(path)
+            self.source = FILE_TYPE
+        else:
+            self.source = STREAM_TYPE
+            path.seek(0)
+            try:
+                self.path = str(Path(path.name))
+            except AttributeError:
+                self.path = ""
+
+    @property
+    def truncated_path(
+        self,
+    ) -> str:  # TODO: Use textwrap or pull out into util function
+        if self.source == FILE_TYPE:
+            path = str(self.path)
+            if len(path) > PATH_TRUNCATION_LENGTH:
+                return (
+                    path[: PATH_TRUNCATION_LENGTH // 2]
+                    + "..."
+                    + path[-PATH_TRUNCATION_LENGTH // 2 :]
+                )
+            else:
+                return path
+        else:
+            return ""  # was from stream, no path
+
+    @classmethod
+    def from_multiples(
+        cls,
+        filelist: list[str],
+        method: str = "mean",
+        stretch: bool = True,
+        **kwargs,
+    ) -> ImageLike:
+        """Load an instance from multiple image items. See :func:`~pylinac.core.image.load_multiples`."""
+        return load_multiples(filelist, method, stretch, **kwargs)
+
+    @property
+    def center(self) -> Point:
+        """Return the center position of the image array as a Point.
+        Even-length arrays will return the midpoint between central two indices. Odd will return the central index.
+        """
+        x_center = (self.shape[1] / 2) - 0.5
+        y_center = (self.shape[0] / 2) - 0.5
+        return Point(x_center, y_center)
+
+    @property
+    def physical_shape(self) -> (float, float):
+        """The physical size of the image in mm."""
+        return self.shape[0] / self.dpmm, self.shape[1] / self.dpmm
+
+    def date_created(self, format: str = "%A, %B %d, %Y") -> str:
+        """The date the file was created. Tries DICOM data before falling back on OS timestamp.
+        The method use one or more inputs of formatted code, where % means a placeholder and the letter the time unit of interest.
+        For a full description of the several formatting codes see `strftime() documentation. <https://docs.python.org/3/library/datetime.html#strftime-and-strptime-format-codes>`_
+
+        Parameters
+        ----------
+        format : str
+            %A means weekday full name, %B month full name, %d day of the month as a zero-padded decimal number and %Y year with century as a decimal number.
+
+        Returns
+        -------
+        str
+            The date the file was created.
+        """
+        date = None
+        try:
+            date = datetime.strptime(
+                self.metadata.InstanceCreationDate
+                + str(round(float(self.metadata.InstanceCreationTime))),
+                "%Y%m%d%H%M%S",
+            )
+            date = date.strftime(format)
+        except (AttributeError, ValueError):
+            try:
+                date = datetime.strptime(self.metadata.StudyDate, "%Y%m%d")
+                date = date.strftime(format)
+            except Exception:
+                pass
+        if date is None:
+            try:
+                date = datetime.fromtimestamp(osp.getctime(self.path)).strftime(format)
+            except AttributeError:
+                date = "Unknown"
+        return date
+
+    def plot(
+        self,
+        ax: plt.Axes = None,
+        show: bool = True,
+        clear_fig: bool = False,
+        show_metrics: bool = True,
+        metric_kwargs: dict | None = None,
+        **kwargs,
+    ) -> plt.Axes:
+        """Plot the image.
+
+        Parameters
+        ----------
+        ax : matplotlib.Axes instance
+            The axis to plot the image to. If None, creates a new figure.
+        show : bool
+            Whether to actually show the image. Set to false when plotting multiple items.
+        clear_fig : bool
+            Whether to clear the prior items on the figure before plotting.
+        show_metrics : bool
+            Whether to show the metrics on the image.
+        metric_kwargs : dict
+            kwargs passed to the metric plot method.
+        kwargs
+            kwargs passed to plt.imshow()
+        """
+        if metric_kwargs is None:
+            metric_kwargs = {}
+        if ax is None:
+            fig, ax = plt.subplots()
+        if clear_fig:
+            plt.clf()
+        ax.imshow(self.array, cmap=get_dicom_cmap(), **kwargs)
+        # plot the metrics
+        if show_metrics:
+            for metric in self.metrics:
+                metric.plot(axis=ax, **metric_kwargs)
+        if show:
+            plt.show()
+        return ax
+
+    def plot_metrics(self, show: bool = True) -> list[plt.figure]:
+        """Plot any additional figures from the metrics.
+
+        Returns a list of figures of the metrics. These metrics are not
+        drawn on the original image but rather are something complete separate.
+        E.g. a profile plot or a histogram of the metric."""
+        figs = []
+        for metric in self.metrics:
+            figs.append(metric.additional_plots())
+        if show:
+            plt.show()
+        return figs
+
+    def filter(
+        self,
+        size: float | int = 0.05,
+        kind: str = "median",
+    ) -> None:
+        """Filter the profile in place.
+
+        Parameters
+        ----------
+        size : int, float
+            Size of the median filter to apply.
+            If a float, the size is the ratio of the length. Must be in the range 0-1.
+            E.g. if size=0.1 for a 1000-element array, the filter will be 100 elements.
+            If an int, the filter is the size passed.
+        kind : {'median', 'gaussian'}
+            The kind of filter to apply. If gaussian, *size* is the sigma value.
+        """
+        self.array = filter(self.array, size=size, kind=kind)
+
+    def crop(
+        self,
+        pixels: int = 15,
+        edges: tuple[str, ...] = ("top", "bottom", "left", "right"),
+    ) -> None:
+        """Removes pixels on all edges of the image in-place.
+
+        Parameters
+        ----------
+        pixels : int
+            Number of pixels to cut off all sides of the image.
+        edges : tuple
+            Which edges to remove from. Can be any combination of the four edges.
+        """
+        if pixels <= 0:
+            raise ValueError("Pixels to remove must be a positive number")
+        if "top" in edges:
+            self.array = self.array[pixels:, :]
+        if "bottom" in edges:
+            self.array = self.array[:-pixels, :]
+        if "left" in edges:
+            self.array = self.array[:, pixels:]
+        if "right" in edges:
+            self.array = self.array[:, :-pixels]
+
+    def flipud(self) -> None:
+        """Flip the image array upside down in-place. Wrapper for np.flipud()"""
+        self.array = np.flipud(self.array)
+
+    def fliplr(self) -> None:
+        """Flip the image array upside down in-place. Wrapper for np.fliplr()"""
+        self.array = np.fliplr(self.array)
+
+    def invert(self) -> None:
+        """Invert (imcomplement) the image."""
+        self.array = invert(self.array)
+
+    def bit_invert(self) -> None:
+        """Invert the image bit-wise"""
+        self.array = bit_invert(self.array)
+
+    def roll(self, direction: str = "x", amount: int = 1) -> None:
+        """Roll the image array around in-place. Wrapper for np.roll().
+
+        Parameters
+        ----------
+        direction : {'x', 'y'}
+            The axis to roll over.
+        amount : int
+            The amount of elements to roll over.
+        """
+        axis = 1 if direction == "x" else 0
+        self.array = np.roll(self.array, amount, axis=axis)
+
+    def rot90(self, n: int = 1) -> None:
+        """Wrapper for numpy.rot90; rotate the array by 90 degrees CCW n times."""
+        self.array = np.rot90(self.array, n)
+
+    def rotate(self, angle: float, mode: str = "edge", *args, **kwargs):
+        """Rotate the image counter-clockwise. Simple wrapper for scikit-image. See https://scikit-image.org/docs/stable/api/skimage.transform.html#skimage.transform.rotate.
+        All parameters are passed to that function."""
+        self.array = rotate(self.array, angle, mode=mode, *args, **kwargs)
+
+    def threshold(self, threshold: float, kind: str = "high") -> None:
+        """Apply a high- or low-pass threshold filter.
+
+        Parameters
+        ----------
+        threshold : int
+            The cutoff value.
+        kind : str
+            If ``high`` (default), will apply a high-pass threshold. All values above the cutoff are left as-is.
+            Remaining points are set to 0.
+            If ``low``, will apply a low-pass threshold.
+        """
+        if kind == "high":
+            self.array = np.where(self.array >= threshold, self, 0)
+        else:
+            self.array = np.where(self.array <= threshold, self, 0)
+
+    def as_binary(self, threshold: int) -> ImageLike:
+        """Return a binary (black & white) image based on the given threshold.
+
+        Parameters
+        ----------
+        threshold : int, float
+            The threshold value. If the value is above or equal to the threshold it is set to 1, otherwise to 0.
+
+        Returns
+        -------
+        ArrayImage
+        """
+        array = np.where(self.array >= threshold, 1, 0)
+        return ArrayImage(array)
+
+    def dist2edge_min(self, point: Point | tuple) -> float:
+        """Calculates distance from given point to the closest edge.
+
+        Parameters
+        ----------
+        point : geometry.Point, tuple
+
+        Returns
+        -------
+        float
+        """
+        if isinstance(point, tuple):
+            point = Point(point)
+        rows = self.shape[0]
+        cols = self.shape[1]
+        disttoedge = np.zeros(4)
+        disttoedge[0] = rows - point.y
+        disttoedge[1] = cols - point.x
+        disttoedge[2] = point.y
+        disttoedge[3] = point.x
+        return min(disttoedge)
+
+    def ground(self) -> float:
+        """Ground the profile in place such that the lowest value is 0.
+
+        .. note::
+            This will also "ground" profiles that are negative or partially-negative.
+            For such profiles, be careful that this is the behavior you desire.
+
+        Returns
+        -------
+        float
+            The amount subtracted from the image.
+        """
+        min_val = self.array.min()
+        self.array = ground(self.array)
+        return min_val
+
+    def normalize(self, norm_val: str | float | None = None) -> None:
+        """Normalize the profile to the given value.
+
+        Parameters
+        ----------
+        value : number or None
+            If a number, normalize the array to that number. If None, normalizes to the maximum value.
+        """
+        # backwards compatibility
+        if norm_val == "max":
+            norm_val = None
+        self.array = normalize(self.array, value=norm_val)
+
+    def check_inversion(
+        self, box_size: int = 20, position: (float, float) = (0.0, 0.0)
+    ) -> None:
+        """Check the image for inversion by sampling the 4 image corners.
+        If the average value of the four corners is above the average pixel value, then it is very likely inverted.
+
+        Parameters
+        ----------
+        box_size : int
+            The size in pixels of the corner box to detect inversion.
+        position : 2-element sequence
+            The location of the sampling boxes.
+        """
+        row_pos = max(int(position[0] * self.array.shape[0]), 1)
+        col_pos = max(int(position[1] * self.array.shape[1]), 1)
+        lt_upper = self.array[
+            row_pos : row_pos + box_size, col_pos : col_pos + box_size
+        ]
+        rt_upper = self.array[
+            row_pos : row_pos + box_size, -col_pos - box_size : -col_pos
+        ]
+        lt_lower = self.array[
+            -row_pos - box_size : -row_pos, col_pos : col_pos + box_size
+        ]
+        rt_lower = self.array[
+            -row_pos - box_size : -row_pos, -col_pos - box_size : -col_pos
+        ]
+        avg = np.mean((lt_upper, lt_lower, rt_upper, rt_lower))
+        if avg > np.mean(self.array.flatten()):
+            self.invert()
+
+    def check_inversion_by_histogram(
+        self, percentiles: (float, float, float) = (5, 50, 95)
+    ) -> bool:
+        """Check the inversion of the image using histogram analysis. The assumption is that the image
+        is mostly background-like values and that there is a relatively small amount of dose getting to the image
+        (e.g. a picket fence image). This function looks at the distance from one percentile to another to determine
+        if the image should be inverted.
+
+        Parameters
+        ----------
+        percentiles : 3-element tuple
+            The 3 percentiles to compare. Default is (5, 50, 95). Recommend using (x, 50, y). To invert the other way
+            (where pixel value is *decreasing* with dose, reverse the percentiles, e.g. (95, 50, 5).
+
+        Returns
+        -------
+        bool: Whether an inversion was performed.
+        """
+        was_inverted = False
+        p_low = np.percentile(self.array, percentiles[0])
+        p_mid = np.percentile(self.array, percentiles[1])
+        p_high = np.percentile(self.array, percentiles[2])
+        mid_to_low = abs(p_mid - p_low)
+        mid_to_high = abs(p_mid - p_high)
+        if mid_to_low > mid_to_high:
+            was_inverted = True
+            self.invert()
+        return was_inverted
+
+    @argue.bounds(threshold=(0.0, 1.0))
+    def gamma(
+        self,
+        comparison_image: ImageLike,
+        doseTA: float = 1,
+        distTA: float = 1,
+        threshold: float = 0.1,
+        ground: bool = True,
+        normalize: bool = True,
+    ) -> np.ndarray:
+        """Calculate the gamma between the current image (reference) and a comparison image.
+
+        .. versionadded:: 1.2
+
+        The gamma calculation is based on `Bakai et al
+        <http://iopscience.iop.org/0031-9155/48/21/006/>`_ eq.6,
+        which is a quicker alternative to the standard Low gamma equation.
+
+        Parameters
+        ----------
+        comparison_image : {:class:`~pylinac.core.image.ArrayImage`, :class:`~pylinac.core.image.DicomImage`, or :class:`~pylinac.core.image.FileImage`}
+            The comparison image. The image must have the same DPI/DPMM to be comparable.
+            The size of the images must also be the same.
+        doseTA : int, float
+            Dose-to-agreement in percent; e.g. 2 is 2%.
+        distTA : int, float
+            Distance-to-agreement in mm.
+        threshold : float
+            The dose threshold percentage of the maximum dose, below which is not analyzed.
+            Must be between 0 and 1.
+        ground : bool
+            Whether to "ground" the image values. If true, this sets both datasets to have the minimum value at 0.
+            This can fix offset errors in the data.
+        normalize : bool
+            Whether to normalize the images. This sets the max value of each image to the same value.
+
+        Returns
+        -------
+        gamma_map : numpy.ndarray
+            The calculated gamma map.
+
+        See Also
+        --------
+        :func:`~pylinac.core.image.equate_images`
+        """
+        # error checking
+        if not is_close(self.dpi, comparison_image.dpi, delta=0.1):
+            raise AttributeError(
+                f"The image DPIs to not match: {self.dpi:.2f} vs. {comparison_image.dpi:.2f}"
+            )
+        same_x = is_close(self.shape[1], comparison_image.shape[1], delta=1.1)
+        same_y = is_close(self.shape[0], comparison_image.shape[0], delta=1.1)
+        if not (same_x and same_y):
+            raise AttributeError(
+                f"The images are not the same size: {self.shape} vs. {comparison_image.shape}"
+            )
+
+        # set up reference and comparison images
+        ref_img = ArrayImage(copy.copy(self.array))
+        ref_img.check_inversion_by_histogram()
+        if ground:
+            ref_img.ground()
+        if normalize:
+            ref_img.normalize()
+        comp_img = ArrayImage(copy.copy(comparison_image.array))
+        comp_img.check_inversion_by_histogram()
+        if ground:
+            comp_img.ground()
+        if normalize:
+            comp_img.normalize()
+
+        # invalidate dose values below threshold so gamma doesn't calculate over it
+        ref_img.array[ref_img < threshold * np.max(ref_img)] = np.NaN
+
+        # convert distance value from mm to pixels
+        distTA_pixels = self.dpmm * distTA
+
+        # construct image gradient using sobel filter
+        img_x = spf.sobel(ref_img.as_type(np.float32), 1)
+        img_y = spf.sobel(ref_img.as_type(np.float32), 0)
+        grad_img = np.hypot(img_x, img_y)
+
+        # equation: (measurement - reference) / sqrt ( doseTA^2 + distTA^2 * image_gradient^2 )
+        subtracted_img = np.abs(comp_img - ref_img)
+        denominator = np.sqrt(
+            ((doseTA / 100.0) ** 2) + ((distTA_pixels**2) * (grad_img**2))
+        )
+        gamma_map = subtracted_img / denominator
+
+        return gamma_map
+
+    def as_type(self, dtype: np.dtype) -> np.ndarray:
+        return self.array.astype(dtype)
+
+    def compute(self, metrics: list[MetricBase] | MetricBase) -> Any | dict[str, Any]:
+        """Compute the given metrics on the image.
+
+        This can be called multiple times to compute different metrics.
+        Metrics are appended on each call. This allows for modification
+        of the image between metric calls as well as the ability to compute
+        different metrics on the same image that might depend on
+        earlier metrics.
+
+        Metrics are both returned and stored in the ``metrics`` attribute.
+        The ``metrics`` attribute will store all metrics every calculated.
+        The metrics returned are only those passed in the ``metrics`` argument.
+
+        Parameters
+        ----------
+        metrics : list[MetricBase] | MetricBase
+            The metric(s) to compute.
+        """
+        metric_data = {}
+        if isinstance(metrics, MetricBase):
+            metrics = [metrics]
+        for metric in metrics:
+            metric.inject_image(self)
+            self.metrics.append(metric)
+            value = metric.context_calculate()
+            metric_data[metric.name] = value
+        self.metric_values |= metric_data
+        if len(metrics) == 1:
+            return metric_data[metrics[0].name]
+        return metric_data
+
+    @property
+    def shape(self) -> (int, int):
+        return self.array.shape
+
+    @property
+    def size(self) -> int:
+        return self.array.size
+
+    @property
+    def ndim(self) -> int:
+        return self.array.ndim
+
+    @property
+    def dtype(self) -> np.dtype:
+        return self.array.dtype
+
+    def sum(self) -> float:
+        return self.array.sum()
+
+    def ravel(self) -> np.ndarray:
+        return self.array.ravel()
+
+    @property
+    def flat(self) -> np.ndarray:
+        return self.array.flat
+
+    def __len__(self):
+        return len(self.array)
+
+    def __getitem__(self, item):
+        return self.array[item]
+
+
+class XIM(BaseImage):
+    """A class to open, read, and/or export an .xim image, Varian's custom image format which is 99.999% PNG
+
+    This had inspiration from a number of places:
+    - https://gist.github.com/1328/7da697c71f9c4ef12e1e
+    - https://medium.com/@duhroach/how-png-works-f1174e3cc7b7
+    - https://www.mathworks.com/matlabcentral/answers/419228-how-to-write-for-loop-and-execute-data
+    - https://www.w3.org/TR/PNG-Filters.html
+    - https://bitbucket.org/dmoderesearchtools/ximreader/src/master/
+    """
+
+    array: np.ndarray  #:
+    properties: dict  #:
+
+    def __init__(self, file_path: str | Path, read_pixels: bool = True):
+        """
+        Parameters
+        ----------
+        file_path
+            The path to the file of interest.
+        read_pixels
+            Whether to read and parse the pixel information. Doing so is quite slow.
+            Set this to false if, e.g., you are searching for images only via tags or doing
+            a pre-filtering of image selection.
+        """
+        super().__init__(path=file_path)
+        with open(self.path, "rb") as xim:
+            self.format_id = decode_binary(xim, str, 8)
+            self.format_version = decode_binary(xim, int)
+            self.img_width_px = decode_binary(xim, int)
+            self.img_height_px = decode_binary(xim, int)
+            self.bits_per_pixel = decode_binary(xim, int)
+            self.bytes_per_pixel = decode_binary(xim, int)
+            self.compression = decode_binary(xim, int)
+            if not self.compression:
+                pixel_buffer_size = decode_binary(xim, int)
+                self.pixel_buffer = decode_binary(
+                    xim, str, num_values=pixel_buffer_size
+                )
+            else:
+                lookup_table_size = decode_binary(xim, int)
+                self.lookup_table = decode_binary(
+                    xim, "B", num_values=lookup_table_size
+                )
+                comp_pixel_buffer_size = decode_binary(xim, int)
+                if read_pixels:
+                    lookup_keys = self._parse_lookup_table(self.lookup_table)
+                    self.array = self._parse_compressed_bytes(
+                        xim, lookup_table=lookup_keys
+                    )
+                else:
+                    _ = decode_binary(xim, "c", num_values=comp_pixel_buffer_size)
+                decode_binary(xim, int)
+            self.num_hist_bins = decode_binary(xim, int)
+            self.histogram = decode_binary(xim, int, num_values=self.num_hist_bins)
+            self.num_properties = decode_binary(xim, int)
+            self.properties = {}
+            for prop in range(self.num_properties):
+                name_length = decode_binary(xim, int)
+                name = decode_binary(xim, str, num_values=name_length)
+                tipe = decode_binary(xim, int)
+                if tipe == XIM_PROP_INT:
+                    value = decode_binary(xim, int)
+                elif tipe == XIM_PROP_DOUBLE:
+                    value = decode_binary(xim, "d")
+                elif tipe == XIM_PROP_STRING:
+                    num_bytes = decode_binary(xim, int)
+                    value = decode_binary(xim, str, num_values=num_bytes)
+                elif tipe == XIM_PROP_DOUBLE_ARRAY:
+                    num_bytes = decode_binary(xim, int)
+                    value = decode_binary(
+                        xim, "d", num_values=int(num_bytes // 8)
+                    )  # doubles are 8 bytes
+                elif tipe == XIM_PROP_INT_ARRAY:
+                    num_bytes = decode_binary(xim, int)
+                    value = decode_binary(
+                        xim, int, num_values=int(num_bytes // 4)
+                    )  # ints are 4 bytes
+                self.properties[name] = value
+
+    @staticmethod
+    def _parse_lookup_table(lookup_table_bytes: np.ndarray) -> np.ndarray:
+        """The lookup table doesn't follow normal structure conventions like 1, 2, or 4 byte values. They
+        got smart and said each value is 2 bits. Yes, bits. This means each byte is actually 4 values.
+        Python only reads things as granular as bytes. To get around this the general logic is:
+
+        1) interpret the data as integers at the single byte level
+        2) convert those integers back into bit representation; e.g. 115 => 01110011. Note the representation must contain the full byte. I.e. 3 => 11 does not work.
+        3) split the binary representation into the 2-bit representations; generates 4x the number of elements. 01110011 => (01, 11, 00, 11)
+        4) Convert the 2-bit representation back into integers (01, 11, 00, 11) => (1, 3, 0, 3)
+
+        .. note::
+
+            This is ripe for optimization, but brevity and clarity won out. Options include bit-shifting (fastest)
+            and numpy.packbits/unpackbits.
+        """
+        table = []
+        extend = table.extend  # prevent python having to do a lookup on each iteration
+        for byte in lookup_table_bytes:
+            byte_repr = f"{byte:08b}"
+            # didn't actually check these indexes but I think they're right.
+            extend(
+                [
+                    int(byte_repr[6:8], 2),
+                    int(byte_repr[4:6], 2),
+                    int(byte_repr[2:4], 2),
+                    int(byte_repr[0:2], 2),
+                ]
+            )
+        return np.asarray(table, dtype=np.int8)
+
+    def _parse_compressed_bytes(
+        self, xim: BinaryIO, lookup_table: np.ndarray
+    ) -> np.ndarray:
+        """Parse the compressed pixels. We have to do this pixel-by-pixel because each
+        pixel can have a different number of bytes representing it
+
+        Per the readme:
+
+        1) The first row is uncompressed
+        2) The first element of the second row is uncompressed
+        3) all other elements are represented by 1, 2, or 4 bytes of data (the annoying part)
+        4) The byte size of the element is given in the lookup table
+
+        So, we have to read in 1, 2, or 4 bytes and convert to an integer depending on
+        the lookup table, which tells us how many bytes to read in
+
+        .. note::
+
+            Optimization can help here. A few ideas:
+
+            - reading in groups of data of the same byte size. I already tried this, and I think it will work, but I couldn't get it going.
+            - reading in rows of data where no byte change occurred in that row. Similar to above.
+            - Using joblib or a processpool
+        """
+        img_height = self.img_height_px
+        img_width = self.img_width_px
+        dtype = np.int8 if self.bytes_per_pixel == 1 else np.int16
+        compressed_array = a = np.zeros((img_height * img_width), dtype=dtype)
+        # first row and 1st element, 2nd row is uncompressed
+        # this SHOULD work by reading the # of bytes specified in the header but AFAICT this is just a standard int (4 bytes)
+        compressed_array[: img_width + 1] = decode_binary(
+            xim, int, num_values=img_width + 1
+        )
+        diffs = self._get_diffs(lookup_table, xim)
+        for diff, idx in zip(diffs, range(img_width + 1, img_width * img_height)):
+            # intermediate math can cause overflow errors. Use float for intermediate, then back to int
+            left = float(a[idx - 1])
+            above = float(a[idx - img_width])
+            upper_left = float(a[idx - img_width - 1])
+            a[idx] = np.asarray(diff + left + above - upper_left, dtype=dtype)
+        return a.reshape((img_height, img_width))
+
+    @staticmethod
+    def _get_diffs(lookup_table: np.ndarray, xim: BinaryIO):
+        """Read in all the pixel value 'diffs'. These can be 1, 2, or 4 bytes in size,
+        so instead of just reading N pixels of M bytes which would be SOOOO easy, we have to read dynamically
+
+        We optimize here by reading bytes in clumps, which is way faster than reading one at a time.
+        Knowing that most values are single bytes with an occasional 2-byte element
+        we read chunks that all look like (n 1-bytes and 1 2-byte)
+        """
+        byte_changes = lookup_table.nonzero()
+        byte_changes = np.insert(byte_changes, 0, -1)
+        byte_changes = np.append(byte_changes, len(lookup_table) - 1)
+        diffs = [5000] * (
+            len(lookup_table) - 1
+        )  # pre-allocate for speed; 5000 is just for debugging
+        LOOKUP_CONVERSION = {0: "b", 1: "h", 2: "i"}
+        for start, stop in zip(byte_changes[:-1], byte_changes[1:]):
+            if stop - start > 1:
+                vals = decode_binary(xim, "b", num_values=stop - start - 1)
+                if not isinstance(vals, Iterable):
+                    vals = [
+                        vals,
+                    ]
+                diffs[start + 1 : stop] = vals
+            if stop != byte_changes[-1]:
+                diffs[stop] = decode_binary(xim, LOOKUP_CONVERSION[lookup_table[stop]])
+        return np.asarray(diffs, dtype=float)
+
+    @property
+    def dpmm(self) -> float:
+        """The dots/mm value of the XIM images. The value appears to be in cm in the file."""
+        if self.properties["PixelWidth"] != self.properties["PixelHeight"]:
+            raise ValueError(
+                "The XIM image does not have the same pixel height and width"
+            )
+        return 1 / (10 * self.properties["PixelHeight"])
+
+    def as_dicom(self) -> Dataset:
+        """Save the XIM image as a *simplistic* DICOM file. Only meant for basic image storage/analysis.
+
+        It appears that XIM images are in the Varian standard coordinate system.
+        We convert to IEC61217 for more general compatibility.
+        """
+        iec_g, iec_c, iec_p = convert(
+            input_scale=MachineScale.VARIAN_STANDARD,
+            output_scale=MachineScale.IEC61217,
+            gantry=self.properties["GantryRtn"],
+            collimator=self.properties["MVCollimatorRtn"],
+            rotation=self.properties["CouchRtn"],
+        )
+        uint_array = convert_to_dtype(self.array, np.uint16)
+        file_meta = FileMetaDataset()
+        # Main data elements
+        ds = Dataset()
+        ds.SOPClassUID = UID("1.2.840.10008.5.1.4.1.1.481.1")  # RT Image
+        ds.SOPInstanceUID = generate_uid()
+        ds.SeriesInstanceUID = generate_uid()
+        ds.Modality = "RTIMAGE"
+        ds.ConversionType = "WSD"
+        ds.PatientName = "Lutz^Test Tool"
+        ds.PatientID = "Someone Important"
+        ds.SamplesPerPixel = 1
+        ds.PhotometricInterpretation = "MONOCHROME2"
+        ds.Rows = self.array.shape[0]
+        ds.Columns = self.array.shape[1]
+        ds.BitsAllocated = 16
+        ds.BitsStored = 16
+        ds.HighBit = 15
+        ds.PixelRepresentation = 0
+        ds.ImagePlanePixelSpacing = [1 / self.dpmm, 1 / self.dpmm]
+        ds.RadiationMachineSAD = "1000.0"
+        ds.RTImageSID = "1000"
+        ds.PrimaryDosimeterUnit = "MU"
+        ds.GantryAngle = f"{iec_g:.2f}"
+        ds.BeamLimitingDeviceAngle = f"{iec_c:.2f}"
+        ds.PatientSupportAngle = f"{iec_p:.2f}"
+        ds.PixelData = uint_array
+
+        ds.file_meta = file_meta
+        ds.is_implicit_VR = True
+        ds.is_little_endian = True
+        return ds
+
+    def save_as(self, file: str | Path, format: str | None = None) -> None:
+        """Save the image to a NORMAL format. PNG is highly suggested. Accepts any format supported by Pillow.
+        Ironically, an equivalent PNG image (w/ metadata) is ~50% smaller than an .xim image.
+
+        .. warning::
+
+            Any format other than PNG will not include the properties included in the .xim image!
+
+        Parameters
+        ----------
+        file
+            The file to save the image to. E.g. my_xim.png
+        format
+            The format to save the image as. Uses the Pillow logic, which will infer the format if the file name has one.
+        """
+        img = pImage.fromarray(self.array)
+        # we construct the custom PNG tags; it won't be included for tiff or jpeg, etc but it won't error it either.
+        metadata = PngInfo()
+        for prop, value in self.properties.items():
+            if isinstance(value, np.ndarray):
+                value = value.tolist()
+            if not isinstance(value, str):
+                value = json.dumps(value)
+            metadata.add_text(prop, value)
+        img.save(file, format=format, pnginfo=metadata)
+
+
+class DicomImage(BaseImage):
+    """An image from a DICOM RTImage file.
+
+    Attributes
+    ----------
+    metadata : pydicom Dataset
+        The dataset of the file as returned by pydicom without pixel data.
+    """
+
+    metadata: pydicom.FileDataset
+    _sid: float
+    _dpi: float
+    _sad: float
+
+    def __init__(
+        self,
+        path: str | Path | BytesIO | BufferedReader,
+        *,
+        dtype: np.dtype | None = None,
+        dpi: float = None,
+        sid: float = None,
+        sad: float = 1000,
+        raw_pixels: bool = False,
+    ):
+        """
+        Parameters
+        ----------
+        path : str, file-object
+            The path to the file or the data stream.
+        dtype : dtype, None, optional
+            The data type to cast the image data as. If None, will use whatever raw image format is.
+        dpi : int, float
+            The dots-per-inch of the image, defined at isocenter.
+
+            .. note:: If a DPI tag is found in the image, that value will override the parameter, otherwise this one
+                will be used.
+
+        sid : int, float
+            The Source-to-Image distance in mm.
+        sad : float
+            The Source-to-Axis distance in mm.
+        raw_pixels : bool
+            Whether to apply pixel intensity correction to the DICOM data.
+            Typically, Rescale Slope, Rescale Intercept, and other tags
+            are included and meant to be applied to the raw pixel data, which
+            is potentially compressed.
+            If True, no correction will be applied. This is typically used
+            for scenarios when you want to match behavior to older or different
+            software.
+        """
+        super().__init__(path)
+        self._sid = sid
+        self._dpi = dpi
+        self._sad = sad
+        # read the file once to get just the DICOM metadata
+        self.metadata = retrieve_dicom_file(path)
+        self._original_dtype = self.metadata.pixel_array.dtype
+        self._raw_pixels = raw_pixels
+        # read a second time to get pixel data
+        try:
+            path.seek(0)
+        except AttributeError:
+            pass
+        ds = retrieve_dicom_file(path)
+        if dtype is not None:
+            self.array = ds.pixel_array.astype(dtype)
+        else:
+            self.array = ds.pixel_array.copy()
+        # convert values to HU or CU
+        self.array = _rescale_dicom_values(self.array, ds, raw_pixels=raw_pixels)
+
+    @classmethod
+    def from_dataset(cls, dataset: Dataset):
+        """Create a DICOM image instance from a pydicom Dataset."""
+        stream = io.BytesIO()
+        dataset.save_as(stream)
+        return cls(path=stream)
+
+    def save(self, filename: str | Path) -> str | Path:
+        """Save the image instance back out to a .dcm file.
+
+        Parameters
+        ----------
+        filename : str, Path
+            The filename to save the DICOM file as.
+
+        Returns
+        -------
+        A string pointing to the new filename.
+        """
+        unscaled_array = _unscale_dicom_values(
+            self.array, self.metadata, self._raw_pixels
+        )
+        # if we will have bit overflows, stretch instead
+        max_is_too_high = (
+            unscaled_array.max() > get_dtype_info(self._original_dtype).max
+        )
+        min_is_too_low = unscaled_array.min() < get_dtype_info(self._original_dtype).min
+        if min_is_too_low or max_is_too_high:
+            warnings.warn(
+                "The pixel values of image were detected to be outside"
+                f"the range of {self._original_dtype} values and will be normalized to fit the original dtype. "
+                f"The maximum value will be the maximum value of the original datatype: ({get_dtype_info(self._original_dtype).max})."
+            )
+            unscaled_array = convert_to_dtype(unscaled_array, self._original_dtype)
+        if self._raw_pixels:
+            # for raw pixels, often the values are wacky; convert them to a normal range
+            # e.g. the range might be 0-1 for a float array. This will convert to the original dtype
+            # This prevents such arrays from being converted to only 0s and 1s for an int dtype.
+            unscaled_array = convert_to_dtype(unscaled_array, self._original_dtype)
+        self.metadata.PixelData = unscaled_array.astype(self._original_dtype).tobytes()
+        self.metadata.Columns = unscaled_array.shape[1]
+        self.metadata.Rows = unscaled_array.shape[0]
+        self.metadata.save_as(filename)
+        return filename
+
+    @property
+    def z_position(self) -> float:
+        """The z-position of the slice. Relevant for CT and MR images."""
+        return z_position(self.metadata)
+
+    @property
+    def slice_spacing(self) -> float:
+        """Determine the distance between slices. The spacing can be greater than the slice thickness (i.e. gaps).
+        Uses the absolute version as it can apparently be negative: https://dicom.innolitics.com/ciods/nm-image/nm-reconstruction/00180088
+
+        This attempts to use the slice spacing attr and if it doesn't exist, use the slice thickness attr
+        """
+
+        try:
+            return abs(self.metadata.SpacingBetweenSlices)
+        except AttributeError:
+            return self.metadata.SliceThickness
+
+    @property
+    def sid(self) -> float:
+        """The Source-to-Image in mm."""
+        try:
+            return float(self.metadata.RTImageSID)
+        except (AttributeError, ValueError, TypeError):
+            return self._sid
+
+    @property
+    def sad(self) -> float:
+        """The source to axis (iso) in mm"""
+        try:
+            return float(self.metadata.RadiationMachineSAD)
+        except (AttributeError, ValueError, TypeError):
+            return self._sad
+
+    @property
+    def dpi(self) -> float:
+        """The dots-per-inch of the image, defined at isocenter."""
+        try:
+            return self.dpmm * MM_PER_INCH
+        except Exception:
+            return self._dpi
+
+    @property
+    def dpmm(self) -> float:
+        """The Dots-per-mm of the image, defined at isocenter. E.g. if an EPID image is taken at 150cm SID,
+        the dpmm will scale back to 100cm."""
+        dpmm = None
+        for tag in ("PixelSpacing", "ImagePlanePixelSpacing"):
+            mmpd = self.metadata.get(tag)
+            if mmpd is not None:
+                dpmm = 1 / mmpd[0]
+                break
+        if dpmm is not None and self.sid is not None:
+            dpmm *= self.sid / self.sad
+        elif dpmm is None and self._dpi is not None:
+            dpmm = self._dpi / MM_PER_INCH
+        return dpmm
+
+    @property
+    def cax(self) -> Point:
+        """The position of the beam central axis. If no DICOM translation tags are found then the center is returned.
+        Uses this tag: https://dicom.innolitics.com/ciods/rt-beams-delivery-instruction/rt-beams-delivery-instruction/00741020/00741030/3002000d
+        """
+        try:
+            x = self.center.x - self.metadata.XRayImageReceptorTranslation[0]
+            y = self.center.y - self.metadata.XRayImageReceptorTranslation[1]
+        except (AttributeError, ValueError, TypeError):
+            return self.center
+        else:
+            return Point(x, y)
+
+
+class LinacDicomImage(DicomImage):
+    """DICOM image taken on a linac. Also allows passing of gantry/coll/couch values via the filename."""
+
+    gantry_keyword = "Gantry"
+    collimator_keyword = "Coll"
+    couch_keyword = "Couch"
+
+    _use_filenames: bool
+
+    def __init__(
+        self,
+        path: str | Path | BinaryIO,
+        use_filenames: bool = False,
+        axes_precision: int | None = None,
+        **kwargs,
+    ):
+        self._gantry = kwargs.pop("gantry", None)
+        self._coll = kwargs.pop("coll", None)
+        self._couch = kwargs.pop("couch", None)
+        self._axes_precision = axes_precision
+        super().__init__(path, **kwargs)
+        self._use_filenames = use_filenames
+
+    @property
+    def gantry_angle(self) -> float:
+        """Gantry angle of the irradiation."""
+        if self._gantry is not None:
+            g = self._gantry
+        else:
+            g = self._get_axis_value(self.gantry_keyword, "GantryAngle")
+        return wrap360(simple_round(g, self._axes_precision))
+
+    @property
+    def collimator_angle(self) -> float:
+        """Collimator angle of the irradiation."""
+        if self._coll is not None:
+            c = self._coll
+        else:
+            c = self._get_axis_value(self.collimator_keyword, "BeamLimitingDeviceAngle")
+        return wrap360(simple_round(c, self._axes_precision))
+
+    @property
+    def couch_angle(self) -> float:
+        """Couch angle of the irradiation."""
+        if self._couch is not None:
+            c = self._couch
+        else:
+            c = self._get_axis_value(self.couch_keyword, "PatientSupportAngle")
+        return wrap360(simple_round(c, self._axes_precision))
+
+    def _get_axis_value(self, axis_str: str, axis_dcm_attr: str) -> float:
+        """Retrieve the value of the axis. This will first look in the file name for the value.
+        If not in the filename then it will look in the DICOM metadata. If the value can be found in neither
+        then a value of 0 is assumed.
+
+        Parameters
+        ----------
+        axis_str : str
+            The string to look for in the filename.
+        axis_dcm_attr : str
+            The DICOM attribute that should contain the axis value.
+
+        Returns
+        -------
+        float
+        """
+        axis_found = False
+        if self._use_filenames:
+            filename = osp.basename(self.path)
+            # see if the keyword is in the filename
+            keyword_in_filename = axis_str.lower() in filename.lower()
+            # if it's not there, then assume it's zero
+            if not keyword_in_filename:
+                axis = 0
+                axis_found = True
+            # if it is, then make sure it follows the naming convention of <axis###>
+            else:
+                match = re.search(rf"(?<={axis_str.lower()})\d+", filename.lower())
+                if match is None:
+                    raise ValueError(
+                        f"The filename contains '{axis_str}' but could not read a number following it. Use the format '...{axis_str}<#>...'"
+                    )
+                else:
+                    axis = float(match.group())
+                    axis_found = True
+        # try to interpret from DICOM data
+        if not axis_found:
+            try:
+                axis = float(getattr(self.metadata, axis_dcm_attr))
+            except AttributeError:
+                axis = 0
+        return axis
+
+
+class FileImage(BaseImage):
+    """An image from a "regular" file (.tif, .jpg, .bmp).
+
+    Attributes
+    ----------
+    info : dict
+        The info dictionary as generated by Pillow.
+    sid : float
+        The SID value as passed in upon construction.
+    """
+
+    def __init__(
+        self,
+        path: str | Path | BinaryIO,
+        *,
+        dpi: float | None = None,
+        sid: float | None = None,
+        dtype: np.dtype | None = None,
+    ):
+        """
+        Parameters
+        ----------
+        path : str, file-object
+            The path to the file or a data stream.
+        dpi : int, float
+            The dots-per-inch of the image, defined at isocenter.
+
+            .. note:: If a DPI tag is found in the image, that value will override the parameter, otherwise this one
+                will be used.
+        sid : int, float
+            The Source-to-Image distance in mm.
+        dtype : numpy.dtype
+            The data type to cast the array as. If None, will use the datatype stored in the file.
+            If the file is multi-channel (e.g. RGB), it will be converted to int32
+        """
+        super().__init__(path)
+        pil_image = pImage.open(path)
+        # convert from multichannel if need be
+        if len(pil_image.getbands()) > 1:
+            pil_image = pil_image.convert(
+                "I"
+            )  # int32; uint16 preferred but not reliable using PIL
+        self.info = pil_image.info
+        try:  # tiff tags
+            self.tags = {TAGS[key]: pil_image.tag_v2[key] for key in pil_image.tag_v2}
+        except AttributeError:
+            pass
+        self.array = np.array(pil_image, dtype=dtype)
+        self._dpi = dpi
+        self.sid = sid
+
+    @property
+    def dpi(self) -> float | None:
+        """The dots-per-inch of the image, defined at isocenter."""
+        dpi = None
+        for key in ("dpi", "resolution"):
+            dpi = self.info.get(key)
+            if dpi is not None:
+                dpi = float(dpi[0])
+                if dpi < 3 and not self._dpi:
+                    raise ValueError(
+                        f"The DPI setting is abnormal or nonsensical. Got resolution of {dpi}. Pass in the dpi manually."
+                    )
+                if dpi < 3:
+                    dpi = None
+                break
+        if dpi is None:
+            dpi = self._dpi
+        if self.sid is not None and dpi is not None:
+            dpi *= self.sid / 1000
+        return dpi
+
+    @property
+    def dpmm(self) -> float | None:
+        """The Dots-per-mm of the image, defined at isocenter. E.g. if an EPID image is taken at 150cm SID,
+        the dpmm will scale back to 100cm."""
+        try:
+            return self.dpi / MM_PER_INCH
+        except TypeError:
+            return
+
+
+class ArrayImage(BaseImage):
+    """An image constructed solely from a numpy array."""
+
+    def __init__(
+        self,
+        array: np.ndarray,
+        *,
+        dpi: float = None,
+        sid: float = None,
+        dtype=None,
+    ):
+        """
+        Parameters
+        ----------
+        array : numpy.ndarray
+            The image array.
+        dpi : int, float
+            The dots-per-inch of the image, defined at isocenter.
+
+            .. note:: If a DPI tag is found in the image, that value will override the parameter, otherwise this one
+                will be used.
+        sid : int, float
+            The Source-to-Image distance in mm.
+        dtype : dtype, None, optional
+            The data type to cast the image data as. If None, will use whatever raw image format is.
+        """
+        if dtype is not None:
+            self.array = np.array(array, dtype=dtype)
+        else:
+            self.array = array
+        self._dpi = dpi
+        self.sid = sid
+        self.metrics = []
+        self.metric_values = {}
+
+    @property
+    def dpmm(self) -> float | None:
+        """The Dots-per-mm of the image, defined at isocenter. E.g. if an EPID image is taken at 150cm SID,
+        the dpmm will scale back to 100cm."""
+        try:
+            return self.dpi / MM_PER_INCH
+        except Exception:
+            return
+
+    @property
+    def dpi(self) -> float | None:
+        """The dots-per-inch of the image, defined at isocenter."""
+        dpi = None
+        if self._dpi is not None:
+            dpi = self._dpi
+            if self.sid is not None:
+                dpi *= self.sid / 1000
+        return dpi
+
+    def __sub__(self, other):
+        return ArrayImage(self.array - other.array)
+
+
+class LazyDicomImageStack:
+    _image_path_keys: list[Path]
+    metadatas: list[pydicom.Dataset]
+
+    def __init__(
+        self,
+        folder: str | Path | Sequence[str | Path],
+        dtype: np.dtype | None = None,
+        min_number: int = 39,
+        check_uid: bool = True,
+    ):
+        """Load a folder with DICOM CT images. This variant is more memory efficient than the standard DicomImageStack.
+
+        This is done by loading images from disk on the fly. This assumes all images remain on disk for the lifetime of the instance. This does not
+        need to be true for the original implementation.
+
+        See the documentation for DicomImageStack for parameter descriptions.
+        """
+        self.dtype = dtype
+        paths = []
+        # load in images in their received order
+        if isinstance(folder, (list, tuple)):
+            paths = folder
+        elif osp.isdir(folder):
+            for pdir, sdir, files in os.walk(folder):
+                for file in files:
+                    paths.append(osp.join(pdir, file))
+        # we only want to read the metadata once
+        # so we read it here and then filter and sort
+        metadatas, paths = self._get_path_metadatas(paths)
+
+        # check that at least 1 image was loaded
+        if len(paths) < 1:
+            raise FileNotFoundError(
+                f"No files were found in the specified location: {folder}"
+            )
+
+        # error checking
+        if check_uid:
+            most_common_uid = self._get_common_uid_imgs(metadatas, min_number)
+            metadatas = [m for m in metadatas if m.SeriesInstanceUID == most_common_uid]
+        # sort according to physical order
+        order = np.argsort([m.ImagePositionPatient[-1] for m in metadatas])
+        self.metadatas = [metadatas[i] for i in order]
+        self._image_path_keys = [paths[i] for i in order]
+
+    @classmethod
+    def from_zip(cls, zip_path: str | Path, dtype: np.dtype | None = None):
+        """Load a DICOM ZIP archive.
+
+        Parameters
+        ----------
+        zip_path : str
+            Path to the ZIP archive.
+        dtype : dtype, None, optional
+            The data type to cast the image data as. If None, will use whatever raw image format is.
+        """
+        with TemporaryZipDirectory(zip_path, delete=False) as tmpzip:
+            obj = cls(tmpzip, dtype)
+        return obj
+
+    def _get_common_uid_imgs(
+        self, metadata: list[pydicom.Dataset], min_number: int
+    ) -> pydicom.DataElement:
+        """Check that all the images are from the same study."""
+        most_common_uid = Counter(i.SeriesInstanceUID for i in metadata).most_common(1)[
+            0
+        ]
+        if most_common_uid[1] < min_number:
+            raise ValueError(
+                "The minimum number images from the same study were not found"
+            )
+        return most_common_uid[0]
+
+    def _get_path_metadatas(
+        self, paths: list[Path]
+    ) -> (list[pydicom.Dataset], list[Path]):
+        """Get the metadata for the images. This also filters out non-image files."""
+        metadata = []
+        matched_paths = []
+        for path in paths:
+            try:
+                ds = pydicom.dcmread(path, force=True, stop_before_pixels=True)
+                if "Image Storage" in ds.SOPClassUID.name:
+                    metadata.append(ds)
+                    matched_paths.append(path)
+            except (InvalidDicomError, AttributeError, MemoryError):
+                pass
+        return metadata, matched_paths
+
+    def side_view(self, axis: int) -> np.ndarray:
+        """Return the side view of the stack. E.g. if axis=0, return the maximum value along the 0th axis."""
+        return np.stack([i for i in self], axis=-1).max(axis=axis)
+
+    @cached_property
+    def metadata(self) -> pydicom.FileDataset:
+        """The metadata of the first image; shortcut attribute. Only attributes that are common throughout the stack should be used,
+        otherwise the individual image metadata should be used."""
+        return self[0].metadata
+
+    @cached_property
+    def slice_spacing(self) -> float:
+        """The slice spacing of the stack. Assumes all slices are equally spaced."""
+        return np.abs(
+            self.metadatas[0].ImagePositionPatient[-1]
+            - self.metadatas[1].ImagePositionPatient[-1]
+        )
+
+    def __getitem__(self, item: int) -> DicomImage:
+        return DicomImage(self._image_path_keys[item], dtype=self.dtype)
+
+    def __setitem__(self, key: int, value: DicomImage):
+        """Save the passed image to disk in place of the current image."""
+        current_path = self._image_path_keys[key]
+        value.save(current_path)
+
+    def __delitem__(self, key):
+        """Delete the image from the stack and OS."""
+        current_path = self._image_path_keys[key]
+        try:
+            os.remove(current_path)
+        except Exception:
+            pass
+        del self._image_path_keys[key]
+
+    def __len__(self):
+        return len(self._image_path_keys)
+
+
+class DicomImageStack(LazyDicomImageStack):
+    """A class that loads and holds a stack of DICOM images (e.g. a CT dataset). The class can take
+    a folder or zip file and will read CT images. The images must all be the same size. Supports
+    indexing to individual images.
+
+    Attributes
+    ----------
+    images : list
+        Holds instances of :class:`~pylinac.core.image.DicomImage`. Can be accessed via index;
+        i.e. self[0] == self.images[0].
+
+    Examples
+    --------
+    Load a folder of Dicom images
+    >>> from pylinac import image
+    >>> img_folder = r"folder/qa/cbct/june"
+    >>> dcm_stack = image.DicomImageStack(img_folder)  # loads and sorts the images
+    >>> dcm_stack.plot(3)  # plot the 3rd image
+
+    Load a zip archive
+    >>> img_folder_zip = r"archive/qa/cbct/june.zip"  # save space and zip your CBCTs
+    >>> dcm_stack = image.DicomImageStack.from_zip(img_folder_zip)
+
+    Load as a certain data type
+    >>> dcm_stack_uint32 = image.DicomImageStack(img_folder, dtype=np.uint32)
+    """
+
+    images: list[ImageLike]
+
+    def __init__(
+        self,
+        folder: str | Path,
+        dtype: np.dtype | None = None,
+        min_number: int = 39,
+        check_uid: bool = True,
+        raw_pixels: bool = False,
+    ):
+        """Load a folder with DICOM CT images.
+
+        Parameters
+        ----------
+        folder : str
+            Path to the folder.
+        dtype : dtype, None, optional
+            The data type to cast the image data as. If None, will use whatever raw image format is.
+        """
+        super().__init__(folder, dtype, min_number, check_uid)
+        self.images = [
+            DicomImage(path, dtype=dtype, raw_pixels=raw_pixels)
+            for path in self._image_path_keys
+        ]
+
+    @classmethod
+    def from_zip(cls, zip_path: str | Path, dtype: np.dtype | None = None, **kwargs):
+        """Load a DICOM ZIP archive.
+
+        Parameters
+        ----------
+        zip_path : str
+            Path to the ZIP archive.
+        dtype : dtype, None, optional
+            The data type to cast the image data as. If None, will use whatever raw image format is.
+        """
+        with TemporaryZipDirectory(zip_path) as tmpzip:
+            obj = cls(tmpzip, dtype, **kwargs)
+        return obj
+
+    def plot_3view(self):
+        """Plot the stack in 3 views: axial, coronal, and sagittal."""
+        fig, axes = plt.subplots(1, 3)
+        names = ("Coronal", "Sagittal", "Axial")
+        for idx, (ax, name) in enumerate(zip(axes, names)):
+            arry = self.side_view(idx)
+            ax.imshow(arry, cmap="gray", aspect="equal")
+            ax.set_title(name)
+        plt.show()
+
+    def roll(self, direction: str, amount: int):
+        for img in self.images:
+            img.roll(direction, amount)
+
+    def __getitem__(self, item) -> DicomImage:
+        return self.images[item]
+
+    def __setitem__(self, key, value: DicomImage):
+        self.images[key] = value
+
+    def __delitem__(self, key):
+        """Delete the image from the stack."""
+        del self.images[key]
+
+    def __len__(self):
+        return len(self.images)
+
+
+class NMImageStack:
+    """A class of frames of a nuclear medicine image.
+    A single image can have N frames. For our purposes, we
+    can treat this as a stack of images."""
+
+    metadata: Dataset
+    path: str | Path
+    frames: list[DicomImage]
+
+    def __init__(self, path: str | Path):
+        """Load a single NM image with N frames."""
+        self.path = path
+        self.frames = []
+        ds = pydicom.dcmread(path, force=True, stop_before_pixels=True)
+        if ds.Modality != "NM":
+            raise TypeError("The file is not a NM image")
+        self.metadata = ds
+        full_ds = pydicom.dcmread(path, force=True)
+        for i in range(full_ds.NumberOfFrames):
+            full_array = full_ds.pixel_array
+            if full_array.ndim == 2:
+                array = full_array
+            else:
+                array = full_array[i]
+            img = DicomImage(self.path)
+            img.array = array
+            self.frames.append(img)
+
+    def as_3d_array(self) -> np.ndarray:
+        """Return the frames as a 3D array."""
+        return np.stack([i.array for i in self.frames], axis=0)
+
+    def __len__(self):
+        return len(self.frames)
+
+
+def tiff_to_dicom(
+    tiff_file: str | Path | BytesIO,
+    sid: float,
+    gantry: float,
+    coll: float,
+    couch: float,
+    dpi: float | None = None,
+) -> Dataset:
+    """Converts a TIFF file into a **simplistic** DICOM file. Not meant to be a full-fledged tool. Used for conversion so that tools that are traditionally oriented
+    towards DICOM have a path to accept TIFF. Currently used to convert files for WL.
+
+    .. note::
+
+        This will convert the image into an uint16 datatype to match the native EPID datatype.
+
+    Parameters
+    ----------
+    tiff_file
+        The TIFF file to be converted.
+    sid
+        The Source-to-Image distance in mm.
+    dpi
+        The dots-per-inch value of the TIFF image.
+    gantry
+        The gantry value that the image was taken at.
+    coll
+        The collimator value that the image was taken at.
+    couch
+        The couch value that the image was taken at.
+    """
+    tiff_img = FileImage(tiff_file, dpi=dpi, sid=sid)
+    if not tiff_img.dpmm:
+        raise ValueError(
+            "Automatic detection of `dpi` failed. A `dpi` value must be passed to the constructor."
+        )
+    uint_array = convert_to_dtype(tiff_img.array, np.uint16)
+    mm_pixel = 25.4 / tiff_img.dpi
+    file_meta = FileMetaDataset()
+    # Main data elements
+    ds = Dataset()
+    ds.SOPClassUID = UID("1.2.840.10008.5.1.4.1.1.481.1")
+    ds.SOPInstanceUID = generate_uid()
+    ds.SeriesInstanceUID = generate_uid()
+    ds.Modality = "RTIMAGE"
+    ds.ConversionType = "WSD"
+    ds.PatientName = "Lutz^Test Tool"
+    ds.PatientID = "Someone Important"
+    ds.SamplesPerPixel = 1
+    ds.PhotometricInterpretation = "MONOCHROME2"
+    ds.Rows = tiff_img.shape[0]
+    ds.Columns = tiff_img.shape[1]
+    ds.BitsAllocated = 16
+    ds.BitsStored = 16
+    ds.HighBit = 15
+    ds.PixelRepresentation = 0
+    ds.ImagePlanePixelSpacing = [mm_pixel, mm_pixel]
+    ds.RadiationMachineSAD = "1000.0"
+    ds.RTImageSID = sid
+    ds.PrimaryDosimeterUnit = "MU"
+    ds.GantryAngle = str(gantry)
+    ds.BeamLimitingDeviceAngle = str(coll)
+    ds.PatientSupportAngle = str(couch)
+    ds.PixelData = uint_array
+
+    ds.file_meta = file_meta
+    ds.is_implicit_VR = True
+    ds.is_little_endian = True
+    return ds
+
+
+def gamma_2d(
+    reference: np.ndarray,
+    evaluation: np.ndarray,
+    dose_to_agreement: float = 1,
+    distance_to_agreement: int = 1,
+    gamma_cap_value: float = 2,
+    global_dose: bool = True,
+    dose_threshold: float = 5,
+    fill_value: float = np.nan,
+) -> np.ndarray:
+    """Compute a 2D gamma of two 2D numpy arrays. This does NOT do size or spatial resolution checking.
+    It performs an element-by-element evaluation. It is the responsibility
+    of the caller to ensure the reference and evaluation have comparable spatial resolution.
+
+    The algorithm follows Table I of D. Low's 2004 paper: Evaluation of the gamma dose distribution comparison method: https://aapm.onlinelibrary.wiley.com/doi/epdf/10.1118/1.1598711
+
+    This is similar to the gamma_1d function for profiles, except we must search a 2D grid around the reference point.
+
+    Parameters
+    ----------
+    reference
+        The reference 2D array.
+    evaluation
+        The evaluation 2D array.
+    dose_to_agreement
+        The dose to agreement in %. E.g. 1 is 1% of global reference max dose.
+    distance_to_agreement
+        The distance to agreement in **elements**. E.g. if the value is 4 this means 4 elements from the reference point under calculation.
+        Must be >0
+    gamma_cap_value
+        The value to cap the gamma at. E.g. a gamma of 5.3 will get capped to 2. Useful for displaying data with a consistent range.
+    global_dose
+        Whether to evaluate the dose to agreement threshold based on the global max or the dose point under evaluation.
+    dose_threshold
+        The dose threshold as a number between 0 and 100 of the % of max dose under which a gamma is not calculated.
+        This is not affected by the global/local dose normalization and the threshold value is evaluated against the global max dose, period.
+    fill_value
+        The value to give pixels that were not calculated because they were under the dose threshold. Default
+        is NaN, but another option would be 0. If NaN, allows the user to calculate mean/median gamma over just the
+        evaluated portion and not be skewed by 0's that should not be considered.
+    """
+    if reference.ndim != 2 or evaluation.ndim != 2:
+        raise ValueError(
+            f"Reference and evaluation arrays must be 2D. Got reference: {reference.ndim} and evaluation: {evaluation.ndim}"
+        )
+    threshold = reference.max() / 100 * dose_threshold
+    # convert dose to agreement to % of global max; ignored later if local dose
+    dose_ta = dose_to_agreement / 100 * reference.max()
+    # pad eval array on both edges so our search does not go out of bounds
+    eval_padded = np.pad(evaluation, distance_to_agreement, mode="edge")
+    # iterate over each reference element, computing distance value and dose value
+    gamma = np.zeros(reference.shape)
+    for row_idx, row in enumerate(reference):
+        for col_idx, ref_point in enumerate(row):
+            # skip if below dose threshold
+            if ref_point < threshold:
+                gamma[row_idx, col_idx] = fill_value
+                continue
+            # use scikit-image to compute the indices of a disk around the reference point
+            # we can then compute gamma over the eval points at these indices
+            # unlike the 1D computation, we have to search at an index offset by the distance to agreement
+            # we use DTA+1 in disk because it looks like the results are exclusive of edges.
+            # https://scikit-image.org/docs/stable/api/skimage.draw.html#disk
+            rs, cs = disk(
+                (row_idx + distance_to_agreement, col_idx + distance_to_agreement),
+                distance_to_agreement + 1,
+            )
+
+            capital_gammas = []
+            for r, c in zip(rs, cs):
+                eval_point = eval_padded[r, c]
+                # for the distance, we compare the ref row/col to the eval padded matrix
+                # but remember the padded array is padded by DTA, so to compare distances, we
+                # have to cancel the offset we used for dose purposes.
+                dist = math.dist(
+                    (row_idx, col_idx),
+                    (r - distance_to_agreement, c - distance_to_agreement),
+                )
+                dose = eval_point - ref_point
+                if not global_dose:
+                    dose_ta = dose_to_agreement / 100 * ref_point
+                capital_gamma = math.sqrt(
+                    dist**2 / distance_to_agreement**2 + dose**2 / dose_ta**2
+                )
+                capital_gammas.append(capital_gamma)
+            gamma[row_idx, col_idx] = min(np.nanmin(capital_gammas), gamma_cap_value)
+    return np.asarray(gamma)
+
+
+def z_position(metadata: pydicom.Dataset) -> float:
+    """The 'z-position' of the image. Relevant for CT and MR images."""
+    try:
+        return metadata.ImagePositionPatient[-1]
+    except AttributeError:
+        return metadata.SliceLocation
```

### Comparing `manteia_qa_pylinac-1.0.0/pylinac/core/image_generator/simulators.py` & `manteia_qa_pylinac-1.1.0/pylinac/core/image_generator/simulators.py`

 * *Ordering differences only*

 * *Files 22% similar despite different names*

```diff
@@ -1,312 +1,312 @@
-from __future__ import annotations
-
-from abc import ABC
-
-import numpy as np
-from pydicom.dataset import Dataset, FileMetaDataset
-from pydicom.uid import UID, generate_uid
-
-from .layers import Layer
-
-
-class Simulator(ABC):
-    """Abstract class for an image simulator"""
-
-    pixel_size: float
-    shape: (int, int)
-    image: np.ndarray
-
-    def __init__(self, sid: float = 1500):
-        """
-
-        Parameters
-        ----------
-        sid
-            Source to image distance in mm.
-        """
-        self.image = np.zeros(self.shape, np.uint16)
-        self.sid = sid
-        self.mag_factor = sid / 1000
-
-    def add_layer(self, layer: Layer) -> None:
-        """Add a layer to the image"""
-        self.image = layer.apply(self.image, self.pixel_size, self.mag_factor)
-
-    def as_dicom(
-        self,
-        gantry_angle: float = 0.0,
-        coll_angle: float = 0.0,
-        table_angle: float = 0.0,
-    ) -> Dataset:
-        """Create and return a pydicom Dataset. I.e. create a pseudo-DICOM image."""
-        raise NotImplementedError(
-            "This method has not been implemented for this simulator. Overload the method of your simulator."
-        )
-
-    def generate_dicom(
-        self,
-        file_out_name: str,
-        gantry_angle: float = 0.0,
-        coll_angle: float = 0.0,
-        table_angle: float = 0.0,
-    ) -> None:
-        ds = self.as_dicom(gantry_angle, coll_angle, table_angle)
-        ds.save_as(file_out_name, write_like_original=False)
-
-
-class AS500Image(Simulator):
-    """Simulates an AS500 EPID image."""
-
-    pixel_size: float = 0.78125
-    shape: (int, int) = (384, 512)
-
-    def as_dicom(
-        self,
-        gantry_angle: float = 0.0,
-        coll_angle: float = 0.0,
-        table_angle: float = 0.0,
-    ) -> Dataset:
-        # make image look like an EPID with flipped data (dose->low)
-        flipped_image = -self.image + self.image.max() + self.image.min()
-
-        file_meta = FileMetaDataset()
-        # Main data elements
-        ds = Dataset()
-        ds.ImageType = ["DERIVED", "SECONDARY", "PORTAL"]
-        ds.SOPClassUID = UID("1.2.840.10008.5.1.4.1.1.481.1")
-        ds.SOPInstanceUID = generate_uid()
-        ds.SeriesInstanceUID = generate_uid()
-        ds.StudyDate = "20150212"
-        ds.ContentDate = "20150212"
-        ds.StudyTime = "124120"
-        ds.ContentTime = "124120"
-        ds.AccessionNumber = ""
-        ds.Modality = "RTIMAGE"
-        ds.ConversionType = "WSD"
-        ds.Manufacturer = "IMPAC Medical Systems, Inc."
-        ds.ReferringPhysicianName = ""
-        ds.StudyDescription = "QA"
-        ds.SeriesDescription = "D + Gantry_0"
-        ds.PhysiciansOfRecord = "Awesome Physician"
-        ds.OperatorsName = ""
-        ds.ManufacturerModelName = "MOSAIQ"
-        ds.PatientName = "Lutz^Test Tool"
-        ds.PatientID = "zzzBAC_Lutz"
-        ds.PatientBirthDate = ""
-        ds.SoftwareVersions = "2.41.01J0"
-        ds.StudyInstanceUID = "1.2.840.113854.141883099300381770008774160544352783139"
-        ds.SeriesInstanceUID = (
-            "1.2.840.113854.141883099300381770008774160544352783139.1"
-        )
-        ds.StudyID = "348469"
-        ds.SeriesNumber = "4597199"
-        ds.InstanceNumber = "0"
-        ds.PatientOrientation = ""
-        ds.PositionReferenceIndicator = ""
-        ds.SamplesPerPixel = 1
-        ds.PhotometricInterpretation = "MONOCHROME2"
-        ds.Rows = self.image.shape[0]
-        ds.Columns = self.image.shape[1]
-        ds.BitsAllocated = 16
-        ds.BitsStored = 16
-        ds.HighBit = 15
-        ds.PixelRepresentation = 0
-        ds.RTImageLabel = "D"
-        ds.RTImagePlane = "NORMAL"
-        ds.XRayImageReceptorAngle = "0.0"
-        ds.ImagePlanePixelSpacing = [self.pixel_size, self.pixel_size]
-        ds.RTImagePosition = [-200.70400, 150.52800]
-        ds.RadiationMachineSAD = "1000.0"
-        ds.RTImageSID = self.sid
-        ds.PrimaryDosimeterUnit = "MU"
-        ds.GantryAngle = str(gantry_angle)
-        ds.BeamLimitingDeviceAngle = str(coll_angle)
-        ds.PatientSupportAngle = str(table_angle)
-        ds.PixelData = flipped_image  # XXX Array of 393216 bytes excluded
-
-        ds.file_meta = file_meta
-        ds.is_implicit_VR = True
-        ds.is_little_endian = True
-        return ds
-
-
-class AS1000Image(Simulator):
-    """Simulates an AS1000 EPID image."""
-
-    pixel_size: float = 0.390625
-    shape: (int, int) = (768, 1024)
-
-    def as_dicom(
-        self,
-        gantry_angle: float = 0.0,
-        coll_angle: float = 0.0,
-        table_angle: float = 0.0,
-    ) -> Dataset:
-        # make image look like an EPID with flipped data (dose->low)
-        flipped_image = -self.image + self.image.max() + self.image.min()
-
-        # File meta info data elements
-        file_meta = FileMetaDataset()
-
-        # Main data elements
-        ds = Dataset()
-        ds.ImageType = ["DERIVED", "SECONDARY", "PORTAL"]
-        ds.SOPClassUID = UID("1.2.840.10008.5.1.4.1.1.481.1")
-        ds.SOPInstanceUID = generate_uid()
-        ds.SeriesInstanceUID = generate_uid()
-        ds.StudyDate = "20140819"
-        ds.ContentDate = "20140819"
-        ds.StudyTime = "130944"
-        ds.ContentTime = "130944"
-        ds.AccessionNumber = ""
-        ds.Modality = "RTIMAGE"
-        ds.ConversionType = "WSD"
-        ds.Manufacturer = "IMPAC Medical Systems, Inc."
-        ds.ReferringPhysicianName = ""
-        ds.StudyDescription = "QA"
-        ds.SeriesDescription = "Q + Couch_270"
-        ds.PhysiciansOfRecord = "I am king"
-        ds.OperatorsName = ""
-        ds.ManufacturerModelName = "MOSAIQ"
-        ds.PatientName = "Albert Einstein"
-        ds.PatientID = "abc123"
-        ds.PatientBirthDate = ""
-        ds.SoftwareVersions = "2.41.01J0"
-        ds.StudyInstanceUID = "1.2.840.113854.323870129946883845737820671794195198978"
-        ds.SeriesInstanceUID = (
-            "1.2.840.113854.323870129946883845737820671794195198978.1"
-        )
-        ds.StudyID = "348469"
-        ds.SeriesNumber = "4290463"
-        ds.InstanceNumber = "0"
-        ds.PatientOrientation = ""
-        ds.PositionReferenceIndicator = ""
-        ds.SamplesPerPixel = 1
-        ds.PhotometricInterpretation = "MONOCHROME2"
-        ds.Rows = self.shape[0]
-        ds.Columns = self.shape[1]
-        ds.BitsAllocated = 16
-        ds.BitsStored = 16
-        ds.HighBit = 15
-        ds.PixelRepresentation = 0
-        ds.RTImageLabel = "Q"
-        ds.RTImagePlane = "NORMAL"
-        ds.XRayImageReceptorAngle = "0.0"
-        ds.ImagePlanePixelSpacing = [self.pixel_size, self.pixel_size]
-        ds.RTImagePosition = [-200.70400, 150.523400]
-        ds.RadiationMachineSAD = "1000.0"
-        ds.RTImageSID = self.sid
-        ds.PrimaryDosimeterUnit = "MU"
-        ds.GantryAngle = str(gantry_angle)
-        ds.BeamLimitingDeviceAngle = str(coll_angle)
-        ds.PatientSupportAngle = str(table_angle)
-        ds.PixelData = flipped_image  # XXX Array of 1572864 bytes excluded
-
-        ds.file_meta = file_meta
-        ds.is_implicit_VR = True
-        ds.is_little_endian = True
-        return ds
-
-
-class AS1200Image(Simulator):
-    """Simulates an AS1200 EPID image."""
-
-    pixel_size: float = 0.336
-    shape: (int, int) = (1280, 1280)
-
-    def as_dicom(
-        self,
-        gantry_angle: float = 0.0,
-        coll_angle: float = 0.0,
-        table_angle: float = 0.0,
-    ) -> Dataset:
-        file_meta = FileMetaDataset()
-        file_meta.FileMetaInformationGroupLength = 196
-        file_meta.FileMetaInformationVersion = b"\x00\x01"
-        file_meta.MediaStorageSOPClassUID = "1.2.840.10008.5.1.4.1.1.481.1"
-        file_meta.MediaStorageSOPInstanceUID = (
-            "1.2.246.352.64.1.5468686515961995030.4457606667843517571"
-        )
-        file_meta.TransferSyntaxUID = "1.2.840.10008.1.2"
-        file_meta.ImplementationClassUID = "1.2.246.352.70.2.1.120.1"
-        file_meta.ImplementationVersionName = "MergeCOM3_410"
-
-        # Main data elements
-        ds = Dataset()
-        ds.SpecificCharacterSet = "ISO_IR 100"
-        ds.ImageType = ["ORIGINAL", "PRIMARY", "PORTAL"]
-        ds.InstanceCreationDate = "20161230"
-        ds.InstanceCreationTime = "215510"
-        ds.SOPClassUID = UID("1.2.840.10008.5.1.4.1.1.481.1")
-        ds.SOPInstanceUID = generate_uid()
-        ds.SeriesInstanceUID = generate_uid()
-        ds.StudyDate = "20161230"
-        ds.ContentDate = "20161230"
-        ds.StudyTime = "215441.936"
-        ds.ContentTime = "215441.936"
-        ds.AccessionNumber = ""
-        ds.Modality = "RTIMAGE"
-        ds.ConversionType = ""
-        ds.Manufacturer = "Varian Medical Systems"
-        ds.ReferringPhysicianName = ""
-        ds.StationName = "NDS-WKS-SN9999"
-        ds.OperatorsName = "King Kong"
-        ds.ManufacturerModelName = "VMS.XI.Service"
-        ds.PatientName = "Grace Hopper"
-        ds.PatientID = "VMS.XI.Service"
-        ds.PatientBirthDate = "19000101"
-        ds.PatientBirthTime = "000000"
-        ds.PatientSex = ""
-        ds.SoftwareVersions = "2.5.13.2"
-        ds.StudyInstanceUID = "1.2.246.352.64.4.5644626269434644263.1905029945372990626"
-        ds.SeriesInstanceUID = (
-            "1.2.246.352.64.2.5508761605912087323.11665958260371685307"
-        )
-        ds.StudyID = "fdd794f2-8520-4c4a-aecc-e4446c1730ff"
-        ds.SeriesNumber = None
-        ds.AcquisitionNumber = "739774555"
-        ds.InstanceNumber = "1"
-        ds.PatientOrientation = ""
-        ds.FrameOfReferenceUID = (
-            "1.2.246.352.64.3.4714322356925391886.9391210174715030407"
-        )
-        ds.PositionReferenceIndicator = ""
-        ds.SamplesPerPixel = 1
-        ds.PhotometricInterpretation = "MONOCHROME1"
-        ds.PlanarConfiguration = 0
-        ds.Rows = self.shape[0]
-        ds.Columns = self.shape[1]
-        ds.BitsAllocated = 16
-        ds.BitsStored = 16
-        ds.HighBit = 15
-        ds.PixelRepresentation = 0
-        ds.WindowCenter = "32767.0"
-        ds.WindowWidth = "65535.0"
-        ds.RescaleIntercept = "0.0"
-        ds.RescaleSlope = "1.0"
-        ds.RescaleType = "US"
-        ds.RTImageLabel = "MV_180"
-        ds.RTImageDescription = ""
-        ds.ReportedValuesOrigin = "ACTUAL"
-        ds.RTImagePlane = "NORMAL"
-        ds.XRayImageReceptorTranslation = [0.00, 0.00, 1000 - self.sid]
-        ds.XRayImageReceptorAngle = "0.0"
-        ds.RTImageOrientation = [1, 0, 0, 0, -1, 0]
-        ds.ImagePlanePixelSpacing = [self.pixel_size, self.pixel_size]
-        ds.RTImagePosition = [-214.872, 214.872]
-        ds.RadiationMachineName = "TrueBeam from Hell"
-        ds.RadiationMachineSAD = "1000.0"
-        ds.RTImageSID = self.sid
-        ds.PrimaryDosimeterUnit = "MU"
-        ds.GantryAngle = str(gantry_angle)
-        ds.BeamLimitingDeviceAngle = str(coll_angle)
-        ds.PatientSupportAngle = str(table_angle)
-        ds.TableTopVerticalPosition = "-24.59382842824"
-        ds.TableTopLongitudinalPosition = "200.813502948597"
-        ds.TableTopLateralPosition = "3.00246706215532"
-        ds.PixelData = self.image  # XXX Array of 3276800 bytes excluded
-
-        ds.file_meta = file_meta
-        ds.is_implicit_VR = True
-        ds.is_little_endian = True
-        return ds
+from __future__ import annotations
+
+from abc import ABC
+
+import numpy as np
+from pydicom.dataset import Dataset, FileMetaDataset
+from pydicom.uid import UID, generate_uid
+
+from .layers import Layer
+
+
+class Simulator(ABC):
+    """Abstract class for an image simulator"""
+
+    pixel_size: float
+    shape: (int, int)
+    image: np.ndarray
+
+    def __init__(self, sid: float = 1500):
+        """
+
+        Parameters
+        ----------
+        sid
+            Source to image distance in mm.
+        """
+        self.image = np.zeros(self.shape, np.uint16)
+        self.sid = sid
+        self.mag_factor = sid / 1000
+
+    def add_layer(self, layer: Layer) -> None:
+        """Add a layer to the image"""
+        self.image = layer.apply(self.image, self.pixel_size, self.mag_factor)
+
+    def as_dicom(
+        self,
+        gantry_angle: float = 0.0,
+        coll_angle: float = 0.0,
+        table_angle: float = 0.0,
+    ) -> Dataset:
+        """Create and return a pydicom Dataset. I.e. create a pseudo-DICOM image."""
+        raise NotImplementedError(
+            "This method has not been implemented for this simulator. Overload the method of your simulator."
+        )
+
+    def generate_dicom(
+        self,
+        file_out_name: str,
+        gantry_angle: float = 0.0,
+        coll_angle: float = 0.0,
+        table_angle: float = 0.0,
+    ) -> None:
+        ds = self.as_dicom(gantry_angle, coll_angle, table_angle)
+        ds.save_as(file_out_name, write_like_original=False)
+
+
+class AS500Image(Simulator):
+    """Simulates an AS500 EPID image."""
+
+    pixel_size: float = 0.78125
+    shape: (int, int) = (384, 512)
+
+    def as_dicom(
+        self,
+        gantry_angle: float = 0.0,
+        coll_angle: float = 0.0,
+        table_angle: float = 0.0,
+    ) -> Dataset:
+        # make image look like an EPID with flipped data (dose->low)
+        flipped_image = -self.image + self.image.max() + self.image.min()
+
+        file_meta = FileMetaDataset()
+        # Main data elements
+        ds = Dataset()
+        ds.ImageType = ["DERIVED", "SECONDARY", "PORTAL"]
+        ds.SOPClassUID = UID("1.2.840.10008.5.1.4.1.1.481.1")
+        ds.SOPInstanceUID = generate_uid()
+        ds.SeriesInstanceUID = generate_uid()
+        ds.StudyDate = "20150212"
+        ds.ContentDate = "20150212"
+        ds.StudyTime = "124120"
+        ds.ContentTime = "124120"
+        ds.AccessionNumber = ""
+        ds.Modality = "RTIMAGE"
+        ds.ConversionType = "WSD"
+        ds.Manufacturer = "IMPAC Medical Systems, Inc."
+        ds.ReferringPhysicianName = ""
+        ds.StudyDescription = "QA"
+        ds.SeriesDescription = "D + Gantry_0"
+        ds.PhysiciansOfRecord = "Awesome Physician"
+        ds.OperatorsName = ""
+        ds.ManufacturerModelName = "MOSAIQ"
+        ds.PatientName = "Lutz^Test Tool"
+        ds.PatientID = "zzzBAC_Lutz"
+        ds.PatientBirthDate = ""
+        ds.SoftwareVersions = "2.41.01J0"
+        ds.StudyInstanceUID = "1.2.840.113854.141883099300381770008774160544352783139"
+        ds.SeriesInstanceUID = (
+            "1.2.840.113854.141883099300381770008774160544352783139.1"
+        )
+        ds.StudyID = "348469"
+        ds.SeriesNumber = "4597199"
+        ds.InstanceNumber = "0"
+        ds.PatientOrientation = ""
+        ds.PositionReferenceIndicator = ""
+        ds.SamplesPerPixel = 1
+        ds.PhotometricInterpretation = "MONOCHROME2"
+        ds.Rows = self.image.shape[0]
+        ds.Columns = self.image.shape[1]
+        ds.BitsAllocated = 16
+        ds.BitsStored = 16
+        ds.HighBit = 15
+        ds.PixelRepresentation = 0
+        ds.RTImageLabel = "D"
+        ds.RTImagePlane = "NORMAL"
+        ds.XRayImageReceptorAngle = "0.0"
+        ds.ImagePlanePixelSpacing = [self.pixel_size, self.pixel_size]
+        ds.RTImagePosition = [-200.70400, 150.52800]
+        ds.RadiationMachineSAD = "1000.0"
+        ds.RTImageSID = self.sid
+        ds.PrimaryDosimeterUnit = "MU"
+        ds.GantryAngle = str(gantry_angle)
+        ds.BeamLimitingDeviceAngle = str(coll_angle)
+        ds.PatientSupportAngle = str(table_angle)
+        ds.PixelData = flipped_image  # XXX Array of 393216 bytes excluded
+
+        ds.file_meta = file_meta
+        ds.is_implicit_VR = True
+        ds.is_little_endian = True
+        return ds
+
+
+class AS1000Image(Simulator):
+    """Simulates an AS1000 EPID image."""
+
+    pixel_size: float = 0.390625
+    shape: (int, int) = (768, 1024)
+
+    def as_dicom(
+        self,
+        gantry_angle: float = 0.0,
+        coll_angle: float = 0.0,
+        table_angle: float = 0.0,
+    ) -> Dataset:
+        # make image look like an EPID with flipped data (dose->low)
+        flipped_image = -self.image + self.image.max() + self.image.min()
+
+        # File meta info data elements
+        file_meta = FileMetaDataset()
+
+        # Main data elements
+        ds = Dataset()
+        ds.ImageType = ["DERIVED", "SECONDARY", "PORTAL"]
+        ds.SOPClassUID = UID("1.2.840.10008.5.1.4.1.1.481.1")
+        ds.SOPInstanceUID = generate_uid()
+        ds.SeriesInstanceUID = generate_uid()
+        ds.StudyDate = "20140819"
+        ds.ContentDate = "20140819"
+        ds.StudyTime = "130944"
+        ds.ContentTime = "130944"
+        ds.AccessionNumber = ""
+        ds.Modality = "RTIMAGE"
+        ds.ConversionType = "WSD"
+        ds.Manufacturer = "IMPAC Medical Systems, Inc."
+        ds.ReferringPhysicianName = ""
+        ds.StudyDescription = "QA"
+        ds.SeriesDescription = "Q + Couch_270"
+        ds.PhysiciansOfRecord = "I am king"
+        ds.OperatorsName = ""
+        ds.ManufacturerModelName = "MOSAIQ"
+        ds.PatientName = "Albert Einstein"
+        ds.PatientID = "abc123"
+        ds.PatientBirthDate = ""
+        ds.SoftwareVersions = "2.41.01J0"
+        ds.StudyInstanceUID = "1.2.840.113854.323870129946883845737820671794195198978"
+        ds.SeriesInstanceUID = (
+            "1.2.840.113854.323870129946883845737820671794195198978.1"
+        )
+        ds.StudyID = "348469"
+        ds.SeriesNumber = "4290463"
+        ds.InstanceNumber = "0"
+        ds.PatientOrientation = ""
+        ds.PositionReferenceIndicator = ""
+        ds.SamplesPerPixel = 1
+        ds.PhotometricInterpretation = "MONOCHROME2"
+        ds.Rows = self.shape[0]
+        ds.Columns = self.shape[1]
+        ds.BitsAllocated = 16
+        ds.BitsStored = 16
+        ds.HighBit = 15
+        ds.PixelRepresentation = 0
+        ds.RTImageLabel = "Q"
+        ds.RTImagePlane = "NORMAL"
+        ds.XRayImageReceptorAngle = "0.0"
+        ds.ImagePlanePixelSpacing = [self.pixel_size, self.pixel_size]
+        ds.RTImagePosition = [-200.70400, 150.523400]
+        ds.RadiationMachineSAD = "1000.0"
+        ds.RTImageSID = self.sid
+        ds.PrimaryDosimeterUnit = "MU"
+        ds.GantryAngle = str(gantry_angle)
+        ds.BeamLimitingDeviceAngle = str(coll_angle)
+        ds.PatientSupportAngle = str(table_angle)
+        ds.PixelData = flipped_image  # XXX Array of 1572864 bytes excluded
+
+        ds.file_meta = file_meta
+        ds.is_implicit_VR = True
+        ds.is_little_endian = True
+        return ds
+
+
+class AS1200Image(Simulator):
+    """Simulates an AS1200 EPID image."""
+
+    pixel_size: float = 0.336
+    shape: (int, int) = (1280, 1280)
+
+    def as_dicom(
+        self,
+        gantry_angle: float = 0.0,
+        coll_angle: float = 0.0,
+        table_angle: float = 0.0,
+    ) -> Dataset:
+        file_meta = FileMetaDataset()
+        file_meta.FileMetaInformationGroupLength = 196
+        file_meta.FileMetaInformationVersion = b"\x00\x01"
+        file_meta.MediaStorageSOPClassUID = "1.2.840.10008.5.1.4.1.1.481.1"
+        file_meta.MediaStorageSOPInstanceUID = (
+            "1.2.246.352.64.1.5468686515961995030.4457606667843517571"
+        )
+        file_meta.TransferSyntaxUID = "1.2.840.10008.1.2"
+        file_meta.ImplementationClassUID = "1.2.246.352.70.2.1.120.1"
+        file_meta.ImplementationVersionName = "MergeCOM3_410"
+
+        # Main data elements
+        ds = Dataset()
+        ds.SpecificCharacterSet = "ISO_IR 100"
+        ds.ImageType = ["ORIGINAL", "PRIMARY", "PORTAL"]
+        ds.InstanceCreationDate = "20161230"
+        ds.InstanceCreationTime = "215510"
+        ds.SOPClassUID = UID("1.2.840.10008.5.1.4.1.1.481.1")
+        ds.SOPInstanceUID = generate_uid()
+        ds.SeriesInstanceUID = generate_uid()
+        ds.StudyDate = "20161230"
+        ds.ContentDate = "20161230"
+        ds.StudyTime = "215441.936"
+        ds.ContentTime = "215441.936"
+        ds.AccessionNumber = ""
+        ds.Modality = "RTIMAGE"
+        ds.ConversionType = ""
+        ds.Manufacturer = "Varian Medical Systems"
+        ds.ReferringPhysicianName = ""
+        ds.StationName = "NDS-WKS-SN9999"
+        ds.OperatorsName = "King Kong"
+        ds.ManufacturerModelName = "VMS.XI.Service"
+        ds.PatientName = "Grace Hopper"
+        ds.PatientID = "VMS.XI.Service"
+        ds.PatientBirthDate = "19000101"
+        ds.PatientBirthTime = "000000"
+        ds.PatientSex = ""
+        ds.SoftwareVersions = "2.5.13.2"
+        ds.StudyInstanceUID = "1.2.246.352.64.4.5644626269434644263.1905029945372990626"
+        ds.SeriesInstanceUID = (
+            "1.2.246.352.64.2.5508761605912087323.11665958260371685307"
+        )
+        ds.StudyID = "fdd794f2-8520-4c4a-aecc-e4446c1730ff"
+        ds.SeriesNumber = None
+        ds.AcquisitionNumber = "739774555"
+        ds.InstanceNumber = "1"
+        ds.PatientOrientation = ""
+        ds.FrameOfReferenceUID = (
+            "1.2.246.352.64.3.4714322356925391886.9391210174715030407"
+        )
+        ds.PositionReferenceIndicator = ""
+        ds.SamplesPerPixel = 1
+        ds.PhotometricInterpretation = "MONOCHROME1"
+        ds.PlanarConfiguration = 0
+        ds.Rows = self.shape[0]
+        ds.Columns = self.shape[1]
+        ds.BitsAllocated = 16
+        ds.BitsStored = 16
+        ds.HighBit = 15
+        ds.PixelRepresentation = 0
+        ds.WindowCenter = "32767.0"
+        ds.WindowWidth = "65535.0"
+        ds.RescaleIntercept = "0.0"
+        ds.RescaleSlope = "1.0"
+        ds.RescaleType = "US"
+        ds.RTImageLabel = "MV_180"
+        ds.RTImageDescription = ""
+        ds.ReportedValuesOrigin = "ACTUAL"
+        ds.RTImagePlane = "NORMAL"
+        ds.XRayImageReceptorTranslation = [0.00, 0.00, 1000 - self.sid]
+        ds.XRayImageReceptorAngle = "0.0"
+        ds.RTImageOrientation = [1, 0, 0, 0, -1, 0]
+        ds.ImagePlanePixelSpacing = [self.pixel_size, self.pixel_size]
+        ds.RTImagePosition = [-214.872, 214.872]
+        ds.RadiationMachineName = "TrueBeam from Hell"
+        ds.RadiationMachineSAD = "1000.0"
+        ds.RTImageSID = self.sid
+        ds.PrimaryDosimeterUnit = "MU"
+        ds.GantryAngle = str(gantry_angle)
+        ds.BeamLimitingDeviceAngle = str(coll_angle)
+        ds.PatientSupportAngle = str(table_angle)
+        ds.TableTopVerticalPosition = "-24.59382842824"
+        ds.TableTopLongitudinalPosition = "200.813502948597"
+        ds.TableTopLateralPosition = "3.00246706215532"
+        ds.PixelData = self.image  # XXX Array of 3276800 bytes excluded
+
+        ds.file_meta = file_meta
+        ds.is_implicit_VR = True
+        ds.is_little_endian = True
+        return ds
```

### Comparing `manteia_qa_pylinac-1.0.0/pylinac/core/image_generator/utils.py` & `manteia_qa_pylinac-1.1.0/pylinac/core/image_generator/utils.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,612 +1,607 @@
-from __future__ import annotations
-
-import copy
-import os
-import os.path as osp
-import random
-from typing import Sequence
-
-from ...picketfence import Orientation
-from ...winston_lutz import bb_projection_gantry_plane, bb_projection_long
-from ..geometry import cos, sin
-from . import GaussianFilterLayer
-from .layers import (
-    FilteredFieldLayer,
-    FilterFreeConeLayer,
-    FilterFreeFieldLayer,
-    Layer,
-    PerfectBBLayer,
-    PerfectConeLayer,
-    PerfectFieldLayer,
-)
-from .simulators import Simulator
-
-
-def generate_lightrad(
-    file_out: str,
-    simulator: Simulator,
-    field_layer: type[FilterFreeFieldLayer | FilteredFieldLayer | PerfectFieldLayer],
-    field_size_mm: (float, float) = (150, 150),
-    cax_offset_mm: (float, float) = (0, 0),
-    final_layers: list[Layer] = [
-        GaussianFilterLayer(),
-    ],
-    bb_size_mm: float = 3,
-    bb_positions: ((float, float), ...) = (
-        (-40, -40),
-        (-40, 40),
-        (40, -40),
-        (40, 40),
-        (-65, -65),
-        (-65, 65),
-        (65, -65),
-        (65, 65),
-    ),
-) -> None:
-    """Create a mock light/rad image with BBs.
-
-    Parameters
-    ----------
-    simulator
-        The image simulator
-    field_layer
-        The primary field layer
-    file_out
-        The name of the file to save the DICOM file to.
-    final_layers
-        Optional layers to apply at the end of the procedure. Useful for noise or blurring.
-    bb_size_mm
-        The size of the phantom BBs
-    bb_positions
-        The position of the BBs relative to the CAX.
-    """
-    # open field layer
-    simulator.add_layer(
-        field_layer(field_size_mm=field_size_mm, cax_offset_mm=cax_offset_mm)
-    )
-    # bbs
-    for bb in bb_positions:
-        simulator.add_layer(PerfectBBLayer(bb_size_mm=bb_size_mm, cax_offset_mm=bb))
-
-    if final_layers is not None:
-        for layer in final_layers:
-            simulator.add_layer(layer)
-    simulator.generate_dicom(file_out)
-
-
-def generate_picketfence(
-    simulator: Simulator,
-    field_layer: type[FilterFreeFieldLayer | FilteredFieldLayer | PerfectFieldLayer],
-    file_out: str,
-    final_layers: list[Layer] = None,
-    pickets: int = 11,
-    picket_spacing_mm: float = 20,
-    picket_width_mm: int = 2,
-    picket_height_mm: int = 300,
-    gantry_angle: int = 0,
-    orientation: Orientation = Orientation.UP_DOWN,
-    picket_offset_error: Sequence | None = None,
-) -> None:
-    """Create a mock picket fence image. Will always be up-down.
-
-    Parameters
-    ----------
-    simulator
-        The image simulator
-    field_layer
-        The primary field layer
-    file_out
-        The name of the file to save the DICOM file to.
-    final_layers
-        Optional layers to apply at the end of the procedure. Useful for noise or blurring.
-    pickets
-        The number of pickets
-    picket_spacing_mm
-        The space between pickets
-    picket_width_mm
-        Picket width parallel to leaf motion
-    picket_height_mm
-        Picket height parallel to leaf motion
-    gantry_angle
-        Gantry angle; sets the DICOM tag.
-    """
-    picket_pos_mm = range(
-        -int((pickets - 1) * picket_spacing_mm / 2),
-        int((pickets - 1) * picket_spacing_mm / 2) + 1,
-        picket_spacing_mm,
-    )
-    for idx, pos in enumerate(picket_pos_mm):
-        if picket_offset_error is not None:
-            if len(picket_offset_error) != pickets:
-                raise ValueError(
-                    "The length of the error array must be the same as the number of pickets."
-                )
-            pos += picket_offset_error[idx]
-        if orientation == orientation.UP_DOWN:
-            position = (0, pos)
-            layout = (picket_height_mm, picket_width_mm)
-        else:
-            position = (pos, 0)
-            layout = (picket_width_mm, picket_height_mm)
-        simulator.add_layer(field_layer(layout, cax_offset_mm=position))
-    if final_layers is not None:
-        for layer in final_layers:
-            simulator.add_layer(layer)
-    simulator.generate_dicom(file_out, gantry_angle=gantry_angle)
-
-
-def generate_winstonlutz(
-    simulator: Simulator,
-    field_layer: type[Layer],
-    dir_out: str,
-    field_size_mm: tuple[float, float] = (30, 30),
-    final_layers: list[Layer] | None = None,
-    bb_size_mm: float = 5,
-    offset_mm_left: float = 0,
-    offset_mm_up: float = 0,
-    offset_mm_in: float = 0,
-    image_axes: ((int, int, int), ...) = (
-        (0, 0, 0),
-        (90, 0, 0),
-        (180, 0, 0),
-        (270, 0, 0),
-    ),
-    gantry_tilt: float = 0,
-    gantry_sag: float = 0,
-    clean_dir: bool = True,
-    field_alpha: float = 1.0,
-    bb_alpha: float = -0.5,
-) -> list[str]:
-    """Create a mock set of WL images, simulating gantry sag effects. Produces one image for each item in image_axes.
-
-    Parameters
-    ----------
-    simulator
-        The image simulator
-    field_layer
-        The primary field layer simulating radiation
-    dir_out
-        The directory to save the images to.
-    field_size_mm
-        The field size of the radiation field in mm
-    final_layers
-        Layers to apply after generating the primary field and BB layer. Useful for blurring or adding noise.
-    bb_size_mm
-        The size of the BB. Must be positive.
-    offset_mm_left
-        How far left (lat) to set the BB. Can be positive or negative.
-    offset_mm_up
-        How far up (vert) to set the BB. Can be positive or negative.
-    offset_mm_in
-        How far in (long) to set the BB. Can be positive or negative.
-    image_axes
-        List of axis values for the images. Sequence is (Gantry, Coll, Couch).
-    gantry_tilt
-        The tilt of the gantry that affects the position at 0 and 180. Simulates a simple cosine function.
-    gantry_sag
-        The sag of the gantry that affects the position at gantry=90 and 270. Simulates a simple sine function.
-    clean_dir
-        Whether to clean out the output directory. Useful when iterating.
-    field_alpha
-        The normalized alpha (i.e. signal) of the radiation field. Use in combination
-        with bb_alpha such that the sum of the two is always <= 1.
-    bb_alpha
-        The normalized alpha (in the case of the BB think of it as attenuation) of the BB against the radiation field. More negative values
-        attenuate (remove signal) more.
-    """
-    if field_alpha + bb_alpha > 1:
-        raise ValueError("field_alpha and bb_alpha must sum to <=1")
-    if field_alpha - bb_alpha < 0:
-        raise ValueError("field_alpha and bb_alpha must have a sum >=0")
-    if not osp.isdir(dir_out):
-        os.mkdir(dir_out)
-    if clean_dir:
-        for pdir, _, files in os.walk(dir_out):
-            [os.remove(osp.join(pdir, f)) for f in files]
-    file_names = []
-    for gantry, coll, couch in image_axes:
-        sim_single = copy.copy(simulator)
-        sim_single.add_layer(
-            field_layer(
-                field_size_mm=field_size_mm,
-                cax_offset_mm=(gantry_tilt * cos(gantry), gantry_sag * sin(gantry)),
-                alpha=field_alpha,
-            )
-        )
-        # we return the negative because this function
-        # will return the offset in PLOTTING space, not coordinate space
-        # which is inverted in the long direction
-        long_offset = -bb_projection_long(
-            offset_in=offset_mm_in,
-            offset_up=offset_mm_up,
-            offset_left=offset_mm_left,
-            sad=1000,
-            gantry=gantry,
-        )
-        gplane_offset = bb_projection_gantry_plane(
-            offset_left=offset_mm_left, offset_up=offset_mm_up, sad=1000, gantry=gantry
-        )
-        sim_single.add_layer(
-            PerfectBBLayer(
-                cax_offset_mm=(long_offset, gplane_offset),
-                bb_size_mm=bb_size_mm,
-                alpha=bb_alpha,
-            )
-        )
-        if final_layers is not None:
-            for layer in final_layers:
-                sim_single.add_layer(layer)
-        file_name = f"WL G={gantry}, C={coll}, P={couch}; Field={field_size_mm}mm; BB={bb_size_mm}mm @ left={offset_mm_left}, in={offset_mm_in}, up={offset_mm_up}; Gantry tilt={gantry_tilt}, Gantry sag={gantry_sag}.dcm"
-        sim_single.generate_dicom(
-            osp.join(dir_out, file_name),
-            gantry_angle=gantry,
-            coll_angle=coll,
-            table_angle=couch,
-        )
-        file_names.append(file_name)
-    return file_names
-
-
-def generate_winstonlutz_multi_bb_single_field(
-    simulator: Simulator,
-    field_layer: type[Layer],
-    dir_out: str,
-    offsets: list[list[float]] | list[dict[str, float]],
-    field_size_mm: tuple[float, float] = (30, 30),
-    final_layers: list[Layer] | None = None,
-    bb_size_mm: float = 5,
-    image_axes: ((int, int, int), ...) = (
-        (0, 0, 0),
-        (90, 0, 0),
-        (180, 0, 0),
-        (270, 0, 0),
-    ),
-    gantry_tilt: float = 0,
-    gantry_sag: float = 0,
-    clean_dir: bool = True,
-    jitter_mm: float = 0,
-) -> list[str]:
-    """Create a mock set of WL images, simulating gantry sag effects. Produces one image for each item in image_axes.
-    This will also generate multiple BBs on the image, one per item in `offsets`. Each offset should be a list of
-    the shifts of the BB relative to isocenter like so: [<left>, <up>, <in>] OR an arrangement from the WL module.
-
-    Parameters
-    ----------
-    simulator
-        The image simulator
-    field_layer
-        The primary field layer simulating radiation
-    dir_out
-        The directory to save the images to.
-    offsets
-        A list of lists containing the shift of the BBs from iso; each sublist should be a 3-item list/tuple of left, up, in.
-        Negative values are acceptable and will go the opposite direction.
-    field_size_mm
-        The field size of the radiation field in mm
-    final_layers
-        Layers to apply after generating the primary field and BB layer. Useful for blurring or adding noise.
-    bb_size_mm
-        The size of the BB. Must be positive.
-    image_axes
-        List of axis values for the images. Sequence is (Gantry, Coll, Couch).
-    gantry_tilt
-        The tilt of the gantry in degrees that affects the position at 0 and 180. Simulates a simple cosine function.
-    gantry_sag
-        The sag of the gantry that affects the position at gantry=90 and 270. Simulates a simple sine function.
-    clean_dir
-        Whether to clean out the output directory. Useful when iterating.
-    jitter_mm
-        The amount of jitter to add to the in/left/up location of the BB in MM.
-    """
-    if not osp.isdir(dir_out):
-        os.mkdir(dir_out)
-    if clean_dir:
-        for pdir, _, files in os.walk(dir_out):
-            [os.remove(osp.join(pdir, f)) for f in files]
-    file_names = []
-    for gantry, coll, couch in image_axes:
-        sim_single = copy.copy(simulator)
-        sim_single.add_layer(
-            field_layer(
-                field_size_mm=field_size_mm,
-                cax_offset_mm=(gantry_tilt * cos(gantry), gantry_sag * sin(gantry)),
-            )
-        )
-        for offset in offsets:
-            if isinstance(offset, dict):
-                offset_mm_left = offset["offset_left_mm"] + random.uniform(
-                    -jitter_mm, jitter_mm
-                )
-                offset_mm_up = offset["offset_up_mm"] + random.uniform(
-                    -jitter_mm, jitter_mm
-                )
-                offset_mm_in = -offset["offset_in_mm"] + random.uniform(
-                    -jitter_mm, jitter_mm
-                )
-            else:
-                offset_mm_left = offset[0] + random.uniform(-jitter_mm, jitter_mm)
-                offset_mm_up = offset[1] + random.uniform(-jitter_mm, jitter_mm)
-                offset_mm_in = -offset[2] + random.uniform(
-                    -jitter_mm, jitter_mm
-                )  # negative because pixels increase as we go out, so to go in we subtract
-
-            long_offset = bb_projection_long(
-                offset_in=offset_mm_in,
-                offset_up=offset_mm_up,
-                offset_left=offset_mm_left,
-                sad=1000,
-                gantry=gantry,
-            )
-            gplane_offset = bb_projection_gantry_plane(
-                offset_left=offset_mm_left,
-                offset_up=offset_mm_up,
-                sad=1000,
-                gantry=gantry,
-            )
-            sim_single.add_layer(
-                PerfectBBLayer(
-                    cax_offset_mm=(
-                        long_offset,
-                        gplane_offset,
-                    ),
-                    bb_size_mm=bb_size_mm,
-                )
-            )
-        if final_layers is not None:
-            for layer in final_layers:
-                sim_single.add_layer(layer)
-        file_name = f"WL G={gantry}, C={coll}, P={couch}; Field={field_size_mm}mm; BB={bb_size_mm}mm @ left={offset_mm_left:.2f}, in={offset_mm_in:.2f}, up={offset_mm_up:.2f}; Gantry tilt={gantry_tilt}, Gantry sag={gantry_sag}.dcm"
-        sim_single.generate_dicom(
-            osp.join(dir_out, file_name),
-            gantry_angle=gantry,
-            coll_angle=coll,
-            table_angle=couch,
-        )
-        file_names.append(file_name)
-    return file_names
-
-
-def generate_winstonlutz_multi_bb_multi_field(
-    simulator: Simulator,
-    field_layer: type[Layer],
-    dir_out: str,
-    field_offsets: list[list[float]],
-    bb_offsets: list[list[float]] | list[dict[str, float]],
-    field_size_mm: tuple[float, float] = (20, 20),
-    final_layers: list[Layer] | None = None,
-    bb_size_mm: float = 5,
-    image_axes: ((int, int, int), ...) = (
-        (0, 0, 0),
-        (90, 0, 0),
-        (180, 0, 0),
-        (270, 0, 0),
-    ),
-    gantry_tilt: float = 0,
-    gantry_sag: float = 0,
-    clean_dir: bool = True,
-    jitter_mm: float = 0,
-    align_to_pixels: bool = True,
-) -> list[str]:
-    """Create a mock set of WL images, simulating gantry sag effects. Produces one image for each item in image_axes.
-    This will also generate multiple BBs on the image, one per item in `offsets`. Each offset should be a list of
-    the shifts of the BB relative to isocenter like so: [<left>, <up>, <in>] OR an arrangement from the WL module.
-
-    Parameters
-    ----------
-    simulator
-        The image simulator
-    field_layer
-        The primary field layer simulating radiation
-    dir_out
-        The directory to save the images to.
-    field_offsets
-        A list of lists containing the shift of the fields. Format is the same as bb_offsets.
-    bb_offsets
-        A list of lists containing the shift of the BBs from iso; each sublist should be a 3-item list/tuple of left, up, in.
-        Negative values are acceptable and will go the opposite direction.
-    field_size_mm
-        The field size of the radiation field in mm
-    final_layers
-        Layers to apply after generating the primary field and BB layer. Useful for blurring or adding noise.
-    bb_size_mm
-        The size of the BB. Must be positive.
-    image_axes
-        List of axis values for the images. Sequence is (Gantry, Coll, Couch).
-    gantry_tilt
-        The tilt of the gantry in degrees that affects the position at 0 and 180. Simulates a simple cosine function.
-    gantry_sag
-        The sag of the gantry that affects the position at gantry=90 and 270. Simulates a simple sine function.
-    clean_dir
-        Whether to clean out the output directory. Useful when iterating.
-    jitter_mm
-        The amount of jitter to add to the in/left/up location of the BB in MM.
-    """
-    if not osp.isdir(dir_out):
-        os.mkdir(dir_out)
-    if clean_dir:
-        for pdir, _, files in os.walk(dir_out):
-            [os.remove(osp.join(pdir, f)) for f in files]
-    file_names = []
-    for gantry, coll, couch in image_axes:
-        sim_single = copy.copy(simulator)
-        for field_offset in field_offsets:
-            offset_mm_left = field_offset[0] + random.uniform(-jitter_mm, jitter_mm)
-            offset_mm_up = field_offset[1] + random.uniform(-jitter_mm, jitter_mm)
-            offset_mm_in = -field_offset[2] + random.uniform(
-                -jitter_mm, jitter_mm
-            )  # negative because pixels increase as we go out, so to go in we subtract
-            long_offset = bb_projection_long(
-                offset_in=offset_mm_in,
-                offset_up=offset_mm_up,
-                offset_left=offset_mm_left,
-                sad=1000,
-                gantry=gantry,
-            )
-            gplane_offset = bb_projection_gantry_plane(
-                offset_left=offset_mm_left,
-                offset_up=offset_mm_up,
-                sad=1000,
-                gantry=gantry,
-            )
-            long_offset += gantry_tilt * cos(gantry)
-            gplane_offset += gantry_sag * sin(gantry)
-            if align_to_pixels:
-                long_offset = pixel_align(sim_single.pixel_size, long_offset)
-                gplane_offset = pixel_align(sim_single.pixel_size, gplane_offset)
-            sim_single.add_layer(
-                field_layer(
-                    field_size_mm=field_size_mm,
-                    cax_offset_mm=(long_offset, gplane_offset),
-                )
-            )
-        for offset in bb_offsets:
-            if isinstance(offset, dict):
-                offset_mm_left = offset["offset_left_mm"] + random.uniform(
-                    -jitter_mm, jitter_mm
-                )
-                offset_mm_up = offset["offset_up_mm"] + random.uniform(
-                    -jitter_mm, jitter_mm
-                )
-                offset_mm_in = -offset["offset_in_mm"] + random.uniform(
-                    -jitter_mm, jitter_mm
-                )
-            else:
-                offset_mm_left = offset[0] + random.uniform(-jitter_mm, jitter_mm)
-                offset_mm_up = offset[1] + random.uniform(-jitter_mm, jitter_mm)
-                offset_mm_in = -offset[2] + random.uniform(
-                    -jitter_mm, jitter_mm
-                )  # negative because pixels increase as we go out, so to go in we subtract
-
-            long_offset = bb_projection_long(
-                offset_in=offset_mm_in,
-                offset_up=offset_mm_up,
-                offset_left=offset_mm_left,
-                sad=1000,
-                gantry=gantry,
-            )
-            gplane_offset = bb_projection_gantry_plane(
-                offset_left=offset_mm_left,
-                offset_up=offset_mm_up,
-                sad=1000,
-                gantry=gantry,
-            )
-            if align_to_pixels:
-                long_offset = pixel_align(sim_single.pixel_size, long_offset)
-                gplane_offset = pixel_align(sim_single.pixel_size, gplane_offset)
-            sim_single.add_layer(
-                PerfectBBLayer(
-                    cax_offset_mm=(
-                        long_offset,
-                        gplane_offset,
-                    ),
-                    bb_size_mm=bb_size_mm,
-                )
-            )
-        if final_layers is not None:
-            for layer in final_layers:
-                sim_single.add_layer(layer)
-        file_name = f"WL G={gantry}, C={coll}, P={couch}; Field={field_size_mm}mm (shifts={field_offsets}); BB={bb_size_mm}mm @ left={offset_mm_left:.2f}, in={offset_mm_in:.2f}, up={offset_mm_up:.2f}; Gantry tilt={gantry_tilt}, Gantry sag={gantry_sag}.dcm"
-        sim_single.generate_dicom(
-            osp.join(dir_out, file_name),
-            gantry_angle=gantry,
-            coll_angle=coll,
-            table_angle=couch,
-        )
-        file_names.append(file_name)
-    return file_names
-
-
-def generate_winstonlutz_cone(
-    simulator: Simulator,
-    cone_layer: type[FilterFreeConeLayer] | type[PerfectConeLayer],
-    dir_out: str,
-    cone_size_mm: float = 17.5,
-    final_layers: list[Layer] | None = None,
-    bb_size_mm: float = 5,
-    offset_mm_left: float = 0,
-    offset_mm_up: float = 0,
-    offset_mm_in: float = 0,
-    image_axes: ((int, int, int), ...) = (
-        (0, 0, 0),
-        (90, 0, 0),
-        (180, 0, 0),
-        (270, 0, 0),
-    ),
-    gantry_tilt: float = 0,
-    gantry_sag: float = 0,
-    clean_dir: bool = True,
-) -> list[str]:
-    """Create a mock set of WL images with a cone field, simulating gantry sag effects. Produces one image for each item in image_axes.
-
-    Parameters
-    ----------
-    simulator
-        The image simulator
-    cone_layer
-        The primary field layer simulating radiation
-    dir_out
-        The directory to save the images to.
-    cone_size_mm
-        The field size of the radiation field in mm
-    final_layers
-        Layers to apply after generating the primary field and BB layer. Useful for blurring or adding noise.
-    bb_size_mm
-        The size of the BB. Must be positive.
-    offset_mm_left
-        How far left (lat) to set the BB. Can be positive or negative.
-    offset_mm_up
-        How far up (vert) to set the BB. Can be positive or negative.
-    offset_mm_in
-        How far in (long) to set the BB. Can be positive or negative.
-    image_axes
-        List of axis values for the images. Sequence is (Gantry, Coll, Couch).
-    gantry_tilt
-        The tilt of the gantry in degrees that affects the position at 0 and 180. Simulates a simple cosine function.
-    gantry_sag
-        The sag of the gantry that affects the position at gantry=90 and 270. Simulates a simple sine function.
-    clean_dir
-        Whether to clean out the output directory. Useful when iterating.
-    """
-    if not osp.isdir(dir_out):
-        os.mkdir(dir_out)
-    if clean_dir:
-        for pdir, _, files in os.walk(dir_out):
-            [os.remove(osp.join(pdir, f)) for f in files]
-    file_names = []
-    for gantry, coll, couch in image_axes:
-        sim_single = copy.copy(simulator)
-        sim_single.add_layer(
-            cone_layer(
-                cone_size_mm=cone_size_mm,
-                cax_offset_mm=(gantry_tilt * cos(gantry), gantry_sag * sin(gantry)),
-            )
-        )
-        sim_single.add_layer(
-            PerfectBBLayer(
-                cax_offset_mm=(
-                    -offset_mm_in,
-                    -offset_mm_left * cos(gantry) - offset_mm_up * sin(gantry),
-                )
-            )
-        )
-        if final_layers is not None:
-            for layer in final_layers:
-                sim_single.add_layer(layer)
-        file_name = f"WL G={gantry}, C={coll}, P={couch}; Cone={cone_size_mm}mm; BB={bb_size_mm}mm @ left={offset_mm_left}, in={offset_mm_in}, up={offset_mm_up}; Gantry tilt={gantry_tilt}, Gantry sag={gantry_sag}.dcm"
-        sim_single.generate_dicom(
-            osp.join(dir_out, file_name),
-            gantry_angle=gantry,
-            coll_angle=coll,
-            table_angle=couch,
-        )
-        file_names.append(file_name)
-    return file_names
-
-
-def pixel_align(pixel_size: float, length_mm: float) -> float:
-    """Due to the finite pixel size, a desired shift may not be possible
-    at the exact distance desired. This may cause benchmarking issues when
-    the user thinks the field or bb is at X when really it's at X +/- 1/2 * pixel size
-
-    This corrects the value to be aligned to the nearest pixel"""
-    return round(length_mm / pixel_size) * pixel_size
+from __future__ import annotations
+
+import copy
+import os
+import os.path as osp
+import random
+from typing import Sequence
+
+from ...picketfence import Orientation
+from ...winston_lutz import bb_projection_with_rotation
+from ..geometry import cos, sin
+from ..scale import MachineScale, convert
+from . import GaussianFilterLayer
+from .layers import (
+    FilteredFieldLayer,
+    FilterFreeConeLayer,
+    FilterFreeFieldLayer,
+    Layer,
+    PerfectBBLayer,
+    PerfectConeLayer,
+    PerfectFieldLayer,
+)
+from .simulators import Simulator
+
+
+def generate_lightrad(
+    file_out: str,
+    simulator: Simulator,
+    field_layer: type[FilterFreeFieldLayer | FilteredFieldLayer | PerfectFieldLayer],
+    field_size_mm: (float, float) = (150, 150),
+    cax_offset_mm: (float, float) = (0, 0),
+    final_layers: list[Layer] = [
+        GaussianFilterLayer(),
+    ],
+    bb_size_mm: float = 3,
+    bb_positions: ((float, float), ...) = (
+        (-40, -40),
+        (-40, 40),
+        (40, -40),
+        (40, 40),
+        (-65, -65),
+        (-65, 65),
+        (65, -65),
+        (65, 65),
+    ),
+) -> None:
+    """Create a mock light/rad image with BBs.
+
+    Parameters
+    ----------
+    simulator
+        The image simulator
+    field_layer
+        The primary field layer
+    file_out
+        The name of the file to save the DICOM file to.
+    final_layers
+        Optional layers to apply at the end of the procedure. Useful for noise or blurring.
+    bb_size_mm
+        The size of the phantom BBs
+    bb_positions
+        The position of the BBs relative to the CAX.
+    """
+    # open field layer
+    simulator.add_layer(
+        field_layer(field_size_mm=field_size_mm, cax_offset_mm=cax_offset_mm)
+    )
+    # bbs
+    for bb in bb_positions:
+        simulator.add_layer(PerfectBBLayer(bb_size_mm=bb_size_mm, cax_offset_mm=bb))
+
+    if final_layers is not None:
+        for layer in final_layers:
+            simulator.add_layer(layer)
+    simulator.generate_dicom(file_out)
+
+
+def generate_picketfence(
+    simulator: Simulator,
+    field_layer: type[FilterFreeFieldLayer | FilteredFieldLayer | PerfectFieldLayer],
+    file_out: str,
+    final_layers: list[Layer] = None,
+    pickets: int = 11,
+    picket_spacing_mm: float = 20,
+    picket_width_mm: int = 2,
+    picket_height_mm: int = 300,
+    gantry_angle: int = 0,
+    orientation: Orientation = Orientation.UP_DOWN,
+    picket_offset_error: Sequence | None = None,
+) -> None:
+    """Create a mock picket fence image. Will always be up-down.
+
+    Parameters
+    ----------
+    simulator
+        The image simulator
+    field_layer
+        The primary field layer
+    file_out
+        The name of the file to save the DICOM file to.
+    final_layers
+        Optional layers to apply at the end of the procedure. Useful for noise or blurring.
+    pickets
+        The number of pickets
+    picket_spacing_mm
+        The space between pickets
+    picket_width_mm
+        Picket width parallel to leaf motion
+    picket_height_mm
+        Picket height parallel to leaf motion
+    gantry_angle
+        Gantry angle; sets the DICOM tag.
+    """
+    picket_pos_mm = range(
+        -int((pickets - 1) * picket_spacing_mm / 2),
+        int((pickets - 1) * picket_spacing_mm / 2) + 1,
+        picket_spacing_mm,
+    )
+    for idx, pos in enumerate(picket_pos_mm):
+        if picket_offset_error is not None:
+            if len(picket_offset_error) != pickets:
+                raise ValueError(
+                    "The length of the error array must be the same as the number of pickets."
+                )
+            pos += picket_offset_error[idx]
+        if orientation == orientation.UP_DOWN:
+            position = (0, pos)
+            layout = (picket_height_mm, picket_width_mm)
+        else:
+            position = (pos, 0)
+            layout = (picket_width_mm, picket_height_mm)
+        simulator.add_layer(field_layer(field_size_mm=layout, cax_offset_mm=position))
+    if final_layers is not None:
+        for layer in final_layers:
+            simulator.add_layer(layer)
+    simulator.generate_dicom(file_out, gantry_angle=gantry_angle)
+
+
+def generate_winstonlutz(
+    simulator: Simulator,
+    field_layer: type[Layer],
+    dir_out: str,
+    field_size_mm: tuple[float, float] = (30, 30),
+    final_layers: list[Layer] | None = None,
+    bb_size_mm: float = 5,
+    offset_mm_left: float = 0,
+    offset_mm_up: float = 0,
+    offset_mm_in: float = 0,
+    image_axes: ((int, int, int), ...) = (
+        (0, 0, 0),
+        (90, 0, 0),
+        (180, 0, 0),
+        (270, 0, 0),
+    ),
+    machine_scale: MachineScale = MachineScale.IEC61217,
+    gantry_tilt: float = 0,
+    gantry_sag: float = 0,
+    clean_dir: bool = True,
+    field_alpha: float = 1.0,
+    bb_alpha: float = -0.5,
+) -> list[str]:
+    """Create a mock set of WL images. Used for benchmarking the WL algorithm. Produces one image for each item in ``image_axes``.
+
+    Parameters
+    ----------
+    simulator
+        The image simulator
+    field_layer
+        The primary field layer simulating radiation
+    dir_out
+        The directory to save the images to.
+    field_size_mm
+        The field size of the radiation field in mm
+    final_layers
+        Layers to apply after generating the primary field and BB layer. Useful for blurring or adding noise.
+    bb_size_mm
+        The size of the BB. Must be positive.
+    offset_mm_left
+        How far left (LAT) to set the BB. Can be positive or negative.
+    offset_mm_up
+        How far up (VERT) to set the BB. Can be positive or negative.
+    offset_mm_in
+        How far in (LONG) to set the BB. Can be positive or negative.
+    image_axes
+        List of axis values for the images. Sequence is (Gantry, Coll, Couch).
+    machine_scale
+        The scale of the machine. Will convert to IEC61217. Allows users to
+        enter image_axes in their machine's scale if desired.
+    gantry_tilt
+        The tilt of the gantry that affects the position at 0 and 180. Simulates a simple cosine function.
+    gantry_sag
+        The sag of the gantry that affects the position at gantry=90 and 270. Simulates a simple sine function.
+    clean_dir
+        Whether to clean out the output directory. Useful when iterating.
+    field_alpha
+        The normalized alpha (i.e. signal) of the radiation field. Use in combination
+        with bb_alpha such that the sum of the two is always <= 1.
+    bb_alpha
+        The normalized alpha (in the case of the BB think of it as attenuation) of the BB against the radiation field. More negative values
+        attenuate (remove signal) more.
+    """
+    if field_alpha + bb_alpha > 1:
+        raise ValueError("field_alpha and bb_alpha must sum to <=1")
+    if field_alpha - bb_alpha < 0:
+        raise ValueError("field_alpha and bb_alpha must have a sum >=0")
+    if not osp.isdir(dir_out):
+        os.mkdir(dir_out)
+    if clean_dir:
+        for pdir, _, files in os.walk(dir_out):
+            [os.remove(osp.join(pdir, f)) for f in files]
+    file_names = []
+    for gantry_in, coll_in, couch_in in image_axes:
+        gantry, coll, couch = convert(
+            input_scale=machine_scale,
+            output_scale=MachineScale.IEC61217,
+            gantry=gantry_in,
+            collimator=coll_in,
+            rotation=couch_in,
+        )
+        sim_single = copy.copy(simulator)
+        sim_single.add_layer(
+            field_layer(
+                field_size_mm=field_size_mm,
+                cax_offset_mm=(gantry_sag * sin(gantry), gantry_tilt * cos(gantry)),
+                alpha=field_alpha,
+                rotation=coll,
+            )
+        )
+        gplane_offset, long_offset = bb_projection_with_rotation(
+            offset_left=offset_mm_left,
+            offset_up=offset_mm_up,
+            offset_in=offset_mm_in,
+            gantry=gantry,
+            couch=couch,
+            sad=1000,
+        )
+        sim_single.add_layer(
+            PerfectBBLayer(
+                # because of an oversight, the cax offset parameter expects (out, right) instead of (in, right)
+                # we thus pass the negative of the long offset
+                cax_offset_mm=(-long_offset, gplane_offset),
+                bb_size_mm=bb_size_mm,
+                alpha=bb_alpha,
+                # we don't pass the rotate parameter here because the offsets above already account for
+                # the rotation. Setting this would cancel out the rotation.
+            )
+        )
+        if final_layers is not None:
+            for layer in final_layers:
+                sim_single.add_layer(layer)
+        file_name = f"WL G={gantry}, C={coll}, P={couch}; Field={field_size_mm}mm; BB={bb_size_mm}mm @ left={offset_mm_left}, in={offset_mm_in}, up={offset_mm_up}; Gantry tilt={gantry_tilt}, Gantry sag={gantry_sag}.dcm"
+        sim_single.generate_dicom(
+            osp.join(dir_out, file_name),
+            gantry_angle=gantry,
+            coll_angle=coll,
+            table_angle=couch,
+        )
+        file_names.append(file_name)
+    return file_names
+
+
+def generate_winstonlutz_multi_bb_single_field(
+    simulator: Simulator,
+    field_layer: type[Layer],
+    dir_out: str,
+    offsets: list[list[float]] | list[dict[str, float]],
+    field_size_mm: tuple[float, float] = (30, 30),
+    final_layers: list[Layer] | None = None,
+    bb_size_mm: float = 5,
+    image_axes: ((int, int, int), ...) = (
+        (0, 0, 0),
+        (90, 0, 0),
+        (180, 0, 0),
+        (270, 0, 0),
+    ),
+    gantry_tilt: float = 0,
+    gantry_sag: float = 0,
+    clean_dir: bool = True,
+    jitter_mm: float = 0,
+) -> list[str]:
+    """Create a mock set of WL images, simulating gantry sag effects. Produces one image for each item in image_axes.
+    This will also generate multiple BBs on the image, one per item in `offsets`. Each offset should be a list of
+    the shifts of the BB relative to isocenter like so: [<left>, <up>, <in>] OR an arrangement from the WL module.
+
+    Parameters
+    ----------
+    simulator
+        The image simulator
+    field_layer
+        The primary field layer simulating radiation
+    dir_out
+        The directory to save the images to.
+    offsets
+        A list of lists containing the shift of the BBs from iso; each sublist should be a 3-item list/tuple of left, up, in.
+        Negative values are acceptable and will go the opposite direction.
+    field_size_mm
+        The field size of the radiation field in mm
+    final_layers
+        Layers to apply after generating the primary field and BB layer. Useful for blurring or adding noise.
+    bb_size_mm
+        The size of the BB. Must be positive.
+    image_axes
+        List of axis values for the images. Sequence is (Gantry, Coll, Couch).
+    gantry_tilt
+        The tilt of the gantry in degrees that affects the position at 0 and 180. Simulates a simple cosine function.
+    gantry_sag
+        The sag of the gantry that affects the position at gantry=90 and 270. Simulates a simple sine function.
+    clean_dir
+        Whether to clean out the output directory. Useful when iterating.
+    jitter_mm
+        The amount of jitter to add to the in/left/up location of the BB in MM.
+    """
+    if not osp.isdir(dir_out):
+        os.mkdir(dir_out)
+    if clean_dir:
+        for pdir, _, files in os.walk(dir_out):
+            [os.remove(osp.join(pdir, f)) for f in files]
+    file_names = []
+    for gantry, coll, couch in image_axes:
+        sim_single = copy.copy(simulator)
+        sim_single.add_layer(
+            field_layer(
+                field_size_mm=field_size_mm,
+                cax_offset_mm=(gantry_tilt * cos(gantry), gantry_sag * sin(gantry)),
+            )
+        )
+        for offset in offsets:
+            if isinstance(offset, dict):
+                offset_mm_left = offset["offset_left_mm"] + random.uniform(
+                    -jitter_mm, jitter_mm
+                )
+                offset_mm_up = offset["offset_up_mm"] + random.uniform(
+                    -jitter_mm, jitter_mm
+                )
+                offset_mm_in = -offset["offset_in_mm"] + random.uniform(
+                    -jitter_mm, jitter_mm
+                )
+            else:
+                offset_mm_left = offset[0] + random.uniform(-jitter_mm, jitter_mm)
+                offset_mm_up = offset[1] + random.uniform(-jitter_mm, jitter_mm)
+                offset_mm_in = -offset[2] + random.uniform(
+                    -jitter_mm, jitter_mm
+                )  # negative because pixels increase as we go out, so to go in we subtract
+            gplane_offset, long_offset = bb_projection_with_rotation(
+                offset_left=offset_mm_left,
+                offset_up=offset_mm_up,
+                offset_in=offset_mm_in,
+                gantry=gantry,
+                couch=couch,
+                sad=1000,
+            )
+            sim_single.add_layer(
+                PerfectBBLayer(
+                    cax_offset_mm=(
+                        long_offset,
+                        gplane_offset,
+                    ),
+                    bb_size_mm=bb_size_mm,
+                )
+            )
+        if final_layers is not None:
+            for layer in final_layers:
+                sim_single.add_layer(layer)
+        file_name = f"WL G={gantry}, C={coll}, P={couch}; Field={field_size_mm}mm; BB={bb_size_mm}mm @ left={offset_mm_left:.2f}, in={offset_mm_in:.2f}, up={offset_mm_up:.2f}; Gantry tilt={gantry_tilt}, Gantry sag={gantry_sag}.dcm"
+        sim_single.generate_dicom(
+            osp.join(dir_out, file_name),
+            gantry_angle=gantry,
+            coll_angle=coll,
+            table_angle=couch,
+        )
+        file_names.append(file_name)
+    return file_names
+
+
+def generate_winstonlutz_multi_bb_multi_field(
+    simulator: Simulator,
+    field_layer: type[Layer],
+    dir_out: str,
+    field_offsets: Sequence[Sequence[float]],
+    bb_offsets: Sequence[Sequence[float]] | list[dict[str, float]],
+    field_size_mm: tuple[float, float] = (20, 20),
+    final_layers: Sequence[Layer] | None = None,
+    bb_size_mm: float = 5,
+    image_axes: ((int, int, int), ...) = (
+        (0, 0, 0),
+        (90, 0, 0),
+        (180, 0, 0),
+        (270, 0, 0),
+    ),
+    gantry_tilt: float = 0,
+    gantry_sag: float = 0,
+    clean_dir: bool = True,
+    jitter_mm: float = 0,
+    align_to_pixels: bool = True,
+) -> list[str]:
+    """Create a mock set of WL images, simulating gantry sag effects. Produces one image for each item in image_axes.
+    This will also generate multiple BBs on the image, one per item in `offsets`. Each offset should be a list of
+    the shifts of the BB relative to isocenter like so: [<left>, <up>, <in>] OR an arrangement from the WL module.
+
+    Parameters
+    ----------
+    simulator
+        The image simulator
+    field_layer
+        The primary field layer simulating radiation
+    dir_out
+        The directory to save the images to.
+    field_offsets
+        A list of lists containing the shift of the fields. Format is the same as bb_offsets.
+    bb_offsets
+        A list of lists containing the shift of the BBs from iso; each sublist should be a 3-item list/tuple of left, up, in.
+        Negative values are acceptable and will go the opposite direction.
+    field_size_mm
+        The field size of the radiation field in mm
+    final_layers
+        Layers to apply after generating the primary field and BB layer. Useful for blurring or adding noise.
+    bb_size_mm
+        The size of the BB. Must be positive.
+    image_axes
+        List of axis values for the images. Sequence is (Gantry, Coll, Couch).
+    gantry_tilt
+        The tilt of the gantry in degrees that affects the position at 0 and 180. Simulates a simple cosine function.
+    gantry_sag
+        The sag of the gantry that affects the position at gantry=90 and 270. Simulates a simple sine function.
+    clean_dir
+        Whether to clean out the output directory. Useful when iterating.
+    jitter_mm
+        The amount of jitter to add to the in/left/up location of the BB in MM.
+    """
+    if not osp.isdir(dir_out):
+        os.mkdir(dir_out)
+    if clean_dir:
+        for pdir, _, files in os.walk(dir_out):
+            [os.remove(osp.join(pdir, f)) for f in files]
+    file_names = []
+    for gantry, coll, couch in image_axes:
+        sim_single = copy.copy(simulator)
+        for field_offset in field_offsets:
+            offset_mm_left = field_offset[0] + random.uniform(-jitter_mm, jitter_mm)
+            offset_mm_up = field_offset[1] + random.uniform(-jitter_mm, jitter_mm)
+            offset_mm_in = field_offset[2] + random.uniform(-jitter_mm, jitter_mm)
+            gplane_offset, long_offset = bb_projection_with_rotation(
+                offset_left=offset_mm_left,
+                offset_up=offset_mm_up,
+                offset_in=offset_mm_in,
+                gantry=gantry,
+                couch=couch,
+                sad=1000,
+            )
+            long_offset += gantry_tilt * cos(gantry)
+            gplane_offset += gantry_sag * sin(gantry)
+            if align_to_pixels:
+                long_offset = pixel_align(sim_single.pixel_size, long_offset)
+                gplane_offset = pixel_align(sim_single.pixel_size, gplane_offset)
+            sim_single.add_layer(
+                field_layer(
+                    # because of an oversight, the cax offset parameter expects (out, right) instead of (in, right)
+                    # we thus pass the negative of the long offset
+                    field_size_mm=field_size_mm,
+                    cax_offset_mm=(-long_offset, gplane_offset),
+                )
+            )
+        for offset in bb_offsets:
+            if isinstance(offset, dict):
+                offset_mm_left = offset["offset_left_mm"] + random.uniform(
+                    -jitter_mm, jitter_mm
+                )
+                offset_mm_up = offset["offset_up_mm"] + random.uniform(
+                    -jitter_mm, jitter_mm
+                )
+                offset_mm_in = offset["offset_in_mm"] + random.uniform(
+                    -jitter_mm, jitter_mm
+                )
+            else:
+                offset_mm_left = offset[0] + random.uniform(-jitter_mm, jitter_mm)
+                offset_mm_up = offset[1] + random.uniform(-jitter_mm, jitter_mm)
+                offset_mm_in = offset[2] + random.uniform(-jitter_mm, jitter_mm)
+            gplane_offset, long_offset = bb_projection_with_rotation(
+                offset_left=offset_mm_left,
+                offset_up=offset_mm_up,
+                offset_in=offset_mm_in,
+                gantry=gantry,
+                couch=couch,
+                sad=1000,
+            )
+            if align_to_pixels:
+                long_offset = pixel_align(sim_single.pixel_size, long_offset)
+                gplane_offset = pixel_align(sim_single.pixel_size, gplane_offset)
+            sim_single.add_layer(
+                PerfectBBLayer(
+                    # because of an oversight, the cax offset is (out, right) instead of (in, right)
+                    # we thus pass the negative of the long offset
+                    cax_offset_mm=(
+                        -long_offset,
+                        gplane_offset,
+                    ),
+                    bb_size_mm=bb_size_mm,
+                )
+            )
+        if final_layers is not None:
+            for layer in final_layers:
+                sim_single.add_layer(layer)
+        file_name = f"WL G={gantry}, C={coll}, P={couch}; Field={field_size_mm}mm (shifts={field_offsets}); BB={bb_size_mm}mm @ left={offset_mm_left:.2f}, in={offset_mm_in:.2f}, up={offset_mm_up:.2f}; Gantry tilt={gantry_tilt}, Gantry sag={gantry_sag}.dcm"
+        sim_single.generate_dicom(
+            osp.join(dir_out, file_name),
+            gantry_angle=gantry,
+            coll_angle=coll,
+            table_angle=couch,
+        )
+        file_names.append(file_name)
+    return file_names
+
+
+def generate_winstonlutz_cone(
+    simulator: Simulator,
+    cone_layer: type[FilterFreeConeLayer] | type[PerfectConeLayer],
+    dir_out: str,
+    cone_size_mm: float = 17.5,
+    final_layers: list[Layer] | None = None,
+    bb_size_mm: float = 5,
+    offset_mm_left: float = 0,
+    offset_mm_up: float = 0,
+    offset_mm_in: float = 0,
+    image_axes: ((int, int, int), ...) = (
+        (0, 0, 0),
+        (90, 0, 0),
+        (180, 0, 0),
+        (270, 0, 0),
+    ),
+    gantry_tilt: float = 0,
+    gantry_sag: float = 0,
+    clean_dir: bool = True,
+) -> list[str]:
+    """Create a mock set of WL images with a cone field, simulating gantry sag effects. Produces one image for each item in image_axes.
+
+    Parameters
+    ----------
+    simulator
+        The image simulator
+    cone_layer
+        The primary field layer simulating radiation
+    dir_out
+        The directory to save the images to.
+    cone_size_mm
+        The field size of the radiation field in mm
+    final_layers
+        Layers to apply after generating the primary field and BB layer. Useful for blurring or adding noise.
+    bb_size_mm
+        The size of the BB. Must be positive.
+    offset_mm_left
+        How far left (lat) to set the BB. Can be positive or negative.
+    offset_mm_up
+        How far up (vert) to set the BB. Can be positive or negative.
+    offset_mm_in
+        How far in (long) to set the BB. Can be positive or negative.
+    image_axes
+        List of axis values for the images. Sequence is (Gantry, Coll, Couch).
+    gantry_tilt
+        The tilt of the gantry in degrees that affects the position at 0 and 180. Simulates a simple cosine function.
+    gantry_sag
+        The sag of the gantry that affects the position at gantry=90 and 270. Simulates a simple sine function.
+    clean_dir
+        Whether to clean out the output directory. Useful when iterating.
+    """
+    if not osp.isdir(dir_out):
+        os.mkdir(dir_out)
+    if clean_dir:
+        for pdir, _, files in os.walk(dir_out):
+            [os.remove(osp.join(pdir, f)) for f in files]
+    file_names = []
+    for gantry, coll, couch in image_axes:
+        sim_single = copy.copy(simulator)
+        sim_single.add_layer(
+            cone_layer(
+                cone_size_mm=cone_size_mm,
+                cax_offset_mm=(gantry_tilt * cos(gantry), gantry_sag * sin(gantry)),
+            )
+        )
+        sim_single.add_layer(
+            PerfectBBLayer(
+                cax_offset_mm=(
+                    -offset_mm_in,
+                    -offset_mm_left * cos(gantry) - offset_mm_up * sin(gantry),
+                )
+            )
+        )
+        if final_layers is not None:
+            for layer in final_layers:
+                sim_single.add_layer(layer)
+        file_name = f"WL G={gantry}, C={coll}, P={couch}; Cone={cone_size_mm}mm; BB={bb_size_mm}mm @ left={offset_mm_left}, in={offset_mm_in}, up={offset_mm_up}; Gantry tilt={gantry_tilt}, Gantry sag={gantry_sag}.dcm"
+        sim_single.generate_dicom(
+            osp.join(dir_out, file_name),
+            gantry_angle=gantry,
+            coll_angle=coll,
+            table_angle=couch,
+        )
+        file_names.append(file_name)
+    return file_names
+
+
+def pixel_align(pixel_size: float, length_mm: float) -> float:
+    """Due to the finite pixel size, a desired shift may not be possible
+    at the exact distance desired. This may cause benchmarking issues when
+    the user thinks the field or bb is at X when really it's at X +/- 1/2 * pixel size
+
+    This corrects the value to be aligned to the nearest pixel"""
+    return round(length_mm / pixel_size) * pixel_size
```

### Comparing `manteia_qa_pylinac-1.0.0/pylinac/core/pdf.py` & `manteia_qa_pylinac-1.1.0/pylinac/core/pdf.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,140 +1,140 @@
-"""Module for constructing and interacting with PDF reports for Pylinac."""
-from __future__ import annotations
-
-import io
-from datetime import datetime
-from pathlib import Path
-from typing import Sequence
-
-from PIL import Image
-from reportlab.lib.pagesizes import A4
-from reportlab.lib.units import cm
-from reportlab.lib.utils import ImageReader
-from reportlab.pdfgen.canvas import Canvas
-
-from .. import __version__
-from .io import get_url
-
-
-def get_logo() -> Path:
-    """Get the Pylinac logo. First try the embedded version, then try the internet.
-    When pylinac is embedded in RadMachine as a package non-py files aren't correctly uncompressed.
-    """
-    logo_file = Path(__file__).parent.parent / "files" / "Pylinac Full cropped.png"
-    if logo_file.exists():
-        return logo_file
-    else:
-        filepath = get_url(
-            url=r"https://storage.googleapis.com/pylinac_demo_files/Pylinac_Full_cropped.png",
-            progress_bar=False,
-        )
-        return Path(filepath)
-
-
-class PylinacCanvas:
-    def __init__(
-        self,
-        filename: str,
-        page_title: str,
-        font: str = "Helvetica",
-        metadata: dict | None = None,
-        metadata_location: tuple = (2, 25.5),
-        logo: Path | str | None = None,
-    ):
-        self.canvas = Canvas(filename, pagesize=A4)
-        self._font = font
-        self._title = page_title
-        self._metadata = metadata
-        self._logo = logo or get_logo()
-        self._metadata_location = metadata_location
-        self._generate_pylinac_template_theme()
-        self._add_metadata()
-
-    def add_new_page(self) -> None:
-        self.canvas.showPage()
-        self._generate_pylinac_template_theme()
-        self._add_metadata()
-
-    def _add_metadata(self) -> None:
-        if self._metadata is None:
-            return
-        else:
-            text = ["Metadata:"]
-            for key, value in self._metadata.items():
-                text.append(f"{key}: {value}")
-            self.add_text(text=text, location=self._metadata_location)
-
-    def _generate_pylinac_template_theme(self) -> None:
-        # draw logo and header separation line
-        self.canvas.drawImage(
-            self._logo,
-            1 * cm,
-            26.5 * cm,
-            width=5 * cm,
-            height=3 * cm,
-            mask="auto",
-            preserveAspectRatio=True,
-        )
-        self.canvas.line(1 * cm, 26.5 * cm, 20 * cm, 26.5 * cm)
-        # draw title
-        self.add_text(text=self._title, location=(7, 28), font_size=24)
-        # draw "generated by pylinac" tag
-        date = datetime.now().strftime("%B %d, %Y, %H:%M")
-        self.add_text(
-            f"Generated with Pylinac v{__version__} on {date}",
-            location=(0.5, 0.5),
-            font_size=8,
-        )
-
-    def add_text(
-        self,
-        text: str | list[str],
-        location: (float, float),
-        font_size: int = 10,
-        font: str | None = None,
-    ) -> None:
-        """Generic text drawing function.
-
-        Parameters
-        ----------
-        location : Sequence of two numbers
-            The first item is the distance from left edge in cm
-            The second item is the distance from bottom edge in cm.
-        text : str, list of strings
-            Text data; if str, prints single line.
-            If list of strings, each list item is printed on its own line.
-        font_size : int
-            Text font size.
-        """
-        font = font or self._font
-        textobj = self.canvas.beginText()
-        textobj.setTextOrigin(location[0] * cm, location[1] * cm)
-        textobj.setFont(font, int(font_size))
-        if isinstance(text, str):
-            textobj.textLine(text)
-        elif isinstance(text, list):
-            for line in text:
-                textobj.textLine(line)
-        self.canvas.drawText(textobj)
-
-    def add_image(
-        self,
-        image_data: io.BytesIO,
-        location: Sequence,
-        dimensions: Sequence,
-        preserve_aspect_ratio: bool = True,
-    ) -> None:
-        image_data.seek(0)
-        image = ImageReader(Image.open(image_data))
-        self.canvas.drawImage(
-            image,
-            location[0] * cm,
-            location[1] * cm,
-            width=dimensions[0] * cm,
-            height=dimensions[1] * cm,
-            preserveAspectRatio=preserve_aspect_ratio,
-        )
-
-    def finish(self) -> None:
-        self.canvas.showPage()
-        self.canvas.save()
+"""Module for constructing and interacting with PDF reports for Pylinac."""
+from __future__ import annotations
+
+import io
+from datetime import datetime
+from pathlib import Path
+from typing import Sequence
+
+from PIL import Image
+from reportlab.lib.pagesizes import A4
+from reportlab.lib.units import cm
+from reportlab.lib.utils import ImageReader
+from reportlab.pdfgen.canvas import Canvas
+
+from .. import __version__
+from .io import get_url
+
+
+def get_logo() -> Path:
+    """Get the Pylinac logo. First try the embedded version, then try the internet.
+    When pylinac is embedded in RadMachine as a package non-py files aren't correctly uncompressed.
+    """
+    logo_file = Path(__file__).parent.parent / "files" / "Pylinac-GREEN.png"
+    if logo_file.exists():
+        return logo_file
+    else:
+        filepath = get_url(
+            url=r"https://storage.googleapis.com/pylinac_demo_files/Pylinac-GREEN.png",
+            progress_bar=False,
+        )
+        return Path(filepath)
+
+
+class PylinacCanvas:
+    def __init__(
+        self,
+        filename: str,
+        page_title: str,
+        font: str = "Helvetica",
+        metadata: dict | None = None,
+        metadata_location: tuple = (2, 25.5),
+        logo: Path | str | None = None,
+    ):
+        self.canvas = Canvas(filename, pagesize=A4)
+        self._font = font
+        self._title = page_title
+        self._metadata = metadata
+        self._logo = logo or get_logo()
+        self._metadata_location = metadata_location
+        self._generate_pylinac_template_theme()
+        self._add_metadata()
+
+    def add_new_page(self) -> None:
+        self.canvas.showPage()
+        self._generate_pylinac_template_theme()
+        self._add_metadata()
+
+    def _add_metadata(self) -> None:
+        if self._metadata is None:
+            return
+        else:
+            text = ["Metadata:"]
+            for key, value in self._metadata.items():
+                text.append(f"{key}: {value}")
+            self.add_text(text=text, location=self._metadata_location)
+
+    def _generate_pylinac_template_theme(self) -> None:
+        # draw logo and header separation line
+        self.canvas.drawImage(
+            self._logo,
+            1 * cm,
+            26.5 * cm,
+            width=5 * cm,
+            height=3 * cm,
+            mask="auto",
+            preserveAspectRatio=True,
+        )
+        self.canvas.line(1 * cm, 26.5 * cm, 20 * cm, 26.5 * cm)
+        # draw title
+        self.add_text(text=self._title, location=(7, 28), font_size=24)
+        # draw "generated by pylinac" tag
+        date = datetime.now().strftime("%B %d, %Y, %H:%M")
+        self.add_text(
+            f"Generated with Pylinac v{__version__} on {date}",
+            location=(0.5, 0.5),
+            font_size=8,
+        )
+
+    def add_text(
+        self,
+        text: str | list[str],
+        location: (float, float),
+        font_size: int = 10,
+        font: str | None = None,
+    ) -> None:
+        """Generic text drawing function.
+
+        Parameters
+        ----------
+        location : Sequence of two numbers
+            The first item is the distance from left edge in cm
+            The second item is the distance from bottom edge in cm.
+        text : str, list of strings
+            Text data; if str, prints single line.
+            If list of strings, each list item is printed on its own line.
+        font_size : int
+            Text font size.
+        """
+        font = font or self._font
+        textobj = self.canvas.beginText()
+        textobj.setTextOrigin(location[0] * cm, location[1] * cm)
+        textobj.setFont(font, int(font_size))
+        if isinstance(text, str):
+            textobj.textLine(text)
+        elif isinstance(text, list):
+            for line in text:
+                textobj.textLine(line)
+        self.canvas.drawText(textobj)
+
+    def add_image(
+        self,
+        image_data: io.BytesIO,
+        location: Sequence,
+        dimensions: Sequence,
+        preserve_aspect_ratio: bool = True,
+    ) -> None:
+        image_data.seek(0)
+        image = ImageReader(Image.open(image_data))
+        self.canvas.drawImage(
+            image,
+            location[0] * cm,
+            location[1] * cm,
+            width=dimensions[0] * cm,
+            height=dimensions[1] * cm,
+            preserveAspectRatio=preserve_aspect_ratio,
+        )
+
+    def finish(self) -> None:
+        self.canvas.showPage()
+        self.canvas.save()
```

### Comparing `manteia_qa_pylinac-1.0.0/pylinac/core/profile.py` & `manteia_qa_pylinac-1.1.0/pylinac/core/profile.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,2295 +1,2357 @@
-from __future__ import annotations  # noqa:I001
-
-import enum
-import math
-import warnings
-from abc import ABC, abstractmethod
-from functools import cached_property
-from typing import Any, Iterable, Literal, Sequence
-
-import argue
-import matplotlib.pyplot as plt
-import numpy as np
-from matplotlib.patches import Circle as mpl_Circle
-from scipy import ndimage, signal
-from scipy.interpolate import UnivariateSpline, interp1d
-from scipy.ndimage import gaussian_filter1d, zoom
-from scipy.optimize import OptimizeWarning, minimize
-from scipy.stats import linregress
-
-# noqa:I001
-from ..metrics.profile import FlatnessDifferenceMetric  # noqa:F401
-from ..metrics.profile import FlatnessRatioMetric  # noqa:F401
-from ..metrics.profile import PenumbraLeftMetric  # noqa:F401
-from ..metrics.profile import PenumbraRightMetric  # noqa:F401
-from ..metrics.profile import SymmetryAreaMetric  # noqa:F401
-from ..metrics.profile import SymmetryPointDifferenceMetric  # noqa:F401
-from ..metrics.profile import SymmetryPointDifferenceQuotientMetric  # noqa:F401
-from ..metrics.profile import LEFT, RIGHT, ProfileMetric
-from . import array_utils as utils
-from . import validators
-from .geometry import Circle, Point
-from .hill import Hill
-from .utilities import convert_to_enum
-
-# for Hill fits of 2D device data the # of points can be small.
-# This results in optimization warnings about the variance of the fit (the variance isn't of concern for us for that particular item)
-warnings.simplefilter("ignore", OptimizeWarning)
-
-
-def gamma_1d(
-    reference: np.ndarray,
-    evaluation: np.ndarray,
-    dose_to_agreement: float = 1,
-    distance_to_agreement: int = 1,
-    gamma_cap_value: float = 2,
-    global_dose: bool = True,
-    dose_threshold: float = 5,
-    fill_value: float = np.nan,
-) -> np.ndarray:
-    """Perform a 1D gamma of two 1D profiles/arrays. This does NOT check lengths or
-    spatial consistency. It performs an element-by-element evaluation. It is the responsibility
-    of the caller to ensure the reference and evaluation have comparable spatial resolution.
-
-    The algorithm follows Table I of D. Low's 2004 paper: Evaluation of the gamma dose distribution comparison method: https://aapm.onlinelibrary.wiley.com/doi/epdf/10.1118/1.1598711
-
-    Parameters
-    ----------
-
-    reference
-        The reference profile.
-    evaluation
-        The evaluation profile.
-    dose_to_agreement
-        The dose to agreement in %. E.g. 1 is 1% of global reference max dose.
-    distance_to_agreement
-        The distance to agreement in **elements**. E.g. if the value is 4 this means 4 elements from the reference point under calculation.
-        Must be >0
-    gamma_cap_value
-        The value to cap the gamma at. E.g. a gamma of 5.3 will get capped to 2. Useful for displaying data with a consistent range.
-    global_dose
-        Whether to evaluate the dose to agreement threshold based on the global max or the dose point under evaluation.
-    dose_threshold
-        The dose threshold as a number between 0 and 100 of the % of max dose under which a gamma is not calculated.
-        This is not affected by the global/local dose normalization and the threshold value is evaluated against the global max dose, period.
-    fill_value
-        The value to give pixels that were not calculated because they were under the dose threshold. Default
-        is NaN, but another option would be 0. If NaN, allows the user to calculate mean/median gamma over just the
-        evaluated portion and not be skewed by 0's that should not be considered.
-    """
-    if reference.ndim != 1 or evaluation.ndim != 1:
-        raise ValueError(
-            f"Reference and evaluation arrays must be 1D. Got reference: {reference.ndim} and evaluation: {evaluation.ndim}"
-        )
-    threshold = reference.max() / 100 * dose_threshold
-    # convert dose to agreement to % of global max; ignored later if local dose
-    dose_ta = dose_to_agreement / 100 * reference.max()
-    # pad eval array on both edges so our search does not go out of bounds
-    eval_padded = np.pad(evaluation, distance_to_agreement, mode="edge")
-    # iterate over each reference element, computing distance value and dose value
-    gamma = []
-    for r_idx, ref_point in enumerate(reference):
-        # skip if below dose threshold
-        if ref_point < threshold:
-            gamma.append(fill_value)
-            continue
-        # we search at the same indices in eval_padded, but remember eval_padded has extra indices on each edge,
-        # so this is actually searching from -DTA to +DTA because r_idx in eval_padded is off by distance_to_agreement.
-        capital_gammas = []
-        for e_idx, eval_point in enumerate(
-            eval_padded[r_idx : r_idx + 2 * distance_to_agreement + 1]
-        ):
-            dist = abs(e_idx - distance_to_agreement)
-            dose = eval_point - ref_point
-            if not global_dose:
-                dose_ta = dose_to_agreement / 100 * ref_point
-            capital_gamma = math.sqrt(
-                dist**2 / distance_to_agreement**2 + dose**2 / dose_ta**2
-            )
-            capital_gammas.append(capital_gamma)
-        gamma.append(min(min(capital_gammas), gamma_cap_value))
-    return np.asarray(gamma)
-
-
-def stretch(
-    array: np.ndarray, min: int = 0, max: int = 1, fill_dtype: np.dtype | None = None
-) -> np.ndarray:
-    """'Stretch' the profile to the fit a new min and max value and interpolate in between.
-    From: http://www.labri.fr/perso/nrougier/teaching/numpy.100/  exercise #17
-
-    .. deprecated:: 3.11
-
-    Parameters
-    ----------
-    array: numpy.ndarray
-        The numpy array to stretch.
-    min : number
-        The new minimum of the values.
-    max : number
-        The new maximum value.
-    fill_dtype : numpy data type
-        If None (default), the array will be stretched to the passed min and max.
-        If a numpy data type (e.g. np.int16), the array will be stretched to fit the full range of values
-        of that data type. If a value is given for this parameter, it overrides ``min`` and ``max``.
-    """
-    warnings.warn(
-        "Using stretch from the profile module is deprecated. Use 'stretch' from the pylinac.core.array_utils module",
-        DeprecationWarning,
-    )
-    new_max = max
-    if fill_dtype is not None:
-        try:
-            di = np.iinfo(fill_dtype)
-        except ValueError:
-            di = np.finfo(fill_dtype)
-        new_max = di.max
-    # perfectly normalize the array (0..1). ground, then div by range
-    stretched_array = (array - array.min()) / (array.max() - array.min())
-    # stretch normalized array to new max/min
-    stretched_array *= new_max
-    # stretched_array += new_min
-    if fill_dtype:
-        stretched_array = stretched_array.astype(fill_dtype)
-    return stretched_array
-
-
-class ProfileMixin:
-    """A mixin to provide various manipulations of 1D profile data."""
-
-    values: np.ndarray
-
-    def invert(self) -> None:
-        """Invert the profile."""
-        self.values = utils.invert(self.values)
-
-    def bit_invert(self) -> None:
-        """Invert the profile bit-wise."""
-        self.values = utils.bit_invert(self.values)
-
-    def normalize(self, norm_val: str | float | None = None) -> None:
-        """Normalize the profile to the given value.
-
-        Parameters
-        ----------
-        norm_val : number or 'max' or None
-            If a number, normalize the array to that number. If None, normalizes to the maximum value.
-        """
-        # backwards compatibility
-        if norm_val == "max":
-            norm_val = None
-        self.values = utils.normalize(self.values, value=norm_val)
-
-    def stretch(self, min: float = 0, max: float = 1) -> None:
-        """'Stretch' the profile to the min and max parameter values.
-
-        Parameters
-        ----------
-        min : number
-            The new minimum of the values
-        max : number
-            The new maximum value.
-        """
-        self.values = utils.stretch(self.values, min=min, max=max)
-
-    def convert_to_dtype(self, dtype: type[np.dtype]) -> None:
-        """Convert the profile datatype to another datatype while retaining the values relative to the datatype min/max"""
-        self.values = utils.convert_to_dtype(self.values, dtype=dtype)
-
-    def ground(self) -> float:
-        """Ground the profile such that the lowest value is 0.
-
-        Returns
-        -------
-        float
-            The minimum value that was used as the grounding value.
-        """
-        min_val = self.values.min()
-        self.values = utils.ground(self.values)
-        return min_val
-
-    def filter(self, size: float = 0.05, kind: str = "median") -> None:
-        """Filter the profile.
-
-        Parameters
-        ----------
-        size : float, int
-            Size of the median filter to apply.
-            If a float, the size is the ratio of the length. Must be in the range 0-1.
-            E.g. if size=0.1 for a 1000-element array, the filter will be 100 elements.
-            If an int, the filter is the size passed.
-        kind : {'median', 'gaussian'}
-            The kind of filter to apply. If gaussian, `size` is the sigma value.
-        """
-        self.values = utils.filter(self.values, size=size, kind=kind)
-
-    def __len__(self):
-        return len(self.values)
-
-    def __getitem__(self, items):
-        return self.values[items]
-
-
-class Interpolation(enum.Enum):
-    """Interpolation Enum"""
-
-    NONE = None  #:
-    LINEAR = "Linear"  #:
-    SPLINE = "Spline"  #:
-
-
-class Normalization(enum.Enum):
-    """Normalization method Enum"""
-
-    NONE = None  #:
-    GEOMETRIC_CENTER = "Geometric center"  #:
-    BEAM_CENTER = "Beam center"  #:
-    MAX = "Max"  #:
-
-
-class Edge(enum.Enum):
-    """Edge detection Enum"""
-
-    FWHM = "FWHM"  #:
-    INFLECTION_DERIVATIVE = "Inflection Derivative"  #:
-    INFLECTION_HILL = "Inflection Hill"  #:
-
-
-class Centering(enum.Enum):
-    """See :ref:`centering`"""
-
-    MANUAL = "Manual"  #:
-    BEAM_CENTER = "Beam center"  #:
-    GEOMETRIC_CENTER = "Geometric center"  #:
-
-
-class ProfileBase(ProfileMixin, ABC):
-    """The base class for multiple type of profiles. This class should not be instantiated directly.
-
-    We use a base class to avoid having long stacked if statements for the different detection patterns.
-    This is also more explicit and extensible."""
-
-    metrics: list[ProfileMetric]
-    metric_values: dict[str, float]
-
-    def __init__(
-        self,
-        values: np.array,
-        x_values: np.array | None = None,
-        ground: bool = False,
-        normalization: str | Normalization = Normalization.NONE,
-        interpolation_order: int = 1,
-    ):
-        """A 1D profile that has one large signal, e.g. a radiation beam profile.
-        Signal analysis methods are given, mostly based on FWXM and on Hill function calculations.
-        Profiles with multiple peaks are better suited by the MultiProfile class.
-        """
-        validators.single_dimension(values)
-        self.metrics = []
-        self.metric_values = {}
-        self._interp_order = interpolation_order
-        if x_values is None:
-            x_values = np.arange(len(values))
-        x_diff = np.diff(x_values)
-        if x_diff.max() > 0 > x_diff.min():
-            raise ValueError("X values must be monotonically increasing or decreasing")
-        # resort in case we are in descending order
-        sort_idxs = np.argsort(x_values)
-        x_values = x_values[sort_idxs]
-        values = values[sort_idxs]
-        self.values = values
-        self.x_values = x_values
-        if ground:
-            self.values = utils.ground(values)
-        if normalization == Normalization.MAX:
-            self.normalize()
-        elif normalization == Normalization.GEOMETRIC_CENTER:
-            center_val = utils.geometric_center_value(self.values)
-            self.normalize(center_val)
-        elif normalization == Normalization.BEAM_CENTER:
-            beam_center_val = self.y_at_x(self.center_idx)
-            self.normalize(beam_center_val)
-
-    def x_at_x(self, x: float) -> np.ndarray:
-        """Deprecated alias for x_at_x_idx"""
-        warnings.warn(
-            "x_at_x is deprecated. Use x_at_x_idx instead", DeprecationWarning
-        )
-        return self.x_at_x_idx(x)
-
-    def x_at_x_idx(self, x: float | np.ndarray) -> np.ndarray | float:
-        """Return the physical x-value at the given index. When no x-values are provided, these are the same.
-        However, physical dimensions can be different than the index."""
-        # UnivariateSpline is the newer approach than interp1d
-        # interp1d is legacy and may be removed in the future
-        # we create an interpolation for x-values so we can
-        # get the original x-value when the index is a float (very often the case)
-        f = UnivariateSpline(
-            x=np.arange(len(self.x_values)), y=self.x_values, k=self._interp_order, s=0
-        )
-        new_x = f(x)
-        if new_x.size == 1:
-            return float(new_x)
-        return f(x)
-
-    def x_idx_at_x(self, x: float) -> int:
-        """Return the **index** of the x-value closest to the given x-value."""
-        return int(np.argmin(np.abs(self.x_values - x)))
-
-    def y_at_x(self, x: float | np.ndarray) -> np.ndarray | float:
-        """Interpolated y-values. The x-value is the physical position, not the index. However, if no x-values were provided, these will be the same."""
-        f = UnivariateSpline(x=self.x_values, y=self.values, k=self._interp_order, s=0)
-        new_y = f(x)
-        if new_y.size == 1:
-            return float(new_y)
-        return new_y
-
-    def x_at_y(self, y: float | np.ndarray, side: str) -> np.ndarray | float:
-        """Interpolated y-values. Can use floats as indices."""
-        # I can't get UnivariateSpline to work here because it wants strictly increasing
-        # data. So we use interp1d instead
-        s = self.x_idx_at_x(self.center_idx)
-        if side == LEFT:
-            f = interp1d(x=self.values[:s], y=self.x_values[:s])
-        elif side == RIGHT:
-            f = interp1d(x=self.values[s:], y=self.x_values[s:])
-        new_x = f(y)
-        if new_x.size == 1:
-            return float(new_x)
-        return f(y)
-
-    @abstractmethod
-    def field_edge_idx(self, side: str) -> float:
-        """The index of the field edge, given the side and edge detection method."""
-        pass
-
-    def field_indices(self, in_field_ratio: float) -> (int, int, int):
-        """Return the indices of the left and right edge of the field, given the in-field ratio.
-        Importantly, this will use the same rounding behavior as field_values.
-        """
-        xs = self.field_x_values(in_field_ratio)
-        left = xs[0]
-        right = xs[-1]
-        width = max(right, left) - min(right, left)
-        return left, right, width
-
-    def field_x_values(self, in_field_ratio: float) -> np.ndarray:
-        """Return the x-values of the field, given the in-field ratio.
-        This is helpful when plotting the field to include the proper x-values as well.
-        """
-        left = self.field_edge_idx(side=LEFT)
-        right = self.field_edge_idx(side=RIGHT)
-        width = self.field_width_px
-        f_left = left + (1 - in_field_ratio) / 2 * width
-        f_right = right - (1 - in_field_ratio) / 2 * width
-        # use floor/ceil to be inclusive of the edges
-        lower_bound = math.floor(min((f_left, f_right)))
-        upper_bound = math.ceil(max((f_left, f_right)))
-        inner_range = np.nonzero(
-            (self.x_values >= lower_bound) & (self.x_values <= upper_bound)
-        )[0]
-        return self.x_values[inner_range]
-
-    @cached_property
-    def center_idx(self) -> float:
-        """The center index of the profile. Halfway between the field edges."""
-        left = self.field_edge_idx(side=LEFT)
-        right = self.field_edge_idx(side=RIGHT)
-        return abs(right - left) / 2 + left
-
-    @cached_property
-    def field_width_px(self) -> float:
-        """The field width of the profile in pixels"""
-        left_idx = self.field_edge_idx(side=LEFT)
-        right_idx = self.field_edge_idx(side=RIGHT)
-        return max(right_idx, left_idx) - min(right_idx, left_idx)
-
-    def field_values(
-        self,
-        in_field_ratio: float = 0.8,
-    ) -> np.ndarray:
-        """The array of values of the profile within the 'field' area. This is typically 80% of the detected
-        field width."""
-        x_values = self.field_x_values(in_field_ratio)
-        return self.y_at_x(x_values)
-
-    def as_resampled(
-        self, interpolation_factor: float = 10, order: int = 3, **kwargs
-    ) -> Any:
-        """Resample the profile at a new resolution. Returns a new profile.
-
-        Parameters
-        ----------
-        interpolation_factor : float
-            The factor to zoom the profile by. E.g. 10 means the profile will be 10x larger.
-        order : int
-            The order of the spline interpolation. 1 is linear, 3 is cubic, etc.
-
-        Warnings
-        --------
-        This method will respect the input datatype of the numpy array. If the input array is a float, the output array will be a float.
-        This can cause issues for int arrays with a small range. E.g. if the range is only 10, interpolation
-        will look more step-like than smooth. If this is the case, convert the array to a float before passing it to this method.
-        The array is not automatically converted to float in this case to respect the original dtype. However,
-        a warning will be produced.
-        """
-        arr_range = self.values.max() - self.values.min()
-        if self.values.dtype != float and arr_range < 100:
-            warnings.warn(
-                f"Array range is small ({arr_range}) and is not a float. Interpolation may look step-like. "
-                f"Consider converting the array to a float before passing it to this method.",
-                UserWarning,
-            )
-        new_y = zoom(
-            self.values,
-            zoom=interpolation_factor,
-            order=order,
-            grid_mode=False,
-            mode="nearest",
-        )
-        new_x = np.linspace(self.x_values.min(), self.x_values.max(), len(new_y))
-
-        return type(self)(
-            values=new_y,
-            x_values=new_x,
-            ground=False,
-            normalization=Normalization.NONE,
-            **kwargs,
-        )
-
-    def plot(
-        self,
-        show: bool = True,
-        axis: plt.Axes | None = None,
-        show_field_edges: bool = True,
-        show_grid: bool = True,
-        show_center: bool = True,
-    ) -> plt.Axes:
-        """Plot the profile along with relevant overlays to point out features."""
-        if axis is None:
-            _, axis = plt.subplots()
-        axis.plot(self.x_values, self.values, label="Data")
-        if show_field_edges:
-            axis.axvline(self.field_edge_idx(side=LEFT), ls="--", label="Field Edges")
-            axis.axvline(self.field_edge_idx(side=RIGHT), ls="--")
-        if show_center:
-            axis.axvline(self.center_idx, ls=":", label="Center")
-        for metric in self.metrics:
-            metric.plot(axis)
-        axis.grid(show_grid)
-        axis.legend()
-        if show:
-            plt.show()
-        return axis
-
-    def compute(
-        self, metrics: Iterable[ProfileMetric] | ProfileMetric
-    ) -> Any | dict[str, Any]:
-        """Compute metric(s) on the profile.
-
-        Unlike other modules, calling ``compute`` is not strictly necessary.
-        Only call it if there are metrics to calculate.
-
-        Parameters
-        ----------
-        metrics: iterable of ProfileMetric | ProfileMetric
-            List of metrics to calculate. If only one metric is desired, it can be passed directly.
-
-        Returns
-        -------
-        dict | list
-            A dictionary of metric names and values if multiple metrics were given.
-            If only one metric was given, the value of that metric is returned.
-
-        """
-        self.metric_values = {}
-        self.metrics = []
-        values = {}
-        if isinstance(metrics, ProfileMetric):
-            metrics = [metrics]
-        for metric in metrics:
-            metric.inject_profile(self)
-            self.metrics.append(metric)
-            values[metric.name] = metric.calculate()
-        self.metric_values |= values
-        if len(values) == 1:
-            return list(values.values())[0]
-        else:
-            return values
-
-
-class FWXMProfile(ProfileBase):
-    """A profile that has one large signal, e.g. a radiation beam profile and data derived from it is based on
-    the Full-Width X-Maximum to find the edge indices"""
-
-    def __init__(
-        self,
-        values: np.array,
-        x_values: np.array | None = None,
-        ground: bool = False,
-        normalization: str | Normalization = Normalization.NONE,
-        fwxm_height: float = 50,
-    ):
-        """A 1D profile that has one large signal, e.g. a radiation beam profile.
-        Signal analysis methods are given, mostly based on FWXM and on Hill function calculations.
-        Profiles with multiple peaks are better suited by the MultiProfile class.
-        """
-        self.fwxm_height = fwxm_height
-        super().__init__(
-            values=values,
-            x_values=x_values,
-            ground=ground,
-            normalization=normalization,
-        )
-
-    def field_edge_idx(self, side: Literal["right", "left"]) -> float:
-        """The edge index of the given side using the FWXM methodology"""
-        _, peak_props = find_peaks(
-            self.values, fwxm_height=self.fwxm_height / 100, max_number=1
-        )
-        if side == LEFT:
-            idx = peak_props["left_ips"][0]
-        elif side == RIGHT:
-            idx = peak_props["right_ips"][0]
-        return self.x_at_x_idx(idx)
-
-    def as_resampled(
-        self, interpolation_factor: float = 10, order: int = 3
-    ) -> FWXMProfile:
-        """Resample the profile at a new resolution. Returns a new profile.
-
-        Parameters
-        ----------
-        interpolation_factor : float
-            The factor to zoom the profile by. E.g. 10 means the profile will be 10x larger.
-        order : int
-            The order of the spline interpolation. 1 is linear, 3 is cubic, etc.
-        """
-        return super().as_resampled(
-            interpolation_factor=interpolation_factor,
-            order=order,
-            fwxm_height=self.fwxm_height,
-        )
-
-
-class InflectionDerivativeProfile(ProfileBase):
-    """A profile that has one large signal, e.g. a radiation beam profile and data derived from it is based on
-    the Full-Width X-Maximum"""
-
-    def __init__(
-        self,
-        values: np.array,
-        x_values: np.array | None = None,
-        ground: bool = False,
-        normalization: str | Normalization = Normalization.NONE,
-        edge_smoothing_ratio: float = 0.003,
-    ):
-        """A 1D profile that has one large signal, e.g. a radiation beam profile.
-        Signal analysis methods are given, mostly based on FWXM and on Hill function calculations.
-        Profiles with multiple peaks are better suited by the MultiProfile class.
-        """
-        self.edge_smoothing_ratio = edge_smoothing_ratio
-        super().__init__(
-            values=values,
-            x_values=x_values,
-            ground=ground,
-            normalization=normalization,
-        )
-
-    def field_edge_idx(self, side: str) -> float:
-        """The edge index of the given side using the second derivative methodology"""
-        filtered_values = gaussian_filter1d(
-            self.values, sigma=self.edge_smoothing_ratio * len(self.values)
-        )
-        diff = np.gradient(filtered_values)
-        f_diff = interp1d(x=self.x_values, y=diff, kind="cubic")
-
-        if side == LEFT:
-            initial_guess = self.x_at_x_idx(np.argmax(diff))
-            idx = minimize(lambda x: -f_diff(x), x0=initial_guess).x[0]
-        else:
-            initial_guess = self.x_at_x_idx(np.argmin(diff))
-            idx = minimize(f_diff, x0=initial_guess).x[0]
-        return idx
-
-    def as_resampled(
-        self, interpolation_factor: float = 10, order: int = 3
-    ) -> InflectionDerivativeProfile:
-        return super().as_resampled(
-            interpolation_factor=interpolation_factor,
-            order=order,
-            edge_smoothing_ratio=self.edge_smoothing_ratio,
-        )
-
-
-class HillProfile(InflectionDerivativeProfile):
-    """A profile that has one large signal, e.g. a radiation beam profile and data derived from it is based on
-    the Full-Width X-Maximum"""
-
-    def __init__(
-        self,
-        values: np.array,
-        x_values: np.array | None = None,
-        ground: bool = False,
-        normalization: str = Normalization.NONE,
-        edge_smoothing_ratio: float = 0.003,
-        hill_window_ratio: float = 0.1,
-    ):
-        """A 1D profile that has one large signal, e.g. a radiation beam profile.
-        Signal analysis methods are given, mostly based on FWXM and on Hill function calculations.
-        Profiles with multiple peaks are better suited by the MultiProfile class.
-        """
-        self.hill_window_ratio = hill_window_ratio
-        super().__init__(
-            values=values,
-            x_values=x_values,
-            ground=ground,
-            normalization=normalization,
-            edge_smoothing_ratio=edge_smoothing_ratio,
-        )
-
-    def field_edge_idx(self, side: str) -> float:
-        """The edge index of the given side using the FWXM methodology"""
-        left_infl_idx = super().field_edge_idx(side=LEFT)
-        right_infl_idx = super().field_edge_idx(side=RIGHT)
-        window_size = (right_infl_idx - left_infl_idx) * self.hill_window_ratio
-        if side == LEFT:
-            left = int(round(left_infl_idx - window_size))
-            right = int(round(left_infl_idx + window_size))
-            x_data = self.x_values[left : right + 1]
-            y_data = self.values[left : right + 1]
-        else:
-            left = int(round(right_infl_idx - window_size))
-            right = int(round(right_infl_idx + window_size))
-            x_data = self.x_values[left : right + 1]
-            y_data = self.values[left : right + 1]
-        hill_fit = Hill.fit(x_data=x_data, y_data=y_data)
-        idx = hill_fit.inflection_idx()["index (exact)"]
-        return self.x_at_x_idx(idx)
-
-    def as_resampled(
-        self, interpolation_factor: float = 10, order: int = 3
-    ) -> HillProfile:
-        return ProfileBase.as_resampled(
-            self,
-            interpolation_factor=interpolation_factor,
-            order=order,
-            edge_smoothing_ratio=self.edge_smoothing_ratio,
-            hill_window_ratio=self.hill_window_ratio,
-        )
-
-
-class PhysicalProfileMixin:
-    """A mixin when the profile has a physical component.
-    This is pretty typical for EPID profiles, etc. The mixin
-    adds a few methods that take physical distance into account."""
-
-    x_values: np.ndarray
-    values: np.ndarray
-    field_width_px: float
-
-    def __init__(
-        self,
-        dpmm: float,
-    ):
-        self.dpmm = dpmm
-
-    @cached_property
-    def field_width_mm(self) -> float:
-        """The field width of the profile in mm"""
-        return self.field_width_px / self.dpmm
-
-    def as_resampled(
-        self,
-        interpolation_resolution_mm: float = 0.1,
-        order: int = 3,
-        grid: bool = True,
-    ) -> Any:
-        """Resample the physical profile at a new resolution. Returns a new profile.
-
-        Parameters
-        ----------
-        interpolation_resolution_mm : float
-            The resolution to resample to in mm. E.g. 0.1 means the profile will be 0.1 mm resolution.
-        order : int
-            The order of the spline interpolation. 1 is linear, 3 is cubic, etc.
-        grid : bool
-            Whether to use grid mode when zooming. See parameter ``grid_mode`` in :func:`~scipy.ndimage.zoom` for more information.
-            This should be true unless you are resampling an already-resampled physical array.
-
-        Warnings
-        --------
-        This method will respect the input datatype of the numpy array. If the input array is a float, the output array will be a float.
-        This can cause issues for int arrays with a small range. E.g. if the range is only 10, interpolation
-        will look more step-like than smooth. If this is the case, convert the array to a float before passing it to this method.
-        The array is not automatically converted to float in this case to respect the original dtype. However,
-        a warning will be produced.
-        """
-        arr_range = self.values.max() - self.values.min()
-        if self.values.dtype != float and arr_range < 100:
-            warnings.warn(
-                f"Array range is small ({arr_range}) and is not a float. Interpolation may look step-like. "
-                f"Consider converting the array to a float before passing it to this method.",
-                UserWarning,
-            )
-
-        factor = 1 / (self.dpmm * interpolation_resolution_mm)
-        #  When dealing with physical arrays where each pixel/voxel is a physical distance, it is important to
-        #  use grid mode when zooming. This is because each pixel/voxel has a physical size.
-        #  See parameter ``grid_mode`` in :func:`~scipy.ndimage.zoom` for more information.
-        new_y = zoom(
-            self.values,
-            zoom=factor,
-            order=order,
-            grid_mode=grid,
-            mode="nearest",
-        )
-        # similarly, we assume that x-values are also physical
-        # we thus have to offset the x-values by half a pixel/voxel
-        # while accounting for the physical size of the pixel/voxel
-        if grid:
-            offset = 0.5 - 1 / (2 * factor)
-            new_x = np.linspace(
-                self.x_values.min() - offset, self.x_values.max() + offset, len(new_y)
-            )
-        else:
-            new_x = np.linspace(self.x_values.min(), self.x_values.max(), len(new_y))
-
-        return type(self)(
-            values=new_y,
-            x_values=new_x,
-            ground=False,
-            normalization=Normalization.NONE,
-            dpmm=factor * self.dpmm,
-        )
-
-
-class FWXMProfilePhysical(PhysicalProfileMixin, FWXMProfile):
-    def __init__(
-        self,
-        values: np.array,
-        dpmm: float,
-        x_values: np.array | None = None,
-        ground: bool = False,
-        normalization: str | Normalization = Normalization.NONE,
-        fwxm_height: float = 50,
-    ):
-        FWXMProfile.__init__(
-            self,
-            values=values,
-            x_values=x_values,
-            ground=ground,
-            normalization=normalization,
-            fwxm_height=fwxm_height,
-        )
-        PhysicalProfileMixin.__init__(self, dpmm=dpmm)
-
-    def as_resampled(
-        self,
-        interpolation_resolution_mm: float = 0.1,
-        order: int = 3,
-        grid: bool = True,
-    ) -> FWXMProfilePhysical:
-        return super().as_resampled(
-            interpolation_resolution_mm=interpolation_resolution_mm,
-            order=order,
-            grid=grid,
-        )
-
-
-class InflectionDerivativeProfilePhysical(
-    PhysicalProfileMixin, InflectionDerivativeProfile
-):
-    def __init__(
-        self,
-        values: np.array,
-        dpmm: float,
-        x_values: np.array | None = None,
-        ground: bool = False,
-        normalization: str | Normalization = Normalization.NONE,
-        edge_smoothing_ratio: float = 0.003,
-    ):
-        InflectionDerivativeProfile.__init__(
-            self,
-            values=values,
-            x_values=x_values,
-            ground=ground,
-            normalization=normalization,
-            edge_smoothing_ratio=edge_smoothing_ratio,
-        )
-        PhysicalProfileMixin.__init__(self, dpmm=dpmm)
-
-    def as_resampled(
-        self,
-        interpolation_resolution_mm: float = 0.1,
-        order: int = 3,
-        grid: bool = True,
-    ) -> InflectionDerivativeProfilePhysical:
-        return super().as_resampled(
-            interpolation_resolution_mm=interpolation_resolution_mm,
-            order=order,
-            grid=grid,
-        )
-
-
-class HillProfilePhysical(PhysicalProfileMixin, HillProfile):
-    def __init__(
-        self,
-        values: np.array,
-        dpmm: float,
-        x_values: np.array | None = None,
-        ground: bool = False,
-        normalization: str | Normalization = Normalization.NONE,
-        edge_smoothing_ratio: float = 0.003,
-        hill_window_ratio: float = 0.1,
-    ):
-        HillProfile.__init__(
-            self,
-            values=values,
-            x_values=x_values,
-            ground=ground,
-            normalization=normalization,
-            edge_smoothing_ratio=edge_smoothing_ratio,
-            hill_window_ratio=hill_window_ratio,
-        )
-        PhysicalProfileMixin.__init__(self, dpmm=dpmm)
-
-    def as_resampled(
-        self,
-        interpolation_resolution_mm: float = 0.1,
-        order: int = 3,
-        grid: bool = True,
-    ) -> HillProfilePhysical:
-        return super().as_resampled(
-            interpolation_resolution_mm=interpolation_resolution_mm,
-            order=order,
-            grid=grid,
-        )
-
-
-class SingleProfile(ProfileMixin):
-    """A profile that has one large signal, e.g. a radiation beam profile.
-    Signal analysis methods are given, mostly based on FWXM and on Hill function calculations.
-    Profiles with multiple peaks are better suited by the MultiProfile class.
-    """
-
-    def __init__(
-        self,
-        values: np.ndarray,
-        dpmm: float = None,
-        interpolation: Interpolation | str | None = Interpolation.LINEAR,
-        ground: bool = True,
-        interpolation_resolution_mm: float = 0.1,
-        interpolation_factor: float = 10,
-        normalization_method: Normalization | str = Normalization.BEAM_CENTER,
-        edge_detection_method: Edge | str = Edge.FWHM,
-        edge_smoothing_ratio: float = 0.003,
-        hill_window_ratio: float = 0.1,
-        x_values: np.ndarray | None = None,
-    ):
-        """
-        Parameters
-        ----------
-        values
-            The profile numpy array. Must be 1D.
-        dpmm
-            The dots (pixels) per mm. Pass to get info like beam width in distance units in addition to pixels
-        interpolation
-            Interpolation technique.
-        ground
-            Whether to ground the profile (set min value to 0). Helpful most of the time.
-        interpolation_resolution_mm
-            The resolution that the interpolation will scale to. **Only used if dpmm is passed and interpolation is set**.
-            E.g. if the dpmm is 0.5 and the resolution is set to 0.1mm the data will be interpolated to have a new dpmm of 10 (1/0.1).
-        interpolation_factor
-            The factor to multiply the data by. **Only used if interpolation is used and dpmm is NOT passed**. E.g. 10
-            will perfectly decimate the existing data according to the interpolation method passed.
-        normalization_method
-            How to pick the point to normalize the data to.
-        edge_detection_method
-            The method by which to detect the field edge. FWHM is reasonable most of the time except for FFF beams.
-            Inflection-derivative will use the max gradient to determine the field edge. Note that this may not be the
-            50% height. In fact, for FFF beams it shouldn't be. Inflection methods are better for FFF and other unusual
-            beam shapes.
-        edge_smoothing_ratio
-            **Only applies to INFLECTION_DERIVATIVE and INFLECTION_HILL.**
-
-            The ratio of the length of the values to use as the sigma for a Gaussian filter applied before searching for
-            the inflection. E.g. 0.005 with a profile of 1000 points will result in a sigma of 5.
-            This helps make the inflection point detection more robust to noise. Increase for noisy data.
-        hill_window_ratio
-            The ratio of the field size to use as the window to fit the Hill function. E.g. 0.2 will using a window
-            centered about each edge with a width of 20% the size of the field width. **Only applies when the edge
-            detection is INFLECTION_HILL**.
-        x_values
-            The x-values of the profile, if any. If None, will generate a simple range(len(values)).
-        """
-        self._interp_method = convert_to_enum(interpolation, Interpolation)
-        self._interpolation_res = interpolation_resolution_mm
-        self._interpolation_factor = interpolation_factor
-        self._norm_method = convert_to_enum(normalization_method, Normalization)
-        self._edge_method = convert_to_enum(edge_detection_method, Edge)
-        self._edge_smoothing_ratio = edge_smoothing_ratio
-        self._hill_window_ratio = hill_window_ratio
-        self.values = (
-            values  # set initial data so we can do things like find beam center
-        )
-        self.dpmm = dpmm
-        fitted_values, new_dpmm, x_indices = self._interpolate(
-            values,
-            x_values,
-            dpmm,
-            interpolation_resolution_mm,
-            interpolation_factor,
-            self._interp_method,
-        )
-        self.values = fitted_values
-        self.x_indices = x_indices
-        self._x_interp1d = interp1d(list(range(len(x_indices))), x_indices)
-        self._ground = ground
-        if ground:
-            fitted_values -= fitted_values.min()
-        self._y_interp1d = interp1d(
-            x_indices, fitted_values, bounds_error=False, fill_value="extrapolate"
-        )
-        norm_values = self._normalize(fitted_values, self._norm_method)
-        self.values = norm_values  # update values
-        self._y_interp1d = interp1d(
-            x_indices, norm_values, bounds_error=False, fill_value="extrapolate"
-        )
-
-    def _x_interp_to_original(self, location: float | np.ndarray) -> float | np.ndarray:
-        """Get the x-value of the (possibly) interpolated profile. The input value is in the original
-        value range. E.g. a profile with x-range of 0-10 is interpolated to 10x. Asking for the location at 99 would scale back to 9.9.
-        We need this function because peak finding is independent of the x-values. I.e. peaks are found and reported according
-        to the (0, len(x_values)) range. If the x-values are interpolated we need to get back to the original x-value.
-        """
-        x = self._x_interp1d(location)
-        if isinstance(location, (float, int)) or location.size == 1:
-            return float(x)
-        return x
-
-    def _y_original_to_interp(self, location: float | np.ndarray) -> float | np.ndarray:
-        """Get the interpolated y-value of the profile. This is a corollary to the _x_interp... function"""
-        y = self._y_interp1d(location)
-        if isinstance(location, (float, int)) or location.size == 1:
-            return float(y)
-        return y
-
-    def resample(
-        self, interpolation_factor: int = 10, interpolation_resolution_mm: float = 0.1
-    ) -> SingleProfile:
-        """Resample the profile at a new resolution. Returns a new profile"""
-        # we have to set the dpmm to what it currently is after interpolating to resample.
-        if self.dpmm:
-            dpmm = 1 / self._interpolation_res
-        else:
-            dpmm = None
-        return SingleProfile(
-            values=self.values,
-            x_values=self.x_indices,
-            dpmm=dpmm,
-            interpolation=self._interp_method,
-            ground=self._ground,
-            interpolation_resolution_mm=interpolation_resolution_mm,
-            interpolation_factor=interpolation_factor,
-            normalization_method=self._norm_method,
-            edge_detection_method=self._edge_method,
-            edge_smoothing_ratio=self._edge_smoothing_ratio,
-            hill_window_ratio=self._hill_window_ratio,
-        )
-
-    @staticmethod
-    def _interpolate(
-        values,
-        x_values,
-        dpmm,
-        interpolation_resolution,
-        interpolation_factor,
-        interp_method: Interpolation,
-    ) -> (np.ndarray, float, float, float):
-        """Fit the data to the passed interpolation method. Will also calculate the new values to correct the measurements such as dpmm"""
-        if x_values is None:
-            x_values = np.array(range(len(values)))
-        if np.diff(x_values).min() < 0:
-            raise ValueError("Profile values must be monotonically increasing")
-        if interp_method == Interpolation.NONE:
-            return values, dpmm, x_values  # do nothing
-        else:
-            if dpmm is not None:
-                samples = int(round(len(x_values) / (dpmm * interpolation_resolution)))
-                new_dpmm = 1 / interpolation_resolution
-            else:
-                samples = int(round(len(x_values) * interpolation_factor))
-                new_dpmm = None
-            # Warning: BMF ahead
-            # the problem is that if we upsample, the left and right ends are not equally sampled.
-            # E.g. upsampling a 3-pixel array (0, 1, 2) by 10 normally results in ~20 elements. You
-            # interpolate between 0 and 1, and 1 and 2.
-            # The first issue is that you do not have a simple X proportion of
-            # elements (3 * 10 = 30 but we get 20). Additionally, if these are pixels they have a
-            # finite, physical size and technically those values are at the center of the pixels.
-            # Thus, you actually need to sample beyond the left and right edges. In the
-            # above case you'd really need to sample from approximately -0.5 to 2.5 to get ~10 pixels
-            # for each original pixel. We also need to offset the x-values to be back to 0 again from -0.5.
-            # We solve this by offsetting the new x-values by a proportion of the sampling ratio.
-            # A ratio of 1 (identical sampling) should not have any offset and return the same values
-            # As the ratio goes up, we approach the limit of 0.5 pixels. This follows a proportional relationship
-            # with the ratio.
-            resampling_factor = samples / len(values)
-            offset = 0.5 - 1 / (2 * resampling_factor)
-            if interp_method == Interpolation.LINEAR:
-                kind = "linear"
-            elif interp_method == Interpolation.SPLINE:
-                kind = "cubic"
-            f = interp1d(
-                x_values,
-                values,
-                kind=kind,
-                bounds_error=False,
-                fill_value="extrapolate",
-            )
-            new_x = np.linspace(
-                x_values[0] - offset, x_values[-1] + offset, num=samples
-            )
-            new_y = f(new_x)
-            return new_y, new_dpmm, new_x
-
-    def _normalize(self, values, method: Normalization) -> np.ndarray:
-        """Normalize the data given a method."""
-        if method == Normalization.NONE:
-            return values
-        elif method == Normalization.MAX:
-            return values / values.max()
-        elif method == Normalization.GEOMETRIC_CENTER:
-            return values / self._geometric_center(values)["value (exact)"]
-        elif method == Normalization.BEAM_CENTER:
-            return values / self.beam_center()["value (@rounded)"]
-
-    def _geometric_center(self, values) -> dict:
-        """Returns the center index and value of the profile.
-
-        If the profile has an even number of values the centre lies between the two centre indices and the centre
-        value is the average of the two centre values else the centre index and value are returned.
-        """
-        return {
-            "index (exact)": self._x_interp_to_original(
-                utils.geometric_center_idx(values)
-            ),
-            "value (exact)": utils.geometric_center_value(values),
-        }
-
-    def geometric_center(self) -> dict:
-        """The geometric center (i.e. the device center)"""
-        return self._geometric_center(self.values)
-
-    def beam_center(self) -> dict:
-        """The center of the detected beam. This can account for asymmetries in the beam position (e.g. offset jaws)"""
-        if self._edge_method == Edge.FWHM:
-            data = self.fwxm_data(x=50)
-            return {
-                "index (rounded)": data["center index (rounded)"],
-                "index (exact)": data["center index (exact)"],
-                "value (@rounded)": data["center value (@rounded)"],
-            }
-        elif self._edge_method in (Edge.INFLECTION_DERIVATIVE, Edge.INFLECTION_HILL):
-            infl = self.inflection_data()
-            mid_point = (
-                infl["left index (exact)"]
-                + (infl["right index (exact)"] - infl["left index (exact)"]) / 2
-            )
-            return {
-                "index (rounded)": int(round(mid_point)),
-                "index (exact)": mid_point,
-                "value (@rounded)": self._y_original_to_interp(int(round(mid_point))),
-            }
-
-    @argue.bounds(x=(0, 100))
-    def fwxm_data(self, x: int = 50) -> dict:
-        """Return the width at X-Max, where X is the percentage height.
-
-        Parameters
-        ----------
-        x
-            The percent height of the profile. E.g. x = 50 is 50% height,
-            i.e. FWHM.
-        """
-        _, peak_props = find_peaks(self.values, fwxm_height=x / 100, max_number=1)
-        left_idx = float(self._x_interp_to_original(peak_props["left_ips"][0]))
-        right_idx = float(self._x_interp_to_original(peak_props["right_ips"][0]))
-        width = right_idx - left_idx
-        fwxm_center_idx = (right_idx - left_idx) / 2 + left_idx
-
-        data = {
-            "width (exact)": width,
-            "width (rounded)": int(round(width)),
-            "center index (rounded)": int(round(fwxm_center_idx)),
-            "center index (exact)": fwxm_center_idx,
-            "center value (@rounded)": float(
-                self._y_original_to_interp(int(round(fwxm_center_idx)))
-            ),
-            "left index (exact)": left_idx,
-            "left index (rounded)": int(round(left_idx)),
-            "left value (@rounded)": float(
-                self._y_original_to_interp(int(round(left_idx)))
-            ),
-            "right index (exact)": right_idx,
-            "right index (rounded)": int(round(right_idx)),
-            "right value (@rounded)": float(
-                self._y_original_to_interp(int(round(right_idx)))
-            ),
-            "field values": self._y_original_to_interp(
-                self.x_indices[int(round(left_idx)) : int(round(right_idx))]
-            ),
-            "peak_props": peak_props,
-        }
-        if self.dpmm:
-            data["width (exact) mm"] = data["width (exact)"] / self.dpmm
-            data["left distance (exact) mm"] = (
-                abs(data["center index (exact)"] - data["left index (exact)"])
-                / self.dpmm
-            )
-            data["right distance (exact) mm"] = (
-                abs(data["right index (exact)"] - data["center index (exact)"])
-                / self.dpmm
-            )
-
-        return data
-
-    @argue.bounds(in_field_ratio=(0, 1.0), slope_exclusion_ratio=(0, 1.0))
-    def field_data(
-        self, in_field_ratio: float = 0.8, slope_exclusion_ratio=0.2
-    ) -> dict:
-        """Return the width at X-Max, where X is the percentage height.
-
-        Parameters
-        ----------
-        in_field_ratio
-            In Field Ratio: 1.0 is the entire detected field; 0.8 would be the central 80%, etc.
-        slope_exclusion_ratio
-            Ratio of the field width to use as the cutoff between "top" calculation and "slope" calculation. Useful for FFF beams.
-            This area is centrally located in the field. E.g. 0.2 will use the central 20% of the field to calculate
-            the "top" value. To calculate the slope of each side, the field width between the edges of the in_field_ratio
-            and the slope exclusion region are used.
-
-            .. warning:: The "top" value is always calculated. For FFF beams this should be reasonable, but for flat beams
-                         this value may end up being non-sensible.
-        """
-        if slope_exclusion_ratio >= in_field_ratio:
-            raise ValueError(
-                "The exclusion region must be smaller than the field ratio"
-            )
-        if self._edge_method == Edge.FWHM:
-            data = self.fwxm_data(x=50)
-            beam_center_idx = data["center index (exact)"]
-            full_width = data["width (exact)"]
-
-        elif self._edge_method in (Edge.INFLECTION_DERIVATIVE, Edge.INFLECTION_HILL):
-            infl_data = self.inflection_data()
-            beam_center_idx = self.beam_center()["index (exact)"]
-            full_width = (
-                infl_data["right index (exact)"] - infl_data["left index (exact)"]
-            )
-        beam_center_idx_r = int(round(beam_center_idx))
-
-        cax_idx = self.geometric_center()["index (exact)"]
-        cax_idx_r = int(round(cax_idx))
-
-        field_left_idx = beam_center_idx - in_field_ratio * full_width / 2
-        field_left_idx_r = int(round(field_left_idx))
-        field_right_idx = beam_center_idx + in_field_ratio * full_width / 2
-        field_right_idx_r = int(round(field_right_idx))
-        field_width = field_right_idx - field_left_idx
-
-        # slope calcs
-        inner_left_idx = beam_center_idx - slope_exclusion_ratio * field_width / 2
-        inner_left_idx_r = int(round(inner_left_idx))
-        inner_right_idx = beam_center_idx + slope_exclusion_ratio * field_width / 2
-        inner_right_idx_r = int(round(inner_right_idx))
-        left_fit = linregress(
-            range(field_left_idx_r, inner_left_idx_r + 1),
-            self._y_original_to_interp(
-                np.arange(field_left_idx_r, inner_left_idx_r + 1)
-            ),
-        )
-        right_fit = linregress(
-            range(inner_right_idx_r, field_right_idx_r + 1),
-            self._y_original_to_interp(
-                np.arange(inner_right_idx_r, field_right_idx_r + 1)
-            ),
-        )
-
-        # top calc
-        fit_params = np.polyfit(
-            range(inner_left_idx_r, inner_right_idx_r + 1),
-            self._y_original_to_interp(
-                np.arange(inner_left_idx_r, inner_right_idx_r + 1)
-            ),
-            deg=2,
-        )
-        width = abs(inner_right_idx_r - inner_left_idx_r)
-
-        def poly_func(x):
-            # return the negative since we're MINIMIZING and want the top value
-            return -(fit_params[0] * (x**2) + fit_params[1] * x + fit_params[2])
-
-        # minimize the polynomial function
-        min_f = minimize(
-            poly_func,
-            x0=(inner_left_idx_r + width / 2,),
-            bounds=((inner_left_idx_r, inner_right_idx_r),),
-        )
-        top_idx = min_f.x[0]
-        top_val = -min_f.fun
-
-        data = {
-            "width (exact)": field_width,
-            "beam center index (exact)": beam_center_idx,
-            "beam center index (rounded)": beam_center_idx_r,
-            "beam center value (@rounded)": self._y_original_to_interp(
-                round(beam_center_idx)
-            ),
-            "cax index (exact)": cax_idx,
-            "cax index (rounded)": cax_idx_r,
-            "cax value (@rounded)": self._y_original_to_interp(round(cax_idx)),
-            "left index (exact)": field_left_idx,
-            "left index (rounded)": field_left_idx_r,
-            "left value (@rounded)": self._y_original_to_interp(round(field_left_idx)),
-            "left slope": left_fit.slope,
-            "left intercept": left_fit.intercept,
-            "right slope": right_fit.slope,
-            "right intercept": right_fit.intercept,
-            "left inner index (exact)": inner_left_idx,
-            "left inner index (rounded)": inner_left_idx_r,
-            "right inner index (exact)": inner_right_idx,
-            "right inner index (rounded)": inner_right_idx_r,
-            '"top" index (exact)': top_idx,
-            '"top" index (rounded)': int(round(top_idx)),
-            '"top" value (@exact)': top_val,
-            "top params": fit_params,
-            "right index (exact)": field_right_idx,
-            "right index (rounded)": field_right_idx_r,
-            "right value (@rounded)": self._y_original_to_interp(
-                round(field_right_idx)
-            ),
-            "field values": self._y_original_to_interp(
-                np.arange(int(round(field_left_idx)), int(round(field_right_idx)) + 1)
-            ),
-        }
-        if self.dpmm:
-            data["width (exact) mm"] = data["width (exact)"] / self.dpmm
-            data["left slope (%/mm)"] = data["left slope"] * self.dpmm * 100
-            data["right slope (%/mm)"] = data["right slope"] * self.dpmm * 100
-            data["left distance->beam center (exact) mm"] = (
-                abs(data["beam center index (exact)"] - data["left index (exact)"])
-                / self.dpmm
-            )
-            data["right distance->beam center (exact) mm"] = (
-                abs(data["right index (exact)"] - data["beam center index (exact)"])
-                / self.dpmm
-            )
-            data["left distance->CAX (exact) mm"] = (
-                abs(data["cax index (exact)"] - data["left index (exact)"]) / self.dpmm
-            )
-            data["right distance->CAX (exact) mm"] = (
-                abs(data["cax index (exact)"] - data["right index (exact)"]) / self.dpmm
-            )
-
-            data["left distance->top (exact) mm"] = (
-                abs(data['"top" index (exact)'] - data["left index (exact)"])
-                / self.dpmm
-            )
-            data["right distance->top (exact) mm"] = (
-                abs(data['"top" index (exact)'] - data["right index (exact)"])
-                / self.dpmm
-            )
-            data['"top"->beam center (exact) mm'] = (
-                data['"top" index (exact)'] - data["beam center index (exact)"]
-            ) / self.dpmm
-            data['"top"->CAX (exact) mm'] = (
-                abs(data['"top" index (exact)'] - data["cax index (exact)"]) / self.dpmm
-            )
-        return data
-
-    def inflection_data(self) -> dict:
-        """Calculate the profile inflection values using either the 2nd derivative or a fitted Hill function.
-
-        .. note::
-            This only applies if the edge detection method is `INFLECTION_...`.
-
-        Parameters
-        ----------
-
-        """
-        # get max/min of the gradient, which is basically the same as the 2nd deriv 0-crossing
-        if self._edge_method == Edge.FWHM:
-            raise ValueError(
-                "FWHM edge method does not have inflection points. Use a different edge detection method"
-            )
-        d1 = np.gradient(
-            gaussian_filter1d(
-                self.values, sigma=self._edge_smoothing_ratio * len(self.values)
-            )
-        )
-        (peak_idxs, _) = MultiProfile(d1).find_peaks(threshold=0.8)
-        (valley_idxs, _) = MultiProfile(d1).find_valleys(threshold=0.8)
-        left_idx = self._x_interp_to_original(peak_idxs[0])  # left-most index
-        right_idx = self._x_interp_to_original(valley_idxs[-1])  # right-most index
-        if self._edge_method == Edge.INFLECTION_DERIVATIVE:
-            data = {
-                "left index (rounded)": int(round(left_idx)),
-                "left index (exact)": left_idx,
-                "right index (rounded)": int(round(right_idx)),
-                "right index (exact)": right_idx,
-                "left value (@rounded)": self._y_original_to_interp(
-                    int(round(left_idx))
-                ),
-                "left value (@exact)": self._y_original_to_interp(left_idx),
-                "right value (@rounded)": self._y_original_to_interp(
-                    int(round(right_idx))
-                ),
-                "right value (@exact)": self._y_original_to_interp(right_idx),
-            }
-            return data
-        else:  # Hill
-            # the 2nd deriv is a good approximation for the inflection point. Start there and fit Hill about it
-            # penum_half_window = self.field_data()['width (exact)'] * self._hill_window_ratio / 2
-            penum_half_window = int(
-                round(self._hill_window_ratio * abs(right_idx - left_idx) / 2)
-            )
-
-            # left side
-            x_data = np.array(
-                [
-                    x
-                    for x in np.arange(
-                        left_idx - penum_half_window, left_idx + penum_half_window
-                    )
-                    if x >= 0
-                ]
-            )
-            y_data = self._y_original_to_interp(x_data)
-            # y_data = self.values[left_idx - penum_half_window: left_idx + penum_half_window]
-            left_hill = Hill.fit(x_data, y_data)
-            left_infl = left_hill.inflection_idx()
-
-            # right side
-            x_data = np.array(
-                [
-                    x
-                    for x in np.arange(
-                        right_idx - penum_half_window, right_idx + penum_half_window
-                    )
-                    if x < len(d1)
-                ]
-            )
-            y_data = self._y_original_to_interp(x_data)
-            right_hill = Hill.fit(x_data, y_data)
-            right_infl = right_hill.inflection_idx()
-
-            data = {
-                "left index (rounded)": left_infl["index (rounded)"],
-                "left index (exact)": left_infl["index (exact)"],
-                "right index (rounded)": right_infl["index (rounded)"],
-                "right index (exact)": right_infl["index (exact)"],
-                "left value (@exact)": left_hill.y(left_infl["index (exact)"]),
-                "right value (@exact)": right_hill.y(right_infl["index (exact)"]),
-                "left Hill params": left_hill.params,
-                "right Hill params": right_hill.params,
-            }
-            return data
-
-    def penumbra(self, lower: int = 20, upper: int = 80):
-        """Calculate the penumbra of the field. Dependent on the edge detection method.
-
-        Parameters
-        ----------
-        lower
-            The lower % of the beam to use. If the edge method is FWHM, this is the typical % penumbra you're thinking.
-            If the inflection method is used it will be the value/50 of the inflection point value. E.g. if the inflection
-            point is perfectly at 50% with a ``lower`` of 20, then the penumbra value here will be 20% of the maximum.
-            If the inflection point is at 30% of the max value (say for a FFF beam) then the lower penumbra will be ``lower/50``
-            of the inflection point or ``0.3*lower/50``.
-        upper
-            Upper % of the beam to use. See lower for details.
-        """
-        if lower > upper:
-            raise ValueError(
-                "Upper penumbra value must be larger than the lower penumbra value"
-            )
-        if self._edge_method == Edge.FWHM:
-            upper_data = self.fwxm_data(x=upper)
-            lower_data = self.fwxm_data(x=lower)
-            data = {
-                f"left {lower}% index (exact)": lower_data["left index (exact)"],
-                f"left {lower}% value (@rounded)": lower_data["left value (@rounded)"],
-                f"left {upper}% index (exact)": upper_data["left index (exact)"],
-                f"left {upper}% value (@rounded)": upper_data["left value (@rounded)"],
-                f"right {lower}% index (exact)": lower_data["right index (exact)"],
-                f"right {lower}% value (@rounded)": lower_data[
-                    "right value (@rounded)"
-                ],
-                f"right {upper}% index (exact)": upper_data["right index (exact)"],
-                f"right {upper}% value (@rounded)": upper_data[
-                    "right value (@rounded)"
-                ],
-                "left values": self.values[
-                    lower_data["left index (rounded)"] : upper_data[
-                        "left index (rounded)"
-                    ]
-                ],
-                "right values": self.values[
-                    upper_data["right index (rounded)"] : lower_data[
-                        "right index (rounded)"
-                    ]
-                ],
-                "left penumbra width (exact)": abs(
-                    upper_data["left index (exact)"] - lower_data["left index (exact)"]
-                ),
-                "right penumbra width (exact)": abs(
-                    upper_data["right index (exact)"]
-                    - lower_data["right index (exact)"]
-                ),
-            }
-            if self.dpmm:
-                data["left penumbra width (exact) mm"] = (
-                    data["left penumbra width (exact)"] / self.dpmm
-                )
-                data["right penumbra width (exact) mm"] = (
-                    data["right penumbra width (exact)"] / self.dpmm
-                )
-            return data
-        elif self._edge_method == Edge.INFLECTION_DERIVATIVE:
-            infl_data = self.inflection_data()
-            lower_left_percent = max(
-                infl_data["left value (@exact)"] / self.values.max() * lower / 50 * 100,
-                1,
-            )
-            upper_left_percent = min(
-                infl_data["left value (@exact)"] / self.values.max() * upper / 50 * 100,
-                99,
-            )
-            upper_left_data = self.fwxm_data(x=upper_left_percent)
-            lower_left_data = self.fwxm_data(x=lower_left_percent)
-
-            lower_right_value = max(
-                infl_data["right value (@exact)"]
-                / self.values.max()
-                * lower
-                / 50
-                * 100,
-                1,
-            )
-            upper_right_value = min(
-                infl_data["right value (@exact)"]
-                / self.values.max()
-                * upper
-                / 50
-                * 100,
-                99,
-            )
-            upper_right_data = self.fwxm_data(x=upper_right_value)
-            lower_right_data = self.fwxm_data(x=lower_right_value)
-
-            data = {
-                f"left {lower}% index (exact)": lower_left_data["left index (exact)"],
-                f"left {upper}% index (exact)": upper_left_data["left index (exact)"],
-                f"right {lower}% index (exact)": lower_right_data[
-                    "right index (exact)"
-                ],
-                f"right {upper}% index (exact)": upper_right_data[
-                    "right index (exact)"
-                ],
-                "left values": self._y_original_to_interp(
-                    np.arange(
-                        lower_left_data["left index (rounded)"],
-                        upper_left_data["left index (rounded)"],
-                    )
-                ),
-                "right values": self._y_original_to_interp(
-                    np.arange(
-                        upper_right_data["right index (rounded)"],
-                        lower_right_data["right index (rounded)"],
-                    )
-                ),
-                "left penumbra width (exact)": abs(
-                    upper_left_data["left index (exact)"]
-                    - lower_left_data["left index (exact)"]
-                ),
-                "right penumbra width (exact)": abs(
-                    upper_right_data["right index (exact)"]
-                    - lower_right_data["right index (exact)"]
-                ),
-            }
-            if self.dpmm:
-                data["left penumbra width (exact) mm"] = (
-                    data["left penumbra width (exact)"] / self.dpmm
-                )
-                data["right penumbra width (exact) mm"] = (
-                    data["right penumbra width (exact)"] / self.dpmm
-                )
-            return data
-        elif self._edge_method == Edge.INFLECTION_HILL:
-            infl_data = self.inflection_data()
-            left_hill = Hill.from_params(infl_data["left Hill params"])
-            right_hill = Hill.from_params(infl_data["right Hill params"])
-
-            lower_left_percent = infl_data["left value (@exact)"] * lower / 50
-            lower_left_index = left_hill.x(lower_left_percent)
-            upper_left_percent = infl_data["left value (@exact)"] * upper / 50
-            upper_left_index = left_hill.x(upper_left_percent)
-
-            lower_right_value = infl_data["right value (@exact)"] * lower / 50
-            lower_right_index = right_hill.x(lower_right_value)
-            upper_right_value = infl_data["right value (@exact)"] * upper / 50
-            upper_right_index = right_hill.x(upper_right_value)
-
-            data = {
-                f"left {lower}% index (exact)": lower_left_index,
-                f"left {lower}% value (exact)": lower_left_percent,
-                f"left {upper}% index (exact)": upper_left_index,
-                f"left {upper}% value (exact)": upper_left_percent,
-                f"right {lower}% index (exact)": lower_right_index,
-                f"right {lower}% value (exact)": lower_right_value,
-                f"right {upper}% index (exact)": upper_right_index,
-                f"right {upper}% value (exact)": upper_right_value,
-                "left values": self.values[
-                    int(round(lower_left_index)) : int(round(upper_left_index))
-                ],
-                "right values": self.values[
-                    int(round(upper_right_index)) : int(round(lower_right_index))
-                ],
-                "left penumbra width (exact)": abs(upper_left_index - lower_left_index),
-                "right penumbra width (exact)": abs(
-                    upper_right_index - lower_right_index
-                ),
-                "left gradient (exact)": left_hill.gradient_at(
-                    infl_data["left index (exact)"]
-                ),
-                r"right gradient (exact)": right_hill.gradient_at(
-                    infl_data["right index (exact)"]
-                ),
-            }
-            if self.dpmm:
-                data["left penumbra width (exact) mm"] = (
-                    data["left penumbra width (exact)"] / self.dpmm
-                )
-                data["left gradient (exact) %/mm"] = (
-                    data["left gradient (exact)"] * self.dpmm * 100
-                )  # 100 to convert to %
-                data["right penumbra width (exact) mm"] = (
-                    data["right penumbra width (exact)"] / self.dpmm
-                )
-                data["right gradient (exact) %/mm"] = (
-                    data["right gradient (exact)"] * self.dpmm * 100
-                )
-            return data
-
-    @argue.options(calculation=("mean", "median", "max", "min", "area"))
-    def field_calculation(
-        self,
-        in_field_ratio: float = 0.8,
-        calculation: str = "mean",
-        slope_exclusion_ratio: float = 0.2,
-    ) -> float | tuple[float, float]:
-        """Perform an operation on the field values of the profile.
-        This function is useful for determining field symmetry and flatness.
-
-        Parameters
-        ----------
-        in_field_ratio
-            Ratio of the field width to use in the calculation.
-        calculation : {'mean', 'median', 'max', 'min', 'area'}
-            Calculation to perform on the field values.
-        """
-        field_values = self.field_data(
-            in_field_ratio, slope_exclusion_ratio=slope_exclusion_ratio
-        )
-
-        if calculation == "mean":
-            return field_values["field values"].mean()
-        elif calculation == "median":
-            return float(np.median(field_values["field values"]))
-        elif calculation == "max":
-            return field_values["field values"].max()
-        elif calculation == "min":
-            return field_values["field values"].min()
-
-    def gamma(
-        self,
-        evaluation_profile: SingleProfile,
-        distance_to_agreement: float = 1,
-        dose_to_agreement: float = 1,
-        gamma_cap_value: float = 2,
-        dose_threshold: float = 5,
-        global_dose: bool = True,
-        fill_value: float = np.nan,
-    ) -> np.ndarray:
-        """Calculate a 1D gamma. The passed profile is the evaluation profile. The instance calling this method is the reference profile.
-        This profile must have the `dpmm` value given at instantiation so that physical spacing can be evaluated.
-        The evaluation profile is resampled to be the same resolution as the reference profile.
-
-        .. note::
-
-            The difference between this method and the `gamma_1d` function is that 1) this is computed on Profile instances and 2)
-            this validates the physical spacing of the profiles.
-
-        Parameters
-        ----------
-        evaluation_profile
-            The evaluation profile. This profile must have the `dpmm` value given at instantiation so that physical spacing can be evaluated.
-        distance_to_agreement
-            Distance in **mm** to search
-        dose_to_agreement
-            Dose in % of either global or local reference dose
-        gamma_cap_value
-            The value to cap the gamma at. E.g. a gamma of 5.3 will get capped to 2. Useful for displaying data with a consistent range.
-        global_dose
-            Whether to evaluate the dose to agreement threshold based on the global max or the dose point under evaluation.
-        dose_threshold
-            The dose threshold as a number between 0 and 100 of the % of max dose under which a gamma is not calculated.
-            This is not affected by the global/local dose normalization and the threshold value is evaluated against the global max dose, period.
-        fill_value
-            The value to give pixels that were not calculated because they were under the dose threshold. Default
-            is NaN, but another option would be 0. If NaN, allows the user to calculate mean/median gamma over just the
-            evaluated portion and not be skewed by 0's that should not be considered.
-        """
-        if not self.dpmm or not evaluation_profile.dpmm:
-            raise ValueError(
-                "At least one profile does not have the dpmm attribute. Physical spacing cannot be determined. Set it before performing gamma analysis."
-            )
-        distance_to_agreement_px = int(round(distance_to_agreement * self.dpmm))
-        # resample eval profile to be same resolution as reference
-        resampled_evaluation = evaluation_profile.resample(
-            interpolation_resolution_mm=self._interpolation_res
-        )
-        if len(resampled_evaluation.values) != len(self.values):
-            warnings.warn(
-                f"The number of elements in the reference and evaluation differ. Ref: {len(self.values)}, Eval: {len(resampled_evaluation.values)}"
-            )
-        # now that we've resampled, it's still possible that the x-values of the two profiles differ.
-        # E.g. we may be at -0.475 and -0.37 for the first index depending on the amount of interpolation.
-        # we thus need to evaluate the evaluation profile at the exact same x-indices as the reference.
-        eval_at_ref_points = resampled_evaluation._y_original_to_interp(self.x_indices)
-        return gamma_1d(
-            reference=self.values,
-            evaluation=eval_at_ref_points,
-            dose_to_agreement=dose_to_agreement,
-            distance_to_agreement=distance_to_agreement_px,
-            gamma_cap_value=gamma_cap_value,
-            global_dose=global_dose,
-            dose_threshold=dose_threshold,
-            fill_value=fill_value,
-        )
-
-    def plot(self, show: bool = True) -> None:
-        """Plot the profile."""
-        plt.plot(self.x_indices, self.values)
-        if show:
-            plt.show()
-
-
-class MultiProfile(ProfileMixin):
-    """A class for analyzing 1-D profiles that contain multiple signals. Methods are mostly for *finding & filtering*
-    the signals, peaks, valleys, etc. Profiles with a single peak (e.g. radiation beam profiles) are better suited by the SingleProfile class.
-
-    Attributes
-    ----------
-    values : ndarray
-        The array of values passed in on instantiation.
-    peaks : list
-        List of Points, containing value and index information.
-    valleys : list
-        Same as peaks, but for valleys.
-
-    """
-
-    values: np.ndarray | Sequence
-    peaks: list
-    valleys: list
-
-    def __init__(self, values: np.array | Sequence):
-        """
-        Parameters
-        ----------
-        values : iterable
-            Array of profile values.
-        """
-        self.values = values
-        self.peaks = []
-        self.valleys = []
-
-    def plot(self, ax: plt.Axes | None = None) -> None:
-        """Plot the profile.
-
-        Parameters
-        ----------
-        ax: plt.Axes
-            An axis to plot onto. Optional.
-        """
-        if ax is None:
-            fig, ax = plt.subplots()
-        ax.plot(self.values)
-        peaks_x = [peak.idx for peak in self.peaks]
-        peaks_y = [peak.value for peak in self.peaks]
-        ax.plot(peaks_x, peaks_y, "gv")
-        valley_x = [peak.idx for peak in self.valleys]
-        valley_y = [peak.value for peak in self.valleys]
-        ax.plot(valley_x, valley_y, "r^")
-
-    def find_peaks(
-        self,
-        threshold: float | int = 0.3,
-        min_distance: float | int = 0.05,
-        max_number: int = None,
-        search_region: tuple = (0.0, 1.0),
-        peak_sort: str = "prominences",
-    ) -> tuple[np.array, np.array]:
-        """Find the peaks of the profile using a simple maximum value search. This also sets the `peaks` attribute.
-
-        Parameters
-        ----------
-        threshold : int, float
-            The value the peak must be above to be considered a peak. This removes "peaks"
-            that are in a low-value region.
-            If passed an int, the actual value is the threshold.
-            E.g. when passed 15, any peak less with a value <15 is removed.
-            If passed a float, it will threshold as a percent. Must be between 0 and 1.
-            E.g. when passed 0.4, any peak <40% of the maximum value will be removed.
-        min_distance : int, float
-            If passed an int, parameter is the number of elements apart a peak must be from neighboring peaks.
-            If passed a float, must be between 0 and 1 and represents the ratio of the profile to exclude.
-            E.g. if passed 0.05 with a 1000-element profile, the minimum peak width will be 0.05*1000 = 50 elements.
-        max_number : int, None
-            Specify up to how many peaks will be returned. E.g. if 3 is passed in and 5 peaks are found, only the 3 largest
-            peaks will be returned. If None, no limit will be applied.
-        search_region : tuple of ints, floats, or both
-            The region within the profile to search. The tuple specifies the (left, right) edges to search.
-            This allows exclusion of edges from the search. If a value is an int, it is taken as is. If a float, must
-            be between 0 and 1 and is the ratio of the profile length. The left value must be less than the right.
-
-        Returns
-        -------
-        indices: ndarray, values, ndarray
-            The indices and values of the peaks.
-        """
-        peak_idxs, peak_props = find_peaks(
-            self.values,
-            threshold=threshold,
-            peak_separation=min_distance,
-            max_number=max_number,
-            search_region=search_region,
-            peak_sort=peak_sort,
-        )
-        self.peaks = [
-            Point(value=peak_val, idx=peak_idx)
-            for peak_idx, peak_val in zip(peak_idxs, peak_props["peak_heights"])
-        ]
-
-        return peak_idxs, peak_props["peak_heights"]
-
-    def find_valleys(
-        self,
-        threshold: float | int = 0.3,
-        min_distance: float | int = 0.05,
-        max_number: int = None,
-        search_region: tuple = (0.0, 1.0),
-    ) -> tuple[np.array, np.array]:
-        """Find the valleys (minimums) of the profile using a simple minimum value search.
-
-        Returns
-        -------
-        indices: ndarray, values, ndarray
-            The indices and values of the valleys.
-
-        See Also
-        --------
-        :meth:`~pylinac.core.profile.MultiProfile.find_peaks` : Further parameter info.
-        """
-        valley_idxs, valley_props = find_peaks(
-            -self.values,
-            threshold=threshold,
-            peak_separation=min_distance,
-            max_number=max_number,
-            search_region=search_region,
-        )
-        self.valleys = [
-            Point(value=self.values[valley_idx], idx=valley_idx)
-            for valley_idx, valley_val in zip(
-                valley_idxs, -valley_props["peak_heights"]
-            )
-        ]
-
-        return valley_idxs, self.values[valley_idxs]
-
-    def find_fwxm_peaks(
-        self,
-        threshold: float | int = 0.3,
-        min_distance: float | int = 0.05,
-        max_number: int = None,
-        search_region: tuple = (0.0, 1.0),
-        peak_sort: str = "prominences",
-        required_prominence=None,
-    ) -> tuple[np.array, np.array]:
-        """Find peaks using the center of the FWXM (rather than by max value).
-
-        Parameters
-        ----------
-        x : int, float
-            The Full-Width-X-Maximum desired. E.g. 0.7 will return the FW70%M.
-            Values must be between 0 and 100.
-
-        See Also
-        --------
-        find_peaks : Further parameter info
-        """
-        _, peak_props = find_peaks(
-            self.values,
-            threshold=threshold,
-            min_width=min_distance,
-            max_number=max_number,
-            search_region=search_region,
-            peak_sort=peak_sort,
-            required_prominence=required_prominence,
-        )
-        fwxm_peak_idxs = []
-        for lt, rt in zip(peak_props["left_ips"], peak_props["right_ips"]):
-            fwxm = int(round(lt + (rt - lt) / 2))
-            fwxm_peak_idxs.append(fwxm)
-
-        fwxm_peak_vals = [self.values[fwxm] for fwxm in fwxm_peak_idxs]
-        self.peaks = [
-            Point(value=peak_val, idx=peak_idx)
-            for peak_idx, peak_val in zip(fwxm_peak_idxs, fwxm_peak_vals)
-        ]
-
-        return np.array(fwxm_peak_idxs), np.array(fwxm_peak_vals)
-
-
-class CircleProfile(MultiProfile, Circle):
-    """A profile in the shape of a circle.
-
-    Attributes
-    ----------
-    image_array : ndarray
-        The 2D image array.
-    start_angle : int, float
-        Starting position of the profile in radians; 0 is right (0 on unit circle).
-    ccw : bool
-        How the profile is/was taken; clockwise or counter-clockwise.
-    """
-
-    image_array: np.array
-    start_angle: float | int
-    ccw: bool
-    sampling_ratio: float
-    _x_locations: np.array | None
-    _y_locations: np.array | None
-
-    def __init__(
-        self,
-        center: Point,
-        radius: float,
-        image_array: np.array,
-        start_angle: float | int = 0,
-        ccw: bool = True,
-        sampling_ratio: float = 1.0,
-    ):
-        """
-        Parameters
-        ----------
-        image_array : ndarray
-            The 2D image array.
-        start_angle : int, float
-            Starting position of the profile in radians; 0 is right (0 on unit circle).
-        ccw : bool
-            If True (default), the profile will proceed counter-clockwise (the direction on the unit circle).
-            If False, will proceed clockwise.
-        sampling_ratio : float
-            The ratio of pixel sampling to real pixels. E.g. if 1.0, the profile will have approximately
-            the same number of elements as was encountered in the profile. A value of 2.0 will sample
-            the profile at 2x the number of elements.
-
-        See Also
-        --------
-        :class:`~pylinac.core.geometry.Circle` : Further parameter info.
-        """
-        Circle.__init__(self, center, radius)
-        self._ensure_array_size(
-            image_array, self.radius + self.center.x, self.radius + self.center.y
-        )
-        self.image_array = image_array
-        self.start_angle = start_angle
-        self.ccw = ccw
-        self.sampling_ratio = sampling_ratio
-        self._x_locations = None
-        self._y_locations = None
-        MultiProfile.__init__(self, self._profile)
-
-    @property
-    def size(self) -> float:
-        """The elemental size of the profile."""
-        return np.pi * self.radius * 2 * self.sampling_ratio
-
-    @property
-    def _radians(self) -> np.array:
-        interval = (2 * np.pi) / self.size
-        rads = np.arange(
-            0 + self.start_angle, (2 * np.pi) + self.start_angle - interval, interval
-        )
-        if self.ccw:
-            rads = rads[::-1]
-        return rads
-
-    @property
-    def x_locations(self) -> np.array:
-        """The x-locations of the profile values."""
-        if self._x_locations is None:
-            return np.cos(self._radians) * self.radius + self.center.x
-        else:
-            return self._x_locations
-
-    @x_locations.setter
-    def x_locations(self, array: np.array):
-        self._x_locations = array
-
-    @property
-    def y_locations(self) -> np.array:
-        """The x-locations of the profile values."""
-        if self._y_locations is None:
-            return np.sin(self._radians) * self.radius + self.center.y
-        else:
-            return self._y_locations
-
-    @y_locations.setter
-    def y_locations(self, array: np.array):
-        self._y_locations = array
-
-    @property
-    def _profile(self) -> np.array:
-        """The actual profile array; private attr that is passed to MultiProfile."""
-        return ndimage.map_coordinates(
-            self.image_array, [self.y_locations, self.x_locations], order=0
-        )
-
-    def find_peaks(
-        self,
-        threshold: float | int = 0.3,
-        min_distance: float | int = 0.05,
-        max_number: int = None,
-        search_region: tuple[float, float] = (0.0, 1.0),
-    ) -> tuple[np.array, np.array]:
-        """Overloads Profile to also map peak locations to the image."""
-        peak_idxs, peak_vals = super().find_peaks(
-            threshold, min_distance, max_number, search_region
-        )
-        self._map_peaks()
-        return peak_idxs, peak_vals
-
-    def find_valleys(
-        self,
-        threshold: float | int = 0.3,
-        min_distance: float | int = 0.05,
-        max_number: int = None,
-        search_region: tuple[float, float] = (0.0, 1.0),
-    ) -> tuple[np.array, np.array]:
-        """Overload Profile to also map valley locations to the image."""
-        valley_idxs, valley_vals = super().find_valleys(
-            threshold, min_distance, max_number, search_region
-        )
-        self._map_peaks()
-        return valley_idxs, valley_vals
-
-    def find_fwxm_peaks(
-        self,
-        threshold: float | int = 0.3,
-        min_distance: float | int = 0.05,
-        max_number: int = None,
-        search_region: tuple[float, float] = (0.0, 1.0),
-    ) -> tuple[np.array, np.array]:
-        """Overloads Profile to also map the peak locations to the image."""
-        peak_idxs, peak_vals = super().find_fwxm_peaks(
-            threshold, min_distance, max_number, search_region=search_region
-        )
-        self._map_peaks()
-        return peak_idxs, peak_vals
-
-    def _map_peaks(self) -> None:
-        """Map found peaks to the x,y locations on the image/array; i.e. adds x,y coordinates to the peak locations"""
-        for peak in self.peaks:
-            peak.x = self.x_locations[int(peak.idx)]
-            peak.y = self.y_locations[int(peak.idx)]
-
-    def roll(self, amount: int) -> None:
-        """Roll the profile and x and y coordinates."""
-        self.values = np.roll(self.values, -amount)
-        self.x_locations = np.roll(self.x_locations, -amount)
-        self.y_locations = np.roll(self.y_locations, -amount)
-
-    def plot2axes(
-        self,
-        axes: plt.Axes = None,
-        edgecolor: str = "black",
-        fill: bool = False,
-        plot_peaks: bool = True,
-    ) -> None:
-        """Plot the circle to an axes.
-
-        Parameters
-        ----------
-        axes : matplotlib.Axes, None
-            The axes to plot on. If None, will create a new figure of the image array.
-        edgecolor : str
-            Color of the Circle; must be a valid matplotlib color.
-        fill : bool
-            Whether to fill the circle. matplotlib keyword.
-        plot_peaks : bool
-            If True, plots the found peaks as well.
-        """
-        if axes is None:
-            fig, axes = plt.subplots()
-            axes.imshow(self.image_array)
-        axes.add_patch(
-            mpl_Circle(
-                (self.center.x, self.center.y),
-                edgecolor=edgecolor,
-                radius=self.radius,
-                fill=fill,
-            )
-        )
-        if plot_peaks:
-            x_locs = [peak.x for peak in self.peaks]
-            y_locs = [peak.y for peak in self.peaks]
-            axes.autoscale(enable=False)
-            axes.scatter(x_locs, y_locs, s=40, marker="x", c=edgecolor)
-
-    @staticmethod
-    def _ensure_array_size(
-        array: np.array, min_width: float, min_height: float
-    ) -> None:
-        """Ensure the array size of inputs are greater than the minimums."""
-        height = array.shape[0]
-        width = array.shape[1]
-        if width < min_width or height < min_height:
-            raise ValueError("Array size not large enough to compute profile")
-
-
-class CollapsedCircleProfile(CircleProfile):
-    """A circular profile that samples a thick band around the nominal circle, rather than just a 1-pixel-wide profile
-    to give a mean value.
-    """
-
-    width_ratio: float
-    num_profiles: int
-
-    @argue.bounds(width_ratio=(0, 1))
-    def __init__(
-        self,
-        center: Point,
-        radius: float,
-        image_array: np.ndarray,
-        start_angle: int = 0,
-        ccw: bool = True,
-        sampling_ratio: float = 1.0,
-        width_ratio: float = 0.1,
-        num_profiles: int = 20,
-    ):
-        """
-        Parameters
-        ----------
-        width_ratio : float
-            The "thickness" of the band to sample. The ratio is relative to the radius. E.g. if the radius is 20
-            and the width_ratio is 0.2, the "thickness" will be 4 pixels.
-        num_profiles : int
-            The number of profiles to sample in the band. Profiles are distributed evenly within the band.
-
-        See Also
-        --------
-        :class:`~pylinac.core.profile.CircleProfile` : Further parameter info.
-        """
-        self.width_ratio = width_ratio
-        self.num_profiles = num_profiles
-        super().__init__(center, radius, image_array, start_angle, ccw, sampling_ratio)
-
-    @property
-    def _radii(self) -> np.array:
-        return np.linspace(
-            start=self.radius * (1 - self.width_ratio),
-            stop=self.radius * (1 + self.width_ratio),
-            num=self.num_profiles,
-        )
-
-    @property
-    def size(self) -> float:
-        return np.pi * max(self._radii) * 2 * self.sampling_ratio
-
-    @property
-    def _multi_x_locations(self) -> list:
-        """List of x-locations of the sampling profiles"""
-        x = []
-        cos = np.cos(self._radians)
-        # extract profile for each circle radii
-        for radius in self._radii:
-            x.append(cos * radius + self.center.x)
-        return x
-
-    @property
-    def _multi_y_locations(self) -> list:
-        """List of x-locations of the sampling profiles"""
-        y = []
-        sin = np.sin(self._radians)
-        # extract profile for each circle radii
-        for radius in self._radii:
-            y.append(sin * radius + self.center.y)
-        return y
-
-    @property
-    def _profile(self) -> np.array:
-        """The actual profile array; private attr that is passed to MultiProfile."""
-        profile = np.zeros(len(self._multi_x_locations[0]))
-        for radius, x, y in zip(
-            self._radii, self._multi_x_locations, self._multi_y_locations
-        ):
-            profile += ndimage.map_coordinates(self.image_array, [y, x], order=0)
-        profile /= self.num_profiles
-        return profile
-
-    def plot2axes(
-        self,
-        axes: plt.Axes = None,
-        edgecolor: str = "black",
-        fill: bool = False,
-        plot_peaks: bool = True,
-    ) -> None:
-        """Add 2 circles to the axes: one at the maximum and minimum radius of the ROI.
-
-        See Also
-        --------
-        :meth:`~pylinac.core.profile.CircleProfile.plot2axes` : Further parameter info.
-        """
-        if axes is None:
-            fig, axes = plt.subplots()
-            axes.imshow(self.image_array)
-        axes.add_patch(
-            mpl_Circle(
-                (self.center.x, self.center.y),
-                edgecolor=edgecolor,
-                radius=self.radius * (1 + self.width_ratio),
-                fill=fill,
-            )
-        )
-        axes.add_patch(
-            mpl_Circle(
-                (self.center.x, self.center.y),
-                edgecolor=edgecolor,
-                radius=self.radius * (1 - self.width_ratio),
-                fill=fill,
-            )
-        )
-        if plot_peaks:
-            x_locs = [peak.x for peak in self.peaks]
-            y_locs = [peak.y for peak in self.peaks]
-            axes.autoscale(enable=False)
-            axes.scatter(x_locs, y_locs, s=20, marker="x", c=edgecolor)
-
-
-def find_peaks(
-    values: np.array,
-    threshold: float | int = -np.inf,
-    peak_separation: float | int = 0,
-    max_number: int | None = None,
-    fwxm_height: float = 0.5,
-    min_width: int = 0,
-    search_region: tuple[float, float] = (0.0, 1.0),
-    peak_sort: str = "prominences",
-    required_prominence: float | np.array | None = None,
-) -> tuple[np.array, dict]:
-    """Find the peaks of a 1D signal. Heavily relies on the scipy implementation.
-
-    Parameters
-    ----------
-    values : array-like
-        Signal values to search for peaks within.
-    threshold : int, float
-        The value the peak must be above to be considered a peak. This removes "peaks"
-        that are in a low-value region.
-        If passed an int, the actual value is the threshold.
-        E.g. when passed 15, any peak less with a value <15 is removed.
-        If passed a float, it will threshold as a percent. Must be between 0 and 1.
-        E.g. when passed 0.4, any peak <40% of the maximum value will be removed.
-    peak_separation : int, float
-        If passed an int, parameter is the number of elements apart a peak must be from neighboring peaks.
-        If passed a float, must be between 0 and 1 and represents the ratio of the profile to exclude.
-        E.g. if passed 0.05 with a 1000-element profile, the minimum peak width will be 0.05*1000 = 50 elements.
-    max_number : int, None
-        Specify up to how many peaks will be returned. E.g. if 3 is passed in and 5 peaks are found, only the 3 largest
-        peaks will be returned.
-    fwxm_height: float
-        The relative height at which a FWXM calculation is performed. Although this function finds simple max values,
-        the underlying function can provide fwxm information as well.
-    min_width: int
-        The minimum width of the peak.
-    search_region: tuple
-        The search region to use within the values.
-        Using between 0 and 1 will convert to a ratio of the indices. E.g. to search the middle half of the passed values, use (0.25, 0.75).
-        Using ints above 1 will use the indices directly. E.g. (33, 71) will search between those two indices.
-    peak_sort
-        The method of sorting peaks. See scipy find_peaks documentation.
-    required_prominence
-        The relative height of the peak compared to surrounding valleys to be considered a peak. See scipy's find_peaks documentation.
-
-    Returns
-    -------
-    peak_idxs : numpy.array
-        The indices of the peaks found.
-    peak_props : dict
-        A dict containing contextual peak data.
-    """
-    peak_separation, shift_amount, threshold, trimmed_values = _parse_peak_args(
-        peak_separation, search_region, threshold, values
-    )
-
-    peak_idxs, peak_props = signal.find_peaks(
-        trimmed_values,
-        rel_height=(1 - fwxm_height),
-        width=min_width,
-        height=threshold,
-        distance=peak_separation,
-        prominence=required_prominence,
-    )
-    peak_idxs += shift_amount  # shift according to the search region left edge
-
-    # get the "largest" peaks up to max number, and then re-sort to be left->right like it was originally
-    largest_peak_idxs = sorted(
-        list(np.argsort(peak_props[peak_sort]))[::-1][:max_number]
-    )
-
-    # cut down prop arrays as need be
-    for key, array_vals in peak_props.items():
-        peak_props[key] = array_vals[largest_peak_idxs]
-    return peak_idxs[largest_peak_idxs], peak_props
-
-
-def _parse_peak_args(
-    peak_separation: float,
-    search_region: tuple[float, float],
-    threshold: float,
-    values: np.array,
-) -> tuple[float, int, float, np.array]:
-    """Converts arguments as needed. E.g. converting a ratio to actual values"""
-    # set threshold as % if between 0 and 1
-    val_range = values.max() - values.min()
-    if 0 <= threshold <= 1:
-        threshold = values.min() + threshold * val_range
-    # set separation as % if between 0 and 1
-    if 0 <= peak_separation <= 1:
-        peak_separation = max(int(peak_separation * len(values)), 1)
-    # limit to search region
-    if max(search_region) <= 1:
-        shift_amount = int(search_region[0] * len(values))
-        values = values[
-            int(search_region[0] * len(values)) : int(search_region[1] * len(values))
-        ]
-    else:
-        values = values[search_region[0] : search_region[1]]
-        shift_amount = search_region[0]
-    return peak_separation, shift_amount, threshold, values
+from __future__ import annotations  # noqa:I001
+
+import enum
+import math
+import warnings
+from abc import ABC, abstractmethod
+from functools import cached_property
+from typing import Any, Iterable, Literal, Sequence
+
+import argue
+import matplotlib.pyplot as plt
+import numpy as np
+from matplotlib.patches import Circle as mpl_Circle
+from scipy import ndimage, signal
+from scipy.interpolate import InterpolatedUnivariateSpline, UnivariateSpline, interp1d
+from scipy.ndimage import gaussian_filter1d, zoom
+from scipy.optimize import OptimizeWarning, minimize
+from scipy.stats import linregress
+
+# noqa:I001
+from ..metrics.profile import FlatnessDifferenceMetric  # noqa:F401
+from ..metrics.profile import FlatnessRatioMetric  # noqa:F401
+from ..metrics.profile import PenumbraLeftMetric  # noqa:F401
+from ..metrics.profile import PenumbraRightMetric  # noqa:F401
+from ..metrics.profile import SymmetryAreaMetric  # noqa:F401
+from ..metrics.profile import SymmetryPointDifferenceMetric  # noqa:F401
+from ..metrics.profile import SymmetryPointDifferenceQuotientMetric  # noqa:F401
+from ..metrics.profile import LEFT, RIGHT, ProfileMetric
+from . import array_utils as utils
+from . import validators
+from .geometry import Circle, Point
+from .hill import Hill
+from .utilities import convert_to_enum
+
+# for Hill fits of 2D device data the # of points can be small.
+# This results in optimization warnings about the variance of the fit (the variance isn't of concern for us for that particular item)
+warnings.simplefilter("ignore", OptimizeWarning)
+
+
+def gamma_1d(
+    reference: np.ndarray,
+    evaluation: np.ndarray,
+    dose_to_agreement: float = 1,
+    distance_to_agreement: int = 1,
+    gamma_cap_value: float = 2,
+    global_dose: bool = True,
+    dose_threshold: float = 5,
+    fill_value: float = np.nan,
+) -> np.ndarray:
+    """Perform a 1D gamma of two 1D profiles/arrays. This does NOT check lengths or
+    spatial consistency. It performs an element-by-element evaluation. It is the responsibility
+    of the caller to ensure the reference and evaluation have comparable spatial resolution.
+
+    The algorithm follows Table I of D. Low's 2004 paper: Evaluation of the gamma dose distribution comparison method: https://aapm.onlinelibrary.wiley.com/doi/epdf/10.1118/1.1598711
+
+    Parameters
+    ----------
+
+    reference
+        The reference profile.
+    evaluation
+        The evaluation profile.
+    dose_to_agreement
+        The dose to agreement in %. E.g. 1 is 1% of global reference max dose.
+    distance_to_agreement
+        The distance to agreement in **elements**. E.g. if the value is 4 this means 4 elements from the reference point under calculation.
+        Must be >0
+    gamma_cap_value
+        The value to cap the gamma at. E.g. a gamma of 5.3 will get capped to 2. Useful for displaying data with a consistent range.
+    global_dose
+        Whether to evaluate the dose to agreement threshold based on the global max or the dose point under evaluation.
+    dose_threshold
+        The dose threshold as a number between 0 and 100 of the % of max dose under which a gamma is not calculated.
+        This is not affected by the global/local dose normalization and the threshold value is evaluated against the global max dose, period.
+    fill_value
+        The value to give pixels that were not calculated because they were under the dose threshold. Default
+        is NaN, but another option would be 0. If NaN, allows the user to calculate mean/median gamma over just the
+        evaluated portion and not be skewed by 0's that should not be considered.
+    """
+    if reference.ndim != 1 or evaluation.ndim != 1:
+        raise ValueError(
+            f"Reference and evaluation arrays must be 1D. Got reference: {reference.ndim} and evaluation: {evaluation.ndim}"
+        )
+    threshold = reference.max() / 100 * dose_threshold
+    # convert dose to agreement to % of global max; ignored later if local dose
+    dose_ta = dose_to_agreement / 100 * reference.max()
+    # pad eval array on both edges so our search does not go out of bounds
+    eval_padded = np.pad(evaluation, distance_to_agreement, mode="edge")
+    # iterate over each reference element, computing distance value and dose value
+    gamma = []
+    for r_idx, ref_point in enumerate(reference):
+        # skip if below dose threshold
+        if ref_point < threshold:
+            gamma.append(fill_value)
+            continue
+        # we search at the same indices in eval_padded, but remember eval_padded has extra indices on each edge,
+        # so this is actually searching from -DTA to +DTA because r_idx in eval_padded is off by distance_to_agreement.
+        capital_gammas = []
+        for e_idx, eval_point in enumerate(
+            eval_padded[r_idx : r_idx + 2 * distance_to_agreement + 1]
+        ):
+            dist = abs(e_idx - distance_to_agreement)
+            dose = eval_point - ref_point
+            if not global_dose:
+                dose_ta = dose_to_agreement / 100 * ref_point
+            capital_gamma = math.sqrt(
+                dist**2 / distance_to_agreement**2 + dose**2 / dose_ta**2
+            )
+            capital_gammas.append(capital_gamma)
+        gamma.append(min(min(capital_gammas), gamma_cap_value))
+    return np.asarray(gamma)
+
+
+def stretch(
+    array: np.ndarray, min: int = 0, max: int = 1, fill_dtype: np.dtype | None = None
+) -> np.ndarray:
+    """'Stretch' the profile to the fit a new min and max value and interpolate in between.
+    From: http://www.labri.fr/perso/nrougier/teaching/numpy.100/  exercise #17
+
+    .. deprecated:: 3.11
+
+    Parameters
+    ----------
+    array: numpy.ndarray
+        The numpy array to stretch.
+    min : number
+        The new minimum of the values.
+    max : number
+        The new maximum value.
+    fill_dtype : numpy data type
+        If None (default), the array will be stretched to the passed min and max.
+        If a numpy data type (e.g. np.int16), the array will be stretched to fit the full range of values
+        of that data type. If a value is given for this parameter, it overrides ``min`` and ``max``.
+    """
+    warnings.warn(
+        "Using stretch from the profile module is deprecated. Use 'stretch' from the pylinac.core.array_utils module",
+        DeprecationWarning,
+    )
+    new_max = max
+    if fill_dtype is not None:
+        try:
+            di = np.iinfo(fill_dtype)
+        except ValueError:
+            di = np.finfo(fill_dtype)
+        new_max = di.max
+    # perfectly normalize the array (0..1). ground, then div by range
+    stretched_array = (array - array.min()) / (array.max() - array.min())
+    # stretch normalized array to new max/min
+    stretched_array *= new_max
+    # stretched_array += new_min
+    if fill_dtype:
+        stretched_array = stretched_array.astype(fill_dtype)
+    return stretched_array
+
+
+class ProfileMixin:
+    """A mixin to provide various manipulations of 1D profile data."""
+
+    values: np.ndarray
+
+    def invert(self) -> None:
+        """Invert the profile."""
+        self.values = utils.invert(self.values)
+
+    def bit_invert(self) -> None:
+        """Invert the profile bit-wise."""
+        self.values = utils.bit_invert(self.values)
+
+    def normalize(self, norm_val: str | float | None = None) -> None:
+        """Normalize the profile to the given value.
+
+        Parameters
+        ----------
+        norm_val : number or 'max' or None
+            If a number, normalize the array to that number. If None, normalizes to the maximum value.
+        """
+        # backwards compatibility
+        if norm_val == "max":
+            norm_val = None
+        self.values = utils.normalize(self.values, value=norm_val)
+
+    def stretch(self, min: float = 0, max: float = 1) -> None:
+        """'Stretch' the profile to the min and max parameter values.
+
+        Parameters
+        ----------
+        min : number
+            The new minimum of the values
+        max : number
+            The new maximum value.
+        """
+        self.values = utils.stretch(self.values, min=min, max=max)
+
+    def convert_to_dtype(self, dtype: type[np.dtype]) -> None:
+        """Convert the profile datatype to another datatype while retaining the values relative to the datatype min/max"""
+        self.values = utils.convert_to_dtype(self.values, dtype=dtype)
+
+    def ground(self) -> float:
+        """Ground the profile such that the lowest value is 0.
+
+        Returns
+        -------
+        float
+            The minimum value that was used as the grounding value.
+        """
+        min_val = self.values.min()
+        self.values = utils.ground(self.values)
+        return min_val
+
+    def filter(self, size: float = 0.05, kind: str = "median") -> None:
+        """Filter the profile.
+
+        Parameters
+        ----------
+        size : float, int
+            Size of the median filter to apply.
+            If a float, the size is the ratio of the length. Must be in the range 0-1.
+            E.g. if size=0.1 for a 1000-element array, the filter will be 100 elements.
+            If an int, the filter is the size passed.
+        kind : {'median', 'gaussian'}
+            The kind of filter to apply. If gaussian, `size` is the sigma value.
+        """
+        self.values = utils.filter(self.values, size=size, kind=kind)
+
+    def __len__(self):
+        return len(self.values)
+
+    def __getitem__(self, items):
+        return self.values[items]
+
+
+class Interpolation(enum.Enum):
+    """Interpolation Enum"""
+
+    NONE = None  #:
+    LINEAR = "Linear"  #:
+    SPLINE = "Spline"  #:
+
+
+class Normalization(enum.Enum):
+    """Normalization method Enum"""
+
+    NONE = None  #:
+    GEOMETRIC_CENTER = "Geometric center"  #:
+    BEAM_CENTER = "Beam center"  #:
+    MAX = "Max"  #:
+
+
+class Edge(enum.Enum):
+    """Edge detection Enum"""
+
+    FWHM = "FWHM"  #:
+    INFLECTION_DERIVATIVE = "Inflection Derivative"  #:
+    INFLECTION_HILL = "Inflection Hill"  #:
+
+
+class Centering(enum.Enum):
+    """See :ref:`centering`"""
+
+    MANUAL = "Manual"  #:
+    BEAM_CENTER = "Beam center"  #:
+    GEOMETRIC_CENTER = "Geometric center"  #:
+
+
+class ProfileBase(ProfileMixin, ABC):
+    """The base class for multiple type of profiles. This class should not be instantiated directly.
+
+    We use a base class to avoid having long stacked if statements for the different detection patterns.
+    This is also more explicit and extensible."""
+
+    metrics: list[ProfileMetric]
+    metric_values: dict[str, float]
+
+    def __init__(
+        self,
+        values: np.array,
+        x_values: np.array | None = None,
+        ground: bool = False,
+        normalization: str | Normalization = Normalization.NONE,
+        interpolation_order: int = 1,
+    ):
+        """A 1D profile that has one large signal, e.g. a radiation beam profile.
+        Signal analysis methods are given, mostly based on FWXM and on Hill function calculations.
+        Profiles with multiple peaks are better suited by the MultiProfile class.
+        """
+        validators.single_dimension(values)
+        self.metrics = []
+        self.metric_values = {}
+        self._interp_order = interpolation_order
+        if x_values is None:
+            x_values = np.arange(len(values))
+        x_diff = np.diff(x_values)
+        if x_diff.max() > 0 > x_diff.min():
+            raise ValueError("X values must be monotonically increasing or decreasing")
+        # resort in case we are in descending order
+        sort_idxs = np.argsort(x_values)
+        x_values = x_values[sort_idxs]
+        values = values[sort_idxs]
+        self.values = values
+        self.x_values = x_values
+        if ground:
+            self.values = utils.ground(values)
+        if normalization == Normalization.MAX:
+            self.normalize()
+        elif normalization == Normalization.GEOMETRIC_CENTER:
+            center_val = utils.geometric_center_value(self.values)
+            self.normalize(center_val)
+        elif normalization == Normalization.BEAM_CENTER:
+            beam_center_val = self.y_at_x(self.center_idx)
+            self.normalize(beam_center_val)
+
+    def x_at_x(self, x: float) -> np.ndarray:
+        """Deprecated alias for x_at_x_idx"""
+        warnings.warn(
+            "x_at_x is deprecated. Use x_at_x_idx instead", DeprecationWarning
+        )
+        return self.x_at_x_idx(x)
+
+    def x_at_x_idx(self, x: float | np.ndarray) -> np.ndarray | float:
+        """Return the physical x-value at the given index. When no x-values are provided, these are the same.
+        However, physical dimensions can be different than the index."""
+        # UnivariateSpline is the newer approach than interp1d
+        # interp1d is legacy and may be removed in the future
+        # we create an interpolation for x-values so we can
+        # get the original x-value when the index is a float (very often the case)
+        f = UnivariateSpline(
+            x=np.arange(len(self.x_values)), y=self.x_values, k=self._interp_order, s=0
+        )
+        new_x = f(x)
+        if new_x.size == 1:
+            return float(new_x)
+        return f(x)
+
+    def x_idx_at_x(self, x: float) -> int:
+        """Return the **index** of the x-value closest to the given x-value."""
+        return int(np.argmin(np.abs(self.x_values - x)))
+
+    def y_at_x(self, x: float | np.ndarray) -> np.ndarray | float:
+        """Interpolated y-values. The x-value is the physical position, not the index. However, if no x-values were provided, these will be the same."""
+        f = UnivariateSpline(x=self.x_values, y=self.values, k=self._interp_order, s=0)
+        new_y = f(x)
+        if new_y.size == 1:
+            return float(new_y)
+        return new_y
+
+    def x_at_y(self, y: float | np.ndarray, side: str) -> np.ndarray | float:
+        """Interpolated y-values. Can use floats as indices."""
+        # I can't get UnivariateSpline to work here because it wants strictly increasing
+        # data. So we use interp1d instead
+        s = self.x_idx_at_x(self.center_idx)
+        if side == LEFT:
+            f = interp1d(x=self.values[:s], y=self.x_values[:s])
+        elif side == RIGHT:
+            f = interp1d(x=self.values[s:], y=self.x_values[s:])
+        new_x = f(y)
+        if new_x.size == 1:
+            return float(new_x)
+        return f(y)
+
+    @abstractmethod
+    def field_edge_idx(self, side: str) -> float:
+        """The index of the field edge, given the side and edge detection method."""
+        pass
+
+    def field_indices(self, in_field_ratio: float) -> (int, int, int):
+        """Return the indices of the left and right edge of the field, given the in-field ratio.
+        Importantly, this will use the same rounding behavior as field_values.
+        """
+        xs = self.field_x_values(in_field_ratio)
+        left = xs[0]
+        right = xs[-1]
+        width = max(right, left) - min(right, left)
+        return left, right, width
+
+    def field_x_values(self, in_field_ratio: float) -> np.ndarray:
+        """Return the x-values of the field, given the in-field ratio.
+        This is helpful when plotting the field to include the proper x-values as well.
+        """
+        left = self.field_edge_idx(side=LEFT)
+        right = self.field_edge_idx(side=RIGHT)
+        width = self.field_width_px
+        f_left = left + (1 - in_field_ratio) / 2 * width
+        f_right = right - (1 - in_field_ratio) / 2 * width
+        # use floor/ceil to be inclusive of the edges
+        lower_bound = math.floor(min((f_left, f_right)))
+        upper_bound = math.ceil(max((f_left, f_right)))
+        inner_range = np.nonzero(
+            (self.x_values >= lower_bound) & (self.x_values <= upper_bound)
+        )[0]
+        return self.x_values[inner_range]
+
+    @cached_property
+    def center_idx(self) -> float:
+        """The center index of the profile. Halfway between the field edges."""
+        left = self.field_edge_idx(side=LEFT)
+        right = self.field_edge_idx(side=RIGHT)
+        return abs(right - left) / 2 + left
+
+    @cached_property
+    def field_width_px(self) -> float:
+        """The field width of the profile in pixels"""
+        left_idx = self.field_edge_idx(side=LEFT)
+        right_idx = self.field_edge_idx(side=RIGHT)
+        return max(right_idx, left_idx) - min(right_idx, left_idx)
+
+    def field_values(
+        self,
+        in_field_ratio: float = 0.8,
+    ) -> np.ndarray:
+        """The array of values of the profile within the 'field' area. This is typically 80% of the detected
+        field width."""
+        x_values = self.field_x_values(in_field_ratio)
+        return self.y_at_x(x_values)
+
+    def as_resampled(
+        self, interpolation_factor: float = 10, order: int = 3, **kwargs
+    ) -> Any:
+        """Resample the profile at a new resolution. Returns a new profile.
+
+        Parameters
+        ----------
+        interpolation_factor : float
+            The factor to zoom the profile by. E.g. 10 means the profile will be 10x larger.
+        order : int
+            The order of the spline interpolation. 1 is linear, 3 is cubic, etc.
+
+        Warnings
+        --------
+        This method will respect the input datatype of the numpy array. If the input array is a float, the output array will be a float.
+        This can cause issues for int arrays with a small range. E.g. if the range is only 10, interpolation
+        will look more step-like than smooth. If this is the case, convert the array to a float before passing it to this method.
+        The array is not automatically converted to float in this case to respect the original dtype. However,
+        a warning will be produced.
+        """
+        arr_range = self.values.max() - self.values.min()
+        if self.values.dtype != float and arr_range < 100:
+            warnings.warn(
+                f"Array range is small ({arr_range}) and is not a float. Interpolation may look step-like. "
+                f"Consider converting the array to a float before passing it to this method.",
+                UserWarning,
+            )
+        new_y = zoom(
+            self.values,
+            zoom=interpolation_factor,
+            order=order,
+            grid_mode=False,
+            mode="nearest",
+        )
+        new_x = np.linspace(self.x_values.min(), self.x_values.max(), len(new_y))
+
+        return type(self)(
+            values=new_y,
+            x_values=new_x,
+            ground=False,
+            normalization=Normalization.NONE,
+            **kwargs,
+        )
+
+    def resample_to(
+        self, target_profile: ProfileBase | PhysicalProfileMixin
+    ) -> ProfileBase:
+        """Resample a target profile to have the same sampling (x-values) rate as the source profile.
+        This will return a new target profile with the same x-values as the source profile and with the values
+        interpolated to match the source profile.
+
+        For example, this can be used to resample an EPID profile to have the same sampling rate as an ion chamber
+        profile or vice versa.
+
+        Requirements
+        ------------
+
+        * The range of x-values for the target profile must be within the x-value range of the source profile.
+          I.e. no extrapolation of the source profile. For example, if we have a profile of an IC Profile,
+          that goes from -15cm to +15cm, we cannot resample onto an EPID profile that goes from -20cm to +20cm.
+          To do so, go the other way: resample the EPID profile onto the IC profile.
+        """
+        # get the absolute x values; depends on the type of profile
+        if isinstance(target_profile, PhysicalProfileMixin):
+            target_x = target_profile.physical_x_values
+        else:
+            target_x = target_profile.x_values
+        if isinstance(self, PhysicalProfileMixin):
+            self_x = self.physical_x_values
+        else:
+            self_x = self.x_values
+        f = InterpolatedUnivariateSpline(self_x, self.values, k=1, ext=2)
+        try:
+            target_y = f(target_x)
+        except ValueError:
+            raise ValueError(
+                f"The target profile x-values are outside this profiles range. Extrapolation is not allowed. self x-values: {self_x.min()} to {self_x.max()}. target x-values: {target_x.min()} to {target_x.max()}. "
+            )
+        if isinstance(self, PhysicalProfileMixin):
+            output_type = self.__class__.__bases__[-1]
+        else:
+            output_type = self.__class__
+        return output_type(values=target_y, x_values=target_x)
+
+    def plot(
+        self,
+        show: bool = True,
+        axis: plt.Axes | None = None,
+        show_field_edges: bool = True,
+        show_grid: bool = True,
+        show_center: bool = True,
+    ) -> plt.Axes:
+        """Plot the profile along with relevant overlays to point out features."""
+        if axis is None:
+            _, axis = plt.subplots()
+        axis.plot(self.x_values, self.values, label="Data")
+        if show_field_edges:
+            axis.axvline(self.field_edge_idx(side=LEFT), ls="--", label="Field Edges")
+            axis.axvline(self.field_edge_idx(side=RIGHT), ls="--")
+        if show_center:
+            axis.axvline(self.center_idx, ls=":", label="Center")
+        for metric in self.metrics:
+            metric.plot(axis)
+        axis.grid(show_grid)
+        axis.legend()
+        if show:
+            plt.show()
+        return axis
+
+    def compute(
+        self, metrics: Iterable[ProfileMetric] | ProfileMetric
+    ) -> Any | dict[str, Any]:
+        """Compute metric(s) on the profile.
+
+        Unlike other modules, calling ``compute`` is not strictly necessary.
+        Only call it if there are metrics to calculate.
+
+        Parameters
+        ----------
+        metrics: iterable of ProfileMetric | ProfileMetric
+            List of metrics to calculate. If only one metric is desired, it can be passed directly.
+
+        Returns
+        -------
+        dict | list
+            A dictionary of metric names and values if multiple metrics were given.
+            If only one metric was given, the value of that metric is returned.
+
+        """
+        self.metric_values = {}
+        self.metrics = []
+        values = {}
+        if isinstance(metrics, ProfileMetric):
+            metrics = [metrics]
+        for metric in metrics:
+            metric.inject_profile(self)
+            self.metrics.append(metric)
+            values[metric.name] = metric.calculate()
+        self.metric_values |= values
+        if len(values) == 1:
+            return list(values.values())[0]
+        else:
+            return values
+
+
+class FWXMProfile(ProfileBase):
+    """A profile that has one large signal, e.g. a radiation beam profile and data derived from it is based on
+    the Full-Width X-Maximum to find the edge indices"""
+
+    def __init__(
+        self,
+        values: np.array,
+        x_values: np.array | None = None,
+        ground: bool = False,
+        normalization: str | Normalization = Normalization.NONE,
+        fwxm_height: float = 50,
+    ):
+        """A 1D profile that has one large signal, e.g. a radiation beam profile.
+        Signal analysis methods are given, mostly based on FWXM and on Hill function calculations.
+        Profiles with multiple peaks are better suited by the MultiProfile class.
+        """
+        self.fwxm_height = fwxm_height
+        super().__init__(
+            values=values,
+            x_values=x_values,
+            ground=ground,
+            normalization=normalization,
+        )
+
+    def field_edge_idx(self, side: Literal["right", "left"]) -> float:
+        """The edge index of the given side using the FWXM methodology"""
+        _, peak_props = find_peaks(
+            self.values, fwxm_height=self.fwxm_height / 100, max_number=1
+        )
+        if side == LEFT:
+            idx = peak_props["left_ips"][0]
+        elif side == RIGHT:
+            idx = peak_props["right_ips"][0]
+        return self.x_at_x_idx(idx)
+
+    def as_resampled(
+        self, interpolation_factor: float = 10, order: int = 3
+    ) -> FWXMProfile:
+        """Resample the profile at a new resolution. Returns a new profile.
+
+        Parameters
+        ----------
+        interpolation_factor : float
+            The factor to zoom the profile by. E.g. 10 means the profile will be 10x larger.
+        order : int
+            The order of the spline interpolation. 1 is linear, 3 is cubic, etc.
+        """
+        return super().as_resampled(
+            interpolation_factor=interpolation_factor,
+            order=order,
+            fwxm_height=self.fwxm_height,
+        )
+
+
+class InflectionDerivativeProfile(ProfileBase):
+    """A profile that has one large signal, e.g. a radiation beam profile and data derived from it is based on
+    the Full-Width X-Maximum"""
+
+    def __init__(
+        self,
+        values: np.array,
+        x_values: np.array | None = None,
+        ground: bool = False,
+        normalization: str | Normalization = Normalization.NONE,
+        edge_smoothing_ratio: float = 0.003,
+    ):
+        """A 1D profile that has one large signal, e.g. a radiation beam profile.
+        Signal analysis methods are given, mostly based on FWXM and on Hill function calculations.
+        Profiles with multiple peaks are better suited by the MultiProfile class.
+        """
+        self.edge_smoothing_ratio = edge_smoothing_ratio
+        super().__init__(
+            values=values,
+            x_values=x_values,
+            ground=ground,
+            normalization=normalization,
+        )
+
+    def field_edge_idx(self, side: str) -> float:
+        """The edge index of the given side using the second derivative methodology"""
+        filtered_values = gaussian_filter1d(
+            self.values, sigma=self.edge_smoothing_ratio * len(self.values)
+        )
+        diff = np.gradient(filtered_values)
+        f_diff = interp1d(x=self.x_values, y=diff, kind="cubic")
+
+        if side == LEFT:
+            initial_guess = self.x_at_x_idx(np.argmax(diff))
+            idx = minimize(lambda x: -f_diff(x), x0=initial_guess).x[0]
+        else:
+            initial_guess = self.x_at_x_idx(np.argmin(diff))
+            idx = minimize(f_diff, x0=initial_guess).x[0]
+        return idx
+
+    def as_resampled(
+        self, interpolation_factor: float = 10, order: int = 3
+    ) -> InflectionDerivativeProfile:
+        return super().as_resampled(
+            interpolation_factor=interpolation_factor,
+            order=order,
+            edge_smoothing_ratio=self.edge_smoothing_ratio,
+        )
+
+
+class HillProfile(InflectionDerivativeProfile):
+    """A profile that has one large signal, e.g. a radiation beam profile and data derived from it is based on
+    the Full-Width X-Maximum"""
+
+    def __init__(
+        self,
+        values: np.array,
+        x_values: np.array | None = None,
+        ground: bool = False,
+        normalization: str = Normalization.NONE,
+        edge_smoothing_ratio: float = 0.003,
+        hill_window_ratio: float = 0.1,
+    ):
+        """A 1D profile that has one large signal, e.g. a radiation beam profile.
+        Signal analysis methods are given, mostly based on FWXM and on Hill function calculations.
+        Profiles with multiple peaks are better suited by the MultiProfile class.
+        """
+        self.hill_window_ratio = hill_window_ratio
+        super().__init__(
+            values=values,
+            x_values=x_values,
+            ground=ground,
+            normalization=normalization,
+            edge_smoothing_ratio=edge_smoothing_ratio,
+        )
+
+    def field_edge_idx(self, side: str) -> float:
+        """The edge index of the given side using the FWXM methodology"""
+        left_infl_idx = super().field_edge_idx(side=LEFT)
+        right_infl_idx = super().field_edge_idx(side=RIGHT)
+        window_size = (right_infl_idx - left_infl_idx) * self.hill_window_ratio
+        if side == LEFT:
+            left = int(round(left_infl_idx - window_size))
+            right = int(round(left_infl_idx + window_size))
+            x_data = self.x_values[left : right + 1]
+            y_data = self.values[left : right + 1]
+        else:
+            left = int(round(right_infl_idx - window_size))
+            right = int(round(right_infl_idx + window_size))
+            x_data = self.x_values[left : right + 1]
+            y_data = self.values[left : right + 1]
+        hill_fit = Hill.fit(x_data=x_data, y_data=y_data)
+        idx = hill_fit.inflection_idx()["index (exact)"]
+        return self.x_at_x_idx(idx)
+
+    def as_resampled(
+        self, interpolation_factor: float = 10, order: int = 3
+    ) -> HillProfile:
+        return ProfileBase.as_resampled(
+            self,
+            interpolation_factor=interpolation_factor,
+            order=order,
+            edge_smoothing_ratio=self.edge_smoothing_ratio,
+            hill_window_ratio=self.hill_window_ratio,
+        )
+
+
+class PhysicalProfileMixin:
+    """A mixin when the profile has a physical component.
+    This is pretty typical for EPID profiles, etc. The mixin
+    adds a few methods that take physical distance into account."""
+
+    x_values: np.ndarray
+    values: np.ndarray
+    field_width_px: float
+
+    def __init__(
+        self,
+        dpmm: float,
+    ):
+        self.dpmm = dpmm
+
+    @property
+    def physical_x_values(self) -> np.array:
+        """The x-values of the profile in absolute position, taking into account the dpmm."""
+        half_pixel_offset = 0.5 / self.dpmm
+        x_values = self.x_values / self.dpmm + half_pixel_offset
+        return x_values
+
+    @cached_property
+    def field_width_mm(self) -> float:
+        """The field width of the profile in mm"""
+        return self.field_width_px / self.dpmm
+
+    def as_simple_profile(self) -> ProfileBase:
+        """Convert a physical profile into a simple profile where
+        the x-values have been converted to the physical x-values.
+
+        An example is converting an EPID profile into a simple profile
+        where the x-values are in mm, not pixels.
+
+        This can be useful when trying to compare physical profiles
+        to simple profiles. E.g. an EPID vs an ion chamber profile acquisition.
+        In the EPID's case, the x-values are indices w/ a dpmm component.
+        The IC profile is usually already directly in absolute x-values.
+        """
+        base_profile_type = self.__class__.__bases__[-1]
+        return base_profile_type(values=self.values, x_values=self.physical_x_values)
+
+    def as_resampled(
+        self,
+        interpolation_resolution_mm: float = 0.1,
+        order: int = 3,
+        grid: bool = True,
+    ) -> Any:
+        """Resample the physical profile at a new resolution. Returns a new profile.
+
+        Parameters
+        ----------
+        interpolation_resolution_mm : float
+            The resolution to resample to in mm. E.g. 0.1 means the profile will be 0.1 mm resolution.
+        order : int
+            The order of the spline interpolation. 1 is linear, 3 is cubic, etc.
+        grid : bool
+            Whether to use grid mode when zooming. See parameter ``grid_mode`` in :func:`~scipy.ndimage.zoom` for more information.
+            This should be true unless you are resampling an already-resampled physical array.
+
+        Warnings
+        --------
+        This method will respect the input datatype of the numpy array. If the input array is a float, the output array will be a float.
+        This can cause issues for int arrays with a small range. E.g. if the range is only 10, interpolation
+        will look more step-like than smooth. If this is the case, convert the array to a float before passing it to this method.
+        The array is not automatically converted to float in this case to respect the original dtype. However,
+        a warning will be produced.
+        """
+        arr_range = self.values.max() - self.values.min()
+        if self.values.dtype != float and arr_range < 100:
+            warnings.warn(
+                f"Array range is small ({arr_range}) and is not a float. Interpolation may look step-like. "
+                f"Consider converting the array to a float before passing it to this method.",
+                UserWarning,
+            )
+
+        factor = 1 / (self.dpmm * interpolation_resolution_mm)
+        #  When dealing with physical arrays where each pixel/voxel is a physical distance, it is important to
+        #  use grid mode when zooming. This is because each pixel/voxel has a physical size.
+        #  See parameter ``grid_mode`` in :func:`~scipy.ndimage.zoom` for more information.
+        new_y = zoom(
+            self.values,
+            zoom=factor,
+            order=order,
+            grid_mode=grid,
+            mode="nearest",
+        )
+        # similarly, we assume that x-values are also physical
+        # we thus have to offset the x-values by half a pixel/voxel
+        # while accounting for the physical size of the pixel/voxel
+        if grid:
+            offset = 0.5 - 1 / (2 * factor)
+            new_x = np.linspace(
+                self.x_values.min() - offset, self.x_values.max() + offset, len(new_y)
+            )
+        else:
+            new_x = np.linspace(self.x_values.min(), self.x_values.max(), len(new_y))
+
+        return type(self)(
+            values=new_y,
+            x_values=new_x,
+            ground=False,
+            normalization=Normalization.NONE,
+            dpmm=factor * self.dpmm,
+        )
+
+
+class FWXMProfilePhysical(PhysicalProfileMixin, FWXMProfile):
+    def __init__(
+        self,
+        values: np.array,
+        dpmm: float,
+        x_values: np.array | None = None,
+        ground: bool = False,
+        normalization: str | Normalization = Normalization.NONE,
+        fwxm_height: float = 50,
+    ):
+        FWXMProfile.__init__(
+            self,
+            values=values,
+            x_values=x_values,
+            ground=ground,
+            normalization=normalization,
+            fwxm_height=fwxm_height,
+        )
+        PhysicalProfileMixin.__init__(self, dpmm=dpmm)
+
+    def as_resampled(
+        self,
+        interpolation_resolution_mm: float = 0.1,
+        order: int = 3,
+        grid: bool = True,
+    ) -> FWXMProfilePhysical:
+        return super().as_resampled(
+            interpolation_resolution_mm=interpolation_resolution_mm,
+            order=order,
+            grid=grid,
+        )
+
+
+class InflectionDerivativeProfilePhysical(
+    PhysicalProfileMixin, InflectionDerivativeProfile
+):
+    def __init__(
+        self,
+        values: np.array,
+        dpmm: float,
+        x_values: np.array | None = None,
+        ground: bool = False,
+        normalization: str | Normalization = Normalization.NONE,
+        edge_smoothing_ratio: float = 0.003,
+    ):
+        InflectionDerivativeProfile.__init__(
+            self,
+            values=values,
+            x_values=x_values,
+            ground=ground,
+            normalization=normalization,
+            edge_smoothing_ratio=edge_smoothing_ratio,
+        )
+        PhysicalProfileMixin.__init__(self, dpmm=dpmm)
+
+    def as_resampled(
+        self,
+        interpolation_resolution_mm: float = 0.1,
+        order: int = 3,
+        grid: bool = True,
+    ) -> InflectionDerivativeProfilePhysical:
+        return super().as_resampled(
+            interpolation_resolution_mm=interpolation_resolution_mm,
+            order=order,
+            grid=grid,
+        )
+
+
+class HillProfilePhysical(PhysicalProfileMixin, HillProfile):
+    def __init__(
+        self,
+        values: np.array,
+        dpmm: float,
+        x_values: np.array | None = None,
+        ground: bool = False,
+        normalization: str | Normalization = Normalization.NONE,
+        edge_smoothing_ratio: float = 0.003,
+        hill_window_ratio: float = 0.1,
+    ):
+        HillProfile.__init__(
+            self,
+            values=values,
+            x_values=x_values,
+            ground=ground,
+            normalization=normalization,
+            edge_smoothing_ratio=edge_smoothing_ratio,
+            hill_window_ratio=hill_window_ratio,
+        )
+        PhysicalProfileMixin.__init__(self, dpmm=dpmm)
+
+    def as_resampled(
+        self,
+        interpolation_resolution_mm: float = 0.1,
+        order: int = 3,
+        grid: bool = True,
+    ) -> HillProfilePhysical:
+        return super().as_resampled(
+            interpolation_resolution_mm=interpolation_resolution_mm,
+            order=order,
+            grid=grid,
+        )
+
+
+class SingleProfile(ProfileMixin):
+    """A profile that has one large signal, e.g. a radiation beam profile.
+    Signal analysis methods are given, mostly based on FWXM and on Hill function calculations.
+    Profiles with multiple peaks are better suited by the MultiProfile class.
+    """
+
+    def __init__(
+        self,
+        values: np.ndarray,
+        dpmm: float = None,
+        interpolation: Interpolation | str | None = Interpolation.LINEAR,
+        ground: bool = True,
+        interpolation_resolution_mm: float = 0.1,
+        interpolation_factor: float = 10,
+        normalization_method: Normalization | str = Normalization.BEAM_CENTER,
+        edge_detection_method: Edge | str = Edge.FWHM,
+        edge_smoothing_ratio: float = 0.003,
+        hill_window_ratio: float = 0.1,
+        x_values: np.ndarray | None = None,
+    ):
+        """
+        Parameters
+        ----------
+        values
+            The profile numpy array. Must be 1D.
+        dpmm
+            The dots (pixels) per mm. Pass to get info like beam width in distance units in addition to pixels
+        interpolation
+            Interpolation technique.
+        ground
+            Whether to ground the profile (set min value to 0). Helpful most of the time.
+        interpolation_resolution_mm
+            The resolution that the interpolation will scale to. **Only used if dpmm is passed and interpolation is set**.
+            E.g. if the dpmm is 0.5 and the resolution is set to 0.1mm the data will be interpolated to have a new dpmm of 10 (1/0.1).
+        interpolation_factor
+            The factor to multiply the data by. **Only used if interpolation is used and dpmm is NOT passed**. E.g. 10
+            will perfectly decimate the existing data according to the interpolation method passed.
+        normalization_method
+            How to pick the point to normalize the data to.
+        edge_detection_method
+            The method by which to detect the field edge. FWHM is reasonable most of the time except for FFF beams.
+            Inflection-derivative will use the max gradient to determine the field edge. Note that this may not be the
+            50% height. In fact, for FFF beams it shouldn't be. Inflection methods are better for FFF and other unusual
+            beam shapes.
+        edge_smoothing_ratio
+            **Only applies to INFLECTION_DERIVATIVE and INFLECTION_HILL.**
+
+            The ratio of the length of the values to use as the sigma for a Gaussian filter applied before searching for
+            the inflection. E.g. 0.005 with a profile of 1000 points will result in a sigma of 5.
+            This helps make the inflection point detection more robust to noise. Increase for noisy data.
+        hill_window_ratio
+            The ratio of the field size to use as the window to fit the Hill function. E.g. 0.2 will using a window
+            centered about each edge with a width of 20% the size of the field width. **Only applies when the edge
+            detection is INFLECTION_HILL**.
+        x_values
+            The x-values of the profile, if any. If None, will generate a simple range(len(values)).
+        """
+        self._interp_method = convert_to_enum(interpolation, Interpolation)
+        self._interpolation_res = interpolation_resolution_mm
+        self._interpolation_factor = interpolation_factor
+        self._norm_method = convert_to_enum(normalization_method, Normalization)
+        self._edge_method = convert_to_enum(edge_detection_method, Edge)
+        self._edge_smoothing_ratio = edge_smoothing_ratio
+        self._hill_window_ratio = hill_window_ratio
+        self.values = (
+            values  # set initial data so we can do things like find beam center
+        )
+        self.dpmm = dpmm
+        fitted_values, new_dpmm, x_indices = self._interpolate(
+            values,
+            x_values,
+            dpmm,
+            interpolation_resolution_mm,
+            interpolation_factor,
+            self._interp_method,
+        )
+        self.values = fitted_values
+        self.x_indices = x_indices
+        self._x_interp1d = interp1d(list(range(len(x_indices))), x_indices)
+        self._ground = ground
+        if ground:
+            fitted_values -= fitted_values.min()
+        self._y_interp1d = interp1d(
+            x_indices, fitted_values, bounds_error=False, fill_value="extrapolate"
+        )
+        norm_values = self._normalize(fitted_values, self._norm_method)
+        self.values = norm_values  # update values
+        self._y_interp1d = interp1d(
+            x_indices, norm_values, bounds_error=False, fill_value="extrapolate"
+        )
+
+    def _x_interp_to_original(self, location: float | np.ndarray) -> float | np.ndarray:
+        """Get the x-value of the (possibly) interpolated profile. The input value is in the original
+        value range. E.g. a profile with x-range of 0-10 is interpolated to 10x. Asking for the location at 99 would scale back to 9.9.
+        We need this function because peak finding is independent of the x-values. I.e. peaks are found and reported according
+        to the (0, len(x_values)) range. If the x-values are interpolated we need to get back to the original x-value.
+        """
+        x = self._x_interp1d(location)
+        if isinstance(location, (float, int)) or location.size == 1:
+            return float(x)
+        return x
+
+    def _y_original_to_interp(self, location: float | np.ndarray) -> float | np.ndarray:
+        """Get the interpolated y-value of the profile. This is a corollary to the _x_interp... function"""
+        y = self._y_interp1d(location)
+        if isinstance(location, (float, int)) or location.size == 1:
+            return float(y)
+        return y
+
+    def resample(
+        self, interpolation_factor: int = 10, interpolation_resolution_mm: float = 0.1
+    ) -> SingleProfile:
+        """Resample the profile at a new resolution. Returns a new profile"""
+        # we have to set the dpmm to what it currently is after interpolating to resample.
+        if self.dpmm:
+            dpmm = 1 / self._interpolation_res
+        else:
+            dpmm = None
+        return SingleProfile(
+            values=self.values,
+            x_values=self.x_indices,
+            dpmm=dpmm,
+            interpolation=self._interp_method,
+            ground=self._ground,
+            interpolation_resolution_mm=interpolation_resolution_mm,
+            interpolation_factor=interpolation_factor,
+            normalization_method=self._norm_method,
+            edge_detection_method=self._edge_method,
+            edge_smoothing_ratio=self._edge_smoothing_ratio,
+            hill_window_ratio=self._hill_window_ratio,
+        )
+
+    @staticmethod
+    def _interpolate(
+        values,
+        x_values,
+        dpmm,
+        interpolation_resolution,
+        interpolation_factor,
+        interp_method: Interpolation,
+    ) -> (np.ndarray, float, float, float):
+        """Fit the data to the passed interpolation method. Will also calculate the new values to correct the measurements such as dpmm"""
+        if x_values is None:
+            x_values = np.array(range(len(values)))
+        if np.diff(x_values).min() < 0:
+            raise ValueError("Profile values must be monotonically increasing")
+        if interp_method == Interpolation.NONE:
+            return values, dpmm, x_values  # do nothing
+        else:
+            if dpmm is not None:
+                samples = int(round(len(x_values) / (dpmm * interpolation_resolution)))
+                new_dpmm = 1 / interpolation_resolution
+            else:
+                samples = int(round(len(x_values) * interpolation_factor))
+                new_dpmm = None
+            # Warning: BMF ahead
+            # the problem is that if we upsample, the left and right ends are not equally sampled.
+            # E.g. upsampling a 3-pixel array (0, 1, 2) by 10 normally results in ~20 elements. You
+            # interpolate between 0 and 1, and 1 and 2.
+            # The first issue is that you do not have a simple X proportion of
+            # elements (3 * 10 = 30 but we get 20). Additionally, if these are pixels they have a
+            # finite, physical size and technically those values are at the center of the pixels.
+            # Thus, you actually need to sample beyond the left and right edges. In the
+            # above case you'd really need to sample from approximately -0.5 to 2.5 to get ~10 pixels
+            # for each original pixel. We also need to offset the x-values to be back to 0 again from -0.5.
+            # We solve this by offsetting the new x-values by a proportion of the sampling ratio.
+            # A ratio of 1 (identical sampling) should not have any offset and return the same values
+            # As the ratio goes up, we approach the limit of 0.5 pixels. This follows a proportional relationship
+            # with the ratio.
+            resampling_factor = samples / len(values)
+            offset = 0.5 - 1 / (2 * resampling_factor)
+            if interp_method == Interpolation.LINEAR:
+                kind = "linear"
+            elif interp_method == Interpolation.SPLINE:
+                kind = "cubic"
+            f = interp1d(
+                x_values,
+                values,
+                kind=kind,
+                bounds_error=False,
+                fill_value="extrapolate",
+            )
+            new_x = np.linspace(
+                x_values[0] - offset, x_values[-1] + offset, num=samples
+            )
+            new_y = f(new_x)
+            return new_y, new_dpmm, new_x
+
+    def _normalize(self, values, method: Normalization) -> np.ndarray:
+        """Normalize the data given a method."""
+        if method == Normalization.NONE:
+            return values
+        elif method == Normalization.MAX:
+            return values / values.max()
+        elif method == Normalization.GEOMETRIC_CENTER:
+            return values / self._geometric_center(values)["value (exact)"]
+        elif method == Normalization.BEAM_CENTER:
+            return values / self.beam_center()["value (@rounded)"]
+
+    def _geometric_center(self, values) -> dict:
+        """Returns the center index and value of the profile.
+
+        If the profile has an even number of values the centre lies between the two centre indices and the centre
+        value is the average of the two centre values else the centre index and value are returned.
+        """
+        return {
+            "index (exact)": self._x_interp_to_original(
+                utils.geometric_center_idx(values)
+            ),
+            "value (exact)": utils.geometric_center_value(values),
+        }
+
+    def geometric_center(self) -> dict:
+        """The geometric center (i.e. the device center)"""
+        return self._geometric_center(self.values)
+
+    def beam_center(self) -> dict:
+        """The center of the detected beam. This can account for asymmetries in the beam position (e.g. offset jaws)"""
+        if self._edge_method == Edge.FWHM:
+            data = self.fwxm_data(x=50)
+            return {
+                "index (rounded)": data["center index (rounded)"],
+                "index (exact)": data["center index (exact)"],
+                "value (@rounded)": data["center value (@rounded)"],
+            }
+        elif self._edge_method in (Edge.INFLECTION_DERIVATIVE, Edge.INFLECTION_HILL):
+            infl = self.inflection_data()
+            mid_point = (
+                infl["left index (exact)"]
+                + (infl["right index (exact)"] - infl["left index (exact)"]) / 2
+            )
+            return {
+                "index (rounded)": int(round(mid_point)),
+                "index (exact)": mid_point,
+                "value (@rounded)": self._y_original_to_interp(int(round(mid_point))),
+            }
+
+    @argue.bounds(x=(0, 100))
+    def fwxm_data(self, x: int = 50) -> dict:
+        """Return the width at X-Max, where X is the percentage height.
+
+        Parameters
+        ----------
+        x
+            The percent height of the profile. E.g. x = 50 is 50% height,
+            i.e. FWHM.
+        """
+        _, peak_props = find_peaks(self.values, fwxm_height=x / 100, max_number=1)
+        left_idx = float(self._x_interp_to_original(peak_props["left_ips"][0]))
+        right_idx = float(self._x_interp_to_original(peak_props["right_ips"][0]))
+        width = right_idx - left_idx
+        fwxm_center_idx = (right_idx - left_idx) / 2 + left_idx
+
+        data = {
+            "width (exact)": width,
+            "width (rounded)": int(round(width)),
+            "center index (rounded)": int(round(fwxm_center_idx)),
+            "center index (exact)": fwxm_center_idx,
+            "center value (@rounded)": float(
+                self._y_original_to_interp(int(round(fwxm_center_idx)))
+            ),
+            "left index (exact)": left_idx,
+            "left index (rounded)": int(round(left_idx)),
+            "left value (@rounded)": float(
+                self._y_original_to_interp(int(round(left_idx)))
+            ),
+            "right index (exact)": right_idx,
+            "right index (rounded)": int(round(right_idx)),
+            "right value (@rounded)": float(
+                self._y_original_to_interp(int(round(right_idx)))
+            ),
+            "field values": self._y_original_to_interp(
+                self.x_indices[int(round(left_idx)) : int(round(right_idx))]
+            ),
+            "peak_props": peak_props,
+        }
+        if self.dpmm:
+            data["width (exact) mm"] = data["width (exact)"] / self.dpmm
+            data["left distance (exact) mm"] = (
+                abs(data["center index (exact)"] - data["left index (exact)"])
+                / self.dpmm
+            )
+            data["right distance (exact) mm"] = (
+                abs(data["right index (exact)"] - data["center index (exact)"])
+                / self.dpmm
+            )
+
+        return data
+
+    @argue.bounds(in_field_ratio=(0, 1.0), slope_exclusion_ratio=(0, 1.0))
+    def field_data(
+        self, in_field_ratio: float = 0.8, slope_exclusion_ratio=0.2
+    ) -> dict:
+        """Return the width at X-Max, where X is the percentage height.
+
+        Parameters
+        ----------
+        in_field_ratio
+            In Field Ratio: 1.0 is the entire detected field; 0.8 would be the central 80%, etc.
+        slope_exclusion_ratio
+            Ratio of the field width to use as the cutoff between "top" calculation and "slope" calculation. Useful for FFF beams.
+            This area is centrally located in the field. E.g. 0.2 will use the central 20% of the field to calculate
+            the "top" value. To calculate the slope of each side, the field width between the edges of the in_field_ratio
+            and the slope exclusion region are used.
+
+            .. warning:: The "top" value is always calculated. For FFF beams this should be reasonable, but for flat beams
+                         this value may end up being non-sensible.
+        """
+        if slope_exclusion_ratio >= in_field_ratio:
+            raise ValueError(
+                "The exclusion region must be smaller than the field ratio"
+            )
+        if self._edge_method == Edge.FWHM:
+            data = self.fwxm_data(x=50)
+            beam_center_idx = data["center index (exact)"]
+            full_width = data["width (exact)"]
+
+        elif self._edge_method in (Edge.INFLECTION_DERIVATIVE, Edge.INFLECTION_HILL):
+            infl_data = self.inflection_data()
+            beam_center_idx = self.beam_center()["index (exact)"]
+            full_width = (
+                infl_data["right index (exact)"] - infl_data["left index (exact)"]
+            )
+        beam_center_idx_r = int(round(beam_center_idx))
+
+        cax_idx = self.geometric_center()["index (exact)"]
+        cax_idx_r = int(round(cax_idx))
+
+        field_left_idx = beam_center_idx - in_field_ratio * full_width / 2
+        field_left_idx_r = int(round(field_left_idx))
+        field_right_idx = beam_center_idx + in_field_ratio * full_width / 2
+        field_right_idx_r = int(round(field_right_idx))
+        field_width = field_right_idx - field_left_idx
+
+        # slope calcs
+        inner_left_idx = beam_center_idx - slope_exclusion_ratio * field_width / 2
+        inner_left_idx_r = int(round(inner_left_idx))
+        inner_right_idx = beam_center_idx + slope_exclusion_ratio * field_width / 2
+        inner_right_idx_r = int(round(inner_right_idx))
+        left_fit = linregress(
+            range(field_left_idx_r, inner_left_idx_r + 1),
+            self._y_original_to_interp(
+                np.arange(field_left_idx_r, inner_left_idx_r + 1)
+            ),
+        )
+        right_fit = linregress(
+            range(inner_right_idx_r, field_right_idx_r + 1),
+            self._y_original_to_interp(
+                np.arange(inner_right_idx_r, field_right_idx_r + 1)
+            ),
+        )
+
+        # top calc
+        fit_params = np.polyfit(
+            range(inner_left_idx_r, inner_right_idx_r + 1),
+            self._y_original_to_interp(
+                np.arange(inner_left_idx_r, inner_right_idx_r + 1)
+            ),
+            deg=2,
+        )
+        width = abs(inner_right_idx_r - inner_left_idx_r)
+
+        def poly_func(x):
+            # return the negative since we're MINIMIZING and want the top value
+            return -(fit_params[0] * (x**2) + fit_params[1] * x + fit_params[2])
+
+        # minimize the polynomial function
+        min_f = minimize(
+            poly_func,
+            x0=(inner_left_idx_r + width / 2,),
+            bounds=((inner_left_idx_r, inner_right_idx_r),),
+        )
+        top_idx = min_f.x[0]
+        top_val = -min_f.fun
+
+        data = {
+            "width (exact)": field_width,
+            "beam center index (exact)": beam_center_idx,
+            "beam center index (rounded)": beam_center_idx_r,
+            "beam center value (@rounded)": self._y_original_to_interp(
+                round(beam_center_idx)
+            ),
+            "cax index (exact)": cax_idx,
+            "cax index (rounded)": cax_idx_r,
+            "cax value (@rounded)": self._y_original_to_interp(round(cax_idx)),
+            "left index (exact)": field_left_idx,
+            "left index (rounded)": field_left_idx_r,
+            "left value (@rounded)": self._y_original_to_interp(round(field_left_idx)),
+            "left slope": left_fit.slope,
+            "left intercept": left_fit.intercept,
+            "right slope": right_fit.slope,
+            "right intercept": right_fit.intercept,
+            "left inner index (exact)": inner_left_idx,
+            "left inner index (rounded)": inner_left_idx_r,
+            "right inner index (exact)": inner_right_idx,
+            "right inner index (rounded)": inner_right_idx_r,
+            '"top" index (exact)': top_idx,
+            '"top" index (rounded)': int(round(top_idx)),
+            '"top" value (@exact)': top_val,
+            "top params": fit_params,
+            "right index (exact)": field_right_idx,
+            "right index (rounded)": field_right_idx_r,
+            "right value (@rounded)": self._y_original_to_interp(
+                round(field_right_idx)
+            ),
+            "field values": self._y_original_to_interp(
+                np.arange(int(round(field_left_idx)), int(round(field_right_idx)) + 1)
+            ),
+        }
+        if self.dpmm:
+            data["width (exact) mm"] = data["width (exact)"] / self.dpmm
+            data["left slope (%/mm)"] = data["left slope"] * self.dpmm * 100
+            data["right slope (%/mm)"] = data["right slope"] * self.dpmm * 100
+            data["left distance->beam center (exact) mm"] = (
+                abs(data["beam center index (exact)"] - data["left index (exact)"])
+                / self.dpmm
+            )
+            data["right distance->beam center (exact) mm"] = (
+                abs(data["right index (exact)"] - data["beam center index (exact)"])
+                / self.dpmm
+            )
+            data["left distance->CAX (exact) mm"] = (
+                abs(data["cax index (exact)"] - data["left index (exact)"]) / self.dpmm
+            )
+            data["right distance->CAX (exact) mm"] = (
+                abs(data["cax index (exact)"] - data["right index (exact)"]) / self.dpmm
+            )
+
+            data["left distance->top (exact) mm"] = (
+                abs(data['"top" index (exact)'] - data["left index (exact)"])
+                / self.dpmm
+            )
+            data["right distance->top (exact) mm"] = (
+                abs(data['"top" index (exact)'] - data["right index (exact)"])
+                / self.dpmm
+            )
+            data['"top"->beam center (exact) mm'] = (
+                data['"top" index (exact)'] - data["beam center index (exact)"]
+            ) / self.dpmm
+            data['"top"->CAX (exact) mm'] = (
+                abs(data['"top" index (exact)'] - data["cax index (exact)"]) / self.dpmm
+            )
+        return data
+
+    def inflection_data(self) -> dict:
+        """Calculate the profile inflection values using either the 2nd derivative or a fitted Hill function.
+
+        .. note::
+            This only applies if the edge detection method is `INFLECTION_...`.
+
+        Parameters
+        ----------
+
+        """
+        # get max/min of the gradient, which is basically the same as the 2nd deriv 0-crossing
+        if self._edge_method == Edge.FWHM:
+            raise ValueError(
+                "FWHM edge method does not have inflection points. Use a different edge detection method"
+            )
+        d1 = np.gradient(
+            gaussian_filter1d(
+                self.values, sigma=self._edge_smoothing_ratio * len(self.values)
+            )
+        )
+        (peak_idxs, _) = MultiProfile(d1).find_peaks(threshold=0.8)
+        (valley_idxs, _) = MultiProfile(d1).find_valleys(threshold=0.8)
+        left_idx = self._x_interp_to_original(peak_idxs[0])  # left-most index
+        right_idx = self._x_interp_to_original(valley_idxs[-1])  # right-most index
+        if self._edge_method == Edge.INFLECTION_DERIVATIVE:
+            data = {
+                "left index (rounded)": int(round(left_idx)),
+                "left index (exact)": left_idx,
+                "right index (rounded)": int(round(right_idx)),
+                "right index (exact)": right_idx,
+                "left value (@rounded)": self._y_original_to_interp(
+                    int(round(left_idx))
+                ),
+                "left value (@exact)": self._y_original_to_interp(left_idx),
+                "right value (@rounded)": self._y_original_to_interp(
+                    int(round(right_idx))
+                ),
+                "right value (@exact)": self._y_original_to_interp(right_idx),
+            }
+            return data
+        else:  # Hill
+            # the 2nd deriv is a good approximation for the inflection point. Start there and fit Hill about it
+            # penum_half_window = self.field_data()['width (exact)'] * self._hill_window_ratio / 2
+            penum_half_window = int(
+                round(self._hill_window_ratio * abs(right_idx - left_idx) / 2)
+            )
+
+            # left side
+            x_data = np.array(
+                [
+                    x
+                    for x in np.arange(
+                        left_idx - penum_half_window, left_idx + penum_half_window
+                    )
+                    if x >= 0
+                ]
+            )
+            y_data = self._y_original_to_interp(x_data)
+            # y_data = self.values[left_idx - penum_half_window: left_idx + penum_half_window]
+            left_hill = Hill.fit(x_data, y_data)
+            left_infl = left_hill.inflection_idx()
+
+            # right side
+            x_data = np.array(
+                [
+                    x
+                    for x in np.arange(
+                        right_idx - penum_half_window, right_idx + penum_half_window
+                    )
+                    if x < len(d1)
+                ]
+            )
+            y_data = self._y_original_to_interp(x_data)
+            right_hill = Hill.fit(x_data, y_data)
+            right_infl = right_hill.inflection_idx()
+
+            data = {
+                "left index (rounded)": left_infl["index (rounded)"],
+                "left index (exact)": left_infl["index (exact)"],
+                "right index (rounded)": right_infl["index (rounded)"],
+                "right index (exact)": right_infl["index (exact)"],
+                "left value (@exact)": left_hill.y(left_infl["index (exact)"]),
+                "right value (@exact)": right_hill.y(right_infl["index (exact)"]),
+                "left Hill params": left_hill.params,
+                "right Hill params": right_hill.params,
+            }
+            return data
+
+    def penumbra(self, lower: int = 20, upper: int = 80):
+        """Calculate the penumbra of the field. Dependent on the edge detection method.
+
+        Parameters
+        ----------
+        lower
+            The lower % of the beam to use. If the edge method is FWHM, this is the typical % penumbra you're thinking.
+            If the inflection method is used it will be the value/50 of the inflection point value. E.g. if the inflection
+            point is perfectly at 50% with a ``lower`` of 20, then the penumbra value here will be 20% of the maximum.
+            If the inflection point is at 30% of the max value (say for a FFF beam) then the lower penumbra will be ``lower/50``
+            of the inflection point or ``0.3*lower/50``.
+        upper
+            Upper % of the beam to use. See lower for details.
+        """
+        if lower > upper:
+            raise ValueError(
+                "Upper penumbra value must be larger than the lower penumbra value"
+            )
+        if self._edge_method == Edge.FWHM:
+            upper_data = self.fwxm_data(x=upper)
+            lower_data = self.fwxm_data(x=lower)
+            data = {
+                f"left {lower}% index (exact)": lower_data["left index (exact)"],
+                f"left {lower}% value (@rounded)": lower_data["left value (@rounded)"],
+                f"left {upper}% index (exact)": upper_data["left index (exact)"],
+                f"left {upper}% value (@rounded)": upper_data["left value (@rounded)"],
+                f"right {lower}% index (exact)": lower_data["right index (exact)"],
+                f"right {lower}% value (@rounded)": lower_data[
+                    "right value (@rounded)"
+                ],
+                f"right {upper}% index (exact)": upper_data["right index (exact)"],
+                f"right {upper}% value (@rounded)": upper_data[
+                    "right value (@rounded)"
+                ],
+                "left values": self.values[
+                    lower_data["left index (rounded)"] : upper_data[
+                        "left index (rounded)"
+                    ]
+                ],
+                "right values": self.values[
+                    upper_data["right index (rounded)"] : lower_data[
+                        "right index (rounded)"
+                    ]
+                ],
+                "left penumbra width (exact)": abs(
+                    upper_data["left index (exact)"] - lower_data["left index (exact)"]
+                ),
+                "right penumbra width (exact)": abs(
+                    upper_data["right index (exact)"]
+                    - lower_data["right index (exact)"]
+                ),
+            }
+            if self.dpmm:
+                data["left penumbra width (exact) mm"] = (
+                    data["left penumbra width (exact)"] / self.dpmm
+                )
+                data["right penumbra width (exact) mm"] = (
+                    data["right penumbra width (exact)"] / self.dpmm
+                )
+            return data
+        elif self._edge_method == Edge.INFLECTION_DERIVATIVE:
+            infl_data = self.inflection_data()
+            lower_left_percent = max(
+                infl_data["left value (@exact)"] / self.values.max() * lower / 50 * 100,
+                1,
+            )
+            upper_left_percent = min(
+                infl_data["left value (@exact)"] / self.values.max() * upper / 50 * 100,
+                99,
+            )
+            upper_left_data = self.fwxm_data(x=upper_left_percent)
+            lower_left_data = self.fwxm_data(x=lower_left_percent)
+
+            lower_right_value = max(
+                infl_data["right value (@exact)"]
+                / self.values.max()
+                * lower
+                / 50
+                * 100,
+                1,
+            )
+            upper_right_value = min(
+                infl_data["right value (@exact)"]
+                / self.values.max()
+                * upper
+                / 50
+                * 100,
+                99,
+            )
+            upper_right_data = self.fwxm_data(x=upper_right_value)
+            lower_right_data = self.fwxm_data(x=lower_right_value)
+
+            data = {
+                f"left {lower}% index (exact)": lower_left_data["left index (exact)"],
+                f"left {upper}% index (exact)": upper_left_data["left index (exact)"],
+                f"right {lower}% index (exact)": lower_right_data[
+                    "right index (exact)"
+                ],
+                f"right {upper}% index (exact)": upper_right_data[
+                    "right index (exact)"
+                ],
+                "left values": self._y_original_to_interp(
+                    np.arange(
+                        lower_left_data["left index (rounded)"],
+                        upper_left_data["left index (rounded)"],
+                    )
+                ),
+                "right values": self._y_original_to_interp(
+                    np.arange(
+                        upper_right_data["right index (rounded)"],
+                        lower_right_data["right index (rounded)"],
+                    )
+                ),
+                "left penumbra width (exact)": abs(
+                    upper_left_data["left index (exact)"]
+                    - lower_left_data["left index (exact)"]
+                ),
+                "right penumbra width (exact)": abs(
+                    upper_right_data["right index (exact)"]
+                    - lower_right_data["right index (exact)"]
+                ),
+            }
+            if self.dpmm:
+                data["left penumbra width (exact) mm"] = (
+                    data["left penumbra width (exact)"] / self.dpmm
+                )
+                data["right penumbra width (exact) mm"] = (
+                    data["right penumbra width (exact)"] / self.dpmm
+                )
+            return data
+        elif self._edge_method == Edge.INFLECTION_HILL:
+            infl_data = self.inflection_data()
+            left_hill = Hill.from_params(infl_data["left Hill params"])
+            right_hill = Hill.from_params(infl_data["right Hill params"])
+
+            lower_left_percent = infl_data["left value (@exact)"] * lower / 50
+            lower_left_index = left_hill.x(lower_left_percent)
+            upper_left_percent = infl_data["left value (@exact)"] * upper / 50
+            upper_left_index = left_hill.x(upper_left_percent)
+
+            lower_right_value = infl_data["right value (@exact)"] * lower / 50
+            lower_right_index = right_hill.x(lower_right_value)
+            upper_right_value = infl_data["right value (@exact)"] * upper / 50
+            upper_right_index = right_hill.x(upper_right_value)
+
+            data = {
+                f"left {lower}% index (exact)": lower_left_index,
+                f"left {lower}% value (exact)": lower_left_percent,
+                f"left {upper}% index (exact)": upper_left_index,
+                f"left {upper}% value (exact)": upper_left_percent,
+                f"right {lower}% index (exact)": lower_right_index,
+                f"right {lower}% value (exact)": lower_right_value,
+                f"right {upper}% index (exact)": upper_right_index,
+                f"right {upper}% value (exact)": upper_right_value,
+                "left values": self.values[
+                    int(round(lower_left_index)) : int(round(upper_left_index))
+                ],
+                "right values": self.values[
+                    int(round(upper_right_index)) : int(round(lower_right_index))
+                ],
+                "left penumbra width (exact)": abs(upper_left_index - lower_left_index),
+                "right penumbra width (exact)": abs(
+                    upper_right_index - lower_right_index
+                ),
+                "left gradient (exact)": left_hill.gradient_at(
+                    infl_data["left index (exact)"]
+                ),
+                r"right gradient (exact)": right_hill.gradient_at(
+                    infl_data["right index (exact)"]
+                ),
+            }
+            if self.dpmm:
+                data["left penumbra width (exact) mm"] = (
+                    data["left penumbra width (exact)"] / self.dpmm
+                )
+                data["left gradient (exact) %/mm"] = (
+                    data["left gradient (exact)"] * self.dpmm * 100
+                )  # 100 to convert to %
+                data["right penumbra width (exact) mm"] = (
+                    data["right penumbra width (exact)"] / self.dpmm
+                )
+                data["right gradient (exact) %/mm"] = (
+                    data["right gradient (exact)"] * self.dpmm * 100
+                )
+            return data
+
+    @argue.options(calculation=("mean", "median", "max", "min", "area"))
+    def field_calculation(
+        self,
+        in_field_ratio: float = 0.8,
+        calculation: str = "mean",
+        slope_exclusion_ratio: float = 0.2,
+    ) -> float | tuple[float, float]:
+        """Perform an operation on the field values of the profile.
+        This function is useful for determining field symmetry and flatness.
+
+        Parameters
+        ----------
+        in_field_ratio
+            Ratio of the field width to use in the calculation.
+        calculation : {'mean', 'median', 'max', 'min', 'area'}
+            Calculation to perform on the field values.
+        """
+        field_values = self.field_data(
+            in_field_ratio, slope_exclusion_ratio=slope_exclusion_ratio
+        )
+
+        if calculation == "mean":
+            return field_values["field values"].mean()
+        elif calculation == "median":
+            return float(np.median(field_values["field values"]))
+        elif calculation == "max":
+            return field_values["field values"].max()
+        elif calculation == "min":
+            return field_values["field values"].min()
+
+    def gamma(
+        self,
+        evaluation_profile: SingleProfile,
+        distance_to_agreement: float = 1,
+        dose_to_agreement: float = 1,
+        gamma_cap_value: float = 2,
+        dose_threshold: float = 5,
+        global_dose: bool = True,
+        fill_value: float = np.nan,
+    ) -> np.ndarray:
+        """Calculate a 1D gamma. The passed profile is the evaluation profile. The instance calling this method is the reference profile.
+        This profile must have the `dpmm` value given at instantiation so that physical spacing can be evaluated.
+        The evaluation profile is resampled to be the same resolution as the reference profile.
+
+        .. note::
+
+            The difference between this method and the `gamma_1d` function is that 1) this is computed on Profile instances and 2)
+            this validates the physical spacing of the profiles.
+
+        Parameters
+        ----------
+        evaluation_profile
+            The evaluation profile. This profile must have the `dpmm` value given at instantiation so that physical spacing can be evaluated.
+        distance_to_agreement
+            Distance in **mm** to search
+        dose_to_agreement
+            Dose in % of either global or local reference dose
+        gamma_cap_value
+            The value to cap the gamma at. E.g. a gamma of 5.3 will get capped to 2. Useful for displaying data with a consistent range.
+        global_dose
+            Whether to evaluate the dose to agreement threshold based on the global max or the dose point under evaluation.
+        dose_threshold
+            The dose threshold as a number between 0 and 100 of the % of max dose under which a gamma is not calculated.
+            This is not affected by the global/local dose normalization and the threshold value is evaluated against the global max dose, period.
+        fill_value
+            The value to give pixels that were not calculated because they were under the dose threshold. Default
+            is NaN, but another option would be 0. If NaN, allows the user to calculate mean/median gamma over just the
+            evaluated portion and not be skewed by 0's that should not be considered.
+        """
+        if not self.dpmm or not evaluation_profile.dpmm:
+            raise ValueError(
+                "At least one profile does not have the dpmm attribute. Physical spacing cannot be determined. Set it before performing gamma analysis."
+            )
+        distance_to_agreement_px = int(round(distance_to_agreement * self.dpmm))
+        # resample eval profile to be same resolution as reference
+        resampled_evaluation = evaluation_profile.resample(
+            interpolation_resolution_mm=self._interpolation_res
+        )
+        if len(resampled_evaluation.values) != len(self.values):
+            warnings.warn(
+                f"The number of elements in the reference and evaluation differ. Ref: {len(self.values)}, Eval: {len(resampled_evaluation.values)}"
+            )
+        # now that we've resampled, it's still possible that the x-values of the two profiles differ.
+        # E.g. we may be at -0.475 and -0.37 for the first index depending on the amount of interpolation.
+        # we thus need to evaluate the evaluation profile at the exact same x-indices as the reference.
+        eval_at_ref_points = resampled_evaluation._y_original_to_interp(self.x_indices)
+        return gamma_1d(
+            reference=self.values,
+            evaluation=eval_at_ref_points,
+            dose_to_agreement=dose_to_agreement,
+            distance_to_agreement=distance_to_agreement_px,
+            gamma_cap_value=gamma_cap_value,
+            global_dose=global_dose,
+            dose_threshold=dose_threshold,
+            fill_value=fill_value,
+        )
+
+    def plot(self, show: bool = True) -> None:
+        """Plot the profile."""
+        plt.plot(self.x_indices, self.values)
+        if show:
+            plt.show()
+
+
+class MultiProfile(ProfileMixin):
+    """A class for analyzing 1-D profiles that contain multiple signals. Methods are mostly for *finding & filtering*
+    the signals, peaks, valleys, etc. Profiles with a single peak (e.g. radiation beam profiles) are better suited by the SingleProfile class.
+
+    Attributes
+    ----------
+    values : ndarray
+        The array of values passed in on instantiation.
+    peaks : list
+        List of Points, containing value and index information.
+    valleys : list
+        Same as peaks, but for valleys.
+
+    """
+
+    values: np.ndarray | Sequence
+    peaks: list
+    valleys: list
+
+    def __init__(self, values: np.array | Sequence):
+        """
+        Parameters
+        ----------
+        values : iterable
+            Array of profile values.
+        """
+        self.values = values
+        self.peaks = []
+        self.valleys = []
+
+    def plot(self, ax: plt.Axes | None = None) -> None:
+        """Plot the profile.
+
+        Parameters
+        ----------
+        ax: plt.Axes
+            An axis to plot onto. Optional.
+        """
+        if ax is None:
+            fig, ax = plt.subplots()
+        ax.plot(self.values)
+        peaks_x = [peak.idx for peak in self.peaks]
+        peaks_y = [peak.value for peak in self.peaks]
+        ax.plot(peaks_x, peaks_y, "gv")
+        valley_x = [peak.idx for peak in self.valleys]
+        valley_y = [peak.value for peak in self.valleys]
+        ax.plot(valley_x, valley_y, "r^")
+
+    def find_peaks(
+        self,
+        threshold: float | int = 0.3,
+        min_distance: float | int = 0.05,
+        max_number: int = None,
+        search_region: tuple = (0.0, 1.0),
+        peak_sort: str = "prominences",
+    ) -> tuple[np.array, np.array]:
+        """Find the peaks of the profile using a simple maximum value search. This also sets the `peaks` attribute.
+
+        Parameters
+        ----------
+        threshold : int, float
+            The value the peak must be above to be considered a peak. This removes "peaks"
+            that are in a low-value region.
+            If passed an int, the actual value is the threshold.
+            E.g. when passed 15, any peak less with a value <15 is removed.
+            If passed a float, it will threshold as a percent. Must be between 0 and 1.
+            E.g. when passed 0.4, any peak <40% of the maximum value will be removed.
+        min_distance : int, float
+            If passed an int, parameter is the number of elements apart a peak must be from neighboring peaks.
+            If passed a float, must be between 0 and 1 and represents the ratio of the profile to exclude.
+            E.g. if passed 0.05 with a 1000-element profile, the minimum peak width will be 0.05*1000 = 50 elements.
+        max_number : int, None
+            Specify up to how many peaks will be returned. E.g. if 3 is passed in and 5 peaks are found, only the 3 largest
+            peaks will be returned. If None, no limit will be applied.
+        search_region : tuple of ints, floats, or both
+            The region within the profile to search. The tuple specifies the (left, right) edges to search.
+            This allows exclusion of edges from the search. If a value is an int, it is taken as is. If a float, must
+            be between 0 and 1 and is the ratio of the profile length. The left value must be less than the right.
+
+        Returns
+        -------
+        indices: ndarray, values, ndarray
+            The indices and values of the peaks.
+        """
+        peak_idxs, peak_props = find_peaks(
+            self.values,
+            threshold=threshold,
+            peak_separation=min_distance,
+            max_number=max_number,
+            search_region=search_region,
+            peak_sort=peak_sort,
+        )
+        self.peaks = [
+            Point(value=peak_val, idx=peak_idx)
+            for peak_idx, peak_val in zip(peak_idxs, peak_props["peak_heights"])
+        ]
+
+        return peak_idxs, peak_props["peak_heights"]
+
+    def find_valleys(
+        self,
+        threshold: float | int = 0.3,
+        min_distance: float | int = 0.05,
+        max_number: int = None,
+        search_region: tuple = (0.0, 1.0),
+    ) -> tuple[np.array, np.array]:
+        """Find the valleys (minimums) of the profile using a simple minimum value search.
+
+        Returns
+        -------
+        indices: ndarray, values, ndarray
+            The indices and values of the valleys.
+
+        See Also
+        --------
+        :meth:`~pylinac.core.profile.MultiProfile.find_peaks` : Further parameter info.
+        """
+        valley_idxs, valley_props = find_peaks(
+            -self.values,
+            threshold=threshold,
+            peak_separation=min_distance,
+            max_number=max_number,
+            search_region=search_region,
+        )
+        self.valleys = [
+            Point(value=self.values[valley_idx], idx=valley_idx)
+            for valley_idx, valley_val in zip(
+                valley_idxs, -valley_props["peak_heights"]
+            )
+        ]
+
+        return valley_idxs, self.values[valley_idxs]
+
+    def find_fwxm_peaks(
+        self,
+        threshold: float | int = 0.3,
+        min_distance: float | int = 0.05,
+        max_number: int = None,
+        search_region: tuple = (0.0, 1.0),
+        peak_sort: str = "prominences",
+        required_prominence=None,
+    ) -> tuple[np.array, np.array]:
+        """Find peaks using the center of the FWXM (rather than by max value).
+
+        Parameters
+        ----------
+        x : int, float
+            The Full-Width-X-Maximum desired. E.g. 0.7 will return the FW70%M.
+            Values must be between 0 and 100.
+
+        See Also
+        --------
+        find_peaks : Further parameter info
+        """
+        _, peak_props = find_peaks(
+            self.values,
+            threshold=threshold,
+            min_width=min_distance,
+            max_number=max_number,
+            search_region=search_region,
+            peak_sort=peak_sort,
+            required_prominence=required_prominence,
+        )
+        fwxm_peak_idxs = []
+        for lt, rt in zip(peak_props["left_ips"], peak_props["right_ips"]):
+            fwxm = int(round(lt + (rt - lt) / 2))
+            fwxm_peak_idxs.append(fwxm)
+
+        fwxm_peak_vals = [self.values[fwxm] for fwxm in fwxm_peak_idxs]
+        self.peaks = [
+            Point(value=peak_val, idx=peak_idx)
+            for peak_idx, peak_val in zip(fwxm_peak_idxs, fwxm_peak_vals)
+        ]
+
+        return np.array(fwxm_peak_idxs), np.array(fwxm_peak_vals)
+
+
+class CircleProfile(MultiProfile, Circle):
+    """A profile in the shape of a circle.
+
+    Attributes
+    ----------
+    image_array : ndarray
+        The 2D image array.
+    start_angle : int, float
+        Starting position of the profile in radians; 0 is right (0 on unit circle).
+    ccw : bool
+        How the profile is/was taken; clockwise or counter-clockwise.
+    """
+
+    image_array: np.array
+    start_angle: float | int
+    ccw: bool
+    sampling_ratio: float
+    _x_locations: np.array | None
+    _y_locations: np.array | None
+
+    def __init__(
+        self,
+        center: Point,
+        radius: float,
+        image_array: np.array,
+        start_angle: float | int = 0,
+        ccw: bool = True,
+        sampling_ratio: float = 1.0,
+    ):
+        """
+        Parameters
+        ----------
+        image_array : ndarray
+            The 2D image array.
+        start_angle : int, float
+            Starting position of the profile in radians; 0 is right (0 on unit circle).
+        ccw : bool
+            If True (default), the profile will proceed counter-clockwise (the direction on the unit circle).
+            If False, will proceed clockwise.
+        sampling_ratio : float
+            The ratio of pixel sampling to real pixels. E.g. if 1.0, the profile will have approximately
+            the same number of elements as was encountered in the profile. A value of 2.0 will sample
+            the profile at 2x the number of elements.
+
+        See Also
+        --------
+        :class:`~pylinac.core.geometry.Circle` : Further parameter info.
+        """
+        Circle.__init__(self, center, radius)
+        self._ensure_array_size(
+            image_array, self.radius + self.center.x, self.radius + self.center.y
+        )
+        self.image_array = image_array
+        self.start_angle = start_angle
+        self.ccw = ccw
+        self.sampling_ratio = sampling_ratio
+        self._x_locations = None
+        self._y_locations = None
+        MultiProfile.__init__(self, self._profile)
+
+    @property
+    def size(self) -> float:
+        """The elemental size of the profile."""
+        return np.pi * self.radius * 2 * self.sampling_ratio
+
+    @property
+    def _radians(self) -> np.array:
+        interval = (2 * np.pi) / self.size
+        rads = np.arange(
+            0 + self.start_angle, (2 * np.pi) + self.start_angle - interval, interval
+        )
+        if self.ccw:
+            rads = rads[::-1]
+        return rads
+
+    @property
+    def x_locations(self) -> np.array:
+        """The x-locations of the profile values."""
+        if self._x_locations is None:
+            return np.cos(self._radians) * self.radius + self.center.x
+        else:
+            return self._x_locations
+
+    @x_locations.setter
+    def x_locations(self, array: np.array):
+        self._x_locations = array
+
+    @property
+    def y_locations(self) -> np.array:
+        """The x-locations of the profile values."""
+        if self._y_locations is None:
+            return np.sin(self._radians) * self.radius + self.center.y
+        else:
+            return self._y_locations
+
+    @y_locations.setter
+    def y_locations(self, array: np.array):
+        self._y_locations = array
+
+    @property
+    def _profile(self) -> np.array:
+        """The actual profile array; private attr that is passed to MultiProfile."""
+        return ndimage.map_coordinates(
+            self.image_array, [self.y_locations, self.x_locations], order=0
+        )
+
+    def find_peaks(
+        self,
+        threshold: float | int = 0.3,
+        min_distance: float | int = 0.05,
+        max_number: int = None,
+        search_region: tuple[float, float] = (0.0, 1.0),
+    ) -> tuple[np.array, np.array]:
+        """Overloads Profile to also map peak locations to the image."""
+        peak_idxs, peak_vals = super().find_peaks(
+            threshold, min_distance, max_number, search_region
+        )
+        self._map_peaks()
+        return peak_idxs, peak_vals
+
+    def find_valleys(
+        self,
+        threshold: float | int = 0.3,
+        min_distance: float | int = 0.05,
+        max_number: int = None,
+        search_region: tuple[float, float] = (0.0, 1.0),
+    ) -> tuple[np.array, np.array]:
+        """Overload Profile to also map valley locations to the image."""
+        valley_idxs, valley_vals = super().find_valleys(
+            threshold, min_distance, max_number, search_region
+        )
+        self._map_peaks()
+        return valley_idxs, valley_vals
+
+    def find_fwxm_peaks(
+        self,
+        threshold: float | int = 0.3,
+        min_distance: float | int = 0.05,
+        max_number: int = None,
+        search_region: tuple[float, float] = (0.0, 1.0),
+    ) -> tuple[np.array, np.array]:
+        """Overloads Profile to also map the peak locations to the image."""
+        peak_idxs, peak_vals = super().find_fwxm_peaks(
+            threshold, min_distance, max_number, search_region=search_region
+        )
+        self._map_peaks()
+        return peak_idxs, peak_vals
+
+    def _map_peaks(self) -> None:
+        """Map found peaks to the x,y locations on the image/array; i.e. adds x,y coordinates to the peak locations"""
+        for peak in self.peaks:
+            peak.x = self.x_locations[int(peak.idx)]
+            peak.y = self.y_locations[int(peak.idx)]
+
+    def roll(self, amount: int) -> None:
+        """Roll the profile and x and y coordinates."""
+        self.values = np.roll(self.values, -amount)
+        self.x_locations = np.roll(self.x_locations, -amount)
+        self.y_locations = np.roll(self.y_locations, -amount)
+
+    def plot2axes(
+        self,
+        axes: plt.Axes = None,
+        edgecolor: str = "black",
+        fill: bool = False,
+        plot_peaks: bool = True,
+    ) -> None:
+        """Plot the circle to an axes.
+
+        Parameters
+        ----------
+        axes : matplotlib.Axes, None
+            The axes to plot on. If None, will create a new figure of the image array.
+        edgecolor : str
+            Color of the Circle; must be a valid matplotlib color.
+        fill : bool
+            Whether to fill the circle. matplotlib keyword.
+        plot_peaks : bool
+            If True, plots the found peaks as well.
+        """
+        if axes is None:
+            fig, axes = plt.subplots()
+            axes.imshow(self.image_array)
+        axes.add_patch(
+            mpl_Circle(
+                (self.center.x, self.center.y),
+                edgecolor=edgecolor,
+                radius=self.radius,
+                fill=fill,
+            )
+        )
+        if plot_peaks:
+            x_locs = [peak.x for peak in self.peaks]
+            y_locs = [peak.y for peak in self.peaks]
+            axes.autoscale(enable=False)
+            axes.scatter(x_locs, y_locs, s=40, marker="x", c=edgecolor)
+
+    @staticmethod
+    def _ensure_array_size(
+        array: np.array, min_width: float, min_height: float
+    ) -> None:
+        """Ensure the array size of inputs are greater than the minimums."""
+        height = array.shape[0]
+        width = array.shape[1]
+        if width < min_width or height < min_height:
+            raise ValueError("Array size not large enough to compute profile")
+
+
+class CollapsedCircleProfile(CircleProfile):
+    """A circular profile that samples a thick band around the nominal circle, rather than just a 1-pixel-wide profile
+    to give a mean value.
+    """
+
+    width_ratio: float
+    num_profiles: int
+
+    @argue.bounds(width_ratio=(0, 1))
+    def __init__(
+        self,
+        center: Point,
+        radius: float,
+        image_array: np.ndarray,
+        start_angle: int = 0,
+        ccw: bool = True,
+        sampling_ratio: float = 1.0,
+        width_ratio: float = 0.1,
+        num_profiles: int = 20,
+    ):
+        """
+        Parameters
+        ----------
+        width_ratio : float
+            The "thickness" of the band to sample. The ratio is relative to the radius. E.g. if the radius is 20
+            and the width_ratio is 0.2, the "thickness" will be 4 pixels.
+        num_profiles : int
+            The number of profiles to sample in the band. Profiles are distributed evenly within the band.
+
+        See Also
+        --------
+        :class:`~pylinac.core.profile.CircleProfile` : Further parameter info.
+        """
+        self.width_ratio = width_ratio
+        self.num_profiles = num_profiles
+        super().__init__(center, radius, image_array, start_angle, ccw, sampling_ratio)
+
+    @property
+    def _radii(self) -> np.array:
+        return np.linspace(
+            start=self.radius * (1 - self.width_ratio),
+            stop=self.radius * (1 + self.width_ratio),
+            num=self.num_profiles,
+        )
+
+    @property
+    def size(self) -> float:
+        return np.pi * max(self._radii) * 2 * self.sampling_ratio
+
+    @property
+    def _multi_x_locations(self) -> list:
+        """List of x-locations of the sampling profiles"""
+        x = []
+        cos = np.cos(self._radians)
+        # extract profile for each circle radii
+        for radius in self._radii:
+            x.append(cos * radius + self.center.x)
+        return x
+
+    @property
+    def _multi_y_locations(self) -> list:
+        """List of x-locations of the sampling profiles"""
+        y = []
+        sin = np.sin(self._radians)
+        # extract profile for each circle radii
+        for radius in self._radii:
+            y.append(sin * radius + self.center.y)
+        return y
+
+    @property
+    def _profile(self) -> np.array:
+        """The actual profile array; private attr that is passed to MultiProfile."""
+        profile = np.zeros(len(self._multi_x_locations[0]))
+        for radius, x, y in zip(
+            self._radii, self._multi_x_locations, self._multi_y_locations
+        ):
+            profile += ndimage.map_coordinates(self.image_array, [y, x], order=0)
+        profile /= self.num_profiles
+        return profile
+
+    def plot2axes(
+        self,
+        axes: plt.Axes = None,
+        edgecolor: str = "black",
+        fill: bool = False,
+        plot_peaks: bool = True,
+    ) -> None:
+        """Add 2 circles to the axes: one at the maximum and minimum radius of the ROI.
+
+        See Also
+        --------
+        :meth:`~pylinac.core.profile.CircleProfile.plot2axes` : Further parameter info.
+        """
+        if axes is None:
+            fig, axes = plt.subplots()
+            axes.imshow(self.image_array)
+        axes.add_patch(
+            mpl_Circle(
+                (self.center.x, self.center.y),
+                edgecolor=edgecolor,
+                radius=self.radius * (1 + self.width_ratio),
+                fill=fill,
+            )
+        )
+        axes.add_patch(
+            mpl_Circle(
+                (self.center.x, self.center.y),
+                edgecolor=edgecolor,
+                radius=self.radius * (1 - self.width_ratio),
+                fill=fill,
+            )
+        )
+        if plot_peaks:
+            x_locs = [peak.x for peak in self.peaks]
+            y_locs = [peak.y for peak in self.peaks]
+            axes.autoscale(enable=False)
+            axes.scatter(x_locs, y_locs, s=20, marker="x", c=edgecolor)
+
+
+def find_peaks(
+    values: np.array,
+    threshold: float | int = -np.inf,
+    peak_separation: float | int = 0,
+    max_number: int | None = None,
+    fwxm_height: float = 0.5,
+    min_width: int = 0,
+    search_region: tuple[float, float] = (0.0, 1.0),
+    peak_sort: str = "prominences",
+    required_prominence: float | np.array | None = None,
+) -> tuple[np.array, dict]:
+    """Find the peaks of a 1D signal. Heavily relies on the scipy implementation.
+
+    Parameters
+    ----------
+    values : array-like
+        Signal values to search for peaks within.
+    threshold : int, float
+        The value the peak must be above to be considered a peak. This removes "peaks"
+        that are in a low-value region.
+        If passed an int, the actual value is the threshold.
+        E.g. when passed 15, any peak less with a value <15 is removed.
+        If passed a float, it will threshold as a percent. Must be between 0 and 1.
+        E.g. when passed 0.4, any peak <40% of the maximum value will be removed.
+    peak_separation : int, float
+        If passed an int, parameter is the number of elements apart a peak must be from neighboring peaks.
+        If passed a float, must be between 0 and 1 and represents the ratio of the profile to exclude.
+        E.g. if passed 0.05 with a 1000-element profile, the minimum peak width will be 0.05*1000 = 50 elements.
+    max_number : int, None
+        Specify up to how many peaks will be returned. E.g. if 3 is passed in and 5 peaks are found, only the 3 largest
+        peaks will be returned.
+    fwxm_height: float
+        The relative height at which a FWXM calculation is performed. Although this function finds simple max values,
+        the underlying function can provide fwxm information as well.
+    min_width: int
+        The minimum width of the peak.
+    search_region: tuple
+        The search region to use within the values.
+        Using between 0 and 1 will convert to a ratio of the indices. E.g. to search the middle half of the passed values, use (0.25, 0.75).
+        Using ints above 1 will use the indices directly. E.g. (33, 71) will search between those two indices.
+    peak_sort
+        The method of sorting peaks. See scipy find_peaks documentation.
+    required_prominence
+        The relative height of the peak compared to surrounding valleys to be considered a peak. See scipy's find_peaks documentation.
+
+    Returns
+    -------
+    peak_idxs : numpy.array
+        The indices of the peaks found.
+    peak_props : dict
+        A dict containing contextual peak data.
+    """
+    peak_separation, shift_amount, threshold, trimmed_values = _parse_peak_args(
+        peak_separation, search_region, threshold, values
+    )
+
+    peak_idxs, peak_props = signal.find_peaks(
+        trimmed_values,
+        rel_height=(1 - fwxm_height),
+        width=min_width,
+        height=threshold,
+        distance=peak_separation,
+        prominence=required_prominence,
+    )
+    peak_idxs += shift_amount  # shift according to the search region left edge
+
+    # get the "largest" peaks up to max number, and then re-sort to be left->right like it was originally
+    largest_peak_idxs = sorted(
+        list(np.argsort(peak_props[peak_sort]))[::-1][:max_number]
+    )
+
+    # cut down prop arrays as need be
+    for key, array_vals in peak_props.items():
+        peak_props[key] = array_vals[largest_peak_idxs]
+    return peak_idxs[largest_peak_idxs], peak_props
+
+
+def _parse_peak_args(
+    peak_separation: float,
+    search_region: tuple[float, float],
+    threshold: float,
+    values: np.array,
+) -> tuple[float, int, float, np.array]:
+    """Converts arguments as needed. E.g. converting a ratio to actual values"""
+    # set threshold as % if between 0 and 1
+    val_range = values.max() - values.min()
+    if 0 <= threshold <= 1:
+        threshold = values.min() + threshold * val_range
+    # set separation as % if between 0 and 1
+    if 0 <= peak_separation <= 1:
+        peak_separation = max(int(peak_separation * len(values)), 1)
+    # limit to search region
+    if max(search_region) <= 1:
+        shift_amount = int(search_region[0] * len(values))
+        values = values[
+            int(search_region[0] * len(values)) : int(search_region[1] * len(values))
+        ]
+    else:
+        values = values[search_region[0] : search_region[1]]
+        shift_amount = search_region[0]
+    return peak_separation, shift_amount, threshold, values
```

### Comparing `manteia_qa_pylinac-1.0.0/pylinac/core/roi.py` & `manteia_qa_pylinac-1.1.0/pylinac/core/roi.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,399 +1,408 @@
-from __future__ import annotations
-
-from functools import cached_property
-
-import matplotlib.pyplot as plt
-import numpy as np
-from skimage import draw
-from skimage.measure._regionprops import _RegionProperties
-
-from .contrast import Contrast, contrast, michelson, ratio, rms, visibility, weber
-from .decorators import lru_cache
-from .geometry import Circle, Point, Rectangle
-from .image import ArrayImage
-
-
-def bbox_center(region: _RegionProperties) -> Point:
-    """Return the center of the bounding box of an scikit-image region.
-
-    Parameters
-    ----------
-    region
-        A scikit-image region as calculated by skimage.measure.regionprops().
-
-    Returns
-    -------
-    point : :class:`~pylinac.core.geometry.Point`
-    """
-    bbox = region.bbox
-    y = abs(bbox[0] - bbox[2]) / 2 + min(bbox[0], bbox[2])
-    x = abs(bbox[1] - bbox[3]) / 2 + min(bbox[1], bbox[3])
-    return Point(x, y)
-
-
-class DiskROI(Circle):
-    """An class representing a disk-shaped Region of Interest."""
-
-    def __init__(
-        self,
-        array: np.ndarray,
-        angle: float,
-        roi_radius: float,
-        dist_from_center: float,
-        phantom_center: tuple | Point,
-    ):
-        """
-        Parameters
-        ----------
-        array : ndarray
-            The 2D array representing the image the disk is on.
-        angle : int, float
-            The angle of the ROI in degrees from the phantom center.
-        roi_radius : int, float
-            The radius of the ROI from the center of the phantom.
-        dist_from_center : int, float
-            The distance of the ROI from the phantom center.
-        phantom_center : tuple
-            The location of the phantom center.
-        """
-        center = self._get_shifted_center(angle, dist_from_center, phantom_center)
-        super().__init__(center_point=center, radius=roi_radius)
-        self._array = array
-
-    @staticmethod
-    def _get_shifted_center(
-        angle: float,
-        dist_from_center: float,
-        phantom_center: Point,
-    ) -> Point:
-        """The center of the ROI; corrects for phantom dislocation and roll."""
-        y_shift = np.sin(np.deg2rad(angle)) * dist_from_center
-        x_shift = np.cos(np.deg2rad(angle)) * dist_from_center
-        return Point(phantom_center.x + x_shift, phantom_center.y + y_shift)
-
-    @cached_property
-    def pixel_values(self) -> np.ndarray:
-        return self.circle_mask()
-
-    @cached_property
-    def pixel_value(self) -> float:
-        """The median pixel value of the ROI."""
-        masked_img = self.circle_mask()
-        return float(np.median(masked_img))
-
-    @cached_property
-    def std(self) -> float:
-        """The standard deviation of the pixel values."""
-        masked_img = self.circle_mask()
-        return float(np.std(masked_img))
-
-    @lru_cache()
-    def circle_mask(self) -> np.ndarray:
-        """Return a mask of the image, only showing the circular ROI."""
-        rr, cc = draw.disk(center=(self.center.y, self.center.x), radius=self.radius)
-        return self._array[rr, cc]
-
-    def plot2axes(
-        self,
-        axes: plt.Axes | None = None,
-        edgecolor: str = "black",
-        fill: bool = False,
-        text: str = "",
-        fontsize: str = "medium",
-    ) -> None:
-        """Plot the Circle on the axes.
-
-        Parameters
-        ----------
-        axes : matplotlib.axes.Axes
-            An MPL axes to plot to.
-        edgecolor : str
-            The color of the circle.
-        fill : bool
-            Whether to fill the circle with color or leave hollow.
-        text: str
-            If provided, plots the given text at the center. Useful for differentiating ROIs on a plotted image.
-        fontsize: str
-            The size of the text, if provided. See https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.text.html
-            for options.
-        """
-        if axes is None:
-            fig, axes = plt.subplots()
-            axes.imshow(self._array)
-        super().plot2axes(axes, edgecolor=edgecolor, text=text, fontsize=fontsize)
-
-    def as_dict(self) -> dict:
-        """Convert to dict. Useful for dataclasses/Result"""
-        data = super().as_dict()
-        data.update({"median": self.pixel_value, "std": self.std})
-        return data
-
-
-class LowContrastDiskROI(DiskROI):
-    """A class for analyzing the low-contrast disks."""
-
-    contrast_threshold: float | None
-    cnr_threshold: float | None
-    contrast_reference: float | None
-
-    def __init__(
-        self,
-        array: np.ndarray | ArrayImage,
-        angle: float,
-        roi_radius: float,
-        dist_from_center: float,
-        phantom_center: tuple | Point,
-        contrast_threshold: float | None = None,
-        contrast_reference: float | None = None,
-        cnr_threshold: float | None = None,
-        contrast_method: str = Contrast.MICHELSON,
-        visibility_threshold: float | None = 0.1,
-    ):
-        """
-        Parameters
-        ----------
-        contrast_threshold : float, int
-            The threshold for considering a bubble to be "seen".
-        """
-        super().__init__(array, angle, roi_radius, dist_from_center, phantom_center)
-        self.contrast_threshold = contrast_threshold
-        self.cnr_threshold = cnr_threshold
-        self.contrast_reference = contrast_reference
-        self.contrast_method = contrast_method
-        self.visibility_threshold = visibility_threshold
-
-    @property
-    def _contrast_array(self) -> np.ndarray:
-        return np.array((self.pixel_value, self.contrast_reference))
-
-    @property
-    def signal_to_noise(self) -> float:
-        """The signal-to-noise ratio. Cast to numpy first to use numpy overflow handling."""
-        return float(np.array(self.pixel_value) / self.std)
-
-    @property
-    def contrast_to_noise(self) -> float:
-        """The contrast to noise ratio of the ROI. Cast to numpy first to use numpy overflow handling."""
-        return float(np.array(self.contrast) / self.std)
-
-    @property
-    def michelson(self) -> float:
-        """The Michelson contrast"""
-        return michelson(self._contrast_array)
-
-    @property
-    def weber(self) -> float:
-        """The Weber contrast"""
-        return weber(feature=self.pixel_value, background=self.contrast_reference)
-
-    @property
-    def rms(self) -> float:
-        """The root-mean-square contrast"""
-        return rms(self._contrast_array)
-
-    @property
-    def ratio(self) -> float:
-        """The ratio contrast"""
-        return ratio(self._contrast_array)
-
-    @property
-    def contrast(self) -> float:
-        """The contrast of the bubble. Uses the contrast method passed in the constructor. See https://en.wikipedia.org/wiki/Contrast_(vision)."""
-        return contrast(self._contrast_array, self.contrast_method)
-
-    @property
-    def cnr_constant(self) -> float:
-        """The contrast-to-noise value times the bubble diameter."""
-        DeprecationWarning(
-            "The 'cnr_constant' property will be deprecated in a future release. Use .visibility instead."
-        )
-        return self.contrast_to_noise * self.diameter
-
-    @property
-    def visibility(self) -> float:
-        """The visual perception of CNR. Uses the model from A Rose: https://www.osapublishing.org/josa/abstract.cfm?uri=josa-38-2-196.
-        See also here: https://howradiologyworks.com/x-ray-cnr/.
-        Finally, a review paper here: http://xrm.phys.northwestern.edu/research/pdf_papers/1999/burgess_josaa_1999.pdf
-        Importantly, the Rose model is not applicable for high-contrast use cases."""
-        return visibility(
-            array=self._contrast_array,
-            radius=self.radius,
-            std=self.std,
-            algorithm=self.contrast_method,
-        )
-
-    @property
-    def contrast_constant(self) -> float:
-        """The contrast value times the bubble diameter."""
-        DeprecationWarning(
-            "The 'contrast_constant' property will be deprecated in a future release. Use .visibility instead."
-        )
-        return self.contrast * self.diameter
-
-    @property
-    def passed(self) -> bool:
-        """Whether the disk ROI contrast passed."""
-        return self.contrast > self.contrast_threshold
-
-    @property
-    def passed_visibility(self) -> bool:
-        """Whether the disk ROI's visibility passed."""
-        return self.visibility > self.visibility_threshold
-
-    @property
-    def passed_contrast_constant(self) -> bool:
-        """Boolean specifying if ROI pixel value was within tolerance of the nominal value."""
-        return self.contrast_constant > self.contrast_threshold
-
-    @property
-    def passed_cnr_constant(self) -> bool:
-        """Boolean specifying if ROI pixel value was within tolerance of the nominal value."""
-        return self.cnr_constant > self.cnr_threshold
-
-    @property
-    def plot_color(self) -> str:
-        """Return one of two colors depending on if ROI passed."""
-        return "green" if self.passed_visibility else "red"
-
-    @property
-    def plot_color_constant(self) -> str:
-        """Return one of two colors depending on if ROI passed."""
-        return "green" if self.passed_contrast_constant else "red"
-
-    @property
-    def plot_color_cnr(self) -> str:
-        """Return one of two colors depending on if ROI passed."""
-        return "green" if self.passed_cnr_constant else "red"
-
-    def as_dict(self) -> dict:
-        """Dump important data as a dictionary. Useful when exporting a `results_data` output"""
-        return {
-            "contrast method": self.contrast_method,
-            "visibility": self.visibility,
-            "visibility threshold": self.visibility_threshold,
-            "passed visibility": self.passed_visibility,
-            "contrast": self.contrast,
-            "cnr": self.contrast_to_noise,
-            "signal to noise": self.signal_to_noise,
-        }
-
-    def percentile(self, percentile: float) -> float:
-        """Return the pixel value at the given percentile."""
-        return np.percentile(self.circle_mask(), percentile)
-
-    @cached_property
-    def std(self) -> float:
-        """The std within the ROI."""
-        return float(np.std(self.circle_mask()))
-
-    @cached_property
-    def max(self) -> float:
-        """The max pixel value of the ROI."""
-        masked_img = self.circle_mask()
-        return np.max(masked_img)
-
-    @cached_property
-    def min(self) -> float:
-        """The min pixel value of the ROI."""
-        masked_img = self.circle_mask()
-        return np.min(masked_img)
-
-
-class HighContrastDiskROI(DiskROI):
-    """A class for analyzing the high-contrast disks."""
-
-    contrast_threshold: float | None
-
-    def __init__(
-        self,
-        array: np.ndarray,
-        angle: float,
-        roi_radius: float,
-        dist_from_center: float,
-        phantom_center: tuple | Point,
-        contrast_threshold: float,
-    ):
-        """
-        Parameters
-        ----------
-        contrast_threshold : float, int
-            The threshold for considering a bubble to be "seen".
-        """
-        super().__init__(array, angle, roi_radius, dist_from_center, phantom_center)
-        self.contrast_threshold = contrast_threshold
-
-    def __repr__(self):
-        return f"High-Contrast Disk; max pixel: {self.max}, min pixel: {self.min}"
-
-    @cached_property
-    def max(self) -> np.ndarray:
-        """The max pixel value of the ROI."""
-        masked_img = self.circle_mask()
-        return np.max(masked_img)
-
-    @cached_property
-    def min(self) -> np.ndarray:
-        """The min pixel value of the ROI."""
-        masked_img = self.circle_mask()
-        return np.min(masked_img)
-
-
-class RectangleROI(Rectangle):
-    """Class that represents a rectangular ROI."""
-
-    def __init__(self, array, width, height, angle, dist_from_center, phantom_center):
-        y_shift = np.sin(np.deg2rad(angle)) * dist_from_center
-        x_shift = np.cos(np.deg2rad(angle)) * dist_from_center
-        center = Point(phantom_center.x + x_shift, phantom_center.y + y_shift)
-        # the ROI must be 'real', i.e. >= 2x2 matrix
-        if width < 2:
-            raise ValueError(f"The width must be >= 2. Given {width}")
-        if height < 2:
-            raise ValueError(f"The height must be >= 2. Given {height}")
-        super().__init__(width, height, center, as_int=True)
-        self._array = array
-
-    def __repr__(self):
-        return f"Rectangle ROI @ {self.center}; mean pixel: {self.pixel_value}"
-
-    # TODO: See if I could use this somewhere
-    # @classmethod
-    # def from_regionprop(cls, regionprop: _RegionProperties, phan_center: Point):
-    #     width = regionprop.bbox[3] - regionprop.bbox[1]
-    #     height = regionprop.bbox[2] - regionprop.bbox[0]
-    #     angle = np.rad2deg(np.arctan2((regionprop.centroid[0] - phan_center.y), (regionprop.centroid[1] - phan_center.x)))
-    #     distance = phan_center.distance_to(Point(regionprop.centroid[1], regionprop.centroid[0]))
-    #     return cls(regionprop.intensity_image, width=width, height=height,
-    #                angle=angle, dist_from_center=distance, phantom_center=phan_center)
-
-    @cached_property
-    def pixel_array(self) -> np.ndarray:
-        """The pixel array within the ROI."""
-        return self._array[
-            self.bl_corner.y : self.tr_corner.y, self.bl_corner.x : self.tr_corner.x
-        ]
-
-    @cached_property
-    def pixel_value(self) -> float:
-        """The pixel array within the ROI."""
-        return float(np.mean(self.pixel_array))
-
-    @cached_property
-    def mean(self) -> float:
-        """The mean value within the ROI."""
-        return float(np.mean(self.pixel_array))
-
-    @cached_property
-    def std(self) -> float:
-        """The std within the ROI."""
-        return float(np.std(self.pixel_array))
-
-    @cached_property
-    def min(self) -> float:
-        """The min value within the ROI."""
-        return float(np.min(self.pixel_array))
-
-    @cached_property
-    def max(self) -> float:
-        """The max value within the ROI."""
-        return float(np.max(self.pixel_array))
+from __future__ import annotations
+
+from functools import cached_property
+
+import matplotlib.pyplot as plt
+import numpy as np
+from skimage import draw
+from skimage.measure._regionprops import _RegionProperties
+
+from .contrast import Contrast, contrast, michelson, ratio, rms, visibility, weber
+from .decorators import lru_cache
+from .geometry import Circle, Point, Rectangle
+from .image import ArrayImage
+
+
+def bbox_center(region: _RegionProperties) -> Point:
+    """Return the center of the bounding box of an scikit-image region.
+
+    Parameters
+    ----------
+    region
+        A scikit-image region as calculated by skimage.measure.regionprops().
+
+    Returns
+    -------
+    point : :class:`~pylinac.core.geometry.Point`
+    """
+    bbox = region.bbox
+    y = abs(bbox[0] - bbox[2]) / 2 + min(bbox[0], bbox[2])
+    x = abs(bbox[1] - bbox[3]) / 2 + min(bbox[1], bbox[3])
+    return Point(x, y)
+
+
+class DiskROI(Circle):
+    """An class representing a disk-shaped Region of Interest."""
+
+    def __init__(
+        self,
+        array: np.ndarray,
+        angle: float,
+        roi_radius: float,
+        dist_from_center: float,
+        phantom_center: tuple | Point,
+    ):
+        """
+        Parameters
+        ----------
+        array : ndarray
+            The 2D array representing the image the disk is on.
+        angle : int, float
+            The angle of the ROI in degrees from the phantom center.
+        roi_radius : int, float
+            The radius of the ROI from the center of the phantom.
+        dist_from_center : int, float
+            The distance of the ROI from the phantom center.
+        phantom_center : tuple
+            The location of the phantom center.
+        """
+        center = self._get_shifted_center(angle, dist_from_center, phantom_center)
+        super().__init__(center_point=center, radius=roi_radius)
+        self._array = array
+
+    @staticmethod
+    def _get_shifted_center(
+        angle: float,
+        dist_from_center: float,
+        phantom_center: Point,
+    ) -> Point:
+        """The center of the ROI; corrects for phantom dislocation and roll."""
+        y_shift = np.sin(np.deg2rad(angle)) * dist_from_center
+        x_shift = np.cos(np.deg2rad(angle)) * dist_from_center
+        return Point(phantom_center.x + x_shift, phantom_center.y + y_shift)
+
+    @cached_property
+    def pixel_values(self) -> np.ndarray:
+        return self.circle_mask()
+
+    @cached_property
+    def pixel_value(self) -> float:
+        """The median pixel value of the ROI."""
+        masked_img = self.circle_mask()
+        return float(np.median(masked_img))
+
+    @cached_property
+    def std(self) -> float:
+        """The standard deviation of the pixel values."""
+        masked_img = self.circle_mask()
+        return float(np.std(masked_img))
+
+    @lru_cache()
+    def circle_mask(self) -> np.ndarray:
+        """Return a mask of the image, only showing the circular ROI."""
+        rr, cc = draw.disk(center=(self.center.y, self.center.x), radius=self.radius)
+        return self._array[rr, cc]
+
+    def plot2axes(
+        self,
+        axes: plt.Axes | None = None,
+        edgecolor: str = "black",
+        fill: bool = False,
+        text: str = "",
+        fontsize: str = "medium",
+        **kwargs,
+    ) -> None:
+        """Plot the Circle on the axes.
+
+        Parameters
+        ----------
+        axes : matplotlib.axes.Axes
+            An MPL axes to plot to.
+        edgecolor : str
+            The color of the circle.
+        fill : bool
+            Whether to fill the circle with color or leave hollow.
+        text: str
+            If provided, plots the given text at the center. Useful for differentiating ROIs on a plotted image.
+        fontsize: str
+            The size of the text, if provided. See https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.text.html
+            for options.
+        """
+        if axes is None:
+            fig, axes = plt.subplots()
+            axes.imshow(self._array)
+        super().plot2axes(
+            axes, edgecolor=edgecolor, text=str(text), fontsize=fontsize, **kwargs
+        )
+
+    def as_dict(self) -> dict:
+        """Convert to dict. Useful for dataclasses/Result"""
+        data = super().as_dict()
+        data.update({"median": self.pixel_value, "std": self.std})
+        return data
+
+
+class LowContrastDiskROI(DiskROI):
+    """A class for analyzing the low-contrast disks."""
+
+    contrast_threshold: float | None
+    cnr_threshold: float | None
+    contrast_reference: float | None
+
+    def __init__(
+        self,
+        array: np.ndarray | ArrayImage,
+        angle: float,
+        roi_radius: float,
+        dist_from_center: float,
+        phantom_center: tuple | Point,
+        contrast_threshold: float | None = None,
+        contrast_reference: float | None = None,
+        cnr_threshold: float | None = None,
+        contrast_method: str = Contrast.MICHELSON,
+        visibility_threshold: float | None = 0.1,
+    ):
+        """
+        Parameters
+        ----------
+        contrast_threshold : float, int
+            The threshold for considering a bubble to be "seen".
+        """
+        super().__init__(array, angle, roi_radius, dist_from_center, phantom_center)
+        self.contrast_threshold = contrast_threshold
+        self.cnr_threshold = cnr_threshold
+        self.contrast_reference = contrast_reference
+        self.contrast_method = contrast_method
+        self.visibility_threshold = visibility_threshold
+
+    @property
+    def _contrast_array(self) -> np.ndarray:
+        return np.array((self.pixel_value, self.contrast_reference))
+
+    @property
+    def signal_to_noise(self) -> float:
+        """The signal-to-noise ratio. Cast to numpy first to use numpy overflow handling."""
+        return float(np.array(self.pixel_value) / self.std)
+
+    @property
+    def contrast_to_noise(self) -> float:
+        """The contrast to noise ratio of the ROI. Cast to numpy first to use numpy overflow handling."""
+        return float(np.array(self.contrast) / self.std)
+
+    @property
+    def michelson(self) -> float:
+        """The Michelson contrast"""
+        return michelson(self._contrast_array)
+
+    @property
+    def weber(self) -> float:
+        """The Weber contrast"""
+        return weber(feature=self.pixel_value, background=self.contrast_reference)
+
+    @property
+    def rms(self) -> float:
+        """The root-mean-square contrast"""
+        return rms(self._contrast_array)
+
+    @property
+    def ratio(self) -> float:
+        """The ratio contrast"""
+        return ratio(self._contrast_array)
+
+    @property
+    def contrast(self) -> float:
+        """The contrast of the bubble. Uses the contrast method passed in the constructor. See https://en.wikipedia.org/wiki/Contrast_(vision)."""
+        return contrast(self._contrast_array, self.contrast_method)
+
+    @property
+    def cnr_constant(self) -> float:
+        """The contrast-to-noise value times the bubble diameter."""
+        DeprecationWarning(
+            "The 'cnr_constant' property will be deprecated in a future release. Use .visibility instead."
+        )
+        return self.contrast_to_noise * self.diameter
+
+    @property
+    def visibility(self) -> float:
+        """The visual perception of CNR. Uses the model from A Rose: https://www.osapublishing.org/josa/abstract.cfm?uri=josa-38-2-196.
+        See also here: https://howradiologyworks.com/x-ray-cnr/.
+        Finally, a review paper here: http://xrm.phys.northwestern.edu/research/pdf_papers/1999/burgess_josaa_1999.pdf
+        Importantly, the Rose model is not applicable for high-contrast use cases."""
+        return visibility(
+            array=self._contrast_array,
+            radius=self.radius,
+            std=self.std,
+            algorithm=self.contrast_method,
+        )
+
+    @property
+    def contrast_constant(self) -> float:
+        """The contrast value times the bubble diameter."""
+        DeprecationWarning(
+            "The 'contrast_constant' property will be deprecated in a future release. Use .visibility instead."
+        )
+        return self.contrast * self.diameter
+
+    @property
+    def passed(self) -> bool:
+        """Whether the disk ROI contrast passed."""
+        return self.contrast > self.contrast_threshold
+
+    @property
+    def passed_visibility(self) -> bool:
+        """Whether the disk ROI's visibility passed."""
+        return self.visibility > self.visibility_threshold
+
+    @property
+    def passed_contrast_constant(self) -> bool:
+        """Boolean specifying if ROI pixel value was within tolerance of the nominal value."""
+        return self.contrast_constant > self.contrast_threshold
+
+    @property
+    def passed_cnr_constant(self) -> bool:
+        """Boolean specifying if ROI pixel value was within tolerance of the nominal value."""
+        return self.cnr_constant > self.cnr_threshold
+
+    @property
+    def plot_color(self) -> str:
+        """Return one of two colors depending on if ROI passed."""
+        return "green" if self.passed_visibility else "red"
+
+    @property
+    def plot_color_constant(self) -> str:
+        """Return one of two colors depending on if ROI passed."""
+        return "green" if self.passed_contrast_constant else "red"
+
+    @property
+    def plot_color_cnr(self) -> str:
+        """Return one of two colors depending on if ROI passed."""
+        return "green" if self.passed_cnr_constant else "red"
+
+    def as_dict(self) -> dict:
+        """Dump important data as a dictionary. Useful when exporting a `results_data` output"""
+        return {
+            "contrast method": self.contrast_method,
+            "visibility": self.visibility,
+            "visibility threshold": self.visibility_threshold,
+            "passed visibility": bool(self.passed_visibility),
+            "contrast": self.contrast,
+            "cnr": self.contrast_to_noise,
+            "signal to noise": self.signal_to_noise,
+        }
+
+    def percentile(self, percentile: float) -> float:
+        """Return the pixel value at the given percentile."""
+        return np.percentile(self.circle_mask(), percentile)
+
+    @cached_property
+    def std(self) -> float:
+        """The std within the ROI."""
+        return float(np.std(self.circle_mask()))
+
+    @cached_property
+    def max(self) -> float:
+        """The max pixel value of the ROI."""
+        masked_img = self.circle_mask()
+        return np.max(masked_img)
+
+    @cached_property
+    def min(self) -> float:
+        """The min pixel value of the ROI."""
+        masked_img = self.circle_mask()
+        return np.min(masked_img)
+
+
+class HighContrastDiskROI(DiskROI):
+    """A class for analyzing the high-contrast disks."""
+
+    contrast_threshold: float | None
+
+    def __init__(
+        self,
+        array: np.ndarray,
+        angle: float,
+        roi_radius: float,
+        dist_from_center: float,
+        phantom_center: tuple | Point,
+        contrast_threshold: float,
+    ):
+        """
+        Parameters
+        ----------
+        contrast_threshold : float, int
+            The threshold for considering a bubble to be "seen".
+        """
+        super().__init__(array, angle, roi_radius, dist_from_center, phantom_center)
+        self.contrast_threshold = contrast_threshold
+
+    def __repr__(self):
+        return f"High-Contrast Disk; max pixel: {self.max}, min pixel: {self.min}"
+
+    @cached_property
+    def max(self) -> float:
+        """The max pixel value of the ROI."""
+        masked_img = self.circle_mask()
+        return float(np.max(masked_img))
+
+    @cached_property
+    def min(self) -> float:
+        """The min pixel value of the ROI."""
+        masked_img = self.circle_mask()
+        return float(np.min(masked_img))
+
+    @cached_property
+    def mean(self) -> float:
+        """The mean pixel value of the ROI."""
+        masked_img = self.circle_mask()
+        return float(np.mean(masked_img))
+
+
+class RectangleROI(Rectangle):
+    """Class that represents a rectangular ROI."""
+
+    def __init__(self, array, width, height, angle, dist_from_center, phantom_center):
+        y_shift = np.sin(np.deg2rad(angle)) * dist_from_center
+        x_shift = np.cos(np.deg2rad(angle)) * dist_from_center
+        center = Point(phantom_center.x + x_shift, phantom_center.y + y_shift)
+        # the ROI must be 'real', i.e. >= 2x2 matrix
+        if width < 2:
+            raise ValueError(f"The width must be >= 2. Given {width}")
+        if height < 2:
+            raise ValueError(f"The height must be >= 2. Given {height}")
+        super().__init__(width, height, center, as_int=True)
+        self._array = array
+
+    def __repr__(self):
+        return f"Rectangle ROI @ {self.center}; mean pixel: {self.pixel_value}"
+
+    # TODO: See if I could use this somewhere
+    # @classmethod
+    # def from_regionprop(cls, regionprop: _RegionProperties, phan_center: Point):
+    #     width = regionprop.bbox[3] - regionprop.bbox[1]
+    #     height = regionprop.bbox[2] - regionprop.bbox[0]
+    #     angle = np.rad2deg(np.arctan2((regionprop.centroid[0] - phan_center.y), (regionprop.centroid[1] - phan_center.x)))
+    #     distance = phan_center.distance_to(Point(regionprop.centroid[1], regionprop.centroid[0]))
+    #     return cls(regionprop.intensity_image, width=width, height=height,
+    #                angle=angle, dist_from_center=distance, phantom_center=phan_center)
+
+    @cached_property
+    def pixel_array(self) -> np.ndarray:
+        """The pixel array within the ROI."""
+        return self._array[
+            self.bl_corner.y : self.tr_corner.y, self.bl_corner.x : self.tr_corner.x
+        ]
+
+    @cached_property
+    def pixel_value(self) -> float:
+        """The pixel array within the ROI."""
+        return float(np.mean(self.pixel_array))
+
+    @cached_property
+    def mean(self) -> float:
+        """The mean value within the ROI."""
+        return float(np.mean(self.pixel_array))
+
+    @cached_property
+    def std(self) -> float:
+        """The std within the ROI."""
+        return float(np.std(self.pixel_array))
+
+    @cached_property
+    def min(self) -> float:
+        """The min value within the ROI."""
+        return float(np.min(self.pixel_array))
+
+    @cached_property
+    def max(self) -> float:
+        """The max value within the ROI."""
+        return float(np.max(self.pixel_array))
```

### Comparing `manteia_qa_pylinac-1.0.0/pylinac/core/scale.py` & `manteia_qa_pylinac-1.1.0/pylinac/core/scale.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,102 +1,102 @@
-from __future__ import annotations
-
-from enum import Enum
-
-import argue
-
-
-def noop(value: float) -> float:
-    """Don't do anything."""
-    return value
-
-
-def mirror_360(value: float) -> float:
-    """Mirror about 0"""
-    argue.verify_bounds(value, argue.POSITIVE)
-    return 360 - value
-
-
-def shift_and_mirror_360(value: float) -> float:
-    """Shift by 180 degrees and then mirror about 0"""
-    argue.verify_bounds(value, argue.POSITIVE)
-    v = value - 180
-    if v > 0:
-        return mirror_360(v)
-    else:
-        return abs(v)
-
-
-def inv_shift_and_mirror_360(value: float) -> float:
-    """Inverse shift and mirror"""
-    v = 180 - value
-    if v < 0:
-        return mirror_360(abs(v))
-    else:
-        return v
-
-
-class MachineScale(Enum):
-    """Possible machine scales. Used for specifying input and output scales for conversion.
-    The enum keys are conversion functions for each axis relative to IEC 61217"""
-
-    IEC61217 = {
-        "gantry_to_iec": noop,
-        "collimator_to_iec": noop,
-        "rotation_to_iec": noop,
-        "gantry_from_iec": noop,
-        "collimator_from_iec": noop,
-        "rotation_from_iec": noop,
-    }
-    ELEKTA_IEC = {
-        "gantry_to_iec": noop,
-        "collimator_to_iec": noop,
-        "rotation_to_iec": mirror_360,
-        "gantry_from_iec": noop,
-        "collimator_from_iec": noop,
-        "rotation_from_iec": mirror_360,
-    }
-    VARIAN_IEC = {
-        "gantry_to_iec": noop,
-        "collimator_to_iec": noop,
-        "rotation_to_iec": mirror_360,
-        "gantry_from_iec": noop,
-        "collimator_from_iec": noop,
-        "rotation_from_iec": mirror_360,
-    }
-    VARIAN_STANDARD = {
-        "gantry_to_iec": shift_and_mirror_360,
-        "collimator_to_iec": shift_and_mirror_360,
-        "rotation_to_iec": shift_and_mirror_360,
-        "gantry_from_iec": inv_shift_and_mirror_360,
-        "collimator_from_iec": inv_shift_and_mirror_360,
-        "rotation_from_iec": inv_shift_and_mirror_360,
-    }
-
-
-def convert(
-    input_scale: MachineScale,
-    output_scale: MachineScale,
-    gantry: float,
-    collimator: float,
-    rotation: float,
-) -> (float, float, float):
-    """Convert from one coordinate scale to another. Returns gantry, collimator, rotation."""
-    # convert to IEC61217 since everything is defined relative to it
-    g = input_scale.value["gantry_to_iec"](gantry)
-    c = input_scale.value["collimator_to_iec"](collimator)
-    r = input_scale.value["rotation_to_iec"](rotation)
-    # now apply the inverse to go from 61217 to output scale
-    g_out = output_scale.value["gantry_from_iec"](g)
-    c_out = output_scale.value["collimator_from_iec"](c)
-    r_out = output_scale.value["rotation_from_iec"](r)
-    return g_out, c_out, r_out
-
-
-def abs360(value: float) -> float:
-    """Convert angles to always be positive. E.g. -90 -> 270"""
-    return (360 + value) % 360
-
-
-def wrap360(value: float) -> float:
-    """Wrap the input value around 360. E.g. 361 -> 1"""
-    return value % 360
+from __future__ import annotations
+
+from enum import Enum
+
+import argue
+
+
+def noop(value: float) -> float:
+    """Don't do anything."""
+    return value
+
+
+def mirror_360(value: float) -> float:
+    """Mirror about 0"""
+    argue.verify_bounds(value, argue.POSITIVE)
+    return 360 - value
+
+
+def shift_and_mirror_360(value: float) -> float:
+    """Shift by 180 degrees and then mirror about 0"""
+    value = abs360(value)
+    v = value - 180
+    if v > 0:
+        return mirror_360(v)
+    else:
+        return abs(v)
+
+
+def inv_shift_and_mirror_360(value: float) -> float:
+    """Inverse shift and mirror"""
+    v = 180 - value
+    if v < 0:
+        return mirror_360(abs(v))
+    else:
+        return v
+
+
+class MachineScale(Enum):
+    """Possible machine scales. Used for specifying input and output scales for conversion.
+    The enum keys are conversion functions for each axis relative to IEC 61217"""
+
+    IEC61217 = {
+        "gantry_to_iec": noop,
+        "collimator_to_iec": noop,
+        "rotation_to_iec": noop,
+        "gantry_from_iec": noop,
+        "collimator_from_iec": noop,
+        "rotation_from_iec": noop,
+    }
+    ELEKTA_IEC = {
+        "gantry_to_iec": noop,
+        "collimator_to_iec": noop,
+        "rotation_to_iec": mirror_360,
+        "gantry_from_iec": noop,
+        "collimator_from_iec": noop,
+        "rotation_from_iec": mirror_360,
+    }
+    VARIAN_IEC = {
+        "gantry_to_iec": noop,
+        "collimator_to_iec": noop,
+        "rotation_to_iec": mirror_360,
+        "gantry_from_iec": noop,
+        "collimator_from_iec": noop,
+        "rotation_from_iec": mirror_360,
+    }
+    VARIAN_STANDARD = {
+        "gantry_to_iec": shift_and_mirror_360,
+        "collimator_to_iec": shift_and_mirror_360,
+        "rotation_to_iec": shift_and_mirror_360,
+        "gantry_from_iec": inv_shift_and_mirror_360,
+        "collimator_from_iec": inv_shift_and_mirror_360,
+        "rotation_from_iec": inv_shift_and_mirror_360,
+    }
+
+
+def convert(
+    input_scale: MachineScale,
+    output_scale: MachineScale,
+    gantry: float,
+    collimator: float,
+    rotation: float,
+) -> (float, float, float):
+    """Convert from one coordinate scale to another. Returns gantry, collimator, rotation."""
+    # convert to IEC61217 since everything is defined relative to it
+    g = input_scale.value["gantry_to_iec"](gantry)
+    c = input_scale.value["collimator_to_iec"](collimator)
+    r = input_scale.value["rotation_to_iec"](rotation)
+    # now apply the inverse to go from 61217 to output scale
+    g_out = output_scale.value["gantry_from_iec"](g)
+    c_out = output_scale.value["collimator_from_iec"](c)
+    r_out = output_scale.value["rotation_from_iec"](r)
+    return g_out, c_out, r_out
+
+
+def abs360(value: float) -> float:
+    """Convert angles to always be positive. E.g. -90 -> 270"""
+    return (360 + value) % 360
+
+
+def wrap360(value: float) -> float:
+    """Wrap the input value around 360. E.g. 361 -> 1"""
+    return value % 360
```

### Comparing `manteia_qa_pylinac-1.0.0/pylinac/core/utilities.py` & `manteia_qa_pylinac-1.1.0/pylinac/core/utilities.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,188 +1,221 @@
-"""Utility functions for pylinac."""
-from __future__ import annotations
-
-import os
-import os.path as osp
-import struct
-from collections.abc import Iterable
-from dataclasses import dataclass, field
-from datetime import datetime
-from enum import Enum
-from typing import BinaryIO, Sequence
-
-import numpy as np
-import pydicom
-
-from .. import __version__
-
-
-def convert_to_enum(value: str | Enum | None, enum: type[Enum]) -> Enum:
-    """Convert a value to an enum representation from an enum value if needed"""
-    if isinstance(value, enum):
-        return value
-    else:
-        return enum(value)
-
-
-class OptionListMixin:
-    """A mixin class that will create a list of the class attributes.
-    Used for enum-like classes"""
-
-    @classmethod
-    def options(cls) -> list[str]:
-        return [
-            option
-            for attr, option in cls.__dict__.items()
-            if not callable(option) and not attr.startswith("__")
-        ]
-
-
-@dataclass
-class ResultBase:
-    pylinac_version: str = field(init=False)  #:
-    date_of_analysis: datetime = field(init=False)  #:
-
-    def __post_init__(self):
-        self.pylinac_version = __version__
-        self.date_of_analysis = datetime.today()
-
-
-def clear_data_files():
-    """Delete all demo files, image classifiers, etc from the demo folder"""
-    demo_folder = osp.join(osp.dirname(osp.dirname(__file__)), "demo_files")
-    if osp.isdir(demo_folder):
-        for file in os.listdir(demo_folder):
-            full_file = osp.join(demo_folder, file)
-            if osp.isfile(full_file):
-                os.remove(full_file)
-    print("Pylinac data files cleared.")
-
-
-def assign2machine(source_file: str, machine_file: str):
-    """Assign a DICOM RT Plan file to a specific machine. The source file is overwritten to contain
-    the machine of the machine file.
-
-    Parameters
-    ----------
-    source_file : str
-        Path to the DICOM RTPlan file that contains the fields/plan desired
-        (e.g. a Winston Lutz set of fields or Varian's default PF files).
-    machine_file : str
-        Path to a DICOM RTPlan file that has the desired machine. This is easily obtained from pushing a plan from the TPS
-        for that specific machine. The file must contain at least one valid field.
-    """
-    dcm_source = pydicom.dcmread(source_file)
-    dcm_machine = pydicom.dcmread(machine_file)
-    for beam in dcm_source.BeamSequence:
-        beam.TreatmentMachineName = dcm_machine.BeamSequence[0].TreatmentMachineName
-    dcm_source.save_as(source_file)
-
-
-def is_close(val: float, target: float | Sequence, delta: float = 1):
-    """Return whether the value is near the target value(s).
-
-    Parameters
-    ----------
-    val : number
-        The value being compared against.
-    target : number, iterable
-        If a number, the values are simply evaluated.
-        If a sequence, each target is compared to ``val``.
-        If any values of ``target`` are close, the comparison is considered True.
-
-    Returns
-    -------
-    bool
-    """
-    try:
-        targets = (value for value in target)
-    except (AttributeError, TypeError):
-        targets = [target]
-    for target in targets:
-        if target - delta < val < target + delta:
-            return True
-    return False
-
-
-def simple_round(number: float | int, decimals: int | None = 0) -> float | int:
-    """Round a number to the given number of decimals. Fixes small floating number errors. If decimals is None, no rounding is performed"""
-    if decimals is None:
-        return number
-    num = int(round(number * 10**decimals))
-    if decimals >= 1:
-        num /= 10**decimals
-    return num
-
-
-def is_iterable(object) -> bool:
-    """Determine if an object is iterable."""
-    return isinstance(object, Iterable)
-
-
-class Structure:
-    """A simple structure that assigns the arguments to the object."""
-
-    def __init__(self, **kwargs):
-        self.__dict__.update(**kwargs)
-
-    def update(self, **kwargs):
-        self.__dict__.update(**kwargs)
-
-
-def decode_binary(
-    file: BinaryIO,
-    dtype: type[int] | type[float] | type[str] | str | np.dtype,
-    num_values: int = 1,
-    cursor_shift: int = 0,
-    strip_empty: bool = True,
-) -> int | float | str | np.ndarray | list:
-    """Read in a raw binary file and convert it to given data types.
-
-    Parameters
-    ----------
-    file
-        The open file object.
-    dtype
-        The expected data type to return. If int or float and num_values > 1, will return numpy array.
-    num_values
-        The expected number of dtype to return
-
-        .. note:: This is not the same as the number of bytes.
-
-    cursor_shift : int
-        The number of bytes to move the cursor forward after decoding. This is used if there is a
-        reserved section after the read-in segment.
-    strip_empty : bool
-        Whether to strip trailing empty/null values for strings.
-    """
-    f = file
-
-    if isinstance(dtype, str):
-        s = struct.calcsize(dtype) * num_values
-        output = struct.unpack(dtype * num_values, f.read(s))
-        if len(output) == 1:
-            output = output[0]
-    elif dtype == str:  # if string
-        ssize = struct.calcsize("c") * num_values
-        output = struct.unpack("c" * num_values, f.read(ssize))
-        if strip_empty:
-            output = "".join(o.decode() for o in output if o != b"\x00")
-        else:
-            output = "".join(o.decode() for o in output)
-    elif dtype == int:
-        ssize = struct.calcsize("i") * num_values
-        output = np.asarray(struct.unpack("i" * num_values, f.read(ssize)))
-        if len(output) == 1:
-            output = int(np.squeeze(output))
-    elif dtype == float:
-        ssize = struct.calcsize("f") * num_values
-        output = np.asarray(struct.unpack("f" * num_values, f.read(ssize)))
-        if len(output) == 1:
-            output = float(np.squeeze(output))
-    else:
-        raise TypeError(f"datatype '{dtype}' was not valid")
-
-    # shift cursor if need be (e.g. if a reserved section follows)
-    if cursor_shift:
-        f.seek(cursor_shift, 1)
-    return output
+"""Utility functions for pylinac."""
+from __future__ import annotations
+
+import os
+import os.path as osp
+import struct
+from abc import abstractmethod
+from collections.abc import Iterable
+from datetime import datetime
+from enum import Enum
+from typing import BinaryIO, Generic, Sequence, TypeVar
+
+import numpy as np
+import pydicom
+from pydantic import BaseModel, ConfigDict, Field
+
+from .. import __version__
+
+
+def convert_to_enum(value: str | Enum | None, enum: type[Enum]) -> Enum:
+    """Convert a value to an enum representation from an enum value if needed"""
+    if isinstance(value, enum):
+        return value
+    else:
+        return enum(value)
+
+
+class OptionListMixin:
+    """A mixin class that will create a list of the class attributes.
+    Used for enum-like classes"""
+
+    @classmethod
+    def options(cls) -> list[str]:
+        return [
+            option
+            for attr, option in cls.__dict__.items()
+            if not callable(option) and not attr.startswith("__")
+        ]
+
+
+class ResultBase(BaseModel):
+    model_config = ConfigDict(
+        arbitrary_types_allowed=True
+    )  # https://docs.pydantic.dev/latest/api/config/#pydantic.config.ConfigDict.arbitrary_types_allowed
+    pylinac_version: str = __version__  #:
+    date_of_analysis: datetime = Field(default_factory=datetime.today)  #:
+
+
+T = TypeVar("T")
+
+
+class ResultsDataMixin(Generic[T]):
+    """A mixin for classes that generate results data. This mixin is used to generate the results data and present it in different formats.
+    The generic types allow correct type hinting of the results data."""
+
+    @abstractmethod
+    def _generate_results_data(self) -> T:
+        pass
+
+    def results_data(
+        self, as_dict: bool = False, as_json: bool = False
+    ) -> T | dict | str:
+        """Present the results data and metadata as a dataclass, dict, or tuple.
+        The default return type is a dataclass.
+
+        Parameters
+        ----------
+        as_dict : bool
+            If True, return the results as a dictionary.
+        as_json : bool
+            If True, return the results as a JSON string. Cannot be True if as_dict is True.
+        """
+        if as_dict and as_json:
+            raise ValueError("Cannot return as both dict and JSON. Pick one.")
+        data = self._generate_results_data()
+        if as_dict:
+            return data.model_dump()
+        if as_json:
+            return data.model_dump_json()
+        return data
+
+
+def clear_data_files():
+    """Delete all demo files, image classifiers, etc from the demo folder"""
+    demo_folder = osp.join(osp.dirname(osp.dirname(__file__)), "demo_files")
+    if osp.isdir(demo_folder):
+        for file in os.listdir(demo_folder):
+            full_file = osp.join(demo_folder, file)
+            if osp.isfile(full_file):
+                os.remove(full_file)
+    print("Pylinac data files cleared.")
+
+
+def assign2machine(source_file: str, machine_file: str):
+    """Assign a DICOM RT Plan file to a specific machine. The source file is overwritten to contain
+    the machine of the machine file.
+
+    Parameters
+    ----------
+    source_file : str
+        Path to the DICOM RTPlan file that contains the fields/plan desired
+        (e.g. a Winston Lutz set of fields or Varian's default PF files).
+    machine_file : str
+        Path to a DICOM RTPlan file that has the desired machine. This is easily obtained from pushing a plan from the TPS
+        for that specific machine. The file must contain at least one valid field.
+    """
+    dcm_source = pydicom.dcmread(source_file)
+    dcm_machine = pydicom.dcmread(machine_file)
+    for beam in dcm_source.BeamSequence:
+        beam.TreatmentMachineName = dcm_machine.BeamSequence[0].TreatmentMachineName
+    dcm_source.save_as(source_file)
+
+
+def is_close(val: float, target: float | Sequence, delta: float = 1):
+    """Return whether the value is near the target value(s).
+
+    Parameters
+    ----------
+    val : number
+        The value being compared against.
+    target : number, iterable
+        If a number, the values are simply evaluated.
+        If a sequence, each target is compared to ``val``.
+        If any values of ``target`` are close, the comparison is considered True.
+
+    Returns
+    -------
+    bool
+    """
+    try:
+        targets = (value for value in target)
+    except (AttributeError, TypeError):
+        targets = [target]
+    for target in targets:
+        if target - delta < val < target + delta:
+            return True
+    return False
+
+
+def simple_round(number: float | int, decimals: int | None = 0) -> float | int:
+    """Round a number to the given number of decimals. Fixes small floating number errors. If decimals is None, no rounding is performed"""
+    if decimals is None:
+        return number
+    num = int(round(number * 10**decimals))
+    if decimals >= 1:
+        num /= 10**decimals
+    return num
+
+
+def is_iterable(object) -> bool:
+    """Determine if an object is iterable."""
+    return isinstance(object, Iterable)
+
+
+class Structure:
+    """A simple structure that assigns the arguments to the object."""
+
+    def __init__(self, **kwargs):
+        self.__dict__.update(**kwargs)
+
+    def update(self, **kwargs):
+        self.__dict__.update(**kwargs)
+
+
+def decode_binary(
+    file: BinaryIO,
+    dtype: type[int] | type[float] | type[str] | str | np.dtype,
+    num_values: int = 1,
+    cursor_shift: int = 0,
+    strip_empty: bool = True,
+) -> int | float | str | np.ndarray | list:
+    """Read in a raw binary file and convert it to given data types.
+
+    Parameters
+    ----------
+    file
+        The open file object.
+    dtype
+        The expected data type to return. If int or float and num_values > 1, will return numpy array.
+    num_values
+        The expected number of dtype to return
+
+        .. note:: This is not the same as the number of bytes.
+
+    cursor_shift : int
+        The number of bytes to move the cursor forward after decoding. This is used if there is a
+        reserved section after the read-in segment.
+    strip_empty : bool
+        Whether to strip trailing empty/null values for strings.
+    """
+    f = file
+
+    if isinstance(dtype, str):
+        s = struct.calcsize(dtype) * num_values
+        output = struct.unpack(dtype * num_values, f.read(s))
+        if len(output) == 1:
+            output = output[0]
+    elif dtype == str:  # if string
+        ssize = struct.calcsize("c") * num_values
+        output = struct.unpack("c" * num_values, f.read(ssize))
+        if strip_empty:
+            output = "".join(o.decode() for o in output if o != b"\x00")
+        else:
+            output = "".join(o.decode() for o in output)
+    elif dtype == int:
+        ssize = struct.calcsize("i") * num_values
+        output = np.asarray(struct.unpack("i" * num_values, f.read(ssize)))
+        if len(output) == 1:
+            output = int(np.squeeze(output))
+    elif dtype == float:
+        ssize = struct.calcsize("f") * num_values
+        output = np.asarray(struct.unpack("f" * num_values, f.read(ssize)))
+        if len(output) == 1:
+            output = float(np.squeeze(output))
+    else:
+        raise TypeError(f"datatype '{dtype}' was not valid")
+
+    # shift cursor if need be (e.g. if a reserved section follows)
+    if cursor_shift:
+        f.seek(cursor_shift, 1)
+    return output
```

### Comparing `manteia_qa_pylinac-1.0.0/pylinac/ct.py` & `manteia_qa_pylinac-1.1.0/pylinac/ct.py`

 * *Files 23% similar despite different names*

```diff
@@ -1,2505 +1,2637 @@
-"""The CT module automatically analyzes DICOM images of a CatPhan 504, 503, 600, Quart DVT, or ACR phantoms acquired when doing CBCT or CT quality assurance.
-It can load a folder or zip file that the images are in and automatically correct for translational and rotational errors.
-It can analyze the HU regions and image scaling (CTP404), the high-contrast line pairs (CTP528) to calculate the modulation transfer function (MTF),
-the HU uniformity (CTP486), and Low Contrast (CTP515) on the corresponding slices.
-
-For ACR and Quart phantoms, the equivalent sections are analyzed where applicable even though each module does not have an explicit name.
-Where intuitive similarities between the phantoms exist, the library usage is the same.
-
-Features:
-
-* **Automatic phantom registration** - Your phantom can be tilted, rotated, or translated--pylinac will automatically register the phantom.
-* **Automatic testing of all major modules** - Major modules are automatically registered and analyzed.
-* **Any scan protocol** - Scan your CatPhan with any protocol; even scan it in a regular CT scanner.
-  Any field size or field extent is allowed.
-"""
-from __future__ import annotations
-
-import dataclasses
-import io
-import itertools
-import os
-import webbrowser
-import zipfile
-from dataclasses import dataclass
-from functools import cached_property
-from io import BytesIO
-from os import path as osp
-from pathlib import Path
-from typing import BinaryIO, Callable, Sequence
-
-import matplotlib.pyplot as plt
-import numpy as np
-from matplotlib.axes import Axes
-from py_linq import Enumerable
-from scipy import ndimage
-from skimage import draw, filters, measure, segmentation
-from skimage.measure._regionprops import RegionProperties
-
-from .core import image, pdf
-from .core.contrast import Contrast
-from .core.geometry import Line, Point
-from .core.image import ArrayImage, DicomImageStack, ImageLike, z_position
-from .core.io import TemporaryZipDirectory, get_url, retrieve_demo_file
-from .core.mtf import MTF
-from .core.profile import CollapsedCircleProfile, FWXMProfile
-from .core.roi import DiskROI, LowContrastDiskROI, RectangleROI
-from .core.utilities import ResultBase
-from .settings import get_dicom_cmap
-
-# The ramp angle ratio is from the Catphan manual ("Scan slice geometry" section)
-# and represents the fact that the wire is at an oblique angle (23), making it appear
-# longer than it is if it were normal or perpendicular to the z (imaging) axis. This ratio
-# fixes the length to represent it as if it were perpendicular to the imaging axis.
-RAMP_ANGLE_RATIO = 0.42
-
-AIR = -1000
-PMP = -196
-LDPE = -104
-POLY = -47
-ACRYLIC = 115
-DELRIN = 365
-TEFLON = 1000
-BONE_20 = 237
-BONE_50 = 725
-WATER = 0
-
-
-@dataclass
-class ROIResult:
-    """This class should not be called directly. It is returned by the ``results_data()`` method.
-    It is a dataclass under the hood and thus comes with all the dunder magic.
-
-    Use the following attributes as normal class attributes."""
-
-    name: str  #:
-    value: float  #:
-    stdev: float  #:
-    difference: float | None  #:
-    nominal_value: float | None  #:
-    passed: bool | None  #:
-
-
-@dataclass
-class CTP404Result:
-    """This class should not be called directly. It is returned by the ``results_data()`` method.
-    It is a dataclass under the hood and thus comes with all the dunder magic.
-
-    Use the following attributes as normal class attributes."""
-
-    offset: int  #:
-    low_contrast_visibility: float  #:
-    thickness_passed: bool  #:
-    measured_slice_thickness_mm: float  #:
-    thickness_num_slices_combined: int  #:
-
-    geometry_passed: bool  #:
-    avg_line_distance_mm: float  #:
-    line_distances_mm: list[float]  #:
-
-    hu_linearity_passed: bool  #:
-    hu_tolerance: float  #:
-    hu_rois: dict  #:
-
-
-@dataclass
-class CTP486Result:
-    """This class should not be called directly. It is returned by the ``results_data()`` method.
-    It is a dataclass under the hood and thus comes with all the dunder magic.
-
-    Use the following attributes as normal class attributes."""
-
-    uniformity_index: float  #:
-    integral_non_uniformity: float  #:
-    passed: bool  #:
-    rois: dict  #:
-
-
-@dataclass
-class CTP515Result:
-    """This class should not be called directly. It is returned by the ``results_data()`` method.
-    It is a dataclass under the hood and thus comes with all the dunder magic.
-
-    Use the following attributes as normal class attributes."""
-
-    cnr_threshold: float  #:
-    num_rois_seen: int  #:
-    roi_settings: dict  #:
-    roi_results: dict  #:
-
-
-@dataclass
-class CTP528Result:
-    """This class should not be called directly. It is returned by the ``results_data()`` method.
-    It is a dataclass under the hood and thus comes with all the dunder magic.
-
-    Use the following attributes as normal class attributes."""
-
-    start_angle_radians: float  #:
-    mtf_lp_mm: dict  #:
-    roi_settings: dict  #:
-
-
-@dataclass
-class CatphanResult(ResultBase):
-    """This class should not be called directly. It is returned by the ``results_data()`` method.
-    It is a dataclass under the hood and thus comes with all the dunder magic.
-
-    Use the following attributes as normal class attributes."""
-
-    catphan_model: str  #:
-    catphan_roll_deg: float  #:
-    origin_slice: int  #:
-    num_images: int  #:
-    ctp404: CTP404Result  #:
-    ctp486: CTP486Result | None = None  #:
-    ctp528: CTP528Result | None = None  #:
-    ctp515: CTP515Result | None = None  #:
-
-
-class HUDiskROI(DiskROI):
-    """An HU ROI object. Represents a circular area measuring either HU sample (Air, Poly, ...)
-    or HU uniformity (bottom, left, ...).
-    """
-
-    def __init__(
-        self,
-        array: np.ndarray | ArrayImage,
-        angle: float,
-        roi_radius: float,
-        dist_from_center: float,
-        phantom_center: tuple | Point,
-        nominal_value: float | None = None,
-        tolerance: float | None = None,
-        background_mean: float | None = None,
-        background_std: float | None = None,
-    ):
-        """
-        Parameters
-        ----------
-        nominal_value
-            The nominal pixel value of the HU ROI.
-        tolerance
-            The roi pixel value tolerance.
-        """
-        super().__init__(array, angle, roi_radius, dist_from_center, phantom_center)
-        self.nominal_val = nominal_value
-        self.tolerance = tolerance
-
-    @property
-    def value_diff(self) -> float:
-        """The difference in HU between measured and nominal."""
-        return self.pixel_value - self.nominal_val
-
-    @property
-    def passed(self) -> bool:
-        """Boolean specifying if ROI pixel value was within tolerance of the nominal value."""
-        if self.tolerance:
-            return abs(self.value_diff) <= self.tolerance
-        else:
-            return True
-
-    @property
-    def plot_color(self) -> str:
-        """Return one of two colors depending on if ROI passed."""
-        return "green" if self.passed else "red"
-
-
-class ThicknessROI(RectangleROI):
-    """A rectangular ROI that measures the angled wire rod in the HU linearity slice which determines slice thickness."""
-
-    @cached_property
-    def long_profile(self) -> FWXMProfile:
-        """The profile along the axis perpendicular to ramped wire."""
-        img = image.load(self.pixel_array)
-        img.filter(size=1, kind="gaussian")
-        return FWXMProfile(values=img.array.max(axis=np.argmin(img.shape)))
-
-    @cached_property
-    def wire_fwhm(self) -> float:
-        """The FWHM of the wire in pixels."""
-        return self.long_profile.field_width_px
-
-    @property
-    def plot_color(self) -> str:
-        """The plot color."""
-        return "blue"
-
-
-class Slice:
-    """Base class for analyzing specific slices of a CBCT dicom set."""
-
-    def __init__(
-        self,
-        catphan,
-        slice_num: int | None = None,
-        combine: bool = True,
-        combine_method: str = "mean",
-        num_slices: int = 0,
-        clear_borders: bool = True,
-        original_image: ImageLike | None = None,
-    ):
-        """
-        Parameters
-        ----------
-
-        catphan : :class:`~pylinac.cbct.CatPhanBase` instance.
-            The catphan instance.
-        slice_num : int
-            The slice number of the DICOM array desired. If None, will use the ``slice_num`` property of subclass.
-        combine : bool
-            If True, combines the slices +/- ``num_slices`` around the slice of interest to improve signal/noise.
-        combine_method : {'mean', 'max'}
-            How to combine the slices if ``combine`` is True.
-        num_slices : int
-            The number of slices on either side of the nominal slice to combine to improve signal/noise; only
-            applicable if ``combine`` is True.
-        clear_borders : bool
-            If True, clears the borders of the image to remove any ROIs that may be present.
-        original_image : :class:`~pylinac.core.image.Image` or None
-            The array of the slice. This is a bolt-on parameter for optimization.
-            Leaving as None is fine, but can increase analysis speed if 1) this image is passed and
-            2) there is no combination of slices happening, which is most of the time.
-        """
-        if slice_num is not None:
-            self.slice_num = slice_num
-        if combine and num_slices > 0:
-            array = combine_surrounding_slices(
-                catphan.dicom_stack,
-                self.slice_num,
-                mode=combine_method,
-                slices_plusminus=num_slices,
-            )
-        elif original_image is not None:
-            array = original_image
-        else:
-            array = catphan.dicom_stack[self.slice_num].array
-        self.image = image.load(array)
-        self.catphan_size = catphan.catphan_size
-        self.mm_per_pixel = catphan.mm_per_pixel
-        self.clear_borders = clear_borders
-        if catphan._phantom_center_func:
-            self._phantom_center_func = catphan._phantom_center_func
-
-    @property
-    def __getitem__(self, item):
-        return self.image.array[item]
-
-    @cached_property
-    def phantom_roi(self) -> RegionProperties:
-        """Get the Scikit-Image ROI of the phantom
-
-        The image is analyzed to see if:
-        1) the CatPhan is even in the image (if there were any ROIs detected)
-        2) an ROI is within the size criteria of the catphan
-        3) the ROI area that is filled compared to the bounding box area is close to that of a circle
-        """
-        # convert the slice to binary and label ROIs
-        edges = filters.scharr(self.image.as_type(float))
-        if np.max(edges) < 0.1:
-            raise ValueError(
-                "No edges were found in the image that look like the phantom"
-            )
-        larr, regionprops, num_roi = get_regions(
-            self, fill_holes=True, threshold="mean", clear_borders=self.clear_borders
-        )
-        # check that there is at least 1 ROI
-        if num_roi < 1 or num_roi is None:
-            raise ValueError(
-                f"The number of ROIs detected {num_roi} was not the number expected (1)"
-            )
-        catphan_region = sorted(
-            regionprops, key=lambda x: np.abs(x.filled_area - self.catphan_size)
-        )[0]
-        if (self.catphan_size * 1.3 < catphan_region.filled_area) or (
-            catphan_region.filled_area < self.catphan_size / 1.3
-        ):
-            raise ValueError("Unable to find ROI of expected size of the phantom")
-        return catphan_region
-
-    def is_phantom_in_view(self) -> bool:
-        """Whether the phantom appears to be within the slice."""
-        try:
-            self.phantom_roi
-            return True
-        except ValueError:
-            return False
-
-    @property
-    def phan_center(self) -> Point:
-        """Determine the location of the center of the phantom."""
-        x = self._phantom_center_func[0](self.slice_num)
-        y = self._phantom_center_func[1](self.slice_num)
-        return Point(x=x, y=y)
-
-
-class CatPhanModule(Slice):
-    """Base class for a CTP module."""
-
-    common_name: str = ""
-    combine_method: str = "mean"
-    num_slices: int = 0
-    roi_settings: dict = {}
-    background_roi_settings: dict = {}
-    roi_dist_mm = float
-    roi_radius_mm = float
-    rois: dict = {}  # dicts of HUDiskROIs
-    background_rois: dict = {}  # dict of HUDiskROIs; possibly empty
-    window_min: int | None = None  # plt visualization
-    window_max: int | None = None  # plt visualization
-
-    def __init__(
-        self,
-        catphan,
-        tolerance: float | None = None,
-        offset: int = 0,
-        clear_borders: bool = True,
-    ):
-        self.model = ""
-        self._offset = offset
-        self.origin_slice = catphan.origin_slice
-        self.tolerance = tolerance
-        self.slice_thickness = catphan.dicom_stack.metadata.SliceThickness
-        self.slice_spacing = catphan.dicom_stack[0].slice_spacing
-        self.catphan_roll = catphan.catphan_roll
-        self.mm_per_pixel = catphan.mm_per_pixel
-        self.rois: dict[str, HUDiskROI] = {}
-        self.background_rois: dict[str, HUDiskROI] = {}
-        Slice.__init__(
-            self,
-            catphan,
-            combine_method=self.combine_method,
-            num_slices=self.num_slices,
-            clear_borders=clear_borders,
-        )
-        self._convert_units_in_settings()
-        self.preprocess(catphan)
-        self._setup_rois()
-
-    def _convert_units_in_settings(self) -> None:
-        setting_groups = [
-            getattr(self, attr) for attr in dir(self) if attr.endswith("roi_settings")
-        ]
-        for roi_settings in setting_groups:
-            for roi, settings in roi_settings.items():
-                if isinstance(settings, dict):
-                    if settings.get("distance") is not None:
-                        settings["distance_pixels"] = (
-                            settings["distance"] / self.mm_per_pixel
-                        )
-                    if settings.get("angle") is not None:
-                        settings["angle_corrected"] = (
-                            settings["angle"] + self.catphan_roll
-                        )
-                    if settings.get("radius") is not None:
-                        settings["radius_pixels"] = (
-                            settings["radius"] / self.mm_per_pixel
-                        )
-                    if settings.get("width") is not None:
-                        settings["width_pixels"] = settings["width"] / self.mm_per_pixel
-                    if settings.get("height") is not None:
-                        settings["height_pixels"] = (
-                            settings["height"] / self.mm_per_pixel
-                        )
-
-    def preprocess(self, catphan):
-        """A preprocessing step before analyzing the CTP module.
-
-        Parameters
-        ----------
-        catphan : `~pylinac.cbct.CatPhanBase` instance.
-        """
-        pass
-
-    @property
-    def slice_num(self) -> int:
-        """The slice number of the spatial resolution module.
-
-        Returns
-        -------
-        float
-        """
-        return int(self.origin_slice + round(self._offset / self.slice_spacing))
-
-    def _setup_rois(self) -> None:
-        for name, setting in self.background_roi_settings.items():
-            self.background_rois[name] = HUDiskROI(
-                self.image,
-                setting["angle_corrected"],
-                setting["radius_pixels"],
-                setting["distance_pixels"],
-                self.phan_center,
-            )
-        if self.background_rois:
-            background_mean = np.mean(
-                [roi.pixel_value for roi in self.background_rois.values()]
-            )
-            background_std = np.std(
-                [roi.pixel_value for roi in self.background_rois.values()]
-            )
-        else:
-            background_mean = None
-            background_std = None
-
-        for name, setting in self.roi_settings.items():
-            nominal_value = setting.get("value", 0)
-            self.rois[name] = HUDiskROI(
-                self.image,
-                setting["angle_corrected"],
-                setting["radius_pixels"],
-                setting["distance_pixels"],
-                self.phan_center,
-                nominal_value,
-                self.tolerance,
-                background_mean=background_mean,
-                background_std=background_std,
-            )
-
-    def plot_rois(self, axis: plt.Axes) -> None:
-        """Plot the ROIs to the axis."""
-        for roi in self.rois.values():
-            roi.plot2axes(axis, edgecolor=roi.plot_color)
-        for roi in self.background_rois.values():
-            roi.plot2axes(axis, edgecolor="blue")
-
-    def plot(self, axis: plt.Axes):
-        """Plot the image along with ROIs to an axis"""
-        axis.imshow(
-            self.image.array,
-            cmap=get_dicom_cmap(),
-            vmin=self.window_min,
-            vmax=self.window_max,
-        )
-        self.plot_rois(axis)
-        axis.autoscale(tight=True)
-        axis.set_title(self.common_name)
-        axis.axis("off")
-
-    @property
-    def roi_vals_as_str(self) -> str:
-        return ", ".join(
-            f"{name}: {roi.pixel_value}" for name, roi in self.rois.items()
-        )
-
-
-class CTP404CP504(CatPhanModule):
-    """Class for analysis of the HU linearity, geometry, and slice thickness regions of the CTP404."""
-
-    attr_name = "ctp404"
-    common_name = "HU Linearity"
-    roi_dist_mm = 58.7
-    roi_radius_mm = 5
-    roi_settings = {
-        "Air": {
-            "value": AIR,
-            "angle": -90,
-            "distance": roi_dist_mm,
-            "radius": roi_radius_mm,
-        },
-        "PMP": {
-            "value": PMP,
-            "angle": -120,
-            "distance": roi_dist_mm,
-            "radius": roi_radius_mm,
-        },
-        "LDPE": {
-            "value": LDPE,
-            "angle": 180,
-            "distance": roi_dist_mm,
-            "radius": roi_radius_mm,
-        },
-        "Poly": {
-            "value": POLY,
-            "angle": 120,
-            "distance": roi_dist_mm,
-            "radius": roi_radius_mm,
-        },
-        "Acrylic": {
-            "value": ACRYLIC,
-            "angle": 60,
-            "distance": roi_dist_mm,
-            "radius": roi_radius_mm,
-        },
-        "Delrin": {
-            "value": DELRIN,
-            "angle": 0,
-            "distance": roi_dist_mm,
-            "radius": roi_radius_mm,
-        },
-        "Teflon": {
-            "value": TEFLON,
-            "angle": -60,
-            "distance": roi_dist_mm,
-            "radius": roi_radius_mm,
-        },
-    }
-    background_roi_settings = {
-        "1": {"angle": -30, "distance": roi_dist_mm, "radius": roi_radius_mm},
-        "2": {"angle": -150, "distance": roi_dist_mm, "radius": roi_radius_mm},
-        "3": {"angle": -210, "distance": roi_dist_mm, "radius": roi_radius_mm},
-        "4": {"angle": 30, "distance": roi_dist_mm, "radius": roi_radius_mm},
-    }
-    # thickness
-    thickness_roi_height = 40
-    thickness_roi_width = 10
-    thickness_roi_distance_mm = 38
-    thickness_roi_settings = {
-        "Left": {
-            "angle": 180,
-            "width": thickness_roi_width,
-            "height": thickness_roi_height,
-            "distance": thickness_roi_distance_mm,
-        },
-        "Bottom": {
-            "angle": 90,
-            "width": thickness_roi_height,
-            "height": thickness_roi_width,
-            "distance": thickness_roi_distance_mm,
-        },
-        "Right": {
-            "angle": 0,
-            "width": thickness_roi_width,
-            "height": thickness_roi_height,
-            "distance": thickness_roi_distance_mm,
-        },
-        "Top": {
-            "angle": -90,
-            "width": thickness_roi_height,
-            "height": thickness_roi_width,
-            "distance": thickness_roi_distance_mm,
-        },
-    }
-    # geometry
-    geometry_roi_size_mm = 35
-    geometry_roi_settings = {
-        "Top-Horizontal": (0, 1),
-        "Bottom-Horizontal": (2, 3),
-        "Left-Vertical": (0, 2),
-        "Right-Vertical": (1, 3),
-    }
-    pad: str | int
-    thickness_image: Slice
-
-    def __init__(
-        self,
-        catphan,
-        offset: int,
-        hu_tolerance: float,
-        thickness_tolerance: float,
-        scaling_tolerance: float,
-        clear_borders: bool = True,
-        thickness_slice_straddle: str | int = "auto",
-        expected_hu_values: dict[str, float | int] | None = None,
-    ):
-        """
-        Parameters
-        ----------
-        catphan : `~pylinac.cbct.CatPhanBase` instance.
-        offset : int
-        hu_tolerance : float
-        thickness_tolerance : float
-        scaling_tolerance : float
-        clear_borders : bool
-        """
-        self.mm_per_pixel = catphan.mm_per_pixel
-        self.hu_tolerance = hu_tolerance
-        self.thickness_tolerance = thickness_tolerance
-        self.scaling_tolerance = scaling_tolerance
-        self.thickness_rois = {}
-        self.lines = {}
-        self.thickness_slice_straddle = thickness_slice_straddle
-        self.expected_hu_values = expected_hu_values
-        super().__init__(
-            catphan, tolerance=hu_tolerance, offset=offset, clear_borders=clear_borders
-        )
-
-    def preprocess(self, catphan) -> None:
-        # for the thickness analysis image, combine thin slices or just use one slice if slices are thick
-        if (
-            isinstance(self.thickness_slice_straddle, str)
-            and self.thickness_slice_straddle.lower() == "auto"
-        ):
-            if float(catphan.dicom_stack.metadata.SliceThickness) < 3.5:
-                self.pad = 1
-            else:
-                self.pad = 0
-        else:
-            self.pad = self.thickness_slice_straddle
-        self.thickness_image = Slice(
-            catphan,
-            combine_method="mean",
-            num_slices=self.num_slices + self.pad,
-            slice_num=self.slice_num,
-            clear_borders=self.clear_borders,
-        ).image
-
-    def _replace_hu_values(self):
-        """Possibly replace the HU values in the ROI settings with the expected values if the key is present."""
-        if self.expected_hu_values is not None:
-            for name, value in self.expected_hu_values.items():
-                if name in self.roi_settings:
-                    self.roi_settings[name]["value"] = value
-
-    def _setup_rois(self) -> None:
-        self._replace_hu_values()
-        super()._setup_rois()
-        self._setup_thickness_rois()
-        self._setup_geometry_rois()
-
-    def _setup_thickness_rois(self) -> None:
-        for name, setting in self.thickness_roi_settings.items():
-            self.thickness_rois[name] = ThicknessROI(
-                self.thickness_image,
-                setting["width_pixels"],
-                setting["height_pixels"],
-                setting["angle_corrected"],
-                setting["distance_pixels"],
-                self.phan_center,
-            )
-
-    def _setup_geometry_rois(self) -> None:
-        boxsize = self.geometry_roi_size_mm / self.mm_per_pixel
-        xbounds = (int(self.phan_center.x - boxsize), int(self.phan_center.x + boxsize))
-        ybounds = (int(self.phan_center.y - boxsize), int(self.phan_center.y + boxsize))
-        geo_img = self.image[ybounds[0] : ybounds[1], xbounds[0] : xbounds[1]]
-        larr, regionprops, num_roi = get_regions(
-            geo_img, fill_holes=True, clear_borders=False
-        )
-        # check that there is at least 1 ROI
-        if num_roi < 4:
-            raise ValueError("Unable to locate the Geometric nodes")
-        elif num_roi > 4:
-            regionprops = sorted(
-                regionprops, key=lambda x: x.filled_area, reverse=True
-            )[:4]
-        sorted_regions = sorted(
-            regionprops, key=lambda x: (2 * x.centroid[0] + x.centroid[1])
-        )
-        centers = [
-            Point(
-                r.weighted_centroid[1] + xbounds[0], r.weighted_centroid[0] + ybounds[0]
-            )
-            for r in sorted_regions
-        ]
-        #  setup the geometric lines
-        for name, order in self.geometry_roi_settings.items():
-            self.lines[name] = GeometricLine(
-                centers[order[0]],
-                centers[order[1]],
-                self.mm_per_pixel,
-                self.scaling_tolerance,
-            )
-
-    @property
-    def lcv(self) -> float:
-        """The low-contrast visibility"""
-        return (
-            2
-            * abs(self.rois["LDPE"].pixel_value - self.rois["Poly"].pixel_value)
-            / (self.rois["LDPE"].std + self.rois["Poly"].std)
-        )
-
-    def plot_linearity(
-        self, axis: plt.Axes | None = None, plot_delta: bool = True
-    ) -> tuple:
-        """Plot the HU linearity values to an axis.
-
-        Parameters
-        ----------
-        axis : None, matplotlib.Axes
-            The axis to plot the values on. If None, will create a new figure.
-        plot_delta : bool
-            Whether to plot the actual measured HU values (False), or the difference from nominal (True).
-        """
-        nominal_x_values = [roi.nominal_val for roi in self.rois.values()]
-        if axis is None:
-            fig, axis = plt.subplots()
-        if plot_delta:
-            values = [roi.value_diff for roi in self.rois.values()]
-            nominal_measurements = [0] * len(values)
-            ylabel = "HU Delta"
-        else:
-            values = [roi.pixel_value for roi in self.rois.values()]
-            nominal_measurements = nominal_x_values
-            ylabel = "Measured Values"
-        points = axis.plot(nominal_x_values, values, "g+", markersize=15, mew=2)
-        axis.plot(nominal_x_values, nominal_measurements)
-        axis.plot(
-            nominal_x_values, np.array(nominal_measurements) + self.hu_tolerance, "r--"
-        )
-        axis.plot(
-            nominal_x_values, np.array(nominal_measurements) - self.hu_tolerance, "r--"
-        )
-        axis.margins(0.05)
-        axis.grid(True)
-        axis.set_xlabel("Nominal Values")
-        axis.set_ylabel(ylabel)
-        axis.set_title("HU linearity")
-        return points
-
-    @property
-    def passed_hu(self) -> bool:
-        """Boolean specifying whether all the ROIs passed within tolerance."""
-        return all(roi.passed for roi in self.rois.values())
-
-    def plot_rois(self, axis: plt.Axes) -> None:
-        """Plot the ROIs onto the image, as well as the background ROIs"""
-        # plot HU linearity ROIs
-        super().plot_rois(axis)
-        # plot thickness ROIs
-        for roi in self.thickness_rois.values():
-            roi.plot2axes(axis, edgecolor="blue")
-        # plot geometry lines
-        for line in self.lines.values():
-            line.plot2axes(axis, color=line.pass_fail_color)
-
-    @property
-    def passed_thickness(self) -> bool:
-        """Whether the slice thickness was within tolerance from nominal."""
-        return (
-            self.slice_thickness - self.thickness_tolerance
-            < self.meas_slice_thickness
-            < self.slice_thickness + self.thickness_tolerance
-        )
-
-    @property
-    def meas_slice_thickness(self) -> float:
-        """The average slice thickness for the 4 wire measurements in mm."""
-        return np.mean(
-            sorted(
-                roi.wire_fwhm * self.mm_per_pixel * RAMP_ANGLE_RATIO
-                for roi in self.thickness_rois.values()
-            )
-        ) / (1 + 2 * self.pad)
-
-    @property
-    def avg_line_length(self) -> float:
-        return float(np.mean([line.length_mm for line in self.lines.values()]))
-
-    @property
-    def passed_geometry(self) -> bool:
-        """Returns whether all the line lengths were within tolerance."""
-        return all(line.passed for line in self.lines.values())
-
-
-class CTP404CP503(CTP404CP504):
-    """Alias for namespace consistency"""
-
-    pass
-
-
-class CTP404CP600(CTP404CP504):
-    roi_dist_mm = 58.7
-    roi_radius_mm = 5
-    roi_settings = {
-        "Air": {
-            "value": AIR,
-            "angle": 90,
-            "distance": roi_dist_mm,
-            "radius": roi_radius_mm,
-        },
-        "PMP": {
-            "value": PMP,
-            "angle": 60,
-            "distance": roi_dist_mm,
-            "radius": roi_radius_mm,
-        },
-        "LDPE": {
-            "value": LDPE,
-            "angle": 0,
-            "distance": roi_dist_mm,
-            "radius": roi_radius_mm,
-        },
-        "Poly": {
-            "value": POLY,
-            "angle": -60,
-            "distance": roi_dist_mm,
-            "radius": roi_radius_mm,
-        },
-        "Acrylic": {
-            "value": ACRYLIC,
-            "angle": -120,
-            "distance": roi_dist_mm,
-            "radius": roi_radius_mm,
-        },
-        "Delrin": {
-            "value": DELRIN,
-            "angle": -180,
-            "distance": roi_dist_mm,
-            "radius": roi_radius_mm,
-        },
-        "Teflon": {
-            "value": TEFLON,
-            "angle": 120,
-            "distance": roi_dist_mm,
-            "radius": roi_radius_mm,
-        },
-        "Vial": {
-            "value": WATER,
-            "angle": -90,
-            "distance": roi_dist_mm,
-            "radius": roi_radius_mm
-            - 1,  # the vial sits inside the ROI and needs some clearance
-        },
-    }
-
-    def _setup_rois(self) -> None:
-        """For the 600, the top ROI is an optional water vial slot. If the HU is near water we leave it, otherwise we remove it so as not to flag false failures"""
-        super()._setup_rois()
-        if self.rois["Vial"].pixel_value < -500:  # closer to air than water
-            self.rois.pop("Vial")
-
-
-class CTP404CP604(CTP404CP504):
-    roi_dist_mm = 58.7
-    roi_radius_mm = 5
-    roi_settings = {
-        "Air": {
-            "value": AIR,
-            "angle": -90,
-            "distance": roi_dist_mm,
-            "radius": roi_radius_mm,
-        },
-        "PMP": {
-            "value": PMP,
-            "angle": -120,
-            "distance": roi_dist_mm,
-            "radius": roi_radius_mm,
-        },
-        "50% Bone": {
-            "value": BONE_50,
-            "angle": -150,
-            "distance": roi_dist_mm,
-            "radius": roi_radius_mm,
-        },
-        "LDPE": {
-            "value": LDPE,
-            "angle": 180,
-            "distance": roi_dist_mm,
-            "radius": roi_radius_mm,
-        },
-        "Poly": {
-            "value": POLY,
-            "angle": 120,
-            "distance": roi_dist_mm,
-            "radius": roi_radius_mm,
-        },
-        "Acrylic": {
-            "value": ACRYLIC,
-            "angle": 60,
-            "distance": roi_dist_mm,
-            "radius": roi_radius_mm,
-        },
-        "20% Bone": {
-            "value": BONE_20,
-            "angle": 30,
-            "distance": roi_dist_mm,
-            "radius": roi_radius_mm,
-        },
-        "Delrin": {
-            "value": DELRIN,
-            "angle": 0,
-            "distance": roi_dist_mm,
-            "radius": roi_radius_mm,
-        },
-        "Teflon": {
-            "value": TEFLON,
-            "angle": -60,
-            "distance": roi_dist_mm,
-            "radius": roi_radius_mm,
-        },
-    }
-    background_roi_settings = {
-        "1": {"angle": -30, "distance": roi_dist_mm, "radius": roi_radius_mm},
-        "2": {"angle": -210, "distance": roi_dist_mm, "radius": roi_radius_mm},
-    }
-
-
-class CTP486(CatPhanModule):
-    """Class for analysis of the Uniformity slice of the CTP module. Measures 5 ROIs around the slice that
-    should all be close to the same value.
-    """
-
-    attr_name = "ctp486"
-    common_name = "HU Uniformity"
-    roi_dist_mm = 53
-    roi_radius_mm = 10
-    nominal_value = 0
-    roi_settings = {
-        "Top": {
-            "value": nominal_value,
-            "angle": -90,
-            "distance": roi_dist_mm,
-            "radius": roi_radius_mm,
-        },
-        "Right": {
-            "value": nominal_value,
-            "angle": 0,
-            "distance": roi_dist_mm,
-            "radius": roi_radius_mm,
-        },
-        "Bottom": {
-            "value": nominal_value,
-            "angle": 90,
-            "distance": roi_dist_mm,
-            "radius": roi_radius_mm,
-        },
-        "Left": {
-            "value": nominal_value,
-            "angle": 180,
-            "distance": roi_dist_mm,
-            "radius": roi_radius_mm,
-        },
-        "Center": {
-            "value": nominal_value,
-            "angle": 0,
-            "distance": 0,
-            "radius": roi_radius_mm,
-        },
-    }
-
-    def plot_profiles(self, axis: plt.Axes | None = None) -> None:
-        """Plot the horizontal and vertical profiles of the Uniformity slice.
-
-        Parameters
-        ----------
-        axis : None, matplotlib.Axes
-            The axis to plot on; if None, will create a new figure.
-        """
-        if axis is None:
-            fig, axis = plt.subplots()
-        horiz_data = self.image[int(self.phan_center.y), :]
-        vert_data = self.image[:, int(self.phan_center.x)]
-        axis.plot(horiz_data, "g", label="Horizontal")
-        axis.plot(vert_data, "b", label="Vertical")
-        axis.autoscale(tight=True)
-        axis.axhline(self.nominal_value + self.tolerance, color="r", linewidth=3)
-        axis.axhline(self.nominal_value - self.tolerance, color="r", linewidth=3)
-        axis.grid(True)
-        axis.set_ylabel("HU")
-        axis.legend(loc=8, fontsize="small", title="")
-        axis.set_title("Uniformity Profiles")
-
-    @property
-    def overall_passed(self) -> bool:
-        """Boolean specifying whether all the ROIs passed within tolerance."""
-        return all(roi.passed for roi in self.rois.values())
-
-    @property
-    def uniformity_index(self) -> float:
-        """The Uniformity Index. Elstrom et al equation 2. https://www.tandfonline.com/doi/pdf/10.3109/0284186X.2011.590525"""
-        center = self.rois["Center"]
-        uis = [
-            100 * ((roi.pixel_value - center.pixel_value) / (center.pixel_value + 1000))
-            for roi in self.rois.values()
-        ]
-        abs_uis = np.abs(uis)
-        return uis[np.argmax(abs_uis)]
-
-    @property
-    def integral_non_uniformity(self) -> float:
-        """The Integral Non-Uniformity. Elstrom et al equation 1. https://www.tandfonline.com/doi/pdf/10.3109/0284186X.2011.590525"""
-        maxhu = max(roi.pixel_value for roi in self.rois.values())
-        minhu = min(roi.pixel_value for roi in self.rois.values())
-        return (maxhu - minhu) / (maxhu + minhu + 2000)
-
-
-class CTP528CP504(CatPhanModule):
-    """Class for analysis of the Spatial Resolution slice of the CBCT dicom data set.
-
-    A collapsed circle profile is taken of the line-pair region. This profile is search for
-    peaks and valleys. The MTF is calculated from those peaks & valleys.
-
-    Attributes
-    ----------
-
-    radius2linepairs_mm : float
-        The radius in mm to the line pairs.
-
-    """
-
-    attr_name: str = "ctp528"
-    common_name: str = "Spatial Resolution"
-    radius2linepairs_mm = 47
-    combine_method: str = "max"
-    num_slices: int = 3
-    boundaries: tuple[float, ...] = (
-        0,
-        0.107,
-        0.173,
-        0.236,
-        0.286,
-        0.335,
-        0.387,
-        0.434,
-        0.479,
-    )
-    start_angle: float = np.pi
-    ccw: bool = True
-    roi_settings = {
-        "region 1": {
-            "start": boundaries[0],
-            "end": boundaries[1],
-            "num peaks": 2,
-            "num valleys": 1,
-            "peak spacing": 0.021,
-            "gap size (cm)": 0.5,
-            "lp/mm": 0.1,
-        },
-        "region 2": {
-            "start": boundaries[1],
-            "end": boundaries[2],
-            "num peaks": 3,
-            "num valleys": 2,
-            "peak spacing": 0.01,
-            "gap size (cm)": 0.25,
-            "lp/mm": 0.2,
-        },
-        "region 3": {
-            "start": boundaries[2],
-            "end": boundaries[3],
-            "num peaks": 4,
-            "num valleys": 3,
-            "peak spacing": 0.006,
-            "gap size (cm)": 0.167,
-            "lp/mm": 0.3,
-        },
-        "region 4": {
-            "start": boundaries[3],
-            "end": boundaries[4],
-            "num peaks": 4,
-            "num valleys": 3,
-            "peak spacing": 0.00557,
-            "gap size (cm)": 0.125,
-            "lp/mm": 0.4,
-        },
-        "region 5": {
-            "start": boundaries[4],
-            "end": boundaries[5],
-            "num peaks": 4,
-            "num valleys": 3,
-            "peak spacing": 0.004777,
-            "gap size (cm)": 0.1,
-            "lp/mm": 0.5,
-        },
-        "region 6": {
-            "start": boundaries[5],
-            "end": boundaries[6],
-            "num peaks": 5,
-            "num valleys": 4,
-            "peak spacing": 0.00398,
-            "gap size (cm)": 0.083,
-            "lp/mm": 0.6,
-        },
-        "region 7": {
-            "start": boundaries[6],
-            "end": boundaries[7],
-            "num peaks": 5,
-            "num valleys": 4,
-            "peak spacing": 0.00358,
-            "gap size (cm)": 0.071,
-            "lp/mm": 0.7,
-        },
-        "region 8": {
-            "start": boundaries[7],
-            "end": boundaries[8],
-            "num peaks": 5,
-            "num valleys": 4,
-            "peak spacing": 0.0027866,
-            "gap size (cm)": 0.063,
-            "lp/mm": 0.8,
-        },
-    }
-
-    def _setup_rois(self):
-        pass
-
-    def _convert_units_in_settings(self):
-        pass
-
-    @cached_property
-    def mtf(self) -> MTF:
-        """The Relative MTF of the line pairs, normalized to the first region.
-
-        Returns
-        -------
-        dict
-        """
-        maxs = list()
-        mins = list()
-        for key, value in self.roi_settings.items():
-            max_indices, max_values = self.circle_profile.find_peaks(
-                min_distance=value["peak spacing"],
-                max_number=value["num peaks"],
-                search_region=(value["start"], value["end"]),
-            )
-            # check that the right number of peaks were found before continuing, otherwise stop searching for regions
-            if len(max_values) != value["num peaks"]:
-                break
-            maxs.append(max_values.mean())
-            _, min_values = self.circle_profile.find_valleys(
-                min_distance=value["peak spacing"],
-                max_number=value["num valleys"],
-                search_region=(min(max_indices), max(max_indices)),
-            )
-            mins.append(min_values.mean())
-        if not maxs:
-            raise ValueError(
-                "Did not find any spatial resolution pairs to analyze. File an issue on github (https://github.com/jrkerns/pylinac/issues) if this is a valid dataset."
-            )
-
-        spacings = [roi["lp/mm"] for roi in self.roi_settings.values()]
-        mtf = MTF(lp_spacings=spacings, lp_maximums=maxs, lp_minimums=mins)
-        return mtf
-
-    @property
-    def radius2linepairs(self) -> float:
-        """Radius from the phantom center to the line-pair region, corrected for pixel spacing."""
-        return self.radius2linepairs_mm / self.mm_per_pixel
-
-    def plot_rois(self, axis: plt.Axes) -> None:
-        """Plot the circles where the profile was taken within."""
-        self.circle_profile.plot2axes(axis, edgecolor="blue", plot_peaks=False)
-
-    @cached_property
-    def circle_profile(self) -> CollapsedCircleProfile:
-        """Calculate the median profile of the Line Pair region.
-
-        Returns
-        -------
-        :class:`pylinac.core.profile.CollapsedCircleProfile` : A 1D profile of the Line Pair region.
-        """
-        circle_profile = CollapsedCircleProfile(
-            self.phan_center,
-            self.radius2linepairs,
-            image_array=self.image,
-            start_angle=self.start_angle + np.deg2rad(self.catphan_roll),
-            width_ratio=0.04,
-            sampling_ratio=2,
-            ccw=self.ccw,
-        )
-        circle_profile.filter(0.001, kind="gaussian")
-        circle_profile.ground()
-        return circle_profile
-
-
-class CTP528CP604(CTP528CP504):
-    """Alias for namespace consistency."""
-
-    pass
-
-
-class CTP528CP600(CTP528CP504):
-    start_angle = np.pi - 0.1
-    ccw = False
-    boundaries = (0, 0.127, 0.195, 0.255, 0.304, 0.354, 0.405, 0.453, 0.496)
-    roi_settings = {
-        "region 1": {
-            "start": boundaries[0],
-            "end": boundaries[1],
-            "num peaks": 2,
-            "num valleys": 1,
-            "peak spacing": 0.021,
-            "gap size (cm)": 0.5,
-            "lp/mm": 0.1,
-        },
-        "region 2": {
-            "start": boundaries[1],
-            "end": boundaries[2],
-            "num peaks": 3,
-            "num valleys": 2,
-            "peak spacing": 0.01,
-            "gap size (cm)": 0.25,
-            "lp/mm": 0.2,
-        },
-        "region 3": {
-            "start": boundaries[2],
-            "end": boundaries[3],
-            "num peaks": 4,
-            "num valleys": 3,
-            "peak spacing": 0.006,
-            "gap size (cm)": 0.167,
-            "lp/mm": 0.3,
-        },
-        "region 4": {
-            "start": boundaries[3],
-            "end": boundaries[4],
-            "num peaks": 4,
-            "num valleys": 3,
-            "peak spacing": 0.00557,
-            "gap size (cm)": 0.125,
-            "lp/mm": 0.4,
-        },
-        "region 5": {
-            "start": boundaries[4],
-            "end": boundaries[5],
-            "num peaks": 4,
-            "num valleys": 3,
-            "peak spacing": 0.004777,
-            "gap size (cm)": 0.1,
-            "lp/mm": 0.5,
-        },
-        "region 6": {
-            "start": boundaries[5],
-            "end": boundaries[6],
-            "num peaks": 5,
-            "num valleys": 4,
-            "peak spacing": 0.00398,
-            "gap size (cm)": 0.083,
-            "lp/mm": 0.6,
-        },
-        "region 7": {
-            "start": boundaries[6],
-            "end": boundaries[7],
-            "num peaks": 5,
-            "num valleys": 4,
-            "peak spacing": 0.00358,
-            "gap size (cm)": 0.071,
-            "lp/mm": 0.7,
-        },
-        "region 8": {
-            "start": boundaries[7],
-            "end": boundaries[8],
-            "num peaks": 5,
-            "num valleys": 4,
-            "peak spacing": 0.0027866,
-            "gap size (cm)": 0.063,
-            "lp/mm": 0.8,
-        },
-    }
-
-
-class CTP528CP503(CTP528CP504):
-    start_angle = 0
-    ccw = False
-    boundaries = (0, 0.111, 0.176, 0.240, 0.289, 0.339, 0.390, 0.436, 0.481)
-
-
-class GeometricLine(Line):
-    """Represents a line connecting two nodes/ROIs on the Geometry Slice.
-
-    Attributes
-    ----------
-    nominal_length_mm : int, float
-        The nominal distance between the geometric nodes, in mm.
-    """
-
-    nominal_length_mm: float | int = 50
-
-    def __init__(
-        self,
-        geo_roi1: Point,
-        geo_roi2: Point,
-        mm_per_pixel: float,
-        tolerance: int | float,
-    ):
-        """
-        Parameters
-        ----------
-        geo_roi1 : GEO_ROI
-            One of two ROIs representing one end of the line.
-        geo_roi2 : GEO_ROI
-            The other ROI which is the other end of the line.
-        mm_per_pixel : float
-            The mm/pixel value.
-        tolerance : int, float
-            The tolerance of the geometric line, in mm.
-        """
-        super().__init__(geo_roi1, geo_roi2)
-        self.mm_per_pixel = mm_per_pixel
-        self.tolerance = tolerance
-
-    @property
-    def passed(self) -> bool:
-        """Whether the line passed tolerance."""
-        return (
-            self.nominal_length_mm - self.tolerance
-            < self.length_mm
-            < self.nominal_length_mm + self.tolerance
-        )
-
-    @property
-    def pass_fail_color(self) -> str:
-        """Plot color for the line, based on pass/fail status."""
-        return "blue" if self.passed else "red"
-
-    @property
-    def length_mm(self) -> float:
-        """Return the length of the line in mm."""
-        return self.length * self.mm_per_pixel
-
-
-class CTP515(CatPhanModule):
-    """Class for analysis of the low contrast slice of the CTP module. Low contrast is measured by obtaining
-    the average pixel value of the contrast ROIs and comparing that value to the average background value. To obtain
-    a more "human" detection level, the contrast (which is largely the same across different-sized ROIs) is multiplied
-    by the diameter. This value is compared to the contrast threshold to decide if it can be "seen".
-    """
-
-    attr_name = "ctp515"
-    common_name = "Low Contrast"
-    num_slices = 1
-    roi_dist_mm = 50
-    roi_radius_mm = [6, 3.5, 3, 2.5, 2, 1.5]
-    roi_angles = [-87.4, -69.1, -52.7, -38.5, -25.1, -12.9]
-    roi_settings = {
-        "15": {
-            "angle": roi_angles[0],
-            "distance": roi_dist_mm,
-            "radius": roi_radius_mm[0],
-        },
-        "9": {
-            "angle": roi_angles[1],
-            "distance": roi_dist_mm,
-            "radius": roi_radius_mm[1],
-        },
-        "8": {
-            "angle": roi_angles[2],
-            "distance": roi_dist_mm,
-            "radius": roi_radius_mm[2],
-        },
-        "7": {
-            "angle": roi_angles[3],
-            "distance": roi_dist_mm,
-            "radius": roi_radius_mm[3],
-        },
-        "6": {
-            "angle": roi_angles[4],
-            "distance": roi_dist_mm,
-            "radius": roi_radius_mm[4],
-        },
-        "5": {
-            "angle": roi_angles[5],
-            "distance": roi_dist_mm,
-            "radius": roi_radius_mm[5],
-        },
-    }
-    background_roi_dist_ratio = 0.75
-    background_roi_radius_mm = 4
-    WINDOW_SIZE = 50
-
-    def __init__(
-        self,
-        catphan,
-        tolerance: float,
-        cnr_threshold: float,
-        offset: int,
-        contrast_method: str,
-        visibility_threshold: float,
-        clear_borders: bool = True,
-    ):
-        self.cnr_threshold = cnr_threshold
-        self.contrast_method = contrast_method
-        self.visibility_threshold = visibility_threshold
-        super().__init__(
-            catphan, tolerance=tolerance, offset=offset, clear_borders=clear_borders
-        )
-
-    def _setup_rois(self):
-        # create both background rois dynamically, then create the actual sample ROI as normal
-        for name, setting in self.roi_settings.items():
-            self.background_rois[name + "-outer"] = LowContrastDiskROI(
-                self.image,
-                setting["angle_corrected"],
-                self.background_roi_radius_mm / self.mm_per_pixel,
-                setting["distance_pixels"] * (2 - self.background_roi_dist_ratio),
-                self.phan_center,
-            )
-            self.background_rois[name + "-inner"] = LowContrastDiskROI(
-                self.image,
-                setting["angle_corrected"],
-                self.background_roi_radius_mm / self.mm_per_pixel,
-                setting["distance_pixels"] * self.background_roi_dist_ratio,
-                self.phan_center,
-            )
-            background_val = float(
-                np.mean(
-                    [
-                        self.background_rois[name + "-outer"].pixel_value,
-                        self.background_rois[name + "-inner"].pixel_value,
-                    ]
-                )
-            )
-
-            self.rois[name] = LowContrastDiskROI(
-                self.image,
-                setting["angle_corrected"],
-                setting["radius_pixels"],
-                setting["distance_pixels"],
-                self.phan_center,
-                contrast_reference=background_val,
-                cnr_threshold=self.cnr_threshold,
-                contrast_method=self.contrast_method,
-                visibility_threshold=self.visibility_threshold,
-            )
-
-    @property
-    def rois_visible(self) -> int:
-        """The number of ROIs "visible"."""
-        return sum(roi.passed_visibility for roi in self.rois.values())
-
-    @property
-    def window_min(self) -> float:
-        """Lower bound of CT window/leveling to show on the plotted image. Improves apparent contrast."""
-        return (
-            Enumerable(self.background_rois.values()).min(lambda r: r.pixel_value)
-            - self.WINDOW_SIZE
-        )
-
-    @property
-    def window_max(self) -> float:
-        """Upper bound of CT window/leveling to show on the plotted image. Improves apparent contrast"""
-        return (
-            Enumerable(self.rois.values()).max(lambda r: r.pixel_value)
-            + self.WINDOW_SIZE
-        )
-
-
-class CTP515CP600(CTP515):
-    roi_angles = [
-        -87.4 + 180,
-        -69.1 + 180,
-        -52.7 + 180,
-        -38.5 + 180,
-        -25.1 + 180,
-        -12.9 + 180,
-    ]
-    roi_dist_mm = 50
-    roi_radius_mm = [6, 3.5, 3, 2.5, 2, 1.5]
-    roi_settings = {
-        "15": {
-            "angle": roi_angles[0],
-            "distance": roi_dist_mm,
-            "radius": roi_radius_mm[0],
-        },
-        "9": {
-            "angle": roi_angles[1],
-            "distance": roi_dist_mm,
-            "radius": roi_radius_mm[1],
-        },
-        "8": {
-            "angle": roi_angles[2],
-            "distance": roi_dist_mm,
-            "radius": roi_radius_mm[2],
-        },
-        "7": {
-            "angle": roi_angles[3],
-            "distance": roi_dist_mm,
-            "radius": roi_radius_mm[3],
-        },
-        "6": {
-            "angle": roi_angles[4],
-            "distance": roi_dist_mm,
-            "radius": roi_radius_mm[4],
-        },
-        "5": {
-            "angle": roi_angles[5],
-            "distance": roi_dist_mm,
-            "radius": roi_radius_mm[5],
-        },
-    }
-
-
-class CatPhanBase:
-    """A class for loading and analyzing CT DICOM files of a CatPhan 504 & CatPhan 503. Can be from a CBCT or CT scanner
-    Analyzes: Uniformity (CTP486), High-Contrast Spatial Resolution (CTP528), Image Scaling & HU Linearity (CTP404).
-    """
-
-    _demo_url: str = ""
-    _model: str = ""
-    air_bubble_radius_mm: int | float = 7
-    localization_radius: int | float = 59
-    was_from_zip: bool = False
-    min_num_images = 39
-    clear_borders: bool = True
-    hu_origin_slice_variance = 400  # the HU variance required on the origin slice
-    _phantom_center_func: tuple[Callable, Callable] | None = None
-    modules: dict[CatPhanModule, dict[str, int]]
-    dicom_stack: image.DicomImageStack | image.LazyDicomImageStack
-
-    def __init__(
-        self,
-        folderpath: str | Sequence[str] | Path | Sequence[Path] | Sequence[BytesIO],
-        check_uid: bool = True,
-        memory_efficient_mode: bool = False,
-    ):
-        """
-        Parameters
-        ----------
-        folderpath : str, list of strings, or Path to folder
-            String that points to the CBCT image folder location.
-        check_uid : bool
-            Whether to enforce raising an error if more than one UID is found in the dataset.
-        memory_efficient_mode : bool
-            Whether to use a memory efficient mode. If True, the DICOM stack will be loaded on demand rather than all at once.
-            This will reduce the memory footprint but will be slower by ~25%. Default is False.
-
-        Raises
-        ------
-        NotADirectoryError
-            If folder str passed is not a valid directory.
-        FileNotFoundError
-            If no CT images are found in the folder
-        """
-        self.origin_slice = 0
-        self.catphan_roll = 0
-        if isinstance(folderpath, (str, Path)):
-            if not osp.isdir(folderpath):
-                raise NotADirectoryError("Path given was not a Directory/Folder")
-        stack = (
-            image.DicomImageStack
-            if not memory_efficient_mode
-            else image.LazyDicomImageStack
-        )
-        self.dicom_stack = stack(
-            folderpath, check_uid=check_uid, min_number=self.min_num_images
-        )
-
-    @classmethod
-    def from_demo_images(cls):
-        """Construct a CBCT object from the demo images."""
-        demo_file = retrieve_demo_file(name=cls._demo_url)
-        return cls.from_zip(demo_file)
-
-    @classmethod
-    def from_url(cls, url: str, check_uid: bool = True):
-        """Instantiate a CBCT object from a URL pointing to a .zip object.
-
-        Parameters
-        ----------
-        url : str
-            URL pointing to a zip archive of CBCT images.
-        check_uid : bool
-            Whether to enforce raising an error if more than one UID is found in the dataset.
-        """
-        filename = get_url(url)
-        return cls.from_zip(filename, check_uid=check_uid)
-
-    @classmethod
-    def from_zip(
-        cls,
-        zip_file: str | zipfile.ZipFile | BinaryIO,
-        check_uid: bool = True,
-        memory_efficient_mode: bool = False,
-    ):
-        """Construct a CBCT object and pass the zip file.
-
-        Parameters
-        ----------
-        zip_file : str, ZipFile
-            Path to the zip file or a ZipFile object.
-        check_uid : bool
-            Whether to enforce raising an error if more than one UID is found in the dataset.
-        memory_efficient_mode : bool
-            Whether to use a memory efficient mode. If True, the DICOM stack will be loaded on demand rather than all at once.
-            This will reduce the memory footprint but will be slower by ~25%. Default is False.
-
-        Raises
-        ------
-        FileExistsError : If zip_file passed was not a legitimate zip file.
-        FileNotFoundError : If no CT images are found in the folder
-        """
-        delete = not memory_efficient_mode
-        with TemporaryZipDirectory(zip_file, delete=delete) as temp_zip:
-            obj = cls(
-                temp_zip,
-                check_uid=check_uid,
-                memory_efficient_mode=memory_efficient_mode,
-            )
-        obj.was_from_zip = True
-        return obj
-
-    def plot_analyzed_image(self, show: bool = True, **plt_kwargs) -> None:
-        """Plot the images used in the calculation and summary data.
-
-        Parameters
-        ----------
-        show : bool
-            Whether to plot the image or not.
-        plt_kwargs : dict
-            Keyword args passed to the plt.figure() method. Allows one to set things like figure size.
-        """
-
-        # set up grid and axes
-        plt.figure(**plt_kwargs)
-        grid_size = (2, 4)
-        hu_ax = plt.subplot2grid(grid_size, (0, 1))
-        self.ctp404.plot(hu_ax)
-        hu_lin_ax = plt.subplot2grid(grid_size, (0, 2))
-        self.ctp404.plot_linearity(hu_lin_ax)
-        # plot side view w/ module locations
-        side_ax = plt.subplot2grid(grid_size, (1, 2))
-        self.plot_side_view(side_ax)
-        # plot individual modules
-        if self._has_module(CTP486):
-            unif_ax = plt.subplot2grid(grid_size, (0, 0))
-            self.ctp486.plot(unif_ax)
-            unif_prof_ax = plt.subplot2grid(grid_size, (1, 3))
-            self.ctp486.plot_profiles(unif_prof_ax)
-        if self._has_module(CTP528CP504):
-            sr_ax = plt.subplot2grid(grid_size, (1, 0))
-            self.ctp528.plot(sr_ax)
-            mtf_ax = plt.subplot2grid(grid_size, (0, 3))
-            self.ctp528.mtf.plot(mtf_ax)
-        if self._has_module(CTP515):
-            locon_ax = plt.subplot2grid(grid_size, (1, 1))
-            self.ctp515.plot(locon_ax)
-
-        # finish up
-        plt.tight_layout()
-        if show:
-            plt.show()
-
-    def save_analyzed_image(self, filename: str | Path | BinaryIO, **kwargs) -> None:
-        """Save the analyzed summary plot.
-
-        Parameters
-        ----------
-        filename : str, file object
-            The name of the file to save the image to.
-        kwargs :
-            Any valid matplotlib kwargs.
-        """
-        self.plot_analyzed_image(show=False)
-        plt.savefig(filename, **kwargs)
-
-    def plot_analyzed_subimage(
-        self,
-        subimage: str = "hu",
-        delta: bool = True,
-        show: bool = True,
-    ) -> plt.Figure | None:
-        """Plot a specific component of the CBCT analysis.
-
-        Parameters
-        ----------
-        subimage : {'hu', 'un', 'sp', 'lc', 'mtf', 'lin', 'prof', 'side'}
-            The subcomponent to plot. Values must contain one of the following letter combinations.
-            E.g. ``linearity``, ``linear``, and ``lin`` will all draw the HU linearity values.
-
-            * ``hu`` draws the HU linearity image.
-            * ``un`` draws the HU uniformity image.
-            * ``sp`` draws the Spatial Resolution image.
-            * ``lc`` draws the Low Contrast image (if applicable).
-            * ``mtf`` draws the RMTF plot.
-            * ``lin`` draws the HU linearity values. Used with ``delta``.
-            * ``prof`` draws the HU uniformity profiles.
-            * ``side`` draws the side view of the phantom with lines of the module locations.
-        delta : bool
-            Only for use with ``lin``. Whether to plot the HU delta or actual values.
-        show : bool
-            Whether to actually show the plot.
-        """
-        subimage = subimage.lower()
-        fig, ax = plt.subplots()
-        plt.axis("off")
-
-        if "hu" in subimage:  # HU, GEO & thickness objects
-            self.ctp404.plot(ax)
-            plt.autoscale(tight=True)
-        elif "un" in subimage:  # uniformity
-            self.ctp486.plot(ax)
-            plt.autoscale(tight=True)
-        elif "sp" in subimage:  # SR objects
-            self.ctp528.plot(ax)
-            plt.autoscale(tight=True)
-        elif "mtf" in subimage:
-            plt.axis("on")
-            self.ctp528.mtf.plot(ax)
-        elif "lc" in subimage:
-            if self._has_module(CTP515):
-                self.ctp515.plot(ax)
-                plt.autoscale(tight=True)
-            else:
-                return
-        elif "lin" in subimage:
-            plt.axis("on")
-            self.ctp404.plot_linearity(ax, delta)
-        elif "prof" in subimage:
-            plt.axis("on")
-            self.ctp486.plot_profiles(ax)
-        elif "side" in subimage:
-            ax = plt.gca()
-            self.plot_side_view(ax)
-        else:
-            raise ValueError(f"Subimage parameter {subimage} not understood")
-
-        if show:
-            plt.show()
-        return fig
-
-    def save_analyzed_subimage(
-        self,
-        filename: str | BinaryIO,
-        subimage: str = "hu",
-        delta: bool = True,
-        **kwargs,
-    ) -> plt.Figure | None:
-        """Save a component image to file.
-
-        Parameters
-        ----------
-        filename : str, file object
-            The file to write the image to.
-        subimage : str
-            See :meth:`~pylinac.ct.CatPhanBase.plot_analyzed_subimage` for parameter info.
-        delta : bool
-            Only for use with ``lin``. Whether to plot the HU delta or actual values.
-        """
-        fig = self.plot_analyzed_subimage(subimage, delta=delta, show=False)
-        if fig:  # no fig if we plot low contrast
-            plt.savefig(filename, **kwargs)
-            if isinstance(filename, str):
-                print(f"CatPhan subimage figure saved to {osp.abspath(filename)}")
-            return fig
-
-    def _results(self) -> None:
-        """Helper function to spit out values that will be tested."""
-        print(self.results())
-        print(f"Phantom roll: {self.catphan_roll}")
-        print(f"Origin slice: {self.origin_slice}")
-        mtfs = {}
-        for mtf in (95, 90, 80, 50, 30):
-            mtfval = self.ctp528.mtf.relative_resolution(mtf)
-            mtfs[mtf] = mtfval
-        print(f"MTFs: {mtfs}")
-
-    def localize(self) -> None:
-        """Find the slice number of the catphan's HU linearity module and roll angle"""
-        self._phantom_center_func = self.find_phantom_axis()
-        self.origin_slice = self.find_origin_slice()
-        self.catphan_roll = self.find_phantom_roll()
-        # now that we have the origin slice, ensure we have scanned all linked modules
-        if not self._ensure_physical_scan_extent():
-            raise ValueError(
-                "The physical scan extent does not match the module configuration. "
-                "This means not all modules were included in the scan. Rescan the phantom to include all"
-                "relevant modules, or remove modules from the analysis."
-            )
-
-    def _module_offsets(self) -> list[float]:
-        """A list of the module offsets. Used to confirm scan extent"""
-        absolute_origin_position = self.dicom_stack[self.origin_slice].z_position
-        return [
-            absolute_origin_position + config["offset"]
-            for config in self.modules.values()
-        ]
-
-    def _ensure_physical_scan_extent(self) -> bool:
-        """Ensure that all the modules of the phantom have been scanned. If a CBCT isn't
-        positioned correctly, some modules might not be included.
-
-        It appears there can be rounding errors between the DICOM tag and the actual slice position. See RAM-2897.
-        """
-        z_positions = [z_position(m) for m in self.dicom_stack.metadatas]
-        min_scan_extent_slice = round(min(z_positions), 1)
-        max_scan_extent_slice = round(max(z_positions), 1)
-        min_config_extent_slice = round(min(self._module_offsets()), 1)
-        max_config_extent_slice = round(max(self._module_offsets()), 1)
-        return (min_config_extent_slice >= min_scan_extent_slice) and (
-            max_config_extent_slice <= max_scan_extent_slice
-        )
-
-    def find_phantom_axis(self) -> (Callable, Callable):
-        """We fit all the center locations of the phantom across all slices to a 1D poly function instead of finding them individually for robustness.
-
-        Normally, each slice would be evaluated individually, but the RadMachine jig gets in the way of
-        detecting the HU module (). To work around that in a backwards-compatible way we instead
-        look at all the slices and if the phantom was detected, capture the phantom center.
-        ALL the centers are then fitted to a 1D poly function and passed to the individual slices.
-        This way, even if one slice is messed up (such as because of the phantom jig), the poly function
-        is robust to give the real center based on all the other properly-located positions on the other slices.
-        """
-        z = []
-        center_x = []
-        center_y = []
-        for idx, img in enumerate(self.dicom_stack):
-            slice = Slice(
-                self,
-                slice_num=idx,
-                clear_borders=self.clear_borders,
-                original_image=img,
-            )
-            if slice.is_phantom_in_view():
-                roi = slice.phantom_roi
-                z.append(idx)
-                center_y.append(roi.centroid[0])
-                center_x.append(roi.centroid[1])
-        # clip to exclude any crazy values
-        zs = np.array(z)
-        center_xs = np.array(center_x)
-        center_ys = np.array(center_y)
-        # gives an absolute and relative range so tight ranges are all included
-        # but extreme values are excluded. Sometimes the range is very tight
-        # and thus percentiles are not a sure thing
-        x_idxs = np.argwhere(
-            np.isclose(np.median(center_xs), center_xs, atol=3, rtol=0.01)
-        )
-        y_idxs = np.argwhere(
-            np.isclose(np.median(center_ys), center_ys, atol=3, rtol=0.01)
-        )
-        common_idxs = np.intersect1d(x_idxs, y_idxs)
-        # fit to 1D polynomials; inspiration: https://stackoverflow.com/a/45351484
-        fit_zx = np.poly1d(np.polyfit(zs[common_idxs], center_xs[common_idxs], deg=1))
-        fit_zy = np.poly1d(np.polyfit(zs[common_idxs], center_ys[common_idxs], deg=1))
-        return fit_zx, fit_zy
-
-    @property
-    def mm_per_pixel(self) -> float:
-        """The millimeters per pixel of the DICOM images."""
-        return self.dicom_stack.metadata.PixelSpacing[0]
-
-    def find_origin_slice(self) -> int:
-        """Using a brute force search of the images, find the median HU linearity slice.
-
-        This method walks through all the images and takes a collapsed circle profile where the HU
-        linearity ROIs are. If the profile contains both low (<800) and high (>800) HU values and most values are the same
-        (i.e. it's not an artifact), then
-        it can be assumed it is an HU linearity slice. The median of all applicable slices is the
-        center of the HU slice.
-
-        Returns
-        -------
-        int
-            The middle slice of the HU linearity module.
-        """
-        hu_slices = []
-        for image_number in range(0, self.num_images, 2):
-            slice = Slice(
-                self, image_number, combine=False, clear_borders=self.clear_borders
-            )
-            # print(image_number)
-            # slice.image.plot()
-            if slice.is_phantom_in_view():
-                circle_prof = CollapsedCircleProfile(
-                    slice.phan_center,
-                    radius=self.localization_radius / self.mm_per_pixel,
-                    image_array=slice.image,
-                    width_ratio=0.05,
-                    num_profiles=5,
-                )
-                prof = circle_prof.values
-                # determine if the profile contains both low and high values and that most values are the same
-                low_end, high_end = np.percentile(prof, [2, 98])
-                median = np.median(prof)
-                middle_variation = np.percentile(prof, 80) - np.percentile(prof, 20)
-                variation_limit = max(
-                    100, self.dicom_stack.metadata.SliceThickness * -100 + 300
-                )
-                if (
-                    (low_end < median - self.hu_origin_slice_variance)
-                    and (high_end > median + self.hu_origin_slice_variance)
-                    and (middle_variation < variation_limit)
-                ):
-                    hu_slices.append(image_number)
-
-        if not hu_slices:
-            raise ValueError(
-                "No slices were found that resembled the HU linearity module"
-            )
-        hu_slices = np.array(hu_slices)
-        c = int(round(float(np.median(hu_slices))))
-        ln = len(hu_slices)
-        # drop slices that are way far from median
-        hu_slices = hu_slices[((c + ln / 2) >= hu_slices) & (hu_slices >= (c - ln / 2))]
-        center_hu_slice = int(round(float(np.median(hu_slices))))
-        if self._is_within_image_extent(center_hu_slice):
-            # print(center_hu_slice)
-            return center_hu_slice
-
-    def _is_right_area(self, region: RegionProperties):
-        thresh = np.pi * ((self.air_bubble_radius_mm / self.mm_per_pixel) ** 2)
-        return thresh * 2 > region.filled_area > thresh / 2
-
-    def _is_right_eccentricity(self, region: RegionProperties):
-        return region.eccentricity < 0.5
-
-    def find_phantom_roll(self, func: Callable | None = None) -> float:
-        """Determine the "roll" of the phantom.
-
-        This algorithm uses the two air bubbles in the HU slice and the resulting angle between them.
-
-        Parameters
-        ----------
-        func
-            A callable to sort the air ROIs.
-
-        Returns
-        -------
-        float : the angle of the phantom in **degrees**.
-        """
-        # get edges and make ROIs from it
-        slice = Slice(self, self.origin_slice, clear_borders=self.clear_borders)
-        larr, regions, _ = get_regions(slice)
-        # find appropriate ROIs and grab the two most centrally positioned ones
-        hu_bubbles = [
-            r
-            for r in regions
-            if (self._is_right_area(r) and self._is_right_eccentricity(r))
-        ]
-        func = func or (lambda x: abs(x.centroid[1] - slice.phan_center.x))
-        central_bubbles = sorted(hu_bubbles, key=func)[:2]
-        sorted_bubbles = sorted(
-            central_bubbles, key=lambda x: x.centroid[0]
-        )  # top, bottom
-        y_dist = sorted_bubbles[1].centroid[0] - sorted_bubbles[0].centroid[0]
-        x_dist = sorted_bubbles[1].centroid[1] - sorted_bubbles[0].centroid[1]
-        phan_roll = np.arctan2(y_dist, x_dist)
-        anglroll = np.rad2deg(phan_roll) - 90
-        return anglroll
-
-    @property
-    def num_images(self) -> int:
-        """The number of images loaded."""
-        return len(self.dicom_stack)
-
-    def _is_within_image_extent(self, image_num: int) -> bool:
-        """Determine if the image number is beyond the edges of the images (negative or past last image)."""
-        if self.num_images - 1 > image_num > 1:
-            return True
-        else:
-            raise ValueError(
-                "The determined image number is beyond the image extent. Either the entire dataset "
-                "wasn't loaded or the entire phantom wasn't scanned."
-            )
-
-    @property
-    def catphan_size(self) -> float:
-        """The expected size of the phantom in pixels, based on a 20cm wide phantom."""
-        phan_area = np.pi * (self.catphan_radius_mm**2)
-        return phan_area / (self.mm_per_pixel**2)
-
-    def publish_pdf(
-        self,
-        filename: str | Path,
-        notes: str | None = None,
-        open_file: bool = False,
-        metadata: dict | None = None,
-        logo: Path | str | None = None,
-    ) -> None:
-        """Publish (print) a PDF containing the analysis and quantitative results.
-
-        Parameters
-        ----------
-        filename : (str, file-like object}
-            The file to write the results to.
-        notes : str, list of strings
-            Text; if str, prints single line.
-            If list of strings, each list item is printed on its own line.
-        open_file : bool
-            Whether to open the file using the default program after creation.
-        metadata : dict
-            Extra data to be passed and shown in the PDF. The key and value will be shown with a colon.
-            E.g. passing {'Author': 'James', 'Unit': 'TrueBeam'} would result in text in the PDF like:
-            --------------
-            Author: James
-            Unit: TrueBeam
-            --------------
-        logo: Path, str
-            A custom logo to use in the PDF report. If nothing is passed, the default pylinac logo is used.
-        """
-        analysis_title = f"CatPhan {self._model} Analysis"
-        module_images = [("hu", "lin")]
-        if self._has_module(CTP528CP504):
-            module_images.append(("sp", "mtf"))
-        if self._has_module(CTP486):
-            module_images.append(("un", "prof"))
-        if self._has_module(CTP515):
-            module_images.append(("lc", None))
-        module_images.append(("side", None))
-
-        self._publish_pdf(
-            filename,
-            metadata,
-            notes,
-            analysis_title,
-            [*self.results(as_list=True), ""],
-            module_images,
-            logo,
-        )
-        if open_file:
-            webbrowser.open(filename)
-
-    def _publish_pdf(
-        self,
-        filename: str,
-        metadata: dict | None,
-        notes: str,
-        analysis_title: str,
-        texts: Sequence[str],
-        imgs: Sequence[tuple[str, str]],
-        logo: Path | str | None = None,
-    ):
-        canvas = pdf.PylinacCanvas(
-            filename, page_title=analysis_title, metadata=metadata, logo=logo
-        )
-        if notes is not None:
-            canvas.add_text(text="Notes:", location=(1, 4.5), font_size=14)
-            canvas.add_text(text=notes, location=(1, 4))
-
-        for page, ((img1, img2), text) in enumerate(zip(imgs, texts)):
-            for img, offset in zip((img1, img2), (12, 2)):
-                if img is not None:
-                    data = io.BytesIO()
-                    self.save_analyzed_subimage(data, img)
-                    canvas.add_image(data, location=(4, offset), dimensions=(15, 10))
-            canvas.add_text(text=text, location=(1.5, 23))
-            canvas.add_new_page()
-        canvas.finish()
-
-    def _zip_images(self) -> None:
-        """Compress the raw images into a ZIP archive and remove the uncompressed images."""
-        zip_name = rf'{osp.dirname(self.dicom_stack[0].path)}\CBCT - {self.dicom_stack[0].date_created(format="%A, %I-%M-%S, %B %d, %Y")}.zip'
-        with zipfile.ZipFile(zip_name, "w", compression=zipfile.ZIP_DEFLATED) as zfile:
-            for img in self.dicom_stack:
-                zfile.write(img.path, arcname=osp.basename(img.path))
-        for img in self.dicom_stack:
-            try:
-                os.remove(img.path)
-            except:
-                pass
-
-    def plot_side_view(self, axis: Axes) -> None:
-        """Plot a view of the scan from the side with lines showing detected module positions"""
-        side_array = self.dicom_stack.side_view(axis=1)
-        axis.set_yticks([])
-        axis.set_title("Side View")
-        axis.imshow(side_array, aspect="auto", cmap="gray", interpolation="none")
-        for module in self._detected_modules():
-            axis.axvline(module.slice_num)
-
-    def _detected_modules(self) -> list[CatPhanModule]:
-        """A list of the modules detected. Unlike _get_module, this returns the instances"""
-        modules = [self.ctp404]
-        if self._has_module(CTP515):
-            modules.append(self.ctp515)
-        if self._has_module(CTP486):
-            modules.append(self.ctp486)
-        if self._has_module(CTP528CP504):
-            modules.append(self.ctp528)
-        return modules
-
-    def analyze(
-        self,
-        hu_tolerance: int | float = 40,
-        scaling_tolerance: int | float = 1,
-        thickness_tolerance: int | float = 0.2,
-        low_contrast_tolerance: int | float = 1,
-        cnr_threshold: int | float = 15,
-        zip_after: bool = False,
-        contrast_method: str = Contrast.MICHELSON,
-        visibility_threshold: float = 0.15,
-        thickness_slice_straddle: str | int = "auto",
-        expected_hu_values: dict[str, int | float] | None = None,
-    ):
-        """Single-method full analysis of CBCT DICOM files.
-
-        Parameters
-        ----------
-        hu_tolerance : int
-            The HU tolerance value for both HU uniformity and linearity.
-        scaling_tolerance : float, int
-            The scaling tolerance in mm of the geometric nodes on the HU linearity slice (CTP404 module).
-        thickness_tolerance : float, int
-            The tolerance of the thickness calculation in mm, based on the wire ramps in the CTP404 module.
-
-            .. warning:: Thickness accuracy degrades with image noise; i.e. low mAs images are less accurate.
-
-        low_contrast_tolerance : int
-            The number of low-contrast bubbles needed to be "seen" to pass.
-        cnr_threshold : float, int
-            The threshold for "detecting" low-contrast image. See RTD for calculation info.
-
-            .. deprecated:: 3.0
-
-                Use visibility parameter instead.
-
-        zip_after : bool
-            If the CT images were not compressed before analysis and this is set to true, pylinac will compress
-            the analyzed images into a ZIP archive.
-        contrast_method
-            The contrast equation to use. See :ref:`low_contrast_topic`.
-        visibility_threshold
-            The threshold for detecting low-contrast ROIs. Use instead of ``cnr_threshold``. Follows the Rose equation.
-            See :ref:`visibility`.
-        thickness_slice_straddle
-            The number of extra slices **on each side** of the HU module slice to use for slice thickness determination.
-            The rationale is that for thin slices the ramp FWHM can be very noisy. I.e. a 1mm slice might have a 100%
-            variation with a low-mAs protocol. To account for this, slice thicknesses < 3.5mm have 1 slice added
-            on either side of the HU module (so 3 total slices) and then averaged. The default is 'auto',
-            which follows the above logic. Set to an integer to explicitly use a certain amount of padding. Typical
-            values are 0, 1, and 2.
-
-            .. warning:: This is the padding **on either side**. So a value of 1 => 3 slices, 2 => 5 slices, 3 => 7 slices, etc.
-
-        expected_hu_values
-            An optional dictionary of the expected HU values for the HU linearity module. The keys are the ROI names and the values
-            are the expected HU values. If a key is not present or the parameter is None, the default values will be used.
-
-        """
-        self.localize()
-        ctp404, offset = self._get_module(CTP404CP504, raise_empty=True)
-        self.ctp404 = ctp404(
-            self,
-            offset=offset,
-            hu_tolerance=hu_tolerance,
-            thickness_tolerance=thickness_tolerance,
-            scaling_tolerance=scaling_tolerance,
-            clear_borders=self.clear_borders,
-            thickness_slice_straddle=thickness_slice_straddle,
-            expected_hu_values=expected_hu_values,
-        )
-        if self._has_module(CTP486):
-            ctp486, offset = self._get_module(CTP486)
-            self.ctp486 = ctp486(
-                self,
-                offset=offset,
-                tolerance=hu_tolerance,
-                clear_borders=self.clear_borders,
-            )
-        if self._has_module(CTP528CP504):
-            ctp528, offset = self._get_module(CTP528CP504)
-            self.ctp528 = ctp528(
-                self, offset=offset, tolerance=None, clear_borders=self.clear_borders
-            )
-        if self._has_module(CTP515):
-            ctp515, offset = self._get_module(CTP515)
-            self.ctp515 = ctp515(
-                self,
-                tolerance=low_contrast_tolerance,
-                cnr_threshold=cnr_threshold,
-                offset=offset,
-                contrast_method=contrast_method,
-                visibility_threshold=visibility_threshold,
-                clear_borders=self.clear_borders,
-            )
-        if zip_after and not self.was_from_zip:
-            self._zip_images()
-
-    def _has_module(self, module_of_interest: type[CatPhanModule]) -> bool:
-        return any(
-            issubclass(module, module_of_interest) for module in self.modules.keys()
-        )
-
-    def _get_module(
-        self, module_of_interest: type[CatPhanModule], raise_empty: bool = False
-    ) -> tuple[type[CatPhanModule], int]:
-        """Grab the module that is, or is a subclass of, the module of interest. This allows users to subclass a CTP module and pass that in."""
-        for module, values in self.modules.items():
-            if issubclass(module, module_of_interest):
-                return module, values.get("offset")
-        if raise_empty:
-            raise ValueError(
-                f"Tried to find the {module_of_interest} or a subclass of it. Did you override `modules` and not pass this module in?"
-            )
-
-    def results(self, as_list: bool = False) -> str | list[list[str]]:
-        """Return the results of the analysis as a string. Use with print().
-
-        Parameters
-        ----------
-        as_list : bool
-            Whether to return as a list of list of strings vs single string. Pretty much for internal usage.
-        """
-        results = []
-        result = [
-            f" - CBCT/CT {self._model} QA Test - ",
-            " - CTP 404 Results - ",
-            f"HU Linearity tolerance: {self.ctp404.hu_tolerance}",
-            f"HU Linearity ROIs: {self.ctp404.roi_vals_as_str}",
-            f"HU Passed?: {self.ctp404.passed_hu}",
-            f"Low contrast visibility: {self.ctp404.lcv:2.2f}",
-            f"Geometric Line Average (mm): {self.ctp404.avg_line_length:2.2f}",
-            f"Geometry Passed?: {self.ctp404.passed_geometry}",
-            f"Measured Slice Thickness (mm): {self.ctp404.meas_slice_thickness:2.3f}",
-            f"Slice Thickness Passed? {self.ctp404.passed_thickness}",
-        ]
-        results.append(result)
-        if self._has_module(CTP528CP504):
-            ctp528_result = [
-                " - CTP528 Results - ",
-                f"MTF 80% (lp/mm): {self.ctp528.mtf.relative_resolution(80):2.2f}",
-                f"MTF 50% (lp/mm): {self.ctp528.mtf.relative_resolution(50):2.2f}",
-                f"MTF 30% (lp/mm): {self.ctp528.mtf.relative_resolution(30):2.2f}",
-            ]
-            results.append(ctp528_result)
-        if self._has_module(CTP486):
-            ctp486_result = [
-                " - CTP486 Results - ",
-                f"Uniformity tolerance: {self.ctp486.tolerance}",
-                f"Uniformity ROIs: {self.ctp486.roi_vals_as_str}",
-                f"Uniformity index: {self.ctp486.uniformity_index:2.3f}",
-                f"Integral non-uniformity: {self.ctp486.integral_non_uniformity:2.4f}",
-                f"Uniformity Passed?: {self.ctp486.overall_passed}",
-            ]
-            results.append(ctp486_result)
-        if self._has_module(CTP515):
-            ctp515_result = [
-                " - CTP515 Results - ",
-                f"CNR threshold: {self.ctp515.cnr_threshold}",
-                f'Low contrast ROIs "seen": {self.ctp515.rois_visible}',
-            ]
-            results.append(ctp515_result)
-        if not as_list:
-            result = "\n".join(itertools.chain(*results))
-        else:
-            result = results
-        return result
-
-    def results_data(self, as_dict: bool = False) -> CatphanResult | dict:
-        """Present the results data and metadata as a dataclass or dict.
-        The default return type is a dataclass."""
-        ctp404_result = CTP404Result(
-            offset=self.ctp404._offset,
-            low_contrast_visibility=self.ctp404.lcv,
-            thickness_passed=self.ctp404.passed_thickness,
-            measured_slice_thickness_mm=self.ctp404.meas_slice_thickness,
-            thickness_num_slices_combined=self.ctp404.num_slices + self.ctp404.pad,
-            geometry_passed=self.ctp404.passed_geometry,
-            avg_line_distance_mm=self.ctp404.avg_line_length,
-            line_distances_mm=[
-                line.length_mm for name, line in self.ctp404.lines.items()
-            ],
-            hu_linearity_passed=self.ctp404.passed_hu,
-            hu_tolerance=self.ctp404.hu_tolerance,
-            hu_rois=rois_to_results(self.ctp404.rois),
-        )
-        data = CatphanResult(
-            catphan_model=self._model,
-            catphan_roll_deg=self.catphan_roll,
-            origin_slice=self.origin_slice,
-            num_images=self.num_images,
-            ctp404=ctp404_result,
-        )
-
-        # CTP 486 Uniformity stuff
-        if self._has_module(CTP486):
-            data.ctp486 = CTP486Result(
-                passed=self.ctp486.overall_passed,
-                uniformity_index=self.ctp486.uniformity_index,
-                integral_non_uniformity=self.ctp486.integral_non_uniformity,
-                rois=rois_to_results(self.ctp486.rois),
-            )
-
-        # CTP 528 stuff
-        if self._has_module(CTP528CP504):
-            data.ctp528 = CTP528Result(
-                roi_settings=self.ctp528.roi_settings,
-                start_angle_radians=self.ctp528.start_angle,
-                mtf_lp_mm={
-                    p: self.ctp528.mtf.relative_resolution(p) for p in range(10, 91, 10)
-                },
-            )
-
-        # CTP 515 stuff
-        if self._has_module(CTP515):
-            data.ctp515 = CTP515Result(
-                cnr_threshold=self.ctp515.cnr_threshold,
-                num_rois_seen=self.ctp515.rois_visible,
-                roi_settings=self.ctp515.roi_settings,
-                roi_results={
-                    key: roi.as_dict() for key, roi in self.ctp515.rois.items()
-                },
-            )
-
-        if as_dict:
-            return dataclasses.asdict(data)
-        return data
-
-
-class CatPhan503(CatPhanBase):
-    """A class for loading and analyzing CT DICOM files of a CatPhan 503.
-    Analyzes: Uniformity (CTP486), High-Contrast Spatial Resolution (CTP528), Image Scaling & HU Linearity (CTP404).
-    """
-
-    _demo_url = "CatPhan503.zip"
-    _model = "503"
-    catphan_radius_mm = 97
-    modules = {
-        CTP404CP503: {"offset": 0},
-        CTP486: {"offset": -110},
-        CTP528CP503: {"offset": -30},
-    }
-
-    @staticmethod
-    def run_demo(show: bool = True):
-        """Run the CBCT demo using high-quality head protocol images."""
-        cbct = CatPhan503.from_demo_images()
-        cbct.analyze()
-        print(cbct.results())
-        cbct.plot_analyzed_image(show)
-
-
-class CatPhan504(CatPhanBase):
-    """A class for loading and analyzing CT DICOM files of a CatPhan 504. Can be from a CBCT or CT scanner
-    Analyzes: Uniformity (CTP486), High-Contrast Spatial Resolution (CTP528),
-    Image Scaling & HU Linearity (CTP404), and Low contrast (CTP515).
-    """
-
-    _demo_url = "CatPhan504.zip"
-    _model = "504"
-    catphan_radius_mm = 101
-    modules = {
-        CTP404CP504: {"offset": 0},
-        CTP486: {"offset": -65},
-        CTP528CP504: {"offset": 30},
-        CTP515: {"offset": -30},
-    }
-
-    @staticmethod
-    def run_demo(show: bool = True):
-        """Run the CBCT demo using high-quality head protocol images."""
-        cbct = CatPhan504.from_demo_images()
-        cbct.analyze()
-        print(cbct.results())
-        cbct.plot_analyzed_image(show)
-
-
-class CatPhan604(CatPhanBase):
-    """A class for loading and analyzing CT DICOM files of a CatPhan 604. Can be from a CBCT or CT scanner
-    Analyzes: Uniformity (CTP486), High-Contrast Spatial Resolution (CTP528),
-    Image Scaling & HU Linearity (CTP404), and Low contrast (CTP515).
-    """
-
-    _demo_url = "CatPhan604.zip"
-    _model = "604"
-    catphan_radius_mm = 101
-    modules = {
-        CTP404CP604: {"offset": 0},
-        CTP486: {"offset": -80},
-        CTP528CP604: {"offset": 42},
-        CTP515: {"offset": -40},
-    }
-
-    @staticmethod
-    def run_demo(show: bool = True):
-        """Run the CBCT demo using high-quality head protocol images."""
-        cbct = CatPhan604.from_demo_images()
-        cbct.analyze()
-        print(cbct.results())
-        cbct.plot_analyzed_image(show)
-
-
-class CatPhan600(CatPhanBase):
-    """A class for loading and analyzing CT DICOM files of a CatPhan 600.
-    Analyzes: Uniformity (CTP486), High-Contrast Spatial Resolution (CTP528),
-    Image Scaling & HU Linearity (CTP404), and Low contrast (CTP515).
-    """
-
-    _demo_url = "CatPhan600.zip"
-    _model = "600"
-    catphan_radius_mm = 101
-    modules = {
-        CTP404CP600: {"offset": 0},
-        CTP486: {"offset": -160},
-        CTP515CP600: {"offset": -110},
-        CTP528CP600: {"offset": -70},
-    }
-
-    @staticmethod
-    def run_demo(show: bool = True):
-        """Run the CatPhan 600 demo."""
-        cbct = CatPhan600.from_demo_images()
-        cbct.analyze()
-        print(cbct.results())
-        cbct.plot_analyzed_image(show)
-
-    def find_phantom_roll(self, func: Callable | None = None) -> float:
-        """With the CatPhan 600, we have to consider that the top air ROI
-        has a water vial in it (see pg 12 of the manual). If so, the top air ROI won't be detected.
-        Rather, the default algorithm will find the bottom air ROI and teflon to the left.
-        It may also find the top air ROI if the water vial isn't there.
-        We use the below lambda to select the bottom air and teflon ROIs consistently.
-        These two ROIs are at 75 degrees from cardinal. We thus offset the default outcome by 75.
-        """
-        angle = super().find_phantom_roll(lambda x: -x.centroid[0])
-        return angle + 75
-
-
-def get_regions(
-    slice_or_arr: Slice | np.array,
-    fill_holes: bool = False,
-    clear_borders: bool = True,
-    threshold: str = "otsu",
-) -> tuple[np.array, list, int]:
-    """Get the skimage regions of a black & white image."""
-    if threshold == "otsu":
-        thresmeth = filters.threshold_otsu
-    elif threshold == "mean":
-        thresmeth = np.mean
-    if isinstance(slice_or_arr, Slice):
-        edges = filters.scharr(slice_or_arr.image.array.astype(float))
-        center = slice_or_arr.image.center
-    elif isinstance(slice_or_arr, np.ndarray):
-        edges = filters.scharr(slice_or_arr.astype(float))
-        center = (int(edges.shape[1] / 2), int(edges.shape[0] / 2))
-    edges = filters.gaussian(edges, sigma=1)
-    if isinstance(slice_or_arr, Slice):
-        radius = 110 / slice_or_arr.mm_per_pixel
-        rr, cc = draw.disk(
-            center=(center.y, center.x), radius=radius, shape=edges.shape
-        )
-        thres = thresmeth(edges[rr, cc])
-    else:
-        thres = thresmeth(edges)
-    bw = edges > thres
-    if clear_borders:
-        bw = segmentation.clear_border(bw, buffer_size=int(max(bw.shape) / 50))
-    if fill_holes:
-        bw = ndimage.binary_fill_holes(bw)
-    labeled_arr, num_roi = measure.label(bw, return_num=True)
-    regionprops = measure.regionprops(labeled_arr, edges)
-    return labeled_arr, regionprops, num_roi
-
-
-def combine_surrounding_slices(
-    dicomstack: DicomImageStack,
-    nominal_slice_num: int,
-    slices_plusminus: int = 1,
-    mode: str = "mean",
-) -> np.array:
-    """Return an array that is the combination of a given slice and a number of slices surrounding it.
-
-    Parameters
-    ----------
-    dicomstack : `~pylinac.core.image.DicomImageStack`
-        The CBCT DICOM stack.
-    nominal_slice_num : int
-        The slice of interest (along 3rd dim).
-    slices_plusminus: int
-        How many slices plus and minus to combine (also along 3rd dim).
-    mode : {'mean', 'median', 'max}
-        Specifies the method of combination.
-
-    Returns
-    -------
-    combined_array : numpy.array
-        The combined array of the DICOM stack slices.
-    """
-    slices = range(
-        nominal_slice_num - slices_plusminus, nominal_slice_num + slices_plusminus + 1
-    )
-    arrays = tuple(dicomstack[s].array for s in slices)
-    array_stack = np.dstack(arrays)
-    if mode == "mean":
-        combined_array = np.mean(array_stack, 2)
-    elif mode == "median":
-        combined_array = np.median(array_stack, 2)
-    else:
-        combined_array = np.max(array_stack, 2)
-    return combined_array
-
-
-def rois_to_results(dict_mapping: dict[str, DiskROI]) -> dict[str, ROIResult]:
-    """Converts a dict of HUDiskROIs to a dict of ROIResults. This is for dumping to simple data formats for results_data and RadMachine"""
-    flat_dict = {}
-    for name, roi in dict_mapping.items():
-        flat_dict[name] = ROIResult(
-            name=name,
-            value=roi.pixel_value,
-            stdev=roi.std,
-            difference=getattr(roi, "value_diff", None),
-            nominal_value=getattr(roi, "nominal_val", None),
-            passed=getattr(roi, "passed", None),
-        )
-    return flat_dict
+"""The CT module automatically analyzes DICOM images of a CatPhan 504, 503, 600, Quart DVT, or ACR phantoms acquired when doing CBCT or CT quality assurance.
+It can load a folder or zip file that the images are in and automatically correct for translational and rotational errors.
+It can analyze the HU regions and image scaling (CTP404), the high-contrast line pairs (CTP528) to calculate the modulation transfer function (MTF),
+the HU uniformity (CTP486), and Low Contrast (CTP515) on the corresponding slices.
+
+For ACR and Quart phantoms, the equivalent sections are analyzed where applicable even though each module does not have an explicit name.
+Where intuitive similarities between the phantoms exist, the library usage is the same.
+
+Features:
+
+* **Automatic phantom registration** - Your phantom can be tilted, rotated, or translated--pylinac will automatically register the phantom.
+* **Automatic testing of all major modules** - Major modules are automatically registered and analyzed.
+* **Any scan protocol** - Scan your CatPhan with any protocol; even scan it in a regular CT scanner.
+  Any field size or field extent is allowed.
+"""
+from __future__ import annotations
+
+import io
+import itertools
+import os
+import textwrap
+import webbrowser
+import zipfile
+from functools import cached_property
+from io import BytesIO
+from os import path as osp
+from pathlib import Path
+from typing import BinaryIO, Callable, Sequence
+
+import matplotlib.pyplot as plt
+import numpy as np
+from matplotlib.axes import Axes
+from py_linq import Enumerable
+from pydantic import BaseModel
+from scipy import ndimage
+from skimage import draw, filters, measure, segmentation
+from skimage.measure._regionprops import RegionProperties
+
+from .core import image, pdf
+from .core.contrast import Contrast
+from .core.geometry import Line, Point
+from .core.image import ArrayImage, DicomImageStack, ImageLike, z_position
+from .core.io import TemporaryZipDirectory, get_url, retrieve_demo_file
+from .core.mtf import MTF
+from .core.nps import (
+    average_power,
+    max_frequency,
+    noise_power_spectrum_1d,
+    noise_power_spectrum_2d,
+)
+from .core.profile import CollapsedCircleProfile, FWXMProfile
+from .core.roi import DiskROI, LowContrastDiskROI, RectangleROI
+from .core.utilities import ResultBase, ResultsDataMixin
+from .settings import get_dicom_cmap
+
+# The ramp angle ratio is from the Catphan manual ("Scan slice geometry" section)
+# and represents the fact that the wire is at an oblique angle (23), making it appear
+# longer than it is if it were normal or perpendicular to the z (imaging) axis. This ratio
+# fixes the length to represent it as if it were perpendicular to the imaging axis.
+RAMP_ANGLE_RATIO = 0.42
+
+AIR = -1000
+PMP = -196
+LDPE = -104
+POLY = -47
+ACRYLIC = 115
+DELRIN = 365
+TEFLON = 1000
+BONE_20 = 237
+BONE_50 = 725
+WATER = 0
+
+
+class ROIResult(BaseModel):
+    """This class should not be called directly. It is returned by the ``results_data()`` method.
+    It is a dataclass under the hood and thus comes with all the dunder magic.
+
+    Use the following attributes as normal class attributes."""
+
+    name: str  #:
+    value: float  #:
+    stdev: float  #:
+    difference: float | None  #:
+    nominal_value: float | None  #:
+    passed: bool | None  #:
+
+
+class CTP404Result(BaseModel):
+    """This class should not be called directly. It is returned by the ``results_data()`` method.
+    It is a dataclass under the hood and thus comes with all the dunder magic.
+
+    Use the following attributes as normal class attributes."""
+
+    offset: int  #:
+    low_contrast_visibility: float  #:
+    thickness_passed: bool  #:
+    measured_slice_thickness_mm: float  #:
+    thickness_num_slices_combined: int  #:
+
+    geometry_passed: bool  #:
+    avg_line_distance_mm: float  #:
+    line_distances_mm: list[float]  #:
+
+    hu_linearity_passed: bool  #:
+    hu_tolerance: float  #:
+    hu_rois: dict  #:
+
+
+class CTP486Result(BaseModel):
+    """This class should not be called directly. It is returned by the ``results_data()`` method.
+    It is a dataclass under the hood and thus comes with all the dunder magic.
+
+    Use the following attributes as normal class attributes."""
+
+    uniformity_index: float  #:
+    integral_non_uniformity: float  #:
+    nps_avg_power: float
+    nps_max_freq: float
+    passed: bool  #:
+    rois: dict  #:
+
+
+class CTP515Result(BaseModel):
+    """This class should not be called directly. It is returned by the ``results_data()`` method.
+    It is a dataclass under the hood and thus comes with all the dunder magic.
+
+    Use the following attributes as normal class attributes."""
+
+    cnr_threshold: float  #:
+    num_rois_seen: int  #:
+    roi_settings: dict  #:
+    roi_results: dict  #:
+
+
+class CTP528Result(BaseModel):
+    """This class should not be called directly. It is returned by the ``results_data()`` method.
+    It is a dataclass under the hood and thus comes with all the dunder magic.
+
+    Use the following attributes as normal class attributes."""
+
+    start_angle_radians: float  #:
+    mtf_lp_mm: dict  #:
+    roi_settings: dict  #:
+
+
+class CatphanResult(ResultBase):
+    """This class should not be called directly. It is returned by the ``results_data()`` method.
+    It is a dataclass under the hood and thus comes with all the dunder magic.
+
+    Use the following attributes as normal class attributes."""
+
+    catphan_model: str  #:
+    catphan_roll_deg: float  #:
+    origin_slice: int  #:
+    num_images: int  #:
+    ctp404: CTP404Result  #:
+    ctp486: CTP486Result | None = None  #:
+    ctp528: CTP528Result | None = None  #:
+    ctp515: CTP515Result | None = None  #:
+
+
+class HUDiskROI(DiskROI):
+    """An HU ROI object. Represents a circular area measuring either HU sample (Air, Poly, ...)
+    or HU uniformity (bottom, left, ...).
+    """
+
+    def __init__(
+        self,
+        array: np.ndarray | ArrayImage,
+        angle: float,
+        roi_radius: float,
+        dist_from_center: float,
+        phantom_center: tuple | Point,
+        nominal_value: float | None = None,
+        tolerance: float | None = None,
+        background_mean: float | None = None,
+        background_std: float | None = None,
+    ):
+        """
+        Parameters
+        ----------
+        nominal_value
+            The nominal pixel value of the HU ROI.
+        tolerance
+            The roi pixel value tolerance.
+        """
+        super().__init__(array, angle, roi_radius, dist_from_center, phantom_center)
+        self.nominal_val = nominal_value
+        self.tolerance = tolerance
+
+    @property
+    def value_diff(self) -> float:
+        """The difference in HU between measured and nominal."""
+        return self.pixel_value - self.nominal_val
+
+    @property
+    def passed(self) -> bool:
+        """Boolean specifying if ROI pixel value was within tolerance of the nominal value."""
+        if self.tolerance:
+            return abs(self.value_diff) <= self.tolerance
+        else:
+            return True
+
+    @property
+    def plot_color(self) -> str:
+        """Return one of two colors depending on if ROI passed."""
+        return "green" if self.passed else "red"
+
+
+class ThicknessROI(RectangleROI):
+    """A rectangular ROI that measures the angled wire rod in the HU linearity slice which determines slice thickness."""
+
+    @cached_property
+    def long_profile(self) -> FWXMProfile:
+        """The profile along the axis perpendicular to ramped wire."""
+        img = image.load(self.pixel_array)
+        img.filter(size=1, kind="gaussian")
+        return FWXMProfile(values=img.array.max(axis=np.argmin(img.shape)))
+
+    @cached_property
+    def wire_fwhm(self) -> float:
+        """The FWHM of the wire in pixels."""
+        return self.long_profile.field_width_px
+
+    @property
+    def plot_color(self) -> str:
+        """The plot color."""
+        return "blue"
+
+
+class Slice:
+    """Base class for analyzing specific slices of a CBCT dicom set."""
+
+    def __init__(
+        self,
+        catphan,
+        slice_num: int | None = None,
+        combine: bool = True,
+        combine_method: str = "mean",
+        num_slices: int = 0,
+        clear_borders: bool = True,
+        original_image: ImageLike | None = None,
+    ):
+        """
+        Parameters
+        ----------
+
+        catphan : :class:`~pylinac.cbct.CatPhanBase` instance.
+            The catphan instance.
+        slice_num : int
+            The slice number of the DICOM array desired. If None, will use the ``slice_num`` property of subclass.
+        combine : bool
+            If True, combines the slices +/- ``num_slices`` around the slice of interest to improve signal/noise.
+        combine_method : {'mean', 'max'}
+            How to combine the slices if ``combine`` is True.
+        num_slices : int
+            The number of slices on either side of the nominal slice to combine to improve signal/noise; only
+            applicable if ``combine`` is True.
+        clear_borders : bool
+            If True, clears the borders of the image to remove any ROIs that may be present.
+        original_image : :class:`~pylinac.core.image.Image` or None
+            The array of the slice. This is a bolt-on parameter for optimization.
+            Leaving as None is fine, but can increase analysis speed if 1) this image is passed and
+            2) there is no combination of slices happening, which is most of the time.
+        """
+        if slice_num is not None:
+            self.slice_num = slice_num
+        if combine and num_slices > 0:
+            array = combine_surrounding_slices(
+                catphan.dicom_stack,
+                self.slice_num,
+                mode=combine_method,
+                slices_plusminus=num_slices,
+            )
+        elif original_image is not None:
+            array = original_image
+        else:
+            array = catphan.dicom_stack[self.slice_num].array
+        self.image = image.load(array)
+        self.catphan_size = catphan.catphan_size
+        self.mm_per_pixel = catphan.mm_per_pixel
+        self.clear_borders = clear_borders
+        if catphan._phantom_center_func:
+            self._phantom_center_func = catphan._phantom_center_func
+
+    @property
+    def __getitem__(self, item):
+        return self.image.array[item]
+
+    @cached_property
+    def phantom_roi(self) -> RegionProperties:
+        """Get the Scikit-Image ROI of the phantom
+
+        The image is analyzed to see if:
+        1) the CatPhan is even in the image (if there were any ROIs detected)
+        2) an ROI is within the size criteria of the catphan
+        3) the ROI area that is filled compared to the bounding box area is close to that of a circle
+        """
+        # convert the slice to binary and label ROIs
+        edges = filters.scharr(self.image.as_type(float))
+        if np.max(edges) < 0.1:
+            raise ValueError(
+                "No edges were found in the image that look like the phantom"
+            )
+        larr, regionprops, num_roi = get_regions(
+            self, fill_holes=True, threshold="otsu", clear_borders=self.clear_borders
+        )
+        # check that there is at least 1 ROI
+        if num_roi < 1 or num_roi is None:
+            raise ValueError(
+                f"The number of ROIs detected {num_roi} was not the number expected (1)"
+            )
+        catphan_region = sorted(
+            regionprops, key=lambda x: np.abs(x.filled_area - self.catphan_size)
+        )[0]
+        if (self.catphan_size * 1.3 < catphan_region.filled_area) or (
+            catphan_region.filled_area < self.catphan_size / 1.3
+        ):
+            raise ValueError("Unable to find ROI of expected size of the phantom")
+        return catphan_region
+
+    def is_phantom_in_view(self) -> bool:
+        """Whether the phantom appears to be within the slice."""
+        try:
+            self.phantom_roi
+            return True
+        except ValueError:
+            return False
+
+    @property
+    def phan_center(self) -> Point:
+        """Determine the location of the center of the phantom."""
+        x = self._phantom_center_func[0](self.slice_num)
+        y = self._phantom_center_func[1](self.slice_num)
+        return Point(x=x, y=y)
+
+
+class CatPhanModule(Slice):
+    """Base class for a CTP module."""
+
+    common_name: str = ""
+    combine_method: str = "mean"
+    num_slices: int = 0
+    roi_settings: dict = {}
+    background_roi_settings: dict = {}
+    roi_dist_mm = float
+    roi_radius_mm = float
+    rois: dict = {}  # dicts of HUDiskROIs
+    background_rois: dict = {}  # dict of HUDiskROIs; possibly empty
+    window_min: int | None = None  # plt visualization
+    window_max: int | None = None  # plt visualization
+
+    def __init__(
+        self,
+        catphan,
+        tolerance: float | None = None,
+        offset: int = 0,
+        clear_borders: bool = True,
+    ):
+        self.model = ""
+        self._offset = offset
+        self.origin_slice = catphan.origin_slice
+        self.tolerance = tolerance
+        self.slice_thickness = catphan.dicom_stack.metadata.SliceThickness
+        self.slice_spacing = catphan.dicom_stack.slice_spacing
+        self.catphan_roll = catphan.catphan_roll
+        self.mm_per_pixel = catphan.mm_per_pixel
+        self.rois: dict[str, HUDiskROI] = {}
+        self.background_rois: dict[str, HUDiskROI] = {}
+        Slice.__init__(
+            self,
+            catphan,
+            combine_method=self.combine_method,
+            num_slices=self.num_slices,
+            clear_borders=clear_borders,
+        )
+        self._convert_units_in_settings()
+        self.preprocess(catphan)
+        self._setup_rois()
+
+    def _convert_units_in_settings(self) -> None:
+        setting_groups = [
+            getattr(self, attr) for attr in dir(self) if attr.endswith("roi_settings")
+        ]
+        for roi_settings in setting_groups:
+            for roi, settings in roi_settings.items():
+                if isinstance(settings, dict):
+                    if settings.get("distance") is not None:
+                        settings["distance_pixels"] = (
+                            settings["distance"] / self.mm_per_pixel
+                        )
+                    if settings.get("angle") is not None:
+                        settings["angle_corrected"] = (
+                            settings["angle"] + self.catphan_roll
+                        )
+                    if settings.get("radius") is not None:
+                        settings["radius_pixels"] = (
+                            settings["radius"] / self.mm_per_pixel
+                        )
+                    if settings.get("width") is not None:
+                        settings["width_pixels"] = settings["width"] / self.mm_per_pixel
+                    if settings.get("height") is not None:
+                        settings["height_pixels"] = (
+                            settings["height"] / self.mm_per_pixel
+                        )
+
+    def preprocess(self, catphan):
+        """A preprocessing step before analyzing the CTP module.
+
+        Parameters
+        ----------
+        catphan : `~pylinac.cbct.CatPhanBase` instance.
+        """
+        pass
+
+    @property
+    def slice_num(self) -> int:
+        """The slice number of the spatial resolution module.
+
+        Returns
+        -------
+        float
+        """
+        return int(self.origin_slice + round(self._offset / self.slice_spacing))
+
+    def _setup_rois(self) -> None:
+        for name, setting in self.background_roi_settings.items():
+            self.background_rois[name] = HUDiskROI(
+                self.image,
+                setting["angle_corrected"],
+                setting["radius_pixels"],
+                setting["distance_pixels"],
+                self.phan_center,
+            )
+        if self.background_rois:
+            background_mean = np.mean(
+                [roi.pixel_value for roi in self.background_rois.values()]
+            )
+            background_std = np.std(
+                [roi.pixel_value for roi in self.background_rois.values()]
+            )
+        else:
+            background_mean = None
+            background_std = None
+
+        for name, setting in self.roi_settings.items():
+            nominal_value = setting.get("value", 0)
+            self.rois[name] = HUDiskROI(
+                self.image,
+                setting["angle_corrected"],
+                setting["radius_pixels"],
+                setting["distance_pixels"],
+                self.phan_center,
+                nominal_value,
+                self.tolerance,
+                background_mean=background_mean,
+                background_std=background_std,
+            )
+
+    def plot_rois(self, axis: plt.Axes) -> None:
+        """Plot the ROIs to the axis."""
+        for roi in self.rois.values():
+            roi.plot2axes(axis, edgecolor=roi.plot_color)
+        for roi in self.background_rois.values():
+            roi.plot2axes(axis, edgecolor="blue")
+
+    def plot(self, axis: plt.Axes):
+        """Plot the image along with ROIs to an axis"""
+        axis.imshow(
+            self.image.array,
+            cmap=get_dicom_cmap(),
+            vmin=self.window_min,
+            vmax=self.window_max,
+        )
+        self.plot_rois(axis)
+        axis.autoscale(tight=True)
+        axis.set_title(self.common_name)
+        axis.axis("off")
+
+    @property
+    def roi_vals_as_str(self) -> str:
+        return ", ".join(
+            f"{name}: {roi.pixel_value}" for name, roi in self.rois.items()
+        )
+
+
+class CTP404CP504(CatPhanModule):
+    """Class for analysis of the HU linearity, geometry, and slice thickness regions of the CTP404."""
+
+    attr_name = "ctp404"
+    common_name = "HU Linearity"
+    roi_dist_mm = 58.7
+    roi_radius_mm = 5
+    roi_settings = {
+        "Air": {
+            "value": AIR,
+            "angle": -90,
+            "distance": roi_dist_mm,
+            "radius": roi_radius_mm,
+        },
+        "PMP": {
+            "value": PMP,
+            "angle": -120,
+            "distance": roi_dist_mm,
+            "radius": roi_radius_mm,
+        },
+        "LDPE": {
+            "value": LDPE,
+            "angle": 180,
+            "distance": roi_dist_mm,
+            "radius": roi_radius_mm,
+        },
+        "Poly": {
+            "value": POLY,
+            "angle": 120,
+            "distance": roi_dist_mm,
+            "radius": roi_radius_mm,
+        },
+        "Acrylic": {
+            "value": ACRYLIC,
+            "angle": 60,
+            "distance": roi_dist_mm,
+            "radius": roi_radius_mm,
+        },
+        "Delrin": {
+            "value": DELRIN,
+            "angle": 0,
+            "distance": roi_dist_mm,
+            "radius": roi_radius_mm,
+        },
+        "Teflon": {
+            "value": TEFLON,
+            "angle": -60,
+            "distance": roi_dist_mm,
+            "radius": roi_radius_mm,
+        },
+    }
+    background_roi_settings = {
+        "1": {"angle": -30, "distance": roi_dist_mm, "radius": roi_radius_mm},
+        "2": {"angle": -150, "distance": roi_dist_mm, "radius": roi_radius_mm},
+        "3": {"angle": -210, "distance": roi_dist_mm, "radius": roi_radius_mm},
+        "4": {"angle": 30, "distance": roi_dist_mm, "radius": roi_radius_mm},
+    }
+    # thickness
+    thickness_roi_height = 40
+    thickness_roi_width = 10
+    thickness_roi_distance_mm = 38
+    thickness_roi_settings = {
+        "Left": {
+            "angle": 180,
+            "width": thickness_roi_width,
+            "height": thickness_roi_height,
+            "distance": thickness_roi_distance_mm,
+        },
+        "Bottom": {
+            "angle": 90,
+            "width": thickness_roi_height,
+            "height": thickness_roi_width,
+            "distance": thickness_roi_distance_mm,
+        },
+        "Right": {
+            "angle": 0,
+            "width": thickness_roi_width,
+            "height": thickness_roi_height,
+            "distance": thickness_roi_distance_mm,
+        },
+        "Top": {
+            "angle": -90,
+            "width": thickness_roi_height,
+            "height": thickness_roi_width,
+            "distance": thickness_roi_distance_mm,
+        },
+    }
+    # geometry
+    geometry_roi_size_mm = 35
+    geometry_roi_settings = {
+        "Top-Horizontal": (0, 1),
+        "Bottom-Horizontal": (2, 3),
+        "Left-Vertical": (0, 2),
+        "Right-Vertical": (1, 3),
+    }
+    pad: str | int
+    thickness_image: Slice
+
+    def __init__(
+        self,
+        catphan,
+        offset: int,
+        hu_tolerance: float,
+        thickness_tolerance: float,
+        scaling_tolerance: float,
+        clear_borders: bool = True,
+        thickness_slice_straddle: str | int = "auto",
+        expected_hu_values: dict[str, float | int] | None = None,
+    ):
+        """
+        Parameters
+        ----------
+        catphan : `~pylinac.cbct.CatPhanBase` instance.
+        offset : int
+        hu_tolerance : float
+        thickness_tolerance : float
+        scaling_tolerance : float
+        clear_borders : bool
+        """
+        self.mm_per_pixel = catphan.mm_per_pixel
+        self.hu_tolerance = hu_tolerance
+        self.thickness_tolerance = thickness_tolerance
+        self.scaling_tolerance = scaling_tolerance
+        self.thickness_rois = {}
+        self.lines = {}
+        self.thickness_slice_straddle = thickness_slice_straddle
+        self.expected_hu_values = expected_hu_values
+        super().__init__(
+            catphan, tolerance=hu_tolerance, offset=offset, clear_borders=clear_borders
+        )
+
+    def preprocess(self, catphan) -> None:
+        # for the thickness analysis image, combine thin slices or just use one slice if slices are thick
+        if (
+            isinstance(self.thickness_slice_straddle, str)
+            and self.thickness_slice_straddle.lower() == "auto"
+        ):
+            if float(catphan.dicom_stack.metadata.SliceThickness) < 3.5:
+                self.pad = 1
+            else:
+                self.pad = 0
+        else:
+            self.pad = self.thickness_slice_straddle
+        self.thickness_image = Slice(
+            catphan,
+            combine_method="mean",
+            num_slices=self.num_slices + self.pad,
+            slice_num=self.slice_num,
+            clear_borders=self.clear_borders,
+        ).image
+
+    def _replace_hu_values(self):
+        """Possibly replace the HU values in the ROI settings with the expected values if the key is present."""
+        if self.expected_hu_values is not None:
+            for name, value in self.expected_hu_values.items():
+                if name in self.roi_settings:
+                    self.roi_settings[name]["value"] = value
+
+    def _setup_rois(self) -> None:
+        self._replace_hu_values()
+        super()._setup_rois()
+        self._setup_thickness_rois()
+        self._setup_geometry_rois()
+
+    def _setup_thickness_rois(self) -> None:
+        for name, setting in self.thickness_roi_settings.items():
+            self.thickness_rois[name] = ThicknessROI(
+                self.thickness_image,
+                setting["width_pixels"],
+                setting["height_pixels"],
+                setting["angle_corrected"],
+                setting["distance_pixels"],
+                self.phan_center,
+            )
+
+    def _setup_geometry_rois(self) -> None:
+        boxsize = self.geometry_roi_size_mm / self.mm_per_pixel
+        xbounds = (int(self.phan_center.x - boxsize), int(self.phan_center.x + boxsize))
+        ybounds = (int(self.phan_center.y - boxsize), int(self.phan_center.y + boxsize))
+        geo_img = self.image[ybounds[0] : ybounds[1], xbounds[0] : xbounds[1]]
+        larr, regionprops, num_roi = get_regions(
+            geo_img, fill_holes=True, clear_borders=False
+        )
+        # check that there is at least 1 ROI
+        if num_roi < 4:
+            raise ValueError("Unable to locate the Geometric nodes")
+        elif num_roi > 4:
+            regionprops = sorted(
+                regionprops, key=lambda x: x.filled_area, reverse=True
+            )[:4]
+        sorted_regions = sorted(
+            regionprops, key=lambda x: (2 * x.centroid[0] + x.centroid[1])
+        )
+        centers = [
+            Point(
+                r.weighted_centroid[1] + xbounds[0], r.weighted_centroid[0] + ybounds[0]
+            )
+            for r in sorted_regions
+        ]
+        #  setup the geometric lines
+        for name, order in self.geometry_roi_settings.items():
+            self.lines[name] = GeometricLine(
+                centers[order[0]],
+                centers[order[1]],
+                self.mm_per_pixel,
+                self.scaling_tolerance,
+            )
+
+    @property
+    def lcv(self) -> float:
+        """The low-contrast visibility"""
+        return (
+            2
+            * abs(self.rois["LDPE"].pixel_value - self.rois["Poly"].pixel_value)
+            / (self.rois["LDPE"].std + self.rois["Poly"].std)
+        )
+
+    def plot_linearity(
+        self, axis: plt.Axes | None = None, plot_delta: bool = True
+    ) -> tuple:
+        """Plot the HU linearity values to an axis.
+
+        Parameters
+        ----------
+        axis : None, matplotlib.Axes
+            The axis to plot the values on. If None, will create a new figure.
+        plot_delta : bool
+            Whether to plot the actual measured HU values (False), or the difference from nominal (True).
+        """
+        nominal_x_values = [roi.nominal_val for roi in self.rois.values()]
+        if axis is None:
+            fig, axis = plt.subplots()
+        if plot_delta:
+            values = [roi.value_diff for roi in self.rois.values()]
+            nominal_measurements = [0] * len(values)
+            ylabel = "HU Delta"
+        else:
+            values = [roi.pixel_value for roi in self.rois.values()]
+            nominal_measurements = nominal_x_values
+            ylabel = "Measured Values"
+        points = axis.plot(nominal_x_values, values, "g+", markersize=15, mew=2)
+        axis.plot(nominal_x_values, nominal_measurements)
+        axis.plot(
+            nominal_x_values, np.array(nominal_measurements) + self.hu_tolerance, "r--"
+        )
+        axis.plot(
+            nominal_x_values, np.array(nominal_measurements) - self.hu_tolerance, "r--"
+        )
+        axis.margins(0.05)
+        axis.grid(True)
+        axis.set_xlabel("Nominal Values")
+        axis.set_ylabel(ylabel)
+        axis.set_title("HU linearity")
+        return points
+
+    @property
+    def passed_hu(self) -> bool:
+        """Boolean specifying whether all the ROIs passed within tolerance."""
+        return all(roi.passed for roi in self.rois.values())
+
+    def plot_rois(self, axis: plt.Axes) -> None:
+        """Plot the ROIs onto the image, as well as the background ROIs"""
+        # plot HU linearity ROIs
+        super().plot_rois(axis)
+        # plot thickness ROIs
+        for roi in self.thickness_rois.values():
+            roi.plot2axes(axis, edgecolor="blue")
+        # plot geometry lines
+        for line in self.lines.values():
+            line.plot2axes(axis, color=line.pass_fail_color)
+
+    @property
+    def passed_thickness(self) -> bool:
+        """Whether the slice thickness was within tolerance from nominal."""
+        return (
+            self.slice_thickness - self.thickness_tolerance
+            < self.meas_slice_thickness
+            < self.slice_thickness + self.thickness_tolerance
+        )
+
+    @property
+    def meas_slice_thickness(self) -> float:
+        """The average slice thickness for the 4 wire measurements in mm."""
+        return np.mean(
+            sorted(
+                roi.wire_fwhm * self.mm_per_pixel * RAMP_ANGLE_RATIO
+                for roi in self.thickness_rois.values()
+            )
+        ) / (1 + 2 * self.pad)
+
+    @property
+    def avg_line_length(self) -> float:
+        return float(np.mean([line.length_mm for line in self.lines.values()]))
+
+    @property
+    def passed_geometry(self) -> bool:
+        """Returns whether all the line lengths were within tolerance."""
+        return all(line.passed for line in self.lines.values())
+
+
+class CTP404CP503(CTP404CP504):
+    """Alias for namespace consistency"""
+
+    pass
+
+
+class CTP404CP600(CTP404CP504):
+    roi_dist_mm = 58.7
+    roi_radius_mm = 5
+    roi_settings = {
+        "Air": {
+            "value": AIR,
+            "angle": 90,
+            "distance": roi_dist_mm,
+            "radius": roi_radius_mm,
+        },
+        "PMP": {
+            "value": PMP,
+            "angle": 60,
+            "distance": roi_dist_mm,
+            "radius": roi_radius_mm,
+        },
+        "LDPE": {
+            "value": LDPE,
+            "angle": 0,
+            "distance": roi_dist_mm,
+            "radius": roi_radius_mm,
+        },
+        "Poly": {
+            "value": POLY,
+            "angle": -60,
+            "distance": roi_dist_mm,
+            "radius": roi_radius_mm,
+        },
+        "Acrylic": {
+            "value": ACRYLIC,
+            "angle": -120,
+            "distance": roi_dist_mm,
+            "radius": roi_radius_mm,
+        },
+        "Delrin": {
+            "value": DELRIN,
+            "angle": -180,
+            "distance": roi_dist_mm,
+            "radius": roi_radius_mm,
+        },
+        "Teflon": {
+            "value": TEFLON,
+            "angle": 120,
+            "distance": roi_dist_mm,
+            "radius": roi_radius_mm,
+        },
+        "Vial": {
+            "value": WATER,
+            "angle": -90,
+            "distance": roi_dist_mm,
+            "radius": roi_radius_mm
+            - 1,  # the vial sits inside the ROI and needs some clearance
+        },
+    }
+
+    def _setup_rois(self) -> None:
+        """For the 600, the top ROI is an optional water vial slot. If the HU is near water we leave it, otherwise we remove it so as not to flag false failures"""
+        super()._setup_rois()
+        if self.rois["Vial"].pixel_value < -500:  # closer to air than water
+            self.rois.pop("Vial")
+
+
+class CTP404CP604(CTP404CP504):
+    roi_dist_mm = 58.7
+    roi_radius_mm = 5
+    roi_settings = {
+        "Air": {
+            "value": AIR,
+            "angle": -90,
+            "distance": roi_dist_mm,
+            "radius": roi_radius_mm,
+        },
+        "PMP": {
+            "value": PMP,
+            "angle": -120,
+            "distance": roi_dist_mm,
+            "radius": roi_radius_mm,
+        },
+        "50% Bone": {
+            "value": BONE_50,
+            "angle": -150,
+            "distance": roi_dist_mm,
+            "radius": roi_radius_mm,
+        },
+        "LDPE": {
+            "value": LDPE,
+            "angle": 180,
+            "distance": roi_dist_mm,
+            "radius": roi_radius_mm,
+        },
+        "Poly": {
+            "value": POLY,
+            "angle": 120,
+            "distance": roi_dist_mm,
+            "radius": roi_radius_mm,
+        },
+        "Acrylic": {
+            "value": ACRYLIC,
+            "angle": 60,
+            "distance": roi_dist_mm,
+            "radius": roi_radius_mm,
+        },
+        "20% Bone": {
+            "value": BONE_20,
+            "angle": 30,
+            "distance": roi_dist_mm,
+            "radius": roi_radius_mm,
+        },
+        "Delrin": {
+            "value": DELRIN,
+            "angle": 0,
+            "distance": roi_dist_mm,
+            "radius": roi_radius_mm,
+        },
+        "Teflon": {
+            "value": TEFLON,
+            "angle": -60,
+            "distance": roi_dist_mm,
+            "radius": roi_radius_mm,
+        },
+    }
+    background_roi_settings = {
+        "1": {"angle": -30, "distance": roi_dist_mm, "radius": roi_radius_mm},
+        "2": {"angle": -210, "distance": roi_dist_mm, "radius": roi_radius_mm},
+    }
+
+
+class CTP486(CatPhanModule):
+    """Class for analysis of the Uniformity slice of the CTP module. Measures 5 ROIs around the slice that
+    should all be close to the same value.
+    """
+
+    attr_name = "ctp486"
+    common_name = "HU Uniformity"
+    roi_dist_mm = 53
+    roi_radius_mm = 10
+    nominal_value = 0
+    nps_rois: dict[str, RectangleROI]
+    roi_settings = {
+        "Top": {
+            "value": nominal_value,
+            "angle": -90,
+            "distance": roi_dist_mm,
+            "radius": roi_radius_mm,
+        },
+        "Right": {
+            "value": nominal_value,
+            "angle": 0,
+            "distance": roi_dist_mm,
+            "radius": roi_radius_mm,
+        },
+        "Bottom": {
+            "value": nominal_value,
+            "angle": 90,
+            "distance": roi_dist_mm,
+            "radius": roi_radius_mm,
+        },
+        "Left": {
+            "value": nominal_value,
+            "angle": 180,
+            "distance": roi_dist_mm,
+            "radius": roi_radius_mm,
+        },
+        "Center": {
+            "value": nominal_value,
+            "angle": 0,
+            "distance": 0,
+            "radius": roi_radius_mm,
+        },
+    }
+
+    def plot_profiles(self, axis: plt.Axes | None = None) -> None:
+        """Plot the horizontal and vertical profiles of the Uniformity slice.
+
+        Parameters
+        ----------
+        axis : None, matplotlib.Axes
+            The axis to plot on; if None, will create a new figure.
+        """
+        if axis is None:
+            fig, axis = plt.subplots()
+        horiz_data = self.image[int(self.phan_center.y), :]
+        vert_data = self.image[:, int(self.phan_center.x)]
+        axis.plot(horiz_data, "g", label="Horizontal")
+        axis.plot(vert_data, "b", label="Vertical")
+        axis.autoscale(tight=True)
+        axis.axhline(self.nominal_value + self.tolerance, color="r", linewidth=3)
+        axis.axhline(self.nominal_value - self.tolerance, color="r", linewidth=3)
+        axis.grid(True)
+        axis.set_ylabel("HU")
+        axis.legend(loc=8, fontsize="small", title="")
+        axis.set_title("Uniformity Profiles")
+
+    def _setup_rois(self) -> None:
+        """Generate our NPS ROIs. They are just square versions of the existing ROIs."""
+        super()._setup_rois()
+        self.nps_rois = {}
+        for name, setting in self.roi_settings.items():
+            self.nps_rois[name] = RectangleROI(
+                array=self.image,
+                width=setting["radius_pixels"] * 2,
+                height=setting["radius_pixels"] * 2,
+                angle=setting["angle_corrected"],
+                dist_from_center=setting["distance_pixels"],
+                phantom_center=self.phan_center,
+            )
+
+    def plot(self, axis: plt.Axes):
+        """Plot the ROIs but also the noise power spectrum ROIs"""
+        for nps_roi in self.nps_rois.values():
+            nps_roi.plot2axes(axis, edgecolor="green", linestyle="-.")
+        super().plot(axis)
+
+    @property
+    def overall_passed(self) -> bool:
+        """Boolean specifying whether all the ROIs passed within tolerance."""
+        return all(roi.passed for roi in self.rois.values())
+
+    @property
+    def uniformity_index(self) -> float:
+        """The Uniformity Index. Elstrom et al equation 2. https://www.tandfonline.com/doi/pdf/10.3109/0284186X.2011.590525"""
+        center = self.rois["Center"]
+        uis = [
+            100 * ((roi.pixel_value - center.pixel_value) / (center.pixel_value + 1000))
+            for roi in self.rois.values()
+        ]
+        abs_uis = np.abs(uis)
+        return uis[np.argmax(abs_uis)]
+
+    @property
+    def integral_non_uniformity(self) -> float:
+        """The Integral Non-Uniformity. Elstrom et al equation 1. https://www.tandfonline.com/doi/pdf/10.3109/0284186X.2011.590525"""
+        maxhu = max(roi.pixel_value for roi in self.rois.values())
+        minhu = min(roi.pixel_value for roi in self.rois.values())
+        return (maxhu - minhu) / (maxhu + minhu + 2000)
+
+    @cached_property
+    def power_spectrum_2d(self) -> np.ndarray:
+        """The power spectrum of the uniformity ROI."""
+        return noise_power_spectrum_2d(
+            pixel_size=self.mm_per_pixel,
+            rois=[r.pixel_array for r in self.nps_rois.values()],
+        )
+
+    @cached_property
+    def power_spectrum_1d(self) -> np.ndarray:
+        """The 1D power spectrum of the uniformity ROI."""
+        return noise_power_spectrum_1d(self.power_spectrum_2d)
+
+    @property
+    def avg_noise_power(self) -> float:
+        """The average noise power of the uniformity ROI."""
+        return average_power(self.power_spectrum_1d)
+
+    @property
+    def max_noise_power_frequency(self) -> float:
+        """The frequency of the maximum noise power. 0 means no pattern."""
+        return max_frequency(self.power_spectrum_1d)
+
+
+class CTP528CP504(CatPhanModule):
+    """Class for analysis of the Spatial Resolution slice of the CBCT dicom data set.
+
+    A collapsed circle profile is taken of the line-pair region. This profile is search for
+    peaks and valleys. The MTF is calculated from those peaks & valleys.
+
+    Attributes
+    ----------
+
+    radius2linepairs_mm : float
+        The radius in mm to the line pairs.
+
+    """
+
+    attr_name: str = "ctp528"
+    common_name: str = "Spatial Resolution"
+    radius2linepairs_mm = 47
+    combine_method: str = "max"
+    num_slices: int = 3
+    boundaries: tuple[float, ...] = (
+        0,
+        0.107,
+        0.173,
+        0.236,
+        0.286,
+        0.335,
+        0.387,
+        0.434,
+        0.479,
+    )
+    start_angle: float = np.pi
+    ccw: bool = True
+    roi_settings = {
+        "region 1": {
+            "start": boundaries[0],
+            "end": boundaries[1],
+            "num peaks": 2,
+            "num valleys": 1,
+            "peak spacing": 0.021,
+            "gap size (cm)": 0.5,
+            "lp/mm": 0.1,
+        },
+        "region 2": {
+            "start": boundaries[1],
+            "end": boundaries[2],
+            "num peaks": 3,
+            "num valleys": 2,
+            "peak spacing": 0.01,
+            "gap size (cm)": 0.25,
+            "lp/mm": 0.2,
+        },
+        "region 3": {
+            "start": boundaries[2],
+            "end": boundaries[3],
+            "num peaks": 4,
+            "num valleys": 3,
+            "peak spacing": 0.006,
+            "gap size (cm)": 0.167,
+            "lp/mm": 0.3,
+        },
+        "region 4": {
+            "start": boundaries[3],
+            "end": boundaries[4],
+            "num peaks": 4,
+            "num valleys": 3,
+            "peak spacing": 0.00557,
+            "gap size (cm)": 0.125,
+            "lp/mm": 0.4,
+        },
+        "region 5": {
+            "start": boundaries[4],
+            "end": boundaries[5],
+            "num peaks": 4,
+            "num valleys": 3,
+            "peak spacing": 0.004777,
+            "gap size (cm)": 0.1,
+            "lp/mm": 0.5,
+        },
+        "region 6": {
+            "start": boundaries[5],
+            "end": boundaries[6],
+            "num peaks": 5,
+            "num valleys": 4,
+            "peak spacing": 0.00398,
+            "gap size (cm)": 0.083,
+            "lp/mm": 0.6,
+        },
+        "region 7": {
+            "start": boundaries[6],
+            "end": boundaries[7],
+            "num peaks": 5,
+            "num valleys": 4,
+            "peak spacing": 0.00358,
+            "gap size (cm)": 0.071,
+            "lp/mm": 0.7,
+        },
+        "region 8": {
+            "start": boundaries[7],
+            "end": boundaries[8],
+            "num peaks": 5,
+            "num valleys": 4,
+            "peak spacing": 0.0027866,
+            "gap size (cm)": 0.063,
+            "lp/mm": 0.8,
+        },
+    }
+
+    def _setup_rois(self):
+        pass
+
+    def _convert_units_in_settings(self):
+        pass
+
+    @cached_property
+    def mtf(self) -> MTF:
+        """The Relative MTF of the line pairs, normalized to the first region.
+
+        Returns
+        -------
+        dict
+        """
+        maxs = list()
+        mins = list()
+        for key, value in self.roi_settings.items():
+            max_indices, max_values = self.circle_profile.find_peaks(
+                min_distance=value["peak spacing"],
+                max_number=value["num peaks"],
+                search_region=(value["start"], value["end"]),
+            )
+            # check that the right number of peaks were found before continuing, otherwise stop searching for regions
+            if len(max_values) != value["num peaks"]:
+                break
+            maxs.append(max_values.mean())
+            _, min_values = self.circle_profile.find_valleys(
+                min_distance=value["peak spacing"],
+                max_number=value["num valleys"],
+                search_region=(min(max_indices), max(max_indices)),
+            )
+            mins.append(min_values.mean())
+        if not maxs:
+            raise ValueError(
+                "Did not find any spatial resolution pairs to analyze. File an issue on github (https://github.com/jrkerns/pylinac/issues) if this is a valid dataset."
+            )
+
+        spacings = [roi["lp/mm"] for roi in self.roi_settings.values()]
+        mtf = MTF(lp_spacings=spacings, lp_maximums=maxs, lp_minimums=mins)
+        return mtf
+
+    @property
+    def radius2linepairs(self) -> float:
+        """Radius from the phantom center to the line-pair region, corrected for pixel spacing."""
+        return self.radius2linepairs_mm / self.mm_per_pixel
+
+    def plot_rois(self, axis: plt.Axes) -> None:
+        """Plot the circles where the profile was taken within."""
+        self.circle_profile.plot2axes(axis, edgecolor="blue", plot_peaks=False)
+
+    @cached_property
+    def circle_profile(self) -> CollapsedCircleProfile:
+        """Calculate the median profile of the Line Pair region.
+
+        Returns
+        -------
+        :class:`pylinac.core.profile.CollapsedCircleProfile` : A 1D profile of the Line Pair region.
+        """
+        circle_profile = CollapsedCircleProfile(
+            self.phan_center,
+            self.radius2linepairs,
+            image_array=self.image,
+            start_angle=self.start_angle + np.deg2rad(self.catphan_roll),
+            width_ratio=0.04,
+            sampling_ratio=2,
+            ccw=self.ccw,
+        )
+        circle_profile.filter(0.001, kind="gaussian")
+        circle_profile.ground()
+        return circle_profile
+
+
+class CTP528CP604(CTP528CP504):
+    """Alias for namespace consistency."""
+
+    pass
+
+
+class CTP528CP600(CTP528CP504):
+    start_angle = np.pi - 0.1
+    ccw = False
+    boundaries = (0, 0.127, 0.195, 0.255, 0.304, 0.354, 0.405, 0.453, 0.496)
+    roi_settings = {
+        "region 1": {
+            "start": boundaries[0],
+            "end": boundaries[1],
+            "num peaks": 2,
+            "num valleys": 1,
+            "peak spacing": 0.021,
+            "gap size (cm)": 0.5,
+            "lp/mm": 0.1,
+        },
+        "region 2": {
+            "start": boundaries[1],
+            "end": boundaries[2],
+            "num peaks": 3,
+            "num valleys": 2,
+            "peak spacing": 0.01,
+            "gap size (cm)": 0.25,
+            "lp/mm": 0.2,
+        },
+        "region 3": {
+            "start": boundaries[2],
+            "end": boundaries[3],
+            "num peaks": 4,
+            "num valleys": 3,
+            "peak spacing": 0.006,
+            "gap size (cm)": 0.167,
+            "lp/mm": 0.3,
+        },
+        "region 4": {
+            "start": boundaries[3],
+            "end": boundaries[4],
+            "num peaks": 4,
+            "num valleys": 3,
+            "peak spacing": 0.00557,
+            "gap size (cm)": 0.125,
+            "lp/mm": 0.4,
+        },
+        "region 5": {
+            "start": boundaries[4],
+            "end": boundaries[5],
+            "num peaks": 4,
+            "num valleys": 3,
+            "peak spacing": 0.004777,
+            "gap size (cm)": 0.1,
+            "lp/mm": 0.5,
+        },
+        "region 6": {
+            "start": boundaries[5],
+            "end": boundaries[6],
+            "num peaks": 5,
+            "num valleys": 4,
+            "peak spacing": 0.00398,
+            "gap size (cm)": 0.083,
+            "lp/mm": 0.6,
+        },
+        "region 7": {
+            "start": boundaries[6],
+            "end": boundaries[7],
+            "num peaks": 5,
+            "num valleys": 4,
+            "peak spacing": 0.00358,
+            "gap size (cm)": 0.071,
+            "lp/mm": 0.7,
+        },
+        "region 8": {
+            "start": boundaries[7],
+            "end": boundaries[8],
+            "num peaks": 5,
+            "num valleys": 4,
+            "peak spacing": 0.0027866,
+            "gap size (cm)": 0.063,
+            "lp/mm": 0.8,
+        },
+    }
+
+
+class CTP528CP503(CTP528CP504):
+    start_angle = 0
+    ccw = False
+    boundaries = (0, 0.111, 0.176, 0.240, 0.289, 0.339, 0.390, 0.436, 0.481)
+
+
+class GeometricLine(Line):
+    """Represents a line connecting two nodes/ROIs on the Geometry Slice.
+
+    Attributes
+    ----------
+    nominal_length_mm : int, float
+        The nominal distance between the geometric nodes, in mm.
+    """
+
+    nominal_length_mm: float | int = 50
+
+    def __init__(
+        self,
+        geo_roi1: Point,
+        geo_roi2: Point,
+        mm_per_pixel: float,
+        tolerance: int | float,
+    ):
+        """
+        Parameters
+        ----------
+        geo_roi1 : GEO_ROI
+            One of two ROIs representing one end of the line.
+        geo_roi2 : GEO_ROI
+            The other ROI which is the other end of the line.
+        mm_per_pixel : float
+            The mm/pixel value.
+        tolerance : int, float
+            The tolerance of the geometric line, in mm.
+        """
+        super().__init__(geo_roi1, geo_roi2)
+        self.mm_per_pixel = mm_per_pixel
+        self.tolerance = tolerance
+
+    @property
+    def passed(self) -> bool:
+        """Whether the line passed tolerance."""
+        return (
+            self.nominal_length_mm - self.tolerance
+            < self.length_mm
+            < self.nominal_length_mm + self.tolerance
+        )
+
+    @property
+    def pass_fail_color(self) -> str:
+        """Plot color for the line, based on pass/fail status."""
+        return "blue" if self.passed else "red"
+
+    @property
+    def length_mm(self) -> float:
+        """Return the length of the line in mm."""
+        return self.length * self.mm_per_pixel
+
+
+class CTP515(CatPhanModule):
+    """Class for analysis of the low contrast slice of the CTP module. Low contrast is measured by obtaining
+    the average pixel value of the contrast ROIs and comparing that value to the average background value. To obtain
+    a more "human" detection level, the contrast (which is largely the same across different-sized ROIs) is multiplied
+    by the diameter. This value is compared to the contrast threshold to decide if it can be "seen".
+    """
+
+    attr_name = "ctp515"
+    common_name = "Low Contrast"
+    num_slices = 1
+    roi_dist_mm = 50
+    roi_radius_mm = [6, 3.5, 3, 2.5, 2, 1.5]
+    roi_angles = [-87.4, -69.1, -52.7, -38.5, -25.1, -12.9]
+    roi_settings = {
+        "15": {
+            "angle": roi_angles[0],
+            "distance": roi_dist_mm,
+            "radius": roi_radius_mm[0],
+        },
+        "9": {
+            "angle": roi_angles[1],
+            "distance": roi_dist_mm,
+            "radius": roi_radius_mm[1],
+        },
+        "8": {
+            "angle": roi_angles[2],
+            "distance": roi_dist_mm,
+            "radius": roi_radius_mm[2],
+        },
+        "7": {
+            "angle": roi_angles[3],
+            "distance": roi_dist_mm,
+            "radius": roi_radius_mm[3],
+        },
+        "6": {
+            "angle": roi_angles[4],
+            "distance": roi_dist_mm,
+            "radius": roi_radius_mm[4],
+        },
+        "5": {
+            "angle": roi_angles[5],
+            "distance": roi_dist_mm,
+            "radius": roi_radius_mm[5],
+        },
+    }
+    background_roi_dist_ratio = 0.75
+    background_roi_radius_mm = 4
+    WINDOW_SIZE = 50
+
+    def __init__(
+        self,
+        catphan,
+        tolerance: float,
+        cnr_threshold: float,
+        offset: int,
+        contrast_method: str,
+        visibility_threshold: float,
+        clear_borders: bool = True,
+    ):
+        self.cnr_threshold = cnr_threshold
+        self.contrast_method = contrast_method
+        self.visibility_threshold = visibility_threshold
+        super().__init__(
+            catphan, tolerance=tolerance, offset=offset, clear_borders=clear_borders
+        )
+
+    def _setup_rois(self):
+        # create both background rois dynamically, then create the actual sample ROI as normal
+        for name, setting in self.roi_settings.items():
+            self.background_rois[name + "-outer"] = LowContrastDiskROI(
+                self.image,
+                setting["angle_corrected"],
+                self.background_roi_radius_mm / self.mm_per_pixel,
+                setting["distance_pixels"] * (2 - self.background_roi_dist_ratio),
+                self.phan_center,
+            )
+            self.background_rois[name + "-inner"] = LowContrastDiskROI(
+                self.image,
+                setting["angle_corrected"],
+                self.background_roi_radius_mm / self.mm_per_pixel,
+                setting["distance_pixels"] * self.background_roi_dist_ratio,
+                self.phan_center,
+            )
+            background_val = float(
+                np.mean(
+                    [
+                        self.background_rois[name + "-outer"].pixel_value,
+                        self.background_rois[name + "-inner"].pixel_value,
+                    ]
+                )
+            )
+
+            self.rois[name] = LowContrastDiskROI(
+                self.image,
+                setting["angle_corrected"],
+                setting["radius_pixels"],
+                setting["distance_pixels"],
+                self.phan_center,
+                contrast_reference=background_val,
+                cnr_threshold=self.cnr_threshold,
+                contrast_method=self.contrast_method,
+                visibility_threshold=self.visibility_threshold,
+            )
+
+    @property
+    def rois_visible(self) -> int:
+        """The number of ROIs "visible"."""
+        return sum(roi.passed_visibility for roi in self.rois.values())
+
+    @property
+    def window_min(self) -> float:
+        """Lower bound of CT window/leveling to show on the plotted image. Improves apparent contrast."""
+        return (
+            Enumerable(self.background_rois.values()).min(lambda r: r.pixel_value)
+            - self.WINDOW_SIZE
+        )
+
+    @property
+    def window_max(self) -> float:
+        """Upper bound of CT window/leveling to show on the plotted image. Improves apparent contrast"""
+        return (
+            Enumerable(self.rois.values()).max(lambda r: r.pixel_value)
+            + self.WINDOW_SIZE
+        )
+
+
+class CTP515CP600(CTP515):
+    roi_angles = [
+        -87.4 + 180,
+        -69.1 + 180,
+        -52.7 + 180,
+        -38.5 + 180,
+        -25.1 + 180,
+        -12.9 + 180,
+    ]
+    roi_dist_mm = 50
+    roi_radius_mm = [6, 3.5, 3, 2.5, 2, 1.5]
+    roi_settings = {
+        "15": {
+            "angle": roi_angles[0],
+            "distance": roi_dist_mm,
+            "radius": roi_radius_mm[0],
+        },
+        "9": {
+            "angle": roi_angles[1],
+            "distance": roi_dist_mm,
+            "radius": roi_radius_mm[1],
+        },
+        "8": {
+            "angle": roi_angles[2],
+            "distance": roi_dist_mm,
+            "radius": roi_radius_mm[2],
+        },
+        "7": {
+            "angle": roi_angles[3],
+            "distance": roi_dist_mm,
+            "radius": roi_radius_mm[3],
+        },
+        "6": {
+            "angle": roi_angles[4],
+            "distance": roi_dist_mm,
+            "radius": roi_radius_mm[4],
+        },
+        "5": {
+            "angle": roi_angles[5],
+            "distance": roi_dist_mm,
+            "radius": roi_radius_mm[5],
+        },
+    }
+
+
+class CatPhanBase(ResultsDataMixin[CatphanResult]):
+    """A class for loading and analyzing CT DICOM files of a CatPhan 504 & CatPhan 503. Can be from a CBCT or CT scanner
+    Analyzes: Uniformity (CTP486), High-Contrast Spatial Resolution (CTP528), Image Scaling & HU Linearity (CTP404).
+    """
+
+    _demo_url: str = ""
+    _model: str = ""
+    air_bubble_radius_mm: int | float = 7
+    localization_radius: int | float = 59
+    was_from_zip: bool = False
+    min_num_images = 39
+    clear_borders: bool = True
+    hu_origin_slice_variance = 400  # the HU variance required on the origin slice
+    _phantom_center_func: tuple[Callable, Callable] | None = None
+    modules: dict[CatPhanModule, dict[str, int]]
+    dicom_stack: image.DicomImageStack | image.LazyDicomImageStack
+
+    def __init__(
+        self,
+        folderpath: str | Sequence[str] | Path | Sequence[Path] | Sequence[BytesIO],
+        check_uid: bool = True,
+        memory_efficient_mode: bool = False,
+    ):
+        """
+        Parameters
+        ----------
+        folderpath : str, list of strings, or Path to folder
+            String that points to the CBCT image folder location.
+        check_uid : bool
+            Whether to enforce raising an error if more than one UID is found in the dataset.
+        memory_efficient_mode : bool
+            Whether to use a memory efficient mode. If True, the DICOM stack will be loaded on demand rather than all at once.
+            This will reduce the memory footprint but will be slower by ~25%. Default is False.
+
+        Raises
+        ------
+        NotADirectoryError
+            If folder str passed is not a valid directory.
+        FileNotFoundError
+            If no CT images are found in the folder
+        """
+        self.origin_slice = 0
+        self.catphan_roll = 0
+        if isinstance(folderpath, (str, Path)):
+            if not osp.isdir(folderpath):
+                raise NotADirectoryError("Path given was not a Directory/Folder")
+        stack = (
+            image.DicomImageStack
+            if not memory_efficient_mode
+            else image.LazyDicomImageStack
+        )
+        self.dicom_stack = stack(
+            folderpath, check_uid=check_uid, min_number=self.min_num_images
+        )
+
+    @classmethod
+    def from_demo_images(cls):
+        """Construct a CBCT object from the demo images."""
+        demo_file = retrieve_demo_file(name=cls._demo_url)
+        return cls.from_zip(demo_file)
+
+    @classmethod
+    def from_url(cls, url: str, check_uid: bool = True):
+        """Instantiate a CBCT object from a URL pointing to a .zip object.
+
+        Parameters
+        ----------
+        url : str
+            URL pointing to a zip archive of CBCT images.
+        check_uid : bool
+            Whether to enforce raising an error if more than one UID is found in the dataset.
+        """
+        filename = get_url(url)
+        return cls.from_zip(filename, check_uid=check_uid)
+
+    @classmethod
+    def from_zip(
+        cls,
+        zip_file: str | zipfile.ZipFile | BinaryIO,
+        check_uid: bool = True,
+        memory_efficient_mode: bool = False,
+    ):
+        """Construct a CBCT object and pass the zip file.
+
+        Parameters
+        ----------
+        zip_file : str, ZipFile
+            Path to the zip file or a ZipFile object.
+        check_uid : bool
+            Whether to enforce raising an error if more than one UID is found in the dataset.
+        memory_efficient_mode : bool
+            Whether to use a memory efficient mode. If True, the DICOM stack will be loaded on demand rather than all at once.
+            This will reduce the memory footprint but will be slower by ~25%. Default is False.
+
+        Raises
+        ------
+        FileExistsError : If zip_file passed was not a legitimate zip file.
+        FileNotFoundError : If no CT images are found in the folder
+        """
+        delete = not memory_efficient_mode
+        with TemporaryZipDirectory(zip_file, delete=delete) as temp_zip:
+            obj = cls(
+                temp_zip,
+                check_uid=check_uid,
+                memory_efficient_mode=memory_efficient_mode,
+            )
+        obj.was_from_zip = True
+        return obj
+
+    def plot_analyzed_image(self, show: bool = True, **plt_kwargs) -> None:
+        """Plot the images used in the calculation and summary data.
+
+        Parameters
+        ----------
+        show : bool
+            Whether to plot the image or not.
+        plt_kwargs : dict
+            Keyword args passed to the plt.figure() method. Allows one to set things like figure size.
+        """
+
+        # set up grid and axes
+        plt.figure(**plt_kwargs)
+        grid_size = (2, 4)
+        hu_ax = plt.subplot2grid(grid_size, (0, 1))
+        self.ctp404.plot(hu_ax)
+        hu_lin_ax = plt.subplot2grid(grid_size, (0, 2))
+        self.ctp404.plot_linearity(hu_lin_ax)
+        # plot side view w/ module locations
+        side_ax = plt.subplot2grid(grid_size, (1, 2))
+        self.plot_side_view(side_ax)
+        # plot individual modules
+        if self._has_module(CTP486):
+            unif_ax = plt.subplot2grid(grid_size, (0, 0))
+            self.ctp486.plot(unif_ax)
+            unif_prof_ax = plt.subplot2grid(grid_size, (1, 3))
+            self.ctp486.plot_profiles(unif_prof_ax)
+        if self._has_module(CTP528CP504):
+            sr_ax = plt.subplot2grid(grid_size, (1, 0))
+            self.ctp528.plot(sr_ax)
+            mtf_ax = plt.subplot2grid(grid_size, (0, 3))
+            self.ctp528.mtf.plot(mtf_ax)
+        if self._has_module(CTP515):
+            locon_ax = plt.subplot2grid(grid_size, (1, 1))
+            self.ctp515.plot(locon_ax)
+
+        # finish up
+        plt.tight_layout()
+        if show:
+            plt.show()
+
+    def save_analyzed_image(self, filename: str | Path | BinaryIO, **kwargs) -> None:
+        """Save the analyzed summary plot.
+
+        Parameters
+        ----------
+        filename : str, file object
+            The name of the file to save the image to.
+        kwargs :
+            Any valid matplotlib kwargs.
+        """
+        self.plot_analyzed_image(show=False)
+        plt.savefig(filename, **kwargs)
+
+    def plot_analyzed_subimage(
+        self,
+        subimage: str = "hu",
+        delta: bool = True,
+        show: bool = True,
+    ) -> plt.Figure | None:
+        """Plot a specific component of the CBCT analysis.
+
+        Parameters
+        ----------
+        subimage : {'hu', 'un', 'sp', 'lc', 'mtf', 'lin', 'prof', 'side'}
+            The subcomponent to plot. Values must contain one of the following letter combinations.
+            E.g. ``linearity``, ``linear``, and ``lin`` will all draw the HU linearity values.
+
+            * ``hu`` draws the HU linearity image.
+            * ``un`` draws the HU uniformity image.
+            * ``sp`` draws the Spatial Resolution image.
+            * ``lc`` draws the Low Contrast image (if applicable).
+            * ``mtf`` draws the RMTF plot.
+            * ``lin`` draws the HU linearity values. Used with ``delta``.
+            * ``prof`` draws the HU uniformity profiles.
+            * ``side`` draws the side view of the phantom with lines of the module locations.
+        delta : bool
+            Only for use with ``lin``. Whether to plot the HU delta or actual values.
+        show : bool
+            Whether to actually show the plot.
+        """
+        subimage = subimage.lower()
+        fig, ax = plt.subplots()
+        plt.axis("off")
+
+        if "hu" in subimage:  # HU, GEO & thickness objects
+            self.ctp404.plot(ax)
+            plt.autoscale(tight=True)
+        elif "un" in subimage:  # uniformity
+            self.ctp486.plot(ax)
+            plt.autoscale(tight=True)
+        elif "sp" in subimage:  # SR objects
+            self.ctp528.plot(ax)
+            plt.autoscale(tight=True)
+        elif "mtf" in subimage:
+            plt.axis("on")
+            self.ctp528.mtf.plot(ax)
+        elif "lc" in subimage:
+            if self._has_module(CTP515):
+                self.ctp515.plot(ax)
+                plt.autoscale(tight=True)
+            else:
+                return
+        elif "lin" in subimage:
+            plt.axis("on")
+            self.ctp404.plot_linearity(ax, delta)
+        elif "prof" in subimage:
+            plt.axis("on")
+            self.ctp486.plot_profiles(ax)
+        elif "side" in subimage:
+            ax = plt.gca()
+            self.plot_side_view(ax)
+        else:
+            raise ValueError(f"Subimage parameter {subimage} not understood")
+
+        if show:
+            plt.show()
+        return fig
+
+    def save_analyzed_subimage(
+        self,
+        filename: str | BinaryIO,
+        subimage: str = "hu",
+        delta: bool = True,
+        **kwargs,
+    ) -> plt.Figure | None:
+        """Save a component image to file.
+
+        Parameters
+        ----------
+        filename : str, file object
+            The file to write the image to.
+        subimage : str
+            See :meth:`~pylinac.ct.CatPhanBase.plot_analyzed_subimage` for parameter info.
+        delta : bool
+            Only for use with ``lin``. Whether to plot the HU delta or actual values.
+        """
+        fig = self.plot_analyzed_subimage(subimage, delta=delta, show=False)
+        if fig:  # no fig if we plot low contrast
+            plt.savefig(filename, **kwargs)
+            if isinstance(filename, str):
+                print(f"CatPhan subimage figure saved to {osp.abspath(filename)}")
+            return fig
+
+    def _results(self) -> None:
+        """Helper function to spit out values that will be tested."""
+        print(self.results())
+        print(f"Phantom roll: {self.catphan_roll}")
+        print(f"Origin slice: {self.origin_slice}")
+        mtfs = {}
+        for mtf in (95, 90, 80, 50, 30):
+            mtfval = self.ctp528.mtf.relative_resolution(mtf)
+            mtfs[mtf] = mtfval
+        print(f"MTFs: {mtfs}")
+
+    def localize(self) -> None:
+        """Find the slice number of the catphan's HU linearity module and roll angle"""
+        self._phantom_center_func = self.find_phantom_axis()
+        self.origin_slice = self.find_origin_slice()
+        self.catphan_roll = self.find_phantom_roll()
+        self.origin_slice = self.refine_origin_slice(
+            initial_slice_num=self.origin_slice
+        )
+        # now that we have the origin slice, ensure we have scanned all linked modules
+        if not self._ensure_physical_scan_extent():
+            raise ValueError(
+                "The physical scan extent does not match the module configuration. "
+                "This means not all modules were included in the scan. Rescan the phantom to include all"
+                "relevant modules, or remove modules from the analysis."
+            )
+
+    def _module_offsets(self) -> list[float]:
+        """A list of the module offsets. Used to confirm scan extent"""
+        absolute_origin_position = self.dicom_stack[self.origin_slice].z_position
+        return [
+            absolute_origin_position + config["offset"]
+            for config in self.modules.values()
+        ]
+
+    def _ensure_physical_scan_extent(self) -> bool:
+        """Ensure that all the modules of the phantom have been scanned. If a CBCT isn't
+        positioned correctly, some modules might not be included.
+
+        It appears there can be rounding errors between the DICOM tag and the actual slice position. See RAM-2897.
+        """
+        z_positions = [z_position(m) for m in self.dicom_stack.metadatas]
+        min_scan_extent_slice = round(min(z_positions), 1)
+        max_scan_extent_slice = round(max(z_positions), 1)
+        min_config_extent_slice = round(min(self._module_offsets()), 1)
+        max_config_extent_slice = round(max(self._module_offsets()), 1)
+        return (min_config_extent_slice >= min_scan_extent_slice) and (
+            max_config_extent_slice <= max_scan_extent_slice
+        )
+
+    def find_phantom_axis(self) -> (Callable, Callable):
+        """We fit all the center locations of the phantom across all slices to a 1D poly function instead of finding them individually for robustness.
+
+        Normally, each slice would be evaluated individually, but the RadMachine jig gets in the way of
+        detecting the HU module (). To work around that in a backwards-compatible way we instead
+        look at all the slices and if the phantom was detected, capture the phantom center.
+        ALL the centers are then fitted to a 1D poly function and passed to the individual slices.
+        This way, even if one slice is messed up (such as because of the phantom jig), the poly function
+        is robust to give the real center based on all the other properly-located positions on the other slices.
+        """
+        z = []
+        center_x = []
+        center_y = []
+        for idx, img in enumerate(self.dicom_stack):
+            slice = Slice(
+                self,
+                slice_num=idx,
+                clear_borders=self.clear_borders,
+                original_image=img,
+            )
+            if slice.is_phantom_in_view():
+                roi = slice.phantom_roi
+                z.append(idx)
+                center_y.append(roi.centroid[0])
+                center_x.append(roi.centroid[1])
+        # clip to exclude any crazy values
+        zs = np.array(z)
+        center_xs = np.array(center_x)
+        center_ys = np.array(center_y)
+        # gives an absolute and relative range so tight ranges are all included
+        # but extreme values are excluded. Sometimes the range is very tight
+        # and thus percentiles are not a sure thing
+        x_idxs = np.argwhere(
+            np.isclose(np.median(center_xs), center_xs, atol=3, rtol=0.01)
+        )
+        y_idxs = np.argwhere(
+            np.isclose(np.median(center_ys), center_ys, atol=3, rtol=0.01)
+        )
+        common_idxs = np.intersect1d(x_idxs, y_idxs)
+        # fit to 1D polynomials; inspiration: https://stackoverflow.com/a/45351484
+        fit_zx = np.poly1d(np.polyfit(zs[common_idxs], center_xs[common_idxs], deg=1))
+        fit_zy = np.poly1d(np.polyfit(zs[common_idxs], center_ys[common_idxs], deg=1))
+        return fit_zx, fit_zy
+
+    @property
+    def mm_per_pixel(self) -> float:
+        """The millimeters per pixel of the DICOM images."""
+        return self.dicom_stack.metadata.PixelSpacing[0]
+
+    def find_origin_slice(self) -> int:
+        """Using a brute force search of the images, find the median HU linearity slice.
+
+        This method walks through all the images and takes a collapsed circle profile where the HU
+        linearity ROIs are. If the profile contains both low (<800) and high (>800) HU values and most values are the same
+        (i.e. it's not an artifact), then
+        it can be assumed it is an HU linearity slice. The median of all applicable slices is the
+        center of the HU slice.
+
+        Returns
+        -------
+        int
+            The middle slice of the HU linearity module.
+        """
+        hu_slices = []
+        for image_number in range(0, self.num_images, 2):
+            slice = Slice(
+                self, image_number, combine=False, clear_borders=self.clear_borders
+            )
+            # print(image_number)
+            # slice.image.plot()
+            if slice.is_phantom_in_view():
+                circle_prof = CollapsedCircleProfile(
+                    slice.phan_center,
+                    radius=self.localization_radius / self.mm_per_pixel,
+                    image_array=slice.image,
+                    width_ratio=0.05,
+                    num_profiles=5,
+                )
+                prof = circle_prof.values
+                # determine if the profile contains both low and high values and that most values are the same
+                low_end, high_end = np.percentile(prof, [2, 98])
+                median = np.median(prof)
+                middle_variation = np.percentile(prof, 80) - np.percentile(prof, 20)
+                variation_limit = max(
+                    100, self.dicom_stack.metadata.SliceThickness * -100 + 300
+                )
+                if (
+                    (low_end < median - self.hu_origin_slice_variance)
+                    and (high_end > median + self.hu_origin_slice_variance)
+                    and (middle_variation < variation_limit)
+                ):
+                    hu_slices.append(image_number)
+
+        if not hu_slices:
+            raise ValueError(
+                "No slices were found that resembled the HU linearity module"
+            )
+        hu_slices = np.array(hu_slices)
+        c = int(round(float(np.median(hu_slices))))
+        ln = len(hu_slices)
+        # drop slices that are way far from median
+        hu_slices = hu_slices[((c + ln / 2) >= hu_slices) & (hu_slices >= (c - ln / 2))]
+        center_hu_slice = int(round(float(np.median(hu_slices))))
+        if self._is_within_image_extent(center_hu_slice):
+            return center_hu_slice
+
+    def refine_origin_slice(self, initial_slice_num: int) -> int:
+        """Apply a refinement to the origin slice. This was added to handle
+        the catphan 604 at least due to variations in the length of the HU plugs."""
+        return initial_slice_num
+
+    def _is_right_area(self, region: RegionProperties):
+        thresh = np.pi * ((self.air_bubble_radius_mm / self.mm_per_pixel) ** 2)
+        return thresh * 2 > region.filled_area > thresh / 2
+
+    def _is_right_eccentricity(self, region: RegionProperties):
+        return region.eccentricity < 0.5
+
+    def find_phantom_roll(self, func: Callable | None = None) -> float:
+        """Determine the "roll" of the phantom.
+
+        This algorithm uses the two air bubbles in the HU slice and the resulting angle between them.
+
+        Parameters
+        ----------
+        func
+            A callable to sort the air ROIs.
+
+        Returns
+        -------
+        float : the angle of the phantom in **degrees**.
+        """
+        # get edges and make ROIs from it
+        slice = Slice(self, self.origin_slice, clear_borders=self.clear_borders)
+        larr, regions, _ = get_regions(slice)
+        # find appropriate ROIs and grab the two most centrally positioned ones
+        hu_bubbles = [
+            r
+            for r in regions
+            if (self._is_right_area(r) and self._is_right_eccentricity(r))
+        ]
+        func = func or (lambda x: abs(x.centroid[1] - slice.phan_center.x))
+        central_bubbles = sorted(hu_bubbles, key=func)[:2]
+        sorted_bubbles = sorted(
+            central_bubbles, key=lambda x: x.centroid[0]
+        )  # top, bottom
+        y_dist = sorted_bubbles[1].centroid[0] - sorted_bubbles[0].centroid[0]
+        x_dist = sorted_bubbles[1].centroid[1] - sorted_bubbles[0].centroid[1]
+        phan_roll = np.arctan2(y_dist, x_dist)
+        anglroll = np.rad2deg(phan_roll) - 90
+        return anglroll
+
+    @property
+    def num_images(self) -> int:
+        """The number of images loaded."""
+        return len(self.dicom_stack)
+
+    def _is_within_image_extent(self, image_num: int) -> bool:
+        """Determine if the image number is beyond the edges of the images (negative or past last image)."""
+        if self.num_images - 1 > image_num > 1:
+            return True
+        else:
+            raise ValueError(
+                "The determined image number is beyond the image extent. Either the entire dataset "
+                "wasn't loaded or the entire phantom wasn't scanned."
+            )
+
+    @property
+    def catphan_size(self) -> float:
+        """The expected size of the phantom in pixels, based on a 20cm wide phantom."""
+        phan_area = np.pi * (self.catphan_radius_mm**2)
+        return phan_area / (self.mm_per_pixel**2)
+
+    def publish_pdf(
+        self,
+        filename: str | Path,
+        notes: str | None = None,
+        open_file: bool = False,
+        metadata: dict | None = None,
+        logo: Path | str | None = None,
+    ) -> None:
+        """Publish (print) a PDF containing the analysis and quantitative results.
+
+        Parameters
+        ----------
+        filename : (str, file-like object}
+            The file to write the results to.
+        notes : str, list of strings
+            Text; if str, prints single line.
+            If list of strings, each list item is printed on its own line.
+        open_file : bool
+            Whether to open the file using the default program after creation.
+        metadata : dict
+            Extra data to be passed and shown in the PDF. The key and value will be shown with a colon.
+            E.g. passing {'Author': 'James', 'Unit': 'TrueBeam'} would result in text in the PDF like:
+            --------------
+            Author: James
+            Unit: TrueBeam
+            --------------
+        logo: Path, str
+            A custom logo to use in the PDF report. If nothing is passed, the default pylinac logo is used.
+        """
+        analysis_title = f"CatPhan {self._model} Analysis"
+        module_images = [("hu", "lin")]
+        if self._has_module(CTP528CP504):
+            module_images.append(("sp", "mtf"))
+        if self._has_module(CTP486):
+            module_images.append(("un", "prof"))
+        if self._has_module(CTP515):
+            module_images.append(("lc", None))
+        module_images.append(("side", None))
+
+        self._publish_pdf(
+            filename,
+            metadata,
+            notes,
+            analysis_title,
+            [*self.results(as_list=True), ""],
+            module_images,
+            logo,
+        )
+        if open_file:
+            webbrowser.open(filename)
+
+    def _publish_pdf(
+        self,
+        filename: str,
+        metadata: dict | None,
+        notes: str,
+        analysis_title: str,
+        texts: Sequence[str],
+        imgs: Sequence[tuple[str, str]],
+        logo: Path | str | None = None,
+    ):
+        canvas = pdf.PylinacCanvas(
+            filename, page_title=analysis_title, metadata=metadata, logo=logo
+        )
+        if notes is not None:
+            canvas.add_text(text="Notes:", location=(1, 4.5), font_size=14)
+            canvas.add_text(text=notes, location=(1, 4))
+
+        for page, ((img1, img2), text) in enumerate(zip(imgs, texts)):
+            for img, offset in zip((img1, img2), (12, 2)):
+                if img is not None:
+                    data = io.BytesIO()
+                    self.save_analyzed_subimage(data, img)
+                    canvas.add_image(data, location=(4, offset), dimensions=(15, 10))
+            canvas.add_text(text=text, location=(1.5, 23))
+            canvas.add_new_page()
+        canvas.finish()
+
+    def _zip_images(self) -> None:
+        """Compress the raw images into a ZIP archive and remove the uncompressed images."""
+        zip_name = rf'{osp.dirname(self.dicom_stack[0].path)}\CBCT - {self.dicom_stack[0].date_created(format="%A, %I-%M-%S, %B %d, %Y")}.zip'
+        with zipfile.ZipFile(zip_name, "w", compression=zipfile.ZIP_DEFLATED) as zfile:
+            for img in self.dicom_stack:
+                zfile.write(img.path, arcname=osp.basename(img.path))
+        for img in self.dicom_stack:
+            try:
+                os.remove(img.path)
+            except Exception:
+                pass
+
+    def plot_side_view(self, axis: Axes) -> None:
+        """Plot a view of the scan from the side with lines showing detected module positions"""
+        side_array = self.dicom_stack.side_view(axis=1)
+        axis.set_yticks([])
+        axis.set_title("Side View")
+        axis.imshow(side_array, aspect="auto", cmap="gray", interpolation="none")
+        for module in self._detected_modules():
+            axis.axvline(module.slice_num)
+
+    def _detected_modules(self) -> list[CatPhanModule]:
+        """A list of the modules detected. Unlike _get_module, this returns the instances"""
+        modules = [self.ctp404]
+        if self._has_module(CTP515):
+            modules.append(self.ctp515)
+        if self._has_module(CTP486):
+            modules.append(self.ctp486)
+        if self._has_module(CTP528CP504):
+            modules.append(self.ctp528)
+        return modules
+
+    def analyze(
+        self,
+        hu_tolerance: int | float = 40,
+        scaling_tolerance: int | float = 1,
+        thickness_tolerance: int | float = 0.2,
+        low_contrast_tolerance: int | float = 1,
+        cnr_threshold: int | float = 15,
+        zip_after: bool = False,
+        contrast_method: str = Contrast.MICHELSON,
+        visibility_threshold: float = 0.15,
+        thickness_slice_straddle: str | int = "auto",
+        expected_hu_values: dict[str, int | float] | None = None,
+    ):
+        """Single-method full analysis of CBCT DICOM files.
+
+        Parameters
+        ----------
+        hu_tolerance : int
+            The HU tolerance value for both HU uniformity and linearity.
+        scaling_tolerance : float, int
+            The scaling tolerance in mm of the geometric nodes on the HU linearity slice (CTP404 module).
+        thickness_tolerance : float, int
+            The tolerance of the thickness calculation in mm, based on the wire ramps in the CTP404 module.
+
+            .. warning:: Thickness accuracy degrades with image noise; i.e. low mAs images are less accurate.
+
+        low_contrast_tolerance : int
+            The number of low-contrast bubbles needed to be "seen" to pass.
+        cnr_threshold : float, int
+            The threshold for "detecting" low-contrast image. See RTD for calculation info.
+
+            .. deprecated:: 3.0
+
+                Use visibility parameter instead.
+
+        zip_after : bool
+            If the CT images were not compressed before analysis and this is set to true, pylinac will compress
+            the analyzed images into a ZIP archive.
+        contrast_method
+            The contrast equation to use. See :ref:`low_contrast_topic`.
+        visibility_threshold
+            The threshold for detecting low-contrast ROIs. Use instead of ``cnr_threshold``. Follows the Rose equation.
+            See :ref:`visibility`.
+        thickness_slice_straddle
+            The number of extra slices **on each side** of the HU module slice to use for slice thickness determination.
+            The rationale is that for thin slices the ramp FWHM can be very noisy. I.e. a 1mm slice might have a 100%
+            variation with a low-mAs protocol. To account for this, slice thicknesses < 3.5mm have 1 slice added
+            on either side of the HU module (so 3 total slices) and then averaged. The default is 'auto',
+            which follows the above logic. Set to an integer to explicitly use a certain amount of padding. Typical
+            values are 0, 1, and 2.
+
+            .. warning:: This is the padding **on either side**. So a value of 1 => 3 slices, 2 => 5 slices, 3 => 7 slices, etc.
+
+        expected_hu_values
+            An optional dictionary of the expected HU values for the HU linearity module. The keys are the ROI names and the values
+            are the expected HU values. If a key is not present or the parameter is None, the default values will be used.
+
+        """
+        self.localize()
+        ctp404, offset = self._get_module(CTP404CP504, raise_empty=True)
+        self.ctp404 = ctp404(
+            self,
+            offset=offset,
+            hu_tolerance=hu_tolerance,
+            thickness_tolerance=thickness_tolerance,
+            scaling_tolerance=scaling_tolerance,
+            clear_borders=self.clear_borders,
+            thickness_slice_straddle=thickness_slice_straddle,
+            expected_hu_values=expected_hu_values,
+        )
+        if self._has_module(CTP486):
+            ctp486, offset = self._get_module(CTP486)
+            self.ctp486 = ctp486(
+                self,
+                offset=offset,
+                tolerance=hu_tolerance,
+                clear_borders=self.clear_borders,
+            )
+        if self._has_module(CTP528CP504):
+            ctp528, offset = self._get_module(CTP528CP504)
+            self.ctp528 = ctp528(
+                self, offset=offset, tolerance=None, clear_borders=self.clear_borders
+            )
+        if self._has_module(CTP515):
+            ctp515, offset = self._get_module(CTP515)
+            self.ctp515 = ctp515(
+                self,
+                tolerance=low_contrast_tolerance,
+                cnr_threshold=cnr_threshold,
+                offset=offset,
+                contrast_method=contrast_method,
+                visibility_threshold=visibility_threshold,
+                clear_borders=self.clear_borders,
+            )
+        if zip_after and not self.was_from_zip:
+            self._zip_images()
+
+    def _has_module(self, module_of_interest: type[CatPhanModule]) -> bool:
+        return any(
+            issubclass(module, module_of_interest) for module in self.modules.keys()
+        )
+
+    def _get_module(
+        self, module_of_interest: type[CatPhanModule], raise_empty: bool = False
+    ) -> tuple[type[CatPhanModule], int]:
+        """Grab the module that is, or is a subclass of, the module of interest. This allows users to subclass a CTP module and pass that in."""
+        for module, values in self.modules.items():
+            if issubclass(module, module_of_interest):
+                return module, values.get("offset")
+        if raise_empty:
+            raise ValueError(
+                f"Tried to find the {module_of_interest} or a subclass of it. Did you override `modules` and not pass this module in?"
+            )
+
+    def results(self, as_list: bool = False) -> str | list[list[str]]:
+        """Return the results of the analysis as a string. Use with print().
+
+        Parameters
+        ----------
+        as_list : bool
+            Whether to return as a list of list of strings vs single string. Pretty much for internal usage.
+        """
+        results = []
+        result = [
+            f" - CBCT/CT {self._model} QA Test - ",
+            " - CTP 404 Results - ",
+            f"HU Linearity tolerance: {self.ctp404.hu_tolerance}",
+            "HU Linearity ROIs:",
+            # wrap so it doesn't fall off the page in PDFs
+            *textwrap.wrap(self.ctp404.roi_vals_as_str, width=50),
+            f"HU Passed?: {self.ctp404.passed_hu}",
+            f"Low contrast visibility: {self.ctp404.lcv:2.2f}",
+            f"Geometric Line Average (mm): {self.ctp404.avg_line_length:2.2f}",
+            f"Geometry Passed?: {self.ctp404.passed_geometry}",
+            f"Measured Slice Thickness (mm): {self.ctp404.meas_slice_thickness:2.3f}",
+            f"Slice Thickness Passed? {self.ctp404.passed_thickness}",
+        ]
+        results.append(result)
+        if self._has_module(CTP528CP504):
+            ctp528_result = [
+                " - CTP528 Results - ",
+                f"MTF 80% (lp/mm): {self.ctp528.mtf.relative_resolution(80):2.2f}",
+                f"MTF 50% (lp/mm): {self.ctp528.mtf.relative_resolution(50):2.2f}",
+                f"MTF 30% (lp/mm): {self.ctp528.mtf.relative_resolution(30):2.2f}",
+            ]
+            results.append(ctp528_result)
+        if self._has_module(CTP486):
+            ctp486_result = [
+                " - CTP486 Results - ",
+                f"Uniformity tolerance: {self.ctp486.tolerance}",
+                f"Uniformity ROIs: {self.ctp486.roi_vals_as_str}",
+                f"Uniformity index: {self.ctp486.uniformity_index:2.3f}",
+                f"Integral non-uniformity: {self.ctp486.integral_non_uniformity:2.4f}",
+                f"Uniformity Passed?: {self.ctp486.overall_passed}",
+                f"Max Noise Power frequency: {self.ctp486.max_noise_power_frequency}",
+                f"Average Noise Power: {self.ctp486.avg_noise_power}",
+            ]
+            results.append(ctp486_result)
+        if self._has_module(CTP515):
+            ctp515_result = [
+                " - CTP515 Results - ",
+                f"CNR threshold: {self.ctp515.cnr_threshold}",
+                f'Low contrast ROIs "seen": {self.ctp515.rois_visible}',
+            ]
+            results.append(ctp515_result)
+        if not as_list:
+            result = "\n".join(itertools.chain(*results))
+        else:
+            result = results
+        return result
+
+    def _generate_results_data(self) -> CatphanResult:
+        """Present the results data and metadata as a dataclass or dict.
+        The default return type is a dataclass."""
+        ctp404_result = CTP404Result(
+            offset=self.ctp404._offset,
+            low_contrast_visibility=self.ctp404.lcv,
+            thickness_passed=self.ctp404.passed_thickness,
+            measured_slice_thickness_mm=self.ctp404.meas_slice_thickness,
+            thickness_num_slices_combined=self.ctp404.num_slices + self.ctp404.pad,
+            geometry_passed=self.ctp404.passed_geometry,
+            avg_line_distance_mm=self.ctp404.avg_line_length,
+            line_distances_mm=[
+                line.length_mm for name, line in self.ctp404.lines.items()
+            ],
+            hu_linearity_passed=self.ctp404.passed_hu,
+            hu_tolerance=self.ctp404.hu_tolerance,
+            hu_rois=rois_to_results(self.ctp404.rois),
+        )
+        data = CatphanResult(
+            catphan_model=self._model,
+            catphan_roll_deg=self.catphan_roll,
+            origin_slice=self.origin_slice,
+            num_images=self.num_images,
+            ctp404=ctp404_result,
+        )
+
+        # CTP 486 Uniformity stuff
+        if self._has_module(CTP486):
+            data.ctp486 = CTP486Result(
+                passed=self.ctp486.overall_passed,
+                uniformity_index=self.ctp486.uniformity_index,
+                integral_non_uniformity=self.ctp486.integral_non_uniformity,
+                rois=rois_to_results(self.ctp486.rois),
+                nps_avg_power=self.ctp486.avg_noise_power,
+                nps_max_freq=self.ctp486.max_noise_power_frequency,
+            )
+
+        # CTP 528 stuff
+        if self._has_module(CTP528CP504):
+            data.ctp528 = CTP528Result(
+                roi_settings=self.ctp528.roi_settings,
+                start_angle_radians=self.ctp528.start_angle,
+                mtf_lp_mm={
+                    p: self.ctp528.mtf.relative_resolution(p) for p in range(10, 91, 10)
+                },
+            )
+
+        # CTP 515 stuff
+        if self._has_module(CTP515):
+            data.ctp515 = CTP515Result(
+                cnr_threshold=self.ctp515.cnr_threshold,
+                num_rois_seen=self.ctp515.rois_visible,
+                roi_settings=self.ctp515.roi_settings,
+                roi_results={
+                    key: roi.as_dict() for key, roi in self.ctp515.rois.items()
+                },
+            )
+        return data
+
+
+class CatPhan503(CatPhanBase):
+    """A class for loading and analyzing CT DICOM files of a CatPhan 503.
+    Analyzes: Uniformity (CTP486), High-Contrast Spatial Resolution (CTP528), Image Scaling & HU Linearity (CTP404).
+    """
+
+    _demo_url = "CatPhan503.zip"
+    _model = "503"
+    catphan_radius_mm = 97
+    modules = {
+        CTP404CP503: {"offset": 0},
+        CTP486: {"offset": -110},
+        CTP528CP503: {"offset": -30},
+    }
+
+    @staticmethod
+    def run_demo(show: bool = True):
+        """Run the CBCT demo using high-quality head protocol images."""
+        cbct = CatPhan503.from_demo_images()
+        cbct.analyze()
+        print(cbct.results())
+        cbct.plot_analyzed_image(show)
+
+
+class CatPhan504(CatPhanBase):
+    """A class for loading and analyzing CT DICOM files of a CatPhan 504. Can be from a CBCT or CT scanner
+    Analyzes: Uniformity (CTP486), High-Contrast Spatial Resolution (CTP528),
+    Image Scaling & HU Linearity (CTP404), and Low contrast (CTP515).
+    """
+
+    _demo_url = "CatPhan504.zip"
+    _model = "504"
+    catphan_radius_mm = 101
+    modules = {
+        CTP404CP504: {"offset": 0},
+        CTP486: {"offset": -65},
+        CTP528CP504: {"offset": 30},
+        CTP515: {"offset": -30},
+    }
+
+    @staticmethod
+    def run_demo(show: bool = True):
+        """Run the CBCT demo using high-quality head protocol images."""
+        cbct = CatPhan504.from_demo_images()
+        cbct.analyze()
+        print(cbct.results())
+        cbct.plot_analyzed_image(show)
+
+
+class CatPhan604(CatPhanBase):
+    """A class for loading and analyzing CT DICOM files of a CatPhan 604. Can be from a CBCT or CT scanner
+    Analyzes: Uniformity (CTP486), High-Contrast Spatial Resolution (CTP528),
+    Image Scaling & HU Linearity (CTP404), and Low contrast (CTP515).
+    """
+
+    _demo_url = "CatPhan604.zip"
+    _model = "604"
+    catphan_radius_mm = 101
+    modules = {
+        CTP404CP604: {"offset": 0},
+        CTP486: {"offset": -80},
+        CTP528CP604: {"offset": 40},
+        CTP515: {"offset": -40},
+    }
+
+    @staticmethod
+    def run_demo(show: bool = True):
+        """Run the CBCT demo using high-quality head protocol images."""
+        cbct = CatPhan604.from_demo_images()
+        cbct.analyze()
+        print(cbct.results())
+        cbct.plot_analyzed_image(show)
+
+    def refine_origin_slice(self, initial_slice_num: int) -> int:
+        """The HU plugs are longer than the 'wire section'. This applies a refinement to find the
+        slice that has the least angle between the centers of the left and right wires.
+
+        Starting with the initial slice, go +/- 5 slices to find the slice with the least angle
+        between the left and right wires.
+
+        This suffers from a weakness that the roll is not yet determined.
+        This will thus return the slice that has the least ABSOLUTE
+        roll. If the phantom has an inherent roll, this will not be detected and may be off by a slice or so.
+        Given the angle of the wire, the error would be small and likely only 1-2 slices max.
+        """
+        angles = []
+        # make a CTP module for the purpose of easily extracting the thickness ROIs
+        ctp404, offset = self._get_module(CTP404CP604, raise_empty=True)
+        # we don't want to set up our other ROIs (they sometimes fail) so we temporarily override the method
+        original_setup = ctp404._setup_rois
+        ctp404._setup_rois = lambda x: x
+        ctp = ctp404(
+            self,
+            offset=offset,
+            clear_borders=self.clear_borders,
+            hu_tolerance=0,
+            scaling_tolerance=0,
+            thickness_tolerance=0,
+        )
+        # we have to reset the method after we're done for future calls
+        ctp404._setup_rois = original_setup
+        for slice_num in range(initial_slice_num - 5, initial_slice_num + 5):
+            slice = Slice(self, slice_num, clear_borders=self.clear_borders)
+            # make a slice and add the wire ROIs to it.
+            troi = {}
+            for name, setting in ctp.thickness_roi_settings.items():
+                troi[name] = ThicknessROI(
+                    slice.image,
+                    setting["width_pixels"],
+                    setting["height_pixels"],
+                    setting["angle_corrected"],
+                    setting["distance_pixels"],
+                    slice.phan_center,
+                )
+            # now find the angle between the left and right and top and bottom wires via the long profile
+            left_wire = troi["Left"].long_profile.center_idx
+            right_wire = troi["Right"].long_profile.center_idx
+            h_angle = abs(left_wire - right_wire)
+            top_wire = troi["Top"].long_profile.center_idx
+            bottom_wire = troi["Bottom"].long_profile.center_idx
+            v_angle = abs(top_wire - bottom_wire)
+            angle = (h_angle + v_angle) / 2
+
+            angles.append(
+                {
+                    "slice": slice_num,
+                    "angle": angle,
+                    "left width": troi["Left"].long_profile.field_width_px,
+                    "right width": troi["Right"].long_profile.field_width_px,
+                }
+            )
+
+        # some slices might not include the wire
+        # we need to drop those; we do so by dropping pairs that have a field width well below the median
+        median_width_l = np.median([angle["left width"] for angle in angles])
+        median_width_r = np.median([angle["right width"] for angle in angles])
+        median_width = (median_width_l + median_width_r) / 2
+        for angle_set in angles.copy():
+            if (
+                angle_set["left width"] < median_width * 0.7
+                or angle_set["right width"] < median_width * 0.7
+            ):
+                angles.remove(angle_set)
+
+        # now find the slice with the least angle, accounting for the phantom roll
+        m_slice_num = np.argsort([a["angle"] - self.catphan_roll for a in angles])
+        refined_slice = angles[m_slice_num[0]]["slice"]
+        return refined_slice
+
+
+class CatPhan600(CatPhanBase):
+    """A class for loading and analyzing CT DICOM files of a CatPhan 600.
+    Analyzes: Uniformity (CTP486), High-Contrast Spatial Resolution (CTP528),
+    Image Scaling & HU Linearity (CTP404), and Low contrast (CTP515).
+    """
+
+    _demo_url = "CatPhan600.zip"
+    _model = "600"
+    catphan_radius_mm = 101
+    modules = {
+        CTP404CP600: {"offset": 0},
+        CTP486: {"offset": -160},
+        CTP515CP600: {"offset": -110},
+        CTP528CP600: {"offset": -70},
+    }
+
+    @staticmethod
+    def run_demo(show: bool = True):
+        """Run the CatPhan 600 demo."""
+        cbct = CatPhan600.from_demo_images()
+        cbct.analyze()
+        print(cbct.results())
+        cbct.plot_analyzed_image(show)
+
+    def find_phantom_roll(self, func: Callable | None = None) -> float:
+        """With the CatPhan 600, we have to consider that the top air ROI
+        has a water vial in it (see pg 12 of the manual). If so, the top air ROI won't be detected.
+        Rather, the default algorithm will find the bottom air ROI and teflon to the left.
+        It may also find the top air ROI if the water vial isn't there.
+        We use the below lambda to select the bottom air and teflon ROIs consistently.
+        These two ROIs are at 75 degrees from cardinal. We thus offset the default outcome by 75.
+        """
+        angle = super().find_phantom_roll(lambda x: -x.centroid[0])
+        return angle + 75
+
+
+def get_regions(
+    slice_or_arr: Slice | np.array,
+    fill_holes: bool = False,
+    clear_borders: bool = True,
+    threshold: str = "otsu",
+) -> tuple[np.array, list, int]:
+    """Get the skimage regions of a black & white image."""
+    if threshold == "otsu":
+        thresmeth = filters.threshold_otsu
+    elif threshold == "mean":
+        thresmeth = np.mean
+    if isinstance(slice_or_arr, Slice):
+        edges = filters.scharr(slice_or_arr.image.array.astype(float))
+        center = slice_or_arr.image.center
+    elif isinstance(slice_or_arr, np.ndarray):
+        edges = filters.scharr(slice_or_arr.astype(float))
+        center = (int(edges.shape[1] / 2), int(edges.shape[0] / 2))
+    edges = filters.gaussian(edges, sigma=1)
+    if isinstance(slice_or_arr, Slice):
+        radius = 110 / slice_or_arr.mm_per_pixel
+        rr, cc = draw.disk(
+            center=(center.y, center.x), radius=radius, shape=edges.shape
+        )
+        thres = thresmeth(edges[rr, cc])
+    else:
+        thres = thresmeth(edges)
+    bw = edges > thres
+    if clear_borders:
+        bw = segmentation.clear_border(bw, buffer_size=int(max(bw.shape) / 50))
+    if fill_holes:
+        bw = ndimage.binary_fill_holes(bw)
+    labeled_arr, num_roi = measure.label(bw, return_num=True)
+    regionprops = measure.regionprops(labeled_arr, edges)
+    return labeled_arr, regionprops, num_roi
+
+
+def combine_surrounding_slices(
+    dicomstack: DicomImageStack,
+    nominal_slice_num: int,
+    slices_plusminus: int = 1,
+    mode: str = "mean",
+) -> np.array:
+    """Return an array that is the combination of a given slice and a number of slices surrounding it.
+
+    Parameters
+    ----------
+    dicomstack : `~pylinac.core.image.DicomImageStack`
+        The CBCT DICOM stack.
+    nominal_slice_num : int
+        The slice of interest (along 3rd dim).
+    slices_plusminus: int
+        How many slices plus and minus to combine (also along 3rd dim).
+    mode : {'mean', 'median', 'max}
+        Specifies the method of combination.
+
+    Returns
+    -------
+    combined_array : numpy.array
+        The combined array of the DICOM stack slices.
+    """
+    slices = range(
+        nominal_slice_num - slices_plusminus, nominal_slice_num + slices_plusminus + 1
+    )
+    arrays = tuple(dicomstack[s].array for s in slices)
+    array_stack = np.dstack(arrays)
+    if mode == "mean":
+        combined_array = np.mean(array_stack, 2)
+    elif mode == "median":
+        combined_array = np.median(array_stack, 2)
+    else:
+        combined_array = np.max(array_stack, 2)
+    return combined_array
+
+
+def rois_to_results(dict_mapping: dict[str, DiskROI]) -> dict[str, ROIResult]:
+    """Converts a dict of HUDiskROIs to a dict of ROIResults. This is for dumping to simple data formats for results_data and RadMachine"""
+    flat_dict = {}
+    for name, roi in dict_mapping.items():
+        flat_dict[name] = ROIResult(
+            name=name,
+            value=roi.pixel_value,
+            stdev=roi.std,
+            difference=getattr(roi, "value_diff", None),
+            nominal_value=getattr(roi, "nominal_val", None),
+            passed=getattr(roi, "passed", None),
+        )
+    return flat_dict
```

### Comparing `manteia_qa_pylinac-1.0.0/pylinac/dlg.py` & `manteia_qa_pylinac-1.1.0/pylinac/dlg.py`

 * *Ordering differences only*

 * *Files 21% similar despite different names*

```diff
@@ -1,127 +1,127 @@
-from __future__ import annotations
-
-from math import ceil, floor
-from typing import Sequence
-
-import numpy as np
-from matplotlib import pyplot as plt
-from scipy.stats import stats
-
-from .core import image
-from .core.array_utils import invert
-from .core.profile import find_peaks
-from .picketfence import MLC
-
-
-class DLG:
-    """Analyze a machine's dosimetric leaf gap by looking at profiles with various amounts of overlap. This is NOT the
-    same procedure as the sweeping gaps as provided by Varian, although the determined value should be similar.
-    """
-
-    def __init__(self, path):
-        self.image = image.LinacDicomImage(path)
-        self.measured_dlg: float = -np.inf
-        self.measured_dlg_per_leaf: list = []
-        self.planned_dlg_per_leaf: list = []
-        self._lin_fit = None
-
-    def analyze(
-        self,
-        gaps: Sequence,
-        mlc: MLC,
-        y_field_size: float = 100,
-        profile_width: int = 10,
-    ):
-        """Analyze an EPID image with varying MLC overlaps to determine the DLG.
-
-        Parameters
-        ----------
-        gaps
-            The gaps (i.e. overlap) of the leaves in mm.
-            These should typically be in descending order and also be negative. E.g. (-1, ..., -2.2).
-
-        mlc
-            The MLC type/arrangement. This lets us know where the leaf centers are to take a profile along.
-
-        y_field_size
-            The field size along the y-dimension (perpendicular to the leaf travel). This will determined which leaves
-            are associated with which gap.
-
-        profile_width
-            The width of the profile to take along the axes parallel to leaf motion. This should be a good bit wider
-            than the gap values. The default is reasonable and it is unlikely it needs tweaking.
-        """
-        measured_dlg_per_leaf = []
-        planned_dlg_per_leaf = []
-        mlc = mlc.value["arrangement"]
-        g = list(gaps)
-        g.sort()
-        profile_width_px = round(self.image.dpmm * profile_width)
-        mid_width = self.image.shape[1] / 2
-        mid_height = self.image.shape[0] / 2
-        for idx, center in enumerate(mlc.centers):
-            if -y_field_size / 2 < center < y_field_size / 2:
-                # get the pixel window area
-                center_px = center * self.image.dpmm
-                width_px = mlc.widths[idx] / 4 * self.image.dpmm
-                top = ceil(mid_height + center_px + width_px)
-                bottom = floor(mid_height + center_px - width_px)
-                # sample the window and take the average perpendicular to MLC motion
-                window = self.image[
-                    bottom:top,
-                    int(mid_width - profile_width_px) : int(
-                        mid_width + profile_width_px
-                    ),
-                ]
-                width = self._determine_measured_gap(window.mean(axis=0))
-                planned_dlg_per_leaf.append(
-                    self._get_dlg_offset(y_field_size, center, g)
-                )
-                measured_dlg_per_leaf.append(width)
-        # fit the data to a line and determine the DLG from the 0 intercept
-        lin_fit = stats.linregress(planned_dlg_per_leaf, measured_dlg_per_leaf)
-        dlg = lin_fit.intercept / lin_fit.slope
-        self._lin_fit = lin_fit
-        self.measured_dlg = dlg
-        self.planned_dlg_per_leaf = planned_dlg_per_leaf
-        self.measured_dlg_per_leaf = measured_dlg_per_leaf
-
-    def plot_dlg(self, show: bool = True) -> None:
-        """Plot the measured DLG values across the planned gaps"""
-        if not self.measured_dlg_per_leaf:
-            raise ValueError("Analyze the image before plotting with .analyze()")
-        plt.plot(self.planned_dlg_per_leaf, self.measured_dlg_per_leaf, "gx")
-        plt.plot(
-            self.planned_dlg_per_leaf,
-            self._lin_fit.intercept
-            + self._lin_fit.slope * np.array(self.planned_dlg_per_leaf),
-            "r",
-            label="fitted line",
-        )
-        plt.title(f"Measured DLG: {self.measured_dlg:2.3f}mm")
-        plt.grid()
-        if show:
-            plt.show()
-
-    @staticmethod
-    def _get_dlg_offset(field_size: float, leaf_center: float, dlgs: Sequence) -> float:
-        """Return the planned leaf overlap for a given leaf"""
-        roi_size = field_size / len(dlgs)
-        y_bounds = [field_size / 2 - idx * roi_size for idx in range(len(dlgs) + 1)]
-        for idx, gap in enumerate(dlgs):
-            upper_bound = y_bounds[idx]
-            lower_bound = y_bounds[idx + 1]
-            if lower_bound < leaf_center < upper_bound:
-                return gap
-
-    @staticmethod
-    def _determine_measured_gap(profile: np.ndarray) -> float:
-        """Return the measured gap based on profile height"""
-        mid_value = profile[int(len(profile) / 2)]
-        if mid_value < profile.mean():
-            profile = invert(profile)
-        _, props = find_peaks(profile, max_number=1)
-        if mid_value < profile.mean():
-            return -props["prominences"][0]
-        else:
-            return props["prominences"][0]
+from __future__ import annotations
+
+from math import ceil, floor
+from typing import Sequence
+
+import numpy as np
+from matplotlib import pyplot as plt
+from scipy.stats import stats
+
+from .core import image
+from .core.array_utils import invert
+from .core.profile import find_peaks
+from .picketfence import MLC
+
+
+class DLG:
+    """Analyze a machine's dosimetric leaf gap by looking at profiles with various amounts of overlap. This is NOT the
+    same procedure as the sweeping gaps as provided by Varian, although the determined value should be similar.
+    """
+
+    def __init__(self, path):
+        self.image = image.LinacDicomImage(path)
+        self.measured_dlg: float = -np.inf
+        self.measured_dlg_per_leaf: list = []
+        self.planned_dlg_per_leaf: list = []
+        self._lin_fit = None
+
+    def analyze(
+        self,
+        gaps: Sequence,
+        mlc: MLC,
+        y_field_size: float = 100,
+        profile_width: int = 10,
+    ):
+        """Analyze an EPID image with varying MLC overlaps to determine the DLG.
+
+        Parameters
+        ----------
+        gaps
+            The gaps (i.e. overlap) of the leaves in mm.
+            These should typically be in descending order and also be negative. E.g. (-1, ..., -2.2).
+
+        mlc
+            The MLC type/arrangement. This lets us know where the leaf centers are to take a profile along.
+
+        y_field_size
+            The field size along the y-dimension (perpendicular to the leaf travel). This will determined which leaves
+            are associated with which gap.
+
+        profile_width
+            The width of the profile to take along the axes parallel to leaf motion. This should be a good bit wider
+            than the gap values. The default is reasonable and it is unlikely it needs tweaking.
+        """
+        measured_dlg_per_leaf = []
+        planned_dlg_per_leaf = []
+        mlc = mlc.value["arrangement"]
+        g = list(gaps)
+        g.sort()
+        profile_width_px = round(self.image.dpmm * profile_width)
+        mid_width = self.image.shape[1] / 2
+        mid_height = self.image.shape[0] / 2
+        for idx, center in enumerate(mlc.centers):
+            if -y_field_size / 2 < center < y_field_size / 2:
+                # get the pixel window area
+                center_px = center * self.image.dpmm
+                width_px = mlc.widths[idx] / 4 * self.image.dpmm
+                top = ceil(mid_height + center_px + width_px)
+                bottom = floor(mid_height + center_px - width_px)
+                # sample the window and take the average perpendicular to MLC motion
+                window = self.image[
+                    bottom:top,
+                    int(mid_width - profile_width_px) : int(
+                        mid_width + profile_width_px
+                    ),
+                ]
+                width = self._determine_measured_gap(window.mean(axis=0))
+                planned_dlg_per_leaf.append(
+                    self._get_dlg_offset(y_field_size, center, g)
+                )
+                measured_dlg_per_leaf.append(width)
+        # fit the data to a line and determine the DLG from the 0 intercept
+        lin_fit = stats.linregress(planned_dlg_per_leaf, measured_dlg_per_leaf)
+        dlg = lin_fit.intercept / lin_fit.slope
+        self._lin_fit = lin_fit
+        self.measured_dlg = dlg
+        self.planned_dlg_per_leaf = planned_dlg_per_leaf
+        self.measured_dlg_per_leaf = measured_dlg_per_leaf
+
+    def plot_dlg(self, show: bool = True) -> None:
+        """Plot the measured DLG values across the planned gaps"""
+        if not self.measured_dlg_per_leaf:
+            raise ValueError("Analyze the image before plotting with .analyze()")
+        plt.plot(self.planned_dlg_per_leaf, self.measured_dlg_per_leaf, "gx")
+        plt.plot(
+            self.planned_dlg_per_leaf,
+            self._lin_fit.intercept
+            + self._lin_fit.slope * np.array(self.planned_dlg_per_leaf),
+            "r",
+            label="fitted line",
+        )
+        plt.title(f"Measured DLG: {self.measured_dlg:2.3f}mm")
+        plt.grid()
+        if show:
+            plt.show()
+
+    @staticmethod
+    def _get_dlg_offset(field_size: float, leaf_center: float, dlgs: Sequence) -> float:
+        """Return the planned leaf overlap for a given leaf"""
+        roi_size = field_size / len(dlgs)
+        y_bounds = [field_size / 2 - idx * roi_size for idx in range(len(dlgs) + 1)]
+        for idx, gap in enumerate(dlgs):
+            upper_bound = y_bounds[idx]
+            lower_bound = y_bounds[idx + 1]
+            if lower_bound < leaf_center < upper_bound:
+                return gap
+
+    @staticmethod
+    def _determine_measured_gap(profile: np.ndarray) -> float:
+        """Return the measured gap based on profile height"""
+        mid_value = profile[int(len(profile) / 2)]
+        if mid_value < profile.mean():
+            profile = invert(profile)
+        _, props = find_peaks(profile, max_number=1)
+        if mid_value < profile.mean():
+            return -props["prominences"][0]
+        else:
+            return props["prominences"][0]
```

### Comparing `manteia_qa_pylinac-1.0.0/pylinac/field_analysis.py` & `manteia_qa_pylinac-1.1.0/pylinac/field_analysis.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,1568 +1,1544 @@
-"""Module for performing analysis of images or 2D arrays for parameters such as flatness and symmetry."""
-from __future__ import annotations
-
-import dataclasses
-import io
-import os.path as osp
-import warnings
-import webbrowser
-from dataclasses import dataclass
-from enum import Enum
-from math import ceil, floor
-from pathlib import Path
-from typing import BinaryIO, Callable
-
-import matplotlib.pyplot as plt
-import numpy as np
-
-from . import Centering
-from .core import image, pdf
-from .core.exceptions import NotAnalyzed
-from .core.geometry import Point, Rectangle
-from .core.hill import Hill
-from .core.io import SNCProfiler, retrieve_demo_file
-from .core.profile import Edge, Interpolation, Normalization, SingleProfile
-from .core.roi import RectangleROI
-from .core.utilities import ResultBase, convert_to_enum
-from .settings import get_dicom_cmap
-
-
-def flatness_dose_difference(
-    profile: SingleProfile, in_field_ratio: float = 0.8, **kwargs
-) -> float:
-    """The Varian specification for calculating flatness. See :ref:`varian_protocol`."""
-    try:
-        dmax = profile.field_calculation(
-            in_field_ratio=in_field_ratio,
-            calculation="max",
-            slope_exclusion_ratio=kwargs.get("slope_exclusion_ratio", 0.2),
-        )
-        dmin = profile.field_calculation(
-            in_field_ratio=in_field_ratio,
-            calculation="min",
-            slope_exclusion_ratio=kwargs.get("slope_exclusion_ratio", 0.2),
-        )
-    except OSError:
-        raise ValueError(
-            "An error was encountered in the flatness calculation. The image is likely inverted. Try inverting the image before analysis with <instance>.image.invert()."
-        )
-    flatness = 100 * abs(dmax - dmin) / (dmax + dmin)
-    return flatness
-
-
-def flatness_dose_ratio(
-    profile: SingleProfile, in_field_ratio: float = 0.8, **kwargs
-) -> float:
-    """The Elekta specification for calculating flatness. See :ref:`elekta_protocol`."""
-    try:
-        dmax = profile.field_calculation(
-            in_field_ratio=in_field_ratio, calculation="max"
-        )
-        dmin = profile.field_calculation(
-            in_field_ratio=in_field_ratio, calculation="min"
-        )
-    except ValueError:
-        raise ValueError(
-            "An error was encountered in the flatness calculation. The image is likely inverted. Try inverting the image before analysis with <instance>.image.invert()."
-        )
-    flatness = 100 * (dmax / dmin)
-    return flatness
-
-
-def plot_flatness(instance, profile: SingleProfile, axis: plt.Axes) -> None:
-    """Plot flatness parameters. Applies to both flatness dose ratio and dose difference."""
-    data = profile.field_data(
-        in_field_ratio=instance._in_field_ratio,
-        slope_exclusion_ratio=instance._slope_exclusion_ratio,
-    )
-    axis.axhline(
-        np.max(data["field values"]), color="g", linestyle="-.", label="Flatness region"
-    )
-    axis.axhline(np.min(data["field values"]), color="g", linestyle="-.")
-
-
-def symmetry_point_difference(
-    profile: SingleProfile, in_field_ratio: float, **kwargs
-) -> float:
-    """Calculation of symmetry by way of point difference equidistant from the CAX. See :ref:`varian_protocol`.
-
-    A negative value means the right side is higher. A positive value means the left side is higher.
-    """
-    field = profile.field_data(
-        in_field_ratio=in_field_ratio,
-        slope_exclusion_ratio=kwargs.get("slope_exclusion_ratio", 0.2),
-    )
-    field_values = field["field values"]
-    cax_value = field["beam center value (@rounded)"]
-
-    def calc_sym(lt, rt, cax) -> float:
-        return 100 * (lt - rt) / cax
-
-    # get value w/ max magnitude
-    sym_vals = [
-        calc_sym(lt, rt, cax_value) for lt, rt in zip(field_values, field_values[::-1])
-    ]
-    max_sym_idx = np.argmax(np.abs(sym_vals))
-    return sym_vals[max_sym_idx]
-
-
-def plot_symmetry_point_difference(
-    instance, profile: SingleProfile, axis: plt.Axes
-) -> None:
-    """Plotting of the symmetry point difference."""
-
-    def calc_sym(lt, rt, cax) -> float:
-        return 100 * abs(lt - rt) / cax
-
-    _plot_sym_common(
-        instance, calc_sym, profile, axis, label="Symmetry (%)", padding=(5, 0.5)
-    )
-
-
-def _plot_sym_common(
-    instance,
-    calc_func: Callable,
-    profile: SingleProfile,
-    axis: plt.Axes,
-    label: str,
-    padding: tuple,
-) -> None:
-    field = profile.field_data(
-        in_field_ratio=instance._in_field_ratio,
-        slope_exclusion_ratio=instance._slope_exclusion_ratio,
-    )
-    field_values = field["field values"]
-    left_idx = field["left index (rounded)"]
-    right_idx = field["right index (rounded)"]
-    cax_value = field["beam center value (@rounded)"]
-
-    # same calc as PDQ and point difference, except we find the INDEX where the symmetry is maximum
-    sym_values = [
-        calc_func(lt, rt, cax_value)
-        for lt, rt, _ in zip(
-            field_values, field_values[::-1], range(int(round(len(field_values) / 2)))
-        )
-    ]
-
-    idx = np.argmax(sym_values)
-    axis.plot(
-        field["left index (rounded)"] + idx,
-        profile._y_original_to_interp(field["left index (rounded)"] + idx),
-        "*",
-        color="red",
-        label="Symmetry max",
-    )
-    axis.plot(
-        field["right index (rounded)"] - idx,
-        profile._y_original_to_interp(field["right index (rounded)"] - idx),
-        "*",
-        color="red",
-    )
-    sec_ax = axis.twinx()
-    sec_ax.set_ylabel(label)
-
-    # squish the secondary graph so it's not so large-looking
-    ylim_top = max(sym_values) + padding[0]
-    ylim_bottom = min(sym_values) - padding[1]
-    sec_ax.set_ylim(ylim_bottom, ylim_top)
-    left_end = int(round(left_idx + (right_idx - left_idx) / 2))
-    sec_ax.plot(range(left_end, left_end + len(sym_values)), sym_values[::-1])
-
-
-def plot_symmetry_pdq(instance, profile: SingleProfile, axis: plt.Axes) -> None:
-    """Plotting of the symmetry point difference quotient."""
-
-    def calc_sym(lt, rt, _) -> float:
-        return max(abs(lt / rt), abs(rt / lt))
-
-    _plot_sym_common(
-        instance, calc_sym, profile, axis, label="Symmetry (AU)", padding=(0.05, 0.01)
-    )
-
-
-def symmetry_pdq_iec(profile: SingleProfile, in_field_ratio: float, **kwargs) -> float:
-    """Symmetry calculation by way of PDQ IEC. See :ref:`elekta_protocol`.
-
-    A negative value means the right side is higher. A positive value means the left side is higher.
-    """
-    field = profile.field_data(
-        in_field_ratio=in_field_ratio,
-        slope_exclusion_ratio=kwargs.get("slope_exclusion_ratio", 0.2),
-    )
-    field_values = field["field values"]
-
-    def calc_sym(lt, rt) -> float:
-        sym1 = lt / rt
-        sym2 = rt / lt
-        if abs(sym1) > abs(sym2):
-            sign = np.sign(sym1)
-        else:
-            sign = np.sign(sym2)
-        return max(abs(lt / rt), abs(rt / lt)) * sign
-
-    sym_values = [calc_sym(lt, rt) for lt, rt in zip(field_values, field_values[::-1])]
-    sym_idx = np.argmax(np.abs(sym_values))
-
-    return sym_values[sym_idx]
-
-
-def symmetry_area(profile: SingleProfile, in_field_ratio: float, **kwargs) -> float:
-    """Ratio of the area under the left and right profile segments.  See :ref:`siemens_protocol`.
-
-    A negative value indicates the right side is higher; a positive value indicates the left side is higher.
-    """
-    data = profile.field_data(
-        in_field_ratio=in_field_ratio,
-        slope_exclusion_ratio=kwargs.get("slope_exclusion_ratio", 0.2),
-    )
-    cax_idx = data["beam center index (exact)"] - data["left index (exact)"]
-    area_left = np.sum(data["field values"][: floor(cax_idx)])
-    area_right = np.sum(data["field values"][ceil(cax_idx) :])
-    symmetry = 100 * (area_left - area_right) / (area_left + area_right)
-    return symmetry
-
-
-def plot_symmetry_area(instance, profile: SingleProfile, axis: plt.Axes) -> None:
-    """PLot the symmetry area."""
-    data = profile.field_data(
-        in_field_ratio=instance._in_field_ratio,
-        slope_exclusion_ratio=instance._slope_exclusion_ratio,
-    )
-    cax_idx = data["beam center index (exact)"]
-    left_idx = data["left index (rounded)"]
-    right_idx = data["right index (rounded)"]
-
-    axis.fill_between(
-        range(left_idx, floor(cax_idx)),
-        data["field values"][: floor(cax_idx) - left_idx],
-        color="green",
-        alpha=0.1,
-        label="Left Area",
-    )
-    arr1 = np.array(range(ceil(cax_idx), right_idx))
-    arr2 = data["field values"][ceil(cax_idx) - left_idx :]
-    if arr1.shape < arr2.shape:
-        arr1_padded = np.pad(arr1, (0, len(arr2) - len(arr1)), 'constant', constant_values=(0, 0))
-        x= arr1_padded.tolist()
-        y1 = arr2
-    elif arr1.shape > arr2.shape:        
-        arr2_padded = np.pad(arr2, (0, len(arr1) - len(arr2)), 'constant', constant_values=(0, 0))
-        x= arr1.tolist()
-        y1 = arr2_padded.tolist()
-    else:
-        x= arr1.tolist()
-        y1 = arr2
-    axis.fill_between(
-        x,
-        y1,
-        color="slateblue",
-        alpha=0.1,
-        label="Right Area",
-    )
-
-
-varian_protocol = {
-    "symmetry": {
-        "calc": symmetry_point_difference,
-        "unit": "%",
-        "plot": plot_symmetry_point_difference,
-    },
-    "flatness": {"calc": flatness_dose_difference, "unit": "%", "plot": plot_flatness},
-}
-elekta_protocol = {
-    "symmetry": {"calc": symmetry_pdq_iec, "unit": "", "plot": plot_symmetry_pdq},
-    "flatness": {"calc": flatness_dose_ratio, "unit": "", "plot": plot_flatness},
-}
-siemens_protocol = {
-    "symmetry": {"calc": symmetry_area, "unit": "", "plot": plot_symmetry_area},
-    "flatness": {"calc": flatness_dose_difference, "unit": "", "plot": plot_flatness},
-}
-
-
-class Protocol(Enum):
-    """Protocols to analyze additional metrics of the field. See :ref:`analysis_definitions`"""
-
-    NONE = {}  #:
-    VARIAN = varian_protocol  #:
-    SIEMENS = siemens_protocol  #:
-    ELEKTA = elekta_protocol  #:
-
-
-@dataclass
-class DeviceResult(ResultBase):
-    protocol: Protocol  #:
-    protocol_results: dict  #:
-    centering_method: Centering  #:
-    normalization_method: Normalization  #:
-    interpolation_method: Interpolation  #:
-    edge_detection_method: Edge  #:
-    top_penumbra_mm: float  #:
-    bottom_penumbra_mm: float  #:
-    left_penumbra_mm: float  #:
-    right_penumbra_mm: float  #:
-    geometric_center_index_x_y: tuple[float, float]  #:
-    beam_center_index_x_y: tuple[float, float]  #:
-    field_size_vertical_mm: float  #:
-    field_size_horizontal_mm: float  #:
-    beam_center_to_top_mm: float  #:
-    beam_center_to_bottom_mm: float  #:
-    beam_center_to_left_mm: float  #:
-    beam_center_to_right_mm: float  #:
-    cax_to_top_mm: float  #:
-    cax_to_bottom_mm: float  #:
-    cax_to_left_mm: float  #:
-    cax_to_right_mm: float  #:
-    top_position_index_x_y: tuple[float, float]  #:
-    top_horizontal_distance_from_cax_mm: float  #:
-    top_vertical_distance_from_cax_mm: float  #:
-    top_horizontal_distance_from_beam_center_mm: float  #:
-    top_vertical_distance_from_beam_center_mm: float  #:
-    left_slope_percent_mm: float  #:
-    right_slope_percent_mm: float  #:
-    top_slope_percent_mm: float  #:
-    bottom_slope_percent_mm: float  #:
-    top_penumbra_percent_mm: float = 0  #:
-    bottom_penumbra_percent_mm: float = 0  #:
-    left_penumbra_percent_mm: float = 0  #:
-    right_penumbra_percent_mm: float = 0  #:
-
-
-@dataclass
-class FieldResult(DeviceResult):
-    """This class should not be called directly. It is returned by the ``results_data()`` method.
-    It is a dataclass under the hood and thus comes with all the dunder magic.
-
-    Use the following attributes as normal class attributes.
-
-    In addition to the below attrs, custom protocol data will also be attached under the
-    ``protocol_results`` attr as a dictionary with keys like so:
-    ``<protocol name>_vertical`` and ``<protocol name>_horizontal`` for each protocol item.
-
-    E.g. a protocol item of ``symmetry`` will result in ``symmetry_vertical`` and ``symmetry_horizontal``.
-    """
-
-    central_roi_mean: float = 0  #:
-    central_roi_max: float = 0  #:
-    central_roi_std: float = 0  #:
-    central_roi_min: float = 0  #:
-
-
-class FieldAnalysis:
-    """Class for analyzing the various parameters of a radiation image, most commonly an open image from a linac."""
-
-    def __init__(
-        self,
-        path: str | BinaryIO,
-        filter: int | None = None,
-        image_kwargs: dict | None = None,
-    ):
-        """
-
-
-        Parameters
-        ----------
-        path
-            The path to the image.
-        filter
-            If None, no filter is applied. If an int, a median filter of size n pixels is applied. Generally, a good idea.
-            Default is None for backwards compatibility.
-        """
-        self._path: str = path
-        img_kwargs = image_kwargs or {}
-        self.image: image.ImageLike = image.load(path, **img_kwargs)  #:
-        if filter:
-            self.image.filter(size=filter)
-        self.vert_profile: SingleProfile  #:
-        self.horiz_profile: SingleProfile  #:
-        self._is_analyzed: bool = False
-        self._from_device: bool = False
-        self.image.check_inversion_by_histogram()
-
-    @classmethod
-    def from_demo_image(cls):
-        """Load the demo image into an instance."""
-        demo_file = retrieve_demo_file(name="flatsym_demo.dcm")
-        return cls(demo_file)
-
-    @staticmethod
-    def run_demo() -> None:
-        """Run the Field Analysis demo by loading the demo image, print results, and plot the profiles."""
-        fs = FieldAnalysis.from_demo_image()
-        fs.analyze(protocol=Protocol.VARIAN)
-        print(fs.results())
-        fs.plot_analyzed_image()
-
-    def _determine_center(self, centering: Centering) -> tuple[float, float]:
-        """Determine the position ratio using a centering technique."""
-        vert_sum = np.sum(self.image.array, axis=1)
-        horiz_sum = np.sum(self.image.array, axis=0)
-        v_prof = SingleProfile(vert_sum)
-        h_prof = SingleProfile(horiz_sum)
-        if centering == Centering.GEOMETRIC_CENTER:
-            # horiz and vert appear switched, but it's because the center of the vert profile
-            # is where to take the horizontal profile and vic versa
-            horiz_ratio = (
-                v_prof.geometric_center()["index (exact)"] / self.image.shape[0]
-            )
-            vert_ratio = (
-                h_prof.geometric_center()["index (exact)"] / self.image.shape[1]
-            )
-        elif centering == Centering.BEAM_CENTER:
-            horiz_ratio = v_prof.beam_center()["index (exact)"] / self.image.shape[0]
-            vert_ratio = h_prof.beam_center()["index (exact)"] / self.image.shape[1]
-        return vert_ratio, horiz_ratio
-
-    def _extract_profiles(
-        self,
-        horiz_position,
-        horiz_width,
-        interpolation_resolution_mm,
-        vert_position,
-        vert_width,
-        edge_detection_method,
-        edge_smoothing_ratio,
-        ground,
-        interpolation,
-        interpolation_resolution,
-        normalization_method,
-        centering,
-        hill_window_ratio,
-        _vert_position,
-        _horiz_position,       
-    ) -> None:
-        """Figures out 1) where to extract the profiles from the image and 2) sets the profiles to instance attrs"""
-
-        # calculate the horiz/vert extraction positions if necessary
-        if centering in (Centering.BEAM_CENTER, Centering.GEOMETRIC_CENTER):
-            if _vert_position and _horiz_position:
-                vert_position = _vert_position
-                horiz_position = _horiz_position
-            else:
-                vert_position, horiz_position = self._determine_center(centering)
-
-        # calculate the profiles
-        horiz_values, upper_h_idx, lower_h_idx = self._get_horiz_values(
-            horiz_position, horiz_width
-        )
-        self._upper_h_index = upper_h_idx
-        self._lower_h_index = lower_h_idx
-        self.horiz_profile = SingleProfile(
-            horiz_values,
-            dpmm=self.image.dpmm,
-            interpolation=interpolation,
-            interpolation_resolution_mm=interpolation_resolution_mm,
-            ground=ground,
-            edge_detection_method=edge_detection_method,
-            normalization_method=normalization_method,
-            edge_smoothing_ratio=edge_smoothing_ratio,
-            hill_window_ratio=hill_window_ratio,
-        )
-
-        vert_values, left_v_idx, right_v_idx = self._get_vert_values(
-            vert_position, vert_width
-        )
-        self._left_v_index = left_v_idx
-        self._right_v_index = right_v_idx
-        self.vert_profile = SingleProfile(
-            vert_values,
-            dpmm=self.image.dpmm,
-            interpolation=interpolation,
-            interpolation_resolution_mm=interpolation_resolution_mm,
-            ground=ground,
-            edge_detection_method=edge_detection_method,
-            normalization_method=normalization_method,
-            edge_smoothing_ratio=edge_smoothing_ratio,
-            hill_window_ratio=hill_window_ratio,
-        )
-
-    def analyze(
-        self,
-        protocol: Protocol = Protocol.VARIAN,
-        centering: Centering | str = Centering.BEAM_CENTER,
-        vert_position: float = 0.5,
-        horiz_position: float = 0.5,
-        vert_width: float = 0,
-        horiz_width: float = 0,
-        in_field_ratio: float = 0.8,
-        slope_exclusion_ratio: float = 0.2,
-        invert: bool = False,
-        is_FFF: bool = False,
-        penumbra: tuple[float, float] = (20, 80),
-        interpolation: Interpolation | str | None = Interpolation.LINEAR,
-        interpolation_resolution_mm: float = 0.1,
-        ground: bool = True,
-        normalization_method: Normalization | str = Normalization.BEAM_CENTER,
-        edge_detection_method: Edge | str = Edge.INFLECTION_DERIVATIVE,
-        edge_smoothing_ratio: float = 0.003,
-        hill_window_ratio: float = 0.15,
-        **kwargs,
-    ) -> None:
-        """Analyze the image to determine parameters such as field edges, penumbra, and/or flatness & symmetry.
-
-        Parameters
-        ----------
-        protocol : :class:`~pylinac.field_analysis.Protocol`
-            The analysis protocol. See :ref:`analysis_definitions` for equations.
-        centering : :class:`~pylinac.Centering`
-            The profile extraction position technique. Beam center will determine the beam center and take profiles through the middle.
-            Geometric center will simply take profiles centered about the image in both axes.
-            Manual will use the values of `vert_position` and `horiz_position` as the position.
-            See :ref:`centering`.
-        vert_position
-            The distance ratio of the image to sample. E.g. at the default of 0.5 the profile is extracted
-            in the middle of the image. 0.0 is at the left edge of the image and 1.0 is at the right edge of the image.
-
-            .. note::
-
-                This value only applies when centering is MANUAL.
-
-        horiz_position
-            The distance ratio of the image to sample. E.g. at the default of 0.5 the profile is extracted
-            in the middle of the image. 0.0 is at the top edge of the image and 1.0 is at the bottom edge of the image.
-
-            .. note::
-
-                This value only applies when centering is MANUAL.
-
-        vert_width
-            The width ratio of the image to sample. E.g. at the default of 0.0 a 1 pixel wide profile is extracted.
-            0.0 would be 1 pixel wide and 1.0 would be the vertical image width.
-        horiz_width
-            The width ratio of the image to sample. E.g. at the default of 0.0 a 1 pixel wide profile is extracted.
-            0.0 would be 1 pixel wide and 1.0 would be the horizontal image width.
-        in_field_ratio
-            The ratio of the field width to use for protocol values. E.g. 0.8 means use the 80% field width.
-        slope_exclusion_ratio
-            This is the ratio of the field to use to 1) calculate the "top" of an FFF field as well as 2) exclude from the
-            "slope" calculation of each side of the field. Alternatively, this also defines the area to use for the
-            slope calculation. E.g. an `in_field_ratio` of 0.8 and `slope_exclusion_ratio` of 0.2 means the central 20% of the
-            field is used to fit and calculate the "top", while the region on either side of the central 20% between the central
-            80% is used to calculate a slope on either side using linear regression.
-
-            .. note::
-
-                While the "top" is always calculated, it will not be displayed in plots if the `is_FFF` parameter is false.
-
-        invert
-            Whether to invert the image. Setting this to True will override the default inversion. This is useful if
-            pylinac's automatic inversion is incorrect.
-        is_FFF
-            This is a flag to display the "top" calculation and slopes on either side of the field.
-        penumbra
-            A tuple of (lower, higher) % of the penumbra to calculate. E.g. (20, 80) will calculate the penumbra width at 20% and 80%.
-
-            .. note::
-
-                The exact height of the penumbra depends on the edge detection method. E.g. FWHM will result in
-                calculating penumbra at 20/80% of the field max, but if something like inflection is used, the penumbra
-                height will be 20/50*100*inflection height and 80/50*100*inflection height.
-
-        ground
-            Whether to ground the profile (set min value to 0). Helpful most of the time.
-        interpolation
-            Interpolation technique to use. See :ref:`Interpolation`.
-        interpolation_resolution_mm
-            The resolution that the interpolation will scale to.
-            E.g. if the native dpmm is 2 and the resolution is set to 0.1mm the data will be interpolated to have a new dpmm of 10 (1/0.1).
-        normalization_method
-            How to pick the point to normalize the data to. See :ref:`Normalization`.
-        edge_detection_method
-            The method by which to detect the field edge. FWHM is reasonable most of the time except for FFF beams.
-            Inflection-derivative will use the max gradient to determine the field edge. Note that this may not be the
-            50% height. In fact, for FFF beams it shouldn't be. Inflection methods are better for FFF and other unusual
-            beam shapes. See :ref:`edge`.
-        edge_smoothing_ratio
-            The ratio of the length of the values to use as the sigma for a Gaussian filter applied before searching for
-            the inflection. E.g. 0.005 with a profile of 1000 points will result in a sigma of 5.
-            This helps make the inflection point detection more robust to noise. Increase for noisy data.
-        hill_window_ratio
-            The ratio of the field size to use as the window to fit the Hill function. E.g. 0.2 will using a window
-            centered about each edge with a width of 20% the size of the field width. Only applies when the edge
-            detection is ``INFLECTION_HILL``.
-        vert_position
-            customize vert_position example 0.32
-        horiz_position
-            customize horiz_position example 0.82
-        kwargs
-            Use these to pass parameters to custom protocol functions. See :ref:`custom_protocols`.
-        """
-        if is_FFF and edge_detection_method == Edge.FWHM:
-            warnings.warn(
-                "Using FWHM for an FFF beam is not advised. Consider using INFLECTION_DERIVATIVE or INFLECTION_HILL"
-            )
-        if invert:
-            self.image.invert()
-        edge_detection_method = convert_to_enum(edge_detection_method, Edge)
-        interpolation = convert_to_enum(interpolation, Interpolation)
-        normalization_method = convert_to_enum(normalization_method, Normalization)
-        centering = convert_to_enum(centering, Centering)
-
-        self._analyze(
-            edge_detection_method,
-            edge_smoothing_ratio,
-            ground,
-            horiz_position,
-            horiz_width,
-            in_field_ratio,
-            interpolation,
-            interpolation_resolution_mm,
-            is_FFF,
-            kwargs,
-            normalization_method,
-            penumbra,
-            protocol,
-            slope_exclusion_ratio,
-            vert_position,
-            vert_width,
-            centering,
-            hill_window_ratio,
-        )
-
-    def _analyze(
-        self,
-        edge_detection_method,
-        edge_smoothing_ratio,
-        ground,
-        horiz_position,
-        horiz_width,
-        in_field_ratio,
-        interpolation,
-        interpolation_resolution_mm,
-        is_FFF,
-        kwargs,
-        normalization_method,
-        penumbra,
-        protocol,
-        slope_exclusion_ratio,
-        vert_position,
-        vert_width,
-        centering,
-        hill_window_ratio,
-    ):
-        self._protocol = protocol
-        self._penumbra = penumbra
-        self._centering = convert_to_enum(centering, Centering)
-        self._is_FFF: bool = is_FFF
-        self._edge_detection = convert_to_enum(edge_detection_method, Edge)
-        self._in_field_ratio = in_field_ratio
-        self._slope_exclusion_ratio = slope_exclusion_ratio
-        self._hill_window_ratio = hill_window_ratio
-        self._interpolation_method = convert_to_enum(interpolation, Interpolation)
-        self._normalization_method = convert_to_enum(
-            normalization_method, Normalization
-        )
-        _vert_position= kwargs.get("vert_position",None)
-        _horiz_position = kwargs.get("horiz_position",None)
-        self._extract_profiles(
-            horiz_position,
-            horiz_width,
-            interpolation_resolution_mm,
-            vert_position,
-            vert_width,
-            self._edge_detection,
-            edge_smoothing_ratio,
-            ground,
-            self._interpolation_method,
-            interpolation_resolution_mm,
-            self._normalization_method,
-            self._centering,
-            hill_window_ratio,
-            _vert_position,
-            _horiz_position,
-        )
-        self._results = {}
-
-        # calculate the central ROI data within the vert and horiz windows
-        if not self._from_device:
-            width = max(abs(self._left_v_index - self._right_v_index), 2)
-            height = max(abs(self._upper_h_index - self._lower_h_index), 2)
-            center = Point(
-                width / 2 + self._left_v_index, height / 2 + self._upper_h_index
-            )
-            self.central_roi = RectangleROI(
-                array=self.image.array,
-                width=width,
-                height=height,
-                phantom_center=center,
-                angle=0,
-                dist_from_center=0,
-            )
-
-        # calculate common field info
-        v_pen = self.vert_profile.penumbra(penumbra[0], penumbra[1])
-        h_pen = self.horiz_profile.penumbra(penumbra[0], penumbra[1])
-        self._results["top_penumbra_mm"] = v_pen["left penumbra width (exact) mm"]
-        self._results["bottom_penumbra_mm"] = v_pen["right penumbra width (exact) mm"]
-        self._results["left_penumbra_mm"] = h_pen["left penumbra width (exact) mm"]
-        self._results["right_penumbra_mm"] = h_pen["right penumbra width (exact) mm"]
-        if edge_detection_method == Edge.INFLECTION_HILL:
-            self._results["top_penumbra_percent_mm"] = abs(
-                v_pen["left gradient (exact) %/mm"]
-            )
-            self._results["bottom_penumbra_percent_mm"] = abs(
-                v_pen["right gradient (exact) %/mm"]
-            )
-            self._results["left_penumbra_percent_mm"] = abs(
-                h_pen["left gradient (exact) %/mm"]
-            )
-            self._results["right_penumbra_percent_mm"] = abs(
-                h_pen["right gradient (exact) %/mm"]
-            )
-        self._results["geometric_center_index_x_y"] = (
-            self.horiz_profile.geometric_center()["index (exact)"],
-            self.vert_profile.geometric_center()["index (exact)"],
-        )
-        self._results["beam_center_index_x_y"] = (
-            self.horiz_profile.beam_center()["index (exact)"],
-            self.vert_profile.beam_center()["index (exact)"],
-        )
-        self._results["field_size_vertical_mm"] = self.vert_profile.field_data(
-            in_field_ratio=1.0, slope_exclusion_ratio=slope_exclusion_ratio
-        )["width (exact) mm"]
-        self._results["field_size_horizontal_mm"] = self.horiz_profile.field_data(
-            in_field_ratio=1.0, slope_exclusion_ratio=slope_exclusion_ratio
-        )["width (exact) mm"]
-        self._results["beam_center_to_top_mm"] = self.vert_profile.field_data(
-            in_field_ratio=1.0, slope_exclusion_ratio=slope_exclusion_ratio
-        )["left distance->beam center (exact) mm"]
-        self._results["beam_center_to_bottom_mm"] = self.vert_profile.field_data(
-            in_field_ratio=1.0, slope_exclusion_ratio=slope_exclusion_ratio
-        )["right distance->beam center (exact) mm"]
-        self._results["beam_center_to_left_mm"] = self.horiz_profile.field_data(
-            in_field_ratio=1.0, slope_exclusion_ratio=slope_exclusion_ratio
-        )["left distance->beam center (exact) mm"]
-        self._results["beam_center_to_right_mm"] = self.horiz_profile.field_data(
-            in_field_ratio=1.0, slope_exclusion_ratio=slope_exclusion_ratio
-        )["right distance->beam center (exact) mm"]
-        self._results["cax_to_top_mm"] = self.vert_profile.field_data(
-            in_field_ratio=1.0, slope_exclusion_ratio=slope_exclusion_ratio
-        )["left distance->CAX (exact) mm"]
-        self._results["cax_to_bottom_mm"] = self.vert_profile.field_data(
-            in_field_ratio=1.0, slope_exclusion_ratio=slope_exclusion_ratio
-        )["right distance->CAX (exact) mm"]
-        self._results["cax_to_left_mm"] = self.horiz_profile.field_data(
-            in_field_ratio=1.0, slope_exclusion_ratio=slope_exclusion_ratio
-        )["left distance->CAX (exact) mm"]
-        self._results["cax_to_right_mm"] = self.horiz_profile.field_data(
-            in_field_ratio=1.0, slope_exclusion_ratio=slope_exclusion_ratio
-        )["right distance->CAX (exact) mm"]
-
-        h_field_data = self.horiz_profile.field_data(
-            in_field_ratio=in_field_ratio, slope_exclusion_ratio=slope_exclusion_ratio
-        )
-        v_field_data = self.vert_profile.field_data(
-            in_field_ratio=in_field_ratio, slope_exclusion_ratio=slope_exclusion_ratio
-        )
-        self._results["top_position_index_x_y"] = (
-            h_field_data['"top" index (exact)'],
-            v_field_data['"top" index (exact)'],
-        )
-        self._results["top_horizontal_distance_from_cax_mm"] = h_field_data[
-            '"top"->CAX (exact) mm'
-        ]
-        self._results["top_vertical_distance_from_cax_mm"] = v_field_data[
-            '"top"->CAX (exact) mm'
-        ]
-        self._results["top_horizontal_distance_from_beam_center_mm"] = h_field_data[
-            '"top"->beam center (exact) mm'
-        ]
-        self._results["top_vertical_distance_from_beam_center_mm"] = v_field_data[
-            '"top"->beam center (exact) mm'
-        ]
-        self._results["left_slope_percent_mm"] = h_field_data["left slope (%/mm)"]
-        self._results["right_slope_percent_mm"] = h_field_data["right slope (%/mm)"]
-        self._results["top_slope_percent_mm"] = v_field_data["left slope (%/mm)"]
-        self._results["bottom_slope_percent_mm"] = v_field_data["right slope (%/mm)"]
-
-        # calculate protocol info
-        self._extra_results = {}
-        kwargs.update({"slope_exclusion_ratio": slope_exclusion_ratio})
-        for name, item in protocol.value.items():
-            self._extra_results[f"{name}_horizontal"] = item["calc"](
-                self.horiz_profile, in_field_ratio, **kwargs
-            )
-            self._extra_results[f"{name}_vertical"] = item["calc"](
-                self.vert_profile, in_field_ratio, **kwargs
-            )
-        self._is_analyzed = True
-
-    def results(self, as_str=True) -> str:
-        """Get the results of the analysis.
-
-        Parameters
-        ----------
-        as_str
-            If True, return a simple string. If False, return a list of each line of text.
-        """
-        if not self._is_analyzed:
-            raise NotAnalyzed("Image is not analyzed yet. Use analyze() first.")
-
-        results = [
-            "Field Analysis Results",
-            "----------------------",
-            f"File: {self._path}",
-            f"Protocol: {self._protocol.name}",
-        ]
-        if not self._from_device:
-            results += [
-                f"Centering method: {self._centering.value}",
-            ]
-        results += [
-            f"Normalization method: {self.horiz_profile._norm_method.value}",
-            f"Interpolation: {self.horiz_profile._interp_method.value}",
-            f"Edge detection method: {self.horiz_profile._edge_method.value}",
-            "",
-            f"Penumbra width ({self._penumbra[0]}/{self._penumbra[1]}):",
-            f"Left: {self._results['left_penumbra_mm']:3.1f}mm",
-            f"Right: {self._results['right_penumbra_mm']:3.1f}mm",
-            f"Top: {self._results['top_penumbra_mm']:3.1f}mm",
-            f"Bottom: {self._results['bottom_penumbra_mm']:3.1f}mm",
-            "",
-        ]
-        if self._edge_detection == Edge.INFLECTION_HILL:
-            results += [
-                "Penumbra gradients:",
-                f"Left gradient: {self._results['left_penumbra_percent_mm']:3.2f}%/mm",
-                f"Right gradient: {self._results['right_penumbra_percent_mm']:3.2f}%/mm",
-                f"Top gradient: {self._results['top_penumbra_percent_mm']:3.2f}%/mm",
-                f"Bottom gradient: {self._results['bottom_penumbra_percent_mm']:3.2f}%/mm",
-                "",
-            ]
-        results += [
-            "Field Size:",
-            f"Horizontal: {self._results['field_size_horizontal_mm']:3.1f}mm",
-            f"Vertical: {self._results['field_size_vertical_mm']:3.1f}mm",
-            "",
-            "CAX to edge distances:",
-            f"CAX -> Top edge: {self._results['cax_to_top_mm']:3.1f}mm",
-            f"CAX -> Bottom edge: {self._results['cax_to_bottom_mm']:3.1f}mm",
-            f"CAX -> Left edge: {self._results['cax_to_left_mm']:3.1f}mm",
-            f"CAX -> Right edge: {self._results['cax_to_right_mm']:3.1f}mm",
-            "",
-        ]
-        if not self._from_device:
-            results += [
-                "Central ROI stats:",
-                f"Mean: {self.central_roi.mean}",
-                f"Max: {self.central_roi.max}",
-                f"Min: {self.central_roi.min}",
-                f"Standard deviation: {self.central_roi.std}",
-                "",
-            ]
-        if self._is_FFF:
-            results += [
-                "'Top' vertical distance from CAX: {:3.1f}mm".format(
-                    self._results["top_vertical_distance_from_cax_mm"]
-                ),
-                "'Top' horizontal distance from CAX: {:3.1f}mm".format(
-                    self._results["top_horizontal_distance_from_cax_mm"]
-                ),
-                "'Top' vertical distance from beam center: {:3.1f}mm".format(
-                    self._results["top_vertical_distance_from_beam_center_mm"]
-                ),
-                "'Top' horizontal distance from beam center: {:3.1f}mm".format(
-                    self._results["top_horizontal_distance_from_beam_center_mm"]
-                ),
-                "",
-            ]
-        results += [
-            f"Top slope: {self._results['top_slope_percent_mm']:3.3f}%/mm",
-            f"Bottom slope: {self._results['bottom_slope_percent_mm']:3.3f}%/mm",
-            f"Left slope: {self._results['left_slope_percent_mm']:3.3f}%/mm",
-            f"Right slope: {self._results['right_slope_percent_mm']:3.3f}%/mm",
-            "",
-            "Protocol data:",
-            "--------------",
-        ]
-
-        for name, item in self._protocol.value.items():
-            results.append(
-                f"Vertical {name}: {self._extra_results[name + '_vertical']:3.3f}{item['unit']}"
-            )
-            results.append(
-                f"Horizontal {name}: {self._extra_results[name + '_horizontal']:3.3f}{item['unit']}"
-            )
-            results.append("")
-
-        if as_str:
-            results = "\n".join(result for result in results)
-        return results
-
-    def results_data(self, as_dict: bool = False) -> FieldResult | dict:
-        """Present the results data and metadata as a dataclass or dict.
-        The default return type is a dataclass."""
-        data = FieldResult(
-            **self._results,
-            protocol=self._protocol.name,
-            centering_method=getattr(self._centering, "value", None),
-            normalization_method=self.horiz_profile._norm_method.value,
-            interpolation_method=self.horiz_profile._interp_method.value,
-            edge_detection_method=self.horiz_profile._edge_method.value,
-            protocol_results=self._extra_results,
-            central_roi_max=self.central_roi.max,
-            central_roi_mean=self.central_roi.mean,
-            central_roi_min=self.central_roi.min,
-            central_roi_std=self.central_roi.std,
-        )
-        if as_dict:
-            return dataclasses.asdict(data)
-        return data
-
-    def _get_vert_values(
-        self, vert_position: float, vert_width: float
-    ) -> (np.ndarray, float, float):
-        """Get the raw values of the profile to pass to SingleProfile"""
-        left_edge = int(
-            round(
-                self.image.array.shape[1] * vert_position
-                - self.image.array.shape[1] * vert_width / 2
-            )
-        )
-        left_edge = max(left_edge, 0)  # clip to 0
-        right_edge = int(
-            round(
-                self.image.array.shape[1] * vert_position
-                + self.image.array.shape[1] * vert_width / 2
-            )
-            + 1
-        )
-        right_edge = min(right_edge, self.image.array.shape[1])  # clip to image limit
-        return (
-            np.mean(self.image.array[:, left_edge:right_edge], 1),
-            left_edge,
-            right_edge,
-        )
-
-    def _get_horiz_values(
-        self, horiz_position: float, horiz_width: float
-    ) -> (np.ndarray, float, float):
-        """Get the raw values of the profile to pass to SingleProfile"""
-        bottom_edge = int(
-            round(
-                self.image.array.shape[0] * horiz_position
-                - self.image.array.shape[0] * horiz_width / 2
-            )
-        )
-        bottom_edge = max(bottom_edge, 0)
-        top_edge = int(
-            round(
-                self.image.array.shape[0] * horiz_position
-                + self.image.array.shape[0] * horiz_width / 2
-            )
-            + 1
-        )
-        top_edge = min(top_edge, self.image.array.shape[0])
-        return (
-            np.mean(self.image.array[bottom_edge:top_edge, :], 0),
-            bottom_edge,
-            top_edge,
-        )
-
-    def publish_pdf(
-        self,
-        filename: str,
-        notes: str | list = None,
-        open_file: bool = False,
-        metadata: dict = None,
-        logo: Path | str | None = None,
-    ) -> None:
-        """Publish (print) a PDF containing the analysis, images, and quantitative results.
-
-        Parameters
-        ----------
-        filename : (str, file-like object}
-            The file to write the results to.
-        notes : str, list of strings
-            Text; if str, prints single line.
-            If list of strings, each list item is printed on its own line.
-        open_file : bool
-            Whether to open the file using the default program after creation.
-        metadata : dict
-            Extra stream to be passed and shown in the PDF. The key and value will be shown with a colon.
-            E.g. passing {'Author': 'James', 'Unit': 'TrueBeam'} would result in text in the PDF like:
-            --------------
-            Author: James
-            Unit: TrueBeam
-            --------------
-        logo: Path, str
-            A custom logo to use in the PDF report. If nothing is passed, the default pylinac logo is used.
-        """
-        plt.ioff()
-        if not self._is_analyzed:
-            raise NotAnalyzed("Image is not analyzed yet. Use analyze() first.")
-        canvas = pdf.PylinacCanvas(
-            filename,
-            page_title="Field Analysis",
-            metadata=metadata,
-            metadata_location=(2, 5),
-            logo=logo,
-        )
-        # draw result text
-        text = self.results(as_str=False)
-        number_of_lines = len(text)
-        i = 0
-        while i < number_of_lines:
-            if i > number_of_lines - 1:
-                i = number_of_lines - 1
-            canvas.add_text(text=text[i : i + 50], location=(2, 25.5), font_size=10)
-            canvas.add_new_page()
-            i = i + 50
-
-        # draw vertical profile
-        stream = io.BytesIO()
-        self._save_plot(self._plot_vert, stream)
-        canvas.add_image(stream, location=(-4, 13), dimensions=(28, 12))
-
-        # draw horizontal profile
-        stream = io.BytesIO()
-        self._save_plot(self._plot_horiz, stream)
-        canvas.add_image(stream, location=(-4, 1), dimensions=(28, 12))
-
-        # draw image on last page if it's an EPID image. Skip if a device as there's no image
-        if not hasattr(self, "device"):
-            canvas.add_new_page()
-            stream = io.BytesIO()
-            self._save_plot(self._plot_image, stream, title="Image")
-            canvas.add_image(stream, location=(1, 2), dimensions=(18, 20))
-
-        if notes is not None:
-            canvas.add_text(text="Notes:", location=(1, 5.5), font_size=14)
-            canvas.add_text(text=notes, location=(1, 5))
-        canvas.finish()
-
-        if open_file:
-            webbrowser.open(filename)
-
-    def plot_analyzed_image(
-        self,
-        show: bool = True,
-        grid: bool = True,
-        split_plots: bool = False,
-        **plt_kwargs,
-    ) -> tuple[list[plt.Figure], list[str]]:
-        """Plot the analyzed image. Shows parameters such as flatness & symmetry.
-
-        Parameters
-        ----------
-        show
-            Whether to show the plot when called.
-        grid
-            Whether to show a grid on the profile plots
-        split_plots : bool
-            Whether to plot the image and profiles on individual figures. Useful for saving individual plots.
-        plt_kwargs : dict
-            Keyword args passed to the plt.figure() method. Allows one to set things like figure size.
-        """
-        if not self._is_analyzed:
-            raise NotAnalyzed("Image is not analyzed yet. Use analyze() first.")
-        # set up axes
-        plt.ioff()
-        figs = []
-        names = []
-        if split_plots:
-            if not self._from_device:
-                im_fig, image_ax = plt.subplots(1, **plt_kwargs)
-                figs.append(im_fig)
-                names.append("Image")
-            v_fig, vert_ax = plt.subplots(1, **plt_kwargs)
-            figs.append(v_fig)
-            names.append("Vertical Profile")
-            h_fig, horiz_ax = plt.subplots(1, **plt_kwargs)
-            figs.append(h_fig)
-            names.append("Horizontal Profile")
-        else:
-            plt.figure(**plt_kwargs)
-            if not self._from_device:
-                image_ax = plt.subplot2grid((2, 2), (0, 1))
-                vert_ax = plt.subplot2grid((2, 2), (1, 1))
-                horiz_ax = plt.subplot2grid((2, 2), (0, 0))
-            else:
-                vert_ax = plt.subplot2grid((1, 2), (0, 1))
-                horiz_ax = plt.subplot2grid((1, 2), (0, 0))
-
-        # plot image and profile lines
-        if not self._from_device:
-            self._plot_image(image_ax, title=osp.basename(self._path))
-        self._plot_vert(vert_ax, grid)
-        self._plot_horiz(horiz_ax, grid)
-
-        # plot legend
-        lines = []
-        labels = []
-        v_lines, v_labels = vert_ax.get_legend_handles_labels()
-        h_lines, h_labels = horiz_ax.get_legend_handles_labels()
-        for label, line in zip(v_labels, v_lines):
-            if label not in labels:
-                lines.append(line)
-                labels.append(label)
-        for label, line in zip(h_labels, h_lines):
-            if label not in labels:
-                lines.append(line)
-                labels.append(label)
-        if not self._from_device:
-            if split_plots:
-                for ax in (vert_ax, horiz_ax):
-                    try:
-                        ax.legend(lines, labels, loc="center")
-                    except:#reduceshape  
-                        pass
-            else:
-                legend_ax = plt.subplot2grid((2, 2), (1, 0))
-                legend_ax.legend(lines, labels, loc="center")
-                legend_ax.axis("off")
-        else:
-            vert_ax.legend(
-                lines,
-                labels,
-                loc="best",
-            )
-        if not split_plots:
-            plt.suptitle("Field Profile Analysis")
-            plt.tight_layout()
-        else:
-            for fig in figs:
-                fig.tight_layout()
-        if show:
-            plt.show()
-        return figs, names
-
-    def save_analyzed_image(
-        self,
-        filename: None | str | Path | BinaryIO = None,
-        split_plots: bool = False,
-        to_streams: bool = False,
-        **kwargs,
-    ) -> list[str] | dict[str, BinaryIO] | None:
-        """Save the analyzed image to disk or to stream. Kwargs are passed to plt.savefig()
-
-        Parameters
-        ----------
-        split_plots: bool
-            If split_plots is True, multiple files will be created that append a name. E.g. `my_file.png` will become `my_file_image.png`, `my_file_vertical.png`, etc.
-            If to_streams is False, a list of new filenames will be returned
-        to_streams: bool
-            This only matters if split_plots is True. If both of these are true, multiple streams will be created and returned as a dict.
-        """
-        if filename is None and to_streams is False:
-            raise ValueError("Must pass in a filename unless saving to streams.")
-        figs, names = self.plot_analyzed_image(
-            show=False, split_plots=split_plots, **kwargs
-        )
-        if isinstance(filename, Path):
-            filename = str(filename)
-        for key in ("grid", "show"):
-            kwargs.pop(key, None)
-        if not split_plots:
-            plt.savefig(filename, **kwargs)
-        else:
-            # append names to filename if it's file-like
-            if not to_streams:
-                filenames = []
-                f, ext = osp.splitext(filename)
-                for name in names:
-                    filenames.append(f + name + ext)
-            else:  # it's a stream buffer
-                filenames = [io.BytesIO() for _ in names]
-            for fig, name in zip(figs, filenames):
-                fig.savefig(name, **kwargs)
-            if to_streams:
-                return {name: stream for name, stream in zip(names, filenames)}
-            if split_plots:
-                return filenames
-
-    def _plot_image(self, axis: plt.Axes = None, title: str = "") -> None:
-        """Plot the image and profile extraction overlay"""
-        if axis is None:
-            fig, axis = plt.subplots()
-        axis.imshow(self.image.array, cmap=get_dicom_cmap())
-
-        # vertical line/rect
-        width = abs(self._left_v_index - self._right_v_index)
-        center = (width / 2 + self._left_v_index, self.image.shape[0] / 2)
-        r = Rectangle(width=width, height=self.image.shape[0], center=center)
-        r.plot2axes(
-            axis,
-            edgecolor="b",
-            fill=True,
-            alpha=0.2,
-            facecolor="b",
-            label="Profile Extraction Area",
-        )
-
-        # horizontal line/rect
-        width_h = abs(self._upper_h_index - self._lower_h_index)
-        center_h = (self.image.shape[1] / 2, width_h / 2 + self._upper_h_index)
-        r = Rectangle(width=self.image.shape[1], height=width_h, center=center_h)
-        r.plot2axes(axis, edgecolor="b", fill=True, alpha=0.2, facecolor="b")
-
-        # cleanup
-        _remove_ticklabels(axis)
-        axis.set_title(title)
-        axis.legend()
-
-    def _plot_vert(self, axis: plt.Axes = None, grid: bool = True) -> None:
-        """Plot vertical profile"""
-        if axis is None:
-            fig, axis = plt.subplots()
-        axis.grid(grid)
-        axis.set_title("Vertical Profile")
-        if self._from_device:
-            axis.set_xlabel("detector")
-            if self._interpolation_method == Interpolation.NONE:
-                markers = "b+"
-            else:
-                markers = "b"
-        else:
-            axis.set_xlabel("pixels")
-            markers = "b"
-        axis.plot(
-            self.vert_profile.x_indices,
-            self.vert_profile.values,
-            markers,
-            label="Profile",
-        )
-        axis.set_ylabel("Normalized Response")
-
-        # plot second axis w/ physical distance
-        sec_y = axis.twiny()
-        physical_distance = self.vert_profile.x_indices / self.vert_profile.dpmm
-        sec_y.plot(physical_distance, self.vert_profile.values, markers)
-        sec_y.set_xlabel("mm")
-
-        # plot basic parameters on profile
-        self._plot_penumbra(self.vert_profile, axis)
-        self._plot_field_edges(self.vert_profile, axis)
-        if self._is_FFF:
-            self._plot_top(self.vert_profile, axis)
-            self._plot_infield_slope(self.vert_profile, axis)
-
-        for name, item in self._protocol.value.items():
-            if item.get("plot"):
-                item["plot"](self, self.vert_profile, axis)
-
-    def _plot_horiz(self, axis: plt.Axes = None, grid: bool = True) -> None:
-        """Plot horizontal profile"""
-        if axis is None:
-            fig, axis = plt.subplots()
-        axis.grid(grid)
-        axis.set_title("Horizontal Profile")
-        if self._from_device:
-            axis.set_xlabel("detector")
-            if self._interpolation_method == Interpolation.NONE:
-                markers = "b+"
-            else:
-                markers = "b"
-        else:
-            axis.set_xlabel("pixels")
-            markers = "b"
-        axis.plot(
-            self.horiz_profile.x_indices,
-            self.horiz_profile.values,
-            markers,
-            label="Profile",
-        )
-        axis.set_ylabel("Normalized Response")
-
-        # plot second axis w/ physical distance
-        sec_y = axis.twiny()
-        physical_distance = self.horiz_profile.x_indices / self.horiz_profile.dpmm
-        sec_y.plot(physical_distance, self.horiz_profile.values, markers)
-        sec_y.set_xlabel("mm")
-
-        # plot basic parameters on profile
-        self._plot_penumbra(self.horiz_profile, axis)
-        self._plot_field_edges(self.horiz_profile, axis)
-        if self._is_FFF:
-            self._plot_top(self.horiz_profile, axis)
-            self._plot_infield_slope(self.horiz_profile, axis)
-
-        for name, item in self._protocol.value.items():
-            if item.get("plot"):
-                item["plot"](self, self.horiz_profile, axis)
-
-    @staticmethod
-    def _save_plot(func, filename: str | io.BytesIO, **kwargs) -> None:
-        func(**kwargs)
-        # figure headers appear cut off on the PDF without a tight layout
-        plt.tight_layout()
-        plt.savefig(filename)
-
-    def _plot_penumbra(self, profile: SingleProfile, axis: plt.Axes = None) -> None:
-        """Plot the non-linear regression fit against the profile"""
-        data = profile.penumbra(self._penumbra[0], self._penumbra[1])
-        axis.axvline(x=data[f"left {self._penumbra[0]}% index (exact)"], color="pink")
-        axis.axvline(
-            x=data[f"left {self._penumbra[1]}% index (exact)"],
-            color="pink",
-            label="Penumbra region",
-        )
-        axis.axvline(x=data[f"right {self._penumbra[0]}% index (exact)"], color="pink")
-        axis.axvline(x=data[f"right {self._penumbra[1]}% index (exact)"], color="pink")
-        if self._edge_detection == Edge.INFLECTION_HILL:
-            # plot left side Hill fit
-            fw = (
-                profile.field_data(
-                    in_field_ratio=1.0,
-                    slope_exclusion_ratio=self._slope_exclusion_ratio,
-                )["width (exact)"]
-                * self._hill_window_ratio
-                / 2
-            )
-            left_hill_idx = int(
-                round(data[f"left {self._penumbra[0]}% index (exact)"] - fw)
-            )
-            right_hill_idx = int(
-                round(data[f"left {self._penumbra[1]}% index (exact)"] + fw)
-            )
-            infl_data = profile.inflection_data()
-            hill_fit = Hill.from_params(infl_data["left Hill params"])
-            l_x_data = np.linspace(left_hill_idx, right_hill_idx, 200)
-            axis.plot(l_x_data, hill_fit.y(l_x_data), color="black", label="Hill fit")
-
-            # plot right side Hill fit
-            left_hill_idx = int(
-                round(data[f"right {self._penumbra[1]}% index (exact)"] - fw)
-            )
-            right_hill_idx = int(
-                round(data[f"right {self._penumbra[0]}% index (exact)"] + fw)
-            )
-            hill_fit = Hill.from_params(infl_data["right Hill params"])
-            r_x_data = np.linspace(left_hill_idx, right_hill_idx, 200)
-            axis.plot(r_x_data, hill_fit.y(r_x_data), color="black", label="Hill fit")
-
-    def _plot_field_edges(self, profile: SingleProfile, axis: plt.Axes) -> None:
-        data = profile.field_data(
-            in_field_ratio=1.0, slope_exclusion_ratio=self._slope_exclusion_ratio
-        )
-        axis.plot(
-            data["left index (rounded)"],
-            data["left value (@rounded)"],
-            "x",
-            color="green",
-            label="Field edge",
-        )
-        axis.plot(
-            data["right index (rounded)"],
-            data["right value (@rounded)"],
-            "x",
-            color="green",
-        )
-
-    def _plot_infield_slope(self, profile: SingleProfile, axis: plt.Axes) -> None:
-        data = profile.field_data(self._in_field_ratio, self._slope_exclusion_ratio)
-        # left slope
-        left_x_values = range(
-            data["left index (rounded)"], data["left inner index (rounded)"]
-        )
-        left_y_values = data["left slope"] * left_x_values + data["left intercept"]
-        axis.plot(left_x_values, left_y_values, color="tomato", label="in-field slope")
-        # right slope
-        right_x_values = range(
-            data["right inner index (rounded)"], data["right index (rounded)"]
-        )
-        right_y_values = data["right slope"] * right_x_values + data["right intercept"]
-        axis.plot(right_x_values, right_y_values, color="tomato")
-
-    def _plot_top(self, profile: SingleProfile, axis: plt.Axes = None) -> None:
-        """Plot a second order polynomial to the peak of the FFF field"""
-        data = profile.field_data(self._in_field_ratio, self._slope_exclusion_ratio)
-        x_model = np.linspace(
-            data["left inner index (rounded)"],
-            data["right inner index (rounded)"],
-            1000,
-        )
-        y_model = (
-            data["top params"][0] * x_model**2
-            + data["top params"][1] * x_model
-            + data["top params"][2]
-        )
-        axis.plot(x_model, y_model, color="magenta", label='"top" polynomial fit')
-        axis.plot(
-            data['"top" index (exact)'],
-            data['"top" value (@exact)'],
-            "x",
-            color="magenta",
-            label='"top" position',
-        )
-
-
-class Device(Enum):
-    """2D array device Enum."""
-
-    PROFILER = {"device": SNCProfiler, "detector spacing (mm)": 5}  #:
-
-
-class DeviceFieldAnalysis(FieldAnalysis):
-    """Field analysis using a device array."""
-
-    def __init__(self, path: str, device: Device):
-        """
-        Parameters
-        ----------
-        path
-            Path to the file of the device output
-        device
-            The array device. Currently, the Profiler is supported. See :ref:`loading_device_data`.
-        """
-        self.device: Device = device.value["device"](path=path)  #:
-        self._path = path
-        self._from_device = True
-        self._dpmm = 1 / device.value["detector spacing (mm)"]
-
-    @classmethod
-    def from_demo_image(cls):
-        """Load the demo image into an instance."""
-        demo_file = retrieve_demo_file(name="6fff.prm")
-        return cls(demo_file, device=Device.PROFILER)
-
-    @staticmethod
-    def run_demo() -> None:
-        """Run the Field analysis demo by loading the demo device dataset, print results, and plot the profiles."""
-        fs = DeviceFieldAnalysis.from_demo_image()
-        fs.analyze(protocol=Protocol.VARIAN, is_FFF=True)
-        print(fs.results())
-        fs.plot_analyzed_image()
-
-    def analyze(
-        self,
-        protocol: Protocol = Protocol.VARIAN,
-        in_field_ratio: float = 0.8,
-        slope_exclusion_ratio: float = 0.3,
-        is_FFF: bool = False,
-        penumbra: tuple = (20, 80),
-        interpolation: Interpolation = Interpolation.NONE,
-        interpolation_resolution_mm: float = 0.1,
-        ground: bool = True,
-        normalization_method: Normalization = Normalization.GEOMETRIC_CENTER,
-        edge_detection_method: Edge = Edge.INFLECTION_HILL,
-        edge_smoothing_ratio: float = 0.003,
-        hill_window_ratio: float = 0.15,
-        **kwargs,
-    ) -> None:
-        """Analyze the device profiles to determine parameters such as field edges, penumbra, and/or flatness & symmetry.
-
-        Parameters
-        ----------
-        protocol
-            The analysis protocol. See :ref:`analysis_definitions` for equations and options.
-        in_field_ratio
-            The ratio of the field width to use for protocol values. E.g. 0.8 means use the 80% field width.
-        slope_exclusion_ratio
-            This is the ratio of the field to use to 1) calculate the "top" of an FFF field as well as 2) exclude from the
-            "slope" calculation of each side of the field. Alternatively, this also defines the area to use for the
-            slope calculation. E.g. an `in_field_ratio` of 0.8 and `slope_exclusion_ratio` of 0.2 means the central 20% of the
-            field is used to fit and calculate the "top", while the region on either side of the central 20% between the central
-            80% is used to calculate a slope on either side using linear regression.
-
-            .. note::
-
-                While the "top" is always calculated, it will not be displayed in plots if the `is_FFF` parameter is false.
-
-        is_FFF
-            This is a flag to display the "top" calculation and slopes on either side of the field.
-        penumbra
-            A tuple of (lower, higher) % of the penumbra to calculate. E.g. (20, 80) will calculate the penumbra width at 20% and 80%.
-
-            .. note::
-
-                The exact height of the penumbra depends on the edge detection method. E.g. FWHM will result in
-                calculating penumbra at 20/80% of the field max, but if something like inflection is used, the penumbra
-                height will be 20/50*100*inflection height and 80/50*100*inflection height.
-
-        interpolation
-            Interpolation technique to use. Must be one of the enum options of ``Interpolation``.
-        ground
-            Whether to ground the profile (set min value to 0). Helpful most of the time.
-        interpolation_resolution_mm
-            The resolution that the interpolation will scale to.
-            E.g. if the native dpmm is 2 and the resolution is set to 0.1mm the data will be interpolated to have a new dpmm of 10 (1/0.1).
-        normalization_method
-            How to pick the point to normalize the data to.
-        edge_detection_method
-            The method by which to detect the field edge. FWHM is reasonable most of the time except for FFF beams.
-            Inflection-derivative will use the max gradient to determine the field edge. Note that this may not be the
-            50% height. In fact, for FFF beams it shouldn't be. Inflection methods are better for FFF and other unusual
-            beam shapes.
-        edge_smoothing_ratio
-            The ratio of the length of the values to use as the sigma for a Gaussian filter applied before searching for
-            the inflection. E.g. 0.005 with a profile of 1000 points will result in a sigma of 5.
-            This helps make the inflection point detection more robust to noise. Increase for noisy data.
-        hill_window_ratio
-            The ratio of the field size to use as the window to fit the Hill function. E.g. 0.2 will using a window
-            centered about each edge with a width of 20% the size of the field width. Only applies when the edge
-            detection is ``INFLECTION_HILL``.
-        kwargs
-            Use these to pass parameters to custom protocol functions. See :ref:`custom_protocols`.
-        """
-        self._analyze(
-            edge_detection_method,
-            edge_smoothing_ratio,
-            ground,
-            None,
-            None,
-            in_field_ratio,
-            interpolation,
-            interpolation_resolution_mm,
-            is_FFF,
-            kwargs,
-            normalization_method,
-            penumbra,
-            protocol,
-            slope_exclusion_ratio,
-            None,
-            None,
-            Centering.MANUAL,
-            hill_window_ratio,
-        )
-
-    def _extract_profiles(
-        self,
-        horiz_position,
-        horiz_width,
-        interpolation_resolution_mm,
-        vert_position,
-        vert_width,
-        edge_detection_method,
-        edge_smoothing_ratio,
-        ground,
-        interpolation,
-        interpolation_resolution,
-        normalization_method,
-        centering,
-        hill_window_ratio,
-    ):
-        # calculate the profiles from the device. Since it's not an image, there's no position values
-        x_prof, y_prof, _, _ = self.device.to_profiles(
-            dpmm=self._dpmm,
-            interpolation=interpolation,
-            interpolation_resolution_mm=interpolation_resolution,
-            ground=ground,
-            edge_detection_method=edge_detection_method,
-            normalization_method=normalization_method,
-            edge_smoothing_ratio=edge_smoothing_ratio,
-            hill_window_ratio=hill_window_ratio,
-        )
-        self.vert_profile = y_prof
-        self.horiz_profile = x_prof
-
-    def results_data(self, as_dict: bool = False) -> FieldResult | dict:
-        """Present the results data and metadata as a dataclass or dict.
-        The default return type is a dataclass. Unlike vanilla FA, there is no central ROI since it's only profiles
-        """
-        data = DeviceResult(
-            **self._results,
-            protocol=self._protocol.name,
-            centering_method=getattr(self._centering, "value", None),
-            normalization_method=self.horiz_profile._norm_method.value,
-            interpolation_method=self.horiz_profile._interp_method.value,
-            edge_detection_method=self.horiz_profile._edge_method.value,
-            protocol_results=self._extra_results,
-        )
-        if as_dict:
-            return dataclasses.asdict(data)
-        return data
-
-
-def _remove_ticklabels(axis: plt.Axes):
-    axis.get_yaxis().set_ticklabels([])
-    axis.get_xaxis().set_ticklabels([])
+"""Module for performing analysis of images or 2D arrays for parameters such as flatness and symmetry."""
+from __future__ import annotations
+
+import io
+import os.path as osp
+import warnings
+import webbrowser
+from enum import Enum
+from math import ceil, floor
+from pathlib import Path
+from typing import BinaryIO, Callable
+
+import matplotlib.pyplot as plt
+import numpy as np
+
+from . import Centering
+from .core import image, pdf
+from .core.exceptions import NotAnalyzed
+from .core.geometry import Point, Rectangle
+from .core.hill import Hill
+from .core.io import SNCProfiler, retrieve_demo_file
+from .core.profile import Edge, Interpolation, Normalization, SingleProfile
+from .core.roi import RectangleROI
+from .core.utilities import ResultBase, ResultsDataMixin, convert_to_enum
+from .settings import get_dicom_cmap
+
+
+def flatness_dose_difference(
+    profile: SingleProfile, in_field_ratio: float = 0.8, **kwargs
+) -> float:
+    """The Varian specification for calculating flatness. See :ref:`varian_protocol`."""
+    try:
+        dmax = profile.field_calculation(
+            in_field_ratio=in_field_ratio,
+            calculation="max",
+            slope_exclusion_ratio=kwargs.get("slope_exclusion_ratio", 0.2),
+        )
+        dmin = profile.field_calculation(
+            in_field_ratio=in_field_ratio,
+            calculation="min",
+            slope_exclusion_ratio=kwargs.get("slope_exclusion_ratio", 0.2),
+        )
+    except OSError:
+        raise ValueError(
+            "An error was encountered in the flatness calculation. The image is likely inverted. Try inverting the image before analysis with <instance>.image.invert()."
+        )
+    flatness = 100 * abs(dmax - dmin) / (dmax + dmin)
+    return flatness
+
+
+def flatness_dose_ratio(
+    profile: SingleProfile, in_field_ratio: float = 0.8, **kwargs
+) -> float:
+    """The Elekta specification for calculating flatness. See :ref:`elekta_protocol`."""
+    try:
+        dmax = profile.field_calculation(
+            in_field_ratio=in_field_ratio, calculation="max"
+        )
+        dmin = profile.field_calculation(
+            in_field_ratio=in_field_ratio, calculation="min"
+        )
+    except ValueError:
+        raise ValueError(
+            "An error was encountered in the flatness calculation. The image is likely inverted. Try inverting the image before analysis with <instance>.image.invert()."
+        )
+    flatness = 100 * (dmax / dmin)
+    return flatness
+
+
+def plot_flatness(instance, profile: SingleProfile, axis: plt.Axes) -> None:
+    """Plot flatness parameters. Applies to both flatness dose ratio and dose difference."""
+    data = profile.field_data(
+        in_field_ratio=instance._in_field_ratio,
+        slope_exclusion_ratio=instance._slope_exclusion_ratio,
+    )
+    axis.axhline(
+        np.max(data["field values"]), color="g", linestyle="-.", label="Flatness region"
+    )
+    axis.axhline(np.min(data["field values"]), color="g", linestyle="-.")
+
+
+def symmetry_point_difference(
+    profile: SingleProfile, in_field_ratio: float, **kwargs
+) -> float:
+    """Calculation of symmetry by way of point difference equidistant from the CAX. See :ref:`varian_protocol`.
+
+    A negative value means the right side is higher. A positive value means the left side is higher.
+    """
+    field = profile.field_data(
+        in_field_ratio=in_field_ratio,
+        slope_exclusion_ratio=kwargs.get("slope_exclusion_ratio", 0.2),
+    )
+    field_values = field["field values"]
+    cax_value = field["beam center value (@rounded)"]
+
+    def calc_sym(lt, rt, cax) -> float:
+        return 100 * (lt - rt) / cax
+
+    # get value w/ max magnitude
+    sym_vals = [
+        calc_sym(lt, rt, cax_value) for lt, rt in zip(field_values, field_values[::-1])
+    ]
+    max_sym_idx = np.argmax(np.abs(sym_vals))
+    return sym_vals[max_sym_idx]
+
+
+def plot_symmetry_point_difference(
+    instance, profile: SingleProfile, axis: plt.Axes
+) -> None:
+    """Plotting of the symmetry point difference."""
+
+    def calc_sym(lt, rt, cax) -> float:
+        return 100 * abs(lt - rt) / cax
+
+    _plot_sym_common(
+        instance, calc_sym, profile, axis, label="Symmetry (%)", padding=(5, 0.5)
+    )
+
+
+def _plot_sym_common(
+    instance,
+    calc_func: Callable,
+    profile: SingleProfile,
+    axis: plt.Axes,
+    label: str,
+    padding: tuple,
+) -> None:
+    field = profile.field_data(
+        in_field_ratio=instance._in_field_ratio,
+        slope_exclusion_ratio=instance._slope_exclusion_ratio,
+    )
+    field_values = field["field values"]
+    left_idx = field["left index (rounded)"]
+    right_idx = field["right index (rounded)"]
+    cax_value = field["beam center value (@rounded)"]
+
+    # same calc as PDQ and point difference, except we find the INDEX where the symmetry is maximum
+    sym_values = [
+        calc_func(lt, rt, cax_value)
+        for lt, rt, _ in zip(
+            field_values, field_values[::-1], range(int(round(len(field_values) / 2)))
+        )
+    ]
+
+    idx = np.argmax(sym_values)
+    axis.plot(
+        field["left index (rounded)"] + idx,
+        profile._y_original_to_interp(field["left index (rounded)"] + idx),
+        "*",
+        color="red",
+        label="Symmetry max",
+    )
+    axis.plot(
+        field["right index (rounded)"] - idx,
+        profile._y_original_to_interp(field["right index (rounded)"] - idx),
+        "*",
+        color="red",
+    )
+    sec_ax = axis.twinx()
+    sec_ax.set_ylabel(label)
+
+    # squish the secondary graph so it's not so large-looking
+    ylim_top = max(sym_values) + padding[0]
+    ylim_bottom = min(sym_values) - padding[1]
+    sec_ax.set_ylim(ylim_bottom, ylim_top)
+    left_end = int(round(left_idx + (right_idx - left_idx) / 2))
+    sec_ax.plot(range(left_end, left_end + len(sym_values)), sym_values[::-1])
+
+
+def plot_symmetry_pdq(instance, profile: SingleProfile, axis: plt.Axes) -> None:
+    """Plotting of the symmetry point difference quotient."""
+
+    def calc_sym(lt, rt, _) -> float:
+        return max(abs(lt / rt), abs(rt / lt))
+
+    _plot_sym_common(
+        instance, calc_sym, profile, axis, label="Symmetry (AU)", padding=(0.05, 0.01)
+    )
+
+
+def symmetry_pdq_iec(profile: SingleProfile, in_field_ratio: float, **kwargs) -> float:
+    """Symmetry calculation by way of PDQ IEC. See :ref:`elekta_protocol`.
+
+    A negative value means the right side is higher. A positive value means the left side is higher.
+    """
+    field = profile.field_data(
+        in_field_ratio=in_field_ratio,
+        slope_exclusion_ratio=kwargs.get("slope_exclusion_ratio", 0.2),
+    )
+    field_values = field["field values"]
+
+    def calc_sym(lt, rt) -> float:
+        sym1 = lt / rt
+        sym2 = rt / lt
+        if abs(sym1) > abs(sym2):
+            sign = np.sign(sym1)
+        else:
+            sign = np.sign(sym2)
+        return max(abs(lt / rt), abs(rt / lt)) * sign
+
+    sym_values = [calc_sym(lt, rt) for lt, rt in zip(field_values, field_values[::-1])]
+    sym_idx = np.argmax(np.abs(sym_values))
+
+    return sym_values[sym_idx]
+
+
+def symmetry_area(profile: SingleProfile, in_field_ratio: float, **kwargs) -> float:
+    """Ratio of the area under the left and right profile segments.  See :ref:`siemens_protocol`.
+
+    A negative value indicates the right side is higher; a positive value indicates the left side is higher.
+    """
+    data = profile.field_data(
+        in_field_ratio=in_field_ratio,
+        slope_exclusion_ratio=kwargs.get("slope_exclusion_ratio", 0.2),
+    )
+    cax_idx = data["beam center index (exact)"] - data["left index (exact)"]
+    area_left = np.sum(data["field values"][: floor(cax_idx)])
+    area_right = np.sum(data["field values"][ceil(cax_idx) :])
+    symmetry = 100 * (area_left - area_right) / (area_left + area_right)
+    return symmetry
+
+
+def plot_symmetry_area(instance, profile: SingleProfile, axis: plt.Axes) -> None:
+    """PLot the symmetry area."""
+    data = profile.field_data(
+        in_field_ratio=instance._in_field_ratio,
+        slope_exclusion_ratio=instance._slope_exclusion_ratio,
+    )
+    cax_idx = data["beam center index (exact)"]
+    left_idx = data["left index (rounded)"]
+    right_idx = data["right index (rounded)"]
+
+    axis.fill_between(
+        range(left_idx, floor(cax_idx)),
+        data["field values"][: floor(cax_idx) - left_idx],
+        color="green",
+        alpha=0.1,
+        label="Left Area",
+    )
+    arr1 = np.array(range(ceil(cax_idx), right_idx))
+    arr2 = data["field values"][ceil(cax_idx) - left_idx :]
+    if arr1.shape < arr2.shape:
+        arr1_padded = np.pad(arr1, (0, len(arr2) - len(arr1)), 'constant', constant_values=(0, 0))
+        x= arr1_padded.tolist()
+        y1 = arr2
+    elif arr1.shape > arr2.shape:        
+        arr2_padded = np.pad(arr2, (0, len(arr1) - len(arr2)), 'constant', constant_values=(0, 0))
+        x= arr1.tolist()
+        y1 = arr2_padded.tolist()
+    else:
+        x= arr1.tolist()
+        y1 = arr2
+    axis.fill_between(
+        x,
+        y1,
+        color="slateblue",
+        alpha=0.1,
+        label="Right Area",
+    )
+
+
+varian_protocol = {
+    "symmetry": {
+        "calc": symmetry_point_difference,
+        "unit": "%",
+        "plot": plot_symmetry_point_difference,
+    },
+    "flatness": {"calc": flatness_dose_difference, "unit": "%", "plot": plot_flatness},
+}
+elekta_protocol = {
+    "symmetry": {"calc": symmetry_pdq_iec, "unit": "", "plot": plot_symmetry_pdq},
+    "flatness": {"calc": flatness_dose_ratio, "unit": "", "plot": plot_flatness},
+}
+siemens_protocol = {
+    "symmetry": {"calc": symmetry_area, "unit": "", "plot": plot_symmetry_area},
+    "flatness": {"calc": flatness_dose_difference, "unit": "", "plot": plot_flatness},
+}
+
+
+class Protocol(Enum):
+    """Protocols to analyze additional metrics of the field. See :ref:`analysis_definitions`"""
+
+    NONE = {}  #:
+    VARIAN = varian_protocol  #:
+    SIEMENS = siemens_protocol  #:
+    ELEKTA = elekta_protocol  #:
+
+
+class DeviceResult(ResultBase):
+    protocol: str  #:
+    protocol_results: dict  #:
+    centering_method: str | None  #:
+    normalization_method: str | None  #:
+    interpolation_method: str | None  #:
+    edge_detection_method: str  #:
+    top_penumbra_mm: float  #:
+    bottom_penumbra_mm: float  #:
+    left_penumbra_mm: float  #:
+    right_penumbra_mm: float  #:
+    geometric_center_index_x_y: tuple[float, float]  #:
+    beam_center_index_x_y: tuple[float, float]  #:
+    field_size_vertical_mm: float  #:
+    field_size_horizontal_mm: float  #:
+    beam_center_to_top_mm: float  #:
+    beam_center_to_bottom_mm: float  #:
+    beam_center_to_left_mm: float  #:
+    beam_center_to_right_mm: float  #:
+    cax_to_top_mm: float  #:
+    cax_to_bottom_mm: float  #:
+    cax_to_left_mm: float  #:
+    cax_to_right_mm: float  #:
+    top_position_index_x_y: tuple[float, float]  #:
+    top_horizontal_distance_from_cax_mm: float  #:
+    top_vertical_distance_from_cax_mm: float  #:
+    top_horizontal_distance_from_beam_center_mm: float  #:
+    top_vertical_distance_from_beam_center_mm: float  #:
+    left_slope_percent_mm: float  #:
+    right_slope_percent_mm: float  #:
+    top_slope_percent_mm: float  #:
+    bottom_slope_percent_mm: float  #:
+    top_penumbra_percent_mm: float = 0  #:
+    bottom_penumbra_percent_mm: float = 0  #:
+    left_penumbra_percent_mm: float = 0  #:
+    right_penumbra_percent_mm: float = 0  #:
+
+
+class FieldResult(DeviceResult):
+    """This class should not be called directly. It is returned by the ``results_data()`` method.
+    It is a dataclass under the hood and thus comes with all the dunder magic.
+
+    Use the following attributes as normal class attributes.
+
+    In addition to the below attrs, custom protocol data will also be attached under the
+    ``protocol_results`` attr as a dictionary with keys like so:
+    ``<protocol name>_vertical`` and ``<protocol name>_horizontal`` for each protocol item.
+
+    E.g. a protocol item of ``symmetry`` will result in ``symmetry_vertical`` and ``symmetry_horizontal``.
+    """
+
+    central_roi_mean: float = 0  #:
+    central_roi_max: float = 0  #:
+    central_roi_std: float = 0  #:
+    central_roi_min: float = 0  #:
+
+
+class FieldAnalysis(ResultsDataMixin[FieldResult]):
+    """Class for analyzing the various parameters of a radiation image, most commonly an open image from a linac."""
+
+    def __init__(
+        self,
+        path: str | BinaryIO,
+        filter: int | None = None,
+        image_kwargs: dict | None = None,
+    ):
+        """
+
+
+        Parameters
+        ----------
+        path
+            The path to the image.
+        filter
+            If None, no filter is applied. If an int, a median filter of size n pixels is applied. Generally, a good idea.
+            Default is None for backwards compatibility.
+        """
+        self._path: str = path
+        img_kwargs = image_kwargs or {}
+        self.image: image.ImageLike = image.load(path, **img_kwargs)  #:
+        if filter:
+            self.image.filter(size=filter)
+        self.vert_profile: SingleProfile  #:
+        self.horiz_profile: SingleProfile  #:
+        self._is_analyzed: bool = False
+        self._from_device: bool = False
+        self.image.check_inversion_by_histogram()
+
+    @classmethod
+    def from_demo_image(cls):
+        """Load the demo image into an instance."""
+        demo_file = retrieve_demo_file(name="flatsym_demo.dcm")
+        return cls(demo_file)
+
+    @staticmethod
+    def run_demo() -> None:
+        """Run the Field Analysis demo by loading the demo image, print results, and plot the profiles."""
+        fs = FieldAnalysis.from_demo_image()
+        fs.analyze(protocol=Protocol.VARIAN)
+        print(fs.results())
+        fs.plot_analyzed_image()
+
+    def _determine_center(self, centering: Centering) -> tuple[float, float]:
+        """Determine the position ratio using a centering technique."""
+        vert_sum = np.sum(self.image.array, axis=1)
+        horiz_sum = np.sum(self.image.array, axis=0)
+        v_prof = SingleProfile(vert_sum)
+        h_prof = SingleProfile(horiz_sum)
+        if centering == Centering.GEOMETRIC_CENTER:
+            # horiz and vert appear switched, but it's because the center of the vert profile
+            # is where to take the horizontal profile and vic versa
+            horiz_ratio = (
+                v_prof.geometric_center()["index (exact)"] / self.image.shape[0]
+            )
+            vert_ratio = (
+                h_prof.geometric_center()["index (exact)"] / self.image.shape[1]
+            )
+        elif centering == Centering.BEAM_CENTER:
+            horiz_ratio = v_prof.beam_center()["index (exact)"] / self.image.shape[0]
+            vert_ratio = h_prof.beam_center()["index (exact)"] / self.image.shape[1]
+        return vert_ratio, horiz_ratio
+
+    def _extract_profiles(
+        self,
+        horiz_position,
+        horiz_width,
+        interpolation_resolution_mm,
+        vert_position,
+        vert_width,
+        edge_detection_method,
+        edge_smoothing_ratio,
+        ground,
+        interpolation,
+        interpolation_resolution,
+        normalization_method,
+        centering,
+        hill_window_ratio,
+    ) -> None:
+        """Figures out 1) where to extract the profiles from the image and 2) sets the profiles to instance attrs"""
+
+        # calculate the horiz/vert extraction positions if necessary
+        if centering in (Centering.BEAM_CENTER, Centering.GEOMETRIC_CENTER):
+            vert_position, horiz_position = self._determine_center(centering)
+
+        # calculate the profiles
+        horiz_values, upper_h_idx, lower_h_idx = self._get_horiz_values(
+            horiz_position, horiz_width
+        )
+        self._upper_h_index = upper_h_idx
+        self._lower_h_index = lower_h_idx
+        self.horiz_profile = SingleProfile(
+            horiz_values,
+            dpmm=self.image.dpmm,
+            interpolation=interpolation,
+            interpolation_resolution_mm=interpolation_resolution_mm,
+            ground=ground,
+            edge_detection_method=edge_detection_method,
+            normalization_method=normalization_method,
+            edge_smoothing_ratio=edge_smoothing_ratio,
+            hill_window_ratio=hill_window_ratio,
+        )
+
+        vert_values, left_v_idx, right_v_idx = self._get_vert_values(
+            vert_position, vert_width
+        )
+        self._left_v_index = left_v_idx
+        self._right_v_index = right_v_idx
+        self.vert_profile = SingleProfile(
+            vert_values,
+            dpmm=self.image.dpmm,
+            interpolation=interpolation,
+            interpolation_resolution_mm=interpolation_resolution_mm,
+            ground=ground,
+            edge_detection_method=edge_detection_method,
+            normalization_method=normalization_method,
+            edge_smoothing_ratio=edge_smoothing_ratio,
+            hill_window_ratio=hill_window_ratio,
+        )
+
+    def analyze(
+        self,
+        protocol: Protocol = Protocol.VARIAN,
+        centering: Centering | str = Centering.BEAM_CENTER,
+        vert_position: float = 0.5,
+        horiz_position: float = 0.5,
+        vert_width: float = 0,
+        horiz_width: float = 0,
+        in_field_ratio: float = 0.8,
+        slope_exclusion_ratio: float = 0.2,
+        invert: bool = False,
+        is_FFF: bool = False,
+        penumbra: tuple[float, float] = (20, 80),
+        interpolation: Interpolation | str | None = Interpolation.LINEAR,
+        interpolation_resolution_mm: float = 0.1,
+        ground: bool = True,
+        normalization_method: Normalization | str = Normalization.BEAM_CENTER,
+        edge_detection_method: Edge | str = Edge.INFLECTION_DERIVATIVE,
+        edge_smoothing_ratio: float = 0.003,
+        hill_window_ratio: float = 0.15,
+        **kwargs,
+    ) -> None:
+        """Analyze the image to determine parameters such as field edges, penumbra, and/or flatness & symmetry.
+
+        Parameters
+        ----------
+        protocol : :class:`~pylinac.field_analysis.Protocol`
+            The analysis protocol. See :ref:`analysis_definitions` for equations.
+        centering : :class:`~pylinac.Centering`
+            The profile extraction position technique. Beam center will determine the beam center and take profiles through the middle.
+            Geometric center will simply take profiles centered about the image in both axes.
+            Manual will use the values of `vert_position` and `horiz_position` as the position.
+            See :ref:`centering`.
+        vert_position
+            The distance ratio of the image to sample. E.g. at the default of 0.5 the profile is extracted
+            in the middle of the image. 0.0 is at the left edge of the image and 1.0 is at the right edge of the image.
+
+            .. note::
+
+                This value only applies when centering is MANUAL.
+
+        horiz_position
+            The distance ratio of the image to sample. E.g. at the default of 0.5 the profile is extracted
+            in the middle of the image. 0.0 is at the top edge of the image and 1.0 is at the bottom edge of the image.
+
+            .. note::
+
+                This value only applies when centering is MANUAL.
+
+        vert_width
+            The width ratio of the image to sample. E.g. at the default of 0.0 a 1 pixel wide profile is extracted.
+            0.0 would be 1 pixel wide and 1.0 would be the vertical image width.
+        horiz_width
+            The width ratio of the image to sample. E.g. at the default of 0.0 a 1 pixel wide profile is extracted.
+            0.0 would be 1 pixel wide and 1.0 would be the horizontal image width.
+        in_field_ratio
+            The ratio of the field width to use for protocol values. E.g. 0.8 means use the 80% field width.
+        slope_exclusion_ratio
+            This is the ratio of the field to use to 1) calculate the "top" of an FFF field as well as 2) exclude from the
+            "slope" calculation of each side of the field. Alternatively, this also defines the area to use for the
+            slope calculation. E.g. an `in_field_ratio` of 0.8 and `slope_exclusion_ratio` of 0.2 means the central 20% of the
+            field is used to fit and calculate the "top", while the region on either side of the central 20% between the central
+            80% is used to calculate a slope on either side using linear regression.
+
+            .. note::
+
+                While the "top" is always calculated, it will not be displayed in plots if the `is_FFF` parameter is false.
+
+        invert
+            Whether to invert the image. Setting this to True will override the default inversion. This is useful if
+            pylinac's automatic inversion is incorrect.
+        is_FFF
+            This is a flag to display the "top" calculation and slopes on either side of the field.
+        penumbra
+            A tuple of (lower, higher) % of the penumbra to calculate. E.g. (20, 80) will calculate the penumbra width at 20% and 80%.
+
+            .. note::
+
+                The exact height of the penumbra depends on the edge detection method. E.g. FWHM will result in
+                calculating penumbra at 20/80% of the field max, but if something like inflection is used, the penumbra
+                height will be 20/50*100*inflection height and 80/50*100*inflection height.
+
+        ground
+            Whether to ground the profile (set min value to 0). Helpful most of the time.
+        interpolation
+            Interpolation technique to use. See :ref:`Interpolation`.
+        interpolation_resolution_mm
+            The resolution that the interpolation will scale to.
+            E.g. if the native dpmm is 2 and the resolution is set to 0.1mm the data will be interpolated to have a new dpmm of 10 (1/0.1).
+        normalization_method
+            How to pick the point to normalize the data to. See :ref:`Normalization`.
+        edge_detection_method
+            The method by which to detect the field edge. FWHM is reasonable most of the time except for FFF beams.
+            Inflection-derivative will use the max gradient to determine the field edge. Note that this may not be the
+            50% height. In fact, for FFF beams it shouldn't be. Inflection methods are better for FFF and other unusual
+            beam shapes. See :ref:`edge`.
+        edge_smoothing_ratio
+            The ratio of the length of the values to use as the sigma for a Gaussian filter applied before searching for
+            the inflection. E.g. 0.005 with a profile of 1000 points will result in a sigma of 5.
+            This helps make the inflection point detection more robust to noise. Increase for noisy data.
+        hill_window_ratio
+            The ratio of the field size to use as the window to fit the Hill function. E.g. 0.2 will using a window
+            centered about each edge with a width of 20% the size of the field width. Only applies when the edge
+            detection is ``INFLECTION_HILL``.
+        kwargs
+            Use these to pass parameters to custom protocol functions. See :ref:`custom_protocols`.
+        """
+        if is_FFF and edge_detection_method == Edge.FWHM:
+            warnings.warn(
+                "Using FWHM for an FFF beam is not advised. Consider using INFLECTION_DERIVATIVE or INFLECTION_HILL"
+            )
+        if invert:
+            self.image.invert()
+        edge_detection_method = convert_to_enum(edge_detection_method, Edge)
+        interpolation = convert_to_enum(interpolation, Interpolation)
+        normalization_method = convert_to_enum(normalization_method, Normalization)
+        centering = convert_to_enum(centering, Centering)
+
+        self._analyze(
+            edge_detection_method,
+            edge_smoothing_ratio,
+            ground,
+            horiz_position,
+            horiz_width,
+            in_field_ratio,
+            interpolation,
+            interpolation_resolution_mm,
+            is_FFF,
+            kwargs,
+            normalization_method,
+            penumbra,
+            protocol,
+            slope_exclusion_ratio,
+            vert_position,
+            vert_width,
+            centering,
+            hill_window_ratio,
+        )
+
+    def _analyze(
+        self,
+        edge_detection_method,
+        edge_smoothing_ratio,
+        ground,
+        horiz_position,
+        horiz_width,
+        in_field_ratio,
+        interpolation,
+        interpolation_resolution_mm,
+        is_FFF,
+        kwargs,
+        normalization_method,
+        penumbra,
+        protocol,
+        slope_exclusion_ratio,
+        vert_position,
+        vert_width,
+        centering,
+        hill_window_ratio,
+    ):
+        self._protocol = protocol
+        self._penumbra = penumbra
+        self._centering = convert_to_enum(centering, Centering)
+        self._is_FFF: bool = is_FFF
+        self._edge_detection = convert_to_enum(edge_detection_method, Edge)
+        self._in_field_ratio = in_field_ratio
+        self._slope_exclusion_ratio = slope_exclusion_ratio
+        self._hill_window_ratio = hill_window_ratio
+        self._interpolation_method = convert_to_enum(interpolation, Interpolation)
+        self._normalization_method = convert_to_enum(
+            normalization_method, Normalization
+        )
+        self._extract_profiles(
+            horiz_position,
+            horiz_width,
+            interpolation_resolution_mm,
+            vert_position,
+            vert_width,
+            self._edge_detection,
+            edge_smoothing_ratio,
+            ground,
+            self._interpolation_method,
+            interpolation_resolution_mm,
+            self._normalization_method,
+            self._centering,
+            hill_window_ratio,
+        )
+        self._results = {}
+
+        # calculate the central ROI data within the vert and horiz windows
+        if not self._from_device:
+            width = max(abs(self._left_v_index - self._right_v_index), 2)
+            height = max(abs(self._upper_h_index - self._lower_h_index), 2)
+            center = Point(
+                width / 2 + self._left_v_index, height / 2 + self._upper_h_index
+            )
+            self.central_roi = RectangleROI(
+                array=self.image.array,
+                width=width,
+                height=height,
+                phantom_center=center,
+                angle=0,
+                dist_from_center=0,
+            )
+
+        # calculate common field info
+        v_pen = self.vert_profile.penumbra(penumbra[0], penumbra[1])
+        h_pen = self.horiz_profile.penumbra(penumbra[0], penumbra[1])
+        self._results["top_penumbra_mm"] = v_pen["left penumbra width (exact) mm"]
+        self._results["bottom_penumbra_mm"] = v_pen["right penumbra width (exact) mm"]
+        self._results["left_penumbra_mm"] = h_pen["left penumbra width (exact) mm"]
+        self._results["right_penumbra_mm"] = h_pen["right penumbra width (exact) mm"]
+        if edge_detection_method == Edge.INFLECTION_HILL:
+            self._results["top_penumbra_percent_mm"] = abs(
+                v_pen["left gradient (exact) %/mm"]
+            )
+            self._results["bottom_penumbra_percent_mm"] = abs(
+                v_pen["right gradient (exact) %/mm"]
+            )
+            self._results["left_penumbra_percent_mm"] = abs(
+                h_pen["left gradient (exact) %/mm"]
+            )
+            self._results["right_penumbra_percent_mm"] = abs(
+                h_pen["right gradient (exact) %/mm"]
+            )
+        self._results["geometric_center_index_x_y"] = (
+            self.horiz_profile.geometric_center()["index (exact)"],
+            self.vert_profile.geometric_center()["index (exact)"],
+        )
+        self._results["beam_center_index_x_y"] = (
+            self.horiz_profile.beam_center()["index (exact)"],
+            self.vert_profile.beam_center()["index (exact)"],
+        )
+        self._results["field_size_vertical_mm"] = self.vert_profile.field_data(
+            in_field_ratio=1.0, slope_exclusion_ratio=slope_exclusion_ratio
+        )["width (exact) mm"]
+        self._results["field_size_horizontal_mm"] = self.horiz_profile.field_data(
+            in_field_ratio=1.0, slope_exclusion_ratio=slope_exclusion_ratio
+        )["width (exact) mm"]
+        self._results["beam_center_to_top_mm"] = self.vert_profile.field_data(
+            in_field_ratio=1.0, slope_exclusion_ratio=slope_exclusion_ratio
+        )["left distance->beam center (exact) mm"]
+        self._results["beam_center_to_bottom_mm"] = self.vert_profile.field_data(
+            in_field_ratio=1.0, slope_exclusion_ratio=slope_exclusion_ratio
+        )["right distance->beam center (exact) mm"]
+        self._results["beam_center_to_left_mm"] = self.horiz_profile.field_data(
+            in_field_ratio=1.0, slope_exclusion_ratio=slope_exclusion_ratio
+        )["left distance->beam center (exact) mm"]
+        self._results["beam_center_to_right_mm"] = self.horiz_profile.field_data(
+            in_field_ratio=1.0, slope_exclusion_ratio=slope_exclusion_ratio
+        )["right distance->beam center (exact) mm"]
+        self._results["cax_to_top_mm"] = self.vert_profile.field_data(
+            in_field_ratio=1.0, slope_exclusion_ratio=slope_exclusion_ratio
+        )["left distance->CAX (exact) mm"]
+        self._results["cax_to_bottom_mm"] = self.vert_profile.field_data(
+            in_field_ratio=1.0, slope_exclusion_ratio=slope_exclusion_ratio
+        )["right distance->CAX (exact) mm"]
+        self._results["cax_to_left_mm"] = self.horiz_profile.field_data(
+            in_field_ratio=1.0, slope_exclusion_ratio=slope_exclusion_ratio
+        )["left distance->CAX (exact) mm"]
+        self._results["cax_to_right_mm"] = self.horiz_profile.field_data(
+            in_field_ratio=1.0, slope_exclusion_ratio=slope_exclusion_ratio
+        )["right distance->CAX (exact) mm"]
+
+        h_field_data = self.horiz_profile.field_data(
+            in_field_ratio=in_field_ratio, slope_exclusion_ratio=slope_exclusion_ratio
+        )
+        v_field_data = self.vert_profile.field_data(
+            in_field_ratio=in_field_ratio, slope_exclusion_ratio=slope_exclusion_ratio
+        )
+        self._results["top_position_index_x_y"] = (
+            h_field_data['"top" index (exact)'],
+            v_field_data['"top" index (exact)'],
+        )
+        self._results["top_horizontal_distance_from_cax_mm"] = h_field_data[
+            '"top"->CAX (exact) mm'
+        ]
+        self._results["top_vertical_distance_from_cax_mm"] = v_field_data[
+            '"top"->CAX (exact) mm'
+        ]
+        self._results["top_horizontal_distance_from_beam_center_mm"] = h_field_data[
+            '"top"->beam center (exact) mm'
+        ]
+        self._results["top_vertical_distance_from_beam_center_mm"] = v_field_data[
+            '"top"->beam center (exact) mm'
+        ]
+        self._results["left_slope_percent_mm"] = h_field_data["left slope (%/mm)"]
+        self._results["right_slope_percent_mm"] = h_field_data["right slope (%/mm)"]
+        self._results["top_slope_percent_mm"] = v_field_data["left slope (%/mm)"]
+        self._results["bottom_slope_percent_mm"] = v_field_data["right slope (%/mm)"]
+
+        # calculate protocol info
+        self._extra_results = {}
+        kwargs.update({"slope_exclusion_ratio": slope_exclusion_ratio})
+        for name, item in protocol.value.items():
+            self._extra_results[f"{name}_horizontal"] = item["calc"](
+                self.horiz_profile, in_field_ratio, **kwargs
+            )
+            self._extra_results[f"{name}_vertical"] = item["calc"](
+                self.vert_profile, in_field_ratio, **kwargs
+            )
+        self._is_analyzed = True
+
+    def results(self, as_str=True) -> str:
+        """Get the results of the analysis.
+
+        Parameters
+        ----------
+        as_str
+            If True, return a simple string. If False, return a list of each line of text.
+        """
+        if not self._is_analyzed:
+            raise NotAnalyzed("Image is not analyzed yet. Use analyze() first.")
+
+        results = [
+            "Field Analysis Results",
+            "----------------------",
+            f"File: {self._path}",
+            f"Protocol: {self._protocol.name}",
+        ]
+        if not self._from_device:
+            results += [
+                f"Centering method: {self._centering.value}",
+            ]
+        results += [
+            f"Normalization method: {self.horiz_profile._norm_method.value}",
+            f"Interpolation: {self.horiz_profile._interp_method.value}",
+            f"Edge detection method: {self.horiz_profile._edge_method.value}",
+            "",
+            f"Penumbra width ({self._penumbra[0]}/{self._penumbra[1]}):",
+            f"Left: {self._results['left_penumbra_mm']:3.1f}mm",
+            f"Right: {self._results['right_penumbra_mm']:3.1f}mm",
+            f"Top: {self._results['top_penumbra_mm']:3.1f}mm",
+            f"Bottom: {self._results['bottom_penumbra_mm']:3.1f}mm",
+            "",
+        ]
+        if self._edge_detection == Edge.INFLECTION_HILL:
+            results += [
+                "Penumbra gradients:",
+                f"Left gradient: {self._results['left_penumbra_percent_mm']:3.2f}%/mm",
+                f"Right gradient: {self._results['right_penumbra_percent_mm']:3.2f}%/mm",
+                f"Top gradient: {self._results['top_penumbra_percent_mm']:3.2f}%/mm",
+                f"Bottom gradient: {self._results['bottom_penumbra_percent_mm']:3.2f}%/mm",
+                "",
+            ]
+        results += [
+            "Field Size:",
+            f"Horizontal: {self._results['field_size_horizontal_mm']:3.1f}mm",
+            f"Vertical: {self._results['field_size_vertical_mm']:3.1f}mm",
+            "",
+            "CAX to edge distances:",
+            f"CAX -> Top edge: {self._results['cax_to_top_mm']:3.1f}mm",
+            f"CAX -> Bottom edge: {self._results['cax_to_bottom_mm']:3.1f}mm",
+            f"CAX -> Left edge: {self._results['cax_to_left_mm']:3.1f}mm",
+            f"CAX -> Right edge: {self._results['cax_to_right_mm']:3.1f}mm",
+            "",
+        ]
+        if not self._from_device:
+            results += [
+                "Central ROI stats:",
+                f"Mean: {self.central_roi.mean}",
+                f"Max: {self.central_roi.max}",
+                f"Min: {self.central_roi.min}",
+                f"Standard deviation: {self.central_roi.std}",
+                "",
+            ]
+        if self._is_FFF:
+            results += [
+                "'Top' vertical distance from CAX: {:3.1f}mm".format(
+                    self._results["top_vertical_distance_from_cax_mm"]
+                ),
+                "'Top' horizontal distance from CAX: {:3.1f}mm".format(
+                    self._results["top_horizontal_distance_from_cax_mm"]
+                ),
+                "'Top' vertical distance from beam center: {:3.1f}mm".format(
+                    self._results["top_vertical_distance_from_beam_center_mm"]
+                ),
+                "'Top' horizontal distance from beam center: {:3.1f}mm".format(
+                    self._results["top_horizontal_distance_from_beam_center_mm"]
+                ),
+                "",
+            ]
+        results += [
+            f"Top slope: {self._results['top_slope_percent_mm']:3.3f}%/mm",
+            f"Bottom slope: {self._results['bottom_slope_percent_mm']:3.3f}%/mm",
+            f"Left slope: {self._results['left_slope_percent_mm']:3.3f}%/mm",
+            f"Right slope: {self._results['right_slope_percent_mm']:3.3f}%/mm",
+            "",
+            "Protocol data:",
+            "--------------",
+        ]
+
+        for name, item in self._protocol.value.items():
+            results.append(
+                f"Vertical {name}: {self._extra_results[name + '_vertical']:3.3f}{item['unit']}"
+            )
+            results.append(
+                f"Horizontal {name}: {self._extra_results[name + '_horizontal']:3.3f}{item['unit']}"
+            )
+            results.append("")
+
+        if as_str:
+            results = "\n".join(result for result in results)
+        return results
+
+    def _generate_results_data(self) -> FieldResult:
+        """Present the results data and metadata as a dataclass or dict.
+        The default return type is a dataclass."""
+        return FieldResult(
+            **self._results,
+            protocol=self._protocol.name,
+            centering_method=getattr(self._centering, "value", None),
+            normalization_method=self.horiz_profile._norm_method.value,
+            interpolation_method=self.horiz_profile._interp_method.value,
+            edge_detection_method=self.horiz_profile._edge_method.value,
+            protocol_results=self._extra_results,
+            central_roi_max=self.central_roi.max,
+            central_roi_mean=self.central_roi.mean,
+            central_roi_min=self.central_roi.min,
+            central_roi_std=self.central_roi.std,
+        )
+
+    def _get_vert_values(
+        self, vert_position: float, vert_width: float
+    ) -> (np.ndarray, float, float):
+        """Get the raw values of the profile to pass to SingleProfile"""
+        left_edge = int(
+            round(
+                self.image.array.shape[1] * vert_position
+                - self.image.array.shape[1] * vert_width / 2
+            )
+        )
+        left_edge = max(left_edge, 0)  # clip to 0
+        right_edge = int(
+            round(
+                self.image.array.shape[1] * vert_position
+                + self.image.array.shape[1] * vert_width / 2
+            )
+            + 1
+        )
+        right_edge = min(right_edge, self.image.array.shape[1])  # clip to image limit
+        return (
+            np.mean(self.image.array[:, left_edge:right_edge], 1),
+            left_edge,
+            right_edge,
+        )
+
+    def _get_horiz_values(
+        self, horiz_position: float, horiz_width: float
+    ) -> (np.ndarray, float, float):
+        """Get the raw values of the profile to pass to SingleProfile"""
+        bottom_edge = int(
+            round(
+                self.image.array.shape[0] * horiz_position
+                - self.image.array.shape[0] * horiz_width / 2
+            )
+        )
+        bottom_edge = max(bottom_edge, 0)
+        top_edge = int(
+            round(
+                self.image.array.shape[0] * horiz_position
+                + self.image.array.shape[0] * horiz_width / 2
+            )
+            + 1
+        )
+        top_edge = min(top_edge, self.image.array.shape[0])
+        return (
+            np.mean(self.image.array[bottom_edge:top_edge, :], 0),
+            bottom_edge,
+            top_edge,
+        )
+
+    def publish_pdf(
+        self,
+        filename: str,
+        notes: str | list = None,
+        open_file: bool = False,
+        metadata: dict = None,
+        logo: Path | str | None = None,
+    ) -> None:
+        """Publish (print) a PDF containing the analysis, images, and quantitative results.
+
+        Parameters
+        ----------
+        filename : (str, file-like object}
+            The file to write the results to.
+        notes : str, list of strings
+            Text; if str, prints single line.
+            If list of strings, each list item is printed on its own line.
+        open_file : bool
+            Whether to open the file using the default program after creation.
+        metadata : dict
+            Extra stream to be passed and shown in the PDF. The key and value will be shown with a colon.
+            E.g. passing {'Author': 'James', 'Unit': 'TrueBeam'} would result in text in the PDF like:
+            --------------
+            Author: James
+            Unit: TrueBeam
+            --------------
+        logo: Path, str
+            A custom logo to use in the PDF report. If nothing is passed, the default pylinac logo is used.
+        """
+        plt.ioff()
+        if not self._is_analyzed:
+            raise NotAnalyzed("Image is not analyzed yet. Use analyze() first.")
+        canvas = pdf.PylinacCanvas(
+            filename,
+            page_title="Field Analysis",
+            metadata=metadata,
+            metadata_location=(2, 5),
+            logo=logo,
+        )
+        # draw result text
+        text = self.results(as_str=False)
+        number_of_lines = len(text)
+        i = 0
+        while i < number_of_lines:
+            if i > number_of_lines - 1:
+                i = number_of_lines - 1
+            canvas.add_text(text=text[i : i + 50], location=(2, 25.5), font_size=10)
+            canvas.add_new_page()
+            i = i + 50
+
+        # draw vertical profile
+        stream = io.BytesIO()
+        self._save_plot(self._plot_vert, stream)
+        canvas.add_image(stream, location=(-4, 13), dimensions=(28, 12))
+
+        # draw horizontal profile
+        stream = io.BytesIO()
+        self._save_plot(self._plot_horiz, stream)
+        canvas.add_image(stream, location=(-4, 1), dimensions=(28, 12))
+
+        # draw image on last page if it's an EPID image. Skip if a device as there's no image
+        if not hasattr(self, "device"):
+            canvas.add_new_page()
+            stream = io.BytesIO()
+            self._save_plot(self._plot_image, stream, title="Image")
+            canvas.add_image(stream, location=(1, 2), dimensions=(18, 20))
+
+        if notes is not None:
+            canvas.add_text(text="Notes:", location=(1, 5.5), font_size=14)
+            canvas.add_text(text=notes, location=(1, 5))
+        canvas.finish()
+
+        if open_file:
+            webbrowser.open(filename)
+
+    def plot_analyzed_image(
+        self,
+        show: bool = True,
+        grid: bool = True,
+        split_plots: bool = False,
+        **plt_kwargs,
+    ) -> tuple[list[plt.Figure], list[str]]:
+        """Plot the analyzed image. Shows parameters such as flatness & symmetry.
+
+        Parameters
+        ----------
+        show
+            Whether to show the plot when called.
+        grid
+            Whether to show a grid on the profile plots
+        split_plots : bool
+            Whether to plot the image and profiles on individual figures. Useful for saving individual plots.
+        plt_kwargs : dict
+            Keyword args passed to the plt.figure() method. Allows one to set things like figure size.
+        """
+        if not self._is_analyzed:
+            raise NotAnalyzed("Image is not analyzed yet. Use analyze() first.")
+        # set up axes
+        plt.ioff()
+        figs = []
+        names = []
+        if split_plots:
+            if not self._from_device:
+                im_fig, image_ax = plt.subplots(1, **plt_kwargs)
+                figs.append(im_fig)
+                names.append("Image")
+            v_fig, vert_ax = plt.subplots(1, **plt_kwargs)
+            figs.append(v_fig)
+            names.append("Vertical Profile")
+            h_fig, horiz_ax = plt.subplots(1, **plt_kwargs)
+            figs.append(h_fig)
+            names.append("Horizontal Profile")
+        else:
+            plt.figure(**plt_kwargs)
+            if not self._from_device:
+                image_ax = plt.subplot2grid((2, 2), (0, 1))
+                vert_ax = plt.subplot2grid((2, 2), (1, 1))
+                horiz_ax = plt.subplot2grid((2, 2), (0, 0))
+            else:
+                vert_ax = plt.subplot2grid((1, 2), (0, 1))
+                horiz_ax = plt.subplot2grid((1, 2), (0, 0))
+
+        # plot image and profile lines
+        if not self._from_device:
+            self._plot_image(image_ax, title=osp.basename(self._path))
+        self._plot_vert(vert_ax, grid)
+        self._plot_horiz(horiz_ax, grid)
+
+        # plot legend
+        lines = []
+        labels = []
+        v_lines, v_labels = vert_ax.get_legend_handles_labels()
+        h_lines, h_labels = horiz_ax.get_legend_handles_labels()
+        for label, line in zip(v_labels, v_lines):
+            if label not in labels:
+                lines.append(line)
+                labels.append(label)
+        for label, line in zip(h_labels, h_lines):
+            if label not in labels:
+                lines.append(line)
+                labels.append(label)
+        if not self._from_device:
+            if split_plots:
+                for ax in (vert_ax, horiz_ax):
+                    try:
+                        ax.legend(lines, labels, loc="center")
+                    except:#reduceshape  
+                        pass
+            else:
+                legend_ax = plt.subplot2grid((2, 2), (1, 0))
+                legend_ax.legend(lines, labels, loc="center")
+                legend_ax.axis("off")
+        else:
+            vert_ax.legend(
+                lines,
+                labels,
+                loc="best",
+            )
+        if not split_plots:
+            plt.suptitle("Field Profile Analysis")
+            plt.tight_layout()
+        else:
+            for fig in figs:
+                fig.tight_layout()
+        if show:
+            plt.show()
+        return figs, names
+
+    def save_analyzed_image(
+        self,
+        filename: None | str | Path | BinaryIO = None,
+        split_plots: bool = False,
+        to_streams: bool = False,
+        **kwargs,
+    ) -> list[str] | dict[str, BinaryIO] | None:
+        """Save the analyzed image to disk or to stream. Kwargs are passed to plt.savefig()
+
+        Parameters
+        ----------
+        split_plots: bool
+            If split_plots is True, multiple files will be created that append a name. E.g. `my_file.png` will become `my_file_image.png`, `my_file_vertical.png`, etc.
+            If to_streams is False, a list of new filenames will be returned
+        to_streams: bool
+            This only matters if split_plots is True. If both of these are true, multiple streams will be created and returned as a dict.
+        """
+        if filename is None and to_streams is False:
+            raise ValueError("Must pass in a filename unless saving to streams.")
+        figs, names = self.plot_analyzed_image(
+            show=False, split_plots=split_plots, **kwargs
+        )
+        if isinstance(filename, Path):
+            filename = str(filename)
+        for key in ("grid", "show"):
+            kwargs.pop(key, None)
+        if not split_plots:
+            plt.savefig(filename, **kwargs)
+        else:
+            # append names to filename if it's file-like
+            if not to_streams:
+                filenames = []
+                f, ext = osp.splitext(filename)
+                for name in names:
+                    filenames.append(f + name + ext)
+            else:  # it's a stream buffer
+                filenames = [io.BytesIO() for _ in names]
+            for fig, name in zip(figs, filenames):
+                fig.savefig(name, **kwargs)
+            if to_streams:
+                return {name: stream for name, stream in zip(names, filenames)}
+            if split_plots:
+                return filenames
+
+    def _plot_image(self, axis: plt.Axes = None, title: str = "") -> None:
+        """Plot the image and profile extraction overlay"""
+        if axis is None:
+            fig, axis = plt.subplots()
+        axis.imshow(self.image.array, cmap=get_dicom_cmap())
+
+        # vertical line/rect
+        width = abs(self._left_v_index - self._right_v_index)
+        center = (width / 2 + self._left_v_index, self.image.shape[0] / 2)
+        r = Rectangle(width=width, height=self.image.shape[0], center=center)
+        r.plot2axes(
+            axis,
+            edgecolor="b",
+            fill=True,
+            alpha=0.2,
+            facecolor="b",
+            label="Profile Extraction Area",
+        )
+
+        # horizontal line/rect
+        width_h = abs(self._upper_h_index - self._lower_h_index)
+        center_h = (self.image.shape[1] / 2, width_h / 2 + self._upper_h_index)
+        r = Rectangle(width=self.image.shape[1], height=width_h, center=center_h)
+        r.plot2axes(axis, edgecolor="b", fill=True, alpha=0.2, facecolor="b")
+
+        # cleanup
+        _remove_ticklabels(axis)
+        axis.set_title(title)
+        axis.legend()
+
+    def _plot_vert(self, axis: plt.Axes = None, grid: bool = True) -> None:
+        """Plot vertical profile"""
+        if axis is None:
+            fig, axis = plt.subplots()
+        axis.grid(grid)
+        axis.set_title("Vertical Profile")
+        if self._from_device:
+            axis.set_xlabel("detector")
+            if self._interpolation_method == Interpolation.NONE:
+                markers = "b+"
+            else:
+                markers = "b"
+        else:
+            axis.set_xlabel("pixels")
+            markers = "b"
+        axis.plot(
+            self.vert_profile.x_indices,
+            self.vert_profile.values,
+            markers,
+            label="Profile",
+        )
+        axis.set_ylabel("Response")
+
+        # plot second axis w/ physical distance
+        sec_y = axis.twiny()
+        physical_distance = self.vert_profile.x_indices / self.vert_profile.dpmm
+        sec_y.plot(physical_distance, self.vert_profile.values, markers)
+        sec_y.set_xlabel("mm")
+
+        # plot basic parameters on profile
+        self._plot_penumbra(self.vert_profile, axis)
+        self._plot_field_edges(self.vert_profile, axis)
+        if self._is_FFF:
+            self._plot_top(self.vert_profile, axis)
+            self._plot_infield_slope(self.vert_profile, axis)
+
+        for name, item in self._protocol.value.items():
+            if item.get("plot"):
+                item["plot"](self, self.vert_profile, axis)
+
+    def _plot_horiz(self, axis: plt.Axes = None, grid: bool = True) -> None:
+        """Plot horizontal profile"""
+        if axis is None:
+            fig, axis = plt.subplots()
+        axis.grid(grid)
+        axis.set_title("Horizontal Profile")
+        if self._from_device:
+            axis.set_xlabel("detector")
+            if self._interpolation_method == Interpolation.NONE:
+                markers = "b+"
+            else:
+                markers = "b"
+        else:
+            axis.set_xlabel("pixels")
+            markers = "b"
+        axis.plot(
+            self.horiz_profile.x_indices,
+            self.horiz_profile.values,
+            markers,
+            label="Profile",
+        )
+        axis.set_ylabel("Response")
+
+        # plot second axis w/ physical distance
+        sec_y = axis.twiny()
+        physical_distance = self.horiz_profile.x_indices / self.horiz_profile.dpmm
+        sec_y.plot(physical_distance, self.horiz_profile.values, markers)
+        sec_y.set_xlabel("mm")
+
+        # plot basic parameters on profile
+        self._plot_penumbra(self.horiz_profile, axis)
+        self._plot_field_edges(self.horiz_profile, axis)
+        if self._is_FFF:
+            self._plot_top(self.horiz_profile, axis)
+            self._plot_infield_slope(self.horiz_profile, axis)
+
+        for name, item in self._protocol.value.items():
+            if item.get("plot"):
+                item["plot"](self, self.horiz_profile, axis)
+
+    @staticmethod
+    def _save_plot(func, filename: str | io.BytesIO, **kwargs) -> None:
+        func(**kwargs)
+        # figure headers appear cut off on the PDF without a tight layout
+        plt.tight_layout()
+        plt.savefig(filename)
+
+    def _plot_penumbra(self, profile: SingleProfile, axis: plt.Axes = None) -> None:
+        """Plot the non-linear regression fit against the profile"""
+        data = profile.penumbra(self._penumbra[0], self._penumbra[1])
+        axis.axvline(x=data[f"left {self._penumbra[0]}% index (exact)"], color="pink")
+        axis.axvline(
+            x=data[f"left {self._penumbra[1]}% index (exact)"],
+            color="pink",
+            label="Penumbra region",
+        )
+        axis.axvline(x=data[f"right {self._penumbra[0]}% index (exact)"], color="pink")
+        axis.axvline(x=data[f"right {self._penumbra[1]}% index (exact)"], color="pink")
+        if self._edge_detection == Edge.INFLECTION_HILL:
+            # plot left side Hill fit
+            fw = (
+                profile.field_data(
+                    in_field_ratio=1.0,
+                    slope_exclusion_ratio=self._slope_exclusion_ratio,
+                )["width (exact)"]
+                * self._hill_window_ratio
+                / 2
+            )
+            left_hill_idx = int(
+                round(data[f"left {self._penumbra[0]}% index (exact)"] - fw)
+            )
+            right_hill_idx = int(
+                round(data[f"left {self._penumbra[1]}% index (exact)"] + fw)
+            )
+            infl_data = profile.inflection_data()
+            hill_fit = Hill.from_params(infl_data["left Hill params"])
+            l_x_data = np.linspace(left_hill_idx, right_hill_idx, 200)
+            axis.plot(l_x_data, hill_fit.y(l_x_data), color="black", label="Hill fit")
+
+            # plot right side Hill fit
+            left_hill_idx = int(
+                round(data[f"right {self._penumbra[1]}% index (exact)"] - fw)
+            )
+            right_hill_idx = int(
+                round(data[f"right {self._penumbra[0]}% index (exact)"] + fw)
+            )
+            hill_fit = Hill.from_params(infl_data["right Hill params"])
+            r_x_data = np.linspace(left_hill_idx, right_hill_idx, 200)
+            axis.plot(r_x_data, hill_fit.y(r_x_data), color="black", label="Hill fit")
+
+    def _plot_field_edges(self, profile: SingleProfile, axis: plt.Axes) -> None:
+        data = profile.field_data(
+            in_field_ratio=1.0, slope_exclusion_ratio=self._slope_exclusion_ratio
+        )
+        axis.plot(
+            data["left index (rounded)"],
+            data["left value (@rounded)"],
+            "x",
+            color="green",
+            label="Field edge",
+        )
+        axis.plot(
+            data["right index (rounded)"],
+            data["right value (@rounded)"],
+            "x",
+            color="green",
+        )
+
+    def _plot_infield_slope(self, profile: SingleProfile, axis: plt.Axes) -> None:
+        data = profile.field_data(self._in_field_ratio, self._slope_exclusion_ratio)
+        # left slope
+        left_x_values = range(
+            data["left index (rounded)"], data["left inner index (rounded)"]
+        )
+        left_y_values = data["left slope"] * left_x_values + data["left intercept"]
+        axis.plot(left_x_values, left_y_values, color="tomato", label="in-field slope")
+        # right slope
+        right_x_values = range(
+            data["right inner index (rounded)"], data["right index (rounded)"]
+        )
+        right_y_values = data["right slope"] * right_x_values + data["right intercept"]
+        axis.plot(right_x_values, right_y_values, color="tomato")
+
+    def _plot_top(self, profile: SingleProfile, axis: plt.Axes = None) -> None:
+        """Plot a second order polynomial to the peak of the FFF field"""
+        data = profile.field_data(self._in_field_ratio, self._slope_exclusion_ratio)
+        x_model = np.linspace(
+            data["left inner index (rounded)"],
+            data["right inner index (rounded)"],
+            1000,
+        )
+        y_model = (
+            data["top params"][0] * x_model**2
+            + data["top params"][1] * x_model
+            + data["top params"][2]
+        )
+        axis.plot(x_model, y_model, color="magenta", label='"top" polynomial fit')
+        axis.plot(
+            data['"top" index (exact)'],
+            data['"top" value (@exact)'],
+            "x",
+            color="magenta",
+            label='"top" position',
+        )
+
+
+class Device(Enum):
+    """2D array device Enum."""
+
+    PROFILER = {"device": SNCProfiler, "detector spacing (mm)": 5}  #:
+
+
+class DeviceFieldAnalysis(FieldAnalysis):
+    """Field analysis using a device array."""
+
+    def __init__(self, path: str, device: Device):
+        """
+        Parameters
+        ----------
+        path
+            Path to the file of the device output
+        device
+            The array device. Currently, the Profiler is supported. See :ref:`loading_device_data`.
+        """
+        self.device: Device = device.value["device"](path=path)  #:
+        self._path = path
+        self._from_device = True
+        self._dpmm = 1 / device.value["detector spacing (mm)"]
+
+    @classmethod
+    def from_demo_image(cls):
+        """Load the demo image into an instance."""
+        demo_file = retrieve_demo_file(name="6fff.prm")
+        return cls(demo_file, device=Device.PROFILER)
+
+    @staticmethod
+    def run_demo() -> None:
+        """Run the Field analysis demo by loading the demo device dataset, print results, and plot the profiles."""
+        fs = DeviceFieldAnalysis.from_demo_image()
+        fs.analyze(protocol=Protocol.VARIAN, is_FFF=True)
+        print(fs.results())
+        fs.plot_analyzed_image()
+
+    def analyze(
+        self,
+        protocol: Protocol = Protocol.VARIAN,
+        in_field_ratio: float = 0.8,
+        slope_exclusion_ratio: float = 0.3,
+        is_FFF: bool = False,
+        penumbra: tuple = (20, 80),
+        interpolation: Interpolation = Interpolation.NONE,
+        interpolation_resolution_mm: float = 0.1,
+        ground: bool = True,
+        normalization_method: Normalization = Normalization.GEOMETRIC_CENTER,
+        edge_detection_method: Edge = Edge.INFLECTION_HILL,
+        edge_smoothing_ratio: float = 0.003,
+        hill_window_ratio: float = 0.15,
+        **kwargs,
+    ) -> None:
+        """Analyze the device profiles to determine parameters such as field edges, penumbra, and/or flatness & symmetry.
+
+        Parameters
+        ----------
+        protocol
+            The analysis protocol. See :ref:`analysis_definitions` for equations and options.
+        in_field_ratio
+            The ratio of the field width to use for protocol values. E.g. 0.8 means use the 80% field width.
+        slope_exclusion_ratio
+            This is the ratio of the field to use to 1) calculate the "top" of an FFF field as well as 2) exclude from the
+            "slope" calculation of each side of the field. Alternatively, this also defines the area to use for the
+            slope calculation. E.g. an `in_field_ratio` of 0.8 and `slope_exclusion_ratio` of 0.2 means the central 20% of the
+            field is used to fit and calculate the "top", while the region on either side of the central 20% between the central
+            80% is used to calculate a slope on either side using linear regression.
+
+            .. note::
+
+                While the "top" is always calculated, it will not be displayed in plots if the `is_FFF` parameter is false.
+
+        is_FFF
+            This is a flag to display the "top" calculation and slopes on either side of the field.
+        penumbra
+            A tuple of (lower, higher) % of the penumbra to calculate. E.g. (20, 80) will calculate the penumbra width at 20% and 80%.
+
+            .. note::
+
+                The exact height of the penumbra depends on the edge detection method. E.g. FWHM will result in
+                calculating penumbra at 20/80% of the field max, but if something like inflection is used, the penumbra
+                height will be 20/50*100*inflection height and 80/50*100*inflection height.
+
+        interpolation
+            Interpolation technique to use. Must be one of the enum options of ``Interpolation``.
+        ground
+            Whether to ground the profile (set min value to 0). Helpful most of the time.
+        interpolation_resolution_mm
+            The resolution that the interpolation will scale to.
+            E.g. if the native dpmm is 2 and the resolution is set to 0.1mm the data will be interpolated to have a new dpmm of 10 (1/0.1).
+        normalization_method
+            How to pick the point to normalize the data to.
+        edge_detection_method
+            The method by which to detect the field edge. FWHM is reasonable most of the time except for FFF beams.
+            Inflection-derivative will use the max gradient to determine the field edge. Note that this may not be the
+            50% height. In fact, for FFF beams it shouldn't be. Inflection methods are better for FFF and other unusual
+            beam shapes.
+        edge_smoothing_ratio
+            The ratio of the length of the values to use as the sigma for a Gaussian filter applied before searching for
+            the inflection. E.g. 0.005 with a profile of 1000 points will result in a sigma of 5.
+            This helps make the inflection point detection more robust to noise. Increase for noisy data.
+        hill_window_ratio
+            The ratio of the field size to use as the window to fit the Hill function. E.g. 0.2 will using a window
+            centered about each edge with a width of 20% the size of the field width. Only applies when the edge
+            detection is ``INFLECTION_HILL``.
+        kwargs
+            Use these to pass parameters to custom protocol functions. See :ref:`custom_protocols`.
+        """
+        self._analyze(
+            edge_detection_method,
+            edge_smoothing_ratio,
+            ground,
+            None,
+            None,
+            in_field_ratio,
+            interpolation,
+            interpolation_resolution_mm,
+            is_FFF,
+            kwargs,
+            normalization_method,
+            penumbra,
+            protocol,
+            slope_exclusion_ratio,
+            None,
+            None,
+            Centering.MANUAL,
+            hill_window_ratio,
+        )
+
+    def _extract_profiles(
+        self,
+        horiz_position,
+        horiz_width,
+        interpolation_resolution_mm,
+        vert_position,
+        vert_width,
+        edge_detection_method,
+        edge_smoothing_ratio,
+        ground,
+        interpolation,
+        interpolation_resolution,
+        normalization_method,
+        centering,
+        hill_window_ratio,
+    ):
+        # calculate the profiles from the device. Since it's not an image, there's no position values
+        x_prof, y_prof, _, _ = self.device.to_profiles(
+            dpmm=self._dpmm,
+            interpolation=interpolation,
+            interpolation_resolution_mm=interpolation_resolution,
+            ground=ground,
+            edge_detection_method=edge_detection_method,
+            normalization_method=normalization_method,
+            edge_smoothing_ratio=edge_smoothing_ratio,
+            hill_window_ratio=hill_window_ratio,
+        )
+        self.vert_profile = y_prof
+        self.horiz_profile = x_prof
+
+    def _generate_results_data(self) -> DeviceResult:
+        """Present the results data and metadata as a dataclass or dict.
+        The default return type is a dataclass. Unlike vanilla FA, there is no central ROI since it's only profiles
+        """
+        return DeviceResult(
+            **self._results,
+            protocol=self._protocol.name,
+            centering_method=getattr(self._centering, "value", None),
+            normalization_method=self.horiz_profile._norm_method.value,
+            interpolation_method=self.horiz_profile._interp_method.value,
+            edge_detection_method=self.horiz_profile._edge_method.value,
+            protocol_results=self._extra_results,
+        )
+
+
+def _remove_ticklabels(axis: plt.Axes):
+    axis.get_yaxis().set_ticklabels([])
+    axis.get_xaxis().set_ticklabels([])
```

### Comparing `manteia_qa_pylinac-1.0.0/pylinac/log_analyzer.py` & `manteia_qa_pylinac-1.1.0/pylinac/log_analyzer.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,2944 +1,2944 @@
-"""
-The log analyzer module reads and parses Varian linear accelerator machine logs, both Dynalogs and Trajectory logs. The module also
-calculates actual and expected fluences as well as performing gamma evaluations. Data is structured to be easily accessible and
-easily plottable.
-
-Unlike most other modules of pylinac, the log analyzer module has no end goal. Data is parsed from the logs, but what is done with that
-info, and which info is analyzed is up to the user.
-
-Features:
-
-* **Analyze Dynalogs or Trajectory logs** - Either platform is supported. Tlog versions 2.1, 3.0, and 4.0 are supported.
-* **Read in both .bin and .txt Trajectory log files** - Read in the machine data from both .bin and .txt files to get all the information recorded.
-  See the :attr:`~pylinac.log_analyzer.MachineLog.txt` attribute.
-* **Save Trajectory log data to CSV** - The Trajectory log binary data format does not allow for easy export of data. Pylinac lets you do
-  that so you can use Excel or other software that you use with Dynalogs.
-* **Plot or analyze any axis** - Every data axis (e.g. gantry, y1, beam holds, MLC leaves) can be accessed and plotted: the actual, expected, and even the difference.
-* **Calculate fluences and gamma** - Besides reading in the MLC positions, pylinac calculates the actual and expected fluence
-  as well as the gamma map; DTA and threshold values are adjustable.
-* **Anonymize logs** - Both dynalogs and trajectory logs can be "anonymized" by removing the Patient ID from the filename(s)
-  and file data.
-"""
-from __future__ import annotations
-
-import collections
-import concurrent.futures
-import copy
-import csv
-import enum
-import gc
-import itertools
-import multiprocessing
-import os
-import os.path as osp
-import shutil
-import webbrowser
-import zipfile
-from functools import cached_property
-from io import BufferedReader, BytesIO
-from pathlib import Path
-from typing import BinaryIO, Iterable, Sequence
-
-import argue
-import matplotlib.pyplot as plt
-import numpy as np
-
-from .core import image, io, pdf
-from .core.decorators import lru_cache
-from .core.utilities import Structure, convert_to_enum, decode_binary, is_iterable
-from .settings import get_array_cmap
-
-
-class TreatmentType(enum.Enum):
-    STATIC_IMRT = "Static IMRT"  #:
-    DYNAMIC_IMRT = "Dynamic IMRT"  #:
-    VMAT = "VMAT"  #:
-    IMAGING = "Imaging"  #:
-
-
-MLC_FOV_WIDTH_MM = 400
-MLC_FOV_HEIGHT_MM = 400
-HDMLC_FOV_HEIGHT_MM = 220
-
-
-class MLCBank(enum.Enum):
-    A = "A"  #:
-    B = "B"  #:
-    BOTH = "both"  #:
-
-
-class Fluence(enum.Enum):
-    ACTUAL = "actual"  #:
-    EXPECTED = "expected"  #:
-    GAMMA = "gamma"  #:
-
-
-class Graph(enum.Enum):
-    GAMMA = "gamma"  #:
-    HISTOGRAM = "histogram"  #:
-    RMS = "rms"  #:
-
-
-class MachineLogs(list):
-    """Read in machine logs from a directory. Inherits from list. Batch methods are also provided."""
-
-    def __init__(self, folder: str, recursive: bool = True):
-        r"""
-        Parameters
-        ----------
-        folder : str
-            The directory of interest. Will walk through and process any logs, Trajectory or dynalog, it finds.
-            Non-log files will be skipped.
-        recursive : bool
-            Whether to walk through subfolders of passed directory. Only used if ``folder`` is a valid log directory.
-
-        Examples
-        --------
-        Load a directory upon initialization::
-
-            >>> log_folder = r'C:\path\log\directory'
-            >>> logs = MachineLogs(log_folder)
-
-        Batch methods include determining the average gamma and average gamma pass value::
-
-            >>> logs.avg_gamma()
-            >>> 0.05 # or whatever it is
-            >>> logs.avg_gamma_pct()
-            >>> 97.2
-        """
-        super().__init__()
-        self.load_folder(folder, recursive)
-
-    @classmethod
-    def from_zip(cls, zfile: str):
-        """Instantiate from a ZIP archive.
-
-        Parameters
-        ----------
-        zfile : str
-            Path to the zip archive.
-        """
-        with io.TemporaryZipDirectory(zfile) as tzd:
-            logs = cls(tzd)
-        return logs
-
-    @property
-    def num_logs(self) -> int:
-        """The number of logs currently loaded."""
-        return len(self)
-
-    @property
-    def num_tlogs(self) -> int:
-        """The number of Trajectory logs currently loaded."""
-        return sum(isinstance(log, TrajectoryLog) for log in self)
-
-    @property
-    def num_dlogs(self) -> int:
-        """The number of Trajectory logs currently loaded."""
-        return sum(isinstance(log, Dynalog) for log in self)
-
-    def load_folder(self, directory: str, recursive: bool = True):
-        """Load log files from a directory and append to existing list.
-
-        Parameters
-        ----------
-        directory : str, None
-            The directory of interest.
-            If a string, will walk through and process any logs, Trajectory or dynalog, it finds.
-            Non-log files will be skipped.
-            If None, files must be loaded later using .load_dir() or .append().
-        recursive : bool
-            If True (default), will walk through subfolders of passed directory.
-            If False, will only search root directory.
-        """
-        # get log files from directory
-        log_files = _get_log_filenames(directory, recursive=recursive)
-        if len(log_files) == 0:
-            print("No logs found.")
-            return
-
-        # actual log loading
-        print(f"{len(log_files)} logs found.")
-        for idx, file in enumerate(log_files):
-            self.append(file)
-            print(f"Log loaded: {idx+1} of {len(log_files)}", end="\r")
-        print("")
-
-    def _check_empty(self) -> None:
-        """Check if any logs have been loaded."""
-        if len(self) == 0:
-            raise ValueError("No logs have been loaded yet.")
-
-    def report_basic_parameters(self) -> None:
-        """Report basic parameters of the logs.
-
-        - Number of logs
-        - Average gamma value of all logs
-        - Average gamma pass percent of all logs
-        """
-        print(f"Number of logs: {len(self)}")
-        print(f"Average gamma: {self.avg_gamma():3.2f}")
-        print(f"Average gamma pass percent: {self.avg_gamma_pct():3.1f}")
-
-    def append(self, obj, recursive: bool = True) -> None:
-        """Append a log. Overloads list method.
-
-        Parameters
-        ----------
-        obj : str, Dynalog, TrajectoryLog
-            If a string, must point to a log file.
-            If a directory, must contain log files.
-            If a Dynalog or Trajectory log instance, then simply appends.
-        recursive : bool
-            Whether to walk through subfolders of passed directory. Only applicable if obj was a directory.
-        """
-        if isinstance(obj, str):
-            if is_log(obj):
-                log = load_log(obj)
-                super().append(log)
-            elif osp.isdir(obj):
-                files = io.retrieve_filenames(obj)
-                for file in files:
-                    self.append(file)
-        elif isinstance(obj, (Dynalog, TrajectoryLog)):
-            super().append(obj)
-        else:
-            raise TypeError(
-                "Can only append MachineLog or string pointing to a log or log directory."
-            )
-
-    def avg_gamma(
-        self,
-        doseTA: int | float = 1,
-        distTA: int | float = 1,
-        threshold: int | float = 0.1,
-        resolution: int | float = 0.1,
-    ) -> float:
-        """Calculate and return the average gamma of all logs. See :meth:`~pylinac.log_analyzer.GammaFluence.calc_map()`
-        for further parameter info."""
-        self._check_empty()
-        gamma_list = np.zeros(self.num_logs)
-
-        for num, log in enumerate(self):
-            log.fluence.gamma.calc_map(doseTA, distTA, threshold, resolution)
-            gamma_list[num] = log.fluence.gamma.avg_gamma
-            print(f"Calculating gammas: {num+1} of {self.num_logs}", end="\r")
-        print("")
-        return gamma_list.mean()
-
-    def avg_gamma_pct(
-        self,
-        doseTA: int | float = 1,
-        distTA: int | float = 1,
-        threshold: int | float = 0.1,
-        resolution: int | float = 0.1,
-    ) -> float:
-        """Calculate and return the average gamma pass percent of all logs. See :meth:`~pylinac.log_analyzer.GammaFluence.calc_map()`
-        for further parameter info."""
-        self._check_empty()
-        gamma_list = np.zeros(self.num_logs)
-
-        for num, log in enumerate(self):
-            log.fluence.gamma.calc_map(doseTA, distTA, threshold, resolution)
-            gamma_list[num] = log.fluence.gamma.pass_prcnt
-            print(
-                f"Calculating gamma pass percent: {num+1} of {self.num_logs}", end="\r"
-            )
-        print("")
-        return gamma_list.mean()
-
-    def to_csv(self) -> list[str]:
-        """Write trajectory logs to CSV. If there are both dynalogs and trajectory logs,
-        only the trajectory logs will be written. File names will be the same as the original log file names.
-
-        Returns
-        -------
-        list
-            A list of all the filenames of the newly created CSV files.
-        """
-        tlogs_written = False
-        files = []
-        for log in self:
-            if is_tlog(log.filename):
-                file = log.to_csv()
-                tlogs_written = True
-                files.append(file)
-        if tlogs_written:
-            print("\nAll trajectory logs written to CSV files!")
-        else:
-            print(
-                "\nNo files written. Either no logs are loaded or all logs were dynalogs."
-            )
-        return files
-
-    def anonymize(self, inplace: bool = False, suffix: str | None = None):
-        """Save anonymized versions of the logs.
-
-        For dynalogs, this replaces the patient ID in the filename(s) and the second line of the log with 'Anonymous<suffix>`.
-        This will rename both A* and B* logs if both are present in the same directory.
-
-        For trajectory logs, the patient ID in the filename is replaced with `Anonymous<suffix>` for the .bin file. If the
-        associated .txt file is in the same directory it will similarly replace the patient ID in the filename with
-        `Anonymous<suffix>`. Additionally, the `Patient ID` row will be replaced with `Patient ID: Anonymous<suffix>`.
-
-        .. note::
-            Anonymization is only available for logs loaded locally (i.e. not from a URL or a data stream). To
-            anonymize such a log it must be first downloaded or written to a file, then loaded in.
-
-        .. note::
-            Anonymization is done to the log *file* itself. The current instance(s) of `MachineLog` will not be anonymized.
-
-        Parameters
-        ----------
-        inplace : bool
-            If False (default), creates an anonymized *copy* of the log(s).
-            If True, *renames and replaces* the content of the log file.
-        suffix : str, optional
-            An optional suffix that is added after `Anonymous` to give specificity to the log.
-
-        Returns
-        -------
-        list
-            A list containing the paths to the newly written files.
-        """
-        file_list = []
-        for log in self:
-            files = log.anonymize(inplace=inplace, suffix=suffix)
-            file_list += files
-        print("\n\nDone anonymizing!")
-        return file_list
-
-
-class Axis:
-    """Represents an 'Axis' of a Trajectory log or dynalog file, holding actual and potentially expected and difference values.
-
-    Attributes
-    ----------
-    Parameters are Attributes
-    """
-
-    def __init__(self, actual: np.ndarray, expected: np.ndarray | None = None):
-        """
-        Parameters
-        ----------
-        actual : numpy.ndarray
-            The array of actual position values.
-        expected : numpy.ndarray, optional
-            The array of expected position values. Not applicable for dynalog axes other than MLCs.
-        """
-        self.actual = actual
-        self.expected = expected
-        if expected is not None:
-            try:
-                if len(actual) != len(expected):
-                    raise ValueError(
-                        "Actual and expected Axis parameters are not equal length"
-                    )
-            except TypeError:
-                pass
-            self.expected = expected
-
-    @property
-    def difference(self) -> np.ndarray:
-        """Return an array of the difference between actual and expected positions.
-
-        Returns
-        -------
-        numpy.ndarray
-            Array the same length as actual/expected.
-        """
-        if self.expected is not None:
-            return self.actual - self.expected
-        else:
-            raise AttributeError("Expected positions not passed to Axis")
-
-    def plot_actual(self) -> None:
-        """Plot the actual positions as a matplotlib figure."""
-        self._plot("actual")
-
-    def save_plot_actual(self, filename: str, **kwargs) -> None:
-        self._plot("actual", show=False)
-        self._save(filename, **kwargs)
-
-    def plot_expected(self) -> None:
-        """Plot the expected positions as a matplotlib figure."""
-        self._plot("expected")
-
-    def save_plot_expected(self, filename: str, **kwargs) -> None:
-        self._plot("expected", show=False)
-        self._save(filename, **kwargs)
-
-    def plot_difference(self) -> None:
-        """Plot the difference of positions as a matplotlib figure."""
-        self._plot("difference")
-
-    def save_plot_difference(self, filename: str, **kwargs) -> None:
-        self._plot("difference", show=False)
-        self._save(filename, **kwargs)
-
-    @argue.options(param=("actual", "expected", "difference"))
-    def _plot(self, param: str, show: bool = True):
-        """Plot the parameter: actual, expected, or difference."""
-        plt.plot(getattr(self, param))
-        plt.grid(True)
-        plt.autoscale(axis="x", tight=True)
-        if show:
-            plt.show()
-
-    def _save(self, filename: str, **kwargs):
-        """Save the figure to a file, either .png or .html."""
-        plt.savefig(filename, **kwargs)
-
-
-class AxisMovedMixin:
-    """Mixin class for Axis."""
-
-    AXIS_MOVE_THRESHOLD: float = 0.003
-
-    @cached_property
-    def moved(self) -> bool:
-        """Return whether the axis moved during treatment."""
-        return np.std(self.actual) > self.AXIS_MOVE_THRESHOLD
-
-
-class LeafAxis(Axis, AxisMovedMixin):
-    """Axis holding leaf information."""
-
-    def __init__(self, actual, expected):
-        # force expected argument to be supplied
-        super().__init__(actual, expected)
-
-
-class GantryAxis(Axis, AxisMovedMixin):
-    """Axis holding gantry information."""
-
-    pass
-
-
-class HeadAxis(Axis, AxisMovedMixin):
-    """Axis holding head information (e.g. jaw positions, collimator)."""
-
-    pass
-
-
-class CouchAxis(Axis, AxisMovedMixin):
-    """Axis holding couch information."""
-
-    pass
-
-
-class BeamAxis(Axis):
-    """Axis holding beam information (e.g. MU, beam hold status)."""
-
-    pass
-
-
-class FluenceBase:
-    """An abstract base class to be used for the actual and expected fluences.
-
-    Attributes
-    ----------
-    array : numpy.ndarray
-        An array representing the fluence map; will be num_mlc_pairs-x-400/resolution.
-        E.g., assuming a Millennium 120 MLC model and a fluence resolution of 0.1mm, the resulting
-        matrix will be 60-x-4000.
-    resolution : int, float
-        The resolution of the fluence calculation; -1 means calculation has not been done yet.
-    """
-
-    resolution = -1
-    FLUENCE_TYPE = ""  # must be specified by subclass
-
-    def __init__(self, mlc_struct=None, mu_axis: Axis = None, jaw_struct=None):
-        """
-        Parameters
-        ----------
-        mlc_struct : MLC_Struct
-        mu_axis : BeamAxis
-        jaw_struct : Jaw_Struct
-        """
-        self.array: np.ndarray = np.empty((0, 0))
-        self._mlc = mlc_struct
-        self._mu = mu_axis
-        self._jaws = jaw_struct
-
-    def is_map_calced(self, raise_error: bool = False) -> bool:
-        """Return a boolean specifying whether the fluence has been calculated."""
-        calced = self.array.size > 0
-        if (not calced) and (raise_error is True):
-            raise ValueError(
-                "Map has not yet been calculated. Use .calc_map() with desired parameters first."
-            )
-        else:
-            return calced
-
-    @lru_cache(maxsize=1)
-    def calc_map(
-        self, resolution: float = 0.1, equal_aspect: bool = False
-    ) -> np.ndarray:
-        """Calculate a fluence pixel map.
-
-        Image calculation is done by adding fluence snapshot by snapshot, and leaf pair by leaf pair.
-        Each leaf pair is analyzed separately. First, to optimize, it checks if the leaf is under the y-jaw.
-        If so, the fluence is left at zero; if not, the leaf (or jaw) ends are determined and the MU fraction of that
-        snapshot is added to the total fluence. All snapshots are iterated over for each leaf pair until the total fluence
-        matrix is built.
-
-        Parameters
-        ----------
-        resolution : int, float
-            The resolution in mm of the fluence calculation in the leaf-moving direction.
-        equal_aspect : bool
-            If True, make the y-direction the same resolution as x. If False, the y-axis will be equal to the number of leaves.
-
-        Returns
-        -------
-        numpy.ndarray
-            A numpy array reconstructing the actual fluence of the log. The size will
-            be the number of MLC pairs by 400 / resolution since the MLCs can move anywhere within the
-            40cm-wide linac head opening.
-        """
-        height = MLC_FOV_HEIGHT_MM if not self._mlc.hdmlc else HDMLC_FOV_HEIGHT_MM
-        if equal_aspect:
-            fluence = np.zeros(
-                (int(height / resolution), int(MLC_FOV_WIDTH_MM / resolution)),
-                dtype=float,
-            )
-        else:
-            fluence = np.zeros(
-                (self._mlc.num_pairs, int(MLC_FOV_WIDTH_MM / resolution)), dtype=float
-            )
-
-        self.array = fluence
-        self.resolution = resolution
-
-        # check if the beam was actually on at all (e.g. kV setups)
-        if len(self._mlc.snapshot_idx) < 1:
-            return fluence
-
-        def create_mlc_y_positions(is_hdmlc):
-            if not is_hdmlc:
-                num_large_leaves = 10
-                size_large_leaves = 10 / resolution
-                num_small_leaves = 40
-                size_small_leaves = 5 / resolution
-            else:
-                num_large_leaves = 14
-                size_large_leaves = 5 / resolution
-                num_small_leaves = 32
-                size_small_leaves = 2.5 / resolution
-            sizes = (
-                [size_large_leaves] * num_large_leaves
-                + [size_small_leaves] * num_small_leaves
-                + [size_large_leaves] * num_large_leaves
-            )
-            return np.cumsum(
-                [
-                    0,
-                ]
-                + sizes
-            ).astype(int)
-
-        positions = create_mlc_y_positions(is_hdmlc=self._mlc.hdmlc)
-
-        def yield_leaf_width():
-            for idx in range(self._mlc.num_pairs):
-                yield (positions[idx], positions[idx + 1])
-
-        # calculate the MU delivered in each snapshot. For Tlogs this is absolute; for dynalogs it's normalized.
-        mu_matrix = getattr(self._mu, self.FLUENCE_TYPE)
-        # if little to no MU was delivered (e.g. MV/kV setup), return
-        if np.max(mu_matrix) < 0.5:
-            return fluence
-        MU_differential = np.array([mu_matrix[0]] + list(np.diff(mu_matrix)))
-        MU_total = mu_matrix[-1]
-
-        # calculate each "line" of fluence (the fluence of an MLC leaf pair, e.g. 1 & 61, 2 & 62, etc),
-        # and add each "line" to the total fluence matrix
-        leaf_offset = self._mlc.num_pairs
-        fluence_line = np.zeros(int(400 / resolution), dtype=np.float32)
-        pos_offset = int(np.round(200 / resolution))
-        for pair, width in zip(range(1, self._mlc.num_pairs + 1), yield_leaf_width()):
-            if not self._mlc.leaf_under_y_jaw(pair):
-                fluence_line[:] = 0  # emtpy the line values on each new leaf pair
-                right_leaf_data = getattr(self._mlc.leaf_axes[pair], self.FLUENCE_TYPE)
-                right_leaf_data = (
-                    np.round(right_leaf_data * 10 / resolution) + pos_offset
-                )
-                left_leaf_data = getattr(
-                    self._mlc.leaf_axes[pair + leaf_offset], self.FLUENCE_TYPE
-                )
-                left_leaf_data = (
-                    -np.round(left_leaf_data * 10 / resolution) + pos_offset
-                )
-                left_jaw_data = np.round(
-                    (200 / resolution) - (self._jaws.x1.actual * 10 / resolution)
-                )
-                right_jaw_data = np.round(
-                    (self._jaws.x2.actual * 10 / resolution) + (200 / resolution)
-                )
-                if self._mlc.pair_moved(pair):
-                    for snapshot in self._mlc.snapshot_idx:
-                        lt_mlc_pos = left_leaf_data[snapshot]
-                        rt_mlc_pos = right_leaf_data[snapshot]
-                        lt_jaw_pos = left_jaw_data[snapshot]
-                        rt_jaw_pos = right_jaw_data[snapshot]
-                        left_edge = int(max(lt_mlc_pos, lt_jaw_pos))
-                        right_edge = int(min(rt_mlc_pos, rt_jaw_pos))
-                        fluence_line[left_edge:right_edge] += MU_differential[snapshot]
-                else:  # leaf didn't move; no need to calc over every snapshot
-                    first_snapshot = self._mlc.snapshot_idx[0]
-                    lt_mlc_pos = left_leaf_data[first_snapshot]
-                    rt_mlc_pos = right_leaf_data[first_snapshot]
-                    lt_jaw_pos = left_jaw_data.min()
-                    rt_jaw_pos = right_jaw_data.max()
-                    left_edge = max(lt_mlc_pos, lt_jaw_pos)
-                    right_edge = min(rt_mlc_pos, rt_jaw_pos)
-                    fluence_line[int(left_edge) : int(right_edge)] = MU_total
-                if equal_aspect:
-                    fluence[width[0] : width[1], :] = np.tile(
-                        fluence_line, [width[1] - width[0], 1]
-                    )
-                else:
-                    fluence[pair - 1, :] = fluence_line
-
-        # if it's a dynalog, then normalize it because 25000 is such an arbitrary value
-        if MU_total == 25000:
-            fluence /= MU_total
-
-        return fluence
-
-    def plot_map(self, show: bool = True) -> None:
-        """Plot the fluence; the fluence (pixel map) must have been calculated first."""
-        self.is_map_calced(raise_error=True)
-        plt.clf()
-        plt.imshow(self.array, aspect="auto", cmap=get_array_cmap())
-        if show:
-            plt.show()
-
-    def save_map(self, filename: str, **kwargs) -> None:
-        """Save the fluence map figure to a file."""
-        self.plot_map(show=False)
-        plt.savefig(filename, **kwargs)
-
-
-class ActualFluence(FluenceBase):
-    """The actual fluence object"""
-
-    FLUENCE_TYPE = "actual"
-
-
-class ExpectedFluence(FluenceBase):
-    """The expected fluence object."""
-
-    FLUENCE_TYPE = "expected"
-
-
-class GammaFluence(FluenceBase):
-    """Gamma object, including pixel maps of gamma, binary pass/fail pixel map, and others.
-
-    Attributes
-    ----------
-    array : numpy.ndarray
-        The gamma map. Only available after calling calc_map()
-    passfail_array : numpy.ndarray
-        The gamma pass/fail map; pixels that pass (<1.0) are set to 0, while failing pixels (>=1.0) are set to 1.
-    distTA : int, float
-        The distance to agreement value used in gamma calculation.
-    doseTA : int, float
-        The dose to agreement value used in gamma calculation.
-    threshold : int, float
-        The threshold percent dose value, below which gamma was not evaluated.
-    pass_prcnt : float
-        The percent of pixels passing gamma (<1.0).
-    avg_gamma : float
-        The average gamma value.
-    """
-
-    distTA = -1
-    doseTA = -1
-    threshold = -1
-    pass_prcnt = -1
-    avg_gamma = -1
-    bins = [0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1, 1.1]
-
-    def __init__(
-        self,
-        actual_fluence: ActualFluence,
-        expected_fluence: ExpectedFluence,
-        mlc_struct,
-    ):
-        """
-        Parameters
-        ----------
-        actual_fluence : ActualFluence
-            The actual fluence object.
-        expected_fluence : ExpectedFluence
-            The expected fluence object.
-        mlc_struct : MLC_Struct
-            The MLC structure, so fluence can be calculated from leaf positions.
-        """
-        self.array: np.ndarray = np.empty((0, 0))
-        self.passfail_array: np.ndarray
-        self._actual_fluence: ActualFluence = actual_fluence
-        self._expected_fluence: ExpectedFluence = expected_fluence
-        self._mlc: MLC = mlc_struct
-
-    @lru_cache(maxsize=1)
-    def calc_map(
-        self,
-        doseTA: int | float = 1,
-        distTA: int | float = 1,
-        threshold: int | float = 0.1,
-        resolution: int | float = 0.1,
-        calc_individual_maps: bool = False,
-    ) -> np.ndarray:
-        """Calculate the gamma from the actual and expected fluences.
-
-        The gamma calculation is based on `Bakai et al
-        <http://iopscience.iop.org/0031-9155/48/21/006/>`_ eq.6,
-        which is a quicker alternative to the standard Low gamma equation.
-
-        Parameters
-        ----------
-        doseTA : int, float
-            Dose-to-agreement in percent; e.g. 2 is 2%.
-        distTA : int, float
-            Distance-to-agreement in mm.
-        threshold : int, float
-            The dose threshold percentage of the maximum dose, below which is not analyzed.
-        resolution : int, float
-            The resolution in mm of the resulting gamma map in the leaf-movement direction.
-        calc_individual_maps : bool
-            Not yet implemented.
-            If True, separate pixel maps for the distance-to-agreement and dose-to-agreement are created.
-
-        Returns
-        -------
-        numpy.ndarray
-            A num_mlc_leaves-x-400/resolution numpy array.
-        """
-        # calc fluences if need be
-        if (
-            not self._actual_fluence.is_map_calced()
-            or resolution != self._actual_fluence.resolution
-        ):
-            self._actual_fluence.calc_map(resolution)
-        if (
-            not self._expected_fluence.is_map_calced()
-            or resolution != self._expected_fluence.resolution
-        ):
-            self._expected_fluence.calc_map(resolution)
-
-        actual_img = image.load(self._actual_fluence.array, dpi=25.4 / resolution)
-        expected_img = image.load(self._expected_fluence.array, dpi=25.4 / resolution)
-        gamma_map = actual_img.gamma(
-            expected_img, doseTA=doseTA, distTA=distTA, threshold=threshold
-        )
-
-        # calculate standard metrics
-        self.avg_gamma = np.nanmean(gamma_map)
-        if np.isnan(self.avg_gamma):
-            self.avg_gamma = 0
-        pixels_passing = np.sum(gamma_map[~np.isnan(gamma_map)] < 1)
-        all_calcd_pixels = np.sum(gamma_map[~np.isnan(gamma_map)] >= 0)
-        self.pass_prcnt = pixels_passing / all_calcd_pixels * 100
-        gamma_map = np.nan_to_num(gamma_map)
-        self.passfail_array = gamma_map >= 1
-
-        self.distTA = distTA
-        self.doseTA = doseTA
-        self.threshold = threshold
-        self.resolution = resolution
-
-        self.array = gamma_map
-        return gamma_map
-
-    def plot_map(self, show: bool = True):
-        """Plot the fluence; the fluence (pixel map) must have been calculated first."""
-        self.is_map_calced(raise_error=True)
-        plt.imshow(self.array, aspect="auto", vmax=1, cmap=get_array_cmap())
-        plt.colorbar()
-        plt.show()
-
-    def histogram(self, bins: list | None = None) -> tuple[np.ndarray, np.ndarray]:
-        """Return a histogram array and bin edge array of the gamma map values.
-
-        Parameters
-        ----------
-        bins : sequence
-            The bin edges for the gamma histogram; see numpy.histogram for more info.
-
-        Returns
-        -------
-        histogram : numpy.ndarray
-            A 1D histogram of the gamma values.
-        bin_edges : numpy.ndarray
-            A 1D array of the bin edges. If left as None, the class default will be used (self.bins).
-        """
-        self.is_map_calced(raise_error=True)
-        if bins is None:
-            bins = self.bins
-        hist_arr, bin_edges = np.histogram(self.array, bins=bins)
-        return hist_arr, bin_edges
-
-    @argue.options(scale=("log", "linear"))
-    def plot_histogram(
-        self, scale: str = "log", bins: list | None = None, show: bool = True
-    ) -> None:
-        """Plot a histogram of the gamma map values.
-
-        Parameters
-        ----------
-        scale : {'log', 'linear'}
-            Scale of the plot y-axis.
-        bins : sequence
-            The bin edges for the gamma histogram; see numpy.histogram for more info.
-        """
-        self.is_map_calced(raise_error=True)
-        if bins is None:
-            bins = self.bins
-        plt.clf()
-        plt.hist(self.array.flatten(), bins=bins)
-        plt.yscale(scale)
-        if show:
-            plt.show()
-
-    @argue.options(scale=("log", "linear"))
-    def save_histogram(
-        self, filename: str, scale: str = "log", bins: list | None = None, **kwargs
-    ) -> None:
-        """Save the histogram plot to file."""
-        self.plot_histogram(scale, bins, show=False)
-        plt.savefig(filename, **kwargs)
-
-    def plot_passfail_map(self) -> None:
-        """Plot the binary gamma map, only showing whether pixels passed or failed."""
-        self.is_map_calced(raise_error=True)
-        plt.imshow(self.passfail_array, cmap=get_array_cmap())
-        plt.show()
-
-
-class FluenceStruct:
-    """Structure for data and methods having to do with fluences.
-
-    Attributes
-    ----------
-    actual : :class:`~pylinac.log_analyzer.FluenceBase`
-        The actual fluence delivered.
-    expected : :class:`~pylinac.log_analyzer.FluenceBase`
-        The expected, or planned, fluence.
-    gamma : :class:`~pylinac.log_analyzer.GammaFluence`
-        The gamma structure regarding the actual and expected fluences.
-    """
-
-    def __init__(self, mlc_struct=None, mu_axis: Axis = None, jaw_struct=None):
-        self.actual = ActualFluence(mlc_struct, mu_axis, jaw_struct)
-        self.expected = ExpectedFluence(mlc_struct, mu_axis, jaw_struct)
-        self.gamma = GammaFluence(self.actual, self.expected, mlc_struct)
-
-
-class MLC:
-    """The MLC class holds MLC information and retrieves relevant data about the MLCs and positions."""
-
-    def __init__(
-        self,
-        log_type,
-        snapshot_idx: np.ndarray | None = None,
-        jaw_struct=None,
-        hdmlc: bool = False,
-        subbeams=None,
-    ):
-        """
-        Parameters
-        ----------
-
-        log_type: :class:`~pylinac.log_analyzer.Dynalog`, :class:`~pylinac.log_analyzer.TrajectoryLog`
-            The log type.
-        snapshot_idx : array, list
-            The snapshots to be considered for RMS and error calculations (can be all snapshots or just when beam was on).
-        jaw_struct : :class:`~pylinac.log_analyzer.JawStruct`
-            The jaw structure.
-        hdmlc : boolean
-            If False (default), indicates a regular MLC model (e.g. Millennium 120).
-            If True, indicates an HD MLC model (e.g. Millennium 120 HD).
-
-        Attributes
-        ----------
-
-        leaf_axes : dict containing :class:`~pylinac.log_analyzer.Axis`
-            The dictionary is keyed by the leaf number, with the Axis as the value.
-
-            .. warning:: Leaf numbers are 1-index based to correspond with Varian convention.
-        """
-        self.leaf_axes: dict = {}
-        self.snapshot_idx = snapshot_idx
-        self._jaws = jaw_struct
-        self.hdmlc = hdmlc
-        self.log_type = log_type
-        self.subbeams = subbeams
-
-    @classmethod
-    def from_dlog(
-        cls,
-        dlog,
-        jaws,
-        snapshot_data: np.ndarray,
-        snapshot_idx: list | np.ndarray,
-    ):
-        """Construct an MLC structure from a Dynalog"""
-        mlc = MLC(Dynalog, snapshot_idx, jaws)
-        for leaf in range(1, (dlog.header.num_mlc_leaves // 2) + 1):
-            axis = LeafAxis(
-                expected=snapshot_data[(leaf - 1) * 4 + 14],
-                actual=snapshot_data[(leaf - 1) * 4 + 15],
-            )
-            mlc.add_leaf_axis(axis, leaf)
-
-        # read in "B"-file to get bank B MLC positions. The file must be in the same folder as the "A"-file.
-        # The header info is repeated but we already have that.
-        with open(dlog.b_logfile, encoding="utf-8") as csvf:
-            dlgdata = csv.reader(csvf, delimiter=",")
-            snapshot_data = np.array(
-                [line for line in dlgdata][dlog.HEADER_LINE_LENGTH :], dtype=float
-            ).transpose()
-
-        # Add bank B MLC positions to mlc snapshot arrays
-        for leaf in range(1, (dlog.header.num_mlc_leaves // 2) + 1):
-            axis = LeafAxis(
-                expected=snapshot_data[(leaf - 1) * 4 + 14],
-                actual=snapshot_data[(leaf - 1) * 4 + 15],
-            )
-            mlc.add_leaf_axis(axis, leaf_num=leaf + dlog.header.num_mlc_leaves // 2)
-
-        # scale dynalog leaf positions from the physical plane to the isocenter plane and from 100ths of mm to cm.
-        # MLC physical plane scaling factor to iso (100cm SAD) plane
-        # the below value was changed from 1.96614, which I believe I determined by dividing the
-        # MLC distance to iso based on old schematics. In any event, the new value is from a
-        # *ahem* credible source: Varian MLC Maintenance guide, pg 135.
-        dynalog_leaf_conversion = 1.96078
-        for leaf in range(1, mlc.num_leaves + 1):
-            mlc.leaf_axes[leaf].actual *= dynalog_leaf_conversion / 1000
-            mlc.leaf_axes[leaf].expected *= dynalog_leaf_conversion / 1000
-        return mlc
-
-    @classmethod
-    def from_tlog(cls, tlog, subbeams, jaws, snapshot_data, snapshot_idx, column_iter):
-        """Construct an MLC instance from a Trajectory log."""
-        mlc = MLC(TrajectoryLog, snapshot_idx, jaws, tlog.is_hdmlc, subbeams=subbeams)
-        for leaf_num in range(1, tlog.header.num_mlc_leaves + 1):
-            leaf_axis = _get_axis(snapshot_data, next(column_iter), LeafAxis)
-            mlc.add_leaf_axis(leaf_axis, leaf_num)
-        return mlc
-
-    @property
-    def num_pairs(self) -> int:
-        """Return the number of MLC pairs."""
-        return int(self.num_leaves / 2)
-
-    @property
-    def num_leaves(self) -> int:
-        """Return the number of MLC leaves."""
-        return len(self.leaf_axes)
-
-    @property
-    def num_snapshots(self) -> int:
-        """Return the number of snapshots used for MLC RMS & Fluence calculations.
-
-        .. warning::
-            This number may not be the same as the number of recorded snapshots in the log
-            since the snapshots where the beam was off may not be included. See :meth:`MachineLog.load`
-        """
-        return len(self.snapshot_idx)
-
-    @property
-    def num_moving_leaves(self) -> int:
-        """Return the number of leaves that moved."""
-        return len(self.moving_leaves)
-
-    @cached_property
-    def moving_leaves(self) -> np.ndarray:
-        """Return an array of the leaves that moved during treatment."""
-        threshold = 0.01
-        indices = ()
-        for leaf_num, leafdata in self.leaf_axes.items():
-            if type(self) == TrajectoryLog:
-                leaf_stdev = np.std(leafdata.actual[self.subbeams[-1]._snapshots])
-            else:
-                leaf_stdev = np.std(leafdata.actual[self.snapshot_idx])
-            if leaf_stdev > threshold:
-                indices += (leaf_num,)
-        return np.array(indices)
-
-    def add_leaf_axis(self, leaf_axis: LeafAxis, leaf_num: int) -> None:
-        """Add a leaf axis to the MLC data structure.
-
-        Parameters
-        ----------
-        leaf_axis : LeafAxis
-            The leaf axis to be added.
-        leaf_num : int
-            The leaf number.
-
-            .. warning:: Leaf numbers are 1-index based to correspond with Varian convention.
-        """
-        self.leaf_axes[leaf_num] = leaf_axis
-
-    def leaf_moved(self, leaf_num: int) -> bool:
-        """Return whether the given leaf moved during treatment.
-
-        Parameters
-        ----------
-        leaf_num : int
-
-
-        .. warning:: Leaf numbers are 1-index based to correspond with Varian convention.
-        """
-        return leaf_num in self.moving_leaves
-
-    def pair_moved(self, pair_num: int) -> bool:
-        """Return whether the given pair moved during treatment.
-
-        If either leaf moved, the pair counts as moving.
-
-        Parameters
-        ----------
-        pair_num : int
-
-
-        .. warning:: Pair numbers are 1-index based to correspond with Varian convention.
-        """
-        a_leaf = pair_num
-        b_leaf = pair_num + self.num_pairs
-        return self.leaf_moved(a_leaf) or self.leaf_moved(b_leaf)
-
-    @property
-    def _all_leaf_indices(self) -> np.ndarray:
-        """Return an array enumerated over all the leaves."""
-        return np.array(range(1, len(self.leaf_axes) + 1))
-
-    def get_RMS_avg(
-        self, bank: MLCBank = MLCBank.BOTH, only_moving_leaves: bool = False
-    ):
-        """Return the overall average RMS of given leaves.
-
-        Parameters
-        ----------
-        bank :
-            Specifies which bank(s) is desired.
-        only_moving_leaves : boolean
-            If False (default), include all the leaves.
-            If True, will remove the leaves that were static during treatment.
-
-            .. warning::
-                The RMS and error will nearly always be lower if all leaves are included since non-moving leaves
-                have an error of 0 and will drive down the average values. Convention would include all leaves,
-                but prudence would use only the moving leaves to get a more accurate assessment of error/RMS.
-
-        Returns
-        -------
-        float
-        """
-        leaves = self.get_leaves(bank, only_moving_leaves)
-        rms_array = self.create_RMS_array(leaves)
-        rms = np.mean(rms_array)
-        if np.isnan(rms):
-            return 0
-        else:
-            return rms
-
-    def get_RMS_max(self, bank: MLCBank = MLCBank.BOTH) -> float:
-        """Return the overall maximum RMS of given leaves.
-
-        Parameters
-        ----------
-        bank :
-            Specifies which bank(s) is desired.
-
-        Returns
-        -------
-        float
-        """
-        leaves = self.get_leaves(bank)
-        rms_array = self.create_RMS_array(leaves)
-        rms = np.max(rms_array)
-        if np.isnan(rms):
-            return 0
-        else:
-            return rms
-
-    def get_RMS_percentile(
-        self,
-        percentile: int | float = 95,
-        bank: MLCBank = MLCBank.BOTH,
-        only_moving_leaves: bool = False,
-    ):
-        """Return the n-th percentile value of RMS for the given leaves.
-
-        Parameters
-        ----------
-        percentile : int
-            RMS percentile desired.
-        bank :
-            Specifies which bank(s) is desired.
-        only_moving_leaves : boolean
-            If False (default), include all the leaves.
-            If True, will remove the leaves that were static during treatment.
-
-            .. warning::
-                The RMS and error will nearly always be lower if all leaves are included since non-moving leaves
-                have an error of 0 and will drive down the average values. Convention would include all leaves,
-                but prudence would use only the moving leaves to get a more accurate assessment of error/RMS.
-        """
-        leaves = self.get_leaves(bank, only_moving_leaves)
-        rms_array = self.create_RMS_array(leaves)
-        return np.percentile(rms_array, percentile)
-
-    def get_RMS(self, leaves_or_bank: str | MLCBank | Iterable) -> np.ndarray:
-        """Return an array of leaf RMSs for the given leaves or MLC bank.
-
-        Parameters
-        ----------
-        leaves_or_bank : sequence of numbers, {'a', 'b', 'both'}
-            If a sequence, must be a sequence of leaf numbers desired.
-            If a string, it specifies which bank (or both) is desired.
-
-        Returns
-        -------
-        numpy.ndarray
-            An array for the given leaves containing the RMS error.
-        """
-        if isinstance(leaves_or_bank, (str, MLCBank)):
-            leaves_or_bank = self.get_leaves(leaves_or_bank)
-        elif not is_iterable(leaves_or_bank):
-            raise TypeError("Input must be iterable, or specify an MLC bank")
-        return self.create_RMS_array(np.array(leaves_or_bank))
-
-    def get_leaves(
-        self, bank: MLCBank = MLCBank.BOTH, only_moving_leaves: bool = False
-    ) -> list:
-        """Return a list of leaves that match the given conditions.
-
-        Parameters
-        ----------
-        bank : {'A', 'B', 'both'}
-            Specifies which bank(s) is desired.
-        only_moving_leaves : boolean
-            If False (default), include all the leaves.
-            If True, will remove the leaves that were static during treatment.
-        """
-        bank = convert_to_enum(bank, MLCBank)
-
-        # get all leaves or only the moving leaves
-        if only_moving_leaves:
-            leaves = copy.copy(self.moving_leaves)
-        else:
-            leaves = copy.copy(self._all_leaf_indices)
-
-        # select leaves by bank if desired
-        if bank is not None:
-            if bank == MLCBank.A:
-                leaves = leaves[leaves <= self.num_pairs]
-            elif bank == MLCBank.B:
-                leaves = leaves[leaves > self.num_pairs]
-
-        return leaves
-
-    def get_error_percentile(
-        self,
-        percentile: int | float = 95,
-        bank: MLCBank = MLCBank.BOTH,
-        only_moving_leaves: bool = False,
-    ) -> float:
-        """Calculate the n-th percentile error of the leaf error.
-
-        Parameters
-        ----------
-        percentile : int
-            RMS percentile desired.
-        bank : {'A', 'B', 'both'}
-            Specifies which bank(s) is desired.
-        only_moving_leaves : boolean
-            If False (default), include all the leaves.
-            If True, will remove the leaves that were static during treatment.
-
-            .. warning::
-                The RMS and error will nearly always be lower if all leaves are included since non-moving leaves
-                have an error of 0 and will drive down the average values. Convention would include all leaves,
-                but prudence would use only the moving leaves to get a more accurate assessment of error/RMS.
-        """
-        leaves = self.get_leaves(bank, only_moving_leaves)
-        leaves -= 1
-        error_array = self.create_error_array(leaves)
-
-        abs_error = np.abs(error_array)
-        return np.percentile(abs_error, percentile)
-
-    def create_error_array(
-        self, leaves: Sequence[int], absolute: bool = True
-    ) -> np.ndarray:
-        """Create and return an error array of only the leaves specified.
-
-        Parameters
-        ----------
-        leaves : sequence
-            Leaves desired.
-        absolute : bool
-            If True, (default) absolute error will be returned.
-            If False, error signs will be retained.
-
-        Returns
-        -------
-        numpy.ndarray
-            An array of size leaves-x-num_snapshots
-        """
-        if absolute:
-            error_array = self._abs_error_all_leaves
-        else:
-            error_array = self._error_array_all_leaves
-        return error_array[leaves, :]
-
-    def create_RMS_array(self, leaves: Sequence[int]) -> np.ndarray:
-        """Create an RMS array of only the leaves specified.
-
-        Parameters
-        ----------
-        leaves : sequence
-            Leaves desired.
-
-        Returns
-        -------
-        numpy.ndarray
-            An array of size leaves-x-num_snapshots
-        """
-        rms_array = self._RMS_array_all_leaves
-        leaves -= 1
-        if len(leaves) == 0:
-            return np.array([0])
-        return rms_array[leaves]
-
-    @property
-    def _abs_error_all_leaves(self) -> float:
-        """Absolute error of all leaves."""
-        return np.abs(self._error_array_all_leaves)
-
-    @cached_property
-    def _error_array_all_leaves(self) -> np.ndarray:
-        """Error array of all leaves."""
-        mlc_error = np.zeros((self.num_leaves, self.num_snapshots))
-        # construct numpy array for easy array calculation
-        for leaf in range(self.num_leaves):
-            mlc_error[leaf, :] = self.leaf_axes[leaf + 1].difference[self.snapshot_idx]
-        return mlc_error
-
-    @argue.options(dtype=("actual", "expected"))
-    def _snapshot_array(self, dtype: str = "actual") -> np.ndarray:
-        """Return an array of the snapshot data of all leaves."""
-        arr = np.zeros((self.num_leaves, self.num_snapshots))
-        # construct numpy array for easy array calculation
-        for leaf in range(self.num_leaves):
-            arr[leaf, :] = getattr(self.leaf_axes[leaf + 1], dtype)[self.snapshot_idx]
-        return arr
-
-    @cached_property
-    def _RMS_array_all_leaves(self) -> np.ndarray:
-        """Return the RMS of all leaves."""
-        rms_array = np.array(
-            [
-                np.sqrt(
-                    np.sum(leafdata.difference[self.snapshot_idx] ** 2)
-                    / self.num_snapshots
-                )
-                for leafdata in self.leaf_axes.values()
-            ]
-        )
-        return rms_array
-
-    def leaf_under_y_jaw(self, leaf_num: int) -> bool:
-        """Return a boolean specifying if the given leaf is under one of the y jaws.
-
-        Parameters
-        ----------
-        leaf_num : int
-        """
-        outer_leaf_thickness = 10  # mm
-        inner_leaf_thickness = 5
-        mlc_position = 0
-        if self.hdmlc:
-            outer_leaf_thickness /= 2
-            inner_leaf_thickness /= 2
-            mlc_position = 100
-        for leaf in range(1, leaf_num + 1):
-            if 10 >= leaf or leaf >= 110:
-                mlc_position += outer_leaf_thickness
-            elif 50 >= leaf or leaf >= 70:
-                mlc_position += inner_leaf_thickness
-            else:  # between 50 and 70
-                mlc_position += outer_leaf_thickness
-
-        y2_position = self._jaws.y2.actual.max() * 10 + 200
-        y1_position = 200 - self._jaws.y1.actual.max() * 10
-        if 10 >= leaf or leaf >= 110:
-            thickness = outer_leaf_thickness
-        elif 50 >= leaf or leaf >= 70:
-            thickness = inner_leaf_thickness
-        else:  # between 50 and 70
-            thickness = outer_leaf_thickness
-        return mlc_position < y1_position or mlc_position - thickness > y2_position
-
-    @argue.options(dtype=("actual", "expected"))
-    def get_snapshot_values(
-        self,
-        bank_or_leaf: MLCBank | Iterable = MLCBank.BOTH,
-        dtype: str = "actual",
-    ) -> np.ndarray:
-        """Retrieve the snapshot data of the given MLC bank or leaf/leaves
-
-        Parameters
-        ----------
-        bank_or_leaf : str, array, list
-            If a str, specifies what bank ('A', 'B', 'both').
-            If an array/list, specifies what leaves (e.g. [1,2,3])
-        dtype : {'actual', 'expected'}
-            The type of MLC snapshot data to return.
-
-        Returns
-        -------
-        ndarray
-            An array of shape (number of leaves - x - number of snapshots). E.g. for an MLC bank
-            and 500 snapshots, the array would be (60, 500).
-        """
-        if isinstance(bank_or_leaf, (str, MLCBank)):
-            leaves = self.get_leaves(bank=bank_or_leaf)
-            leaves -= 1
-        else:
-            leaves = bank_or_leaf
-
-        arr = self._snapshot_array(dtype)
-        return arr[leaves, :]
-
-    def plot_mlc_error_hist(self, show: bool = True) -> None:
-        """Plot an MLC error histogram."""
-        plt.hist(self._abs_error_all_leaves.flatten())
-        if show:
-            plt.show()
-
-    def save_mlc_error_hist(self, filename: str, **kwargs) -> None:
-        """Save the MLC error histogram to file."""
-        self.plot_mlc_error_hist(show=False)
-        plt.savefig(filename, **kwargs)
-
-    def plot_rms_by_leaf(self, show: bool = True) -> None:
-        """Plot RMSs by leaf."""
-        plt.clf()
-        plt.bar(
-            np.arange(len(self.get_RMS(MLCBank.BOTH)))[::-1],
-            self.get_RMS(MLCBank.BOTH),
-            align="center",
-        )
-        if show:
-            plt.show()
-
-    def save_rms_by_leaf(self, filename: str, **kwargs) -> None:
-        """Save the RMS-leaf to file."""
-        self.plot_rms_by_leaf(show=False)
-        plt.savefig(filename, **kwargs)
-
-
-class JawStruct:
-    """Jaw Axes data structure.
-
-    Attributes
-    ----------
-    x1 : :class:`~pylinac.log_analyzer.Axis`
-    y1 : :class:`~pylinac.log_analyzer.Axis`
-    x2 : :class:`~pylinac.log_analyzer.Axis`
-    y2 : :class:`~pylinac.log_analyzer.Axis`
-    """
-
-    def __init__(self, x1: HeadAxis, y1: HeadAxis, x2: HeadAxis, y2: HeadAxis):
-        if not all(
-            (
-                isinstance(x1, HeadAxis),
-                isinstance(y1, HeadAxis),
-                isinstance(x2, HeadAxis),
-                isinstance(y2, HeadAxis),
-            )
-        ):
-            raise TypeError("HeadAxis not passed into Jaw structure")
-        self.x1 = x1
-        self.y1 = y1
-        self.x2 = x2
-        self.y2 = y2
-
-
-class CouchStruct:
-    """Couch Axes data structure."""
-
-    vert: CouchAxis
-    long: CouchAxis
-    latl: CouchAxis
-    rotn: CouchAxis
-    pitch: CouchAxis | None
-    roll: CouchAxis | None
-
-    def __init__(
-        self,
-        vertical: CouchAxis,
-        longitudinal: CouchAxis,
-        lateral: CouchAxis,
-        rotational: CouchAxis,
-        pitch: CouchAxis | None = None,
-        roll: CouchAxis | None = None,
-    ):
-        if not all(
-            (
-                isinstance(vertical, CouchAxis),
-                isinstance(longitudinal, CouchAxis),
-                isinstance(lateral, CouchAxis),
-                isinstance(rotational, CouchAxis),
-            )
-        ):
-            raise TypeError("Couch structure must be passed Couch Axes.")
-        self.vert = vertical
-        self.long = longitudinal
-        self.latl = lateral
-        self.rotn = rotational
-        if pitch is not None:
-            self.pitch = pitch
-            self.roll = roll
-        else:
-            self.pitch = None
-            self.roll = None
-
-
-class Subbeam:
-    """Data structure for trajectory log "subbeams". Only applicable for auto-sequenced beams.
-
-    Attributes
-    ----------
-    control_point : int
-        Internally-defined marker that defines where the plan is currently executing.
-    mu_delivered : float
-        Dose delivered in units of MU.
-    rad_time : float
-        Radiation time in seconds.
-    sequence_num : int
-        Sequence number of the subbeam.
-    beam_name : str
-        Name of the subbeam.
-    """
-
-    def __init__(self, file, log_version: float):
-        f = file
-        self.control_point = decode_binary(f, int)
-        self.mu_delivered = decode_binary(f, float)
-        self.rad_time = decode_binary(f, float)
-        self.sequence_num = decode_binary(f, int)
-        # In Tlogs version 3.0 and up, beam names are 512 byte unicode strings, but in <3.0 they are 32 byte unicode strings
-        if log_version >= 3:
-            chars = 512
-        else:
-            chars = 32
-        self.beam_name = decode_binary(f, str, chars, 32)
-
-    @property
-    def gantry_angle(self) -> float:
-        """Median gantry angle of the subbeam."""
-        return self._get_metadata_axis("gantry")
-
-    @property
-    def collimator_angle(self) -> float:
-        """Median collimator angle of the subbeam."""
-        return self._get_metadata_axis("collimator")
-
-    @property
-    def jaw_x1(self) -> float:
-        """Median X1 position of the subbeam."""
-        return self._get_metadata_axis("jaws", "x1")
-
-    @property
-    def jaw_x2(self) -> float:
-        """Median X2 position of the subbeam."""
-        return self._get_metadata_axis("jaws", "x2")
-
-    @property
-    def jaw_y1(self) -> float:
-        """Median Y1 position of the subbeam."""
-        return self._get_metadata_axis("jaws", "y1")
-
-    @property
-    def jaw_y2(self) -> float:
-        """Median Y2 position of the subbeam."""
-        return self._get_metadata_axis("jaws", "y2")
-
-    def _get_metadata_axis(self, attr, subattr=None) -> Axis:
-        if subattr is None:
-            actual = getattr(self._axis_data, attr).actual[self._snapshots]
-            expected = getattr(self._axis_data, attr).expected[self._snapshots]
-        else:
-            actual = getattr(getattr(self._axis_data, attr), subattr).actual[
-                self._snapshots
-            ]
-            expected = getattr(getattr(self._axis_data, attr), subattr).expected[
-                self._snapshots
-            ]
-        return Axis(np.median(actual), np.median(expected))
-
-
-class SubbeamManager:
-    """One of 4 subsections of a trajectory log. Holds a list of Subbeams; only applicable for auto-sequenced beams."""
-
-    def __init__(self, file, header):
-        self.subbeams = []
-        if header.num_subbeams > 0:
-            for _ in range(header.num_subbeams):
-                subbeam = Subbeam(file, header.version)
-                self.subbeams.append(subbeam)
-
-    def post_hoc_metadata(self, axis_data):
-        """From the Axis Data, perform post-hoc analysis and set metadata to the subbeams.
-        Gives the subbeams more information, as not much is given directly in the logs.
-        """
-        for subbeam_num, subbeam in enumerate(self.subbeams):
-            self._set_subbeam_snapshots(axis_data, subbeam_num)
-            mlc_subsection = copy.copy(axis_data.mlc)
-            mlc_subsection.snapshot_idx = subbeam._snapshots
-            subbeam.fluence = FluenceStruct(
-                mlc_subsection, axis_data.mu, axis_data.jaws
-            )
-        gc.collect()  # don't know why gc is needed; maybe something to do w/ copy?
-
-    def _set_subbeam_snapshots(self, axis_data, beam_num: int):
-        """Get the snapshot indices 1) where the beam was on and 2) between the subbeam control point values."""
-        subbeam = self.subbeams[beam_num]
-        cp_by_snapshot = axis_data.control_point.actual
-
-        # find upper and lower bounds of the subbeam control points
-        cp_lower_bound = subbeam.control_point
-        try:
-            cp_upper_bound = self.subbeams[beam_num + 1].control_point
-        except IndexError:
-            cp_upper_bound = cp_by_snapshot[-1]
-
-        # extract the snapshots within those control points and drop the beam holds as booleans
-        snapshots_within_subbeam = np.logical_and(
-            cp_by_snapshot >= cp_lower_bound, cp_by_snapshot < cp_upper_bound
-        )
-        beam_on_snapshots = axis_data.beam_hold.actual == 0
-        combined_snaps_as_bool = np.logical_and(
-            beam_on_snapshots, snapshots_within_subbeam
-        )
-        # convert boolean array back to snapshot indices
-        combined_snapshots = [
-            snapshot_idx
-            for (snapshot_idx, boolean_snapshot) in enumerate(combined_snaps_as_bool)
-            if boolean_snapshot
-        ]
-
-        subbeam._snapshots = combined_snapshots
-        subbeam._axis_data = axis_data
-
-    def __getitem__(self, item) -> Subbeam:
-        return self.subbeams[item]
-
-    def __len__(self):
-        return len(self.subbeams)
-
-
-class LogBase:
-    """Base class for the Dynalog and TrajectoryLog classes. Should not be called directly."""
-
-    ANON_LINE = -1
-
-    def __init__(self, filename: str, exclude_beam_off: bool = True):
-        if is_log(filename):
-            self.filename = filename
-            self.exclude_beam_off = exclude_beam_off
-        else:
-            raise OSError(f"{filename} was not a valid log file")
-
-    @classmethod
-    def from_url(cls, url: str, exclude_beam_off: bool = True):
-        """Instantiate a log from a URL."""
-        filename = io.get_url(url)
-        return cls(filename, exclude_beam_off)
-
-    def plot_summary(self, show: bool = True):
-        """Plot actual & expected fluence, gamma map, gamma histogram,
-        MLC error histogram, and MLC RMS histogram.
-        """
-        self.fluence.gamma.is_map_calced(raise_error=True)
-
-        # plot the actual fluence
-        ax = plt.subplot(2, 3, 1)
-        self.plot_subfluence(Fluence.ACTUAL, ax, show=False)
-
-        # plot the expected fluence
-        ax = plt.subplot(2, 3, 2)
-        self.plot_subfluence(Fluence.EXPECTED, ax, show=False)
-
-        # plot the gamma map
-        ax = plt.subplot(2, 3, 3)
-        self.plot_subfluence(Fluence.GAMMA, ax, show=False)
-
-        # plot the gamma histogram
-        ax = plt.subplot(2, 3, 4)
-        self.plot_subgraph(Graph.GAMMA, ax, show=False)
-
-        # plot the MLC error histogram
-        ax = plt.subplot(2, 3, 5)
-        self.plot_subgraph(Graph.HISTOGRAM, ax, show=False)
-
-        # plot the leaf RMSs
-        ax = plt.subplot(2, 3, 6)
-        self.plot_subgraph("rms", ax, show=False)
-
-        if show:
-            plt.show()
-
-    def save_summary(self, filename: str, **kwargs) -> None:
-        """Save the summary image to file."""
-        self.plot_summary(show=False)
-        plt.savefig(filename, **kwargs)
-        plt.close()
-
-    def plot_subfluence(
-        self, img: Fluence, ax: plt.Axes = None, show: bool = True, fontsize: int = 10
-    ):
-        """Plot a subimage."""
-        img = convert_to_enum(img, Fluence)
-        if ax is None:
-            ax = plt.subplot()
-        ax.tick_params(axis="both", labelsize=8)
-        if img in (Fluence.ACTUAL, Fluence.EXPECTED):
-            title = img.value.capitalize() + " Image"
-            plt.imshow(
-                getattr(self.fluence, img.value).array.astype(np.float32),
-                aspect="auto",
-                interpolation="none",
-                cmap=get_array_cmap(),
-            )
-        elif img == Fluence.GAMMA:
-            plt.imshow(
-                getattr(self.fluence, img.value).array.astype(np.float32),
-                aspect="auto",
-                interpolation="none",
-                vmax=1,
-                cmap=get_array_cmap(),
-            )
-            plt.colorbar(ax=ax)
-            title = "Gamma Map"
-        ax.autoscale(tight=True)
-        ax.set_title(title, fontsize=fontsize)
-        if show:
-            plt.show()
-
-    def save_subimage(
-        self, filename: str | BinaryIO, img: Fluence, fontsize: int, **kwargs
-    ):
-        """Save a subimage to file"""
-        self.plot_subfluence(img, show=False, fontsize=fontsize)
-        plt.savefig(filename, **kwargs)
-        plt.close()
-
-    def plot_subgraph(
-        self,
-        graph: Graph,
-        ax: plt.Axes = None,
-        show: bool = True,
-        fontsize: int = 10,
-        labelsize: int = 8,
-    ):
-        graph = convert_to_enum(graph, Graph)
-        if ax is None:
-            ax = plt.subplot()
-        if graph == Graph.GAMMA:
-            title = "Gamma Histogram"
-            plt.hist(self.fluence.gamma.array.flatten(), bins=self.fluence.gamma.bins)
-            ax.set_yscale("log")
-        elif graph == Graph.HISTOGRAM:
-            title = "Leaf Histogram"
-            plt.hist(self.axis_data.mlc._abs_error_all_leaves.flatten())
-        elif graph == Graph.RMS:
-            title = "Leaf RMS (mm)"
-            ax.set_xlim(
-                [-0.5, self.axis_data.mlc.num_leaves + 0.5]
-            )  # bit of padding since bar chart alignment is center
-            plt.bar(
-                np.arange(len(self.axis_data.mlc.get_RMS("both")))[::-1],
-                self.axis_data.mlc.get_RMS("both") * 10,
-                align="center",
-            )
-        ax.set_title(title, fontsize=fontsize)
-        ax.tick_params(axis="both", labelsize=labelsize)
-        ax.grid(True)
-        if show:
-            plt.show()
-
-    def save_subgraph(
-        self,
-        filename: str | BinaryIO,
-        graph: Graph,
-        fontsize: int = 10,
-        labelsize: int = 8,
-        **kwargs,
-    ):
-        self.plot_subgraph(graph, show=False, fontsize=fontsize, labelsize=labelsize)
-        plt.savefig(filename, **kwargs)
-        plt.close()
-
-    def report_basic_parameters(self, printout: bool = True) -> str:
-        """Print the common parameters analyzed when investigating machine logs:
-
-        - Log type
-        - Average MLC RMS
-        - Maximum MLC RMS
-        - 95th percentile MLC error
-        - Number of beam holdoffs
-        - Gamma pass percentage
-        - Average gamma value
-        """
-        title = f"Results of file: {self.filename}\n"
-        if self.treatment_type == TreatmentType.IMAGING.value:
-            string = title + "Log is an Imaging field; no statistics can be calculated"
-        else:
-            avg_rms = f"Average RMS of all leaves: {self.axis_data.mlc.get_RMS_avg(only_moving_leaves=False)*10:3.3f} mm\n"
-            max_rms = f"Max RMS error of all leaves: {self.axis_data.mlc.get_RMS_max()*10:3.3f} mm\n"
-            p95 = f"95th percentile error: {self.axis_data.mlc.get_error_percentile(95, only_moving_leaves=False)*10:3.3f} mm\n"
-            num_holdoffs = f"Number of beam holdoffs: {self.num_beamholds:1.0f}\n"
-            self.fluence.gamma.calc_map()
-            gamma_pass = f"Gamma pass %: {self.fluence.gamma.pass_prcnt:2.2f}\n"
-            gamma_avg = f"Gamma average: {self.fluence.gamma.avg_gamma:2.3f}\n"
-
-            string = (
-                title + avg_rms + max_rms + p95 + num_holdoffs + gamma_pass + gamma_avg
-            )
-        if printout:
-            print(string)
-        return string
-
-    @property
-    def treatment_type(self) -> str:
-        """The treatment type of the log. Possible options:
-
-        Returns
-        -------
-        str
-            See :class:`~pylinac.log_analyzer.TreatmentType`
-        """
-        if isinstance(self, TrajectoryLog):  # trajectory log
-            gantry_std = max(
-                subbeam.gantry_angle.actual.std() for subbeam in self.subbeams
-            )
-            if np.isnan(gantry_std):
-                return TreatmentType.IMAGING.value
-        else:
-            gantry_std = self.axis_data.gantry.actual.std()
-        if gantry_std > 0.5:
-            return TreatmentType.VMAT.value
-        elif self.axis_data.mu.actual.max() <= 2.1:
-            return TreatmentType.IMAGING.value
-        elif self.axis_data.mlc.num_moving_leaves == 0 and isinstance(
-            self, TrajectoryLog
-        ):
-            return TreatmentType.STATIC_IMRT.value
-        else:
-            return TreatmentType.DYNAMIC_IMRT.value
-
-    @property
-    def _underscore_idx(self) -> int:
-        base_filename = osp.basename(self.filename)
-        under_index = base_filename.find("_")
-        if under_index < 0:
-            raise NameError(
-                f"Filename `{base_filename}` has no underscore. "
-                "Place an underscore between the patient ID and the rest of the filename and try again."
-            )
-        return under_index
-
-
-class DynalogHeader(Structure):
-    """
-    Attributes
-    ----------
-    version : str
-        The Dynalog version letter.
-    patient_name : str
-        Patient information.
-    plan_filename : str
-        Filename if using standalone. If using Treat =<6.5 will produce PlanUID, Beam Number.
-        Not yet implemented for this yet.
-    tolerance : int
-        Plan tolerance.
-    num_mlc_leaves : int
-        Number of MLC leaves.
-    clinac_scale : int
-        Clinac scale; 0 -> Varian scale, 1 -> IEC 60601-2-1 scale
-    """
-
-    def __init__(self, dlogdata):
-        c = itertools.count()
-        super().__init__(
-            version=str(dlogdata[next(c)]),
-            patient_name=dlogdata[next(c)],
-            plan_filename=dlogdata[next(c)],
-            tolerance=int(dlogdata[next(c)][0]),
-            num_mlc_leaves=int(dlogdata[next(c)][0]) * 2,
-            clinac_scale=int(dlogdata[next(c)][0]),
-        )
-
-
-class DynalogAxisData:
-    """
-    Attributes
-    ----------
-    num_snapshots : int
-        Number of snapshots recorded.
-    mu : :class:`~pylinac.log_analyzer.Axis`
-        Current dose fraction
-
-        .. note:: This *can* be gantry rotation under certain conditions. See Dynalog file specs.
-
-    previous_segment_num : :class:`~pylinac.log_analyzer.Axis`
-        Previous segment *number*, starting with zero.
-    beam_hold : :class:`~pylinac.log_analyzer.Axis`
-        Beam hold state; 0 -> holdoff not asserted (beam on), 1 -> holdoff asserted, 2 -> carriage in transition
-    beam_on : :class:`~pylinac.log_analyzer.Axis`
-        Beam on state; 1 -> beam is on, 0 -> beam is off
-    prior_dose_index : :class:`~pylinac.log_analyzer.Axis`
-        Previous segment dose index or previous segment gantry angle.
-    next_dose_index : :class:`~pylinac.log_analyzer.Axis`
-        Next segment dose index.
-    gantry : :class:`~pylinac.log_analyzer.Axis`
-        Gantry data in degrees.
-    collimator : :class:`~pylinac.log_analyzer.Axis`
-        Collimator data in degrees.
-    jaws : :class:`~pylinac.log_analyzer.Jaw_Struct`
-        Jaw data structure. Data in cm.
-    carriage_A : :class:`~pylinac.log_analyzer.Axis`
-        Carriage A data. Data in cm.
-    carriage_B : :class:`~pylinac.log_analyzer.Axis`
-        Carriage B data. Data in cm.
-    mlc : :class:`~pylinac.log_analyzer.MLC`
-        MLC data structure. Data in cm.
-    """
-
-    def __init__(self, log, dlogdata):
-        """Read the dynalog axis data."""
-        snapshot_data = np.array(dlogdata[6:], dtype=np.float64).transpose()
-
-        self.num_snapshots = np.size(snapshot_data, 1)
-
-        c = itertools.count()
-
-        def nx():
-            return snapshot_data[next(c)]
-
-        # assignment of snapshot values
-        # There is no "expected" MU in dynalogs, but for fluence calc purposes, it is set to that of the actual
-        mu = nx()
-
-        # if treatment was vmat then MU is replaced by gantry angle (so stupid). If so, convert to normalized MU by looking at gantry movement.
-        def correct_vmat_mu(mu_array):
-            if mu_array[-1] == 25000:
-                return mu_array
-            else:
-                abs_diff = list(np.abs(np.diff(mu_array)))
-                # this is the cumulative gantry diff, a surrogate for MU. Normalize to 25000 to look like a "normal" dynalog
-                cum_gantry_diff = (
-                    np.array(
-                        [
-                            0,
-                        ]
-                        + list(np.cumsum(abs_diff) / np.sum(abs_diff))
-                    )
-                    * 25000
-                )
-                return cum_gantry_diff
-
-        corrected_mu = correct_vmat_mu(mu)
-
-        self.mu = Axis(corrected_mu, corrected_mu)
-        self.previous_segment_num = Axis(nx())
-        self.beam_hold = Axis(nx())
-        self.beam_on = Axis(nx())
-        self.prior_dose_index = Axis(nx())  # currently not used for anything
-        self.next_dose_index = Axis(nx())  # ditto
-        self.gantry = GantryAxis(nx() / 10)
-        self.collimator = HeadAxis(nx() / 10)
-
-        # jaws are in mm; convert to cm by /10
-        jaw_y1 = HeadAxis(nx() / 10)
-        jaw_y2 = HeadAxis(nx() / 10)
-        jaw_x1 = HeadAxis(nx() / 10)
-        jaw_x2 = HeadAxis(nx() / 10)
-        self.jaws = JawStruct(jaw_x1, jaw_y1, jaw_x2, jaw_y2)
-
-        # carriages are in 100ths of mm; converted to cm.
-        self.carriage_A = Axis(nx() / 1000)
-        self.carriage_B = Axis(nx() / 1000)
-
-        if log.exclude_beam_off:
-            hold_idx = np.where(self.beam_hold.actual == 0)[0]
-            beamon_idx = np.where(self.beam_on.actual == 1)[0]
-            snapshot_idx = np.intersect1d(hold_idx, beamon_idx)
-        else:
-            snapshot_idx = list(range(self.num_snapshots))
-
-        self.num_snapshots = self.num_snapshots
-        self.mlc = MLC.from_dlog(log, self.jaws, snapshot_data, snapshot_idx)
-
-
-class Dynalog(LogBase):
-    """Class for loading, analyzing, and plotting data within a Dynalog file.
-
-    Attributes
-    ----------
-    header : :class:`~pylinac.log_analyzer.DynalogHeader`
-    axis_data : :class:`~pylinac.log_analyzer.DynalogAxisData`
-    fluence : :class:`~pylinac.log_analyzer.FluenceStruct`
-    """
-
-    ANON_LINE = 1
-    HEADER_LINE_LENGTH = 6
-
-    def __init__(self, filename, exclude_beam_off: bool = True):
-        super().__init__(filename, exclude_beam_off)
-        if not is_dlog(self.filename):
-            raise NotADynalogError(f"{self.filename} was not a valid Dynalog file")
-        if not self._has_other_file:
-            raise DynalogMatchError(
-                "Didn't find the matching dynalog file"
-            )  # TODO: clean up
-
-        with open(self.a_logfile, encoding="utf-8") as a_log:
-            dlgdata = [line for line in csv.reader(a_log, delimiter=",")]
-        self.header = DynalogHeader(dlgdata)
-        self.axis_data = DynalogAxisData(self, dlgdata)
-        self.fluence = FluenceStruct(
-            self.axis_data.mlc, self.axis_data.mu, self.axis_data.jaws
-        )
-
-    def anon_file_renames(self, destination: str, suffix: str) -> dict:
-        base_a = osp.basename(self.a_logfile)
-        base_b = osp.basename(self.b_logfile)
-        anonymous_base_a = (
-            base_a[: self._underscore_idx] + "_Anonymous" + suffix + ".dlg"
-        )
-        anonymous_base_b = (
-            base_b[: self._underscore_idx] + "_Anonymous" + suffix + ".dlg"
-        )
-        anonymous_a = osp.join(destination, anonymous_base_a)
-        anonymous_b = osp.join(destination, anonymous_base_b)
-        filenames = collections.OrderedDict()
-        filenames[self.a_logfile] = anonymous_a
-        filenames[self.b_logfile] = anonymous_b
-        return filenames
-
-    def anon_files(self, destination: str, suffix: str):
-        return self.anon_file_renames(destination, suffix).values()
-
-    def snapshot_idx(self, axis_data) -> list:
-        if self.exclude_beam_off:
-            hold_idx = np.where(axis_data.beam_hold.actual == 0)[0]
-            beamon_idx = np.where(axis_data.beam_on.actual == 1)[0]
-            snapshot_idx = np.intersect1d(hold_idx, beamon_idx)
-        else:
-            snapshot_idx = list(range(self.num_snapshots))
-        return snapshot_idx
-
-    @property
-    def _has_other_file(self) -> bool:
-        """Whether the companion file (A* for B-file or vic versa)."""
-        return (
-            True
-            if self.identify_other_file(self.filename, raise_find_error=False)
-            is not None
-            else False
-        )
-
-    @cached_property
-    def a_logfile(self) -> str:
-        """Path of the A* dynalog file."""
-        other_dlg_file = self.identify_other_file(self.filename)
-        return (
-            self.filename
-            if osp.basename(self.filename).startswith("A")
-            else other_dlg_file
-        )
-
-    @cached_property
-    def b_logfile(self) -> str:
-        """Path of the B* dynalog file."""
-        other_dlg_file = self.identify_other_file(self.filename)
-        return (
-            self.filename
-            if osp.basename(self.filename).startswith("B")
-            else other_dlg_file
-        )
-
-    @property
-    def num_beamholds(self) -> int:
-        """Return the number of times the beam was held."""
-        diffmatrix = np.diff(self.axis_data.beam_hold.actual)
-        num_holds = int(np.sum(diffmatrix > 0))
-        return num_holds
-
-    @classmethod
-    def from_demo(cls, exclude_beam_off: bool = True):
-        """Load and instantiate from the demo dynalog file included with the package."""
-        demo_file = io.retrieve_demo_file(name="AQA.dlg")
-        io.retrieve_demo_file(name="BQA.dlg")  # also download "B" dynalog
-        return cls(demo_file, exclude_beam_off)
-
-    @staticmethod
-    def run_demo():
-        """Run the Dynalog demo."""
-        dlog = Dynalog.from_demo()
-        dlog.report_basic_parameters()
-        dlog.plot_summary()
-
-    def publish_pdf(
-        self,
-        filename: str,
-        notes: str = None,
-        metadata: dict = None,
-        open_file: bool = False,
-        logo: Path | str | None = None,
-    ):
-        """Publish (print) a PDF containing the analysis and quantitative results.
-
-        Parameters
-        ----------
-        filename : (str, file-like object}
-            The file to write the results to.
-        notes : str, list of strings
-            Text; if str, prints single line.
-            If list of strings, each list item is printed on its own line.
-        open_file : bool
-            Whether to open the file using the default program after creation.
-        metadata : dict
-            Extra data to be passed and shown in the PDF. The key and value will be shown with a colon.
-            E.g. passing {'Author': 'James', 'Unit': 'TrueBeam'} would result in text in the PDF like:
-            --------------
-            Author: James
-            Unit: TrueBeam
-            --------------
-        logo: Path, str
-            A custom logo to use in the PDF report. If nothing is passed, the default pylinac logo is used.
-        """
-        self.fluence.gamma.calc_map()
-        canvas = pdf.PylinacCanvas(
-            filename, page_title="Dynalog Analysis", metadata=metadata, logo=logo
-        )
-        canvas.add_text(
-            text=[
-                "Dynalog results:",
-                f"Average RMS (mm): {self.axis_data.mlc.get_RMS_avg()*10:2.2f}",
-                f"Max RMS (mm): {self.axis_data.mlc.get_RMS_max()*10:2.2f}",
-                f"95th Percentile error (mm): {self.axis_data.mlc.get_error_percentile(95)*10:2.2f}",
-                f"Number of beam holdoffs: {self.num_beamholds}",
-                f"Gamma pass (%): {self.fluence.gamma.pass_prcnt:2.1f}",
-                f"Gamma average: {self.fluence.gamma.avg_gamma:2.2f}",
-            ],
-            location=(10, 25.5),
-        )
-        for idx, (x, y, graph) in enumerate(
-            zip((2, 11, 2, 11), (14, 14, 6, 6), ("actual", "expected", "gamma", ""))
-        ):
-            data = BytesIO()
-            if idx != 3:
-                self.save_subimage(data, graph, fontsize=20)
-            else:
-                self.save_subgraph(data, "gamma", fontsize=20, labelsize=12)
-            canvas.add_image(data, location=(x, y), dimensions=(9, 9))
-        if notes is not None:
-            canvas.add_text(location=(1, 5.5), font_size=14, text="Notes:")
-            canvas.add_text(location=(1, 5), text=notes)
-        canvas.add_new_page()
-        for idx, (x, y, graph) in enumerate(
-            zip((5, 5), (13, 2), (Graph.HISTOGRAM, Graph.RMS))
-        ):
-            data = BytesIO()
-            self.save_subgraph(data, graph, fontsize=20, labelsize=12)
-            canvas.add_image(location=(x, y), dimensions=(13, 13), image_data=data)
-        canvas.finish()
-
-        if open_file:
-            webbrowser.open(filename)
-
-    @staticmethod
-    def identify_other_file(first_dlg_file: str, raise_find_error: bool = True) -> str:
-        """Return the filename of the corresponding dynalog file.
-
-        For example, if the A*.dlg file was passed in, return the corresponding B*.dlg filename.
-        Can find both A- and B-files.
-
-        Parameters
-        ----------
-        first_dlg_file : str
-            The absolute file path of the dynalog file.
-        raise_find_error : bool
-            Whether to raise an error if the file isn't found.
-
-        Returns
-        -------
-        str
-            The absolute file path to the corresponding dynalog file.
-        """
-        dlg_dir, dlg_file = osp.split(first_dlg_file)
-        if dlg_file.startswith("A"):
-            file2get = dlg_file.replace("A", "B", 1)
-        elif dlg_file.startswith("B"):
-            file2get = dlg_file.replace("B", "A", 1)
-        else:
-            raise ValueError(
-                "Unable to decipher log names; ensure dynalogs start with 'A' and 'B'"
-            )
-        other_filename = osp.join(dlg_dir, file2get)
-
-        if osp.isfile(other_filename):
-            return other_filename
-        elif raise_find_error:
-            raise FileNotFoundError(
-                "Complementary dlg file not found; ensure A and B-file are in same directory."
-            )
-
-    def anonymize(
-        self,
-        inplace: bool = False,
-        destination: str | None = None,
-        suffix: str | None = None,
-    ) -> list[str]:
-        """Save an anonymized version of the log.
-
-        For dynalogs, this replaces the patient ID in the filename(s) and the second line of the log with ``Anonymous<suffix>``.
-        This will rename both A* and B* logs if both are present in the same directory.
-
-        .. note::
-            Anonymization is only available for logs loaded locally (i.e. not from a URL or a data stream). To
-            anonymize such a log it must be first downloaded or written to a file, then loaded in.
-
-        .. note::
-            Anonymization is done to the log **file** itself. The current instance of ``MachineLog`` will not be anonymized.
-
-        Parameters
-        ----------
-        inplace : bool
-            If False (default), creates an anonymized **copy** of the log(s).
-            If True, **renames and replaces** the content of the log file.
-        destination : str, optional
-            A string specifying the directory where the newly anonymized logs should be placed.
-            If None, will place the logs in the same directory as the originals.
-        suffix : str, optional
-            An optional suffix that is added after ``Anonymous`` to give specificity to the log.
-
-        Returns
-        -------
-        list
-            A list containing the paths to the newly written files.
-        """
-        if suffix is None:
-            suffix = ""
-
-        # determine destination directory
-        if destination is None:
-            dest_dir = osp.dirname(self.filename)
-        else:
-            if not osp.isdir(destination):
-                raise NotADirectoryError(
-                    f"Specified destination `{destination}` was not a valid directory"
-                )
-            dest_dir = destination
-
-        # copy or rename the files, depending on `inplace` parameter
-        anonymous_filenames = self.anon_file_renames(dest_dir, suffix)
-        method = os.rename if inplace else shutil.copy
-        for old_file, new_file in anonymous_filenames.items():
-            method(old_file, new_file)
-
-        # now the actual anonymization
-        for file in self.anon_files(dest_dir, suffix):
-            with open(file, encoding="utf-8") as f:
-                txtdata = f.readlines()
-            txtdata[self.ANON_LINE] = "Patient ID:\tAnonymous_" + suffix + "\n"
-            with open(file, mode="w", encoding="utf-8") as f:
-                f.writelines(txtdata)
-            print("Anonymized file written to: ", file)
-
-        return list(anonymous_filenames.values())
-
-
-class TrajectoryLogAxisData:
-    """
-    Attributes
-    ----------
-    collimator : :class:`~pylinac.log_analyzer.Axis`
-        Collimator data in degrees.
-    gantry : :class:`~pylinac.log_analyzer.Axis`
-        Gantry data in degrees.
-    jaws : :class:`~pylinac.log_analyzer.JawStruct`
-        Jaw data structure. Data in cm.
-    couch : :class:`~pylinac.log_analyzer.CouchStruct`
-        Couch data structure. Data in cm.
-    mu : :class:`~pylinac.log_analyzer.Axis`
-        MU data in MU.
-    beam_hold : :class:`~pylinac.log_analyzer.Axis`
-        Beam hold state. Beam *pauses* (e.g. Beam Off button pressed) are not recorded in the log.
-        Data is automatic hold state.
-        0 -> Normal; beam on.
-        1 -> Freeze; beam on, dose servo is temporarily turned off.
-        2 -> Hold; servo holding beam.
-        3 -> Disabled; beam on, dose servo is disable via Service.
-    control_point : :class:`~pylinac.log_analyzer.Axis`
-        Current control point.
-    carriage_A : :class:`~pylinac.log_analyzer.Axis`
-        Carriage A data in cm.
-    carriage_B : :class:`~pylinac.log_analyzer.Axis`
-        Carriage B data in cm.
-    mlc : :class:`~pylinac.log_analyzer.MLC`
-        MLC data structure; data in cm.
-    """
-
-    def __init__(self, log, file, subbeams):
-        # step size in bytes
-        step_size = sum(log.header.samples_per_axis) * 2
-
-        # read in all snapshot data at once, then assign
-        snapshot_data = decode_binary(file, float, step_size * log.header.num_snapshots)
-
-        # reshape snapshot data to be a x-by-num_snapshots matrix
-        snapshot_data = snapshot_data.reshape(log.header.num_snapshots, -1)
-
-        clm_iter = itertools.count(step=2)
-
-        self.collimator = _get_axis(snapshot_data, next(clm_iter), HeadAxis)
-        self.gantry = _get_axis(snapshot_data, next(clm_iter), GantryAxis)
-        jaw_y1 = _get_axis(snapshot_data, next(clm_iter), HeadAxis)
-        jaw_y2 = _get_axis(snapshot_data, next(clm_iter), HeadAxis)
-        jaw_x1 = _get_axis(snapshot_data, next(clm_iter), HeadAxis)
-        jaw_x2 = _get_axis(snapshot_data, next(clm_iter), HeadAxis)
-        self.jaws = JawStruct(jaw_x1, jaw_y1, jaw_x2, jaw_y2)
-
-        vrt = _get_axis(snapshot_data, next(clm_iter), CouchAxis)
-        lng = _get_axis(snapshot_data, next(clm_iter), CouchAxis)
-        lat = _get_axis(snapshot_data, next(clm_iter), CouchAxis)
-        rtn = _get_axis(snapshot_data, next(clm_iter), CouchAxis)
-        if log.header.version >= 3:
-            pitch = _get_axis(snapshot_data, next(clm_iter), CouchAxis)
-            roll = _get_axis(snapshot_data, next(clm_iter), CouchAxis)
-        else:
-            pitch = None
-            roll = None
-        self.couch = CouchStruct(vrt, lng, lat, rtn, pitch, roll)
-
-        self.mu = _get_axis(snapshot_data, next(clm_iter), BeamAxis)
-
-        self.beam_hold = _get_axis(snapshot_data, next(clm_iter), BeamAxis)
-
-        self.control_point = _get_axis(snapshot_data, next(clm_iter), BeamAxis)
-
-        self.carriage_A = _get_axis(snapshot_data, next(clm_iter), HeadAxis)
-        self.carriage_B = _get_axis(snapshot_data, next(clm_iter), HeadAxis)
-
-        if log.exclude_beam_off:
-            snapshot_idx = np.where(self.beam_hold.actual == 0)[0]
-        else:
-            snapshot_idx = list(range(log.header.num_snapshots))
-
-        self.mlc = MLC.from_tlog(
-            log, subbeams, self.jaws, snapshot_data, snapshot_idx, clm_iter
-        )
-
-
-class TrajectoryLogHeader:
-    """
-    Attributes
-    ----------
-    header : str
-        Header signature: 'VOSTL'.
-    version : str
-        Log version.
-    header_size : int
-        Header size; fixed at 1024.
-    sampling_interval : int
-        Sampling interval in milliseconds.
-    num_axes : int
-        Number of axes sampled.
-    axis_enum : int
-        Axis enumeration; see the Tlog file specification for more info.
-    samples_per_axis : numpy.ndarray
-        Number of samples per axis; 1 for most axes, for MLC it's # of leaves and carriages.
-    num_mlc_leaves : int
-        Number of MLC leaves.
-    axis_scale : int
-        Axis scale; 1 -> Machine scale, 2 -> Modified IEC 61217.
-    num_subbeams : int
-        Number of subbeams, if autosequenced.
-    is_truncated : int
-        Whether log was truncated due to space limitations; 0 -> not truncated, 1 -> truncated
-    num_snapshots : int
-        Number of snapshots, cycles, heartbeats, or whatever you'd prefer to call them.
-    mlc_model : int
-        The MLC model; 2 -> NDS 120 (e.g. Millennium), 3 -> NDS 120 HD (e.g. Millennium 120 HD)
-    """
-
-    def __init__(self, file: BinaryIO):
-        f = file
-        self.header = decode_binary(f, str, 16)  # for version 1.5 will be "VOSTL"
-        self.version = float(decode_binary(f, str, 16))  # in the format of 2.x or 3.x
-        self.header_size = decode_binary(f, int)  # fixed at 1024 in 1.5 specs
-        self.sampling_interval = decode_binary(f, int)
-        self.num_axes = decode_binary(f, int)
-        self.axis_enum = decode_binary(f, int, self.num_axes)
-        self.samples_per_axis = decode_binary(f, int, self.num_axes)
-        self.num_mlc_leaves = (
-            self.samples_per_axis[-1] - 2
-        )  # subtract 2 (each carriage counts as an "axis" and must be removed)
-        self.axis_scale = decode_binary(f, int)
-        self.num_subbeams = decode_binary(f, int)
-        self.is_truncated = decode_binary(f, int)
-        self.num_snapshots = decode_binary(f, int)
-        # the section after MLC model is reserved. Cursor is moved to the end of this reserved section.
-        if self.version >= 4.0:
-            self.mlc_model = decode_binary(f, int)
-            self.metadata = Metadata(f, self.num_axes)
-        else:
-            self.mlc_model = decode_binary(
-                f, int, cursor_shift=1024 - (64 + self.num_axes * 8)
-            )
-
-
-class Metadata:
-    """Metadata field for Trajectory logs v4.0+.
-
-    .. warning::
-          The TrueBeam log file spec says that there is a reserved section of the same size as v3.0 following this section.
-          That is NOT TRUE. It is actually offset by the size of the metadata; meaning 1024 - (64 + num_axes * 8) - 745.
-    """
-
-    def __init__(self, stream: BinaryIO, num_axes: int):
-        # structure lengths are NOT predetermined (why?!) so we read it all and split it up
-        full_data = decode_binary(
-            stream, str, 745, cursor_shift=1024 - (64 + (num_axes * 8)) - 745
-        )  # see docstring
-        fields = full_data.split("\r\n")
-        self.patient_id: str = fields[0].split("\t")[1]
-        self.plan_name: str = fields[1].split("\t")[1]
-        self.sop_instance_uid: str = fields[2].split("\t")[1]
-        self.mu_planned: float = float(fields[3].split("\t")[1])
-        self.mu_remaining: float = float(fields[4].split("\t")[1])
-        self.energy: str = fields[5].split("\t")[1]
-        self.beam_name: str = fields[6].split("\t")[1]
-
-
-class TrajectoryLog(LogBase):
-    """A class for loading and analyzing the data of a Trajectory log.
-
-    Attributes
-    ----------
-    header : `~pylinac.log_analyzer.TrajectoryLogHeader`, which has the following attributes:
-    axis_data : `~pylinac.log_analyzer.TrajectoryLogAxisData`
-    fluence : `~pylinac.log_analyzer.FluenceStruct`
-    subbeams : `~pylinac.log_analyzer.SubbeamManager`
-    """
-
-    ANON_LINE = 0
-
-    def __init__(self, filename: str | BinaryIO, exclude_beam_off: bool = True):
-        super().__init__(filename, exclude_beam_off)
-
-        self._read_txt_file()
-
-        # load from file object
-        if isinstance(filename, (BinaryIO, BufferedReader)):
-            filename.seek(0)
-            self._read_it(filename)
-        # load from disk
-        else:
-            with open(self.filename, mode="rb") as tlogfile:
-                self._read_it(tlogfile)
-
-        self.subbeams.post_hoc_metadata(self.axis_data)
-        if not self.treatment_type == TreatmentType.IMAGING.value:
-            self.fluence = FluenceStruct(
-                self.axis_data.mlc, self.axis_data.mu, self.axis_data.jaws
-            )
-
-    def _read_it(self, tlogfile: BinaryIO):
-        """Read the file object"""
-        self.header = TrajectoryLogHeader(tlogfile)
-        self.subbeams = SubbeamManager(tlogfile, self.header)
-        self.axis_data = TrajectoryLogAxisData(self, tlogfile, self.subbeams)
-
-    @property
-    def txt_filename(self) -> str:
-        """The name of the associated .txt file for the .bin file. The file may or may not be available."""
-        if self.txt is not None:
-            return self.filename.replace(".bin", ".txt")
-
-    def anon_file_renames(self, destination: str, suffix: str) -> dict[str, str]:
-        base_filename = osp.basename(self.filename)
-        anonymous_base_filename = (
-            "Anonymous" + suffix + base_filename[self._underscore_idx :]
-        )
-        anonymous_filename = osp.join(destination, anonymous_base_filename)
-        filenames = {self.filename: anonymous_filename}
-        if self.txt_filename is not None:
-            anonymous_txtfilename = anonymous_filename.replace(".bin", ".txt")
-            filenames[self.txt_filename] = anonymous_txtfilename
-        return filenames
-
-    def anonymize(
-        self,
-        inplace: bool = False,
-        destination: str | None = None,
-        suffix: str | None = None,
-    ) -> list[str]:
-        """Save an anonymized version of the log.
-
-        The patient ID in the filename is replaced with ``Anonymous<suffix>`` for the .bin file. If the
-        associated .txt file is in the same directory it will similarly replace the patient ID in the filename with
-        ``Anonymous<suffix>``. Additionally, the `Patient ID` row will be replaced with ``Patient ID: Anonymous<suffix>``.
-        For v4+ logs, the Patient ID field in the Metadata structure will be replaced with ``Anonymous<suffix>``.
-
-        .. note::
-            Anonymization is only available for logs loaded locally (i.e. not from a URL or a data stream). To
-            anonymize such a log it must be first downloaded or written to a file, then loaded in.
-
-        .. note::
-            Anonymization is done to the log **file** itself. The current instance of ``MachineLog`` will not be anonymized.
-
-        Parameters
-        ----------
-        inplace : bool
-            If False (default), creates an anonymized **copy** of the log(s).
-            If True, **renames and replaces** the content of the log file.
-        destination : str, optional
-            A string specifying the directory where the newly anonymized logs should be placed.
-            If None, will place the logs in the same directory as the originals.
-        suffix : str, optional
-            An optional suffix that is added after ``Anonymous`` to give specificity to the log.
-
-        Returns
-        -------
-        list
-            A list containing the paths to the newly written files.
-        """
-        if suffix is None:
-            suffix = ""
-
-        # determine destination directory
-        if destination is None:
-            dest_dir = osp.dirname(self.filename)
-        else:
-            if not osp.isdir(destination):
-                raise NotADirectoryError(
-                    f"Specified destination `{destination}` was not a valid directory"
-                )
-            dest_dir = destination
-
-        # copy or rename the files, depending on `inplace` parameter
-        anonymous_filenames = self.anon_file_renames(dest_dir, suffix)
-        method = os.rename if inplace else shutil.copy
-        for old_file, new_file in anonymous_filenames.items():
-            method(old_file, new_file)
-
-        # anonymize the .txt file if it exists.
-        # The .txt file is no longer in use so this can likely be removed at some point in the future
-        txt_file = anonymous_filenames.get(self.txt_filename)
-        if txt_file:
-            with open(txt_file, encoding="utf-8") as f:
-                txtdata = f.readlines()
-            txtdata[self.ANON_LINE] = "Patient ID:\tAnonymous_" + suffix + "\n"
-            with open(txt_file, mode="w", encoding="utf-8") as f:
-                f.writelines(txtdata)
-            print(f"Anonymized .txt file written to: {txt_file}")
-
-        # anonymize the .bin file. Only applies to v4+ files as only they contain metadata
-        bin_file = anonymous_filenames[self.filename]
-        if self.header.version < 4:
-            print(
-                f"The log version is <4.0 and thus does not have metadata. No fields to anonymize. A simple copy or rename has been performed to {bin_file}"
-            )
-        else:
-            with open(self.filename, mode="rb") as log_file:
-                # each block listed per the manual
-                header_size = (
-                    16
-                    + 16
-                    + 4
-                    + 4
-                    + 4
-                    + (4 * self.header.num_axes)
-                    + (4 * self.header.num_axes)
-                    + 4
-                    + 4
-                    + 4
-                    + 4
-                    + 4
-                )
-                header_data = log_file.read(header_size)
-                metadata = decode_binary(log_file, str, 745, strip_empty=False)
-                fields = metadata.split("\r\n")
-                fields[0] = fields[0].split("\t")[0] + "\tAnonymous" + suffix
-                anon_metadata = bytes("\r\n".join(fields).encode("ascii"))
-                rest_of_data = log_file.read()
-
-            with open(bin_file, mode="wb") as new_log_file:
-                new_log_file.write(header_data)
-                new_log_file.write(anon_metadata)
-                new_log_file.write(rest_of_data)
-            print(f"The anonymized .bin file has been written to {bin_file}")
-        return list(anonymous_filenames.values())
-
-    def _read_txt_file(self) -> None:
-        """Read a Tlog's associated .txt file and put in under the 'txt' attribute."""
-        self.txt = None
-        if ".bin" in str(
-            self.filename
-        ):  # files downloaded via URL may not have .bin ending
-            txt_filename = str(self.filename).replace(".bin", ".txt")
-            if osp.isfile(txt_filename):
-                self.txt = {}
-                with open(txt_filename, encoding="utf-8") as txtfile:
-                    txtdata = txtfile.readlines()
-                for line in txtdata:
-                    items = line.split(":")
-                    if len(items) == 2:
-                        self.txt[items[0].strip()] = items[1].strip()
-
-    @classmethod
-    def from_demo(cls, exclude_beam_off: bool = True):
-        """Load and instantiate from the demo trajetory log file included with the package."""
-        demo_file = io.retrieve_demo_file(name="Tlog.bin")
-        return cls(demo_file, exclude_beam_off)
-
-    @staticmethod
-    def run_demo():
-        """Run the Trajectory log demo."""
-        tlog = TrajectoryLog.from_demo()
-        tlog.report_basic_parameters()
-        tlog.plot_summary()
-
-    def to_csv(self, filename: str | None = None) -> str:
-        """Write the log to a CSV file.
-
-        Parameters
-        ----------
-        filename : None, str
-            If None (default), the CSV filename will be the same as the filename of the log.
-            If a string, the filename will be named so.
-
-        Returns
-        -------
-        str
-            The full filename of the newly created CSV file.
-        """
-        if filename is None:
-            filename = self.filename.replace("bin", "csv")
-        elif not filename.endswith(".csv"):
-            filename += ".csv"
-
-        csv_file = open(filename, mode="w", encoding="utf-8")
-        writer = csv.writer(csv_file, lineterminator="\n")
-        # write header info
-        header_titles = (
-            "Tlog File:",
-            "Signature:",
-            "Version:",
-            "Header Size:",
-            "Sampling Inteval:",
-            "Number of Axes:",
-            "Axis Enumeration:",
-            "Samples per Axis:",
-            "Axis Scale:",
-            "Number of Subbeams:",
-            "Is Truncated?",
-            "Number of Snapshots:",
-            "MLC Model:",
-        )
-        h = self.header
-        header_values = (
-            self.filename,
-            h.header,
-            h.version,
-            h.header_size,
-            h.sampling_interval,
-            h.num_axes,
-            h.axis_enum,
-            h.samples_per_axis,
-            h.axis_scale,
-            h.num_subbeams,
-            h.is_truncated,
-            h.num_snapshots,
-            h.mlc_model,
-        )
-        for title, value in zip(header_titles, header_values):
-            write_single_value(writer, title, value)
-
-        # write axis data
-        data_titles = (
-            "Gantry",
-            "Collimator",
-            "Jaws X1",
-            "Jaws X2",
-            "Jaws Y1",
-            "Jaws Y2",
-            "Couch Lat",
-            "Couch Lng",
-            "Couch Vert",
-            "Couch Rtn",
-            "Couch Pitch",
-            "Couch Roll",
-            "MU",
-            "Beam Hold",
-            "Control Point",
-            "Carriage A",
-            "Carriage B",
-        )
-        ad = self.axis_data
-        data_values = (
-            ad.gantry,
-            ad.collimator,
-            ad.jaws.x1,
-            ad.jaws.x2,
-            ad.jaws.y1,
-            ad.jaws.y2,
-            ad.couch.latl,
-            ad.couch.long,
-            ad.couch.vert,
-            ad.couch.rotn,
-            ad.couch.pitch,
-            ad.couch.roll,
-            ad.mu,
-            ad.beam_hold,
-            ad.control_point,
-            ad.carriage_A,
-            ad.carriage_B,
-        )
-        data_units = (
-            "degrees",
-            "degrees",
-            "cm",
-            "cm",
-            "cm",
-            "cm",
-            "cm",
-            "cm",
-            "cm",
-            "degrees",
-            "degrees",
-            "degrees",
-            "MU",
-            None,
-            None,
-            "cm",
-            "cm",
-        )
-        for title, value, unit in zip(data_titles, data_values, data_units):
-            # the value might not exist, such as pitch which is only for 6D couches
-            # thus, check the value exists first
-            if value:
-                write_array(writer, title, value, unit)
-
-        # write leaf data
-        for leaf_num, leaf in self.axis_data.mlc.leaf_axes.items():
-            write_array(writer, "Leaf " + str(leaf_num), leaf, "cm")
-
-        print("CSV file written to: " + filename)
-        return filename
-
-    def publish_pdf(
-        self,
-        filename: str | BinaryIO,
-        metadata: dict = None,
-        notes: str | list = None,
-        open_file: bool = False,
-        logo: Path | str | None = None,
-    ):
-        """Publish (print) a PDF containing the analysis and quantitative results.
-
-        Parameters
-        ----------
-        filename : (str, file-like object}
-            The file to write the results to.
-        notes : str, list of strings
-            Text; if str, prints single line.
-            If list of strings, each list item is printed on its own line.
-        open_file : bool
-            Whether to open the file using the default program after creation.
-        metadata : dict
-            Extra data to be passed and shown in the PDF. The key and value will be shown with a colon.
-            E.g. passing {'Author': 'James', 'Unit': 'TrueBeam'} would result in text in the PDF like:
-            --------------
-            Author: James
-            Unit: TrueBeam
-            --------------
-        logo: Path, str
-            A custom logo to use in the PDF report. If nothing is passed, the default pylinac logo is used.
-        """
-        if self.treatment_type == TreatmentType.IMAGING.value:
-            raise ValueError(
-                "Log is of imaging type (e.g. kV setup) and does not contain relevant gamma/leaf data"
-            )
-        self.fluence.gamma.calc_map()
-        canvas = pdf.PylinacCanvas(
-            filename, page_title="Trajectory Log Analysis", metadata=metadata, logo=logo
-        )
-        canvas.add_text(
-            text=[
-                "Trajectory Log results:",
-                f"Average RMS (mm): {self.axis_data.mlc.get_RMS_avg()*10:2.2f}",
-                f"Max RMS (mm): {self.axis_data.mlc.get_RMS_max()*10:2.2f}",
-                f"95th Percentile error (mm): {self.axis_data.mlc.get_error_percentile(95)*10:2.2f}",
-                f"Number of beam holdoffs: {self.num_beamholds}",
-                f"Gamma pass (%): {self.fluence.gamma.pass_prcnt:2.1f}",
-                f"Gamma average: {self.fluence.gamma.avg_gamma:2.2f}",
-            ],
-            location=(10, 25.5),
-        )
-        for idx, (x, y, graph) in enumerate(
-            zip(
-                (2, 11, 2, 11),
-                (14, 14, 6, 6),
-                (Fluence.ACTUAL, Fluence.EXPECTED, Fluence.GAMMA, ""),
-            )
-        ):
-            data = BytesIO()
-            if graph != "":
-                self.save_subimage(data, graph, fontsize=20)
-            else:
-                self.save_subgraph(data, Graph.GAMMA, fontsize=20, labelsize=12)
-            canvas.add_image(data, location=(x, y), dimensions=(9, 9))
-        if notes is not None:
-            canvas.add_text(location=(1, 5.5), font_size=14, text="Notes:")
-            canvas.add_text(location=(1, 5), text=notes)
-        canvas.add_new_page()
-        for idx, (x, y, graph) in enumerate(
-            zip((5, 5), (13, 2), (Graph.HISTOGRAM, Graph.RMS))
-        ):
-            data = BytesIO()
-            self.save_subgraph(data, graph, fontsize=20, labelsize=12)
-            canvas.add_image(location=(x, y), dimensions=(13, 13), image_data=data)
-        canvas.finish()
-
-        if open_file:
-            webbrowser.open(filename)
-
-    @property
-    def num_beamholds(self) -> int:
-        """Return the number of times the beam was held."""
-        diffmatrix = np.diff(self.axis_data.beam_hold.actual)
-        num_holds = int(np.sum(diffmatrix > 0))
-        return num_holds
-
-    @property
-    def is_hdmlc(self) -> bool:
-        """Whether the machine has an HDMLC or not."""
-        return self.header.mlc_model == 3
-
-
-def anonymize(
-    source: str, inplace: bool = False, destination: bool = None, recursive: bool = True
-):
-    """Quickly anonymize an individual log or directory of logs.
-    For directories, threaded execution is performed, making this much faster (10-20x) than loading a ``MachineLogs``
-    instance of the folder and using the ``.anonymize()`` method.
-
-    .. note::
-        Because ``MachineLog`` instances are not overly memory-efficient, you *may* run into ``MemoryError`` issues.
-        To avoid this, try not to anonymize more than ~3000 logs at once.
-
-    Parameters
-    ----------
-    source : str
-        Points to a local log file (e.g. .dlg or .bin file) or to a directory containing log files.
-    inplace : bool
-        Whether to edit the file itself, or created an anonymized copy and leave the original.
-    destination : str, None
-        Where the put the anonymized logs. Must point to an existing directory. If None, will place the logs in their original location.
-    recursive : bool
-        Whether to recursively enter sub-directories below the root source folder.
-    """
-
-    def _anonymize(filepath, inplace, destination):
-        """Function to anonymize logs; used in the thread executor."""
-        if is_tlog(filepath) or (
-            is_dlog(filepath) and osp.basename(filepath).startswith("A")
-        ):
-            log = load_log(filepath)
-            log.anonymize(inplace=inplace, destination=destination)
-
-    # if a single file, just anonymize it
-    if osp.isfile(source):
-        log = load_log(source)
-        log.anonymize(inplace=inplace, destination=destination)
-    # if a dir, start a threaded executor and walk the folder.
-    elif osp.isdir(source):
-        futures = []
-        with concurrent.futures.ThreadPoolExecutor(
-            max_workers=multiprocessing.cpu_count() * 8
-        ) as exec:
-            for pdir, sdir, files in os.walk(source):
-                for file in files:
-                    filepath = osp.join(pdir, file)
-                    future = exec.submit(_anonymize, filepath, inplace, destination)
-                    futures.append(future)
-                if not recursive:
-                    break
-            concurrent.futures.wait(futures)
-        print(f"All logs in {source} have been anonymized.")
-    else:
-        raise NotALogError(f"{source} is not a log file or directory.")
-
-
-def load_log(
-    file_or_dir: str, exclude_beam_off: bool = True, recursive: bool = True
-) -> TrajectoryLog | Dynalog | MachineLogs:
-    """Load a log file or directory of logs, either dynalogs or Trajectory logs.
-
-    Parameters
-    ----------
-    file_or_dir : str
-        String pointing to a single log file or a directory that contains log files.
-    exclude_beam_off : bool
-        Whether to include snapshots where the beam was off.
-    recursive : bool
-        Whether to recursively search a directory. Irrelevant for single log files.
-
-    Returns
-    -------
-    One of :class:`~pylinac.log_analyzer.Dynalog`, :class:`~pylinac.log_analyzer.TrajectoryLog`,
-        :class:`~pylinac.log_analyzer.MachineLogs`.
-    """
-    if io.is_url(file_or_dir):
-        file_or_dir = io.get_url(file_or_dir)
-    if osp.isfile(file_or_dir):
-        if zipfile.is_zipfile(file_or_dir):
-            return MachineLogs.from_zip(file_or_dir)
-        if not is_log(file_or_dir):
-            raise NotALogError("Not a valid log")
-        elif is_tlog(file_or_dir):
-            return TrajectoryLog(file_or_dir, exclude_beam_off)
-        else:
-            return Dynalog(file_or_dir, exclude_beam_off)
-    elif osp.isdir(file_or_dir):
-        return MachineLogs(file_or_dir, recursive)
-    else:
-        raise NotALogError(
-            f"'{file_or_dir}' did not point to a valid file, directory, or ZIP archive"
-        )
-
-
-def is_log(filename: str) -> bool:
-    """Boolean specifying if filename is a valid log file."""
-    return is_tlog(filename) or is_dlog(filename)
-
-
-def is_tlog(filename: str) -> bool:
-    """Boolean specifying if filename is a Trajectory log file."""
-    return _is_log(filename, ("VOSTL",))
-
-
-def is_dlog(filename: str) -> bool:
-    """Boolean specifying if filename is a Dynalog file."""
-    return _is_log(filename, ("B", "A"))
-
-
-def _is_log(filename: str, keys: Sequence[str]) -> bool:
-    """Internal function that determines whether a file is a log.
-
-    Parameters
-    ----------
-    filename : str
-    keys : iterable of strings
-        An iterable of strings that should be in the file. If any key
-        is in the file it will return true.
-    """
-    if isinstance(filename, (BytesIO, BufferedReader)):
-        header_sample = filename.read(5).decode()
-        return any(key in header_sample for key in keys)
-    elif osp.isfile(filename):
-        try:
-            with open(filename, mode="rb") as f:
-                header_sample = f.read(5).decode()
-            return any(key in header_sample for key in keys)
-        except:
-            return False
-    else:
-        return False
-
-
-def write_single_value(writer, description, value, unit=None):
-    writer.writerow([description, str(value), unit])
-
-
-def write_array(writer, description, value, unit=None):
-    # write expected
-    for dtype, attr in zip((" Expected", " Actual"), ("expected", "actual")):
-        if unit is None:
-            dtype_desc = description + dtype
-        else:
-            dtype_desc = description + dtype + " in units of " + unit
-        arr2write = np.insert(getattr(value, attr).astype(object), 0, dtype_desc)
-        writer.writerow(arr2write)
-
-
-def _get_log_filenames(directory: str, recursive: bool = True) -> list:
-    """Extract the names of real log files from a directory."""
-    tlogs = io.retrieve_filenames(directory, is_tlog, recursive=recursive)
-    dlogs = io.retrieve_filenames(directory, is_dlog, recursive=recursive)
-    # drop double-counted dynalogs (both A & B files; just need one of two)
-    idx = 0
-    while idx < len(dlogs):
-        opp_file = Dynalog.identify_other_file(dlogs[idx], raise_find_error=False)
-        if opp_file in dlogs:
-            del dlogs[dlogs.index(opp_file)]
-        else:
-            del dlogs[idx]
-            idx -= 1
-        idx += 1
-    return tlogs + dlogs
-
-
-def _get_axis(snapshot_data, column, axis_type):
-    """Return column of data from snapshot data of the axis type passed.
-
-    Parameters
-    ----------
-    snapshot_data : numpy.ndarray
-        The data read in holding the axis data of the log.
-    column : int
-        The column of the desired data in snapshot_data
-    axis_type : subclass of Axis
-        The type of axis the data is.
-
-    Returns
-    -------
-    axis_type
-    """
-    return axis_type(
-        expected=snapshot_data[:, column], actual=snapshot_data[:, column + 1]
-    )
-
-
-class NotALogError(IOError):
-    """Machine log error. Indicates that the passed file is not a valid machine log file."""
-
-    pass
-
-
-class NotADynalogError(IOError):
-    """Dynalog error. Indicates that the passed file is not a valid dynalog file."""
-
-    pass
-
-
-class DynalogMatchError(IOError):
-    """Dynalog error. Indicates that the associated file of the dynalog passed in
-    (A file if B passed in & vic versa) cannot be found. Ensure associated file is in the same folder
-    and has the same name as the passed file, except the first letter."""
-
-    pass
+"""
+The log analyzer module reads and parses Varian linear accelerator machine logs, both Dynalogs and Trajectory logs. The module also
+calculates actual and expected fluences as well as performing gamma evaluations. Data is structured to be easily accessible and
+easily plottable.
+
+Unlike most other modules of pylinac, the log analyzer module has no end goal. Data is parsed from the logs, but what is done with that
+info, and which info is analyzed is up to the user.
+
+Features:
+
+* **Analyze Dynalogs or Trajectory logs** - Either platform is supported. Tlog versions 2.1, 3.0, and 4.0 are supported.
+* **Read in both .bin and .txt Trajectory log files** - Read in the machine data from both .bin and .txt files to get all the information recorded.
+  See the :attr:`~pylinac.log_analyzer.MachineLog.txt` attribute.
+* **Save Trajectory log data to CSV** - The Trajectory log binary data format does not allow for easy export of data. Pylinac lets you do
+  that so you can use Excel or other software that you use with Dynalogs.
+* **Plot or analyze any axis** - Every data axis (e.g. gantry, y1, beam holds, MLC leaves) can be accessed and plotted: the actual, expected, and even the difference.
+* **Calculate fluences and gamma** - Besides reading in the MLC positions, pylinac calculates the actual and expected fluence
+  as well as the gamma map; DTA and threshold values are adjustable.
+* **Anonymize logs** - Both dynalogs and trajectory logs can be "anonymized" by removing the Patient ID from the filename(s)
+  and file data.
+"""
+from __future__ import annotations
+
+import collections
+import concurrent.futures
+import copy
+import csv
+import enum
+import gc
+import itertools
+import multiprocessing
+import os
+import os.path as osp
+import shutil
+import webbrowser
+import zipfile
+from functools import cached_property
+from io import BufferedReader, BytesIO
+from pathlib import Path
+from typing import BinaryIO, Iterable, Sequence
+
+import argue
+import matplotlib.pyplot as plt
+import numpy as np
+
+from .core import image, io, pdf
+from .core.decorators import lru_cache
+from .core.utilities import Structure, convert_to_enum, decode_binary, is_iterable
+from .settings import get_array_cmap
+
+
+class TreatmentType(enum.Enum):
+    STATIC_IMRT = "Static IMRT"  #:
+    DYNAMIC_IMRT = "Dynamic IMRT"  #:
+    VMAT = "VMAT"  #:
+    IMAGING = "Imaging"  #:
+
+
+MLC_FOV_WIDTH_MM = 400
+MLC_FOV_HEIGHT_MM = 400
+HDMLC_FOV_HEIGHT_MM = 220
+
+
+class MLCBank(enum.Enum):
+    A = "A"  #:
+    B = "B"  #:
+    BOTH = "both"  #:
+
+
+class Fluence(enum.Enum):
+    ACTUAL = "actual"  #:
+    EXPECTED = "expected"  #:
+    GAMMA = "gamma"  #:
+
+
+class Graph(enum.Enum):
+    GAMMA = "gamma"  #:
+    HISTOGRAM = "histogram"  #:
+    RMS = "rms"  #:
+
+
+class MachineLogs(list):
+    """Read in machine logs from a directory. Inherits from list. Batch methods are also provided."""
+
+    def __init__(self, folder: str, recursive: bool = True):
+        r"""
+        Parameters
+        ----------
+        folder : str
+            The directory of interest. Will walk through and process any logs, Trajectory or dynalog, it finds.
+            Non-log files will be skipped.
+        recursive : bool
+            Whether to walk through subfolders of passed directory. Only used if ``folder`` is a valid log directory.
+
+        Examples
+        --------
+        Load a directory upon initialization::
+
+            >>> log_folder = r'C:\path\log\directory'
+            >>> logs = MachineLogs(log_folder)
+
+        Batch methods include determining the average gamma and average gamma pass value::
+
+            >>> logs.avg_gamma()
+            >>> 0.05 # or whatever it is
+            >>> logs.avg_gamma_pct()
+            >>> 97.2
+        """
+        super().__init__()
+        self.load_folder(folder, recursive)
+
+    @classmethod
+    def from_zip(cls, zfile: str):
+        """Instantiate from a ZIP archive.
+
+        Parameters
+        ----------
+        zfile : str
+            Path to the zip archive.
+        """
+        with io.TemporaryZipDirectory(zfile) as tzd:
+            logs = cls(tzd)
+        return logs
+
+    @property
+    def num_logs(self) -> int:
+        """The number of logs currently loaded."""
+        return len(self)
+
+    @property
+    def num_tlogs(self) -> int:
+        """The number of Trajectory logs currently loaded."""
+        return sum(isinstance(log, TrajectoryLog) for log in self)
+
+    @property
+    def num_dlogs(self) -> int:
+        """The number of Trajectory logs currently loaded."""
+        return sum(isinstance(log, Dynalog) for log in self)
+
+    def load_folder(self, directory: str, recursive: bool = True):
+        """Load log files from a directory and append to existing list.
+
+        Parameters
+        ----------
+        directory : str, None
+            The directory of interest.
+            If a string, will walk through and process any logs, Trajectory or dynalog, it finds.
+            Non-log files will be skipped.
+            If None, files must be loaded later using .load_dir() or .append().
+        recursive : bool
+            If True (default), will walk through subfolders of passed directory.
+            If False, will only search root directory.
+        """
+        # get log files from directory
+        log_files = _get_log_filenames(directory, recursive=recursive)
+        if len(log_files) == 0:
+            print("No logs found.")
+            return
+
+        # actual log loading
+        print(f"{len(log_files)} logs found.")
+        for idx, file in enumerate(log_files):
+            self.append(file)
+            print(f"Log loaded: {idx+1} of {len(log_files)}", end="\r")
+        print("")
+
+    def _check_empty(self) -> None:
+        """Check if any logs have been loaded."""
+        if len(self) == 0:
+            raise ValueError("No logs have been loaded yet.")
+
+    def report_basic_parameters(self) -> None:
+        """Report basic parameters of the logs.
+
+        - Number of logs
+        - Average gamma value of all logs
+        - Average gamma pass percent of all logs
+        """
+        print(f"Number of logs: {len(self)}")
+        print(f"Average gamma: {self.avg_gamma():3.2f}")
+        print(f"Average gamma pass percent: {self.avg_gamma_pct():3.1f}")
+
+    def append(self, obj, recursive: bool = True) -> None:
+        """Append a log. Overloads list method.
+
+        Parameters
+        ----------
+        obj : str, Dynalog, TrajectoryLog
+            If a string, must point to a log file.
+            If a directory, must contain log files.
+            If a Dynalog or Trajectory log instance, then simply appends.
+        recursive : bool
+            Whether to walk through subfolders of passed directory. Only applicable if obj was a directory.
+        """
+        if isinstance(obj, str):
+            if is_log(obj):
+                log = load_log(obj)
+                super().append(log)
+            elif osp.isdir(obj):
+                files = io.retrieve_filenames(obj)
+                for file in files:
+                    self.append(file)
+        elif isinstance(obj, (Dynalog, TrajectoryLog)):
+            super().append(obj)
+        else:
+            raise TypeError(
+                "Can only append MachineLog or string pointing to a log or log directory."
+            )
+
+    def avg_gamma(
+        self,
+        doseTA: int | float = 1,
+        distTA: int | float = 1,
+        threshold: int | float = 0.1,
+        resolution: int | float = 0.1,
+    ) -> float:
+        """Calculate and return the average gamma of all logs. See :meth:`~pylinac.log_analyzer.GammaFluence.calc_map()`
+        for further parameter info."""
+        self._check_empty()
+        gamma_list = np.zeros(self.num_logs)
+
+        for num, log in enumerate(self):
+            log.fluence.gamma.calc_map(doseTA, distTA, threshold, resolution)
+            gamma_list[num] = log.fluence.gamma.avg_gamma
+            print(f"Calculating gammas: {num+1} of {self.num_logs}", end="\r")
+        print("")
+        return gamma_list.mean()
+
+    def avg_gamma_pct(
+        self,
+        doseTA: int | float = 1,
+        distTA: int | float = 1,
+        threshold: int | float = 0.1,
+        resolution: int | float = 0.1,
+    ) -> float:
+        """Calculate and return the average gamma pass percent of all logs. See :meth:`~pylinac.log_analyzer.GammaFluence.calc_map()`
+        for further parameter info."""
+        self._check_empty()
+        gamma_list = np.zeros(self.num_logs)
+
+        for num, log in enumerate(self):
+            log.fluence.gamma.calc_map(doseTA, distTA, threshold, resolution)
+            gamma_list[num] = log.fluence.gamma.pass_prcnt
+            print(
+                f"Calculating gamma pass percent: {num+1} of {self.num_logs}", end="\r"
+            )
+        print("")
+        return gamma_list.mean()
+
+    def to_csv(self) -> list[str]:
+        """Write trajectory logs to CSV. If there are both dynalogs and trajectory logs,
+        only the trajectory logs will be written. File names will be the same as the original log file names.
+
+        Returns
+        -------
+        list
+            A list of all the filenames of the newly created CSV files.
+        """
+        tlogs_written = False
+        files = []
+        for log in self:
+            if is_tlog(log.filename):
+                file = log.to_csv()
+                tlogs_written = True
+                files.append(file)
+        if tlogs_written:
+            print("\nAll trajectory logs written to CSV files!")
+        else:
+            print(
+                "\nNo files written. Either no logs are loaded or all logs were dynalogs."
+            )
+        return files
+
+    def anonymize(self, inplace: bool = False, suffix: str | None = None):
+        """Save anonymized versions of the logs.
+
+        For dynalogs, this replaces the patient ID in the filename(s) and the second line of the log with 'Anonymous<suffix>`.
+        This will rename both A* and B* logs if both are present in the same directory.
+
+        For trajectory logs, the patient ID in the filename is replaced with `Anonymous<suffix>` for the .bin file. If the
+        associated .txt file is in the same directory it will similarly replace the patient ID in the filename with
+        `Anonymous<suffix>`. Additionally, the `Patient ID` row will be replaced with `Patient ID: Anonymous<suffix>`.
+
+        .. note::
+            Anonymization is only available for logs loaded locally (i.e. not from a URL or a data stream). To
+            anonymize such a log it must be first downloaded or written to a file, then loaded in.
+
+        .. note::
+            Anonymization is done to the log *file* itself. The current instance(s) of `MachineLog` will not be anonymized.
+
+        Parameters
+        ----------
+        inplace : bool
+            If False (default), creates an anonymized *copy* of the log(s).
+            If True, *renames and replaces* the content of the log file.
+        suffix : str, optional
+            An optional suffix that is added after `Anonymous` to give specificity to the log.
+
+        Returns
+        -------
+        list
+            A list containing the paths to the newly written files.
+        """
+        file_list = []
+        for log in self:
+            files = log.anonymize(inplace=inplace, suffix=suffix)
+            file_list += files
+        print("\n\nDone anonymizing!")
+        return file_list
+
+
+class Axis:
+    """Represents an 'Axis' of a Trajectory log or dynalog file, holding actual and potentially expected and difference values.
+
+    Attributes
+    ----------
+    Parameters are Attributes
+    """
+
+    def __init__(self, actual: np.ndarray, expected: np.ndarray | None = None):
+        """
+        Parameters
+        ----------
+        actual : numpy.ndarray
+            The array of actual position values.
+        expected : numpy.ndarray, optional
+            The array of expected position values. Not applicable for dynalog axes other than MLCs.
+        """
+        self.actual = actual
+        self.expected = expected
+        if expected is not None:
+            try:
+                if len(actual) != len(expected):
+                    raise ValueError(
+                        "Actual and expected Axis parameters are not equal length"
+                    )
+            except TypeError:
+                pass
+            self.expected = expected
+
+    @property
+    def difference(self) -> np.ndarray:
+        """Return an array of the difference between actual and expected positions.
+
+        Returns
+        -------
+        numpy.ndarray
+            Array the same length as actual/expected.
+        """
+        if self.expected is not None:
+            return self.actual - self.expected
+        else:
+            raise AttributeError("Expected positions not passed to Axis")
+
+    def plot_actual(self) -> None:
+        """Plot the actual positions as a matplotlib figure."""
+        self._plot("actual")
+
+    def save_plot_actual(self, filename: str, **kwargs) -> None:
+        self._plot("actual", show=False)
+        self._save(filename, **kwargs)
+
+    def plot_expected(self) -> None:
+        """Plot the expected positions as a matplotlib figure."""
+        self._plot("expected")
+
+    def save_plot_expected(self, filename: str, **kwargs) -> None:
+        self._plot("expected", show=False)
+        self._save(filename, **kwargs)
+
+    def plot_difference(self) -> None:
+        """Plot the difference of positions as a matplotlib figure."""
+        self._plot("difference")
+
+    def save_plot_difference(self, filename: str, **kwargs) -> None:
+        self._plot("difference", show=False)
+        self._save(filename, **kwargs)
+
+    @argue.options(param=("actual", "expected", "difference"))
+    def _plot(self, param: str, show: bool = True):
+        """Plot the parameter: actual, expected, or difference."""
+        plt.plot(getattr(self, param))
+        plt.grid(True)
+        plt.autoscale(axis="x", tight=True)
+        if show:
+            plt.show()
+
+    def _save(self, filename: str, **kwargs):
+        """Save the figure to a file, either .png or .html."""
+        plt.savefig(filename, **kwargs)
+
+
+class AxisMovedMixin:
+    """Mixin class for Axis."""
+
+    AXIS_MOVE_THRESHOLD: float = 0.003
+
+    @cached_property
+    def moved(self) -> bool:
+        """Return whether the axis moved during treatment."""
+        return np.std(self.actual) > self.AXIS_MOVE_THRESHOLD
+
+
+class LeafAxis(Axis, AxisMovedMixin):
+    """Axis holding leaf information."""
+
+    def __init__(self, actual, expected):
+        # force expected argument to be supplied
+        super().__init__(actual, expected)
+
+
+class GantryAxis(Axis, AxisMovedMixin):
+    """Axis holding gantry information."""
+
+    pass
+
+
+class HeadAxis(Axis, AxisMovedMixin):
+    """Axis holding head information (e.g. jaw positions, collimator)."""
+
+    pass
+
+
+class CouchAxis(Axis, AxisMovedMixin):
+    """Axis holding couch information."""
+
+    pass
+
+
+class BeamAxis(Axis):
+    """Axis holding beam information (e.g. MU, beam hold status)."""
+
+    pass
+
+
+class FluenceBase:
+    """An abstract base class to be used for the actual and expected fluences.
+
+    Attributes
+    ----------
+    array : numpy.ndarray
+        An array representing the fluence map; will be num_mlc_pairs-x-400/resolution.
+        E.g., assuming a Millennium 120 MLC model and a fluence resolution of 0.1mm, the resulting
+        matrix will be 60-x-4000.
+    resolution : int, float
+        The resolution of the fluence calculation; -1 means calculation has not been done yet.
+    """
+
+    resolution = -1
+    FLUENCE_TYPE = ""  # must be specified by subclass
+
+    def __init__(self, mlc_struct=None, mu_axis: Axis = None, jaw_struct=None):
+        """
+        Parameters
+        ----------
+        mlc_struct : MLC_Struct
+        mu_axis : BeamAxis
+        jaw_struct : Jaw_Struct
+        """
+        self.array: np.ndarray = np.empty((0, 0))
+        self._mlc = mlc_struct
+        self._mu = mu_axis
+        self._jaws = jaw_struct
+
+    def is_map_calced(self, raise_error: bool = False) -> bool:
+        """Return a boolean specifying whether the fluence has been calculated."""
+        calced = self.array.size > 0
+        if (not calced) and (raise_error is True):
+            raise ValueError(
+                "Map has not yet been calculated. Use .calc_map() with desired parameters first."
+            )
+        else:
+            return calced
+
+    @lru_cache(maxsize=1)
+    def calc_map(
+        self, resolution: float = 0.1, equal_aspect: bool = False
+    ) -> np.ndarray:
+        """Calculate a fluence pixel map.
+
+        Image calculation is done by adding fluence snapshot by snapshot, and leaf pair by leaf pair.
+        Each leaf pair is analyzed separately. First, to optimize, it checks if the leaf is under the y-jaw.
+        If so, the fluence is left at zero; if not, the leaf (or jaw) ends are determined and the MU fraction of that
+        snapshot is added to the total fluence. All snapshots are iterated over for each leaf pair until the total fluence
+        matrix is built.
+
+        Parameters
+        ----------
+        resolution : int, float
+            The resolution in mm of the fluence calculation in the leaf-moving direction.
+        equal_aspect : bool
+            If True, make the y-direction the same resolution as x. If False, the y-axis will be equal to the number of leaves.
+
+        Returns
+        -------
+        numpy.ndarray
+            A numpy array reconstructing the actual fluence of the log. The size will
+            be the number of MLC pairs by 400 / resolution since the MLCs can move anywhere within the
+            40cm-wide linac head opening.
+        """
+        height = MLC_FOV_HEIGHT_MM if not self._mlc.hdmlc else HDMLC_FOV_HEIGHT_MM
+        if equal_aspect:
+            fluence = np.zeros(
+                (int(height / resolution), int(MLC_FOV_WIDTH_MM / resolution)),
+                dtype=float,
+            )
+        else:
+            fluence = np.zeros(
+                (self._mlc.num_pairs, int(MLC_FOV_WIDTH_MM / resolution)), dtype=float
+            )
+
+        self.array = fluence
+        self.resolution = resolution
+
+        # check if the beam was actually on at all (e.g. kV setups)
+        if len(self._mlc.snapshot_idx) < 1:
+            return fluence
+
+        def create_mlc_y_positions(is_hdmlc):
+            if not is_hdmlc:
+                num_large_leaves = 10
+                size_large_leaves = 10 / resolution
+                num_small_leaves = 40
+                size_small_leaves = 5 / resolution
+            else:
+                num_large_leaves = 14
+                size_large_leaves = 5 / resolution
+                num_small_leaves = 32
+                size_small_leaves = 2.5 / resolution
+            sizes = (
+                [size_large_leaves] * num_large_leaves
+                + [size_small_leaves] * num_small_leaves
+                + [size_large_leaves] * num_large_leaves
+            )
+            return np.cumsum(
+                [
+                    0,
+                ]
+                + sizes
+            ).astype(int)
+
+        positions = create_mlc_y_positions(is_hdmlc=self._mlc.hdmlc)
+
+        def yield_leaf_width():
+            for idx in range(self._mlc.num_pairs):
+                yield (positions[idx], positions[idx + 1])
+
+        # calculate the MU delivered in each snapshot. For Tlogs this is absolute; for dynalogs it's normalized.
+        mu_matrix = getattr(self._mu, self.FLUENCE_TYPE)
+        # if little to no MU was delivered (e.g. MV/kV setup), return
+        if np.max(mu_matrix) < 0.5:
+            return fluence
+        MU_differential = np.array([mu_matrix[0]] + list(np.diff(mu_matrix)))
+        MU_total = mu_matrix[-1]
+
+        # calculate each "line" of fluence (the fluence of an MLC leaf pair, e.g. 1 & 61, 2 & 62, etc),
+        # and add each "line" to the total fluence matrix
+        leaf_offset = self._mlc.num_pairs
+        fluence_line = np.zeros(int(400 / resolution), dtype=np.float32)
+        pos_offset = int(np.round(200 / resolution))
+        for pair, width in zip(range(1, self._mlc.num_pairs + 1), yield_leaf_width()):
+            if not self._mlc.leaf_under_y_jaw(pair):
+                fluence_line[:] = 0  # emtpy the line values on each new leaf pair
+                right_leaf_data = getattr(self._mlc.leaf_axes[pair], self.FLUENCE_TYPE)
+                right_leaf_data = (
+                    np.round(right_leaf_data * 10 / resolution) + pos_offset
+                )
+                left_leaf_data = getattr(
+                    self._mlc.leaf_axes[pair + leaf_offset], self.FLUENCE_TYPE
+                )
+                left_leaf_data = (
+                    -np.round(left_leaf_data * 10 / resolution) + pos_offset
+                )
+                left_jaw_data = np.round(
+                    (200 / resolution) - (self._jaws.x1.actual * 10 / resolution)
+                )
+                right_jaw_data = np.round(
+                    (self._jaws.x2.actual * 10 / resolution) + (200 / resolution)
+                )
+                if self._mlc.pair_moved(pair):
+                    for snapshot in self._mlc.snapshot_idx:
+                        lt_mlc_pos = left_leaf_data[snapshot]
+                        rt_mlc_pos = right_leaf_data[snapshot]
+                        lt_jaw_pos = left_jaw_data[snapshot]
+                        rt_jaw_pos = right_jaw_data[snapshot]
+                        left_edge = int(max(lt_mlc_pos, lt_jaw_pos))
+                        right_edge = int(min(rt_mlc_pos, rt_jaw_pos))
+                        fluence_line[left_edge:right_edge] += MU_differential[snapshot]
+                else:  # leaf didn't move; no need to calc over every snapshot
+                    first_snapshot = self._mlc.snapshot_idx[0]
+                    lt_mlc_pos = left_leaf_data[first_snapshot]
+                    rt_mlc_pos = right_leaf_data[first_snapshot]
+                    lt_jaw_pos = left_jaw_data.min()
+                    rt_jaw_pos = right_jaw_data.max()
+                    left_edge = max(lt_mlc_pos, lt_jaw_pos)
+                    right_edge = min(rt_mlc_pos, rt_jaw_pos)
+                    fluence_line[int(left_edge) : int(right_edge)] = MU_total
+                if equal_aspect:
+                    fluence[width[0] : width[1], :] = np.tile(
+                        fluence_line, [width[1] - width[0], 1]
+                    )
+                else:
+                    fluence[pair - 1, :] = fluence_line
+
+        # if it's a dynalog, then normalize it because 25000 is such an arbitrary value
+        if MU_total == 25000:
+            fluence /= MU_total
+
+        return fluence
+
+    def plot_map(self, show: bool = True) -> None:
+        """Plot the fluence; the fluence (pixel map) must have been calculated first."""
+        self.is_map_calced(raise_error=True)
+        plt.clf()
+        plt.imshow(self.array, aspect="auto", cmap=get_array_cmap())
+        if show:
+            plt.show()
+
+    def save_map(self, filename: str, **kwargs) -> None:
+        """Save the fluence map figure to a file."""
+        self.plot_map(show=False)
+        plt.savefig(filename, **kwargs)
+
+
+class ActualFluence(FluenceBase):
+    """The actual fluence object"""
+
+    FLUENCE_TYPE = "actual"
+
+
+class ExpectedFluence(FluenceBase):
+    """The expected fluence object."""
+
+    FLUENCE_TYPE = "expected"
+
+
+class GammaFluence(FluenceBase):
+    """Gamma object, including pixel maps of gamma, binary pass/fail pixel map, and others.
+
+    Attributes
+    ----------
+    array : numpy.ndarray
+        The gamma map. Only available after calling calc_map()
+    passfail_array : numpy.ndarray
+        The gamma pass/fail map; pixels that pass (<1.0) are set to 0, while failing pixels (>=1.0) are set to 1.
+    distTA : int, float
+        The distance to agreement value used in gamma calculation.
+    doseTA : int, float
+        The dose to agreement value used in gamma calculation.
+    threshold : int, float
+        The threshold percent dose value, below which gamma was not evaluated.
+    pass_prcnt : float
+        The percent of pixels passing gamma (<1.0).
+    avg_gamma : float
+        The average gamma value.
+    """
+
+    distTA = -1
+    doseTA = -1
+    threshold = -1
+    pass_prcnt = -1
+    avg_gamma = -1
+    bins = [0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1, 1.1]
+
+    def __init__(
+        self,
+        actual_fluence: ActualFluence,
+        expected_fluence: ExpectedFluence,
+        mlc_struct,
+    ):
+        """
+        Parameters
+        ----------
+        actual_fluence : ActualFluence
+            The actual fluence object.
+        expected_fluence : ExpectedFluence
+            The expected fluence object.
+        mlc_struct : MLC_Struct
+            The MLC structure, so fluence can be calculated from leaf positions.
+        """
+        self.array: np.ndarray = np.empty((0, 0))
+        self.passfail_array: np.ndarray
+        self._actual_fluence: ActualFluence = actual_fluence
+        self._expected_fluence: ExpectedFluence = expected_fluence
+        self._mlc: MLC = mlc_struct
+
+    @lru_cache(maxsize=1)
+    def calc_map(
+        self,
+        doseTA: int | float = 1,
+        distTA: int | float = 1,
+        threshold: int | float = 0.1,
+        resolution: int | float = 0.1,
+        calc_individual_maps: bool = False,
+    ) -> np.ndarray:
+        """Calculate the gamma from the actual and expected fluences.
+
+        The gamma calculation is based on `Bakai et al
+        <http://iopscience.iop.org/0031-9155/48/21/006/>`_ eq.6,
+        which is a quicker alternative to the standard Low gamma equation.
+
+        Parameters
+        ----------
+        doseTA : int, float
+            Dose-to-agreement in percent; e.g. 2 is 2%.
+        distTA : int, float
+            Distance-to-agreement in mm.
+        threshold : int, float
+            The dose threshold percentage of the maximum dose, below which is not analyzed.
+        resolution : int, float
+            The resolution in mm of the resulting gamma map in the leaf-movement direction.
+        calc_individual_maps : bool
+            Not yet implemented.
+            If True, separate pixel maps for the distance-to-agreement and dose-to-agreement are created.
+
+        Returns
+        -------
+        numpy.ndarray
+            A num_mlc_leaves-x-400/resolution numpy array.
+        """
+        # calc fluences if need be
+        if (
+            not self._actual_fluence.is_map_calced()
+            or resolution != self._actual_fluence.resolution
+        ):
+            self._actual_fluence.calc_map(resolution)
+        if (
+            not self._expected_fluence.is_map_calced()
+            or resolution != self._expected_fluence.resolution
+        ):
+            self._expected_fluence.calc_map(resolution)
+
+        actual_img = image.load(self._actual_fluence.array, dpi=25.4 / resolution)
+        expected_img = image.load(self._expected_fluence.array, dpi=25.4 / resolution)
+        gamma_map = actual_img.gamma(
+            expected_img, doseTA=doseTA, distTA=distTA, threshold=threshold
+        )
+
+        # calculate standard metrics
+        self.avg_gamma = np.nanmean(gamma_map)
+        if np.isnan(self.avg_gamma):
+            self.avg_gamma = 0
+        pixels_passing = np.sum(gamma_map[~np.isnan(gamma_map)] < 1)
+        all_calcd_pixels = np.sum(gamma_map[~np.isnan(gamma_map)] >= 0)
+        self.pass_prcnt = pixels_passing / all_calcd_pixels * 100
+        gamma_map = np.nan_to_num(gamma_map)
+        self.passfail_array = gamma_map >= 1
+
+        self.distTA = distTA
+        self.doseTA = doseTA
+        self.threshold = threshold
+        self.resolution = resolution
+
+        self.array = gamma_map
+        return gamma_map
+
+    def plot_map(self, show: bool = True):
+        """Plot the fluence; the fluence (pixel map) must have been calculated first."""
+        self.is_map_calced(raise_error=True)
+        plt.imshow(self.array, aspect="auto", vmax=1, cmap=get_array_cmap())
+        plt.colorbar()
+        plt.show()
+
+    def histogram(self, bins: list | None = None) -> tuple[np.ndarray, np.ndarray]:
+        """Return a histogram array and bin edge array of the gamma map values.
+
+        Parameters
+        ----------
+        bins : sequence
+            The bin edges for the gamma histogram; see numpy.histogram for more info.
+
+        Returns
+        -------
+        histogram : numpy.ndarray
+            A 1D histogram of the gamma values.
+        bin_edges : numpy.ndarray
+            A 1D array of the bin edges. If left as None, the class default will be used (self.bins).
+        """
+        self.is_map_calced(raise_error=True)
+        if bins is None:
+            bins = self.bins
+        hist_arr, bin_edges = np.histogram(self.array, bins=bins)
+        return hist_arr, bin_edges
+
+    @argue.options(scale=("log", "linear"))
+    def plot_histogram(
+        self, scale: str = "log", bins: list | None = None, show: bool = True
+    ) -> None:
+        """Plot a histogram of the gamma map values.
+
+        Parameters
+        ----------
+        scale : {'log', 'linear'}
+            Scale of the plot y-axis.
+        bins : sequence
+            The bin edges for the gamma histogram; see numpy.histogram for more info.
+        """
+        self.is_map_calced(raise_error=True)
+        if bins is None:
+            bins = self.bins
+        plt.clf()
+        plt.hist(self.array.flatten(), bins=bins)
+        plt.yscale(scale)
+        if show:
+            plt.show()
+
+    @argue.options(scale=("log", "linear"))
+    def save_histogram(
+        self, filename: str, scale: str = "log", bins: list | None = None, **kwargs
+    ) -> None:
+        """Save the histogram plot to file."""
+        self.plot_histogram(scale, bins, show=False)
+        plt.savefig(filename, **kwargs)
+
+    def plot_passfail_map(self) -> None:
+        """Plot the binary gamma map, only showing whether pixels passed or failed."""
+        self.is_map_calced(raise_error=True)
+        plt.imshow(self.passfail_array, cmap=get_array_cmap())
+        plt.show()
+
+
+class FluenceStruct:
+    """Structure for data and methods having to do with fluences.
+
+    Attributes
+    ----------
+    actual : :class:`~pylinac.log_analyzer.FluenceBase`
+        The actual fluence delivered.
+    expected : :class:`~pylinac.log_analyzer.FluenceBase`
+        The expected, or planned, fluence.
+    gamma : :class:`~pylinac.log_analyzer.GammaFluence`
+        The gamma structure regarding the actual and expected fluences.
+    """
+
+    def __init__(self, mlc_struct=None, mu_axis: Axis = None, jaw_struct=None):
+        self.actual = ActualFluence(mlc_struct, mu_axis, jaw_struct)
+        self.expected = ExpectedFluence(mlc_struct, mu_axis, jaw_struct)
+        self.gamma = GammaFluence(self.actual, self.expected, mlc_struct)
+
+
+class MLC:
+    """The MLC class holds MLC information and retrieves relevant data about the MLCs and positions."""
+
+    def __init__(
+        self,
+        log_type,
+        snapshot_idx: np.ndarray | None = None,
+        jaw_struct=None,
+        hdmlc: bool = False,
+        subbeams=None,
+    ):
+        """
+        Parameters
+        ----------
+
+        log_type: :class:`~pylinac.log_analyzer.Dynalog`, :class:`~pylinac.log_analyzer.TrajectoryLog`
+            The log type.
+        snapshot_idx : array, list
+            The snapshots to be considered for RMS and error calculations (can be all snapshots or just when beam was on).
+        jaw_struct : :class:`~pylinac.log_analyzer.JawStruct`
+            The jaw structure.
+        hdmlc : boolean
+            If False (default), indicates a regular MLC model (e.g. Millennium 120).
+            If True, indicates an HD MLC model (e.g. Millennium 120 HD).
+
+        Attributes
+        ----------
+
+        leaf_axes : dict containing :class:`~pylinac.log_analyzer.Axis`
+            The dictionary is keyed by the leaf number, with the Axis as the value.
+
+            .. warning:: Leaf numbers are 1-index based to correspond with Varian convention.
+        """
+        self.leaf_axes: dict = {}
+        self.snapshot_idx = snapshot_idx
+        self._jaws = jaw_struct
+        self.hdmlc = hdmlc
+        self.log_type = log_type
+        self.subbeams = subbeams
+
+    @classmethod
+    def from_dlog(
+        cls,
+        dlog,
+        jaws,
+        snapshot_data: np.ndarray,
+        snapshot_idx: list | np.ndarray,
+    ):
+        """Construct an MLC structure from a Dynalog"""
+        mlc = MLC(Dynalog, snapshot_idx, jaws)
+        for leaf in range(1, (dlog.header.num_mlc_leaves // 2) + 1):
+            axis = LeafAxis(
+                expected=snapshot_data[(leaf - 1) * 4 + 14],
+                actual=snapshot_data[(leaf - 1) * 4 + 15],
+            )
+            mlc.add_leaf_axis(axis, leaf)
+
+        # read in "B"-file to get bank B MLC positions. The file must be in the same folder as the "A"-file.
+        # The header info is repeated but we already have that.
+        with open(dlog.b_logfile, encoding="utf-8") as csvf:
+            dlgdata = csv.reader(csvf, delimiter=",")
+            snapshot_data = np.array(
+                [line for line in dlgdata][dlog.HEADER_LINE_LENGTH :], dtype=float
+            ).transpose()
+
+        # Add bank B MLC positions to mlc snapshot arrays
+        for leaf in range(1, (dlog.header.num_mlc_leaves // 2) + 1):
+            axis = LeafAxis(
+                expected=snapshot_data[(leaf - 1) * 4 + 14],
+                actual=snapshot_data[(leaf - 1) * 4 + 15],
+            )
+            mlc.add_leaf_axis(axis, leaf_num=leaf + dlog.header.num_mlc_leaves // 2)
+
+        # scale dynalog leaf positions from the physical plane to the isocenter plane and from 100ths of mm to cm.
+        # MLC physical plane scaling factor to iso (100cm SAD) plane
+        # the below value was changed from 1.96614, which I believe I determined by dividing the
+        # MLC distance to iso based on old schematics. In any event, the new value is from a
+        # *ahem* credible source: Varian MLC Maintenance guide, pg 135.
+        dynalog_leaf_conversion = 1.96078
+        for leaf in range(1, mlc.num_leaves + 1):
+            mlc.leaf_axes[leaf].actual *= dynalog_leaf_conversion / 1000
+            mlc.leaf_axes[leaf].expected *= dynalog_leaf_conversion / 1000
+        return mlc
+
+    @classmethod
+    def from_tlog(cls, tlog, subbeams, jaws, snapshot_data, snapshot_idx, column_iter):
+        """Construct an MLC instance from a Trajectory log."""
+        mlc = MLC(TrajectoryLog, snapshot_idx, jaws, tlog.is_hdmlc, subbeams=subbeams)
+        for leaf_num in range(1, tlog.header.num_mlc_leaves + 1):
+            leaf_axis = _get_axis(snapshot_data, next(column_iter), LeafAxis)
+            mlc.add_leaf_axis(leaf_axis, leaf_num)
+        return mlc
+
+    @property
+    def num_pairs(self) -> int:
+        """Return the number of MLC pairs."""
+        return int(self.num_leaves / 2)
+
+    @property
+    def num_leaves(self) -> int:
+        """Return the number of MLC leaves."""
+        return len(self.leaf_axes)
+
+    @property
+    def num_snapshots(self) -> int:
+        """Return the number of snapshots used for MLC RMS & Fluence calculations.
+
+        .. warning::
+            This number may not be the same as the number of recorded snapshots in the log
+            since the snapshots where the beam was off may not be included. See :meth:`MachineLog.load`
+        """
+        return len(self.snapshot_idx)
+
+    @property
+    def num_moving_leaves(self) -> int:
+        """Return the number of leaves that moved."""
+        return len(self.moving_leaves)
+
+    @cached_property
+    def moving_leaves(self) -> np.ndarray:
+        """Return an array of the leaves that moved during treatment."""
+        threshold = 0.01
+        indices = ()
+        for leaf_num, leafdata in self.leaf_axes.items():
+            if type(self) == TrajectoryLog:
+                leaf_stdev = np.std(leafdata.actual[self.subbeams[-1]._snapshots])
+            else:
+                leaf_stdev = np.std(leafdata.actual[self.snapshot_idx])
+            if leaf_stdev > threshold:
+                indices += (leaf_num,)
+        return np.array(indices)
+
+    def add_leaf_axis(self, leaf_axis: LeafAxis, leaf_num: int) -> None:
+        """Add a leaf axis to the MLC data structure.
+
+        Parameters
+        ----------
+        leaf_axis : LeafAxis
+            The leaf axis to be added.
+        leaf_num : int
+            The leaf number.
+
+            .. warning:: Leaf numbers are 1-index based to correspond with Varian convention.
+        """
+        self.leaf_axes[leaf_num] = leaf_axis
+
+    def leaf_moved(self, leaf_num: int) -> bool:
+        """Return whether the given leaf moved during treatment.
+
+        Parameters
+        ----------
+        leaf_num : int
+
+
+        .. warning:: Leaf numbers are 1-index based to correspond with Varian convention.
+        """
+        return leaf_num in self.moving_leaves
+
+    def pair_moved(self, pair_num: int) -> bool:
+        """Return whether the given pair moved during treatment.
+
+        If either leaf moved, the pair counts as moving.
+
+        Parameters
+        ----------
+        pair_num : int
+
+
+        .. warning:: Pair numbers are 1-index based to correspond with Varian convention.
+        """
+        a_leaf = pair_num
+        b_leaf = pair_num + self.num_pairs
+        return self.leaf_moved(a_leaf) or self.leaf_moved(b_leaf)
+
+    @property
+    def _all_leaf_indices(self) -> np.ndarray:
+        """Return an array enumerated over all the leaves."""
+        return np.array(range(1, len(self.leaf_axes) + 1))
+
+    def get_RMS_avg(
+        self, bank: MLCBank = MLCBank.BOTH, only_moving_leaves: bool = False
+    ):
+        """Return the overall average RMS of given leaves.
+
+        Parameters
+        ----------
+        bank :
+            Specifies which bank(s) is desired.
+        only_moving_leaves : boolean
+            If False (default), include all the leaves.
+            If True, will remove the leaves that were static during treatment.
+
+            .. warning::
+                The RMS and error will nearly always be lower if all leaves are included since non-moving leaves
+                have an error of 0 and will drive down the average values. Convention would include all leaves,
+                but prudence would use only the moving leaves to get a more accurate assessment of error/RMS.
+
+        Returns
+        -------
+        float
+        """
+        leaves = self.get_leaves(bank, only_moving_leaves)
+        rms_array = self.create_RMS_array(leaves)
+        rms = np.mean(rms_array)
+        if np.isnan(rms):
+            return 0
+        else:
+            return rms
+
+    def get_RMS_max(self, bank: MLCBank = MLCBank.BOTH) -> float:
+        """Return the overall maximum RMS of given leaves.
+
+        Parameters
+        ----------
+        bank :
+            Specifies which bank(s) is desired.
+
+        Returns
+        -------
+        float
+        """
+        leaves = self.get_leaves(bank)
+        rms_array = self.create_RMS_array(leaves)
+        rms = np.max(rms_array)
+        if np.isnan(rms):
+            return 0
+        else:
+            return rms
+
+    def get_RMS_percentile(
+        self,
+        percentile: int | float = 95,
+        bank: MLCBank = MLCBank.BOTH,
+        only_moving_leaves: bool = False,
+    ):
+        """Return the n-th percentile value of RMS for the given leaves.
+
+        Parameters
+        ----------
+        percentile : int
+            RMS percentile desired.
+        bank :
+            Specifies which bank(s) is desired.
+        only_moving_leaves : boolean
+            If False (default), include all the leaves.
+            If True, will remove the leaves that were static during treatment.
+
+            .. warning::
+                The RMS and error will nearly always be lower if all leaves are included since non-moving leaves
+                have an error of 0 and will drive down the average values. Convention would include all leaves,
+                but prudence would use only the moving leaves to get a more accurate assessment of error/RMS.
+        """
+        leaves = self.get_leaves(bank, only_moving_leaves)
+        rms_array = self.create_RMS_array(leaves)
+        return np.percentile(rms_array, percentile)
+
+    def get_RMS(self, leaves_or_bank: str | MLCBank | Iterable) -> np.ndarray:
+        """Return an array of leaf RMSs for the given leaves or MLC bank.
+
+        Parameters
+        ----------
+        leaves_or_bank : sequence of numbers, {'a', 'b', 'both'}
+            If a sequence, must be a sequence of leaf numbers desired.
+            If a string, it specifies which bank (or both) is desired.
+
+        Returns
+        -------
+        numpy.ndarray
+            An array for the given leaves containing the RMS error.
+        """
+        if isinstance(leaves_or_bank, (str, MLCBank)):
+            leaves_or_bank = self.get_leaves(leaves_or_bank)
+        elif not is_iterable(leaves_or_bank):
+            raise TypeError("Input must be iterable, or specify an MLC bank")
+        return self.create_RMS_array(np.array(leaves_or_bank))
+
+    def get_leaves(
+        self, bank: MLCBank = MLCBank.BOTH, only_moving_leaves: bool = False
+    ) -> list:
+        """Return a list of leaves that match the given conditions.
+
+        Parameters
+        ----------
+        bank : {'A', 'B', 'both'}
+            Specifies which bank(s) is desired.
+        only_moving_leaves : boolean
+            If False (default), include all the leaves.
+            If True, will remove the leaves that were static during treatment.
+        """
+        bank = convert_to_enum(bank, MLCBank)
+
+        # get all leaves or only the moving leaves
+        if only_moving_leaves:
+            leaves = copy.copy(self.moving_leaves)
+        else:
+            leaves = copy.copy(self._all_leaf_indices)
+
+        # select leaves by bank if desired
+        if bank is not None:
+            if bank == MLCBank.A:
+                leaves = leaves[leaves <= self.num_pairs]
+            elif bank == MLCBank.B:
+                leaves = leaves[leaves > self.num_pairs]
+
+        return leaves
+
+    def get_error_percentile(
+        self,
+        percentile: int | float = 95,
+        bank: MLCBank = MLCBank.BOTH,
+        only_moving_leaves: bool = False,
+    ) -> float:
+        """Calculate the n-th percentile error of the leaf error.
+
+        Parameters
+        ----------
+        percentile : int
+            RMS percentile desired.
+        bank : {'A', 'B', 'both'}
+            Specifies which bank(s) is desired.
+        only_moving_leaves : boolean
+            If False (default), include all the leaves.
+            If True, will remove the leaves that were static during treatment.
+
+            .. warning::
+                The RMS and error will nearly always be lower if all leaves are included since non-moving leaves
+                have an error of 0 and will drive down the average values. Convention would include all leaves,
+                but prudence would use only the moving leaves to get a more accurate assessment of error/RMS.
+        """
+        leaves = self.get_leaves(bank, only_moving_leaves)
+        leaves -= 1
+        error_array = self.create_error_array(leaves)
+
+        abs_error = np.abs(error_array)
+        return np.percentile(abs_error, percentile)
+
+    def create_error_array(
+        self, leaves: Sequence[int], absolute: bool = True
+    ) -> np.ndarray:
+        """Create and return an error array of only the leaves specified.
+
+        Parameters
+        ----------
+        leaves : sequence
+            Leaves desired.
+        absolute : bool
+            If True, (default) absolute error will be returned.
+            If False, error signs will be retained.
+
+        Returns
+        -------
+        numpy.ndarray
+            An array of size leaves-x-num_snapshots
+        """
+        if absolute:
+            error_array = self._abs_error_all_leaves
+        else:
+            error_array = self._error_array_all_leaves
+        return error_array[leaves, :]
+
+    def create_RMS_array(self, leaves: Sequence[int]) -> np.ndarray:
+        """Create an RMS array of only the leaves specified.
+
+        Parameters
+        ----------
+        leaves : sequence
+            Leaves desired.
+
+        Returns
+        -------
+        numpy.ndarray
+            An array of size leaves-x-num_snapshots
+        """
+        rms_array = self._RMS_array_all_leaves
+        leaves -= 1
+        if len(leaves) == 0:
+            return np.array([0])
+        return rms_array[leaves]
+
+    @property
+    def _abs_error_all_leaves(self) -> float:
+        """Absolute error of all leaves."""
+        return np.abs(self._error_array_all_leaves)
+
+    @cached_property
+    def _error_array_all_leaves(self) -> np.ndarray:
+        """Error array of all leaves."""
+        mlc_error = np.zeros((self.num_leaves, self.num_snapshots))
+        # construct numpy array for easy array calculation
+        for leaf in range(self.num_leaves):
+            mlc_error[leaf, :] = self.leaf_axes[leaf + 1].difference[self.snapshot_idx]
+        return mlc_error
+
+    @argue.options(dtype=("actual", "expected"))
+    def _snapshot_array(self, dtype: str = "actual") -> np.ndarray:
+        """Return an array of the snapshot data of all leaves."""
+        arr = np.zeros((self.num_leaves, self.num_snapshots))
+        # construct numpy array for easy array calculation
+        for leaf in range(self.num_leaves):
+            arr[leaf, :] = getattr(self.leaf_axes[leaf + 1], dtype)[self.snapshot_idx]
+        return arr
+
+    @cached_property
+    def _RMS_array_all_leaves(self) -> np.ndarray:
+        """Return the RMS of all leaves."""
+        rms_array = np.array(
+            [
+                np.sqrt(
+                    np.sum(leafdata.difference[self.snapshot_idx] ** 2)
+                    / self.num_snapshots
+                )
+                for leafdata in self.leaf_axes.values()
+            ]
+        )
+        return rms_array
+
+    def leaf_under_y_jaw(self, leaf_num: int) -> bool:
+        """Return a boolean specifying if the given leaf is under one of the y jaws.
+
+        Parameters
+        ----------
+        leaf_num : int
+        """
+        outer_leaf_thickness = 10  # mm
+        inner_leaf_thickness = 5
+        mlc_position = 0
+        if self.hdmlc:
+            outer_leaf_thickness /= 2
+            inner_leaf_thickness /= 2
+            mlc_position = 100
+        for leaf in range(1, leaf_num + 1):
+            if 10 >= leaf or leaf >= 110:
+                mlc_position += outer_leaf_thickness
+            elif 50 >= leaf or leaf >= 70:
+                mlc_position += inner_leaf_thickness
+            else:  # between 50 and 70
+                mlc_position += outer_leaf_thickness
+
+        y2_position = self._jaws.y2.actual.max() * 10 + 200
+        y1_position = 200 - self._jaws.y1.actual.max() * 10
+        if 10 >= leaf or leaf >= 110:
+            thickness = outer_leaf_thickness
+        elif 50 >= leaf or leaf >= 70:
+            thickness = inner_leaf_thickness
+        else:  # between 50 and 70
+            thickness = outer_leaf_thickness
+        return mlc_position < y1_position or mlc_position - thickness > y2_position
+
+    @argue.options(dtype=("actual", "expected"))
+    def get_snapshot_values(
+        self,
+        bank_or_leaf: MLCBank | Iterable = MLCBank.BOTH,
+        dtype: str = "actual",
+    ) -> np.ndarray:
+        """Retrieve the snapshot data of the given MLC bank or leaf/leaves
+
+        Parameters
+        ----------
+        bank_or_leaf : str, array, list
+            If a str, specifies what bank ('A', 'B', 'both').
+            If an array/list, specifies what leaves (e.g. [1,2,3])
+        dtype : {'actual', 'expected'}
+            The type of MLC snapshot data to return.
+
+        Returns
+        -------
+        ndarray
+            An array of shape (number of leaves - x - number of snapshots). E.g. for an MLC bank
+            and 500 snapshots, the array would be (60, 500).
+        """
+        if isinstance(bank_or_leaf, (str, MLCBank)):
+            leaves = self.get_leaves(bank=bank_or_leaf)
+            leaves -= 1
+        else:
+            leaves = bank_or_leaf
+
+        arr = self._snapshot_array(dtype)
+        return arr[leaves, :]
+
+    def plot_mlc_error_hist(self, show: bool = True) -> None:
+        """Plot an MLC error histogram."""
+        plt.hist(self._abs_error_all_leaves.flatten())
+        if show:
+            plt.show()
+
+    def save_mlc_error_hist(self, filename: str, **kwargs) -> None:
+        """Save the MLC error histogram to file."""
+        self.plot_mlc_error_hist(show=False)
+        plt.savefig(filename, **kwargs)
+
+    def plot_rms_by_leaf(self, show: bool = True) -> None:
+        """Plot RMSs by leaf."""
+        plt.clf()
+        plt.bar(
+            np.arange(len(self.get_RMS(MLCBank.BOTH)))[::-1],
+            self.get_RMS(MLCBank.BOTH),
+            align="center",
+        )
+        if show:
+            plt.show()
+
+    def save_rms_by_leaf(self, filename: str, **kwargs) -> None:
+        """Save the RMS-leaf to file."""
+        self.plot_rms_by_leaf(show=False)
+        plt.savefig(filename, **kwargs)
+
+
+class JawStruct:
+    """Jaw Axes data structure.
+
+    Attributes
+    ----------
+    x1 : :class:`~pylinac.log_analyzer.Axis`
+    y1 : :class:`~pylinac.log_analyzer.Axis`
+    x2 : :class:`~pylinac.log_analyzer.Axis`
+    y2 : :class:`~pylinac.log_analyzer.Axis`
+    """
+
+    def __init__(self, x1: HeadAxis, y1: HeadAxis, x2: HeadAxis, y2: HeadAxis):
+        if not all(
+            (
+                isinstance(x1, HeadAxis),
+                isinstance(y1, HeadAxis),
+                isinstance(x2, HeadAxis),
+                isinstance(y2, HeadAxis),
+            )
+        ):
+            raise TypeError("HeadAxis not passed into Jaw structure")
+        self.x1 = x1
+        self.y1 = y1
+        self.x2 = x2
+        self.y2 = y2
+
+
+class CouchStruct:
+    """Couch Axes data structure."""
+
+    vert: CouchAxis
+    long: CouchAxis
+    latl: CouchAxis
+    rotn: CouchAxis
+    pitch: CouchAxis | None
+    roll: CouchAxis | None
+
+    def __init__(
+        self,
+        vertical: CouchAxis,
+        longitudinal: CouchAxis,
+        lateral: CouchAxis,
+        rotational: CouchAxis,
+        pitch: CouchAxis | None = None,
+        roll: CouchAxis | None = None,
+    ):
+        if not all(
+            (
+                isinstance(vertical, CouchAxis),
+                isinstance(longitudinal, CouchAxis),
+                isinstance(lateral, CouchAxis),
+                isinstance(rotational, CouchAxis),
+            )
+        ):
+            raise TypeError("Couch structure must be passed Couch Axes.")
+        self.vert = vertical
+        self.long = longitudinal
+        self.latl = lateral
+        self.rotn = rotational
+        if pitch is not None:
+            self.pitch = pitch
+            self.roll = roll
+        else:
+            self.pitch = None
+            self.roll = None
+
+
+class Subbeam:
+    """Data structure for trajectory log "subbeams". Only applicable for auto-sequenced beams.
+
+    Attributes
+    ----------
+    control_point : int
+        Internally-defined marker that defines where the plan is currently executing.
+    mu_delivered : float
+        Dose delivered in units of MU.
+    rad_time : float
+        Radiation time in seconds.
+    sequence_num : int
+        Sequence number of the subbeam.
+    beam_name : str
+        Name of the subbeam.
+    """
+
+    def __init__(self, file, log_version: float):
+        f = file
+        self.control_point = decode_binary(f, int)
+        self.mu_delivered = decode_binary(f, float)
+        self.rad_time = decode_binary(f, float)
+        self.sequence_num = decode_binary(f, int)
+        # In Tlogs version 3.0 and up, beam names are 512 byte unicode strings, but in <3.0 they are 32 byte unicode strings
+        if log_version >= 3:
+            chars = 512
+        else:
+            chars = 32
+        self.beam_name = decode_binary(f, str, chars, 32)
+
+    @property
+    def gantry_angle(self) -> float:
+        """Median gantry angle of the subbeam."""
+        return self._get_metadata_axis("gantry")
+
+    @property
+    def collimator_angle(self) -> float:
+        """Median collimator angle of the subbeam."""
+        return self._get_metadata_axis("collimator")
+
+    @property
+    def jaw_x1(self) -> float:
+        """Median X1 position of the subbeam."""
+        return self._get_metadata_axis("jaws", "x1")
+
+    @property
+    def jaw_x2(self) -> float:
+        """Median X2 position of the subbeam."""
+        return self._get_metadata_axis("jaws", "x2")
+
+    @property
+    def jaw_y1(self) -> float:
+        """Median Y1 position of the subbeam."""
+        return self._get_metadata_axis("jaws", "y1")
+
+    @property
+    def jaw_y2(self) -> float:
+        """Median Y2 position of the subbeam."""
+        return self._get_metadata_axis("jaws", "y2")
+
+    def _get_metadata_axis(self, attr, subattr=None) -> Axis:
+        if subattr is None:
+            actual = getattr(self._axis_data, attr).actual[self._snapshots]
+            expected = getattr(self._axis_data, attr).expected[self._snapshots]
+        else:
+            actual = getattr(getattr(self._axis_data, attr), subattr).actual[
+                self._snapshots
+            ]
+            expected = getattr(getattr(self._axis_data, attr), subattr).expected[
+                self._snapshots
+            ]
+        return Axis(np.median(actual), np.median(expected))
+
+
+class SubbeamManager:
+    """One of 4 subsections of a trajectory log. Holds a list of Subbeams; only applicable for auto-sequenced beams."""
+
+    def __init__(self, file, header):
+        self.subbeams = []
+        if header.num_subbeams > 0:
+            for _ in range(header.num_subbeams):
+                subbeam = Subbeam(file, header.version)
+                self.subbeams.append(subbeam)
+
+    def post_hoc_metadata(self, axis_data):
+        """From the Axis Data, perform post-hoc analysis and set metadata to the subbeams.
+        Gives the subbeams more information, as not much is given directly in the logs.
+        """
+        for subbeam_num, subbeam in enumerate(self.subbeams):
+            self._set_subbeam_snapshots(axis_data, subbeam_num)
+            mlc_subsection = copy.copy(axis_data.mlc)
+            mlc_subsection.snapshot_idx = subbeam._snapshots
+            subbeam.fluence = FluenceStruct(
+                mlc_subsection, axis_data.mu, axis_data.jaws
+            )
+        gc.collect()  # don't know why gc is needed; maybe something to do w/ copy?
+
+    def _set_subbeam_snapshots(self, axis_data, beam_num: int):
+        """Get the snapshot indices 1) where the beam was on and 2) between the subbeam control point values."""
+        subbeam = self.subbeams[beam_num]
+        cp_by_snapshot = axis_data.control_point.actual
+
+        # find upper and lower bounds of the subbeam control points
+        cp_lower_bound = subbeam.control_point
+        try:
+            cp_upper_bound = self.subbeams[beam_num + 1].control_point
+        except IndexError:
+            cp_upper_bound = cp_by_snapshot[-1]
+
+        # extract the snapshots within those control points and drop the beam holds as booleans
+        snapshots_within_subbeam = np.logical_and(
+            cp_by_snapshot >= cp_lower_bound, cp_by_snapshot < cp_upper_bound
+        )
+        beam_on_snapshots = axis_data.beam_hold.actual == 0
+        combined_snaps_as_bool = np.logical_and(
+            beam_on_snapshots, snapshots_within_subbeam
+        )
+        # convert boolean array back to snapshot indices
+        combined_snapshots = [
+            snapshot_idx
+            for (snapshot_idx, boolean_snapshot) in enumerate(combined_snaps_as_bool)
+            if boolean_snapshot
+        ]
+
+        subbeam._snapshots = combined_snapshots
+        subbeam._axis_data = axis_data
+
+    def __getitem__(self, item) -> Subbeam:
+        return self.subbeams[item]
+
+    def __len__(self):
+        return len(self.subbeams)
+
+
+class LogBase:
+    """Base class for the Dynalog and TrajectoryLog classes. Should not be called directly."""
+
+    ANON_LINE = -1
+
+    def __init__(self, filename: str, exclude_beam_off: bool = True):
+        if is_log(filename):
+            self.filename = filename
+            self.exclude_beam_off = exclude_beam_off
+        else:
+            raise OSError(f"{filename} was not a valid log file")
+
+    @classmethod
+    def from_url(cls, url: str, exclude_beam_off: bool = True):
+        """Instantiate a log from a URL."""
+        filename = io.get_url(url)
+        return cls(filename, exclude_beam_off)
+
+    def plot_summary(self, show: bool = True):
+        """Plot actual & expected fluence, gamma map, gamma histogram,
+        MLC error histogram, and MLC RMS histogram.
+        """
+        self.fluence.gamma.is_map_calced(raise_error=True)
+
+        # plot the actual fluence
+        ax = plt.subplot(2, 3, 1)
+        self.plot_subfluence(Fluence.ACTUAL, ax, show=False)
+
+        # plot the expected fluence
+        ax = plt.subplot(2, 3, 2)
+        self.plot_subfluence(Fluence.EXPECTED, ax, show=False)
+
+        # plot the gamma map
+        ax = plt.subplot(2, 3, 3)
+        self.plot_subfluence(Fluence.GAMMA, ax, show=False)
+
+        # plot the gamma histogram
+        ax = plt.subplot(2, 3, 4)
+        self.plot_subgraph(Graph.GAMMA, ax, show=False)
+
+        # plot the MLC error histogram
+        ax = plt.subplot(2, 3, 5)
+        self.plot_subgraph(Graph.HISTOGRAM, ax, show=False)
+
+        # plot the leaf RMSs
+        ax = plt.subplot(2, 3, 6)
+        self.plot_subgraph("rms", ax, show=False)
+
+        if show:
+            plt.show()
+
+    def save_summary(self, filename: str, **kwargs) -> None:
+        """Save the summary image to file."""
+        self.plot_summary(show=False)
+        plt.savefig(filename, **kwargs)
+        plt.close()
+
+    def plot_subfluence(
+        self, img: Fluence, ax: plt.Axes = None, show: bool = True, fontsize: int = 10
+    ):
+        """Plot a subimage."""
+        img = convert_to_enum(img, Fluence)
+        if ax is None:
+            ax = plt.subplot()
+        ax.tick_params(axis="both", labelsize=8)
+        if img in (Fluence.ACTUAL, Fluence.EXPECTED):
+            title = img.value.capitalize() + " Image"
+            plt.imshow(
+                getattr(self.fluence, img.value).array.astype(np.float32),
+                aspect="auto",
+                interpolation="none",
+                cmap=get_array_cmap(),
+            )
+        elif img == Fluence.GAMMA:
+            plt.imshow(
+                getattr(self.fluence, img.value).array.astype(np.float32),
+                aspect="auto",
+                interpolation="none",
+                vmax=1,
+                cmap=get_array_cmap(),
+            )
+            plt.colorbar(ax=ax)
+            title = "Gamma Map"
+        ax.autoscale(tight=True)
+        ax.set_title(title, fontsize=fontsize)
+        if show:
+            plt.show()
+
+    def save_subimage(
+        self, filename: str | BinaryIO, img: Fluence, fontsize: int, **kwargs
+    ):
+        """Save a subimage to file"""
+        self.plot_subfluence(img, show=False, fontsize=fontsize)
+        plt.savefig(filename, **kwargs)
+        plt.close()
+
+    def plot_subgraph(
+        self,
+        graph: Graph,
+        ax: plt.Axes = None,
+        show: bool = True,
+        fontsize: int = 10,
+        labelsize: int = 8,
+    ):
+        graph = convert_to_enum(graph, Graph)
+        if ax is None:
+            ax = plt.subplot()
+        if graph == Graph.GAMMA:
+            title = "Gamma Histogram"
+            plt.hist(self.fluence.gamma.array.flatten(), bins=self.fluence.gamma.bins)
+            ax.set_yscale("log")
+        elif graph == Graph.HISTOGRAM:
+            title = "Leaf Histogram"
+            plt.hist(self.axis_data.mlc._abs_error_all_leaves.flatten())
+        elif graph == Graph.RMS:
+            title = "Leaf RMS (mm)"
+            ax.set_xlim(
+                [-0.5, self.axis_data.mlc.num_leaves + 0.5]
+            )  # bit of padding since bar chart alignment is center
+            plt.bar(
+                np.arange(len(self.axis_data.mlc.get_RMS("both")))[::-1],
+                self.axis_data.mlc.get_RMS("both") * 10,
+                align="center",
+            )
+        ax.set_title(title, fontsize=fontsize)
+        ax.tick_params(axis="both", labelsize=labelsize)
+        ax.grid(True)
+        if show:
+            plt.show()
+
+    def save_subgraph(
+        self,
+        filename: str | BinaryIO,
+        graph: Graph,
+        fontsize: int = 10,
+        labelsize: int = 8,
+        **kwargs,
+    ):
+        self.plot_subgraph(graph, show=False, fontsize=fontsize, labelsize=labelsize)
+        plt.savefig(filename, **kwargs)
+        plt.close()
+
+    def report_basic_parameters(self, printout: bool = True) -> str:
+        """Print the common parameters analyzed when investigating machine logs:
+
+        - Log type
+        - Average MLC RMS
+        - Maximum MLC RMS
+        - 95th percentile MLC error
+        - Number of beam holdoffs
+        - Gamma pass percentage
+        - Average gamma value
+        """
+        title = f"Results of file: {self.filename}\n"
+        if self.treatment_type == TreatmentType.IMAGING.value:
+            string = title + "Log is an Imaging field; no statistics can be calculated"
+        else:
+            avg_rms = f"Average RMS of all leaves: {self.axis_data.mlc.get_RMS_avg(only_moving_leaves=False)*10:3.3f} mm\n"
+            max_rms = f"Max RMS error of all leaves: {self.axis_data.mlc.get_RMS_max()*10:3.3f} mm\n"
+            p95 = f"95th percentile error: {self.axis_data.mlc.get_error_percentile(95, only_moving_leaves=False)*10:3.3f} mm\n"
+            num_holdoffs = f"Number of beam holdoffs: {self.num_beamholds:1.0f}\n"
+            self.fluence.gamma.calc_map()
+            gamma_pass = f"Gamma pass %: {self.fluence.gamma.pass_prcnt:2.2f}\n"
+            gamma_avg = f"Gamma average: {self.fluence.gamma.avg_gamma:2.3f}\n"
+
+            string = (
+                title + avg_rms + max_rms + p95 + num_holdoffs + gamma_pass + gamma_avg
+            )
+        if printout:
+            print(string)
+        return string
+
+    @property
+    def treatment_type(self) -> str:
+        """The treatment type of the log. Possible options:
+
+        Returns
+        -------
+        str
+            See :class:`~pylinac.log_analyzer.TreatmentType`
+        """
+        if isinstance(self, TrajectoryLog):  # trajectory log
+            gantry_std = max(
+                subbeam.gantry_angle.actual.std() for subbeam in self.subbeams
+            )
+            if np.isnan(gantry_std):
+                return TreatmentType.IMAGING.value
+        else:
+            gantry_std = self.axis_data.gantry.actual.std()
+        if gantry_std > 0.5:
+            return TreatmentType.VMAT.value
+        elif self.axis_data.mu.actual.max() <= 2.1:
+            return TreatmentType.IMAGING.value
+        elif self.axis_data.mlc.num_moving_leaves == 0 and isinstance(
+            self, TrajectoryLog
+        ):
+            return TreatmentType.STATIC_IMRT.value
+        else:
+            return TreatmentType.DYNAMIC_IMRT.value
+
+    @property
+    def _underscore_idx(self) -> int:
+        base_filename = osp.basename(self.filename)
+        under_index = base_filename.find("_")
+        if under_index < 0:
+            raise NameError(
+                f"Filename `{base_filename}` has no underscore. "
+                "Place an underscore between the patient ID and the rest of the filename and try again."
+            )
+        return under_index
+
+
+class DynalogHeader(Structure):
+    """
+    Attributes
+    ----------
+    version : str
+        The Dynalog version letter.
+    patient_name : str
+        Patient information.
+    plan_filename : str
+        Filename if using standalone. If using Treat =<6.5 will produce PlanUID, Beam Number.
+        Not yet implemented for this yet.
+    tolerance : int
+        Plan tolerance.
+    num_mlc_leaves : int
+        Number of MLC leaves.
+    clinac_scale : int
+        Clinac scale; 0 -> Varian scale, 1 -> IEC 60601-2-1 scale
+    """
+
+    def __init__(self, dlogdata):
+        c = itertools.count()
+        super().__init__(
+            version=str(dlogdata[next(c)]),
+            patient_name=dlogdata[next(c)],
+            plan_filename=dlogdata[next(c)],
+            tolerance=int(dlogdata[next(c)][0]),
+            num_mlc_leaves=int(dlogdata[next(c)][0]) * 2,
+            clinac_scale=int(dlogdata[next(c)][0]),
+        )
+
+
+class DynalogAxisData:
+    """
+    Attributes
+    ----------
+    num_snapshots : int
+        Number of snapshots recorded.
+    mu : :class:`~pylinac.log_analyzer.Axis`
+        Current dose fraction
+
+        .. note:: This *can* be gantry rotation under certain conditions. See Dynalog file specs.
+
+    previous_segment_num : :class:`~pylinac.log_analyzer.Axis`
+        Previous segment *number*, starting with zero.
+    beam_hold : :class:`~pylinac.log_analyzer.Axis`
+        Beam hold state; 0 -> holdoff not asserted (beam on), 1 -> holdoff asserted, 2 -> carriage in transition
+    beam_on : :class:`~pylinac.log_analyzer.Axis`
+        Beam on state; 1 -> beam is on, 0 -> beam is off
+    prior_dose_index : :class:`~pylinac.log_analyzer.Axis`
+        Previous segment dose index or previous segment gantry angle.
+    next_dose_index : :class:`~pylinac.log_analyzer.Axis`
+        Next segment dose index.
+    gantry : :class:`~pylinac.log_analyzer.Axis`
+        Gantry data in degrees.
+    collimator : :class:`~pylinac.log_analyzer.Axis`
+        Collimator data in degrees.
+    jaws : :class:`~pylinac.log_analyzer.Jaw_Struct`
+        Jaw data structure. Data in cm.
+    carriage_A : :class:`~pylinac.log_analyzer.Axis`
+        Carriage A data. Data in cm.
+    carriage_B : :class:`~pylinac.log_analyzer.Axis`
+        Carriage B data. Data in cm.
+    mlc : :class:`~pylinac.log_analyzer.MLC`
+        MLC data structure. Data in cm.
+    """
+
+    def __init__(self, log, dlogdata):
+        """Read the dynalog axis data."""
+        snapshot_data = np.array(dlogdata[6:], dtype=np.float64).transpose()
+
+        self.num_snapshots = np.size(snapshot_data, 1)
+
+        c = itertools.count()
+
+        def nx():
+            return snapshot_data[next(c)]
+
+        # assignment of snapshot values
+        # There is no "expected" MU in dynalogs, but for fluence calc purposes, it is set to that of the actual
+        mu = nx()
+
+        # if treatment was vmat then MU is replaced by gantry angle (so stupid). If so, convert to normalized MU by looking at gantry movement.
+        def correct_vmat_mu(mu_array):
+            if mu_array[-1] == 25000:
+                return mu_array
+            else:
+                abs_diff = list(np.abs(np.diff(mu_array)))
+                # this is the cumulative gantry diff, a surrogate for MU. Normalize to 25000 to look like a "normal" dynalog
+                cum_gantry_diff = (
+                    np.array(
+                        [
+                            0,
+                        ]
+                        + list(np.cumsum(abs_diff) / np.sum(abs_diff))
+                    )
+                    * 25000
+                )
+                return cum_gantry_diff
+
+        corrected_mu = correct_vmat_mu(mu)
+
+        self.mu = Axis(corrected_mu, corrected_mu)
+        self.previous_segment_num = Axis(nx())
+        self.beam_hold = Axis(nx())
+        self.beam_on = Axis(nx())
+        self.prior_dose_index = Axis(nx())  # currently not used for anything
+        self.next_dose_index = Axis(nx())  # ditto
+        self.gantry = GantryAxis(nx() / 10)
+        self.collimator = HeadAxis(nx() / 10)
+
+        # jaws are in mm; convert to cm by /10
+        jaw_y1 = HeadAxis(nx() / 10)
+        jaw_y2 = HeadAxis(nx() / 10)
+        jaw_x1 = HeadAxis(nx() / 10)
+        jaw_x2 = HeadAxis(nx() / 10)
+        self.jaws = JawStruct(jaw_x1, jaw_y1, jaw_x2, jaw_y2)
+
+        # carriages are in 100ths of mm; converted to cm.
+        self.carriage_A = Axis(nx() / 1000)
+        self.carriage_B = Axis(nx() / 1000)
+
+        if log.exclude_beam_off:
+            hold_idx = np.where(self.beam_hold.actual == 0)[0]
+            beamon_idx = np.where(self.beam_on.actual == 1)[0]
+            snapshot_idx = np.intersect1d(hold_idx, beamon_idx)
+        else:
+            snapshot_idx = list(range(self.num_snapshots))
+
+        self.num_snapshots = self.num_snapshots
+        self.mlc = MLC.from_dlog(log, self.jaws, snapshot_data, snapshot_idx)
+
+
+class Dynalog(LogBase):
+    """Class for loading, analyzing, and plotting data within a Dynalog file.
+
+    Attributes
+    ----------
+    header : :class:`~pylinac.log_analyzer.DynalogHeader`
+    axis_data : :class:`~pylinac.log_analyzer.DynalogAxisData`
+    fluence : :class:`~pylinac.log_analyzer.FluenceStruct`
+    """
+
+    ANON_LINE = 1
+    HEADER_LINE_LENGTH = 6
+
+    def __init__(self, filename, exclude_beam_off: bool = True):
+        super().__init__(filename, exclude_beam_off)
+        if not is_dlog(self.filename):
+            raise NotADynalogError(f"{self.filename} was not a valid Dynalog file")
+        if not self._has_other_file:
+            raise DynalogMatchError(
+                "Didn't find the matching dynalog file"
+            )  # TODO: clean up
+
+        with open(self.a_logfile, encoding="utf-8") as a_log:
+            dlgdata = [line for line in csv.reader(a_log, delimiter=",")]
+        self.header = DynalogHeader(dlgdata)
+        self.axis_data = DynalogAxisData(self, dlgdata)
+        self.fluence = FluenceStruct(
+            self.axis_data.mlc, self.axis_data.mu, self.axis_data.jaws
+        )
+
+    def anon_file_renames(self, destination: str, suffix: str) -> dict:
+        base_a = osp.basename(self.a_logfile)
+        base_b = osp.basename(self.b_logfile)
+        anonymous_base_a = (
+            base_a[: self._underscore_idx] + "_Anonymous" + suffix + ".dlg"
+        )
+        anonymous_base_b = (
+            base_b[: self._underscore_idx] + "_Anonymous" + suffix + ".dlg"
+        )
+        anonymous_a = osp.join(destination, anonymous_base_a)
+        anonymous_b = osp.join(destination, anonymous_base_b)
+        filenames = collections.OrderedDict()
+        filenames[self.a_logfile] = anonymous_a
+        filenames[self.b_logfile] = anonymous_b
+        return filenames
+
+    def anon_files(self, destination: str, suffix: str):
+        return self.anon_file_renames(destination, suffix).values()
+
+    def snapshot_idx(self, axis_data) -> list:
+        if self.exclude_beam_off:
+            hold_idx = np.where(axis_data.beam_hold.actual == 0)[0]
+            beamon_idx = np.where(axis_data.beam_on.actual == 1)[0]
+            snapshot_idx = np.intersect1d(hold_idx, beamon_idx)
+        else:
+            snapshot_idx = list(range(self.num_snapshots))
+        return snapshot_idx
+
+    @property
+    def _has_other_file(self) -> bool:
+        """Whether the companion file (A* for B-file or vic versa)."""
+        return (
+            True
+            if self.identify_other_file(self.filename, raise_find_error=False)
+            is not None
+            else False
+        )
+
+    @cached_property
+    def a_logfile(self) -> str:
+        """Path of the A* dynalog file."""
+        other_dlg_file = self.identify_other_file(self.filename)
+        return (
+            self.filename
+            if osp.basename(self.filename).startswith("A")
+            else other_dlg_file
+        )
+
+    @cached_property
+    def b_logfile(self) -> str:
+        """Path of the B* dynalog file."""
+        other_dlg_file = self.identify_other_file(self.filename)
+        return (
+            self.filename
+            if osp.basename(self.filename).startswith("B")
+            else other_dlg_file
+        )
+
+    @property
+    def num_beamholds(self) -> int:
+        """Return the number of times the beam was held."""
+        diffmatrix = np.diff(self.axis_data.beam_hold.actual)
+        num_holds = int(np.sum(diffmatrix > 0))
+        return num_holds
+
+    @classmethod
+    def from_demo(cls, exclude_beam_off: bool = True):
+        """Load and instantiate from the demo dynalog file included with the package."""
+        demo_file = io.retrieve_demo_file(name="AQA.dlg")
+        io.retrieve_demo_file(name="BQA.dlg")  # also download "B" dynalog
+        return cls(demo_file, exclude_beam_off)
+
+    @staticmethod
+    def run_demo():
+        """Run the Dynalog demo."""
+        dlog = Dynalog.from_demo()
+        dlog.report_basic_parameters()
+        dlog.plot_summary()
+
+    def publish_pdf(
+        self,
+        filename: str,
+        notes: str = None,
+        metadata: dict = None,
+        open_file: bool = False,
+        logo: Path | str | None = None,
+    ):
+        """Publish (print) a PDF containing the analysis and quantitative results.
+
+        Parameters
+        ----------
+        filename : (str, file-like object}
+            The file to write the results to.
+        notes : str, list of strings
+            Text; if str, prints single line.
+            If list of strings, each list item is printed on its own line.
+        open_file : bool
+            Whether to open the file using the default program after creation.
+        metadata : dict
+            Extra data to be passed and shown in the PDF. The key and value will be shown with a colon.
+            E.g. passing {'Author': 'James', 'Unit': 'TrueBeam'} would result in text in the PDF like:
+            --------------
+            Author: James
+            Unit: TrueBeam
+            --------------
+        logo: Path, str
+            A custom logo to use in the PDF report. If nothing is passed, the default pylinac logo is used.
+        """
+        self.fluence.gamma.calc_map()
+        canvas = pdf.PylinacCanvas(
+            filename, page_title="Dynalog Analysis", metadata=metadata, logo=logo
+        )
+        canvas.add_text(
+            text=[
+                "Dynalog results:",
+                f"Average RMS (mm): {self.axis_data.mlc.get_RMS_avg()*10:2.2f}",
+                f"Max RMS (mm): {self.axis_data.mlc.get_RMS_max()*10:2.2f}",
+                f"95th Percentile error (mm): {self.axis_data.mlc.get_error_percentile(95)*10:2.2f}",
+                f"Number of beam holdoffs: {self.num_beamholds}",
+                f"Gamma pass (%): {self.fluence.gamma.pass_prcnt:2.1f}",
+                f"Gamma average: {self.fluence.gamma.avg_gamma:2.2f}",
+            ],
+            location=(10, 25.5),
+        )
+        for idx, (x, y, graph) in enumerate(
+            zip((2, 11, 2, 11), (14, 14, 6, 6), ("actual", "expected", "gamma", ""))
+        ):
+            data = BytesIO()
+            if idx != 3:
+                self.save_subimage(data, graph, fontsize=20)
+            else:
+                self.save_subgraph(data, "gamma", fontsize=20, labelsize=12)
+            canvas.add_image(data, location=(x, y), dimensions=(9, 9))
+        if notes is not None:
+            canvas.add_text(location=(1, 5.5), font_size=14, text="Notes:")
+            canvas.add_text(location=(1, 5), text=notes)
+        canvas.add_new_page()
+        for idx, (x, y, graph) in enumerate(
+            zip((5, 5), (13, 2), (Graph.HISTOGRAM, Graph.RMS))
+        ):
+            data = BytesIO()
+            self.save_subgraph(data, graph, fontsize=20, labelsize=12)
+            canvas.add_image(location=(x, y), dimensions=(13, 13), image_data=data)
+        canvas.finish()
+
+        if open_file:
+            webbrowser.open(filename)
+
+    @staticmethod
+    def identify_other_file(first_dlg_file: str, raise_find_error: bool = True) -> str:
+        """Return the filename of the corresponding dynalog file.
+
+        For example, if the A*.dlg file was passed in, return the corresponding B*.dlg filename.
+        Can find both A- and B-files.
+
+        Parameters
+        ----------
+        first_dlg_file : str
+            The absolute file path of the dynalog file.
+        raise_find_error : bool
+            Whether to raise an error if the file isn't found.
+
+        Returns
+        -------
+        str
+            The absolute file path to the corresponding dynalog file.
+        """
+        dlg_dir, dlg_file = osp.split(first_dlg_file)
+        if dlg_file.startswith("A"):
+            file2get = dlg_file.replace("A", "B", 1)
+        elif dlg_file.startswith("B"):
+            file2get = dlg_file.replace("B", "A", 1)
+        else:
+            raise ValueError(
+                "Unable to decipher log names; ensure dynalogs start with 'A' and 'B'"
+            )
+        other_filename = osp.join(dlg_dir, file2get)
+
+        if osp.isfile(other_filename):
+            return other_filename
+        elif raise_find_error:
+            raise FileNotFoundError(
+                "Complementary dlg file not found; ensure A and B-file are in same directory."
+            )
+
+    def anonymize(
+        self,
+        inplace: bool = False,
+        destination: str | None = None,
+        suffix: str | None = None,
+    ) -> list[str]:
+        """Save an anonymized version of the log.
+
+        For dynalogs, this replaces the patient ID in the filename(s) and the second line of the log with ``Anonymous<suffix>``.
+        This will rename both A* and B* logs if both are present in the same directory.
+
+        .. note::
+            Anonymization is only available for logs loaded locally (i.e. not from a URL or a data stream). To
+            anonymize such a log it must be first downloaded or written to a file, then loaded in.
+
+        .. note::
+            Anonymization is done to the log **file** itself. The current instance of ``MachineLog`` will not be anonymized.
+
+        Parameters
+        ----------
+        inplace : bool
+            If False (default), creates an anonymized **copy** of the log(s).
+            If True, **renames and replaces** the content of the log file.
+        destination : str, optional
+            A string specifying the directory where the newly anonymized logs should be placed.
+            If None, will place the logs in the same directory as the originals.
+        suffix : str, optional
+            An optional suffix that is added after ``Anonymous`` to give specificity to the log.
+
+        Returns
+        -------
+        list
+            A list containing the paths to the newly written files.
+        """
+        if suffix is None:
+            suffix = ""
+
+        # determine destination directory
+        if destination is None:
+            dest_dir = osp.dirname(self.filename)
+        else:
+            if not osp.isdir(destination):
+                raise NotADirectoryError(
+                    f"Specified destination `{destination}` was not a valid directory"
+                )
+            dest_dir = destination
+
+        # copy or rename the files, depending on `inplace` parameter
+        anonymous_filenames = self.anon_file_renames(dest_dir, suffix)
+        method = os.rename if inplace else shutil.copy
+        for old_file, new_file in anonymous_filenames.items():
+            method(old_file, new_file)
+
+        # now the actual anonymization
+        for file in self.anon_files(dest_dir, suffix):
+            with open(file, encoding="utf-8") as f:
+                txtdata = f.readlines()
+            txtdata[self.ANON_LINE] = "Patient ID:\tAnonymous_" + suffix + "\n"
+            with open(file, mode="w", encoding="utf-8") as f:
+                f.writelines(txtdata)
+            print("Anonymized file written to: ", file)
+
+        return list(anonymous_filenames.values())
+
+
+class TrajectoryLogAxisData:
+    """
+    Attributes
+    ----------
+    collimator : :class:`~pylinac.log_analyzer.Axis`
+        Collimator data in degrees.
+    gantry : :class:`~pylinac.log_analyzer.Axis`
+        Gantry data in degrees.
+    jaws : :class:`~pylinac.log_analyzer.JawStruct`
+        Jaw data structure. Data in cm.
+    couch : :class:`~pylinac.log_analyzer.CouchStruct`
+        Couch data structure. Data in cm.
+    mu : :class:`~pylinac.log_analyzer.Axis`
+        MU data in MU.
+    beam_hold : :class:`~pylinac.log_analyzer.Axis`
+        Beam hold state. Beam *pauses* (e.g. Beam Off button pressed) are not recorded in the log.
+        Data is automatic hold state.
+        0 -> Normal; beam on.
+        1 -> Freeze; beam on, dose servo is temporarily turned off.
+        2 -> Hold; servo holding beam.
+        3 -> Disabled; beam on, dose servo is disable via Service.
+    control_point : :class:`~pylinac.log_analyzer.Axis`
+        Current control point.
+    carriage_A : :class:`~pylinac.log_analyzer.Axis`
+        Carriage A data in cm.
+    carriage_B : :class:`~pylinac.log_analyzer.Axis`
+        Carriage B data in cm.
+    mlc : :class:`~pylinac.log_analyzer.MLC`
+        MLC data structure; data in cm.
+    """
+
+    def __init__(self, log, file, subbeams):
+        # step size in bytes
+        step_size = sum(log.header.samples_per_axis) * 2
+
+        # read in all snapshot data at once, then assign
+        snapshot_data = decode_binary(file, float, step_size * log.header.num_snapshots)
+
+        # reshape snapshot data to be a x-by-num_snapshots matrix
+        snapshot_data = snapshot_data.reshape(log.header.num_snapshots, -1)
+
+        clm_iter = itertools.count(step=2)
+
+        self.collimator = _get_axis(snapshot_data, next(clm_iter), HeadAxis)
+        self.gantry = _get_axis(snapshot_data, next(clm_iter), GantryAxis)
+        jaw_y1 = _get_axis(snapshot_data, next(clm_iter), HeadAxis)
+        jaw_y2 = _get_axis(snapshot_data, next(clm_iter), HeadAxis)
+        jaw_x1 = _get_axis(snapshot_data, next(clm_iter), HeadAxis)
+        jaw_x2 = _get_axis(snapshot_data, next(clm_iter), HeadAxis)
+        self.jaws = JawStruct(jaw_x1, jaw_y1, jaw_x2, jaw_y2)
+
+        vrt = _get_axis(snapshot_data, next(clm_iter), CouchAxis)
+        lng = _get_axis(snapshot_data, next(clm_iter), CouchAxis)
+        lat = _get_axis(snapshot_data, next(clm_iter), CouchAxis)
+        rtn = _get_axis(snapshot_data, next(clm_iter), CouchAxis)
+        if log.header.version >= 3:
+            pitch = _get_axis(snapshot_data, next(clm_iter), CouchAxis)
+            roll = _get_axis(snapshot_data, next(clm_iter), CouchAxis)
+        else:
+            pitch = None
+            roll = None
+        self.couch = CouchStruct(vrt, lng, lat, rtn, pitch, roll)
+
+        self.mu = _get_axis(snapshot_data, next(clm_iter), BeamAxis)
+
+        self.beam_hold = _get_axis(snapshot_data, next(clm_iter), BeamAxis)
+
+        self.control_point = _get_axis(snapshot_data, next(clm_iter), BeamAxis)
+
+        self.carriage_A = _get_axis(snapshot_data, next(clm_iter), HeadAxis)
+        self.carriage_B = _get_axis(snapshot_data, next(clm_iter), HeadAxis)
+
+        if log.exclude_beam_off:
+            snapshot_idx = np.where(self.beam_hold.actual == 0)[0]
+        else:
+            snapshot_idx = list(range(log.header.num_snapshots))
+
+        self.mlc = MLC.from_tlog(
+            log, subbeams, self.jaws, snapshot_data, snapshot_idx, clm_iter
+        )
+
+
+class TrajectoryLogHeader:
+    """
+    Attributes
+    ----------
+    header : str
+        Header signature: 'VOSTL'.
+    version : str
+        Log version.
+    header_size : int
+        Header size; fixed at 1024.
+    sampling_interval : int
+        Sampling interval in milliseconds.
+    num_axes : int
+        Number of axes sampled.
+    axis_enum : int
+        Axis enumeration; see the Tlog file specification for more info.
+    samples_per_axis : numpy.ndarray
+        Number of samples per axis; 1 for most axes, for MLC it's # of leaves and carriages.
+    num_mlc_leaves : int
+        Number of MLC leaves.
+    axis_scale : int
+        Axis scale; 1 -> Machine scale, 2 -> Modified IEC 61217.
+    num_subbeams : int
+        Number of subbeams, if autosequenced.
+    is_truncated : int
+        Whether log was truncated due to space limitations; 0 -> not truncated, 1 -> truncated
+    num_snapshots : int
+        Number of snapshots, cycles, heartbeats, or whatever you'd prefer to call them.
+    mlc_model : int
+        The MLC model; 2 -> NDS 120 (e.g. Millennium), 3 -> NDS 120 HD (e.g. Millennium 120 HD)
+    """
+
+    def __init__(self, file: BinaryIO):
+        f = file
+        self.header = decode_binary(f, str, 16)  # for version 1.5 will be "VOSTL"
+        self.version = float(decode_binary(f, str, 16))  # in the format of 2.x or 3.x
+        self.header_size = decode_binary(f, int)  # fixed at 1024 in 1.5 specs
+        self.sampling_interval = decode_binary(f, int)
+        self.num_axes = decode_binary(f, int)
+        self.axis_enum = decode_binary(f, int, self.num_axes)
+        self.samples_per_axis = decode_binary(f, int, self.num_axes)
+        self.num_mlc_leaves = (
+            self.samples_per_axis[-1] - 2
+        )  # subtract 2 (each carriage counts as an "axis" and must be removed)
+        self.axis_scale = decode_binary(f, int)
+        self.num_subbeams = decode_binary(f, int)
+        self.is_truncated = decode_binary(f, int)
+        self.num_snapshots = decode_binary(f, int)
+        # the section after MLC model is reserved. Cursor is moved to the end of this reserved section.
+        if self.version >= 4.0:
+            self.mlc_model = decode_binary(f, int)
+            self.metadata = Metadata(f, self.num_axes)
+        else:
+            self.mlc_model = decode_binary(
+                f, int, cursor_shift=1024 - (64 + self.num_axes * 8)
+            )
+
+
+class Metadata:
+    """Metadata field for Trajectory logs v4.0+.
+
+    .. warning::
+          The TrueBeam log file spec says that there is a reserved section of the same size as v3.0 following this section.
+          That is NOT TRUE. It is actually offset by the size of the metadata; meaning 1024 - (64 + num_axes * 8) - 745.
+    """
+
+    def __init__(self, stream: BinaryIO, num_axes: int):
+        # structure lengths are NOT predetermined (why?!) so we read it all and split it up
+        full_data = decode_binary(
+            stream, str, 745, cursor_shift=1024 - (64 + (num_axes * 8)) - 745
+        )  # see docstring
+        fields = full_data.split("\r\n")
+        self.patient_id: str = fields[0].split("\t")[1]
+        self.plan_name: str = fields[1].split("\t")[1]
+        self.sop_instance_uid: str = fields[2].split("\t")[1]
+        self.mu_planned: float = float(fields[3].split("\t")[1])
+        self.mu_remaining: float = float(fields[4].split("\t")[1])
+        self.energy: str = fields[5].split("\t")[1]
+        self.beam_name: str = fields[6].split("\t")[1]
+
+
+class TrajectoryLog(LogBase):
+    """A class for loading and analyzing the data of a Trajectory log.
+
+    Attributes
+    ----------
+    header : `~pylinac.log_analyzer.TrajectoryLogHeader`, which has the following attributes:
+    axis_data : `~pylinac.log_analyzer.TrajectoryLogAxisData`
+    fluence : `~pylinac.log_analyzer.FluenceStruct`
+    subbeams : `~pylinac.log_analyzer.SubbeamManager`
+    """
+
+    ANON_LINE = 0
+
+    def __init__(self, filename: str | BinaryIO, exclude_beam_off: bool = True):
+        super().__init__(filename, exclude_beam_off)
+
+        self._read_txt_file()
+
+        # load from file object
+        if isinstance(filename, (BinaryIO, BufferedReader)):
+            filename.seek(0)
+            self._read_it(filename)
+        # load from disk
+        else:
+            with open(self.filename, mode="rb") as tlogfile:
+                self._read_it(tlogfile)
+
+        self.subbeams.post_hoc_metadata(self.axis_data)
+        if not self.treatment_type == TreatmentType.IMAGING.value:
+            self.fluence = FluenceStruct(
+                self.axis_data.mlc, self.axis_data.mu, self.axis_data.jaws
+            )
+
+    def _read_it(self, tlogfile: BinaryIO):
+        """Read the file object"""
+        self.header = TrajectoryLogHeader(tlogfile)
+        self.subbeams = SubbeamManager(tlogfile, self.header)
+        self.axis_data = TrajectoryLogAxisData(self, tlogfile, self.subbeams)
+
+    @property
+    def txt_filename(self) -> str:
+        """The name of the associated .txt file for the .bin file. The file may or may not be available."""
+        if self.txt is not None:
+            return self.filename.replace(".bin", ".txt")
+
+    def anon_file_renames(self, destination: str, suffix: str) -> dict[str, str]:
+        base_filename = osp.basename(self.filename)
+        anonymous_base_filename = (
+            "Anonymous" + suffix + base_filename[self._underscore_idx :]
+        )
+        anonymous_filename = osp.join(destination, anonymous_base_filename)
+        filenames = {self.filename: anonymous_filename}
+        if self.txt_filename is not None:
+            anonymous_txtfilename = anonymous_filename.replace(".bin", ".txt")
+            filenames[self.txt_filename] = anonymous_txtfilename
+        return filenames
+
+    def anonymize(
+        self,
+        inplace: bool = False,
+        destination: str | None = None,
+        suffix: str | None = None,
+    ) -> list[str]:
+        """Save an anonymized version of the log.
+
+        The patient ID in the filename is replaced with ``Anonymous<suffix>`` for the .bin file. If the
+        associated .txt file is in the same directory it will similarly replace the patient ID in the filename with
+        ``Anonymous<suffix>``. Additionally, the `Patient ID` row will be replaced with ``Patient ID: Anonymous<suffix>``.
+        For v4+ logs, the Patient ID field in the Metadata structure will be replaced with ``Anonymous<suffix>``.
+
+        .. note::
+            Anonymization is only available for logs loaded locally (i.e. not from a URL or a data stream). To
+            anonymize such a log it must be first downloaded or written to a file, then loaded in.
+
+        .. note::
+            Anonymization is done to the log **file** itself. The current instance of ``MachineLog`` will not be anonymized.
+
+        Parameters
+        ----------
+        inplace : bool
+            If False (default), creates an anonymized **copy** of the log(s).
+            If True, **renames and replaces** the content of the log file.
+        destination : str, optional
+            A string specifying the directory where the newly anonymized logs should be placed.
+            If None, will place the logs in the same directory as the originals.
+        suffix : str, optional
+            An optional suffix that is added after ``Anonymous`` to give specificity to the log.
+
+        Returns
+        -------
+        list
+            A list containing the paths to the newly written files.
+        """
+        if suffix is None:
+            suffix = ""
+
+        # determine destination directory
+        if destination is None:
+            dest_dir = osp.dirname(self.filename)
+        else:
+            if not osp.isdir(destination):
+                raise NotADirectoryError(
+                    f"Specified destination `{destination}` was not a valid directory"
+                )
+            dest_dir = destination
+
+        # copy or rename the files, depending on `inplace` parameter
+        anonymous_filenames = self.anon_file_renames(dest_dir, suffix)
+        method = os.rename if inplace else shutil.copy
+        for old_file, new_file in anonymous_filenames.items():
+            method(old_file, new_file)
+
+        # anonymize the .txt file if it exists.
+        # The .txt file is no longer in use so this can likely be removed at some point in the future
+        txt_file = anonymous_filenames.get(self.txt_filename)
+        if txt_file:
+            with open(txt_file, encoding="utf-8") as f:
+                txtdata = f.readlines()
+            txtdata[self.ANON_LINE] = "Patient ID:\tAnonymous_" + suffix + "\n"
+            with open(txt_file, mode="w", encoding="utf-8") as f:
+                f.writelines(txtdata)
+            print(f"Anonymized .txt file written to: {txt_file}")
+
+        # anonymize the .bin file. Only applies to v4+ files as only they contain metadata
+        bin_file = anonymous_filenames[self.filename]
+        if self.header.version < 4:
+            print(
+                f"The log version is <4.0 and thus does not have metadata. No fields to anonymize. A simple copy or rename has been performed to {bin_file}"
+            )
+        else:
+            with open(self.filename, mode="rb") as log_file:
+                # each block listed per the manual
+                header_size = (
+                    16
+                    + 16
+                    + 4
+                    + 4
+                    + 4
+                    + (4 * self.header.num_axes)
+                    + (4 * self.header.num_axes)
+                    + 4
+                    + 4
+                    + 4
+                    + 4
+                    + 4
+                )
+                header_data = log_file.read(header_size)
+                metadata = decode_binary(log_file, str, 745, strip_empty=False)
+                fields = metadata.split("\r\n")
+                fields[0] = fields[0].split("\t")[0] + "\tAnonymous" + suffix
+                anon_metadata = bytes("\r\n".join(fields).encode("ascii"))
+                rest_of_data = log_file.read()
+
+            with open(bin_file, mode="wb") as new_log_file:
+                new_log_file.write(header_data)
+                new_log_file.write(anon_metadata)
+                new_log_file.write(rest_of_data)
+            print(f"The anonymized .bin file has been written to {bin_file}")
+        return list(anonymous_filenames.values())
+
+    def _read_txt_file(self) -> None:
+        """Read a Tlog's associated .txt file and put in under the 'txt' attribute."""
+        self.txt = None
+        if ".bin" in str(
+            self.filename
+        ):  # files downloaded via URL may not have .bin ending
+            txt_filename = str(self.filename).replace(".bin", ".txt")
+            if osp.isfile(txt_filename):
+                self.txt = {}
+                with open(txt_filename, encoding="utf-8") as txtfile:
+                    txtdata = txtfile.readlines()
+                for line in txtdata:
+                    items = line.split(":")
+                    if len(items) == 2:
+                        self.txt[items[0].strip()] = items[1].strip()
+
+    @classmethod
+    def from_demo(cls, exclude_beam_off: bool = True):
+        """Load and instantiate from the demo trajetory log file included with the package."""
+        demo_file = io.retrieve_demo_file(name="Tlog.bin")
+        return cls(demo_file, exclude_beam_off)
+
+    @staticmethod
+    def run_demo():
+        """Run the Trajectory log demo."""
+        tlog = TrajectoryLog.from_demo()
+        tlog.report_basic_parameters()
+        tlog.plot_summary()
+
+    def to_csv(self, filename: str | None = None) -> str:
+        """Write the log to a CSV file.
+
+        Parameters
+        ----------
+        filename : None, str
+            If None (default), the CSV filename will be the same as the filename of the log.
+            If a string, the filename will be named so.
+
+        Returns
+        -------
+        str
+            The full filename of the newly created CSV file.
+        """
+        if filename is None:
+            filename = self.filename.replace("bin", "csv")
+        elif not filename.endswith(".csv"):
+            filename += ".csv"
+
+        csv_file = open(filename, mode="w", encoding="utf-8")
+        writer = csv.writer(csv_file, lineterminator="\n")
+        # write header info
+        header_titles = (
+            "Tlog File:",
+            "Signature:",
+            "Version:",
+            "Header Size:",
+            "Sampling Inteval:",
+            "Number of Axes:",
+            "Axis Enumeration:",
+            "Samples per Axis:",
+            "Axis Scale:",
+            "Number of Subbeams:",
+            "Is Truncated?",
+            "Number of Snapshots:",
+            "MLC Model:",
+        )
+        h = self.header
+        header_values = (
+            self.filename,
+            h.header,
+            h.version,
+            h.header_size,
+            h.sampling_interval,
+            h.num_axes,
+            h.axis_enum,
+            h.samples_per_axis,
+            h.axis_scale,
+            h.num_subbeams,
+            h.is_truncated,
+            h.num_snapshots,
+            h.mlc_model,
+        )
+        for title, value in zip(header_titles, header_values):
+            write_single_value(writer, title, value)
+
+        # write axis data
+        data_titles = (
+            "Gantry",
+            "Collimator",
+            "Jaws X1",
+            "Jaws X2",
+            "Jaws Y1",
+            "Jaws Y2",
+            "Couch Lat",
+            "Couch Lng",
+            "Couch Vert",
+            "Couch Rtn",
+            "Couch Pitch",
+            "Couch Roll",
+            "MU",
+            "Beam Hold",
+            "Control Point",
+            "Carriage A",
+            "Carriage B",
+        )
+        ad = self.axis_data
+        data_values = (
+            ad.gantry,
+            ad.collimator,
+            ad.jaws.x1,
+            ad.jaws.x2,
+            ad.jaws.y1,
+            ad.jaws.y2,
+            ad.couch.latl,
+            ad.couch.long,
+            ad.couch.vert,
+            ad.couch.rotn,
+            ad.couch.pitch,
+            ad.couch.roll,
+            ad.mu,
+            ad.beam_hold,
+            ad.control_point,
+            ad.carriage_A,
+            ad.carriage_B,
+        )
+        data_units = (
+            "degrees",
+            "degrees",
+            "cm",
+            "cm",
+            "cm",
+            "cm",
+            "cm",
+            "cm",
+            "cm",
+            "degrees",
+            "degrees",
+            "degrees",
+            "MU",
+            None,
+            None,
+            "cm",
+            "cm",
+        )
+        for title, value, unit in zip(data_titles, data_values, data_units):
+            # the value might not exist, such as pitch which is only for 6D couches
+            # thus, check the value exists first
+            if value:
+                write_array(writer, title, value, unit)
+
+        # write leaf data
+        for leaf_num, leaf in self.axis_data.mlc.leaf_axes.items():
+            write_array(writer, "Leaf " + str(leaf_num), leaf, "cm")
+
+        print("CSV file written to: " + filename)
+        return filename
+
+    def publish_pdf(
+        self,
+        filename: str | BinaryIO,
+        metadata: dict = None,
+        notes: str | list = None,
+        open_file: bool = False,
+        logo: Path | str | None = None,
+    ):
+        """Publish (print) a PDF containing the analysis and quantitative results.
+
+        Parameters
+        ----------
+        filename : (str, file-like object}
+            The file to write the results to.
+        notes : str, list of strings
+            Text; if str, prints single line.
+            If list of strings, each list item is printed on its own line.
+        open_file : bool
+            Whether to open the file using the default program after creation.
+        metadata : dict
+            Extra data to be passed and shown in the PDF. The key and value will be shown with a colon.
+            E.g. passing {'Author': 'James', 'Unit': 'TrueBeam'} would result in text in the PDF like:
+            --------------
+            Author: James
+            Unit: TrueBeam
+            --------------
+        logo: Path, str
+            A custom logo to use in the PDF report. If nothing is passed, the default pylinac logo is used.
+        """
+        if self.treatment_type == TreatmentType.IMAGING.value:
+            raise ValueError(
+                "Log is of imaging type (e.g. kV setup) and does not contain relevant gamma/leaf data"
+            )
+        self.fluence.gamma.calc_map()
+        canvas = pdf.PylinacCanvas(
+            filename, page_title="Trajectory Log Analysis", metadata=metadata, logo=logo
+        )
+        canvas.add_text(
+            text=[
+                "Trajectory Log results:",
+                f"Average RMS (mm): {self.axis_data.mlc.get_RMS_avg()*10:2.2f}",
+                f"Max RMS (mm): {self.axis_data.mlc.get_RMS_max()*10:2.2f}",
+                f"95th Percentile error (mm): {self.axis_data.mlc.get_error_percentile(95)*10:2.2f}",
+                f"Number of beam holdoffs: {self.num_beamholds}",
+                f"Gamma pass (%): {self.fluence.gamma.pass_prcnt:2.1f}",
+                f"Gamma average: {self.fluence.gamma.avg_gamma:2.2f}",
+            ],
+            location=(10, 25.5),
+        )
+        for idx, (x, y, graph) in enumerate(
+            zip(
+                (2, 11, 2, 11),
+                (14, 14, 6, 6),
+                (Fluence.ACTUAL, Fluence.EXPECTED, Fluence.GAMMA, ""),
+            )
+        ):
+            data = BytesIO()
+            if graph != "":
+                self.save_subimage(data, graph, fontsize=20)
+            else:
+                self.save_subgraph(data, Graph.GAMMA, fontsize=20, labelsize=12)
+            canvas.add_image(data, location=(x, y), dimensions=(9, 9))
+        if notes is not None:
+            canvas.add_text(location=(1, 5.5), font_size=14, text="Notes:")
+            canvas.add_text(location=(1, 5), text=notes)
+        canvas.add_new_page()
+        for idx, (x, y, graph) in enumerate(
+            zip((5, 5), (13, 2), (Graph.HISTOGRAM, Graph.RMS))
+        ):
+            data = BytesIO()
+            self.save_subgraph(data, graph, fontsize=20, labelsize=12)
+            canvas.add_image(location=(x, y), dimensions=(13, 13), image_data=data)
+        canvas.finish()
+
+        if open_file:
+            webbrowser.open(filename)
+
+    @property
+    def num_beamholds(self) -> int:
+        """Return the number of times the beam was held."""
+        diffmatrix = np.diff(self.axis_data.beam_hold.actual)
+        num_holds = int(np.sum(diffmatrix > 0))
+        return num_holds
+
+    @property
+    def is_hdmlc(self) -> bool:
+        """Whether the machine has an HDMLC or not."""
+        return self.header.mlc_model == 3
+
+
+def anonymize(
+    source: str, inplace: bool = False, destination: bool = None, recursive: bool = True
+):
+    """Quickly anonymize an individual log or directory of logs.
+    For directories, threaded execution is performed, making this much faster (10-20x) than loading a ``MachineLogs``
+    instance of the folder and using the ``.anonymize()`` method.
+
+    .. note::
+        Because ``MachineLog`` instances are not overly memory-efficient, you *may* run into ``MemoryError`` issues.
+        To avoid this, try not to anonymize more than ~3000 logs at once.
+
+    Parameters
+    ----------
+    source : str
+        Points to a local log file (e.g. .dlg or .bin file) or to a directory containing log files.
+    inplace : bool
+        Whether to edit the file itself, or created an anonymized copy and leave the original.
+    destination : str, None
+        Where the put the anonymized logs. Must point to an existing directory. If None, will place the logs in their original location.
+    recursive : bool
+        Whether to recursively enter sub-directories below the root source folder.
+    """
+
+    def _anonymize(filepath, inplace, destination):
+        """Function to anonymize logs; used in the thread executor."""
+        if is_tlog(filepath) or (
+            is_dlog(filepath) and osp.basename(filepath).startswith("A")
+        ):
+            log = load_log(filepath)
+            log.anonymize(inplace=inplace, destination=destination)
+
+    # if a single file, just anonymize it
+    if osp.isfile(source):
+        log = load_log(source)
+        log.anonymize(inplace=inplace, destination=destination)
+    # if a dir, start a threaded executor and walk the folder.
+    elif osp.isdir(source):
+        futures = []
+        with concurrent.futures.ThreadPoolExecutor(
+            max_workers=multiprocessing.cpu_count() * 8
+        ) as exec:
+            for pdir, sdir, files in os.walk(source):
+                for file in files:
+                    filepath = osp.join(pdir, file)
+                    future = exec.submit(_anonymize, filepath, inplace, destination)
+                    futures.append(future)
+                if not recursive:
+                    break
+            concurrent.futures.wait(futures)
+        print(f"All logs in {source} have been anonymized.")
+    else:
+        raise NotALogError(f"{source} is not a log file or directory.")
+
+
+def load_log(
+    file_or_dir: str, exclude_beam_off: bool = True, recursive: bool = True
+) -> TrajectoryLog | Dynalog | MachineLogs:
+    """Load a log file or directory of logs, either dynalogs or Trajectory logs.
+
+    Parameters
+    ----------
+    file_or_dir : str
+        String pointing to a single log file or a directory that contains log files.
+    exclude_beam_off : bool
+        Whether to include snapshots where the beam was off.
+    recursive : bool
+        Whether to recursively search a directory. Irrelevant for single log files.
+
+    Returns
+    -------
+    One of :class:`~pylinac.log_analyzer.Dynalog`, :class:`~pylinac.log_analyzer.TrajectoryLog`,
+        :class:`~pylinac.log_analyzer.MachineLogs`.
+    """
+    if io.is_url(file_or_dir):
+        file_or_dir = io.get_url(file_or_dir)
+    if osp.isfile(file_or_dir):
+        if zipfile.is_zipfile(file_or_dir):
+            return MachineLogs.from_zip(file_or_dir)
+        if not is_log(file_or_dir):
+            raise NotALogError("Not a valid log")
+        elif is_tlog(file_or_dir):
+            return TrajectoryLog(file_or_dir, exclude_beam_off)
+        else:
+            return Dynalog(file_or_dir, exclude_beam_off)
+    elif osp.isdir(file_or_dir):
+        return MachineLogs(file_or_dir, recursive)
+    else:
+        raise NotALogError(
+            f"'{file_or_dir}' did not point to a valid file, directory, or ZIP archive"
+        )
+
+
+def is_log(filename: str) -> bool:
+    """Boolean specifying if filename is a valid log file."""
+    return is_tlog(filename) or is_dlog(filename)
+
+
+def is_tlog(filename: str) -> bool:
+    """Boolean specifying if filename is a Trajectory log file."""
+    return _is_log(filename, ("VOSTL",))
+
+
+def is_dlog(filename: str) -> bool:
+    """Boolean specifying if filename is a Dynalog file."""
+    return _is_log(filename, ("B", "A"))
+
+
+def _is_log(filename: str, keys: Sequence[str]) -> bool:
+    """Internal function that determines whether a file is a log.
+
+    Parameters
+    ----------
+    filename : str
+    keys : iterable of strings
+        An iterable of strings that should be in the file. If any key
+        is in the file it will return true.
+    """
+    if isinstance(filename, (BytesIO, BufferedReader)):
+        header_sample = filename.read(5).decode()
+        return any(key in header_sample for key in keys)
+    elif osp.isfile(filename):
+        try:
+            with open(filename, mode="rb") as f:
+                header_sample = f.read(5).decode()
+            return any(key in header_sample for key in keys)
+        except Exception:
+            return False
+    else:
+        return False
+
+
+def write_single_value(writer, description, value, unit=None):
+    writer.writerow([description, str(value), unit])
+
+
+def write_array(writer, description, value, unit=None):
+    # write expected
+    for dtype, attr in zip((" Expected", " Actual"), ("expected", "actual")):
+        if unit is None:
+            dtype_desc = description + dtype
+        else:
+            dtype_desc = description + dtype + " in units of " + unit
+        arr2write = np.insert(getattr(value, attr).astype(object), 0, dtype_desc)
+        writer.writerow(arr2write)
+
+
+def _get_log_filenames(directory: str, recursive: bool = True) -> list:
+    """Extract the names of real log files from a directory."""
+    tlogs = io.retrieve_filenames(directory, is_tlog, recursive=recursive)
+    dlogs = io.retrieve_filenames(directory, is_dlog, recursive=recursive)
+    # drop double-counted dynalogs (both A & B files; just need one of two)
+    idx = 0
+    while idx < len(dlogs):
+        opp_file = Dynalog.identify_other_file(dlogs[idx], raise_find_error=False)
+        if opp_file in dlogs:
+            del dlogs[dlogs.index(opp_file)]
+        else:
+            del dlogs[idx]
+            idx -= 1
+        idx += 1
+    return tlogs + dlogs
+
+
+def _get_axis(snapshot_data, column, axis_type):
+    """Return column of data from snapshot data of the axis type passed.
+
+    Parameters
+    ----------
+    snapshot_data : numpy.ndarray
+        The data read in holding the axis data of the log.
+    column : int
+        The column of the desired data in snapshot_data
+    axis_type : subclass of Axis
+        The type of axis the data is.
+
+    Returns
+    -------
+    axis_type
+    """
+    return axis_type(
+        expected=snapshot_data[:, column], actual=snapshot_data[:, column + 1]
+    )
+
+
+class NotALogError(IOError):
+    """Machine log error. Indicates that the passed file is not a valid machine log file."""
+
+    pass
+
+
+class NotADynalogError(IOError):
+    """Dynalog error. Indicates that the passed file is not a valid dynalog file."""
+
+    pass
+
+
+class DynalogMatchError(IOError):
+    """Dynalog error. Indicates that the associated file of the dynalog passed in
+    (A file if B passed in & vic versa) cannot be found. Ensure associated file is in the same folder
+    and has the same name as the passed file, except the first letter."""
+
+    pass
```

### Comparing `manteia_qa_pylinac-1.0.0/pylinac/metrics/features.py` & `manteia_qa_pylinac-1.1.0/pylinac/metrics/features.py`

 * *Ordering differences only*

 * *Files 12% similar despite different names*

```diff
@@ -1,101 +1,101 @@
-from __future__ import annotations
-
-import numpy as np
-from skimage.measure._regionprops import RegionProperties
-
-
-def is_symmetric(region: RegionProperties, *args, **kwargs) -> bool:
-    """Whether the binary object's dimensions are symmetric, i.e. a perfect circle. Used to find the BB."""
-    ymin, xmin, ymax, xmax = region.bbox
-    y = abs(ymax - ymin)
-    x = abs(xmax - xmin)
-    if x > max(y * 1.05, y + 3) or x < min(y * 0.95, y - 3):
-        return False
-    return True
-
-
-def is_near_center(region: RegionProperties, *args, **kwargs) -> bool:
-    """Whether the bb is <2cm from the center of the field"""
-    dpmm = kwargs["dpmm"]
-    shape = kwargs["shape"]
-    extent_limit_mm = 20
-    bottom, left, top, right = region.bbox
-    bb_center_x = left + (right - left) / 2
-    bb_center_y = bottom + (top - bottom) / 2
-    x_lo_limit = shape[1] / 2 - dpmm * extent_limit_mm
-    x_hi_limit = shape[1] / 2 + dpmm * extent_limit_mm
-    is_bb_x_centered = x_lo_limit < bb_center_x < x_hi_limit
-    y_lo_limit = shape[0] / 2 - dpmm * extent_limit_mm
-    y_hi_limit = shape[0] / 2 + dpmm * extent_limit_mm
-    is_bb_y_centered = y_lo_limit < bb_center_y < y_hi_limit
-    return is_bb_x_centered and is_bb_y_centered
-
-
-def is_right_size_bb(region: RegionProperties, *args, **kwargs) -> bool:
-    """Decide whether the ROI is roughly the size of a BB; not noise and not an artifact. Used to find the BB."""
-    bb_area = region.area_filled / (kwargs["dpmm"] ** 2)
-    bb_size = kwargs["bb_size"]  # radius in mm
-    tolerance = kwargs["tolerance"]  # radius tolerance in mm
-    # A = pi * r^2
-    larger_bb_area = np.pi * (bb_size + tolerance) ** 2
-    smaller_bb_area = max(
-        (np.pi * (bb_size - tolerance) ** 2, 2)
-    )  # set a min of 2 to avoid a lower bound of 0 when radius<=2. Having a small lower bound is much more likely to find noise in a block.
-    # this is actually really important. A lower bound of 1 will catch SIGNIFICANT noise and produce erroneous results.
-    return smaller_bb_area < bb_area < larger_bb_area
-
-
-def is_solid(region: RegionProperties, *args, **kwargs) -> bool:
-    """Whether the ROI is spiculated. We want nice, round ROIs,
-    and this will drop such ROIs. Generally, these spiculations are noise or a BB rod.
-    """
-    return region.solidity > 0.9
-
-
-def is_round(region: RegionProperties, *args, **kwargs) -> bool:
-    """Decide if the ROI is circular in nature by testing the filled area vs bounding box. Used to find the BB."""
-    expected_fill_ratio = np.pi / 4  # area of a circle inside a square
-    actual_fill_ratio = region.filled_area / region.bbox_area
-    return expected_fill_ratio * 1.2 > actual_fill_ratio > expected_fill_ratio * 0.8
-
-
-def is_right_circumference(region: RegionProperties, *args, **kwargs) -> bool:
-    """Test the regionprop's perimeter attr to see if it matches
-    that of an equivalent circle"""
-    upper_circumference = 2 * np.pi * (kwargs["bb_size"] + kwargs["tolerance"])
-    lower_circumference = 2 * np.pi * (kwargs["bb_size"] - kwargs["tolerance"])
-    actual_perimeter = region.perimeter / kwargs["dpmm"]
-    return upper_circumference > actual_perimeter > lower_circumference
-
-
-def is_right_square_perimeter(region: RegionProperties, *args, **kwargs) -> bool:
-    """Test the regionprop's perimeter attr to see if it matches
-    that of an equivalent square. In reality, edges aren't perfectly straight, so
-    the real perimeter is always going to be higher than the theoretical perimeter.
-    We thus add a larger tolerance (20%) to the upper perimeter"""
-    actual_perimeter = region.perimeter / kwargs["dpmm"]
-    upper_perimeter = 1.20 * 2 * (
-        kwargs["field_width_mm"] + kwargs["field_tolerance_mm"]
-    ) + 2 * (kwargs["field_height_mm"] + kwargs["field_tolerance_mm"])
-    lower_perimeter = 2 * (
-        kwargs["field_width_mm"] - kwargs["field_tolerance_mm"]
-    ) + 2 * (kwargs["field_height_mm"] - kwargs["field_tolerance_mm"])
-    return upper_perimeter > actual_perimeter > lower_perimeter
-
-
-def is_square(region: RegionProperties, *args, **kwargs) -> bool:
-    """Decide if the ROI is square in nature by testing the filled area vs bounding box. Used to find the BB."""
-    actual_fill_ratio = region.filled_area / region.bbox_area
-    return actual_fill_ratio > 0.8
-
-
-def is_right_area_square(region: RegionProperties, *args, **kwargs) -> bool:
-    """Decide if the ROI is square in nature by testing the filled area vs bounding box. Used to find the BB."""
-    field_area = region.area_filled / (kwargs["dpmm"] ** 2)
-    low_bound_expected_area = (
-        kwargs["field_width_mm"] - kwargs["field_tolerance_mm"]
-    ) * (kwargs["field_height_mm"] - kwargs["field_tolerance_mm"])
-    high_bound_expected_area = (
-        kwargs["field_width_mm"] + kwargs["field_tolerance_mm"]
-    ) * (kwargs["field_height_mm"] + kwargs["field_tolerance_mm"])
-    return low_bound_expected_area < field_area < high_bound_expected_area
+from __future__ import annotations
+
+import numpy as np
+from skimage.measure._regionprops import RegionProperties
+
+
+def is_symmetric(region: RegionProperties, *args, **kwargs) -> bool:
+    """Whether the binary object's dimensions are symmetric, i.e. a perfect circle. Used to find the BB."""
+    ymin, xmin, ymax, xmax = region.bbox
+    y = abs(ymax - ymin)
+    x = abs(xmax - xmin)
+    if x > max(y * 1.05, y + 3) or x < min(y * 0.95, y - 3):
+        return False
+    return True
+
+
+def is_near_center(region: RegionProperties, *args, **kwargs) -> bool:
+    """Whether the bb is <2cm from the center of the field"""
+    dpmm = kwargs["dpmm"]
+    shape = kwargs["shape"]
+    extent_limit_mm = 20
+    bottom, left, top, right = region.bbox
+    bb_center_x = left + (right - left) / 2
+    bb_center_y = bottom + (top - bottom) / 2
+    x_lo_limit = shape[1] / 2 - dpmm * extent_limit_mm
+    x_hi_limit = shape[1] / 2 + dpmm * extent_limit_mm
+    is_bb_x_centered = x_lo_limit < bb_center_x < x_hi_limit
+    y_lo_limit = shape[0] / 2 - dpmm * extent_limit_mm
+    y_hi_limit = shape[0] / 2 + dpmm * extent_limit_mm
+    is_bb_y_centered = y_lo_limit < bb_center_y < y_hi_limit
+    return is_bb_x_centered and is_bb_y_centered
+
+
+def is_right_size_bb(region: RegionProperties, *args, **kwargs) -> bool:
+    """Decide whether the ROI is roughly the size of a BB; not noise and not an artifact. Used to find the BB."""
+    bb_area = region.area_filled / (kwargs["dpmm"] ** 2)
+    bb_size = kwargs["bb_size"]  # radius in mm
+    tolerance = kwargs["tolerance"]  # radius tolerance in mm
+    # A = pi * r^2
+    larger_bb_area = np.pi * (bb_size + tolerance) ** 2
+    smaller_bb_area = max(
+        (np.pi * (bb_size - tolerance) ** 2, 2)
+    )  # set a min of 2 to avoid a lower bound of 0 when radius<=2. Having a small lower bound is much more likely to find noise in a block.
+    # this is actually really important. A lower bound of 1 will catch SIGNIFICANT noise and produce erroneous results.
+    return smaller_bb_area < bb_area < larger_bb_area
+
+
+def is_solid(region: RegionProperties, *args, **kwargs) -> bool:
+    """Whether the ROI is spiculated. We want nice, round ROIs,
+    and this will drop such ROIs. Generally, these spiculations are noise or a BB rod.
+    """
+    return region.solidity > 0.9
+
+
+def is_round(region: RegionProperties, *args, **kwargs) -> bool:
+    """Decide if the ROI is circular in nature by testing the filled area vs bounding box. Used to find the BB."""
+    expected_fill_ratio = np.pi / 4  # area of a circle inside a square
+    actual_fill_ratio = region.filled_area / region.bbox_area
+    return expected_fill_ratio * 1.2 > actual_fill_ratio > expected_fill_ratio * 0.8
+
+
+def is_right_circumference(region: RegionProperties, *args, **kwargs) -> bool:
+    """Test the regionprop's perimeter attr to see if it matches
+    that of an equivalent circle"""
+    upper_circumference = 2 * np.pi * (kwargs["bb_size"] + kwargs["tolerance"])
+    lower_circumference = 2 * np.pi * (kwargs["bb_size"] - kwargs["tolerance"])
+    actual_perimeter = region.perimeter / kwargs["dpmm"]
+    return upper_circumference > actual_perimeter > lower_circumference
+
+
+def is_right_square_perimeter(region: RegionProperties, *args, **kwargs) -> bool:
+    """Test the regionprop's perimeter attr to see if it matches
+    that of an equivalent square. In reality, edges aren't perfectly straight, so
+    the real perimeter is always going to be higher than the theoretical perimeter.
+    We thus add a larger tolerance (20%) to the upper perimeter"""
+    actual_perimeter = region.perimeter / kwargs["dpmm"]
+    upper_perimeter = 1.20 * 2 * (
+        kwargs["field_width_mm"] + kwargs["field_tolerance_mm"]
+    ) + 2 * (kwargs["field_height_mm"] + kwargs["field_tolerance_mm"])
+    lower_perimeter = 2 * (
+        kwargs["field_width_mm"] - kwargs["field_tolerance_mm"]
+    ) + 2 * (kwargs["field_height_mm"] - kwargs["field_tolerance_mm"])
+    return upper_perimeter > actual_perimeter > lower_perimeter
+
+
+def is_square(region: RegionProperties, *args, **kwargs) -> bool:
+    """Decide if the ROI is square in nature by testing the filled area vs bounding box. Used to find the BB."""
+    actual_fill_ratio = region.filled_area / region.bbox_area
+    return actual_fill_ratio > 0.8
+
+
+def is_right_area_square(region: RegionProperties, *args, **kwargs) -> bool:
+    """Decide if the ROI is square in nature by testing the filled area vs bounding box. Used to find the BB."""
+    field_area = region.area_filled / (kwargs["dpmm"] ** 2)
+    low_bound_expected_area = (
+        kwargs["field_width_mm"] - kwargs["field_tolerance_mm"]
+    ) * (kwargs["field_height_mm"] - kwargs["field_tolerance_mm"])
+    high_bound_expected_area = (
+        kwargs["field_width_mm"] + kwargs["field_tolerance_mm"]
+    ) * (kwargs["field_height_mm"] + kwargs["field_tolerance_mm"])
+    return low_bound_expected_area < field_area < high_bound_expected_area
```

### Comparing `manteia_qa_pylinac-1.0.0/pylinac/metrics/image.py` & `manteia_qa_pylinac-1.1.0/pylinac/metrics/image.py`

 * *Files 23% similar despite different names*

```diff
@@ -1,713 +1,722 @@
-from __future__ import annotations
-
-import math
-import typing
-from abc import ABC, abstractmethod
-from typing import Any, Callable
-
-import numpy as np
-from matplotlib import pyplot as plt
-from skimage import measure, segmentation
-from skimage.measure._regionprops import RegionProperties
-
-from ..core.array_utils import invert, stretch
-from ..core.geometry import Point
-from ..metrics.features import (
-    is_right_area_square,
-    is_right_circumference,
-    is_right_size_bb,
-    is_right_square_perimeter,
-    is_round,
-    is_solid,
-    is_symmetric,
-)
-from ..metrics.utils import deduplicate_points_and_boundaries, get_boundary
-
-if typing.TYPE_CHECKING:
-    from ..core.image import BaseImage
-
-
-class MetricBase(ABC):
-    """Base class for any 2D metric. This class is abstract and should not be instantiated.
-
-    The subclass should implement the ``calculate`` method and the ``name`` attribute.
-
-    As a best practice, the ``image_compatibility`` attribute should be set to a list of image classes that the metric
-    is compatible with. Image types that are not in the list will raise an error. This allows
-    compatibility to be explicit. However, by default this is None and no compatibility checking is done.
-    """
-
-    unit: str = ""
-    image: BaseImage
-    image_compatibility: list[BaseImage] | None = None
-    name: str
-
-    def inject_image(self, image: BaseImage):
-        """Inject the image into the metric."""
-        if self.image_compatibility is not None and not isinstance(
-            image, self.image_compatibility
-        ):
-            raise TypeError(f"Image must be one of {self.image_compatibility}")
-        self.image = image
-
-    def context_calculate(self) -> Any:
-        """Calculate the metric. This also checks the image hash to attempt to ensure no changes were made."""
-        img_hash = hash(self.image.array.tobytes())
-        calculation = self.calculate()
-        # check no modifications
-        if hash(self.image.array.tobytes()) != img_hash:
-            raise RuntimeError(
-                "A metric modified an image. This is not allowed as this could affect other, downstream metrics. Change"
-                "the calculate method to not modify the underlying image."
-            )
-        return calculation
-
-    @abstractmethod
-    def calculate(self) -> Any:
-        """Calculate the metric. Can return anything"""
-        pass
-
-    def plot(self, axis: plt.Axes, **kwargs) -> None:
-        """Plot the metric"""
-        pass
-
-    def additional_plots(self) -> list[plt.figure]:
-        """Plot additional information on a separate figure as needed.
-
-        This should NOT show the figure. The figure will be shown
-        via the ``metric_plots`` method. Calling show here would
-        block other metrics from plotting their own separate metrics.
-        """
-        pass
-
-
-class GlobalSizedDiskLocator(MetricBase):
-    name: str
-    points: list[Point]
-    y_boundaries: list[np.ndarray]
-    x_boundaries: list[np.ndarray]
-
-    def __init__(
-        self,
-        radius_mm: float,
-        radius_tolerance_mm: float,
-        detection_conditions: list[Callable[[RegionProperties, ...], bool]] = (
-            is_round,
-            is_right_size_bb,
-            is_right_circumference,
-        ),
-        min_number: int = 1,
-        max_number: int | None = None,
-        min_separation_mm: float = 5,
-        name="Global Disk Locator",
-    ):
-        """Finds BBs globally within an image.
-
-        Parameters
-        ----------
-        radius_mm : float
-            The radius of the BB in mm.
-        radius_tolerance_mm : float
-            The tolerance of the BB radius in mm.
-        detection_conditions : list[callable]
-            A list of functions that take a regionprops object and return a boolean.
-            The functions should be used to determine whether the regionprops object
-            is a BB.
-        min_number : int
-            The minimum number of BBs to find. If not found, an error is raised.
-        max_number : int, None
-            The maximum number of BBs to find. If None, no maximum is set.
-        min_separation_mm : float
-            The minimum distance between BBs in mm. If BBs are found that are closer than this,
-            they are deduplicated.
-        name : str
-            The name of the metric.
-        """
-        self.radius = radius_mm
-        self.radius_tolerance = radius_tolerance_mm
-        self.detection_conditions = detection_conditions
-        self.name = name
-        self.min_number = min_number
-        self.max_number = max_number or 1e3
-        self.min_separation_mm = min_separation_mm
-
-    def _calculate_sample(
-        self, sample: np.ndarray, top_offset: int, left_offset: int
-    ) -> (list[Point], list[np.ndarray], list[RegionProperties]):
-        """Find up to N BBs/disks in the image. This will look for BBs at every percentile range.
-        Multiple BBs may be found at different threshold levels."""
-
-        # The implementation difference here from the original isn't large,
-        # But we need to detect MULTIPLE bbs instead of just one.
-        bbs = []
-        boundaries = []
-        detected_regions = {}
-        # uses the same algo as original WL; this is better than a percentile method as the percentile method
-        # can often be thrown off at the very ends of the distribution. It's more linear and faster to use the simple
-        # spread of min/max.
-        sample = stretch(sample, min=0, max=1)
-        imin, imax = sample.min(), sample.max()
-        spread = imax - imin
-        step_size = (
-            spread / 50
-        )  # move in 1/50 increments; maximum of 50 passes per image
-        cutoff = (
-            imin + step_size
-        )  # start at the min + 1 step; we know the min cutoff will be a blank, full image
-        while cutoff <= imax and len(bbs) < self.max_number:
-            try:
-                binary_array = sample > cutoff
-                labeled_arr = measure.label(binary_array, connectivity=1)
-                regions = measure.regionprops(labeled_arr, intensity_image=sample)
-                detected_regions = {i: r for i, r in enumerate(regions)}
-                for condition in self.detection_conditions:
-                    to_pop = []
-                    for key, region in sorted(
-                        detected_regions.items(),
-                        key=lambda item: item[1].filled_area,
-                        reverse=True,
-                    ):
-                        if not condition(
-                            region,
-                            dpmm=self.image.dpmm,
-                            bb_size=self.radius,
-                            tolerance=self.radius_tolerance,
-                            shape=binary_array.shape,
-                        ):
-                            to_pop.append(key)
-                    detected_regions = {
-                        key: region
-                        for key, region in detected_regions.items()
-                        if key not in to_pop
-                    }
-                if len(detected_regions) == 0:
-                    raise ValueError
-                else:
-                    points = [
-                        Point(region.weighted_centroid[1], region.weighted_centroid[0])
-                        for region in detected_regions.values()
-                    ]
-                    new_boundaries = [
-                        get_boundary(
-                            detected_region,
-                            top_offset=top_offset,
-                            left_offset=left_offset,
-                        )
-                        for detected_region in detected_regions.values()
-                    ]
-                    bbs, boundaries = deduplicate_points_and_boundaries(
-                        original_points=bbs,
-                        new_points=points,
-                        min_separation_px=self.min_separation_mm * self.image.dpmm,
-                        original_boundaries=boundaries,
-                        new_boundaries=new_boundaries,
-                    )
-            except (IndexError, ValueError):
-                pass
-            finally:
-                cutoff += step_size
-        if len(bbs) < self.min_number:
-            # didn't find the number we needed
-            raise ValueError(
-                f"Couldn't find the minimum number of disks in the image. Found {len(bbs)}; required: {self.min_number}"
-            )
-        return bbs, boundaries, list(detected_regions.values())
-
-    def calculate(self) -> list[Point]:
-        """Find up to N BBs/disks in the image. This will look for BBs at every percentile range.
-        Multiple BBs may be found at different threshold levels."""
-        sample = invert(self.image.array)
-        self.points, boundaries, _ = self._calculate_sample(
-            sample, top_offset=0, left_offset=0
-        )
-        self.y_boundaries = []
-        self.x_boundaries = []
-        for boundary in boundaries:
-            boundary_y, boundary_x = np.nonzero(boundary)
-            self.y_boundaries.append(boundary_y)
-            self.x_boundaries.append(boundary_x)
-        return self.points
-
-    def plot(
-        self,
-        axis: plt.Axes,
-        show_boundaries: bool = True,
-        color: str = "red",
-        markersize: float = 3,
-        alpha: float = 0.25,
-    ) -> None:
-        """Plot the BB centers"""
-        for point in self.points:
-            axis.plot(point.x, point.y, "o", color=color)
-        if show_boundaries:
-            for boundary_y, boundary_x in zip(self.y_boundaries, self.x_boundaries):
-                axis.scatter(
-                    boundary_x,
-                    boundary_y,
-                    c=color,
-                    marker="s",
-                    alpha=alpha,
-                    s=markersize,
-                )
-
-
-class SizedDiskRegion(GlobalSizedDiskLocator):
-    """A metric to find a disk/BB in an image where the BB is near an expected position and size.
-    This will calculate the scikit-image regionprops of the BB."""
-
-    x_offset: float
-    y_offset: float
-    is_from_physical: bool
-    is_from_center: bool
-    max_number = 1
-    min_number = 1
-    min_separation_mm = 1e4
-
-    def __init__(
-        self,
-        expected_position: Point | tuple[float, float],
-        search_window: tuple[float, float],
-        radius: float,
-        radius_tolerance: float,
-        detection_conditions: list[Callable[[RegionProperties, ...], bool]] = (
-            is_right_size_bb,
-            is_round,
-            is_right_circumference,
-            is_symmetric,
-            is_solid,
-        ),
-        invert: bool = True,
-        name: str = "Disk Region",
-    ):
-        # purposely avoid super call as parent defaults to mm. We set the values ourselves.
-        self.expected_position = Point(expected_position)
-        self.radius = radius
-        self.radius_tolerance = radius_tolerance
-        self.search_window = search_window
-        self.detection_conditions = detection_conditions
-        self.name = name
-        self.invert = invert
-        self.is_from_center = False
-        self.is_from_physical = False
-
-    @classmethod
-    def from_physical(
-        cls,
-        expected_position_mm: Point | tuple[float, float],
-        search_window_mm: tuple[float, float],
-        radius_mm: float,
-        radius_tolerance_mm: float,
-        detection_conditions: list[Callable[[RegionProperties, ...], bool]] = (
-            is_right_size_bb,
-            is_round,
-            is_right_circumference,
-            is_symmetric,
-            is_solid,
-        ),
-        invert: bool = True,
-        name="Disk Region",
-    ):
-        """Create a DiskRegion using physical dimensions."""
-        # We set a flag so we know to convert from physical sizes to pixels later.
-        # We don't have the image/dpmm yet so we can't do it now.
-        instance = cls(
-            expected_position=expected_position_mm,
-            search_window=search_window_mm,
-            radius=radius_mm,
-            radius_tolerance=radius_tolerance_mm,
-            detection_conditions=detection_conditions,
-            name=name,
-            invert=invert,
-        )
-        instance.is_from_physical = True
-        return instance
-
-    @classmethod
-    def from_center(
-        cls,
-        expected_position: Point | tuple[float, float],
-        search_window: tuple[float, float],
-        radius: float,
-        radius_tolerance: float,
-        detection_conditions: list[Callable[[RegionProperties, ...], bool]] = (
-            is_right_size_bb,
-            is_round,
-            is_right_circumference,
-            is_symmetric,
-            is_solid,
-        ),
-        invert: bool = True,
-        name="Disk Region",
-    ):
-        """Create a DiskRegion from a center point."""
-        # We set a flag so we know to convert from image edge to center later.
-        # We don't have the image/dpmm yet so we can't do it now
-        instance = cls(
-            expected_position=expected_position,
-            search_window=search_window,
-            radius=radius,
-            radius_tolerance=radius_tolerance,
-            detection_conditions=detection_conditions,
-            name=name,
-            invert=invert,
-        )
-        instance.is_from_center = True
-        return instance
-
-    @classmethod
-    def from_center_physical(
-        cls,
-        expected_position_mm: Point | tuple[float, float],
-        search_window_mm: tuple[float, float],
-        radius_mm: float,
-        radius_tolerance_mm: float = 0.25,
-        detection_conditions: list[Callable[[RegionProperties, ...], bool]] = (
-            is_right_size_bb,
-            is_round,
-            is_right_circumference,
-            is_symmetric,
-            is_solid,
-        ),
-        invert: bool = True,
-        name="Disk Region",
-    ):
-        """Create a DiskRegion using physical dimensions from the center point."""
-        # We set a flag so we know to convert from physical sizes to pixels later.
-        # We don't have the image/dpmm yet so we can't do it now
-        instance = cls(
-            expected_position=expected_position_mm,
-            search_window=search_window_mm,
-            radius=radius_mm,
-            radius_tolerance=radius_tolerance_mm,
-            detection_conditions=detection_conditions,
-            name=name,
-            invert=invert,
-        )
-        instance.is_from_physical = True
-        instance.is_from_center = True
-        return instance
-
-    def calculate(self) -> RegionProperties:
-        """Find the scikit-image regiongprops of the BB.
-
-        This will apply a high-pass filter to the image iteratively.
-        The filter starts at a very low percentile and increases until
-        a region is found that meets the detection conditions.
-        """
-        if self.is_from_physical:
-            # convert from physical sizes to pixels
-            self.expected_position * self.image.dpmm
-            self.search_window = np.asarray(self.search_window) * self.image.dpmm
-        else:
-            # convert from pixels to physical sizes
-            # I know, it's weird. The functions
-            # for detection historically have expected
-            # sizes in physical dimensions
-            self.radius /= self.image.dpmm
-            self.radius_tolerance /= self.image.dpmm
-        if self.is_from_center:
-            # convert from image edge to center
-            self.expected_position.x += self.image.shape[1] / 2
-            self.expected_position.y += self.image.shape[0] / 2
-        # sample the image in the search window; need to convert to mm
-        left = math.floor(self.expected_position.x - self.search_window[0] / 2)
-        right = math.ceil(self.expected_position.x + self.search_window[0] / 2)
-        top = math.floor(self.expected_position.y - self.search_window[1] / 2)
-        bottom = math.ceil(self.expected_position.y + self.search_window[1] / 2)
-        sample = self.image[top:bottom, left:right]
-        # we might need to invert the image so that the BB pixel intensity is higher than the background
-        if self.invert:
-            sample = invert(sample)
-        points, boundaries, regions = self._calculate_sample(
-            sample, top_offset=top, left_offset=left
-        )
-        self.x_offset = left
-        self.y_offset = top
-        y_boundary, x_boundary = np.nonzero(boundaries[0])
-        self.y_boundaries = [y_boundary]
-        self.x_boundaries = [x_boundary]
-        return regions[0]
-
-    def plot(
-        self,
-        axis: plt.Axes,
-        show_boundaries: bool = True,
-        color: str = "red",
-        markersize: float = 3,
-        alpha: float = 0.25,
-    ) -> None:
-        """Plot the BB center"""
-        if show_boundaries:
-            axis.scatter(
-                self.x_boundaries[0],
-                self.y_boundaries[0],
-                c=color,
-                marker="s",
-                alpha=alpha,
-                s=markersize,
-            )
-
-
-class SizedDiskLocator(SizedDiskRegion):
-    """Calculates the weighted centroid of a disk/BB as a Point in an image where the disk is near an expected position and size."""
-
-    point: Point
-
-    def calculate(self) -> Point:
-        """Get the weighted centroid of the region prop of the BB."""
-        region = super().calculate()
-        self.point = Point(
-            region.weighted_centroid[1] + self.x_offset,
-            region.weighted_centroid[0] + self.y_offset,
-        )
-        return self.point
-
-    def plot(
-        self,
-        axis: plt.Axes,
-        show_boundaries: bool = True,
-        color: str = "red",
-        markersize: float = 3,
-        alpha: float = 0.25,
-    ) -> None:
-        """Plot the BB center"""
-        super().plot(
-            axis,
-            show_boundaries=show_boundaries,
-            color=color,
-            markersize=markersize,
-            alpha=alpha,
-        )
-        axis.plot(self.point.x, self.point.y, "o", color=color, markersize=10)
-
-
-class GlobalSizedFieldLocator(MetricBase):
-    fields: list[Point]
-    boundaries: list[np.ndarray]
-    is_from_physical: bool = False
-
-    def __init__(
-        self,
-        field_width_px: float,
-        field_height_px: float,
-        field_tolerance_px: float,
-        min_number: int = 1,
-        max_number: int | None = None,
-        name: str = "Field Finder",
-        detection_conditions: list[callable] = (
-            is_right_square_perimeter,
-            is_right_area_square,
-        ),
-    ):
-        """Finds fields globally within an image.
-
-        Parameters
-        ----------
-        field_width_px : float
-            The width of the field in px.
-        field_height_px : float
-            The height of the field in px.
-        field_tolerance_px : float
-            The tolerance of the field size in px.
-        min_number : int
-            The minimum number of fields to find. If not found, an error is raised.
-        max_number : int, None
-            The maximum number of fields to find. If None, no maximum is set.
-        name : str
-            The name of the metric.
-        detection_conditions : list[callable]
-            A list of functions that take a regionprops object and return a boolean.
-        """
-        self.field_width_mm = field_width_px
-        self.field_height_mm = field_height_px
-        self.field_tolerance_mm = field_tolerance_px
-        self.min_number = min_number
-        self.max_number = max_number or 1e6
-        self.name = name
-        self.detection_conditions = detection_conditions
-
-    @classmethod
-    def from_physical(
-        cls,
-        field_width_mm: float,
-        field_height_mm: float,
-        field_tolerance_mm: float,
-        min_number: int = 1,
-        max_number: int | None = None,
-        name: str = "Field Finder",
-        detection_conditions: list[callable] = (
-            is_right_square_perimeter,
-            is_right_area_square,
-        ),
-    ):
-        """Construct an instance using physical dimensions.
-
-        Parameters
-        ----------
-        field_width_mm : float
-            The width of the field in mm.
-        field_height_mm : float
-            The height of the field in mm.
-        field_tolerance_mm : float
-            The tolerance of the field size in mm.
-        min_number : int
-            The minimum number of fields to find. If not found, an error is raised.
-        max_number : int, None
-            The maximum number of fields to find. If None, no maximum is set.
-        name : str
-            The name of the metric.
-        detection_conditions : list[callable]
-            A list of functions that take a regionprops object and return a boolean.
-        """
-        instance = cls(
-            field_width_px=field_width_mm,
-            field_height_px=field_height_mm,
-            field_tolerance_px=field_tolerance_mm,
-            min_number=min_number,
-            max_number=max_number,
-            name=name,
-            detection_conditions=detection_conditions,
-        )
-        instance.is_from_physical = True
-        return instance
-
-    def calculate(self) -> list[Point]:
-        """Find up to N fields in the image. This will look for fields at every percentile range.
-        Multiple fields may be found at different threshold levels."""
-        if not self.is_from_physical:
-            self.field_width_mm /= self.image.dpmm
-            self.field_height_mm /= self.image.dpmm
-            self.field_tolerance_mm /= self.image.dpmm
-        fields = []
-        boundaries = []
-        sample = self.image.array
-        # search for multiple BBs by iteratively raising the high-pass threshold value.
-        imin, imax = sample.min(), sample.max()
-        spread = imax - imin
-        step_size = (
-            spread / 50
-        )  # move in 1/50 increments; maximum of 50 passes per image
-        cutoff = imin + step_size * 5  # start at 10% height
-        while cutoff <= imax and len(fields) < self.max_number:
-            try:
-                binary_array = sample > cutoff
-                binary_array = segmentation.clear_border(binary_array, buffer_size=3)
-                labeled_arr = measure.label(binary_array)
-                regions = measure.regionprops(labeled_arr, intensity_image=sample)
-                conditions_met = [
-                    all(
-                        condition(
-                            region,
-                            dpmm=self.image.dpmm,
-                            field_width_mm=self.field_width_mm,
-                            field_height_mm=self.field_height_mm,
-                            field_tolerance_mm=self.field_tolerance_mm,
-                            shape=binary_array.shape,
-                        )
-                        for condition in self.detection_conditions
-                    )
-                    for region in regions
-                ]
-                if not any(conditions_met):
-                    raise ValueError
-                else:
-                    fields_regions = [
-                        regions[idx]
-                        for idx, value in enumerate(conditions_met)
-                        if value
-                    ]
-                    points = [
-                        Point(region.centroid[1], region.centroid[0])
-                        for region in fields_regions
-                    ]
-                    # find the boundaries of the fields
-                    # this is solely for plotting purposes
-                    # these will be bool arrays
-                    # we pad the boundaries to offset the ROI to the right
-                    # position on the image.
-                    new_boundaries = [
-                        get_boundary(region, top_offset=0, left_offset=0)
-                        for region in fields_regions
-                    ]
-                    # the separation is the minimum value + field size
-                    fields, boundaries = deduplicate_points_and_boundaries(
-                        original_points=fields,
-                        new_points=points,
-                        min_separation_px=max(
-                            r.equivalent_diameter_area for r in fields_regions
-                        )
-                        / self.image.dpmm,
-                        original_boundaries=boundaries,
-                        new_boundaries=new_boundaries,
-                    )
-            except (IndexError, ValueError):
-                pass
-            finally:
-                cutoff += step_size
-        if len(fields) < self.min_number:
-            # didn't find the number we needed
-            raise ValueError(
-                f"Couldn't find the minimum number of fields in the image. Found {len(fields)}; required: {self.min_number}"
-            )
-        self.fields = fields
-        self.boundaries = boundaries
-        return fields
-
-    def plot(
-        self,
-        axis: plt.Axes,
-        show_boundaries: bool = True,
-        color: str = "red",
-        markersize: float = 3,
-        alpha: float = 0.25,
-    ) -> None:
-        """Plot the BB centers and boundary of detection."""
-        for point in self.fields:
-            axis.plot(point.x, point.y, color=color, marker="+", alpha=alpha)
-        if show_boundaries:
-            for boundary in self.boundaries:
-                boundary_y, boundary_x = np.nonzero(boundary)
-                axis.scatter(
-                    boundary_x,
-                    boundary_y,
-                    c=color,
-                    marker="s",
-                    alpha=alpha,
-                    s=markersize,
-                )
-
-
-class GlobalFieldLocator(GlobalSizedFieldLocator):
-    def __init__(
-        self,
-        min_number: int = 1,
-        max_number: int | None = None,
-        name: str = "Field Finder",
-        detection_conditions: list[callable] = (
-            is_right_square_perimeter,
-            is_right_area_square,
-        ),
-    ):
-        """Finds fields globally within an image, irrespective of size."""
-        # we override to set the width/height/tolerance to be very large
-        # in this case we are more likely to get noise since the size is unconstrained.
-        super().__init__(
-            field_width_px=1e4,
-            field_height_px=1e4,
-            field_tolerance_px=1e4,
-            min_number=min_number,
-            max_number=max_number,
-            name=name,
-            detection_conditions=detection_conditions,
-        )
-
-    @classmethod
-    def from_physical(
-        cls,
-        *args,
-        **kwargs,
-    ):
-        raise NotImplementedError(
-            "This method is not implemented for global field-finding. Use the "
-            "standard initializer instead."
-        )
+from __future__ import annotations
+
+import math
+import typing
+from abc import ABC, abstractmethod
+from typing import Any, Callable
+
+import numpy as np
+from matplotlib import pyplot as plt
+from skimage import measure, segmentation
+from skimage.measure._regionprops import RegionProperties
+
+from ..core.array_utils import invert
+from ..core.geometry import Point
+from ..metrics.features import (
+    is_right_area_square,
+    is_right_circumference,
+    is_right_size_bb,
+    is_right_square_perimeter,
+    is_round,
+    is_solid,
+    is_symmetric,
+)
+from ..metrics.utils import (
+    deduplicate_points_and_boundaries,
+    find_features,
+    get_boundary,
+)
+
+if typing.TYPE_CHECKING:
+    from ..core.image import BaseImage
+
+
+class MetricBase(ABC):
+    """Base class for any 2D metric. This class is abstract and should not be instantiated.
+
+    The subclass should implement the ``calculate`` method and the ``name`` attribute.
+
+    As a best practice, the ``image_compatibility`` attribute should be set to a list of image classes that the metric
+    is compatible with. Image types that are not in the list will raise an error. This allows
+    compatibility to be explicit. However, by default this is None and no compatibility checking is done.
+    """
+
+    unit: str = ""
+    image: BaseImage
+    image_compatibility: list[BaseImage] | None = None
+    name: str
+
+    def inject_image(self, image: BaseImage):
+        """Inject the image into the metric."""
+        if self.image_compatibility is not None and not isinstance(
+            image, self.image_compatibility
+        ):
+            raise TypeError(f"Image must be one of {self.image_compatibility}")
+        self.image = image
+
+    def context_calculate(self) -> Any:
+        """Calculate the metric. This also checks the image hash to attempt to ensure no changes were made."""
+        img_hash = hash(self.image.array.tobytes())
+        calculation = self.calculate()
+        # check no modifications
+        if hash(self.image.array.tobytes()) != img_hash:
+            raise RuntimeError(
+                "A metric modified an image. This is not allowed as this could affect other, downstream metrics. Change"
+                "the calculate method to not modify the underlying image."
+            )
+        return calculation
+
+    @abstractmethod
+    def calculate(self) -> Any:
+        """Calculate the metric. Can return anything"""
+        pass
+
+    def plot(self, axis: plt.Axes, **kwargs) -> None:
+        """Plot the metric"""
+        pass
+
+    def additional_plots(self) -> list[plt.figure]:
+        """Plot additional information on a separate figure as needed.
+
+        This should NOT show the figure. The figure will be shown
+        via the ``metric_plots`` method. Calling show here would
+        block other metrics from plotting their own separate metrics.
+        """
+        pass
+
+
+class GlobalSizedDiskLocator(MetricBase):
+    name: str
+    points: list[Point]
+    y_boundaries: list[np.ndarray]
+    x_boundaries: list[np.ndarray]
+
+    def __init__(
+        self,
+        radius_mm: float,
+        radius_tolerance_mm: float,
+        detection_conditions: list[Callable[[RegionProperties, ...], bool]] = (
+            is_round,
+            is_right_size_bb,
+            is_right_circumference,
+        ),
+        invert: bool = True,
+        min_number: int = 1,
+        max_number: int | None = None,
+        min_separation_mm: float = 5,
+        name="Global Disk Locator",
+    ):
+        """Finds BBs globally within an image.
+
+        Parameters
+        ----------
+        radius_mm : float
+            The radius of the BB in mm.
+        radius_tolerance_mm : float
+            The tolerance of the BB radius in mm.
+        detection_conditions : list[callable]
+            A list of functions that take a regionprops object and return a boolean.
+            The functions should be used to determine whether the regionprops object
+            is a BB.
+        invert : bool
+            Whether to invert the image before searching for BBs.
+        min_number : int
+            The minimum number of BBs to find. If not found, an error is raised.
+        max_number : int, None
+            The maximum number of BBs to find. If None, no maximum is set.
+        min_separation_mm : float
+            The minimum distance between BBs in mm. If BBs are found that are closer than this,
+            they are deduplicated.
+        name : str
+            The name of the metric.
+        """
+        self.radius = radius_mm
+        self.radius_tolerance = radius_tolerance_mm
+        self.detection_conditions = detection_conditions
+        self.name = name
+        self.invert = invert
+        self.min_number = min_number
+        self.max_number = max_number or 1e3
+        self.min_separation_mm = min_separation_mm
+
+    def calculate(self) -> list[Point]:
+        """Find up to N BBs/disks in the image. This will look for BBs at every percentile range.
+        Multiple BBs may be found at different threshold levels."""
+        if self.invert:
+            sample = invert(self.image.array)
+        else:
+            sample = self.image.array
+        self.points, boundaries, _ = find_features(
+            sample,
+            top_offset=0,
+            left_offset=0,
+            min_number=self.min_number,
+            max_number=self.max_number,
+            dpmm=self.image.dpmm,
+            detection_conditions=self.detection_conditions,
+            radius_mm=self.radius,
+            radius_tolerance_mm=self.radius_tolerance,
+            min_separation_mm=self.min_separation_mm,
+        )
+        self.y_boundaries = []
+        self.x_boundaries = []
+        for boundary in boundaries:
+            boundary_y, boundary_x = np.nonzero(boundary)
+            self.y_boundaries.append(boundary_y)
+            self.x_boundaries.append(boundary_x)
+        return self.points
+
+    def plot(
+        self,
+        axis: plt.Axes,
+        show_boundaries: bool = True,
+        color: str = "red",
+        markersize: float = 3,
+        alpha: float = 0.25,
+    ) -> None:
+        """Plot the BB centers"""
+        for point in self.points:
+            axis.plot(point.x, point.y, "o", color=color)
+        if show_boundaries:
+            for boundary_y, boundary_x in zip(self.y_boundaries, self.x_boundaries):
+                axis.scatter(
+                    boundary_x,
+                    boundary_y,
+                    c=color,
+                    marker="s",
+                    alpha=alpha,
+                    s=markersize,
+                )
+
+
+class SizedDiskRegion(MetricBase):
+    """A metric to find a disk/BB in an image where the BB is near an expected position and size.
+    This will calculate the scikit-image regionprops of the BB."""
+
+    x_offset: float
+    y_offset: float
+    is_from_physical: bool
+    is_from_center: bool
+    max_number: int
+    min_number: int
+    min_separation_mm: float
+    boundaries: list[np.ndarray]
+    points: list[Point]
+
+    def __init__(
+        self,
+        expected_position: Point | tuple[float, float],
+        search_window: tuple[float, float],
+        radius: float,
+        radius_tolerance: float,
+        detection_conditions: list[Callable[[RegionProperties, ...], bool]] = (
+            is_right_size_bb,
+            is_round,
+            is_right_circumference,
+            is_symmetric,
+            is_solid,
+        ),
+        invert: bool = True,
+        name: str = "Disk Region",
+        max_number: int = 1,
+        min_number: int = 1,
+        min_separation_pixels: float = 5,
+    ):
+        # purposely avoid super call as parent defaults to mm. We set the values ourselves.
+        self.expected_position = Point(expected_position)
+        self.radius = radius
+        self.radius_tolerance = radius_tolerance
+        self.search_window = search_window
+        self.detection_conditions = detection_conditions
+        self.name = name
+        self.invert = invert
+        self.is_from_center = False
+        self.is_from_physical = False
+        self.max_number = max_number
+        self.min_number = min_number
+        self.min_separation = min_separation_pixels
+
+    @classmethod
+    def from_physical(
+        cls,
+        expected_position_mm: Point | tuple[float, float],
+        search_window_mm: tuple[float, float],
+        radius_mm: float,
+        radius_tolerance_mm: float,
+        detection_conditions: list[Callable[[RegionProperties, ...], bool]] = (
+            is_right_size_bb,
+            is_round,
+            is_right_circumference,
+            is_symmetric,
+            is_solid,
+        ),
+        invert: bool = True,
+        name="Disk Region",
+        max_number: int = 1,
+        min_number: int = 1,
+        min_separation_mm: float = 5,
+    ):
+        """Create a DiskRegion using physical dimensions."""
+        # We set a flag so we know to convert from physical sizes to pixels later.
+        # We don't have the image/dpmm yet so we can't do it now.
+        instance = cls(
+            expected_position=expected_position_mm,
+            search_window=search_window_mm,
+            radius=radius_mm,
+            radius_tolerance=radius_tolerance_mm,
+            detection_conditions=detection_conditions,
+            name=name,
+            invert=invert,
+            max_number=max_number,
+            min_number=min_number,
+            min_separation_pixels=min_separation_mm,
+        )
+        instance.is_from_physical = True
+        return instance
+
+    @classmethod
+    def from_center(
+        cls,
+        expected_position: Point | tuple[float, float],
+        search_window: tuple[float, float],
+        radius: float,
+        radius_tolerance: float,
+        detection_conditions: list[Callable[[RegionProperties, ...], bool]] = (
+            is_right_size_bb,
+            is_round,
+            is_right_circumference,
+            is_symmetric,
+            is_solid,
+        ),
+        invert: bool = True,
+        name="Disk Region",
+        max_number: int = 1,
+        min_number: int = 1,
+        min_separation_pixels: float = 5,
+    ):
+        """Create a DiskRegion from a center point."""
+        # We set a flag so we know to convert from image edge to center later.
+        # We don't have the image/dpmm yet so we can't do it now
+        instance = cls(
+            expected_position=expected_position,
+            search_window=search_window,
+            radius=radius,
+            radius_tolerance=radius_tolerance,
+            detection_conditions=detection_conditions,
+            name=name,
+            invert=invert,
+            max_number=max_number,
+            min_number=min_number,
+            min_separation_pixels=min_separation_pixels,
+        )
+        instance.is_from_center = True
+        return instance
+
+    @classmethod
+    def from_center_physical(
+        cls,
+        expected_position_mm: Point | tuple[float, float],
+        search_window_mm: tuple[float, float],
+        radius_mm: float,
+        radius_tolerance_mm: float = 0.25,
+        detection_conditions: list[Callable[[RegionProperties, ...], bool]] = (
+            is_right_size_bb,
+            is_round,
+            is_right_circumference,
+            is_symmetric,
+            is_solid,
+        ),
+        invert: bool = True,
+        name="Disk Region",
+        max_number: int = 1,
+        min_number: int = 1,
+        min_separation_mm: float = 5,
+    ):
+        """Create a DiskRegion using physical dimensions from the center point."""
+        # We set a flag so we know to convert from physical sizes to pixels later.
+        # We don't have the image/dpmm yet so we can't do it now
+        instance = cls(
+            expected_position=expected_position_mm,
+            search_window=search_window_mm,
+            radius=radius_mm,
+            radius_tolerance=radius_tolerance_mm,
+            detection_conditions=detection_conditions,
+            name=name,
+            invert=invert,
+            max_number=max_number,
+            min_number=min_number,
+            min_separation_pixels=min_separation_mm,
+        )
+        instance.is_from_physical = True
+        instance.is_from_center = True
+        return instance
+
+    def calculate(self) -> list[RegionProperties]:
+        """Find the scikit-image regiongprops of the BB.
+
+        This will apply a high-pass filter to the image iteratively.
+        The filter starts at a very low percentile and increases until
+        a region is found that meets the detection conditions.
+        """
+        if self.is_from_physical:
+            # convert from physical sizes to pixels
+            self.expected_position * self.image.dpmm
+            self.search_window = np.asarray(self.search_window) * self.image.dpmm
+        else:
+            # convert from pixels to physical sizes
+            # I know, it's weird. The functions
+            # for detection historically have expected
+            # sizes in physical dimensions
+            self.min_separation /= self.image.dpmm
+            self.radius /= self.image.dpmm
+            self.radius_tolerance /= self.image.dpmm
+        if self.is_from_center:
+            # convert from image edge to center
+            self.expected_position.x += self.image.shape[1] / 2
+            self.expected_position.y += self.image.shape[0] / 2
+        # sample the image in the search window; need to convert to mm
+        left = max(math.floor(self.expected_position.x - self.search_window[0] / 2), 0)
+        right = math.ceil(self.expected_position.x + self.search_window[0] / 2)
+        top = max(math.floor(self.expected_position.y - self.search_window[1] / 2), 0)
+        bottom = math.ceil(self.expected_position.y + self.search_window[1] / 2)
+        sample = self.image[top:bottom, left:right]
+        # we might need to invert the image so that the BB pixel intensity is higher than the background
+        if self.invert:
+            sample = invert(sample)
+        points, boundaries, regions = find_features(
+            sample,
+            top_offset=top,
+            left_offset=left,
+            min_number=self.min_number,
+            max_number=self.max_number,
+            dpmm=self.image.dpmm,
+            detection_conditions=self.detection_conditions,
+            radius_mm=self.radius,
+            radius_tolerance_mm=self.radius_tolerance,
+            min_separation_mm=self.min_separation,
+        )
+        self.x_offset = left
+        self.y_offset = top
+        self.boundaries = boundaries
+        self.points = points
+        return regions
+
+    def plot(
+        self,
+        axis: plt.Axes,
+        show_boundaries: bool = True,
+        color: str = "red",
+        markersize: float = 3,
+        alpha: float = 0.25,
+    ) -> None:
+        """Plot the BB boundaries"""
+        if show_boundaries:
+            for boundary in self.boundaries:
+                boundary_y, boundary_x = np.nonzero(boundary)
+                axis.scatter(
+                    boundary_x,
+                    boundary_y,
+                    c=color,
+                    marker="s",
+                    alpha=alpha,
+                    s=markersize,
+                )
+
+
+class SizedDiskLocator(SizedDiskRegion):
+    """Calculates the weighted centroid of a disk/BB as a Point in an image where the disk is near an expected position and size."""
+
+    def calculate(self) -> list[Point]:
+        """Get the weighted centroids of the BB regions."""
+        super().calculate()
+        return self.points
+
+    def plot(
+        self,
+        axis: plt.Axes,
+        show_boundaries: bool = True,
+        color: str = "red",
+        markersize: float = 3,
+        alpha: float = 0.25,
+    ) -> None:
+        """Plot the BB center"""
+        super().plot(
+            axis,
+            show_boundaries=show_boundaries,
+            color=color,
+            markersize=markersize,
+            alpha=alpha,
+        )
+        for point in self.points:
+            axis.plot(
+                point.x,
+                point.y,
+                color=color,
+                marker="o",
+                alpha=1,
+                markersize=markersize,
+            )
+
+
+class GlobalSizedFieldLocator(MetricBase):
+    fields: list[Point]
+    boundaries: list[np.ndarray]
+    is_from_physical: bool = False
+
+    def __init__(
+        self,
+        field_width_px: float,
+        field_height_px: float,
+        field_tolerance_px: float,
+        min_number: int = 1,
+        max_number: int | None = None,
+        name: str = "Field Finder",
+        detection_conditions: list[callable] = (
+            is_right_square_perimeter,
+            is_right_area_square,
+        ),
+    ):
+        """Finds fields globally within an image.
+
+        Parameters
+        ----------
+        field_width_px : float
+            The width of the field in px.
+        field_height_px : float
+            The height of the field in px.
+        field_tolerance_px : float
+            The tolerance of the field size in px.
+        min_number : int
+            The minimum number of fields to find. If not found, an error is raised.
+        max_number : int, None
+            The maximum number of fields to find. If None, no maximum is set.
+        name : str
+            The name of the metric.
+        detection_conditions : list[callable]
+            A list of functions that take a regionprops object and return a boolean.
+        """
+        self.field_width_mm = field_width_px
+        self.field_height_mm = field_height_px
+        self.field_tolerance_mm = field_tolerance_px
+        self.min_number = min_number
+        self.max_number = max_number or 1e6
+        self.name = name
+        self.detection_conditions = detection_conditions
+
+    @classmethod
+    def from_physical(
+        cls,
+        field_width_mm: float,
+        field_height_mm: float,
+        field_tolerance_mm: float,
+        min_number: int = 1,
+        max_number: int | None = None,
+        name: str = "Field Finder",
+        detection_conditions: list[callable] = (
+            is_right_square_perimeter,
+            is_right_area_square,
+        ),
+    ):
+        """Construct an instance using physical dimensions.
+
+        Parameters
+        ----------
+        field_width_mm : float
+            The width of the field in mm.
+        field_height_mm : float
+            The height of the field in mm.
+        field_tolerance_mm : float
+            The tolerance of the field size in mm.
+        min_number : int
+            The minimum number of fields to find. If not found, an error is raised.
+        max_number : int, None
+            The maximum number of fields to find. If None, no maximum is set.
+        name : str
+            The name of the metric.
+        detection_conditions : list[callable]
+            A list of functions that take a regionprops object and return a boolean.
+        """
+        instance = cls(
+            field_width_px=field_width_mm,
+            field_height_px=field_height_mm,
+            field_tolerance_px=field_tolerance_mm,
+            min_number=min_number,
+            max_number=max_number,
+            name=name,
+            detection_conditions=detection_conditions,
+        )
+        instance.is_from_physical = True
+        return instance
+
+    def calculate(self) -> list[Point]:
+        """Find up to N fields in the image. This will look for fields at every percentile range.
+        Multiple fields may be found at different threshold levels."""
+        if not self.is_from_physical:
+            self.field_width_mm /= self.image.dpmm
+            self.field_height_mm /= self.image.dpmm
+            self.field_tolerance_mm /= self.image.dpmm
+        fields = []
+        boundaries = []
+        sample = self.image.array
+        # search for multiple BBs by iteratively raising the high-pass threshold value.
+        imin, imax = sample.min(), sample.max()
+        spread = imax - imin
+        step_size = (
+            spread / 50
+        )  # move in 1/50 increments; maximum of 50 passes per image
+        cutoff = imin + step_size * 5  # start at 10% height
+        while cutoff <= imax and len(fields) < self.max_number:
+            try:
+                binary_array = sample > cutoff
+                binary_array = segmentation.clear_border(binary_array, buffer_size=3)
+                labeled_arr = measure.label(binary_array)
+                regions = measure.regionprops(labeled_arr, intensity_image=sample)
+                conditions_met = [
+                    all(
+                        condition(
+                            region,
+                            dpmm=self.image.dpmm,
+                            field_width_mm=self.field_width_mm,
+                            field_height_mm=self.field_height_mm,
+                            field_tolerance_mm=self.field_tolerance_mm,
+                            shape=binary_array.shape,
+                        )
+                        for condition in self.detection_conditions
+                    )
+                    for region in regions
+                ]
+                if not any(conditions_met):
+                    raise ValueError
+                else:
+                    fields_regions = [
+                        regions[idx]
+                        for idx, value in enumerate(conditions_met)
+                        if value
+                    ]
+                    points = [
+                        Point(region.centroid[1], region.centroid[0])
+                        for region in fields_regions
+                    ]
+                    # find the boundaries of the fields
+                    # this is solely for plotting purposes
+                    # these will be bool arrays
+                    # we pad the boundaries to offset the ROI to the right
+                    # position on the image.
+                    new_boundaries = [
+                        get_boundary(region, top_offset=0, left_offset=0)
+                        for region in fields_regions
+                    ]
+                    # the separation is the minimum value + field size
+                    fields, boundaries = deduplicate_points_and_boundaries(
+                        original_points=fields,
+                        new_points=points,
+                        min_separation_px=max(
+                            r.equivalent_diameter_area for r in fields_regions
+                        )
+                        / self.image.dpmm,
+                        original_boundaries=boundaries,
+                        new_boundaries=new_boundaries,
+                    )
+            except (IndexError, ValueError):
+                pass
+            finally:
+                cutoff += step_size
+        if len(fields) < self.min_number:
+            # didn't find the number we needed
+            raise ValueError(
+                f"Couldn't find the minimum number of fields in the image. Found {len(fields)}; required: {self.min_number}"
+            )
+        self.fields = fields
+        self.boundaries = boundaries
+        return fields
+
+    def plot(
+        self,
+        axis: plt.Axes,
+        show_boundaries: bool = True,
+        color: str = "red",
+        markersize: float = 3,
+        alpha: float = 0.25,
+    ) -> None:
+        """Plot the BB centers and boundary of detection."""
+        for point in self.fields:
+            axis.plot(point.x, point.y, color=color, marker="+", alpha=alpha)
+        if show_boundaries:
+            for boundary in self.boundaries:
+                boundary_y, boundary_x = np.nonzero(boundary)
+                axis.scatter(
+                    boundary_x,
+                    boundary_y,
+                    c=color,
+                    marker="s",
+                    alpha=alpha,
+                    s=markersize,
+                )
+
+
+class GlobalFieldLocator(GlobalSizedFieldLocator):
+    def __init__(
+        self,
+        min_number: int = 1,
+        max_number: int | None = None,
+        name: str = "Field Finder",
+        detection_conditions: list[callable] = (
+            is_right_square_perimeter,
+            is_right_area_square,
+        ),
+    ):
+        """Finds fields globally within an image, irrespective of size."""
+        # we override to set the width/height/tolerance to be very large
+        # in this case we are more likely to get noise since the size is unconstrained.
+        super().__init__(
+            field_width_px=1e4,
+            field_height_px=1e4,
+            field_tolerance_px=1e4,
+            min_number=min_number,
+            max_number=max_number,
+            name=name,
+            detection_conditions=detection_conditions,
+        )
+
+    @classmethod
+    def from_physical(
+        cls,
+        *args,
+        **kwargs,
+    ):
+        raise NotImplementedError(
+            "This method is not implemented for global field-finding. Use the "
+            "standard initializer instead."
+        )
+
+
+class WeightedCentroid(MetricBase):
+    def __init__(self, name: str = "Weighted Centroid"):
+        self.name = name
+
+    def calculate(self) -> Point:
+        """Calculate the weighted centroid of the image."""
+        arr = self.image.array
+        if np.sum(arr) == 0:
+            raise ValueError("Image is blank; cannot calculate weighted centroid")
+
+        # Get the indices of all elements
+        y_indices, x_indices = np.indices(arr.shape)
+
+        # Calculate the sum of weights (total weight)
+        total_weight = np.sum(arr)
+
+        # Calculate the weighted sum of indices
+        x_weighted_sum = np.sum(x_indices * arr)
+        y_weighted_sum = np.sum(y_indices * arr)
+
+        # Calculate the centroid
+        centroid_x = x_weighted_sum / total_weight
+        centroid_y = y_weighted_sum / total_weight
+
+        return Point(centroid_x, centroid_y)
+
+    def plot(self, axis: plt.Axes, **kwargs) -> None:
+        """Plot the weighted centroid of the image."""
+        centroid = self.calculate()
+        plt.plot(centroid.x, centroid.y, "o", color="red", markersize=10)
```

### Comparing `manteia_qa_pylinac-1.0.0/pylinac/metrics/profile.py` & `manteia_qa_pylinac-1.1.0/pylinac/metrics/profile.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,538 +1,617 @@
-from __future__ import annotations
-
-import math
-import typing
-from abc import ABC, abstractmethod
-from functools import cached_property
-from typing import Any, Literal
-
-import numpy as np
-from matplotlib import pyplot as plt
-from matplotlib.patches import Rectangle
-from scipy.interpolate import UnivariateSpline
-from scipy.optimize import minimize
-
-if typing.TYPE_CHECKING:
-    from ..core.profile import PhysicalProfileMixin, ProfileBase
-
-
-RIGHT = "right"
-LEFT = "left"
-
-
-class ProfileMetric(ABC):
-    """Abstract base class for profile metrics. A profile metric is a value that can be calculated from a profile
-    and potentially has plot features associated with it.
-    Examples include penumbra, flatness, and symmetry"""
-
-    name: str
-    unit: str = ""
-    profile: ProfileBase | PhysicalProfileMixin
-
-    def __init__(self, color: str | None = None, linestyle: str | None = None):
-        self.color = color
-        self.linestyle = linestyle
-
-    def inject_profile(self, profile: ProfileBase) -> None:
-        """Inject the profile into the metric class.
-        We can't do this at instantiation because we don't have
-        the profile yet. We also don't want to force the user
-        to have to save it manually as they might forget.
-        Finally, we want to have it around for any method we might use."""
-        self.profile = profile
-
-    def plot(self, axis: plt.Axes):
-        """Plot the metric on the given axis."""
-        pass
-
-    @abstractmethod
-    def calculate(self) -> Any:
-        """Calculate the metric on the given profile."""
-        pass
-
-
-class FlatnessDifferenceMetric(ProfileMetric):
-    """Flatness as defined by IAEA Rad Onc Handbook pg 196: https://www-pub.iaea.org/MTCD/Publications/PDF/Pub1196_web.pdf"""
-
-    name = "Flatness (Difference)"
-    unit = "%"
-
-    def __init__(self, in_field_ratio: float = 0.8, color="g", linestyle="-."):
-        self.in_field_ratio = in_field_ratio
-        super().__init__(color=color, linestyle=linestyle)
-
-    def calculate(self) -> float:
-        """Calculate the flatness ratio of the profile."""
-        return (
-            100
-            * (self.profile.field_values().max() - self.profile.field_values().min())
-            / (self.profile.field_values().max() + self.profile.field_values().min())
-        )
-
-    def plot(self, axis: plt.Axes) -> None:
-        """Plot the points of largest flattness difference as well as the search bounding box."""
-        data = self.profile.field_values()
-        left, _, width = self.profile.field_indices(in_field_ratio=self.in_field_ratio)
-        # plot the search bounding box
-        axis.add_patch(
-            Rectangle(
-                (left, np.min(data)),
-                width,
-                np.max(data) - np.min(data),
-                fill=False,
-                color=self.color,
-                label=self.label + " Bounding box",
-            )
-        )
-        # plot the max and min values
-        axis.plot(
-            [np.argmax(data) + left, np.argmin(data) + left],
-            [np.max(data), np.min(data)],
-            "o",
-            color=self.color,
-            label=self.name,
-        )
-
-
-class FlatnessRatioMetric(FlatnessDifferenceMetric):
-    """Flatness as (apparently) defined by IEC."""
-
-    name = "Flatness (Ratio)"
-
-    def calculate(self) -> float:
-        """Calculate the flatness ratio of the profile."""
-        return (
-            100 * self.profile.field_values().max() / self.profile.field_values().min()
-        )
-
-
-class SymmetryPointDifferenceMetric(ProfileMetric):
-    """Symmetry using the point difference method."""
-
-    unit = "%"
-    name = "Point Difference Symmetry"
-
-    def __init__(
-        self,
-        in_field_ratio: float = 0.8,
-        color="magenta",
-        linestyle="--",
-        max_sym_range: float = 2,
-        min_sym_range: float = -2,
-    ):
-        self.in_field_ratio = in_field_ratio
-        self.max_sym = max_sym_range
-        self.min_sym = min_sym_range
-        super().__init__(color=color, linestyle=linestyle)
-
-    @staticmethod
-    def _calc_point(lt: float, rt: float, cax: float) -> float:
-        return 100 * (lt - rt) / cax
-
-    @cached_property
-    def symmetry_values(self) -> list[float]:
-        field_values = self.profile.field_values(in_field_ratio=self.in_field_ratio)
-        cax_value = self.profile.y_at_x(self.profile.center_idx)
-        return [
-            self._calc_point(lt, rt, cax_value)
-            for lt, rt in zip(field_values, field_values[::-1])
-        ]
-
-    def calculate(self) -> float:
-        """Calculate the symmetry ratio of the profile."""
-        max_sym_idx = np.argmax(np.abs(self.symmetry_values))
-        return self.symmetry_values[max_sym_idx]
-
-    def plot(self, axis: plt.Axes, markers: (str, str) = ("^", "v")) -> None:
-        idx = np.argmax(self.symmetry_values)
-        left_edge, right_edge, _ = self.profile.field_indices(
-            in_field_ratio=self.in_field_ratio
-        )
-        # plot max sym value
-        max_x = self.profile.x_at_x_idx(self.profile.x_idx_at_x(left_edge) + idx)
-        axis.plot(
-            max_x,
-            self.profile.y_at_x(max_x),
-            markers[0],
-            color=self.color,
-            label=self.name,
-        )
-        # plot min sym value
-        min_x = self.profile.x_at_x_idx(self.profile.x_idx_at_x(right_edge) - idx)
-        axis.plot(
-            min_x,
-            self.profile.y_at_x(min_x),
-            markers[1],
-            color=self.color,
-        )
-
-        # plot the symmetry on a secondary axis
-        sec_ax = axis.twinx()
-        sec_ax.set_ylabel(self.name)
-
-        # plot the symmetry on the secondary axis
-        # add some vertical padding and/or use the minimum/maximum symmetry values
-        ylim_top = max((max(self.symmetry_values) + 0.5, self.max_sym + 0.5))
-        ylim_bottom = min((min(self.symmetry_values) - 0.5, self.min_sym - 0.5))
-        sec_ax.set_ylim(ylim_bottom, ylim_top)
-        sec_ax.plot(
-            self.profile.field_x_values(self.in_field_ratio),
-            self.symmetry_values,
-            color=self.color,
-            linestyle=self.linestyle,
-        )
-
-
-class SymmetryPointDifferenceQuotientMetric(SymmetryPointDifferenceMetric):
-    """Symmetry as defined by IEC."""
-
-    name = "Point Difference Quotient Symmetry"
-
-    def __init__(
-        self,
-        in_field_ratio: float = 0.8,
-        color="magenta",
-        linestyle="--",
-        max_sym_range: float = 2,
-        min_sym_range: float = 0,
-    ):
-        super().__init__(in_field_ratio, color, linestyle, max_sym_range, min_sym_range)
-
-    @staticmethod
-    def _calc_point(lt: float, rt: float, cax: float) -> float:
-        """Calculate an individual point's symmetry."""
-        return 100 * max((lt / rt), (rt / lt))
-
-    def plot(self, axis: plt.Axes, markers: (str, str) = ("x", "x")) -> None:
-        super().plot(axis, markers)
-
-
-class SymmetryAreaMetric(ProfileMetric):
-    """The symmetry using ratios of the areas of the left and right sides of the profile."""
-
-    name = "Symmetry (Area)"
-
-    def __init__(
-        self,
-        in_field_ratio: float = 0.8,
-    ):
-        self.in_field_ratio = in_field_ratio
-
-    def calculate(self) -> float:
-        """Calculate the symmetry ratio of the profile using the area of the left side vs the right side."""
-        _, _, width = self.profile.field_indices(in_field_ratio=self.in_field_ratio)
-        area_left = np.sum(
-            self.profile.field_values(self.in_field_ratio)[: math.floor(width / 2) + 1]
-        )
-        area_right = np.sum(
-            self.profile.field_values(self.in_field_ratio)[math.ceil(width / 2) :]
-        )
-        return 100 * (area_left - area_right) / (area_left + area_right)
-
-    def plot(self, axis: plt.Axes):
-        """Plot the symmetry by shading the left and right areas"""
-        field_values = self.profile.field_values(self.in_field_ratio)
-        x_values = self.profile.field_x_values(self.in_field_ratio)
-        split = math.floor(len(field_values) / 2)
-        left_data = field_values[: split + 1]
-        left_x = x_values[: split + 1]
-        right_data = field_values[split:]
-        right_x = x_values[split:]
-        axis.fill_between(left_x, left_data, alpha=0.2, label="Left Area")
-        axis.fill_between(right_x, right_data, alpha=0.2, label="Right Area")
-
-
-class PenumbraLeftMetric(ProfileMetric):
-    unit = "%"
-    name = "Left Penumbra"
-    side = LEFT
-
-    def __init__(self, lower: float = 20, upper: float = 80, color="pink", ls="-."):
-        self.lower = lower
-        self.upper = upper
-        super().__init__(color=color, linestyle=ls)
-
-    def calculate(self) -> float:
-        """Calculate the left penumbra in mm.
-        We first find the edge point and then return the
-        distance from the lower penumbra value to upper penumbra value.
-        The trick is that wherever the field edge is, is assumed to be 50%
-        height. It's okay if it's not actually (like for FFF).
-        """
-        left_edge = self.profile.field_edge_idx(side=self.side)
-        left_edge_value = self.profile.y_at_x(left_edge)
-        lower_search_value = left_edge_value * 2 * self.lower / 100
-        lower_index = self.profile.x_at_y(y=lower_search_value, side=self.side)
-        upper_search_value = left_edge_value * 2 * self.upper / 100
-        upper_index = self.profile.x_at_y(y=upper_search_value, side=self.side)
-        self.lower_index = lower_index
-        self.upper_index = upper_index
-        return abs(upper_index - lower_index) / self.profile.dpmm
-
-    def plot(self, axis: plt.Axes):
-        axis.vlines(
-            x=[self.lower_index, self.upper_index],
-            ymin=self.profile.values.min(),
-            ymax=self.profile.values.max(),
-            color=self.color,
-            linestyle=self.linestyle,
-            label=self.name,
-        )
-
-
-class PenumbraRightMetric(PenumbraLeftMetric):
-    side = RIGHT
-    name = "Right Penumbra"
-
-
-class TopDistanceMetric(ProfileMetric):
-    """The distance from an FFF beam's "top" to the center of the field. Similar, although
-    not 100% faithful to NCS-33. The NCS report uses the middle 5cm but we use a field ratio.
-    In practice, this shouldn't make a difference."""
-
-    name = "Top Distance"
-    unit = "mm"
-
-    def __init__(self, top_region_ratio: float = 0.2, color="orange"):
-        self.top_region_ratio = top_region_ratio
-        super().__init__(color=color)
-
-    def calculate(self) -> float:
-        """Calculate the distance from the top to the field center. Positive means the top is to the right,
-        negative means the top is to the left."""
-        values = self.profile.field_values(in_field_ratio=self.top_region_ratio)
-        left, right, _ = self.profile.field_indices(
-            in_field_ratio=self.top_region_ratio
-        )
-        fit_params = np.polyfit(
-            range(left, right + 1),
-            values,
-            deg=2,
-        )
-
-        # minimize the polynomial function
-        min_f = minimize(
-            lambda x: -np.polyval(
-                fit_params, x
-            ),  # return the negative since we're MINIMIZING and want the top value
-            method="Nelder-Mead",
-            x0=self.profile.center_idx,
-            bounds=((left, right),),
-        )
-        top_idx = min_f.x[0]
-        self.top_idx = top_idx
-        self.top_values = np.polyval(fit_params, range(left, right + 1))
-        return (top_idx - self.profile.center_idx) / self.profile.dpmm
-
-    def plot(self, axis: plt.Axes):
-        """Plot the top point and the fitted curve."""
-        axis.plot(
-            self.top_idx,
-            self.profile.y_at_x(self.top_idx),
-            "o",
-            color=self.color,
-            label=self.name,
-        )
-        left, right, _ = self.profile.field_indices(
-            in_field_ratio=self.top_region_ratio
-        )
-        axis.plot(
-            range(left, right + 1),
-            self.top_values,
-            color=self.color,
-            linestyle=self.linestyle,
-            label=self.name + " Fit",
-        )
-
-
-class Dmax(ProfileMetric):
-    """Find the Dmax of the profile. This is a special case of the PDD metric.
-
-    Parameters
-    ----------
-    window_mm
-        The width of the window to use for the fit. The window will be centered around the maximum value point, which
-        is used as the initial guess for the fit.
-    poly_order
-        The order of the polynomial to use for the fit. See `UnivariateSpline <https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.UnivariateSpline.html>`__ for more information.
-        Generally, an order between 3 and 5 is recommended.
-    color
-        The color of the Dmax point.
-    linestyle
-        The linestyle of the fit line.
-    """
-
-    name = "Dmax"
-    unit = "mm"
-    fit_x: np.ndarray
-    fit_y: np.ndarray
-    point_x: float
-    point_y: float
-    window_mm: float
-
-    def __init__(
-        self,
-        window_mm: float = 20,
-        poly_order: int = 5,
-        color: str | None = None,
-        linestyle: str | None = "-.",
-    ):
-        super().__init__(color=color, linestyle=linestyle)
-        self.window_mm = window_mm
-        self.poly_order = poly_order
-
-    def calculate(self) -> float:
-        """Calculate the Dmax of the profile.
-
-        We find the maximum value of the profile and then fit a polynomial to the profile in a window around the
-        maximum value. The Dmax is the x-value of the polynomial's maximum value."""
-        # find the approximate depth first via the maximum value.
-        # we don't use profile.x_at_y because the max could be on the left or right side
-        # of the center idx. We don't know; a hack is to just index the max y-value.
-        dmax_idx = np.argmax(self.profile.values)
-        appr_dmax_mm = self.profile.x_values[dmax_idx]
-        f, fit_x = self._spline_fit(self.window_mm, appr_dmax_mm, self.poly_order)
-        # now maximize the polynomial to find dmax
-        fun = minimize(
-            lambda x: -f(x), bounds=((fit_x.min(), fit_x.max()),), x0=fit_x.mean()
-        )
-        self.fit_x = fit_x
-        self.fit_y = f(fit_x)
-        self.point_x = fun.x[0]
-        self.point_y = -fun.fun  # negative because we're minimizing the negative above
-        return self.point_x
-
-    def _spline_fit(
-        self, window_mm: float, depth_mm: float, poly_order: int
-    ) -> (UnivariateSpline, np.ndarray):
-        """Fit a spline to the profile of a given window at the passed depth."""
-        half_window = window_mm / 2
-        start, end = max(depth_mm - half_window, 0), min(
-            depth_mm + half_window, self.profile.x_values.max()
-        )
-        if abs(start - end) <= half_window or start > end:
-            raise ValueError(
-                f"The PDD/Dmax metric at {depth_mm} has a window that is at or past an edge and is too small to reliably fit the data. Make the window smaller or adjust the desired depth."
-            )
-        fit_x = np.arange(start, end + 1, 0.1)  # interpolate the fit to 0.1mm
-        f = UnivariateSpline(fit_x, self.profile.y_at_x(fit_x), k=poly_order)
-        return f, fit_x
-
-    def plot(self, axis: plt.Axes):
-        """Plot the PDD point and polynomial fit."""
-        axis.plot(
-            self.point_x,
-            self.point_y,
-            "D",
-            color=self.color,
-            label=f"{self.name} ({self.point_x:.2f}{self.unit})",
-        )
-        axis.plot(
-            self.fit_x,
-            self.fit_y,
-            color=self.color,
-            linestyle=self.linestyle,
-        )
-
-
-class PDD(Dmax):
-    """The PDD at a given depth.
-
-    This will fit a polynomial to the profile in a window around the depth of interest and
-    calculate the y-value of the polynomial at the depth of interest. This is the
-    un-normalized value. We then have to normalize to the Dmax.
-    The original PDD is then set as PDD/Dmax to give a true percentage.
-
-    Parameters
-    ----------
-    depth_mm
-        The depth at which to calculate the PDD.
-    window_mm
-        The width of the window to use for the fit. The window will be centered around the depth of interest.
-    poly_order
-        The order of the polynomial to use for the fit. See `UnivariateSpline <https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.UnivariateSpline.html>`__ for more information.
-        Generally, an order between 1 and 2 is recommended.
-    normalize_to
-        The value to normalize the PDD to. Either "fit" or "max". If "fit", the Dmax is calculated using the
-        default Dmax metric using the ``dmax_window_mm`` and ``dmax_poly_order`` parameters. If "max", the maximum value of the profile is used.
-    dmax_window_mm
-        The width of the window to use for the Dmax calculation. Only used if ``normalize_to`` is "fit".
-    dmax_poly_order
-        The order of the polynomial to use for the Dmax calculation. Only used if ``normalize_to`` is "fit".
-    color
-        The color of the PDD point.
-    linestyle
-        The linestyle of the fit line.
-    """
-
-    unit = "%"
-    fit_x: np.ndarray
-    fit_y: np.ndarray
-    point_x: float
-    point_y: float
-    window_mm: float
-
-    @property
-    def name(self):
-        return f"PDD@{self.depth_mm}mm"
-
-    def __init__(
-        self,
-        depth_mm: float,
-        window_mm: float = 10,
-        poly_order: int = 2,
-        normalize_to: Literal["fit", "max"] = "fit",
-        dmax_window_mm: float = 20,
-        dmax_poly_order: int = 5,
-        color: str | None = None,
-        linestyle: str | None = "-.",
-    ):
-        super().__init__(
-            color=color, linestyle=linestyle, window_mm=window_mm, poly_order=poly_order
-        )
-        self.depth_mm = depth_mm
-        self.window_mm = window_mm
-        self.poly_order = poly_order
-        self.normalize_to = normalize_to
-        self.dmax_window = dmax_window_mm
-        self.dmax_poly_order = dmax_poly_order
-
-    def calculate(self) -> float:
-        """Calculate the PDD of the profile.
-
-        This fits a polynomial to the profile in a window around the depth of interest and
-        returns the y-value of the polynomial at the depth of interest."""
-        f, fit_x = self._spline_fit(self.window_mm, self.depth_mm, self.poly_order)
-        self.fit_x = fit_x
-        self.fit_y = f(fit_x)
-        self.point_x = self.depth_mm
-        self.point_y = f(self.depth_mm)
-        # now we have to normalize to the dmax
-        if self.normalize_to == "fit":
-            dmax = Dmax(window_mm=self.dmax_window, poly_order=self.dmax_poly_order)
-            dmax.inject_profile(self.profile)
-            dmax.calculate()
-            s = self.point_y / dmax.point_y
-        elif self.normalize_to == "max":
-            s = self.point_y / self.profile.values.max()
-        else:
-            raise ValueError(
-                "The PDD normalization parameter must be either 'fit' or 'max'."
-            )
-        return s * 100
-
-    def plot(self, axis: plt.Axes):
-        """Plot the PDD point and polynomial fit."""
-        axis.plot(
-            self.point_x,
-            self.point_y,
-            "D",
-            color=self.color,
-            label=f"{self.name} ({self.calculate():.2f}{self.unit})",
-        )
-        axis.plot(
-            self.fit_x,
-            self.fit_y,
-            color=self.color,
-            linestyle=self.linestyle,
-        )
+from __future__ import annotations
+
+import math
+import typing
+from abc import ABC, abstractmethod
+from functools import cached_property
+from typing import Any, Literal
+
+import numpy as np
+from matplotlib import pyplot as plt
+from matplotlib.patches import Rectangle
+from scipy.interpolate import UnivariateSpline
+from scipy.optimize import minimize
+
+if typing.TYPE_CHECKING:
+    from ..core.profile import PhysicalProfileMixin, ProfileBase
+
+
+RIGHT = "right"
+LEFT = "left"
+
+
+class ProfileMetric(ABC):
+    """Abstract base class for profile metrics. A profile metric is a value that can be calculated from a profile
+    and potentially has plot features associated with it.
+    Examples include penumbra, flatness, and symmetry"""
+
+    name: str
+    unit: str = ""
+    profile: ProfileBase | PhysicalProfileMixin
+
+    def __init__(self, color: str | None = None, linestyle: str | None = None):
+        self.color = color
+        self.linestyle = linestyle
+
+    def inject_profile(self, profile: ProfileBase) -> None:
+        """Inject the profile into the metric class.
+        We can't do this at instantiation because we don't have
+        the profile yet. We also don't want to force the user
+        to have to save it manually as they might forget.
+        Finally, we want to have it around for any method we might use."""
+        self.profile = profile
+
+    def plot(self, axis: plt.Axes):
+        """Plot the metric on the given axis."""
+        pass
+
+    @abstractmethod
+    def calculate(self) -> Any:
+        """Calculate the metric on the given profile."""
+        pass
+
+
+class FlatnessDifferenceMetric(ProfileMetric):
+    """Flatness as defined by IAEA Rad Onc Handbook pg 196: https://www-pub.iaea.org/MTCD/Publications/PDF/Pub1196_web.pdf"""
+
+    name = "Flatness (Difference)"
+    unit = "%"
+
+    def __init__(self, in_field_ratio: float = 0.8, color="g", linestyle="-."):
+        self.in_field_ratio = in_field_ratio
+        super().__init__(color=color, linestyle=linestyle)
+
+    def calculate(self) -> float:
+        """Calculate the flatness ratio of the profile."""
+        return (
+            100
+            * (self.profile.field_values().max() - self.profile.field_values().min())
+            / (self.profile.field_values().max() + self.profile.field_values().min())
+        )
+
+    def plot(self, axis: plt.Axes) -> None:
+        """Plot the points of largest flattness difference as well as the search bounding box."""
+        data = self.profile.field_values()
+        left, _, width = self.profile.field_indices(in_field_ratio=self.in_field_ratio)
+        # plot the search bounding box
+        axis.add_patch(
+            Rectangle(
+                (left, np.min(data)),
+                width,
+                np.max(data) - np.min(data),
+                fill=False,
+                color=self.color,
+                label=self.label + " Bounding box",
+            )
+        )
+        # plot the max and min values
+        axis.plot(
+            [np.argmax(data) + left, np.argmin(data) + left],
+            [np.max(data), np.min(data)],
+            "o",
+            color=self.color,
+            label=self.name,
+        )
+
+
+class FlatnessRatioMetric(FlatnessDifferenceMetric):
+    """Flatness as (apparently) defined by IEC."""
+
+    name = "Flatness (Ratio)"
+
+    def calculate(self) -> float:
+        """Calculate the flatness ratio of the profile."""
+        return (
+            100 * self.profile.field_values().max() / self.profile.field_values().min()
+        )
+
+
+class SymmetryPointDifferenceMetric(ProfileMetric):
+    """Symmetry using the point difference method."""
+
+    unit = "%"
+    name = "Point Difference Symmetry"
+
+    def __init__(
+        self,
+        in_field_ratio: float = 0.8,
+        color="magenta",
+        linestyle="--",
+        max_sym_range: float = 2,
+        min_sym_range: float = -2,
+    ):
+        self.in_field_ratio = in_field_ratio
+        self.max_sym = max_sym_range
+        self.min_sym = min_sym_range
+        super().__init__(color=color, linestyle=linestyle)
+
+    @staticmethod
+    def _calc_point(lt: float, rt: float, cax: float) -> float:
+        return 100 * (lt - rt) / cax
+
+    @cached_property
+    def symmetry_values(self) -> list[float]:
+        field_values = self.profile.field_values(in_field_ratio=self.in_field_ratio)
+        cax_value = self.profile.y_at_x(self.profile.center_idx)
+        return [
+            self._calc_point(lt, rt, cax_value)
+            for lt, rt in zip(field_values, field_values[::-1])
+        ]
+
+    def calculate(self) -> float:
+        """Calculate the symmetry ratio of the profile."""
+        max_sym_idx = np.argmax(np.abs(self.symmetry_values))
+        return self.symmetry_values[max_sym_idx]
+
+    def plot(self, axis: plt.Axes, markers: (str, str) = ("^", "v")) -> None:
+        idx = np.argmax(self.symmetry_values)
+        left_edge, right_edge, _ = self.profile.field_indices(
+            in_field_ratio=self.in_field_ratio
+        )
+        # plot max sym value
+        max_x = self.profile.x_at_x_idx(self.profile.x_idx_at_x(left_edge) + idx)
+        axis.plot(
+            max_x,
+            self.profile.y_at_x(max_x),
+            markers[0],
+            color=self.color,
+            label=self.name,
+        )
+        # plot min sym value
+        min_x = self.profile.x_at_x_idx(self.profile.x_idx_at_x(right_edge) - idx)
+        axis.plot(
+            min_x,
+            self.profile.y_at_x(min_x),
+            markers[1],
+            color=self.color,
+        )
+
+        # plot the symmetry on a secondary axis
+        sec_ax = axis.twinx()
+        sec_ax.set_ylabel(self.name)
+
+        # plot the symmetry on the secondary axis
+        # add some vertical padding and/or use the minimum/maximum symmetry values
+        ylim_top = max((max(self.symmetry_values) + 0.5, self.max_sym + 0.5))
+        ylim_bottom = min((min(self.symmetry_values) - 0.5, self.min_sym - 0.5))
+        sec_ax.set_ylim(ylim_bottom, ylim_top)
+        sec_ax.plot(
+            self.profile.field_x_values(self.in_field_ratio),
+            self.symmetry_values,
+            color=self.color,
+            linestyle=self.linestyle,
+        )
+
+
+class SymmetryPointDifferenceQuotientMetric(SymmetryPointDifferenceMetric):
+    """Symmetry as defined by IEC."""
+
+    name = "Point Difference Quotient Symmetry"
+
+    def __init__(
+        self,
+        in_field_ratio: float = 0.8,
+        color="magenta",
+        linestyle="--",
+        max_sym_range: float = 2,
+        min_sym_range: float = 0,
+    ):
+        super().__init__(in_field_ratio, color, linestyle, max_sym_range, min_sym_range)
+
+    @staticmethod
+    def _calc_point(lt: float, rt: float, cax: float) -> float:
+        """Calculate an individual point's symmetry."""
+        return 100 * max((lt / rt), (rt / lt))
+
+    def plot(self, axis: plt.Axes, markers: (str, str) = ("x", "x")) -> None:
+        super().plot(axis, markers)
+
+
+class SymmetryAreaMetric(ProfileMetric):
+    """The symmetry using ratios of the areas of the left and right sides of the profile."""
+
+    name = "Symmetry (Area)"
+
+    def __init__(
+        self,
+        in_field_ratio: float = 0.8,
+    ):
+        self.in_field_ratio = in_field_ratio
+
+    def calculate(self) -> float:
+        """Calculate the symmetry ratio of the profile using the area of the left side vs the right side."""
+        _, _, width = self.profile.field_indices(in_field_ratio=self.in_field_ratio)
+        area_left = np.sum(
+            self.profile.field_values(self.in_field_ratio)[: math.floor(width / 2) + 1]
+        )
+        area_right = np.sum(
+            self.profile.field_values(self.in_field_ratio)[math.ceil(width / 2) :]
+        )
+        return 100 * (area_left - area_right) / (area_left + area_right)
+
+    def plot(self, axis: plt.Axes):
+        """Plot the symmetry by shading the left and right areas"""
+        field_values = self.profile.field_values(self.in_field_ratio)
+        x_values = self.profile.field_x_values(self.in_field_ratio)
+        split = math.floor(len(field_values) / 2)
+        left_data = field_values[: split + 1]
+        left_x = x_values[: split + 1]
+        right_data = field_values[split:]
+        right_x = x_values[split:]
+        axis.fill_between(left_x, left_data, alpha=0.2, label="Left Area")
+        axis.fill_between(right_x, right_data, alpha=0.2, label="Right Area")
+
+
+class PenumbraLeftMetric(ProfileMetric):
+    unit = "%"
+    name = "Left Penumbra"
+    side = LEFT
+
+    def __init__(self, lower: float = 20, upper: float = 80, color="pink", ls="-."):
+        self.lower = lower
+        self.upper = upper
+        super().__init__(color=color, linestyle=ls)
+
+    def calculate(self) -> float:
+        """Calculate the left penumbra in mm.
+        We first find the edge point and then return the
+        distance from the lower penumbra value to upper penumbra value.
+        The trick is that wherever the field edge is, is assumed to be 50%
+        height. It's okay if it's not actually (like for FFF).
+        """
+        left_edge = self.profile.field_edge_idx(side=self.side)
+        left_edge_value = self.profile.y_at_x(left_edge)
+        lower_search_value = left_edge_value * 2 * self.lower / 100
+        lower_index = self.profile.x_at_y(y=lower_search_value, side=self.side)
+        upper_search_value = left_edge_value * 2 * self.upper / 100
+        upper_index = self.profile.x_at_y(y=upper_search_value, side=self.side)
+        self.lower_index = lower_index
+        self.upper_index = upper_index
+        return abs(upper_index - lower_index) / self.profile.dpmm
+
+    def plot(self, axis: plt.Axes):
+        axis.vlines(
+            x=[self.lower_index, self.upper_index],
+            ymin=self.profile.values.min(),
+            ymax=self.profile.values.max(),
+            color=self.color,
+            linestyle=self.linestyle,
+            label=self.name,
+        )
+
+
+class PenumbraRightMetric(PenumbraLeftMetric):
+    side = RIGHT
+    name = "Right Penumbra"
+
+
+class TopDistanceMetric(ProfileMetric):
+    """The distance from an FFF beam's "top" to the center of the field. Similar, although
+    not 100% faithful to NCS-33. The NCS report uses the middle 5cm but we use a field ratio.
+    In practice, this shouldn't make a difference."""
+
+    name = "Top Distance"
+    unit = "mm"
+
+    def __init__(self, top_region_ratio: float = 0.2, color="orange"):
+        self.top_region_ratio = top_region_ratio
+        super().__init__(color=color)
+
+    def calculate(self) -> float:
+        """Calculate the distance from the top to the field center. Positive means the top is to the right,
+        negative means the top is to the left."""
+        values = self.profile.field_values(in_field_ratio=self.top_region_ratio)
+        left, right, _ = self.profile.field_indices(
+            in_field_ratio=self.top_region_ratio
+        )
+        fit_params = np.polyfit(
+            range(left, right + 1),
+            values,
+            deg=2,
+        )
+
+        # minimize the polynomial function
+        min_f = minimize(
+            lambda x: -np.polyval(
+                fit_params, x
+            ),  # return the negative since we're MINIMIZING and want the top value
+            method="Nelder-Mead",
+            x0=self.profile.center_idx,
+            bounds=((left, right),),
+        )
+        top_idx = min_f.x[0]
+        self.top_idx = top_idx
+        self.top_values = np.polyval(fit_params, range(left, right + 1))
+        return (top_idx - self.profile.center_idx) / self.profile.dpmm
+
+    def plot(self, axis: plt.Axes):
+        """Plot the top point and the fitted curve."""
+        axis.plot(
+            self.top_idx,
+            self.profile.y_at_x(self.top_idx),
+            "o",
+            color=self.color,
+            label=self.name,
+        )
+        left, right, _ = self.profile.field_indices(
+            in_field_ratio=self.top_region_ratio
+        )
+        axis.plot(
+            range(left, right + 1),
+            self.top_values,
+            color=self.color,
+            linestyle=self.linestyle,
+            label=self.name + " Fit",
+        )
+
+
+class SlopeMetric(ProfileMetric):
+    """The slope of the field; useful for FFF beams where traditional flatness metrics are not as useful.
+
+    Not 100% faithful to NCS-33; see Section 3.2.5. The NCS-33 report uses several points of evaluation on either side of the CAX.
+    Pylinac uses all points within the given region and computes the slope of the best-fit line through those points.
+    """
+
+    name = "In-Field Slope"
+    unit = "%/mm"
+
+    def __init__(self, ratio_edges: (float, float) = (0.2, 0.8), color="cyan"):
+        if len(ratio_edges) != 2:
+            raise ValueError("The ratio_edges parameter must be a tuple of two floats.")
+        if ratio_edges[0] >= ratio_edges[1]:
+            raise ValueError(
+                "The first value in the ratio_edges tuple must be less than the second."
+            )
+        self.ratio_edges = ratio_edges
+        super().__init__(color=color)
+
+    def calculate(self) -> float:
+        """Calculate the angle of the slope of the field. This averages the slopes of the
+        left and right side, per NCS-33"""
+        inner_left_idx, inner_right_idx, _ = self.profile.field_indices(
+            in_field_ratio=self.ratio_edges[0]
+        )
+        outer_left_idx, outer_right_idx, _ = self.profile.field_indices(
+            in_field_ratio=self.ratio_edges[1]
+        )
+        left_indices = np.arange(outer_left_idx, inner_left_idx)
+        right_indices = np.arange(inner_right_idx, outer_right_idx)
+        left_values = self.profile.y_at_x(left_indices)
+        right_values = self.profile.y_at_x(np.arange(inner_right_idx, outer_right_idx))
+        raw_combined_values = []
+        # by zipping we can avoid a potential length error if the left and right
+        # values are not the same exact same length. This is possible from an asymmetrically-open field, either intentional or not.
+        for left, right in zip(left_values, right_values[::-1]):
+            raw_combined_values.append((left + right) / 2)
+        scaled_combined_values = np.array(raw_combined_values) / self.profile.y_at_x(
+            self.profile.center_idx
+        )
+        real_fit_params = np.polyfit(
+            np.arange(len(raw_combined_values)) / self.profile.dpmm,
+            scaled_combined_values,
+            deg=1,
+        )
+        self.raw_combined_values = np.array(raw_combined_values)
+        self.left_indices = left_indices
+        self.right_indices = right_indices
+
+        return float(real_fit_params[0])
+
+    def plot(self, axis: plt.Axes):
+        """Plot the fits of the slope angles."""
+        left_plot_fit_params = np.polyfit(
+            self.left_indices,
+            self.raw_combined_values,
+            deg=1,
+        )
+        axis.plot(
+            self.left_indices,
+            np.polyval(left_plot_fit_params, self.left_indices),
+            "-.",
+            color=self.color,
+            label=self.name,
+        )
+        right_plot_fit_params = np.polyfit(
+            self.right_indices,
+            self.raw_combined_values[::-1],
+            deg=1,
+        )
+        axis.plot(
+            self.right_indices,
+            np.polyval(right_plot_fit_params, self.right_indices),
+            "-.",
+            color=self.color,
+        )
+
+
+class Dmax(ProfileMetric):
+    """Find the Dmax of the profile. This is a special case of the PDD metric.
+
+    Parameters
+    ----------
+    window_mm
+        The width of the window to use for the fit. The window will be centered around the maximum value point, which
+        is used as the initial guess for the fit.
+    poly_order
+        The order of the polynomial to use for the fit. See `UnivariateSpline <https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.UnivariateSpline.html>`__ for more information.
+        Generally, an order between 3 and 5 is recommended.
+    color
+        The color of the Dmax point.
+    linestyle
+        The linestyle of the fit line.
+    """
+
+    name = "Dmax"
+    unit = "mm"
+    fit_x: np.ndarray
+    fit_y: np.ndarray
+    point_x: float
+    point_y: float
+    window_mm: float
+
+    def __init__(
+        self,
+        window_mm: float = 20,
+        poly_order: int = 5,
+        color: str | None = None,
+        linestyle: str | None = "-.",
+    ):
+        super().__init__(color=color, linestyle=linestyle)
+        self.window_mm = window_mm
+        self.poly_order = poly_order
+
+    def calculate(self) -> float:
+        """Calculate the Dmax of the profile.
+
+        We find the maximum value of the profile and then fit a polynomial to the profile in a window around the
+        maximum value. The Dmax is the x-value of the polynomial's maximum value."""
+        # find the approximate depth first via the maximum value.
+        # we don't use profile.x_at_y because the max could be on the left or right side
+        # of the center idx. We don't know; a hack is to just index the max y-value.
+        dmax_idx = np.argmax(self.profile.values)
+        appr_dmax_mm = self.profile.x_values[dmax_idx]
+        f, fit_x = self._spline_fit(self.window_mm, appr_dmax_mm, self.poly_order)
+        # now maximize the polynomial to find dmax
+        fun = minimize(
+            lambda x: -f(x), bounds=((fit_x.min(), fit_x.max()),), x0=fit_x.mean()
+        )
+        self.fit_x = fit_x
+        self.fit_y = f(fit_x)
+        self.point_x = fun.x[0]
+        self.point_y = -fun.fun  # negative because we're minimizing the negative above
+        return self.point_x
+
+    def _spline_fit(
+        self, window_mm: float, depth_mm: float, poly_order: int
+    ) -> (UnivariateSpline, np.ndarray):
+        """Fit a spline to the profile of a given window at the passed depth."""
+        half_window = window_mm / 2
+        start, end = max(depth_mm - half_window, 0), min(
+            depth_mm + half_window, self.profile.x_values.max()
+        )
+        if abs(start - end) <= half_window or start > end:
+            raise ValueError(
+                f"The PDD/Dmax metric at {depth_mm} has a window that is at or past an edge and is too small to reliably fit the data. Make the window smaller or adjust the desired depth."
+            )
+        fit_x = np.arange(start, end + 1, 0.1)  # interpolate the fit to 0.1mm
+        f = UnivariateSpline(fit_x, self.profile.y_at_x(fit_x), k=poly_order)
+        return f, fit_x
+
+    def plot(self, axis: plt.Axes):
+        """Plot the PDD point and polynomial fit."""
+        axis.plot(
+            self.point_x,
+            self.point_y,
+            "D",
+            color=self.color,
+            label=f"{self.name} ({self.point_x:.2f}{self.unit})",
+        )
+        axis.plot(
+            self.fit_x,
+            self.fit_y,
+            color=self.color,
+            linestyle=self.linestyle,
+        )
+
+
+class PDD(Dmax):
+    """The PDD at a given depth.
+
+    This will fit a polynomial to the profile in a window around the depth of interest and
+    calculate the y-value of the polynomial at the depth of interest. This is the
+    un-normalized value. We then have to normalize to the Dmax.
+    The original PDD is then set as PDD/Dmax to give a true percentage.
+
+    Parameters
+    ----------
+    depth_mm
+        The depth at which to calculate the PDD.
+    window_mm
+        The width of the window to use for the fit. The window will be centered around the depth of interest.
+    poly_order
+        The order of the polynomial to use for the fit. See `UnivariateSpline <https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.UnivariateSpline.html>`__ for more information.
+        Generally, an order between 1 and 2 is recommended.
+    normalize_to
+        The value to normalize the PDD to. Either "fit" or "max". If "fit", the Dmax is calculated using the
+        default Dmax metric using the ``dmax_window_mm`` and ``dmax_poly_order`` parameters. If "max", the maximum value of the profile is used.
+    dmax_window_mm
+        The width of the window to use for the Dmax calculation. Only used if ``normalize_to`` is "fit".
+    dmax_poly_order
+        The order of the polynomial to use for the Dmax calculation. Only used if ``normalize_to`` is "fit".
+    color
+        The color of the PDD point.
+    linestyle
+        The linestyle of the fit line.
+    """
+
+    unit = "%"
+    fit_x: np.ndarray
+    fit_y: np.ndarray
+    point_x: float
+    point_y: float
+    window_mm: float
+
+    @property
+    def name(self):
+        return f"PDD@{self.depth_mm}mm"
+
+    def __init__(
+        self,
+        depth_mm: float,
+        window_mm: float = 10,
+        poly_order: int = 2,
+        normalize_to: Literal["fit", "max"] = "fit",
+        dmax_window_mm: float = 20,
+        dmax_poly_order: int = 5,
+        color: str | None = None,
+        linestyle: str | None = "-.",
+    ):
+        super().__init__(
+            color=color, linestyle=linestyle, window_mm=window_mm, poly_order=poly_order
+        )
+        self.depth_mm = depth_mm
+        self.window_mm = window_mm
+        self.poly_order = poly_order
+        self.normalize_to = normalize_to
+        self.dmax_window = dmax_window_mm
+        self.dmax_poly_order = dmax_poly_order
+
+    def calculate(self) -> float:
+        """Calculate the PDD of the profile.
+
+        This fits a polynomial to the profile in a window around the depth of interest and
+        returns the y-value of the polynomial at the depth of interest."""
+        f, fit_x = self._spline_fit(self.window_mm, self.depth_mm, self.poly_order)
+        self.fit_x = fit_x
+        self.fit_y = f(fit_x)
+        self.point_x = self.depth_mm
+        self.point_y = f(self.depth_mm)
+        # now we have to normalize to the dmax
+        if self.normalize_to == "fit":
+            dmax = Dmax(window_mm=self.dmax_window, poly_order=self.dmax_poly_order)
+            dmax.inject_profile(self.profile)
+            dmax.calculate()
+            s = self.point_y / dmax.point_y
+        elif self.normalize_to == "max":
+            s = self.point_y / self.profile.values.max()
+        else:
+            raise ValueError(
+                "The PDD normalization parameter must be either 'fit' or 'max'."
+            )
+        return s * 100
+
+    def plot(self, axis: plt.Axes):
+        """Plot the PDD point and polynomial fit."""
+        axis.plot(
+            self.point_x,
+            self.point_y,
+            "D",
+            color=self.color,
+            label=f"{self.name} ({self.calculate():.2f}{self.unit})",
+        )
+        axis.plot(
+            self.fit_x,
+            self.fit_y,
+            color=self.color,
+            linestyle=self.linestyle,
+        )
```

### Comparing `manteia_qa_pylinac-1.0.0/pylinac/picketfence.py` & `manteia_qa_pylinac-1.1.0/pylinac/picketfence.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,1521 +1,1538 @@
-"""The picket fence module is meant for analyzing EPID images where a "picket fence" MLC pattern has been made.
-Physicists regularly check MLC positioning through this test. This test can be done using film and one can
-"eyeball" it, but this is the 21st century and we have numerous ways of quantifying such data. This module
-attains to be one of them. It can load in an EPID dicom image (or superimpose multiple images) and determine the MLC peaks, error of each MLC
-pair to the picket, and give a few visual indicators for passing/warning/failing.
-
-Features:
-
-* **Analyze any MLC type** - Both default MLCs and custom MLCs can be used.
-* **Easy-to-read pass/warn/fail overlay** - Analysis gives you easy-to-read tools for determining the status of an MLC pair.
-* **Any Source-to-Image distance** - Whatever your clinic uses as the SID for picket fence, pylinac can account for it.
-* **Account for panel translation** - Have an off-CAX setup? No problem. Translate your EPID and pylinac knows.
-* **Account for panel sag** - If your EPID sags at certain angles, just tell pylinac and the results will be shifted.
-"""
-from __future__ import annotations
-
-import copy
-import dataclasses
-import enum
-import io
-import os.path as osp
-import statistics
-import warnings
-import webbrowser
-from dataclasses import dataclass
-from functools import cached_property
-from io import BytesIO
-from itertools import cycle
-from pathlib import Path
-from typing import BinaryIO, Iterable, Sequence
-
-import matplotlib.pyplot as plt
-import numpy as np
-from mpl_toolkits.axes_grid1 import make_axes_locatable
-from py_linq import Enumerable
-
-from . import Normalization
-from .core import image, pdf
-from .core.geometry import Line, Point, Rectangle
-from .core.io import get_url, retrieve_demo_file
-from .core.metrics import SizedDiskLocator
-from .core.profile import FWXMProfilePhysical, MultiProfile
-from .core.utilities import ResultBase, convert_to_enum
-from .log_analyzer import load_log
-from .settings import get_dicom_cmap
-
-LEFT_MLC_PREFIX = "A"
-RIGHT_MLC_PREFIX = "B"
-
-
-class Orientation(enum.Enum):
-    """Possible orientations of the image"""
-
-    UP_DOWN = "Up-Down"  #:
-    LEFT_RIGHT = "Left-Right"  #:
-
-
-class MLCArrangement:
-    """Construct an MLC array"""
-
-    def __init__(self, leaf_arrangement: list[tuple[int, float]], offset: float = 0):
-        """
-
-        Parameters
-        ----------
-        leaf_arrangement
-            Description of the leaf arrangement. List of tuples containing the number of leaves and leaf width.
-            E.g. (10, 5) is 10 leaves with 5mm widths.
-        offset
-            The offset in mm of the leaves. Used for asymmetric arrangements. E.g. -2.5mm will shift the arrangement 2.5mm to the left.
-        """
-        self.centers = []
-        self.widths = []
-        rolling_edge = 0
-        for leaf_num, width in leaf_arrangement:
-            self.centers += np.arange(
-                start=rolling_edge + width / 2,
-                stop=leaf_num * width + rolling_edge + width / 2,
-                step=width,
-            ).tolist()
-            rolling_edge = self.centers[-1] + width / 2
-            self.widths += [width] * leaf_num
-        self.centers = [c - np.mean(self.centers) + offset for c in self.centers]
-
-
-class MLC(enum.Enum):
-    """The pre-built MLC types"""
-
-    MILLENNIUM = {
-        "name": "Millennium",
-        "arrangement": MLCArrangement([(10, 10), (40, 5), (10, 10)]),
-    }  #:
-    HD_MILLENNIUM = {
-        "name": "HD Millennium",
-        "arrangement": MLCArrangement([(10, 5), (40, 2.5), (10, 5)]),
-    }  #:
-    BMOD = {
-        "name": "B Mod",
-        "arrangement": MLCArrangement([(40, 4)]),
-    }  #:
-    AGILITY = {
-        "name": "Agility",
-        "arrangement": MLCArrangement([(80, 5)]),
-    }  #:
-    MLCI = {
-        "name": "MLCi",
-        "arrangement": MLCArrangement([(40, 10)]),
-    }  #:
-    # Halcyon reference
-    # https://aapm.onlinelibrary.wiley.com/doi/pdf/10.1002/acm2.12568
-    HALCYON_DISTAL = {
-        "name": "Halcyon distal",
-        "arrangement": MLCArrangement([(28, 10)]),
-    }  #:
-    HALCYON_PROXIMAL = {
-        "name": "Halcyon proximal",
-        "arrangement": MLCArrangement([(29, 10)]),
-    }  #:
-
-
-@dataclass
-class PFResult(ResultBase):
-    """This class should not be called directly. It is returned by the ``results_data()`` method.
-    It is a dataclass under the hood and thus comes with all the dunder magic.
-
-    Use the following attributes as normal class attributes."""
-
-    tolerance_mm: float  #:
-    action_tolerance_mm: float  #:
-    percent_leaves_passing: float  #:
-    number_of_pickets: int  #:
-    absolute_median_error_mm: float  #:
-    max_error_mm: float  #:
-    max_error_picket: int  #:
-    max_error_leaf: str | int  #:
-    mean_picket_spacing_mm: float  #:
-    offsets_from_cax_mm: list[float]  #:
-    passed: bool  #:
-    failed_leaves: list[str] | list[int]  #:
-    mlc_skew: float  #:
-    picket_widths: dict[int, dict[str, float]]  #:
-
-
-class PFDicomImage(image.LinacDicomImage):
-    """A subclass of a DICOM image that checks for noise and inversion when instantiated. Can also adjust for EPID sag."""
-
-    _central_axis: Point | None  #:
-
-    def __init__(self, path: str, **kwargs):
-        crop_mm = kwargs.pop("crop_mm", 3)
-        self._central_axis = kwargs.pop("central_axis", None)
-        super().__init__(path, **kwargs)
-        # crop the images so that Elekta images don't fail. See #168
-        crop_pixels = int(round(crop_mm * self.dpmm))
-        self.crop(pixels=crop_pixels)
-        # self.invert()  # EPID images are always inverted; rather than check inversion, just flip it.
-        self._check_for_noise()
-        # Possibly revert/change the below if inversion detection doesn't work so well
-        self.check_inversion(box_size=10, position=(0.01, 0.01))
-
-    def _check_for_noise(self) -> None:
-        """Check if the image has extreme noise (dead pixel, etc) by comparing
-        min/max to 1/99 percentiles and smoothing if need be."""
-        safety_stop = 5
-        while self._has_noise() and safety_stop > 0:
-            self.filter(size=3)
-            safety_stop -= 1
-
-    def _has_noise(self) -> bool:
-        """Helper method to determine if there is spurious signal in the image."""
-        min = self.array.min()
-        max = self.array.max()
-        near_min, near_max = np.percentile(self.array, [0.5, 99.5])
-        max_is_extreme = max > near_max * 1.25
-        min_is_extreme = (min < near_min * 0.75) and (
-            abs(min - near_min) > 0.1 * (near_max - near_min)
-        )
-        return max_is_extreme or min_is_extreme
-
-    def adjust_for_sag(self, sag: int, orientation: str | Orientation) -> None:
-        """Roll the image to adjust for EPID sag."""
-        orient = convert_to_enum(orientation, Orientation)
-        direction = "y" if orient == Orientation.UP_DOWN else "x"
-        self.roll(direction, sag)
-
-    @property
-    def center(self) -> Point:
-        """Override the central axis call in the event we passed it directly"""
-        if self._central_axis is not None:
-            cax = copy.copy(self._central_axis)
-            cax.y = 2 * (self.shape[0] // 2) - cax.y
-            return cax
-        else:
-            return super().center
-
-
-class PicketFence:
-    """A class used for analyzing EPID images where radiation strips have been formed by the
-    MLCs. The strips are assumed to be parallel to one another and normal to the image edge;
-    i.e. a "left-right" or "up-down" orientation is assumed. Further work could follow up by accounting
-    for any angle.
-    """
-
-    _from_bb_setup: bool = False
-    _bb_image: image.LinacDicomImage | None = None
-
-    def __init__(
-        self,
-        filename: str | Path | BinaryIO,
-        filter: int | None = None,
-        log: str | None = None,
-        use_filename: bool = False,
-        mlc: MLC | MLCArrangement | str = MLC.MILLENNIUM,
-        crop_mm: int = 3,
-        image_kwargs: dict | None = None,
-    ):
-        """
-        Parameters
-        ----------
-        filename
-            Name of the file as a string or a file-like object.
-        filter
-            If None (default), no filtering will be done to the image.
-            If an int, will perform median filtering over image of size ``filter``.
-        log
-            Path to a log file corresponding to the delivery. The expected fluence of the log file is
-            used to construct the pickets. MLC peaks are then compared to an absolute reference instead of
-            a fitted picket.
-        use_filename
-            If False (default), no action will be performed.
-            If True, the filename will be searched for keywords that describe the gantry and/or collimator angle.
-            For example, if set to True and the file name was "PF_gantry45.dcm" the gantry would be interpreted as being at 45 degrees.
-        mlc
-            The MLC model of the image. Must be an option from the enum :class:`~pylinac.picketfence.MLCs` or
-            an :class:`~pylinac.picketfence.MLCArrangement`.
-        crop_mm
-            The number of mm to crop from all edges. Elekta is infamous for having columns of dead pixels on the side of their images.
-            These need to be cleaned up first. For Varian images, this really shouldn't make a difference unless the pickets are
-            very close to the edge. Generally speaking, they shouldn't be for the best accuracy.
-        """
-        leaf_analysis_width: float  #:
-        mlc_meas: list  #:
-        pickets: list  #:
-        tolerance: float  #:
-        action_tolerance: float  #:
-        image: PFDicomImage  #:
-
-        if filename is not None:
-            img_kwargs = image_kwargs or {}
-            self.image = PFDicomImage(
-                filename, use_filenames=use_filename, crop_mm=crop_mm, **img_kwargs
-            )
-            if isinstance(filter, int):
-                self.image.filter(size=filter)
-            self.image.ground()
-            self.image.normalize()
-        if log is not None:
-            self._load_log(log)
-        else:
-            self._log_fits = None
-        self._is_analyzed = False
-        self.mlc = self._get_mlc_arrangement(mlc)
-
-    @staticmethod
-    def _get_mlc_arrangement(value: MLC | MLCArrangement | str) -> MLCArrangement:
-        if isinstance(value, MLC):
-            return value.value["arrangement"]
-        if isinstance(value, MLCArrangement):
-            return value
-        if isinstance(value, str):
-            return [
-                member.value["arrangement"]
-                for name, member in MLC.__members__.items()
-                if member.value["name"] == value
-            ][0]
-
-    @classmethod
-    def from_url(cls, url: str, filter: int = None, image_kwargs: dict | None = None):
-        """Instantiate from a URL."""
-        filename = get_url(url, progress_bar=True)
-        return cls(filename, filter=filter, image_kwargs=image_kwargs)
-
-    @classmethod
-    def from_demo_image(cls, filter: int = None):
-        """Construct a PicketFence instance using the demo image."""
-        demo_file = retrieve_demo_file(name="AS1200.dcm")
-        return cls(demo_file, filter=filter)
-
-    @classmethod
-    def from_multiple_images(
-        cls,
-        path_list: Iterable[str | Path],
-        stretch_each: bool = True,
-        method: str = "mean",
-        **kwargs,
-    ):
-        """Load and superimpose multiple images and instantiate a PF object.
-
-        Parameters
-        ----------
-        path_list : iterable
-            An iterable of path locations to the files to be loaded/combined.
-        stretch_each : bool
-            Whether to stretch each image individually before combining. See ``load_multiples``.
-        method : {'sum', 'mean'}
-            The method to combine the images. See ``load_multiples``.
-        kwargs
-            Passed to :func:`~pylinac.core.image.load_multiples`.
-        """
-        with io.BytesIO() as stream:
-            img = image.load_multiples(
-                path_list, stretch_each=stretch_each, method=method, **kwargs
-            )
-            img.save(stream)
-            stream.seek(0)
-            return cls(stream, **kwargs)
-
-    @classmethod
-    def from_bb_setup(
-        cls, *args, bb_image: str | Path | BinaryIO, bb_diameter: float, **kwargs
-    ):
-        """Construct a PicketFence instance using a BB setup image to find the CAX first.
-        The CAX of the PF image is then overridden w/ the BB location from the first image.
-
-        Thank the French for this."""
-        bb_image = image.load(bb_image)
-        cax = bb_image.compute(
-            metrics=SizedDiskLocator.from_center_physical(
-                expected_position_mm=(0, 0),
-                search_window_mm=(30 + bb_diameter, 30 + bb_diameter),
-                radius_mm=bb_diameter / 2,
-                radius_tolerance_mm=bb_diameter * 0.1 + 1,
-            )
-        )
-        instance = cls(*args, **kwargs, image_kwargs={"central_axis": cax})
-        instance._from_bb_setup = True
-        instance._bb_image = bb_image
-        return instance
-
-    @property
-    def passed(self) -> bool:
-        """Boolean specifying if all MLC positions were within tolerance."""
-        # nested all because each measurement returns a list of booleans. So all the passes of each measurement must all pass.
-        return all(all(m.passed) for m in self.mlc_meas)
-
-    @property
-    def percent_passing(self) -> float:
-        """Return the percentage of MLC positions under tolerance."""
-        num_meas = Enumerable(self.mlc_meas).select_many(lambda m: m.passed).count()
-        num_pass = (
-            Enumerable(self.mlc_meas)
-            .select_many(lambda m: m.passed)
-            .count(lambda p: bool(p) is True)
-        )
-        return float(100 * num_pass / num_meas)
-
-    @property
-    def max_error(self) -> float:
-        """Return the maximum error found."""
-        return float(np.max(np.abs(self._flattened_errors())))
-
-    @property
-    def max_error_picket(self) -> int:
-        """Return the picket number where the maximum error occurred."""
-        return (
-            Enumerable(self.mlc_meas)
-            .order_by_descending(lambda m: np.max(np.abs(m.error)))
-            .select(lambda m: m.picket_num)
-            .first()
-        )
-
-    def picket_width_stat(self, picket: int, metric: str = "max") -> float:
-        """Get the statistic of the picket width for the given picket.
-
-        Parameters
-        ----------
-        picket
-            The picket number to analyze.
-        metric
-            The metric to use. One of 'max', 'median', 'mean', 'min'.
-        """
-        picket_widths = [
-            m.profile.field_width_mm for m in self.mlc_meas if m.picket_num == picket
-        ]
-        if metric == "max":
-            return max(picket_widths)
-        elif metric == "median":
-            return statistics.median(picket_widths)
-        elif metric == "mean":
-            return statistics.mean(picket_widths)
-        elif metric == "min":
-            return min(picket_widths)
-
-    @property
-    def max_error_leaf(self) -> int | str:
-        """Return the leaf/leaf pair that had the maximum error.
-        This will be a single int value (i.e. either/both A and B) for classic analysis or a fully-qualified name for separate analysis. E.g. A43
-        """
-        if not self.separate_leaves:
-            return (
-                Enumerable(self.mlc_meas)
-                .order_by_descending(lambda m: np.max(np.abs(m.error)))
-                .select(lambda m: m.full_leaf_nums[0])
-                .first()
-            )
-        else:
-            max_meas = (
-                Enumerable(self.mlc_meas)
-                .order_by_descending(lambda m: np.max(np.abs(m.error)))
-                .first()
-            )
-            if abs(max_meas.error[0]) > abs(max_meas.error[1]):
-                return max_meas.full_leaf_nums[0]
-            else:
-                return max_meas.full_leaf_nums[1]
-
-    def _flattened_errors(self) -> list[float]:
-        return Enumerable(self.mlc_meas).select_many(lambda m: m.error).to_list()
-
-    def failed_leaves(self) -> list[int] | list[str]:
-        """A list of the failed leaves. Either the leaf number or the bank+leaf number if using separate leaves."""
-        if not self._is_analyzed:
-            raise ValueError(
-                "It appears the PF image has not been analyzed yet. Use .analyze() first."
-            )
-        failing_sets = Enumerable(self.mlc_meas).where(lambda m: not all(m.passed))
-        if not self.separate_leaves:
-            return failing_sets.select(lambda m: m.leaf_num).distinct().to_list()
-        else:
-            return (
-                failing_sets.select_many(
-                    lambda m: [
-                        m.full_leaf_nums[idx]
-                        for idx, passed in enumerate(m.passed)
-                        if not passed
-                    ]
-                )
-                .distinct()
-                .to_list()
-            )
-
-    @property
-    def abs_median_error(self) -> float:
-        """Return the median error found."""
-        return float(np.median(np.abs(self._flattened_errors())))
-
-    @property
-    def num_pickets(self) -> int:
-        """Return the number of pickets determined."""
-        return len(self.pickets)
-
-    @property
-    def mean_picket_spacing(self) -> float:
-        """The average distance between pickets in mm."""
-        sorted_pickets = sorted(self.pickets, key=lambda x: x.dist2cax)
-        return float(
-            np.mean(
-                [
-                    abs(sorted_pickets[idx].dist2cax - sorted_pickets[idx + 1].dist2cax)
-                    for idx in range(len(sorted_pickets) - 1)
-                ]
-            )
-        )
-
-    def plot_leaf_profile(self, leaf: str | int, picket: int, show: bool = True):
-        """Plot the leaf profile of a given leaf pair parallel to leaf motion.
-
-        Parameters
-        ----------
-        leaf
-            The leaf to plot. If ``separate_leaves`` is True, this will be a string like "A15" or "B33".
-            If ``separate_leaves`` is False, this must be an int, like ``15`` or ``33``.
-        picket
-            An int of the picket number. Pickets start from the 0-side of an image. E.g. for left-right PFs, this would start on the left; for up-down this would start at the bottom.
-        """
-        mlc_meas = Enumerable(self.mlc_meas).single(
-            lambda m: leaf in m.full_leaf_nums and m.picket_num == picket
-        )
-        ax = mlc_meas.plot_detailed_profile()
-        ax.set_title(f"MLC profile Leaf: {leaf}, Picket: {picket}")
-        for lg, rg, m in zip(
-            self.pickets[picket].left_guard_separated,
-            self.pickets[picket].right_guard_separated,
-            mlc_meas.marker_lines,
-        ):
-            g_val = lg(m.point1.y)
-            rg_val = rg(m.point1.y)
-            ax.axvline(g_val, color="green", label="Guard rail")
-            ax.axvline(rg_val, color="green", label="Guard rail")
-        ax.legend()
-        if show:
-            plt.show()
-
-    def save_leaf_profile(
-        self,
-        filename: str | Path | BinaryIO,
-        leaf: str | int,
-        picket: int,
-        **kwargs,
-    ):
-        """Save the leaf profile plot to disk or stream. See plot_leaf_profile for parameter hints. Kwargs are passed to matplotlib.savefig()"""
-        self.plot_leaf_profile(leaf, picket, show=False)
-        plt.savefig(filename, **kwargs)
-        if not isinstance(filename, BytesIO):
-            print(f"Picket fence leaf profile saved to: {osp.abspath(filename)}")
-
-    def _load_log(self, log: str) -> None:
-        """Load a machine log that corresponds to the picket fence delivery.
-
-        This log determines the location of the pickets. The MLC peaks are then compared to the expected log pickets,
-        not a simple fit of the peaks."""
-        # load the log fluence image
-        mlog = load_log(log)
-        fl = mlog.fluence.expected.calc_map(equal_aspect=True)
-        fli = image.load(
-            fl, dpi=254
-        )  # 254 pix/in => 1 pix/0.1mm (default fluence calc)
-
-        # equate them such that they're the same size & DPI
-        fluence_img, img_array = image.equate_images(fli, self.image)
-        self.image.array = img_array.array
-
-        # get picket fits from the modified fluence image
-        pf = PicketFence.from_demo_image()
-        pf.image = fluence_img
-        pf.analyze()
-        self._log_fits = cycle([p.get_fit() for p in pf.pickets])
-
-    @staticmethod
-    def run_demo(tolerance: float = 0.5, action_tolerance: float = None) -> None:
-        """Run the Picket Fence demo using the demo image. See analyze() for parameter info."""
-        pf = PicketFence.from_demo_image()
-        pf.analyze(tolerance, action_tolerance=action_tolerance)
-        print(pf.results())
-        pf.plot_analyzed_image(leaf_error_subplot=True)
-
-    def analyze(
-        self,
-        tolerance: float = 0.5,
-        action_tolerance: float | None = None,
-        num_pickets: int | None = None,
-        sag_adjustment: float | int = 0,
-        orientation: Orientation | str | None = None,
-        invert: bool = False,
-        leaf_analysis_width_ratio: float = 0.4,
-        picket_spacing: float | None = None,
-        height_threshold: float = 0.5,
-        edge_threshold: float = 1.5,
-        peak_sort: str = "peak_heights",
-        required_prominence: float = 0.2,
-        fwxm: int = 50,
-        separate_leaves: bool = False,
-        nominal_gap_mm: float = 3,
-        central_axis: Point | None = None,
-    ) -> None:
-        """Analyze the picket fence image.
-
-        Parameters
-        ----------
-        tolerance
-            The tolerance of difference in mm between an MLC pair position and the
-            picket fit line.
-        action_tolerance
-            If None (default), no action tolerance is set or compared to.
-            If an int or float, the MLC pair measurement is also compared to this
-            tolerance. Must be lower than tolerance. This value is usually meant
-            to indicate that a physicist should take an "action" to reduce the error,
-            but should not stop treatment.
-        num_pickets
-            The number of pickets in the image. A helper parameter to limit the total number of pickets,
-            only needed if analysis is catching more pickets than there really are.
-        sag_adjustment
-            The amount of shift in mm to apply to the image to correct for EPID sag.
-            For Up-Down picket images, positive moves the image down, negative up.
-            For Left-Right picket images, positive moves the image left, negative right.
-        orientation
-            If None (default), the orientation is automatically determined. If for some reason the determined
-            orientation is not correct, you can pass it directly using this parameter.
-            If passed a string with 'u' (e.g. 'up-down', 'u-d', 'up') it will set the orientation of the pickets as
-            going up-down. If passed a string with 'l' (e.g. 'left-right', 'lr', 'left') it will set it as going
-            left-right.
-        invert
-            If False (default), the inversion of the image is automatically detected and used.
-            If True, the image inversion is reversed from the automatic detection. This is useful when runtime errors
-            are encountered.
-        leaf_analysis_width_ratio
-            The ratio of the leaf width to use as part of the evaluation. E.g. if the ratio is 0.5, the center half of
-            the leaf will be used. This helps avoid tongue and groove influence.
-        picket_spacing
-            If None (default), the spacing between pickets is determined automatically.
-            If given, it should be an int or float specifying the number of **PIXELS** apart the pickets are.
-        height_threshold
-            The threshold that the MLC peak needs to be above to be considered a picket (vs background).
-            Lower if not all leaves are being caught. Note that for FFF beams this would very likely need to be lowered.
-        edge_threshold
-            The threshold of pixel value standard deviation within the analysis window of the MLC leaf to be considered a full leaf.
-            This is how pylinac removes MLCs that are eclipsed by the jaw. This also is how to
-            omit or catch leaves at the edge of the field. Raise to catch more edge leaves.
-        peak_sort
-            Either 'peak_heights' or 'prominences'. This is the method for determining the peaks. Usually not needed
-            unless the wrong number of pickets have been detected.
-            See the scipy.signal.find_peaks function for more information.
-        required_prominence
-            The required height of the picket (not individual MLCs) to be considered a peak.
-            Pylinac takes a mean of the image axis perpendicular to the leaf motion to get an initial guess of the peak
-            locations and also to determine picket spacing. Changing this can be useful for wide-gap tests where
-            the shape of the beam horns can form two or more local maximums in the picket area. Increase if for wide-gap
-            images that are catching too many pickets. Consider lowering for FFF beams if there are analysis issues.
-
-            .. warning::
-
-                We do not recommend performing FFF wide-gap PF tests. Make your FFF pickets narrow or measure with a flat beam instead.
-
-        fwxm
-            For each MLC kiss, the profile is a curve from low to high to low. The FWXM (0-100) is the height to use to measure
-            to determine the center of the curve, which is the surrogate for MLC kiss position. I.e. for each MLC kiss,
-            what height of the picket should you use to actually determine the center location? It is unusual to change this.
-            If you have something in the way (we've seen crazy examples with a BB in the way) you may want to increase this.
-        separate_leaves
-            Whether to analyze leaves individually (each tip) or as a set (combined, center of the picket). False is
-            the default for backwards compatibility.
-        nominal_gap_mm
-            The expected gap of the pickets in mm. Only used when separate leaves is True. Due to the DLG and EPID
-            scattering, this value will have to be determined by you with a known good delivery.
-        central_axis
-            The central axis of the beam. If None (default), the CAX is automatically determined. This
-            is used for French regulations where the CAX is set to the BB location from a separate image.
-        """
-        if action_tolerance is not None and tolerance < action_tolerance:
-            raise ValueError("Tolerance cannot be lower than the action tolerance")
-        self.tolerance = tolerance
-        self.action_tolerance = action_tolerance
-        self.leaf_analysis_width = leaf_analysis_width_ratio
-        self.separate_leaves = separate_leaves
-
-        if central_axis:
-            self.image._central_axis = central_axis
-
-        if invert:
-            self.image.invert()
-
-        self._orientation = orientation
-        # adjust for sag
-        if sag_adjustment != 0:
-            sag_pixels = int(round(sag_adjustment * self.image.dpmm))
-            self.image.adjust_for_sag(sag_pixels, self.orientation)
-
-        if self.orientation == Orientation.UP_DOWN:
-            leaf_prof = np.mean(self.image, 0)
-        else:
-            leaf_prof = np.mean(self.image, 1)
-        leaf_prof = MultiProfile(leaf_prof)
-        peak_idxs, peak_vals = leaf_prof.find_fwxm_peaks(
-            min_distance=0.02,
-            threshold=height_threshold,
-            max_number=num_pickets,
-            peak_sort=peak_sort,
-            required_prominence=required_prominence,
-        )
-        if len(peak_idxs) == 0:
-            raise ValueError(
-                "No pickets were found. This can mean either an incorrect orientation or incorrect inversion. "
-                "Try passing the correct orientation; if that fails, also set invert=True."
-            )
-        # get picket spacing if not set by user
-        if picket_spacing is None:
-            picket_spacing = np.median(np.diff(np.sort(peak_idxs)))
-
-        # loop through each leaf row and analyze each MLC kiss
-        self.mlc_meas = []
-        for leaf_num, center, width in self._leaves_in_view(leaf_analysis_width_ratio):
-            for picket_num, (picket_idx, picket_peak_val) in enumerate(
-                zip(peak_idxs, peak_vals)
-            ):
-                window = self._get_mlc_window(
-                    leaf_center=center,
-                    leaf_width=width,
-                    approx_idx=picket_idx,
-                    spacing=picket_spacing,
-                )
-                if self._is_mlc_peak_in_window(
-                    window, height_threshold, edge_threshold, picket_peak_val
-                ):
-                    self.mlc_meas.append(
-                        MLCValue(
-                            picket_num=picket_num,
-                            approx_idx=picket_idx,
-                            leaf_width=width,
-                            leaf_center=center,
-                            picket_spacing=picket_spacing,
-                            orientation=self.orientation,
-                            leaf_analysis_width_ratio=leaf_analysis_width_ratio,
-                            tolerance=tolerance,
-                            action_tolerance=action_tolerance,
-                            leaf_num=leaf_num,
-                            approx_peak_val=picket_peak_val,
-                            image_window=window,
-                            image=self.image,
-                            fwxm=fwxm,
-                            separate_leaves=separate_leaves,
-                            nominal_gap_mm=nominal_gap_mm,
-                        )
-                    )
-        if not self.mlc_meas:
-            raise ValueError(
-                "No MLC measurements were found. This may be due to an incorrect inversion. Try setting invert=True. Or, you may have passed an incorrect orientation."
-            )
-
-        # drop any leaf rows that don't have the right amount of MLC kisses (i.e. near edge where one is dropped)
-        median_num_leaves = (
-            Enumerable(self.mlc_meas)
-            .group_by(key=lambda m: m.leaf_num)
-            .median(lambda m: len(m))
-        )
-        full_leaves = (
-            Enumerable(self.mlc_meas)
-            .group_by(key=lambda m: m.leaf_num)
-            .where(lambda m: len(m) == median_num_leaves)
-            .select_many(lambda m: m)
-            .select(lambda m: m.leaf_num)
-            .distinct()
-            .to_list()
-        )
-        self.mlc_meas = [m for m in self.mlc_meas if m.leaf_num in full_leaves]
-        if any([True for m in self.mlc_meas if m.leaf_num not in full_leaves]):
-            warnings.warn(
-                "Some leaves were removed from analysis because they were not detected for all pickets. If some valid leaves are missing try adjusting height_threshold or edge_threshold"
-            )
-
-        # retrospectively create the pickets and update the individual MLC measurements so error can be calculated
-        self.pickets = []
-        for picket_num, _ in enumerate(peak_idxs):
-            self.pickets.append(
-                Picket(
-                    [m for m in self.mlc_meas if m.picket_num == picket_num],
-                    log_fits=self._log_fits,
-                    orientation=self.orientation,
-                    image=self.image,
-                    tolerance=tolerance,
-                    nominal_gap=nominal_gap_mm,
-                    separate_leaves=separate_leaves,
-                )
-            )
-
-        self._is_analyzed = True
-
-    def _is_mlc_peak_in_window(
-        self, window, height_threshold, edge_threshold, picket_peak_val
-    ) -> bool:
-        """Whether the MLC peak is inside the given window. E.g. the jaw could be closed or at an edge."""
-        if self.orientation == Orientation.UP_DOWN:
-            std = np.std(window, axis=1)
-        else:
-            std = np.std(window, axis=0)
-        is_above_height_threshold = np.max(window) > height_threshold * picket_peak_val
-        is_not_at_edge = max(std) < edge_threshold * np.median(std)
-        return is_above_height_threshold and is_not_at_edge
-
-    def _get_mlc_window(
-        self, leaf_center, leaf_width, approx_idx, spacing
-    ) -> np.ndarray:
-        """A small 2D window of the image that contains the area around the picket."""
-        leaf_width_px = leaf_width * self.image.dpmm
-        leaf_center_px = leaf_center * self.image.dpmm + (
-            self.image.shape[0] / 2
-            if self.orientation == Orientation.UP_DOWN
-            else self.image.shape[1] / 2
-        )
-        if self.orientation == Orientation.UP_DOWN:
-            # crop edges to image boundary if need be; if the pickets are too close to edge we could spill outside
-            left_edge = max(int(approx_idx - spacing / 2), 0)
-            right_edge = min(int(approx_idx + spacing / 2), self.image.shape[1])
-            top_edge = max(int(leaf_center_px - leaf_width_px / 2), 0)
-            bottom_edge = min(
-                int(leaf_center_px + leaf_width_px / 2), self.image.shape[0]
-            )
-            array = self.image[top_edge:bottom_edge, left_edge:right_edge]
-        else:
-            top_edge = max(int(approx_idx - spacing / 2), 0)
-            bottom_edge = min(int(approx_idx + spacing / 2), self.image.shape[0])
-            left_edge = max(int(leaf_center_px - leaf_width_px / 2), 0)
-            right_edge = min(
-                int(leaf_center_px + leaf_width_px / 2), self.image.shape[1]
-            )
-            array = self.image[top_edge:bottom_edge, left_edge:right_edge]
-        return array
-
-    def _leaves_in_view(self, analysis_width) -> list[tuple[int, int, int]]:
-        """Crop the leaves if not all leaves are in view."""
-        range = (
-            self.image.shape[0] / 2
-            if self.orientation == Orientation.UP_DOWN
-            else self.image.shape[1] / 2
-        )
-        # cut off the edge so that we're not halfway through a leaf.
-        range -= (
-            max(
-                self.mlc.widths[0] * analysis_width,
-                self.mlc.widths[-1] * analysis_width,
-            )
-            * self.image.dpmm
-        )
-        leaves = [
-            i
-            for i, c in enumerate(self.mlc.centers)
-            if abs(c) < (range / self.image.dpmm)
-        ]
-        return [
-            (leaf_num, center, width)
-            for leaf_num, center, width in zip(
-                leaves,
-                self.mlc.centers[leaves[0] : leaves[-1] + 1],
-                self.mlc.widths[leaves[0] : leaves[-1] + 1],
-            )
-        ]
-
-    def plot_analyzed_image(
-        self,
-        guard_rails: bool = True,
-        mlc_peaks: bool = True,
-        overlay: bool = True,
-        leaf_error_subplot: bool = True,
-        show: bool = True,
-        figure_size: str | tuple = "auto",
-    ) -> None:
-        """Plot the analyzed image.
-
-        Parameters
-        ----------
-        guard_rails
-            Do/don't plot the picket "guard rails" around the ideal picket
-        mlc_peaks
-            Do/don't plot the detected MLC peak positions.
-        overlay
-            Do/don't plot the alpha overlay of the leaf status.
-        leaf_error_subplot
-            If True, plots a linked leaf error subplot adjacent to the PF image plotting the average and standard
-            deviation of leaf error.
-        show
-            Whether to display the plot. Set to false for saving to a figure, etc.
-        figure_size
-            Either 'auto' or a tuple. If auto, the figure size is set depending on the orientation. If a tuple, this is the
-            figure size to use.
-        """
-        if not self._is_analyzed:
-            raise RuntimeError("The image must be analyzed first. Use .analyze().")
-
-        # plot the image
-        if figure_size == "auto":
-            if self.orientation == Orientation.UP_DOWN:
-                figure_size = (12, 8)
-            else:
-                figure_size = (9, 9)
-        fig, ax = plt.subplots(figsize=figure_size)
-        ax.imshow(self.image.array, cmap=get_dicom_cmap())
-
-        if leaf_error_subplot:
-            self._add_leaf_error_subplot(ax)
-
-        if guard_rails:
-            for picket in self.pickets:
-                picket.add_guards_to_axes(ax.axes)
-        if mlc_peaks:
-            for mlc_meas in self.mlc_meas:
-                mlc_meas.plot2axes(ax.axes, width=1.5)
-
-        if overlay:
-            for mlc_meas in self.mlc_meas:
-                mlc_meas.plot_overlay2axes(ax.axes)
-
-        # plot CAX
-        ax.plot(
-            self.image.center.x, self.image.center.y, "r+", ms=12, markeredgewidth=3
-        )
-
-        # tighten up the plot view
-        ax.set_xlim([0, self.image.shape[1]])
-        ax.set_ylim([0, self.image.shape[0]])
-        ax.axis("off")
-
-        if show:
-            plt.show()
-
-    def _add_leaf_error_subplot(self, ax: plt.Axes) -> None:
-        """Add a bar subplot showing the leaf error."""
-
-        # make the new axis
-        divider = make_axes_locatable(ax)
-        if self.orientation == Orientation.UP_DOWN:
-            axtop = divider.append_axes("right", 2, pad=1, sharey=ax)
-        else:
-            axtop = divider.append_axes("bottom", 2, pad=1, sharex=ax)
-
-        # get leaf positions, errors, standard deviation, and leaf numbers
-        if self.orientation == Orientation.UP_DOWN:
-            pos = [
-                position.marker_lines[0].center.y
-                for position in self.pickets[0].mlc_meas
-            ]
-        else:
-            pos = [
-                position.marker_lines[0].center.x
-                for position in self.pickets[0].mlc_meas
-            ]
-
-        # calculate the error and stdev values per MLC pair
-        error_stdev = []
-        error_vals = []
-        for leaf_num in {m.leaf_num for m in self.mlc_meas}:
-            error_vals.append(
-                np.mean(
-                    [np.abs(m.error) for m in self.mlc_meas if m.leaf_num == leaf_num]
-                )
-            )
-            error_stdev.append(
-                np.std([m.error for m in self.mlc_meas if m.leaf_num == leaf_num])
-            )
-
-        # plot the leaf errors as a bar plot
-        if self.orientation == Orientation.UP_DOWN:
-            axtop.barh(
-                pos,
-                error_vals,
-                xerr=error_stdev,
-                height=self.leaf_analysis_width * 2,
-                alpha=0.4,
-                align="center",
-            )
-            # plot the tolerance line(s)
-            axtop.axvline(self.tolerance, color="r", linewidth=3)
-            if self.action_tolerance is not None:
-                axtop.axvline(self.action_tolerance, color="m", linewidth=3)
-            # reset xlims to comfortably include the max error or tolerance value
-            axtop.set_xlim(
-                [0, max([max(error_vals) + max(error_stdev), self.tolerance]) + 0.1]
-            )
-        else:
-            axtop.bar(
-                pos,
-                error_vals,
-                yerr=error_stdev,
-                width=self.leaf_analysis_width * 2,
-                alpha=0.4,
-                align="center",
-            )
-            # plot the tolerance line(s)
-            axtop.axhline(self.tolerance, color="r", linewidth=3)
-            if self.action_tolerance is not None:
-                axtop.axhline(self.action_tolerance, color="m", linewidth=3)
-            axtop.set_ylim(
-                [0, max([max(error_vals) + max(error_stdev), self.tolerance]) + 0.1]
-            )
-
-        axtop.grid(True)
-        axtop.set_title("Average Error (mm)")
-
-    def save_analyzed_image(
-        self,
-        filename: str | io.BytesIO,
-        guard_rails: bool = True,
-        mlc_peaks: bool = True,
-        overlay: bool = True,
-        leaf_error_subplot: bool = False,
-        **kwargs,
-    ) -> None:
-        """Save the analyzed figure to a file. See :meth:`~pylinac.picketfence.PicketFence.plot_analyzed_image()` for
-        further parameter info.
-        """
-        self.plot_analyzed_image(
-            guard_rails,
-            mlc_peaks,
-            overlay,
-            leaf_error_subplot=leaf_error_subplot,
-            show=False,
-        )
-        plt.savefig(filename, **kwargs)
-        if isinstance(filename, str):
-            print(f"Picket fence image saved to: {osp.abspath(filename)}")
-
-    def results(self, as_list: bool = False) -> str:
-        """Return results of analysis. Use with print()."""
-        offsets = " ".join(f"{pk.dist2cax:.1f}" for pk in self.pickets)
-        results = [
-            "Picket Fence Results:",
-            f"Gantry Angle (\N{DEGREE SIGN}): {self.image.gantry_angle:2.1f}",
-            f"Collimator Angle (\N{DEGREE SIGN}): {self.image.collimator_angle:2.1f}",
-            f"Tolerance (mm): {self.tolerance}",
-            f"Leaves passing (%): {self.percent_passing:2.1f}",
-            f"Absolute median error (mm): {self.abs_median_error:2.3f}mm",
-            f"Mean picket spacing (mm): {self.mean_picket_spacing:2.1f}mmn",
-            f"Picket offsets from CAX (mm): {offsets}",
-            f"Max Error: {self.max_error:2.3f}mm on Picket: {self.max_error_picket}, Leaf: {self.max_error_leaf}",
-        ]
-        if self.failed_leaves():
-            results.append(f"Failing leaves: {self.failed_leaves()}")
-        if not as_list:
-            results = "\n".join(results)
-        return results
-
-    def results_data(self, as_dict=False) -> PFResult | dict:
-        """Present the results data and metadata as a dataclass, dict, or tuple.
-        The default return type is a dataclass."""
-        picket_widths = {
-            f"picket_{pk}": {
-                key: self.picket_width_stat(pk, key)
-                for key in ("max", "mean", "median", "min")
-            }
-            for pk in range(len(self.pickets))
-        }
-        data = PFResult(
-            tolerance_mm=self.tolerance,
-            action_tolerance_mm=self.action_tolerance,
-            percent_leaves_passing=self.percent_passing,
-            number_of_pickets=self.num_pickets,
-            absolute_median_error_mm=self.abs_median_error,
-            max_error_mm=self.max_error,
-            max_error_picket=self.max_error_picket,
-            max_error_leaf=self.max_error_leaf,
-            mean_picket_spacing_mm=self.mean_picket_spacing,
-            offsets_from_cax_mm=[pk.dist2cax for pk in self.pickets],
-            passed=self.passed,
-            failed_leaves=self.failed_leaves(),
-            mlc_skew=self.mlc_skew(),
-            picket_widths=picket_widths,
-        )
-        if as_dict:
-            return dataclasses.asdict(data)
-        return data
-
-    def publish_pdf(
-        self,
-        filename: str | io.BytesIO,
-        notes: str = None,
-        open_file: bool = False,
-        metadata: dict = None,
-        bins: int = 10,
-        logo: Path | str | None = None,
-    ) -> None:
-        """Publish (print) a PDF containing the analysis, images, and quantitative results.
-
-        Parameters
-        ----------
-        filename : (str, file-like object}
-            The file to write the results to.
-        notes : str, list of strings
-            Text; if str, prints single line.
-            If list of strings, each list item is printed on its own line.
-        open_file : bool
-            Whether to open the file using the default program after creation.
-        metadata : dict
-            Extra data to be passed and shown in the PDF. The key and value will be shown with a colon.
-            E.g. passing {'Author': 'James', 'Unit': 'TrueBeam'} would result in text in the PDF like:
-            --------------
-            Author: James
-            Unit: TrueBeam
-            --------------
-        bins: int
-            Number of bins to show for the histogram
-        logo: Path, str
-            A custom logo to use in the PDF report. If nothing is passed, the default pylinac logo is used.
-        """
-        plt.ioff()
-        canvas = pdf.PylinacCanvas(
-            filename, page_title="Picket Fence Analysis", metadata=metadata, logo=logo
-        )
-        data = io.BytesIO()
-        self.save_analyzed_image(data, leaf_error_subplot=True)
-        canvas.add_image(data, location=(3, 5), dimensions=(15, 15))
-        if metadata:
-            canvas.add_text(
-                text=self.results(as_list=True), location=(1.5, 22), font_size=14
-            )
-        else:
-            canvas.add_text(
-                text=self.results(as_list=True), location=(1.5, 25), font_size=14
-            )
-        if notes is not None:
-            canvas.add_text(text="Notes:", location=(1, 5.5), font_size=14)
-            canvas.add_text(text=notes, location=(1, 5))
-
-        canvas.add_new_page()
-        hist = io.BytesIO()
-        self.save_histogram(hist, bins)
-        canvas.add_image(hist, location=(3, 8), dimensions=(15, 15))
-        canvas.finish()
-
-        if open_file:
-            webbrowser.open(filename)
-
-    def mlc_skew(self) -> float:
-        """Apparent rotation in degrees of the MLC. This could be conflated with the EPID skew, so be careful when interpreting this value."""
-        return float(np.mean([p.skew() for p in self.pickets]))
-
-    def plot_histogram(self, bins: int = 10, show: bool = True) -> None:
-        """Plot a histogram of the leaf errors"""
-        if not self._is_analyzed:
-            raise ValueError(
-                "It appears the PF image has not been analyzed yet. Use .analyze() first."
-            )
-        errors = Enumerable(self.mlc_meas).select_many(lambda m: m.error).to_list()
-        fig, ax = plt.subplots()
-        ax.axvline(self.tolerance, color="r", linewidth=3)
-        ax.axvline(-self.tolerance, color="r", linewidth=3)
-        ax.grid(True)
-        if self.action_tolerance is not None:
-            ax.axvline(self.action_tolerance, color="m", linewidth=3)
-            ax.axvline(-self.action_tolerance, color="m", linewidth=3)
-        ax.set_title("Leaf error histogram")
-        ax.set_ylabel("Counts")
-        ax.set_xlabel("Error (mm)")
-        ax.hist(errors, bins=bins)
-        if show:
-            plt.show()
-
-    def save_histogram(
-        self, filename: [str, Path, BinaryIO], bins: int = 10, **kwargs
-    ) -> None:
-        """Save a histogram of the leaf errors"""
-        self.plot_histogram(bins, show=False)
-        plt.savefig(filename, **kwargs)
-        if not isinstance(filename, BytesIO):
-            print(f"Picket fence histogram saved to: {osp.abspath(filename)}")
-
-    @cached_property
-    def orientation(self) -> Orientation:
-        """The orientation of the image, either Up-Down or Left-Right."""
-        # if orientation was passed in, use it
-        if self._orientation is not None:
-            return convert_to_enum(self._orientation, Orientation)
-
-        # replace any dead pixels with median value
-        temp_image = self.image.array.copy()
-        temp_image[temp_image < np.median(temp_image)] = np.median(temp_image)
-
-        # find "range" of 80 to 90th percentiles
-        row_sum = np.sum(temp_image, 0)
-        col_sum = np.sum(temp_image, 1)
-        row80, row90 = np.percentile(row_sum, [85, 99])
-        col80, col90 = np.percentile(col_sum, [85, 99])
-        row_range = row90 - row80
-        col_range = col90 - col80
-
-        # The true picket side will have a greater difference in
-        # percentiles than will the non-picket size.
-        if row_range < col_range:
-            orientation = Orientation.LEFT_RIGHT
-        else:
-            orientation = Orientation.UP_DOWN
-        return orientation
-
-
-class MLCValue:
-    def __init__(
-        self,
-        picket_num: int,
-        approx_idx: int,
-        leaf_width: float,
-        leaf_center: float,
-        picket_spacing: float,
-        orientation: Orientation,
-        leaf_analysis_width_ratio: float,
-        tolerance: float,
-        action_tolerance: float | None,
-        leaf_num: int,
-        approx_peak_val: float,
-        image_window: np.ndarray,
-        image: PFDicomImage,
-        fwxm: int,
-        separate_leaves: bool,
-        nominal_gap_mm: float,
-    ):
-        """Representation of an MLC kiss or of each MLC about a kiss."""
-        self._approximate_idx = approx_idx
-        self.picket_num = picket_num
-        self._approximate_peak_vale = approx_peak_val
-        self.leaf_width_px = leaf_width * image.dpmm
-        self._leaf_center = leaf_center
-        self.leaf_center_px = leaf_center * image.dpmm + (
-            image.shape[0] / 2
-            if orientation == Orientation.UP_DOWN
-            else image.shape[1] / 2
-        )
-        self.leaf_num = leaf_num
-        self._image_window = image_window
-        self._image = image
-        self._fwxm = fwxm
-        self._analysis_ratio: float = leaf_analysis_width_ratio
-        self._spacing: float = picket_spacing
-        self._orientation = orientation
-        self._tolerance: float = tolerance
-        self._action_tolerance: float = action_tolerance
-        self._separate_leaves = separate_leaves
-        self._nominal_gap_mm = nominal_gap_mm
-        self.profile: FWXMProfilePhysical
-        self.position = self.get_peak_positions()
-        self._fit = None
-
-    def __repr__(self) -> str:
-        return f"Leaf: {self.leaf_num}, Picket: {self.picket_num}"
-
-    @property
-    def full_leaf_nums(self) -> Sequence[str | int]:
-        """The fully-qualified leaf names. This will be the simple leaf number for traditional analysis or the bank+leaf num for separate leaves."""
-        if not self._separate_leaves:
-            return [
-                self.leaf_num,
-            ]
-        else:
-            return [
-                f"{LEFT_MLC_PREFIX}{self.leaf_num}",
-                f"{RIGHT_MLC_PREFIX}{self.leaf_num}",
-            ]
-
-    def plot2axes(self, axes: plt.Axes, width: float | int = 1) -> None:
-        """Plot the measurement to the axes."""
-        for idx, line in enumerate(self.marker_lines):
-            line.plot2axes(axes, width, color=self.bg_color[idx])
-
-    def get_peak_positions(self) -> Sequence[float]:
-        if self._orientation == Orientation.UP_DOWN:
-            pix_vals = np.median(self._image_window, axis=0)
-        else:
-            pix_vals = np.median(self._image_window, axis=1)
-        prof = FWXMProfilePhysical(
-            values=pix_vals,
-            ground=True,
-            normalization=Normalization.MAX,
-            dpmm=self._image.dpmm,
-        )
-        self.profile = prof
-        if self._separate_leaves:
-            left = prof.field_edge_idx(side="left") + max(
-                self._approximate_idx - self._spacing / 2, 0
-            )
-            right = prof.field_edge_idx(side="right") + max(
-                self._approximate_idx - self._spacing / 2, 0
-            )
-            return left, right
-        else:
-            return (
-                prof.center_idx + max(self._approximate_idx - self._spacing / 2, 0),
-            )  # crop to left edge if need be
-
-    @property
-    def passed(self) -> Sequence[bool]:
-        """Whether the MLC kiss or leaf was within tolerance."""
-        return [abs(error) < self._tolerance for error in self.error]
-
-    @property
-    def passed_action(self) -> Sequence[bool] | None:
-        """Whether the MLC kiss or leaf was within the action tolerance."""
-        return (
-            [abs(error) < self._action_tolerance for error in self.error]
-            if self._action_tolerance is not None
-            else [True, True]
-        )
-
-    @property
-    def bg_color(self) -> Sequence[str]:
-        """The color of the measurement when the PF image is plotted, based on pass/fail status."""
-        colors = []
-        for idx, passed in enumerate(self.passed):
-            if not passed:
-                colors.append("r")
-            elif self._action_tolerance is not None:
-                colors.append("b" if self.passed_action[idx] else "m")
-            else:
-                colors.append("b")
-        return colors
-
-    @property
-    def picket_positions(self) -> Sequence[float]:
-        """The position(s) of the pickets in mm"""
-        picket_pos = []
-        for line, sign in zip(self.marker_lines, (-1, 1)):
-            if self._orientation == Orientation.UP_DOWN:
-                picket = self._fit(line.center.y)
-            else:
-                picket = self._fit(line.center.x)
-            if (
-                self._separate_leaves
-            ):  # offset the picket position by the DLG and nominal gap
-                mag_factor = self._image.sid / 1000
-                picket += (
-                    sign * self._nominal_gap_mm * mag_factor / 2 * self._image.dpmm
-                )
-            picket_pos.append(picket / self._image.dpmm)
-        return picket_pos
-
-    def plot_detailed_profile(self) -> plt.Axes:
-        if self._orientation == Orientation.UP_DOWN:
-            pix_vals = np.median(self._image_window, axis=0)
-        else:
-            pix_vals = np.median(self._image_window, axis=1)
-        offset_pixels = max(self._approximate_idx - self._spacing / 2, 0)
-        x_values = np.array(range(len(pix_vals))) + offset_pixels
-
-        fig, ax = plt.subplots()
-        ax.plot(x_values, pix_vals)
-        for picket_pos in self.picket_positions:
-            ax.axvline(
-                x=picket_pos * self._image.dpmm,
-                label="Fitted picket location",
-                color="black",
-            )
-        for pos, bg_color in zip(self.get_peak_positions(), self.bg_color):
-            ax.axvline(pos, color=bg_color, label="Measured MLC position")
-        return ax
-
-    @property
-    def error(self) -> Sequence[float]:
-        """The error (difference) of the MLC measurement and the picket fit.
-        If using individual leaf analysis, returns both errors otherwise return one."""
-        errors = []
-        for line, sign in zip(self.marker_lines, (-1, 1)):
-            if self._orientation == Orientation.UP_DOWN:
-                picket_pos = self._fit(line.center.y)
-                mlc_pos = line.center.x
-            else:
-                picket_pos = self._fit(line.center.x)
-                mlc_pos = line.center.y
-            if (
-                self._separate_leaves
-            ):  # offset the picket position by the DLG and nominal gap
-                mag_factor = self._image.sid / 1000
-                picket_pos += (
-                    sign * self._nominal_gap_mm * mag_factor / 2 * self._image.dpmm
-                )
-            errors.append((mlc_pos - picket_pos) / self._image.dpmm)
-        return errors
-
-    @property
-    def max_abs_error(self) -> float:
-        """The maximum absolute error"""
-        return np.max(np.abs([self.error]))
-
-    @property
-    def marker_lines(self) -> list[Line]:
-        """The line(s) representing the MLC measurement position. When using separated leaves
-        there are two lines. Traditional analysis returns one."""
-        upper_point = (
-            self.leaf_center_px - self.leaf_width_px / 2 * self._analysis_ratio
-        )
-        lower_point = (
-            self.leaf_center_px + self.leaf_width_px / 2 * self._analysis_ratio
-        )
-
-        lines = []
-        for mlc_position in self.position:
-            if self._orientation == Orientation.UP_DOWN:
-                line = Line((mlc_position, upper_point), (mlc_position, lower_point))
-            else:
-                line = Line((upper_point, mlc_position), (lower_point, mlc_position))
-            lines.append(line)
-        return lines
-
-    def plot_overlay2axes(self, axes) -> None:
-        """Create a rectangle overlay with the width of the error. I.e. it stretches from the picket fit to the MLC position. Gives more visual size to the"""
-        # calculate height (based on leaf analysis ratio)
-        upper_point = (
-            self.leaf_center_px - self.leaf_width_px / 2 * self._analysis_ratio
-        )
-        lower_point = (
-            self.leaf_center_px + self.leaf_width_px / 2 * self._analysis_ratio
-        )
-        height = abs(upper_point - lower_point) * 0.8
-
-        for idx, line in enumerate(self.marker_lines):
-            width = abs(self.error[idx]) * self._image.dpmm
-            y = line.center.y
-            x = self.position[idx] - (self.error[idx] * self._image.dpmm) / 2
-
-            if self._orientation == Orientation.UP_DOWN:
-                r = Rectangle(width, height, center=(x, y))
-                # if any of the values are over tolerance, show another larger rectangle to draw the eye
-                if not self.passed[idx] or not self.passed_action[idx]:
-                    re = Rectangle(
-                        self._image_window.shape[1] * 0.2, height * 1.2, center=(x, y)
-                    )
-                    re.plot2axes(
-                        axes,
-                        edgecolor="none",
-                        fill=True,
-                        alpha=0.5,
-                        facecolor=self.bg_color[idx],
-                    )
-            else:
-                r = Rectangle(height, width, center=(x, y))
-                if not self.passed[idx] or not self.passed_action[idx]:
-                    re = Rectangle(
-                        self._image_window.shape[1] * 0.2, height * 1.2, center=(x, y)
-                    )
-                    re.plot2axes(
-                        axes,
-                        edgecolor="none",
-                        fill=True,
-                        alpha=0.5,
-                        facecolor=self.bg_color[idx],
-                    )
-            r.plot2axes(
-                axes, edgecolor="none", fill=True, alpha=1, facecolor=self.bg_color[idx]
-            )
-
-
-class Picket:
-    """Holds picket information in a Picket Fence test."""
-
-    def __init__(
-        self,
-        mlc_measurements: list[MLCValue],
-        log_fits,
-        orientation: Orientation,
-        image: PFDicomImage,
-        tolerance: float,
-        separate_leaves: bool,
-        nominal_gap: float,
-    ):
-        self.mlc_meas: list[MLCValue] = mlc_measurements
-        self.log_fits = log_fits
-        self.tolerance = tolerance
-        self.orientation = orientation
-        self.image = image
-        self._separate_leaves = separate_leaves
-        self._nominal_gap = nominal_gap
-        self.fit = self.get_fit()
-        for m in self.mlc_meas:
-            m._fit = self.fit
-
-    def get_fit(self) -> np.poly1d:
-        """The fit of a polynomial to the MLC measurements."""
-        if self.log_fits is not None:
-            return next(self.log_fits)
-        x = (
-            Enumerable(self.mlc_meas)
-            .select_many(lambda m: [line.point1.y for line in m.marker_lines])
-            .to_list()
-        )
-        y = (
-            Enumerable(self.mlc_meas)
-            .select_many(lambda m: [line.point1.x for line in m.marker_lines])
-            .to_list()
-        )
-        if self.orientation == Orientation.UP_DOWN:
-            fit = np.polyfit(x, y, 1)
-        else:
-            fit = np.polyfit(y, x, 1)
-        return np.poly1d(fit)
-
-    def skew(self) -> float:
-        """The slope/skew of the picket"""
-        return float(np.rad2deg(self.fit.coefficients[0]))
-
-    @property
-    def dist2cax(self) -> float:
-        """The distance from the CAX to the picket, in mm."""
-        # TODO: see about using line and built-in dist to point.
-        center_fit = np.poly1d(self.fit)
-        if self.orientation == Orientation.UP_DOWN:
-            length = self.image.shape[0]
-        else:
-            length = self.image.shape[1]
-        x_data = np.arange(length)
-        y_data = center_fit(x_data)
-        idx = int(round(len(x_data) / 2))
-        if self.orientation == Orientation.UP_DOWN:
-            axis = "x"
-            p1 = Point(y_data[idx], x_data[idx])
-        else:
-            axis = "y"
-            p1 = Point(x_data[idx], y_data[idx])
-        return (getattr(self.image.center, axis) - getattr(p1, axis)) / self.image.dpmm
-
-    @property
-    def left_guard_separated(self) -> Sequence[np.poly1d]:
-        """The line representing the left-sided guard rails.
-        When not doing separate analysis, the left and right rails will overlap."""
-        l_fit = np.copy(self.fit)
-        l_fit[-1] += self.tolerance * self.image.dpmm
-        if not self._separate_leaves:
-            return [
-                np.poly1d(l_fit),
-            ]
-        else:
-            other_fit = copy.copy(l_fit)
-            mag_factor = self.image.sid / 1000
-            l_fit[-1] += self._nominal_gap * mag_factor / 2 * self.image.dpmm
-            other_fit[-1] -= self._nominal_gap * mag_factor / 2 * self.image.dpmm
-            return [np.poly1d(l_fit), np.poly1d(other_fit)]
-
-    @property
-    def right_guard_separated(self):
-        """The line representing the right-sided guard rails."""
-        r_fit = np.copy(self.fit)
-        r_fit[-1] -= self.tolerance * self.image.dpmm
-        if not self._separate_leaves:
-            return [
-                np.poly1d(r_fit),
-            ]
-        else:
-            other_fit = copy.copy(r_fit)
-            mag_factor = self.image.sid / 1000
-            r_fit[-1] -= self._nominal_gap * mag_factor / 2 * self.image.dpmm
-            other_fit[-1] += self._nominal_gap * mag_factor / 2 * self.image.dpmm
-            return [np.poly1d(r_fit), np.poly1d(other_fit)]
-
-    def add_guards_to_axes(self, axis: plt.Axes, color: str = "g") -> None:
-        """Plot guard rails to the axis."""
-        if self.orientation == Orientation.UP_DOWN:
-            length = self.image.shape[0]
-        else:
-            length = self.image.shape[1]
-        x_data = np.arange(length)
-        left_y_data = self.left_guard_separated
-        right_y_data = self.right_guard_separated
-        for left, right in zip(left_y_data, right_y_data):
-            if self.orientation == Orientation.UP_DOWN:
-                axis.plot(left(x_data), x_data, color=color)
-                axis.plot(right(x_data), x_data, color=color)
-            else:
-                axis.plot(x_data, left(x_data), color=color)
-                axis.plot(x_data, right(x_data), color=color)
+"""The picket fence module is meant for analyzing EPID images where a "picket fence" MLC pattern has been made.
+Physicists regularly check MLC positioning through this test. This test can be done using film and one can
+"eyeball" it, but this is the 21st century and we have numerous ways of quantifying such data. This module
+attains to be one of them. It can load in an EPID dicom image (or superimpose multiple images) and determine the MLC peaks, error of each MLC
+pair to the picket, and give a few visual indicators for passing/warning/failing.
+
+Features:
+
+* **Analyze any MLC type** - Both default MLCs and custom MLCs can be used.
+* **Easy-to-read pass/warn/fail overlay** - Analysis gives you easy-to-read tools for determining the status of an MLC pair.
+* **Any Source-to-Image distance** - Whatever your clinic uses as the SID for picket fence, pylinac can account for it.
+* **Account for panel translation** - Have an off-CAX setup? No problem. Translate your EPID and pylinac knows.
+* **Account for panel sag** - If your EPID sags at certain angles, just tell pylinac and the results will be shifted.
+"""
+from __future__ import annotations
+
+import copy
+import enum
+import io
+import os.path as osp
+import statistics
+import warnings
+import webbrowser
+from functools import cached_property
+from io import BytesIO
+from itertools import cycle
+from pathlib import Path
+from typing import BinaryIO, Iterable, Sequence
+
+import matplotlib.pyplot as plt
+import numpy as np
+from mpl_toolkits.axes_grid1 import make_axes_locatable
+from py_linq import Enumerable
+
+from . import Normalization
+from .core import image, pdf
+from .core.geometry import Line, Point, Rectangle
+from .core.io import get_url, retrieve_demo_file
+from .core.profile import FWXMProfilePhysical, MultiProfile
+from .core.utilities import ResultBase, ResultsDataMixin, convert_to_enum
+from .log_analyzer import load_log
+from .metrics.image import SizedDiskLocator
+
+LEFT_MLC_PREFIX = "A"
+RIGHT_MLC_PREFIX = "B"
+
+
+class Orientation(enum.Enum):
+    """Possible orientations of the image"""
+
+    UP_DOWN = "Up-Down"  #:
+    LEFT_RIGHT = "Left-Right"  #:
+
+
+class MLCArrangement:
+    """Construct an MLC array"""
+
+    def __init__(self, leaf_arrangement: list[tuple[int, float]], offset: float = 0):
+        """
+
+        Parameters
+        ----------
+        leaf_arrangement
+            Description of the leaf arrangement. List of tuples containing the number of leaves and leaf width.
+            E.g. (10, 5) is 10 leaves with 5mm widths.
+        offset
+            The offset in mm of the leaves. Used for asymmetric arrangements. E.g. -2.5mm will shift the arrangement 2.5mm to the left.
+        """
+        self.centers = []
+        self.widths = []
+        rolling_edge = 0
+        for leaf_num, width in leaf_arrangement:
+            self.centers += np.arange(
+                start=rolling_edge + width / 2,
+                stop=leaf_num * width + rolling_edge + width / 2,
+                step=width,
+            ).tolist()
+            rolling_edge = self.centers[-1] + width / 2
+            self.widths += [width] * leaf_num
+        self.centers = [c - np.mean(self.centers) + offset for c in self.centers]
+
+    @property
+    def leaves(self) -> list[int]:
+        """The leaf numbers; index pairs with the centers. Assumes that
+        the first leaf center is toward the target and the last leaf center is towards the gun.
+        """
+        return np.arange(1, len(self.centers) + 1, dtype=int)[::-1].tolist()
+
+
+class MLC(enum.Enum):
+    """The pre-built MLC types"""
+
+    MILLENNIUM = {
+        "name": "Millennium",
+        "arrangement": MLCArrangement([(10, 10), (40, 5), (10, 10)]),
+    }  #:
+    HD_MILLENNIUM = {
+        "name": "HD Millennium",
+        "arrangement": MLCArrangement([(10, 5), (40, 2.5), (10, 5)]),
+    }  #:
+    BMOD = {
+        "name": "B Mod",
+        "arrangement": MLCArrangement([(40, 4)]),
+    }  #:
+    AGILITY = {
+        "name": "Agility",
+        "arrangement": MLCArrangement([(80, 5)]),
+    }  #:
+    MLCI = {
+        "name": "MLCi",
+        "arrangement": MLCArrangement([(40, 10)]),
+    }  #:
+    # Halcyon reference
+    # https://aapm.onlinelibrary.wiley.com/doi/pdf/10.1002/acm2.12568
+    HALCYON_DISTAL = {
+        "name": "Halcyon distal",
+        "arrangement": MLCArrangement([(28, 10)]),
+    }  #:
+    HALCYON_PROXIMAL = {
+        "name": "Halcyon proximal",
+        "arrangement": MLCArrangement([(29, 10)]),
+    }  #:
+
+
+class PFResult(ResultBase):
+    """This class should not be called directly. It is returned by the ``results_data()`` method.
+    It is a dataclass under the hood and thus comes with all the dunder magic.
+
+    Use the following attributes as normal class attributes."""
+
+    tolerance_mm: float  #:
+    action_tolerance_mm: float | None  #:
+    percent_leaves_passing: float  #:
+    number_of_pickets: int  #:
+    absolute_median_error_mm: float  #:
+    max_error_mm: float  #:
+    max_error_picket: int  #:
+    max_error_leaf: str | int  #:
+    mean_picket_spacing_mm: float  #:
+    offsets_from_cax_mm: list[float]  #:
+    passed: bool  #:
+    failed_leaves: list[str] | list[int]  #:
+    mlc_skew: float  #:
+    picket_widths: dict[str, dict[str, float]]  #:
+
+
+class PFDicomImage(image.LinacDicomImage):
+    """A subclass of a DICOM image that checks for noise and inversion when instantiated. Can also adjust for EPID sag."""
+
+    _central_axis: Point | None  #:
+
+    def __init__(self, path: str, **kwargs):
+        crop_mm = kwargs.pop("crop_mm", 3)
+        self._central_axis = kwargs.pop("central_axis", None)
+        super().__init__(path, **kwargs)
+        # crop the images so that Elekta images don't fail. See #168
+        crop_pixels = int(round(crop_mm * self.dpmm))
+        self.crop(pixels=crop_pixels)
+        # self.invert()  # EPID images are always inverted; rather than check inversion, just flip it.
+        self._check_for_noise()
+        # Possibly revert/change the below if inversion detection doesn't work so well
+        self.check_inversion(box_size=10, position=(0.01, 0.01))
+
+    def _check_for_noise(self) -> None:
+        """Check if the image has extreme noise (dead pixel, etc) by comparing
+        min/max to 1/99 percentiles and smoothing if need be."""
+        safety_stop = 5
+        while self._has_noise() and safety_stop > 0:
+            self.filter(size=3)
+            safety_stop -= 1
+
+    def _has_noise(self) -> bool:
+        """Helper method to determine if there is spurious signal in the image."""
+        min = self.array.min()
+        max = self.array.max()
+        near_min, near_max = np.percentile(self.array, [0.5, 99.5])
+        max_is_extreme = max > near_max * 1.25
+        min_is_extreme = (min < near_min * 0.75) and (
+            abs(min - near_min) > 0.1 * (near_max - near_min)
+        )
+        return max_is_extreme or min_is_extreme
+
+    def adjust_for_sag(self, sag: int, orientation: str | Orientation) -> None:
+        """Roll the image to adjust for EPID sag."""
+        orient = convert_to_enum(orientation, Orientation)
+        direction = "y" if orient == Orientation.UP_DOWN else "x"
+        self.roll(direction, sag)
+
+    @property
+    def center(self) -> Point:
+        """Override the central axis call in the event we passed it directly"""
+        if self._central_axis is not None:
+            # convert from physical to pixel
+            cax_shift = Point(
+                x=self._central_axis.x * self.dpmm, y=self._central_axis.y * self.dpmm
+            )
+            # shift from center to BB position
+            cax = super().center + cax_shift
+            # invert the y-axis for plotting purposes/consistency
+            cax.y = 2 * (self.shape[0] // 2) - cax.y
+            return cax
+        else:
+            return super().center
+
+
+class PicketFence(ResultsDataMixin[PFResult]):
+    """A class used for analyzing EPID images where radiation strips have been formed by the
+    MLCs. The strips are assumed to be parallel to one another and normal to the image edge;
+    i.e. a "left-right" or "up-down" orientation is assumed. Further work could follow up by accounting
+    for any angle.
+    """
+
+    _from_bb_setup: bool = False
+    _bb_image: image.LinacDicomImage | None = None
+    leaf_analysis_width: float  #:
+    mlc_meas: list  #:
+    pickets: list  #:
+    tolerance: float  #:
+    action_tolerance: float  #:
+    image: PFDicomImage  #:
+
+    def __init__(
+        self,
+        filename: str | Path | BinaryIO,
+        filter: int | None = None,
+        log: str | None = None,
+        use_filename: bool = False,
+        mlc: MLC | MLCArrangement | str = MLC.MILLENNIUM,
+        crop_mm: int = 3,
+        image_kwargs: dict | None = None,
+    ):
+        """
+        Parameters
+        ----------
+        filename
+            Name of the file as a string or a file-like object.
+        filter
+            If None (default), no filtering will be done to the image.
+            If an int, will perform median filtering over image of size ``filter``.
+        log
+            Path to a log file corresponding to the delivery. The expected fluence of the log file is
+            used to construct the pickets. MLC peaks are then compared to an absolute reference instead of
+            a fitted picket.
+        use_filename
+            If False (default), no action will be performed.
+            If True, the filename will be searched for keywords that describe the gantry and/or collimator angle.
+            For example, if set to True and the file name was "PF_gantry45.dcm" the gantry would be interpreted as being at 45 degrees.
+        mlc
+            The MLC model of the image. Must be an option from the enum :class:`~pylinac.picketfence.MLCs` or
+            an :class:`~pylinac.picketfence.MLCArrangement`.
+        crop_mm
+            The number of mm to crop from all edges. Elekta is infamous for having columns of dead pixels on the side of their images.
+            These need to be cleaned up first. For Varian images, this really shouldn't make a difference unless the pickets are
+            very close to the edge. Generally speaking, they shouldn't be for the best accuracy.
+        """
+
+        if filename is not None:
+            img_kwargs = image_kwargs or {}
+            self.image = PFDicomImage(
+                filename, use_filenames=use_filename, crop_mm=crop_mm, **img_kwargs
+            )
+            if isinstance(filter, int):
+                self.image.filter(size=filter)
+            self.image.ground()
+            self.image.normalize()
+        if log is not None:
+            self._load_log(log)
+        else:
+            self._log_fits = None
+        self._is_analyzed = False
+        self.mlc = self._get_mlc_arrangement(mlc)
+
+    @staticmethod
+    def _get_mlc_arrangement(value: MLC | MLCArrangement | str) -> MLCArrangement:
+        if isinstance(value, MLC):
+            return value.value["arrangement"]
+        if isinstance(value, MLCArrangement):
+            return value
+        if isinstance(value, str):
+            return [
+                member.value["arrangement"]
+                for name, member in MLC.__members__.items()
+                if member.value["name"] == value
+            ][0]
+
+    @classmethod
+    def from_url(cls, url: str, filter: int = None, image_kwargs: dict | None = None):
+        """Instantiate from a URL."""
+        filename = get_url(url, progress_bar=True)
+        return cls(filename, filter=filter, image_kwargs=image_kwargs)
+
+    @classmethod
+    def from_demo_image(cls, filter: int = None):
+        """Construct a PicketFence instance using the demo image."""
+        demo_file = retrieve_demo_file(name="AS1200.dcm")
+        return cls(demo_file, filter=filter)
+
+    @classmethod
+    def from_multiple_images(
+        cls,
+        path_list: Iterable[str | Path],
+        stretch_each: bool = True,
+        method: str = "mean",
+        mlc: MLC | MLCArrangement | str = MLC.MILLENNIUM,
+        **kwargs,
+    ):
+        """Load and superimpose multiple images and instantiate a PF object.
+
+        Parameters
+        ----------
+        path_list : iterable
+            An iterable of path locations to the files to be loaded/combined.
+        stretch_each : bool
+            Whether to stretch each image individually before combining. See ``load_multiples``.
+        method : {'sum', 'mean'}
+            The method to combine the images. See ``load_multiples``.
+        mlc : MLC, MLCArrangement, or str
+            The MLC model of the image. Must be an option from the enum :class:`~pylinac.picketfence.MLCs` or
+            an :class:`~pylinac.picketfence.MLCArrangement`.
+        kwargs
+            Passed to :func:`~pylinac.core.image.load_multiples` and to the PicketFence constructor.
+        """
+        with io.BytesIO() as stream:
+            img = image.load_multiples(
+                path_list,
+                stretch_each=stretch_each,
+                method=method,
+                loader=PFDicomImage,
+                **kwargs,
+            )
+            img.save(stream)
+            stream.seek(0)
+            # there is a parameter name mismatch between the PFDicomImage and PicketFence constructors
+            # Dicom uses "use_filenames" and PicketFence uses "use_filename" 
+            use_filename = kwargs.pop("use_filenames", False)
+            return cls(stream, mlc=mlc, use_filename=use_filename, **kwargs)
+
+    @classmethod
+    def from_bb_setup(
+        cls, *args, bb_image: str | Path | BinaryIO, bb_diameter: float, **kwargs
+    ):
+        """Construct a PicketFence instance using a BB setup image to find the CAX first.
+        The CAX of the PF image is then overridden w/ the BB location from the first image.
+
+        Thank the French for this."""
+        bb_image = image.load(bb_image)
+        caxs = bb_image.compute(
+            metrics=SizedDiskLocator.from_center_physical(
+                expected_position_mm=(0, 0),
+                search_window_mm=(30 + bb_diameter, 30 + bb_diameter),
+                radius_mm=bb_diameter / 2,
+                radius_tolerance_mm=bb_diameter * 0.1 + 1,
+            )
+        )
+        cax_shift = caxs[0] - bb_image.center
+        # we convert to physical because we may have images of different sizes/dpmms
+        cax_physical_shift = Point(
+            x=cax_shift.x / bb_image.dpmm, y=cax_shift.y / bb_image.dpmm
+        )
+        instance = cls(
+            *args, **kwargs, image_kwargs={"central_axis": cax_physical_shift}
+        )
+        instance._from_bb_setup = True
+        instance._bb_image = bb_image
+        return instance
+
+    @property
+    def passed(self) -> bool:
+        """Boolean specifying if all MLC positions were within tolerance."""
+        # nested all because each measurement returns a list of booleans. So all the passes of each measurement must all pass.
+        return all(all(m.passed) for m in self.mlc_meas)
+
+    @property
+    def percent_passing(self) -> float:
+        """Return the percentage of MLC positions under tolerance."""
+        num_meas = Enumerable(self.mlc_meas).select_many(lambda m: m.passed).count()
+        num_pass = (
+            Enumerable(self.mlc_meas)
+            .select_many(lambda m: m.passed)
+            .count(lambda p: bool(p) is True)
+        )
+        return float(100 * num_pass / num_meas)
+
+    @property
+    def max_error(self) -> float:
+        """Return the maximum error found."""
+        return float(np.max(np.abs(self._flattened_errors())))
+
+    @property
+    def max_error_picket(self) -> int:
+        """Return the picket number where the maximum error occurred."""
+        return (
+            Enumerable(self.mlc_meas)
+            .order_by_descending(lambda m: np.max(np.abs(m.error)))
+            .select(lambda m: m.picket_num)
+            .first()
+        )
+
+    def picket_width_stat(self, picket: int, metric: str = "max") -> float:
+        """Get the statistic of the picket width for the given picket.
+
+        Parameters
+        ----------
+        picket
+            The picket number to analyze.
+        metric
+            The metric to use. One of 'max', 'median', 'mean', 'min'.
+        """
+        picket_widths = [
+            m.profile.field_width_mm for m in self.mlc_meas if m.picket_num == picket
+        ]
+        if metric == "max":
+            return max(picket_widths)
+        elif metric == "median":
+            return statistics.median(picket_widths)
+        elif metric == "mean":
+            return statistics.mean(picket_widths)
+        elif metric == "min":
+            return min(picket_widths)
+
+    @property
+    def max_error_leaf(self) -> int | str:
+        """Return the leaf/leaf pair that had the maximum error.
+        This will be a single int value (i.e. either/both A and B) for classic analysis or a fully-qualified name for separate analysis. E.g. A43
+        """
+        if not self.separate_leaves:
+            return (
+                Enumerable(self.mlc_meas)
+                .order_by_descending(lambda m: np.max(np.abs(m.error)))
+                .select(lambda m: m.full_leaf_nums[0])
+                .first()
+            )
+        else:
+            max_meas = (
+                Enumerable(self.mlc_meas)
+                .order_by_descending(lambda m: np.max(np.abs(m.error)))
+                .first()
+            )
+            if abs(max_meas.error[0]) > abs(max_meas.error[1]):
+                return max_meas.full_leaf_nums[0]
+            else:
+                return max_meas.full_leaf_nums[1]
+
+    def _flattened_errors(self) -> list[float]:
+        return Enumerable(self.mlc_meas).select_many(lambda m: m.error).to_list()
+
+    def failed_leaves(self) -> list[int] | list[str]:
+        """A list of the failed leaves. Either the leaf number or the bank+leaf number if using separate leaves."""
+        if not self._is_analyzed:
+            raise ValueError(
+                "It appears the PF image has not been analyzed yet. Use .analyze() first."
+            )
+        failing_sets = Enumerable(self.mlc_meas).where(lambda m: not all(m.passed))
+        if not self.separate_leaves:
+            return failing_sets.select(lambda m: m.leaf_num).distinct().to_list()
+        else:
+            return (
+                failing_sets.select_many(
+                    lambda m: [
+                        m.full_leaf_nums[idx]
+                        for idx, passed in enumerate(m.passed)
+                        if not passed
+                    ]
+                )
+                .distinct()
+                .to_list()
+            )
+
+    @property
+    def abs_median_error(self) -> float:
+        """Return the median error found."""
+        return float(np.median(np.abs(self._flattened_errors())))
+
+    @property
+    def num_pickets(self) -> int:
+        """Return the number of pickets determined."""
+        return len(self.pickets)
+
+    @property
+    def mean_picket_spacing(self) -> float:
+        """The average distance between pickets in mm."""
+        sorted_pickets = sorted(self.pickets, key=lambda x: x.dist2cax)
+        return float(
+            np.mean(
+                [
+                    abs(sorted_pickets[idx].dist2cax - sorted_pickets[idx + 1].dist2cax)
+                    for idx in range(len(sorted_pickets) - 1)
+                ]
+            )
+        )
+
+    def plot_leaf_profile(self, leaf: str | int, picket: int, show: bool = True):
+        """Plot the leaf profile of a given leaf pair parallel to leaf motion.
+
+        Parameters
+        ----------
+        leaf
+            The leaf to plot. If ``separate_leaves`` is True, this will be a string like "A15" or "B33".
+            If ``separate_leaves`` is False, this must be an int, like ``15`` or ``33``.
+        picket
+            An int of the picket number. Pickets start from the 0-side of an image. E.g. for left-right PFs, this would start on the left; for up-down this would start at the bottom.
+        """
+        mlc_meas = Enumerable(self.mlc_meas).single(
+            lambda m: leaf in m.full_leaf_nums and m.picket_num == picket
+        )
+        ax = mlc_meas.plot_detailed_profile()
+        ax.set_title(f"MLC profile Leaf: {leaf}, Picket: {picket}")
+        for lg, rg, m in zip(
+            self.pickets[picket].left_guard_separated,
+            self.pickets[picket].right_guard_separated,
+            mlc_meas.marker_lines,
+        ):
+            g_val = lg(m.point1.y)
+            rg_val = rg(m.point1.y)
+            ax.axvline(g_val, color="green", label="Guard rail")
+            ax.axvline(rg_val, color="green", label="Guard rail")
+        ax.legend()
+        if show:
+            plt.show()
+
+    def save_leaf_profile(
+        self,
+        filename: str | Path | BinaryIO,
+        leaf: str | int,
+        picket: int,
+        **kwargs,
+    ):
+        """Save the leaf profile plot to disk or stream. See plot_leaf_profile for parameter hints. Kwargs are passed to matplotlib.savefig()"""
+        self.plot_leaf_profile(leaf, picket, show=False)
+        plt.savefig(filename, **kwargs)
+        if not isinstance(filename, BytesIO):
+            print(f"Picket fence leaf profile saved to: {osp.abspath(filename)}")
+
+    def _load_log(self, log: str) -> None:
+        """Load a machine log that corresponds to the picket fence delivery.
+
+        This log determines the location of the pickets. The MLC peaks are then compared to the expected log pickets,
+        not a simple fit of the peaks."""
+        # load the log fluence image
+        mlog = load_log(log)
+        fl = mlog.fluence.expected.calc_map(equal_aspect=True)
+        fli = image.load(
+            fl, dpi=254
+        )  # 254 pix/in => 1 pix/0.1mm (default fluence calc)
+
+        # equate them such that they're the same size & DPI
+        fluence_img, img_array = image.equate_images(fli, self.image)
+        self.image.array = img_array.array
+
+        # get picket fits from the modified fluence image
+        pf = PicketFence.from_demo_image()
+        pf.image = fluence_img
+        pf.analyze()
+        self._log_fits = cycle([p.get_fit() for p in pf.pickets])
+
+    @staticmethod
+    def run_demo(tolerance: float = 0.5, action_tolerance: float = None) -> None:
+        """Run the Picket Fence demo using the demo image. See analyze() for parameter info."""
+        pf = PicketFence.from_demo_image()
+        pf.analyze(tolerance, action_tolerance=action_tolerance)
+        print(pf.results())
+        pf.plot_analyzed_image(leaf_error_subplot=True)
+
+    def analyze(
+        self,
+        tolerance: float = 0.5,
+        action_tolerance: float | None = None,
+        num_pickets: int | None = None,
+        sag_adjustment: float | int = 0,
+        orientation: Orientation | str | None = None,
+        invert: bool = False,
+        leaf_analysis_width_ratio: float = 0.4,
+        picket_spacing: float | None = None,
+        height_threshold: float = 0.5,
+        edge_threshold: float = 1.5,
+        peak_sort: str = "peak_heights",
+        required_prominence: float = 0.2,
+        fwxm: int = 50,
+        separate_leaves: bool = False,
+        nominal_gap_mm: float = 3,
+        central_axis: Point | None = None,
+    ) -> None:
+        """Analyze the picket fence image.
+
+        Parameters
+        ----------
+        tolerance
+            The tolerance of difference in mm between an MLC pair position and the
+            picket fit line.
+        action_tolerance
+            If None (default), no action tolerance is set or compared to.
+            If an int or float, the MLC pair measurement is also compared to this
+            tolerance. Must be lower than tolerance. This value is usually meant
+            to indicate that a physicist should take an "action" to reduce the error,
+            but should not stop treatment.
+        num_pickets
+            The number of pickets in the image. A helper parameter to limit the total number of pickets,
+            only needed if analysis is catching more pickets than there really are.
+        sag_adjustment
+            The amount of shift in mm to apply to the image to correct for EPID sag.
+            For Up-Down picket images, positive moves the image down, negative up.
+            For Left-Right picket images, positive moves the image left, negative right.
+        orientation
+            If None (default), the orientation is automatically determined. If for some reason the determined
+            orientation is not correct, you can pass it directly using this parameter.
+            If passed a string with 'u' (e.g. 'up-down', 'u-d', 'up') it will set the orientation of the pickets as
+            going up-down. If passed a string with 'l' (e.g. 'left-right', 'lr', 'left') it will set it as going
+            left-right.
+        invert
+            If False (default), the inversion of the image is automatically detected and used.
+            If True, the image inversion is reversed from the automatic detection. This is useful when runtime errors
+            are encountered.
+        leaf_analysis_width_ratio
+            The ratio of the leaf width to use as part of the evaluation. E.g. if the ratio is 0.5, the center half of
+            the leaf will be used. This helps avoid tongue and groove influence.
+        picket_spacing
+            If None (default), the spacing between pickets is determined automatically.
+            If given, it should be an int or float specifying the number of **PIXELS** apart the pickets are.
+        height_threshold
+            The threshold that the MLC peak needs to be above to be considered a picket (vs background).
+            Lower if not all leaves are being caught. Note that for FFF beams this would very likely need to be lowered.
+        edge_threshold
+            The threshold of pixel value standard deviation within the analysis window of the MLC leaf to be considered a full leaf.
+            This is how pylinac removes MLCs that are eclipsed by the jaw. This also is how to
+            omit or catch leaves at the edge of the field. Raise to catch more edge leaves.
+        peak_sort
+            Either 'peak_heights' or 'prominences'. This is the method for determining the peaks. Usually not needed
+            unless the wrong number of pickets have been detected.
+            See the scipy.signal.find_peaks function for more information.
+        required_prominence
+            The required height of the picket (not individual MLCs) to be considered a peak.
+            Pylinac takes a mean of the image axis perpendicular to the leaf motion to get an initial guess of the peak
+            locations and also to determine picket spacing. Changing this can be useful for wide-gap tests where
+            the shape of the beam horns can form two or more local maximums in the picket area. Increase if for wide-gap
+            images that are catching too many pickets. Consider lowering for FFF beams if there are analysis issues.
+
+            .. warning::
+
+                We do not recommend performing FFF wide-gap PF tests. Make your FFF pickets narrow or measure with a flat beam instead.
+
+        fwxm
+            For each MLC kiss, the profile is a curve from low to high to low. The FWXM (0-100) is the height to use to measure
+            to determine the center of the curve, which is the surrogate for MLC kiss position. I.e. for each MLC kiss,
+            what height of the picket should you use to actually determine the center location? It is unusual to change this.
+            If you have something in the way (we've seen crazy examples with a BB in the way) you may want to increase this.
+        separate_leaves
+            Whether to analyze leaves individually (each tip) or as a set (combined, center of the picket). False is
+            the default for backwards compatibility.
+        nominal_gap_mm
+            The expected gap of the pickets in mm. Only used when separate leaves is True. Due to the DLG and EPID
+            scattering, this value will have to be determined by you with a known good delivery.
+        central_axis
+            The central axis of the beam. If None (default), the CAX is automatically determined. This
+            is used for French regulations where the CAX is set to the BB location from a separate image.
+        """
+        if action_tolerance is not None and tolerance < action_tolerance:
+            raise ValueError("Tolerance cannot be lower than the action tolerance")
+        self.tolerance = tolerance
+        self.action_tolerance = action_tolerance
+        self.leaf_analysis_width = leaf_analysis_width_ratio
+        self.separate_leaves = separate_leaves
+
+        if central_axis:
+            self.image._central_axis = central_axis
+
+        if invert:
+            self.image.invert()
+
+        self._orientation = orientation
+        # adjust for sag
+        if sag_adjustment != 0:
+            sag_pixels = int(round(sag_adjustment * self.image.dpmm))
+            self.image.adjust_for_sag(sag_pixels, self.orientation)
+
+        if self.orientation == Orientation.UP_DOWN:
+            leaf_prof = np.mean(self.image, 0)
+        else:
+            leaf_prof = np.mean(self.image, 1)
+        leaf_prof = MultiProfile(leaf_prof)
+        leaf_prof.normalize()  # normalize so required prominence is also normalized.
+        peak_idxs, peak_vals = leaf_prof.find_fwxm_peaks(
+            min_distance=0.02,
+            threshold=height_threshold,
+            max_number=num_pickets,
+            peak_sort=peak_sort,
+            required_prominence=required_prominence,
+        )
+        if len(peak_idxs) == 0:
+            raise ValueError(
+                "No pickets were found. This can mean either an incorrect orientation or incorrect inversion. "
+                "Try passing the correct orientation; if that fails, also set invert=True."
+            )
+        # get picket spacing if not set by user
+        if picket_spacing is None:
+            picket_spacing = np.median(np.diff(np.sort(peak_idxs)))
+
+        # loop through each leaf row and analyze each MLC kiss
+        self.mlc_meas = []
+        for leaf_num, center, width in self._leaves_in_view(leaf_analysis_width_ratio):
+            for picket_num, (picket_idx, picket_peak_val) in enumerate(
+                zip(peak_idxs, peak_vals)
+            ):
+                window = self._get_mlc_window(
+                    leaf_center=center,
+                    leaf_width=width,
+                    approx_idx=picket_idx,
+                    spacing=picket_spacing,
+                )
+                if self._is_mlc_peak_in_window(
+                    window, height_threshold, edge_threshold, picket_peak_val
+                ):
+                    self.mlc_meas.append(
+                        MLCValue(
+                            picket_num=picket_num,
+                            approx_idx=picket_idx,
+                            leaf_width=width,
+                            leaf_center=center,
+                            picket_spacing=picket_spacing,
+                            orientation=self.orientation,
+                            leaf_analysis_width_ratio=leaf_analysis_width_ratio,
+                            tolerance=tolerance,
+                            action_tolerance=action_tolerance,
+                            leaf_num=leaf_num,
+                            approx_peak_val=picket_peak_val,
+                            image_window=window,
+                            image=self.image,
+                            fwxm=fwxm,
+                            separate_leaves=separate_leaves,
+                            nominal_gap_mm=nominal_gap_mm,
+                        )
+                    )
+        if not self.mlc_meas:
+            raise ValueError(
+                "No MLC measurements were found. This may be due to an incorrect inversion. Try setting invert=True. Or, you may have passed an incorrect orientation."
+            )
+
+        # drop any leaf rows that don't have the right amount of MLC kisses (i.e. near edge where one is dropped)
+        median_num_leaves = (
+            Enumerable(self.mlc_meas)
+            .group_by(key=lambda m: m.leaf_num)
+            .median(lambda m: len(m))
+        )
+        full_leaves = (
+            Enumerable(self.mlc_meas)
+            .group_by(key=lambda m: m.leaf_num)
+            .where(lambda m: len(m) == median_num_leaves)
+            .select_many(lambda m: m)
+            .select(lambda m: m.leaf_num)
+            .distinct()
+            .to_list()
+        )
+        self.mlc_meas = [m for m in self.mlc_meas if m.leaf_num in full_leaves]
+        if any([True for m in self.mlc_meas if m.leaf_num not in full_leaves]):
+            warnings.warn(
+                "Some leaves were removed from analysis because they were not detected for all pickets. If some valid leaves are missing try adjusting height_threshold or edge_threshold"
+            )
+
+        # retrospectively create the pickets and update the individual MLC measurements so error can be calculated
+        self.pickets = []
+        for picket_num, _ in enumerate(peak_idxs):
+            self.pickets.append(
+                Picket(
+                    [m for m in self.mlc_meas if m.picket_num == picket_num],
+                    log_fits=self._log_fits,
+                    orientation=self.orientation,
+                    image=self.image,
+                    tolerance=tolerance,
+                    nominal_gap=nominal_gap_mm,
+                    separate_leaves=separate_leaves,
+                )
+            )
+
+        self._is_analyzed = True
+
+    def _is_mlc_peak_in_window(
+        self, window, height_threshold, edge_threshold, picket_peak_val
+    ) -> bool:
+        """Whether the MLC peak is inside the given window. E.g. the jaw could be closed or at an edge."""
+        if self.orientation == Orientation.UP_DOWN:
+            std = np.std(window, axis=1)
+        else:
+            std = np.std(window, axis=0)
+        is_above_height_threshold = np.max(window) > height_threshold * picket_peak_val
+        is_not_at_edge = max(std) < edge_threshold * np.median(std)
+        return is_above_height_threshold and is_not_at_edge
+
+    def _get_mlc_window(
+        self, leaf_center, leaf_width, approx_idx, spacing
+    ) -> np.ndarray:
+        """A small 2D window of the image that contains the area around the picket."""
+        leaf_width_px = leaf_width * self.image.dpmm
+        leaf_center_px = leaf_center * self.image.dpmm + (
+            self.image.shape[0] / 2
+            if self.orientation == Orientation.UP_DOWN
+            else self.image.shape[1] / 2
+        )
+        if self.orientation == Orientation.UP_DOWN:
+            # crop edges to image boundary if need be; if the pickets are too close to edge we could spill outside
+            left_edge = max(int(approx_idx - spacing / 2), 0)
+            right_edge = min(int(approx_idx + spacing / 2), self.image.shape[1])
+            top_edge = max(int(leaf_center_px - leaf_width_px / 2), 0)
+            bottom_edge = min(
+                int(leaf_center_px + leaf_width_px / 2), self.image.shape[0]
+            )
+            array = self.image[top_edge:bottom_edge, left_edge:right_edge]
+        else:
+            top_edge = max(int(approx_idx - spacing / 2), 0)
+            bottom_edge = min(int(approx_idx + spacing / 2), self.image.shape[0])
+            left_edge = max(int(leaf_center_px - leaf_width_px / 2), 0)
+            right_edge = min(
+                int(leaf_center_px + leaf_width_px / 2), self.image.shape[1]
+            )
+            array = self.image[top_edge:bottom_edge, left_edge:right_edge]
+        return array
+
+    def _leaves_in_view(self, analysis_width) -> list[tuple[int, int, int]]:
+        """Crop the leaves if not all leaves are in view."""
+        pixel_range = (
+            self.image.shape[0] / 2
+            if self.orientation == Orientation.UP_DOWN
+            else self.image.shape[1] / 2
+        )
+        # cut off the edge so that we're not halfway through a leaf.
+        pixel_range -= (
+            max(
+                self.mlc.widths[0] * analysis_width,
+                self.mlc.widths[-1] * analysis_width,
+            )
+            * self.image.dpmm
+        )
+        # include the leaf if the center is within the pixel range
+        return [
+            (leaf_num, center, width)
+            for leaf_num, center, width in zip(
+                self.mlc.leaves,
+                self.mlc.centers,
+                self.mlc.widths,
+            )
+            if abs(center) < pixel_range / self.image.dpmm
+        ]
+
+    def plot_analyzed_image(
+        self,
+        guard_rails: bool = True,
+        mlc_peaks: bool = True,
+        overlay: bool = True,
+        leaf_error_subplot: bool = True,
+        show: bool = True,
+        figure_size: str | tuple = "auto",
+    ) -> None:
+        """Plot the analyzed image.
+
+        Parameters
+        ----------
+        guard_rails
+            Do/don't plot the picket "guard rails" around the ideal picket
+        mlc_peaks
+            Do/don't plot the detected MLC peak positions.
+        overlay
+            Do/don't plot the alpha overlay of the leaf status.
+        leaf_error_subplot
+            If True, plots a linked leaf error subplot adjacent to the PF image plotting the average and standard
+            deviation of leaf error.
+        show
+            Whether to display the plot. Set to false for saving to a figure, etc.
+        figure_size
+            Either 'auto' or a tuple. If auto, the figure size is set depending on the orientation. If a tuple, this is the
+            figure size to use.
+        """
+        if not self._is_analyzed:
+            raise RuntimeError("The image must be analyzed first. Use .analyze().")
+
+        # plot the image
+        if figure_size == "auto":
+            if self.orientation == Orientation.UP_DOWN:
+                figure_size = (12, 8)
+            else:
+                figure_size = (9, 9)
+        fig, ax = plt.subplots(figsize=figure_size)
+        self.image.plot(ax=ax, show=False)
+
+        if leaf_error_subplot:
+            self._add_leaf_error_subplot(ax)
+
+        if guard_rails:
+            for picket in self.pickets:
+                picket.add_guards_to_axes(ax.axes)
+        if mlc_peaks:
+            for mlc_meas in self.mlc_meas:
+                mlc_meas.plot2axes(ax.axes, width=1.5)
+
+        if overlay:
+            for mlc_meas in self.mlc_meas:
+                mlc_meas.plot_overlay2axes(ax.axes)
+
+        # plot CAX
+        ax.plot(
+            self.image.center.x, self.image.center.y, "r+", ms=12, markeredgewidth=3
+        )
+        ax.axis("off")
+
+        if show:
+            plt.show()
+
+    def _add_leaf_error_subplot(self, ax: plt.Axes) -> None:
+        """Add a bar subplot showing the leaf error."""
+
+        # make the new axis
+        divider = make_axes_locatable(ax)
+        if self.orientation == Orientation.UP_DOWN:
+            axtop = divider.append_axes("right", 2, pad=1, sharey=ax)
+        else:
+            axtop = divider.append_axes("bottom", 2, pad=1, sharex=ax)
+
+        # get leaf positions, errors, standard deviation, and leaf numbers
+        if self.orientation == Orientation.UP_DOWN:
+            pos = [
+                position.marker_lines[0].center.y
+                for position in self.pickets[0].mlc_meas
+            ][::-1]
+        else:
+            pos = [
+                position.marker_lines[0].center.x
+                for position in self.pickets[0].mlc_meas
+            ][::-1]
+
+        # calculate the error and stdev values per MLC pair
+        error_stdev = []
+        error_vals = []
+        for leaf_num in {m.leaf_num for m in self.mlc_meas}:
+            error_vals.append(
+                np.mean(
+                    [np.abs(m.error) for m in self.mlc_meas if m.leaf_num == leaf_num]
+                )
+            )
+            error_stdev.append(
+                np.std([m.error for m in self.mlc_meas if m.leaf_num == leaf_num])
+            )
+
+        # plot the leaf errors as a bar plot
+        if self.orientation == Orientation.UP_DOWN:
+            axtop.barh(
+                pos,
+                error_vals,
+                xerr=error_stdev,
+                height=self.leaf_analysis_width * 2,
+                alpha=0.4,
+                align="center",
+            )
+            # plot the tolerance line(s)
+            axtop.axvline(self.tolerance, color="r", linewidth=3)
+            if self.action_tolerance is not None:
+                axtop.axvline(self.action_tolerance, color="m", linewidth=3)
+            # reset xlims to comfortably include the max error or tolerance value
+            axtop.set_xlim(
+                [0, max([max(error_vals) + max(error_stdev), self.tolerance]) + 0.1]
+            )
+        else:
+            axtop.bar(
+                pos,
+                error_vals,
+                yerr=error_stdev,
+                width=self.leaf_analysis_width * 2,
+                alpha=0.4,
+                align="center",
+            )
+            # plot the tolerance line(s)
+            axtop.axhline(self.tolerance, color="r", linewidth=3)
+            if self.action_tolerance is not None:
+                axtop.axhline(self.action_tolerance, color="m", linewidth=3)
+            axtop.set_ylim(
+                [0, max([max(error_vals) + max(error_stdev), self.tolerance]) + 0.1]
+            )
+
+        axtop.grid(True)
+        axtop.set_title("Average Error (mm)")
+
+    def save_analyzed_image(
+        self,
+        filename: str | io.BytesIO,
+        guard_rails: bool = True,
+        mlc_peaks: bool = True,
+        overlay: bool = True,
+        leaf_error_subplot: bool = False,
+        **kwargs,
+    ) -> None:
+        """Save the analyzed figure to a file. See :meth:`~pylinac.picketfence.PicketFence.plot_analyzed_image()` for
+        further parameter info.
+        """
+        self.plot_analyzed_image(
+            guard_rails,
+            mlc_peaks,
+            overlay,
+            leaf_error_subplot=leaf_error_subplot,
+            show=False,
+        )
+        plt.savefig(filename, **kwargs)
+        if isinstance(filename, str):
+            print(f"Picket fence image saved to: {osp.abspath(filename)}")
+
+    def results(self, as_list: bool = False) -> str:
+        """Return results of analysis. Use with print()."""
+        offsets = " ".join(f"{pk.dist2cax:.1f}" for pk in self.pickets)
+        results = [
+            "Picket Fence Results:",
+            f"Gantry Angle (\N{DEGREE SIGN}): {self.image.gantry_angle:2.1f}",
+            f"Collimator Angle (\N{DEGREE SIGN}): {self.image.collimator_angle:2.1f}",
+            f"Tolerance (mm): {self.tolerance}",
+            f"Leaves passing (%): {self.percent_passing:2.1f}",
+            f"Absolute median error (mm): {self.abs_median_error:2.3f}mm",
+            f"Mean picket spacing (mm): {self.mean_picket_spacing:2.1f}mmn",
+            f"Picket offsets from CAX (mm): {offsets}",
+            f"Max Error: {self.max_error:2.3f}mm on Picket: {self.max_error_picket}, Leaf: {self.max_error_leaf}",
+            f"MLC Skew: {self.mlc_skew():2.3f} degrees",
+        ]
+        if self.failed_leaves():
+            results.append(f"Failing leaves: {self.failed_leaves()}")
+        if not as_list:
+            results = "\n".join(results)
+        return results
+
+    def _generate_results_data(self) -> PFResult:
+        picket_widths = {
+            f"picket_{pk}": {
+                key: self.picket_width_stat(pk, key)
+                for key in ("max", "mean", "median", "min")
+            }
+            for pk in range(len(self.pickets))
+        }
+        return PFResult(
+            tolerance_mm=self.tolerance,
+            action_tolerance_mm=self.action_tolerance,
+            percent_leaves_passing=self.percent_passing,
+            number_of_pickets=self.num_pickets,
+            absolute_median_error_mm=self.abs_median_error,
+            max_error_mm=self.max_error,
+            max_error_picket=self.max_error_picket,
+            max_error_leaf=self.max_error_leaf,
+            mean_picket_spacing_mm=self.mean_picket_spacing,
+            offsets_from_cax_mm=[pk.dist2cax for pk in self.pickets],
+            passed=self.passed,
+            failed_leaves=self.failed_leaves(),
+            mlc_skew=self.mlc_skew(),
+            picket_widths=picket_widths,
+        )
+
+    def publish_pdf(
+        self,
+        filename: str | io.BytesIO,
+        notes: str = None,
+        open_file: bool = False,
+        metadata: dict = None,
+        bins: int = 10,
+        logo: Path | str | None = None,
+    ) -> None:
+        """Publish (print) a PDF containing the analysis, images, and quantitative results.
+
+        Parameters
+        ----------
+        filename : (str, file-like object}
+            The file to write the results to.
+        notes : str, list of strings
+            Text; if str, prints single line.
+            If list of strings, each list item is printed on its own line.
+        open_file : bool
+            Whether to open the file using the default program after creation.
+        metadata : dict
+            Extra data to be passed and shown in the PDF. The key and value will be shown with a colon.
+            E.g. passing {'Author': 'James', 'Unit': 'TrueBeam'} would result in text in the PDF like:
+            --------------
+            Author: James
+            Unit: TrueBeam
+            --------------
+        bins: int
+            Number of bins to show for the histogram
+        logo: Path, str
+            A custom logo to use in the PDF report. If nothing is passed, the default pylinac logo is used.
+        """
+        plt.ioff()
+        canvas = pdf.PylinacCanvas(
+            filename, page_title="Picket Fence Analysis", metadata=metadata, logo=logo
+        )
+        data = io.BytesIO()
+        self.save_analyzed_image(data, leaf_error_subplot=True)
+        canvas.add_image(data, location=(3, 5), dimensions=(15, 15))
+        if metadata:
+            canvas.add_text(
+                text=self.results(as_list=True), location=(1.5, 22), font_size=14
+            )
+        else:
+            canvas.add_text(
+                text=self.results(as_list=True), location=(1.5, 25), font_size=14
+            )
+        if notes is not None:
+            canvas.add_text(text="Notes:", location=(1, 5.5), font_size=14)
+            canvas.add_text(text=notes, location=(1, 5))
+
+        canvas.add_new_page()
+        hist = io.BytesIO()
+        self.save_histogram(hist, bins)
+        canvas.add_image(hist, location=(3, 8), dimensions=(15, 15))
+        canvas.finish()
+
+        if open_file:
+            webbrowser.open(filename)
+
+    def mlc_skew(self) -> float:
+        """Apparent rotation in degrees of the MLC. This could be conflated with the EPID skew, so be careful when interpreting this value."""
+        return float(np.mean([p.skew() for p in self.pickets]))
+
+    def plot_histogram(self, bins: int = 10, show: bool = True) -> None:
+        """Plot a histogram of the leaf errors"""
+        if not self._is_analyzed:
+            raise ValueError(
+                "It appears the PF image has not been analyzed yet. Use .analyze() first."
+            )
+        errors = Enumerable(self.mlc_meas).select_many(lambda m: m.error).to_list()
+        fig, ax = plt.subplots()
+        ax.axvline(self.tolerance, color="r", linewidth=3)
+        ax.axvline(-self.tolerance, color="r", linewidth=3)
+        ax.grid(True)
+        if self.action_tolerance is not None:
+            ax.axvline(self.action_tolerance, color="m", linewidth=3)
+            ax.axvline(-self.action_tolerance, color="m", linewidth=3)
+        ax.set_title("Leaf error histogram")
+        ax.set_ylabel("Counts")
+        ax.set_xlabel("Error (mm)")
+        ax.hist(errors, bins=bins)
+        if show:
+            plt.show()
+
+    def save_histogram(
+        self, filename: [str, Path, BinaryIO], bins: int = 10, **kwargs
+    ) -> None:
+        """Save a histogram of the leaf errors"""
+        self.plot_histogram(bins, show=False)
+        plt.savefig(filename, **kwargs)
+        if not isinstance(filename, BytesIO):
+            print(f"Picket fence histogram saved to: {osp.abspath(filename)}")
+
+    @cached_property
+    def orientation(self) -> Orientation:
+        """The orientation of the image, either Up-Down or Left-Right."""
+        # if orientation was passed in, use it
+        if self._orientation is not None:
+            return convert_to_enum(self._orientation, Orientation)
+
+        # replace any dead pixels with median value
+        temp_image = self.image.array.copy()
+        temp_image[temp_image < np.median(temp_image)] = np.median(temp_image)
+
+        # find "range" of 80 to 90th percentiles
+        row_sum = np.sum(temp_image, 0)
+        col_sum = np.sum(temp_image, 1)
+        row80, row90 = np.percentile(row_sum, [85, 99])
+        col80, col90 = np.percentile(col_sum, [85, 99])
+        row_range = row90 - row80
+        col_range = col90 - col80
+
+        # The true picket side will have a greater difference in
+        # percentiles than will the non-picket size.
+        if row_range < col_range:
+            orientation = Orientation.LEFT_RIGHT
+        else:
+            orientation = Orientation.UP_DOWN
+        return orientation
+
+
+class MLCValue:
+    def __init__(
+        self,
+        picket_num: int,
+        approx_idx: int,
+        leaf_width: float,
+        leaf_center: float,
+        picket_spacing: float,
+        orientation: Orientation,
+        leaf_analysis_width_ratio: float,
+        tolerance: float,
+        action_tolerance: float | None,
+        leaf_num: int,
+        approx_peak_val: float,
+        image_window: np.ndarray,
+        image: PFDicomImage,
+        fwxm: int,
+        separate_leaves: bool,
+        nominal_gap_mm: float,
+    ):
+        """Representation of an MLC kiss or of each MLC about a kiss."""
+        self._approximate_idx = approx_idx
+        self.picket_num = picket_num
+        self._approximate_peak_vale = approx_peak_val
+        self.leaf_width_px = leaf_width * image.dpmm
+        self._leaf_center = leaf_center
+        self.leaf_center_px = leaf_center * image.dpmm + (
+            image.shape[0] / 2
+            if orientation == Orientation.UP_DOWN
+            else image.shape[1] / 2
+        )
+        self.leaf_num = leaf_num
+        self._image_window = image_window
+        self._image = image
+        self._fwxm = fwxm
+        self._analysis_ratio: float = leaf_analysis_width_ratio
+        self._spacing: float = picket_spacing
+        self._orientation = orientation
+        self._tolerance: float = tolerance
+        self._action_tolerance: float = action_tolerance
+        self._separate_leaves = separate_leaves
+        self._nominal_gap_mm = nominal_gap_mm
+        self.profile: FWXMProfilePhysical
+        self.position = self.get_peak_positions()
+        self._fit = None
+
+    def __repr__(self) -> str:
+        return f"Leaf: {self.leaf_num}, Picket: {self.picket_num}"
+
+    @property
+    def full_leaf_nums(self) -> Sequence[str | int]:
+        """The fully-qualified leaf names. This will be the simple leaf number for traditional analysis or the bank+leaf num for separate leaves."""
+        if not self._separate_leaves:
+            return [
+                self.leaf_num,
+            ]
+        else:
+            return [
+                f"{LEFT_MLC_PREFIX}{self.leaf_num}",
+                f"{RIGHT_MLC_PREFIX}{self.leaf_num}",
+            ]
+
+    def plot2axes(self, axes: plt.Axes, width: float | int = 1) -> None:
+        """Plot the measurement to the axes."""
+        for idx, line in enumerate(self.marker_lines):
+            line.plot2axes(axes, width, color=self.bg_color[idx])
+
+    def get_peak_positions(self) -> Sequence[float]:
+        if self._orientation == Orientation.UP_DOWN:
+            pix_vals = np.median(self._image_window, axis=0)
+        else:
+            pix_vals = np.median(self._image_window, axis=1)
+        prof = FWXMProfilePhysical(
+            values=pix_vals,
+            ground=True,
+            normalization=Normalization.MAX,
+            dpmm=self._image.dpmm,
+        )
+        self.profile = prof
+        if self._separate_leaves:
+            left = prof.field_edge_idx(side="left") + max(
+                self._approximate_idx - self._spacing / 2, 0
+            )
+            right = prof.field_edge_idx(side="right") + max(
+                self._approximate_idx - self._spacing / 2, 0
+            )
+            return left, right
+        else:
+            return (
+                prof.center_idx + max(self._approximate_idx - self._spacing / 2, 0),
+            )  # crop to left edge if need be
+
+    @property
+    def passed(self) -> Sequence[bool]:
+        """Whether the MLC kiss or leaf was within tolerance."""
+        return [abs(error) < self._tolerance for error in self.error]
+
+    @property
+    def passed_action(self) -> Sequence[bool] | None:
+        """Whether the MLC kiss or leaf was within the action tolerance."""
+        return (
+            [abs(error) < self._action_tolerance for error in self.error]
+            if self._action_tolerance is not None
+            else [True, True]
+        )
+
+    @property
+    def bg_color(self) -> Sequence[str]:
+        """The color of the measurement when the PF image is plotted, based on pass/fail status."""
+        colors = []
+        for idx, passed in enumerate(self.passed):
+            if not passed:
+                colors.append("r")
+            elif self._action_tolerance is not None:
+                colors.append("b" if self.passed_action[idx] else "m")
+            else:
+                colors.append("b")
+        return colors
+
+    @property
+    def picket_positions(self) -> Sequence[float]:
+        """The position(s) of the pickets in mm"""
+        picket_pos = []
+        for line, sign in zip(self.marker_lines, (-1, 1)):
+            if self._orientation == Orientation.UP_DOWN:
+                picket = self._fit(line.center.y)
+            else:
+                picket = self._fit(line.center.x)
+            if (
+                self._separate_leaves
+            ):  # offset the picket position by the DLG and nominal gap
+                mag_factor = self._image.sid / 1000
+                picket += (
+                    sign * self._nominal_gap_mm * mag_factor / 2 * self._image.dpmm
+                )
+            picket_pos.append(picket / self._image.dpmm)
+        return picket_pos
+
+    def plot_detailed_profile(self) -> plt.Axes:
+        if self._orientation == Orientation.UP_DOWN:
+            pix_vals = np.median(self._image_window, axis=0)
+        else:
+            pix_vals = np.median(self._image_window, axis=1)
+        offset_pixels = max(self._approximate_idx - self._spacing / 2, 0)
+        x_values = np.array(range(len(pix_vals))) + offset_pixels
+
+        fig, ax = plt.subplots()
+        ax.plot(x_values, pix_vals)
+        for picket_pos in self.picket_positions:
+            ax.axvline(
+                x=picket_pos * self._image.dpmm,
+                label="Fitted picket location",
+                color="black",
+            )
+        for pos, bg_color in zip(self.get_peak_positions(), self.bg_color):
+            ax.axvline(pos, color=bg_color, label="Measured MLC position")
+        return ax
+
+    @property
+    def error(self) -> Sequence[float]:
+        """The error (difference) of the MLC measurement and the picket fit.
+        If using individual leaf analysis, returns both errors otherwise return one."""
+        errors = []
+        for line, sign in zip(self.marker_lines, (-1, 1)):
+            if self._orientation == Orientation.UP_DOWN:
+                picket_pos = self._fit(line.center.y)
+                mlc_pos = line.center.x
+            else:
+                picket_pos = self._fit(line.center.x)
+                mlc_pos = line.center.y
+            if (
+                self._separate_leaves
+            ):  # offset the picket position by the DLG and nominal gap
+                mag_factor = self._image.sid / 1000
+                picket_pos += (
+                    sign * self._nominal_gap_mm * mag_factor / 2 * self._image.dpmm
+                )
+            errors.append((mlc_pos - picket_pos) / self._image.dpmm)
+        return errors
+
+    @property
+    def max_abs_error(self) -> float:
+        """The maximum absolute error"""
+        return np.max(np.abs([self.error]))
+
+    @property
+    def marker_lines(self) -> list[Line]:
+        """The line(s) representing the MLC measurement position. When using separated leaves
+        there are two lines. Traditional analysis returns one."""
+        upper_point = (
+            self.leaf_center_px - self.leaf_width_px / 2 * self._analysis_ratio
+        )
+        lower_point = (
+            self.leaf_center_px + self.leaf_width_px / 2 * self._analysis_ratio
+        )
+
+        lines = []
+        for mlc_position in self.position:
+            if self._orientation == Orientation.UP_DOWN:
+                line = Line((mlc_position, upper_point), (mlc_position, lower_point))
+            else:
+                line = Line((upper_point, mlc_position), (lower_point, mlc_position))
+            lines.append(line)
+        return lines
+
+    def plot_overlay2axes(self, axes) -> None:
+        """Create a rectangle overlay with the width of the error. I.e. it stretches from the picket fit to the MLC position. Gives more visual size to the"""
+        # calculate height (based on leaf analysis ratio)
+        upper_point = (
+            self.leaf_center_px - self.leaf_width_px / 2 * self._analysis_ratio
+        )
+        lower_point = (
+            self.leaf_center_px + self.leaf_width_px / 2 * self._analysis_ratio
+        )
+        height = abs(upper_point - lower_point) * 0.8
+
+        for idx, line in enumerate(self.marker_lines):
+            width = abs(self.error[idx]) * self._image.dpmm
+            y = line.center.y
+            x = self.position[idx] - (self.error[idx] * self._image.dpmm) / 2
+
+            if self._orientation == Orientation.UP_DOWN:
+                r = Rectangle(width, height, center=(x, y))
+                # if any of the values are over tolerance, show another larger rectangle to draw the eye
+                if not self.passed[idx] or not self.passed_action[idx]:
+                    re = Rectangle(
+                        self._image_window.shape[1] * 0.2, height * 1.2, center=(x, y)
+                    )
+                    re.plot2axes(
+                        axes,
+                        edgecolor="none",
+                        fill=True,
+                        alpha=0.5,
+                        facecolor=self.bg_color[idx],
+                    )
+            else:
+                r = Rectangle(height, width, center=(x, y))
+                if not self.passed[idx] or not self.passed_action[idx]:
+                    re = Rectangle(
+                        self._image_window.shape[1] * 0.2, height * 1.2, center=(x, y)
+                    )
+                    re.plot2axes(
+                        axes,
+                        edgecolor="none",
+                        fill=True,
+                        alpha=0.5,
+                        facecolor=self.bg_color[idx],
+                    )
+            r.plot2axes(
+                axes, edgecolor="none", fill=True, alpha=1, facecolor=self.bg_color[idx]
+            )
+
+
+class Picket:
+    """Holds picket information in a Picket Fence test."""
+
+    def __init__(
+        self,
+        mlc_measurements: list[MLCValue],
+        log_fits,
+        orientation: Orientation,
+        image: PFDicomImage,
+        tolerance: float,
+        separate_leaves: bool,
+        nominal_gap: float,
+    ):
+        self.mlc_meas: list[MLCValue] = mlc_measurements
+        self.log_fits = log_fits
+        self.tolerance = tolerance
+        self.orientation = orientation
+        self.image = image
+        self._separate_leaves = separate_leaves
+        self._nominal_gap = nominal_gap
+        self.fit = self.get_fit()
+        for m in self.mlc_meas:
+            m._fit = self.fit
+
+    def get_fit(self) -> np.poly1d:
+        """The fit of a polynomial to the MLC measurements."""
+        if self.log_fits is not None:
+            return next(self.log_fits)
+        x = (
+            Enumerable(self.mlc_meas)
+            .select_many(lambda m: [line.point1.y for line in m.marker_lines])
+            .to_list()
+        )
+        y = (
+            Enumerable(self.mlc_meas)
+            .select_many(lambda m: [line.point1.x for line in m.marker_lines])
+            .to_list()
+        )
+        if self.orientation == Orientation.UP_DOWN:
+            fit = np.polyfit(x, y, 1)
+        else:
+            fit = np.polyfit(y, x, 1)
+        return np.poly1d(fit)
+
+    def skew(self) -> float:
+        """The slope/skew of the picket"""
+        return float(np.rad2deg(self.fit.coefficients[0]))
+
+    @property
+    def dist2cax(self) -> float:
+        """The distance from the CAX to the picket, in mm."""
+        # TODO: see about using line and built-in dist to point.
+        center_fit = np.poly1d(self.fit)
+        if self.orientation == Orientation.UP_DOWN:
+            length = self.image.shape[0]
+        else:
+            length = self.image.shape[1]
+        x_data = np.arange(length)
+        y_data = center_fit(x_data)
+        idx = int(round(len(x_data) / 2))
+        if self.orientation == Orientation.UP_DOWN:
+            axis = "x"
+            p1 = Point(y_data[idx], x_data[idx])
+        else:
+            axis = "y"
+            p1 = Point(x_data[idx], y_data[idx])
+        return (getattr(self.image.center, axis) - getattr(p1, axis)) / self.image.dpmm
+
+    @property
+    def left_guard_separated(self) -> Sequence[np.poly1d]:
+        """The line representing the left-sided guard rails.
+        When not doing separate analysis, the left and right rails will overlap."""
+        l_fit = np.copy(self.fit)
+        l_fit[-1] += self.tolerance * self.image.dpmm
+        if not self._separate_leaves:
+            return [
+                np.poly1d(l_fit),
+            ]
+        else:
+            other_fit = copy.copy(l_fit)
+            mag_factor = self.image.sid / 1000
+            l_fit[-1] += self._nominal_gap * mag_factor / 2 * self.image.dpmm
+            other_fit[-1] -= self._nominal_gap * mag_factor / 2 * self.image.dpmm
+            return [np.poly1d(l_fit), np.poly1d(other_fit)]
+
+    @property
+    def right_guard_separated(self):
+        """The line representing the right-sided guard rails."""
+        r_fit = np.copy(self.fit)
+        r_fit[-1] -= self.tolerance * self.image.dpmm
+        if not self._separate_leaves:
+            return [
+                np.poly1d(r_fit),
+            ]
+        else:
+            other_fit = copy.copy(r_fit)
+            mag_factor = self.image.sid / 1000
+            r_fit[-1] -= self._nominal_gap * mag_factor / 2 * self.image.dpmm
+            other_fit[-1] += self._nominal_gap * mag_factor / 2 * self.image.dpmm
+            return [np.poly1d(r_fit), np.poly1d(other_fit)]
+
+    def add_guards_to_axes(self, axis: plt.Axes, color: str = "g") -> None:
+        """Plot guard rails to the axis."""
+        if self.orientation == Orientation.UP_DOWN:
+            length = self.image.shape[0]
+        else:
+            length = self.image.shape[1]
+        x_data = np.arange(length)
+        left_y_data = self.left_guard_separated
+        right_y_data = self.right_guard_separated
+        for left, right in zip(left_y_data, right_y_data):
+            if self.orientation == Orientation.UP_DOWN:
+                axis.plot(left(x_data), x_data, color=color)
+                axis.plot(right(x_data), x_data, color=color)
+            else:
+                axis.plot(x_data, left(x_data), color=color)
+                axis.plot(x_data, right(x_data), color=color)
```

#### encoding

```diff
@@ -1 +1 @@
-us-ascii
+utf-8
```

### Comparing `manteia_qa_pylinac-1.0.0/pylinac/quart.py` & `manteia_qa_pylinac-1.1.0/pylinac/quart.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,637 +1,629 @@
-from __future__ import annotations
-
-import dataclasses
-import io
-import textwrap
-import webbrowser
-from io import BytesIO
-from pathlib import Path
-
-import numpy as np
-import scipy.ndimage
-from matplotlib import pyplot as plt
-from scipy.interpolate import interp1d
-
-from .core import pdf
-from .core.geometry import Line, Point
-from .core.profile import FWXMProfilePhysical
-from .core.utilities import ResultBase
-from .ct import (
-    AIR,
-    CTP404CP504,
-    CTP486,
-    WATER,
-    CatPhanBase,
-    CatPhanModule,
-    ThicknessROI,
-    rois_to_results,
-)
-
-UNIFORMITY_OFFSET_MM = -45
-GEOMETRY_OFFSET_MM = 45
-ACRYLIC = 120
-POLY = -35
-TEFLON = 990
-
-
-@dataclasses.dataclass
-class QuartHUModuleOutput:
-    """This class should not be called directly. It is returned by the ``results_data()`` method.
-    It is a dataclass under the hood and thus comes with all the dunder magic.
-
-    Use the following attributes as normal class attributes."""
-
-    offset: int
-    roi_settings: dict
-    rois: dict
-    measured_slice_thickness_mm: float
-    signal_to_noise: float
-    contrast_to_noise: float
-
-
-@dataclasses.dataclass
-class QuartGeometryModuleOutput:
-    """This class should not be called directly. It is returned by the ``results_data()`` method.
-    It is a dataclass under the hood and thus comes with all the dunder magic.
-
-    Use the following attributes as normal class attributes."""
-
-    offset: int
-    roi_settings: dict
-    rois: dict
-    distances: dict
-    high_contrast_distances: dict
-    mean_high_contrast_distance: float
-
-
-@dataclasses.dataclass
-class QuartUniformityModuleOutput:
-    """This class should not be called directly. It is returned by the ``results_data()`` method.
-    It is a dataclass under the hood and thus comes with all the dunder magic.
-
-    Use the following attributes as normal class attributes."""
-
-    offset: int
-    roi_settings: dict
-    rois: dict
-    passed: bool
-
-
-@dataclasses.dataclass
-class QuartDVTResult(ResultBase):
-    """This class should not be called directly. It is returned by the ``results_data()`` method.
-    It is a dataclass under the hood and thus comes with all the dunder magic.
-
-    Use the following attributes as normal class attributes."""
-
-    phantom_model: str  #:
-    phantom_roll_deg: float  #:
-    origin_slice: int  #:
-    num_images: int  #:
-    hu_module: QuartHUModuleOutput  #:
-    uniformity_module: QuartUniformityModuleOutput  #:
-    geometric_module: QuartGeometryModuleOutput  #:
-
-
-class QuartHUModule(CTP404CP504):
-    roi_dist_mm = 52.5
-    roi_radius_mm = 6
-    roi_settings = {
-        "Air": {
-            "value": AIR,
-            "angle": -90,
-            "distance": roi_dist_mm,
-            "radius": roi_radius_mm,
-        },
-        "Poly": {
-            "value": POLY,
-            "angle": 0,
-            "distance": roi_dist_mm,
-            "radius": roi_radius_mm,
-        },
-        "Acrylic": {
-            "value": ACRYLIC,
-            "angle": 45,
-            "distance": roi_dist_mm,
-            "radius": roi_radius_mm,
-        },
-        "Teflon": {
-            "value": TEFLON,
-            "angle": 180,
-            "distance": roi_dist_mm,
-            "radius": roi_radius_mm,
-        },
-    }
-    background_roi_settings = {}
-    thickness_roi_height = 25
-    thickness_roi_width = 15
-    thickness_roi_distance_mm = 32
-    thickness_roi_settings = {
-        "Bottom": {
-            "angle": 90,
-            "width": thickness_roi_height,
-            "height": thickness_roi_width,
-            "distance": thickness_roi_distance_mm,
-        },
-        "Top": {
-            "angle": -90,
-            "width": thickness_roi_height,
-            "height": thickness_roi_width,
-            "distance": thickness_roi_distance_mm,
-        },
-    }
-
-    def _setup_geometry_rois(self) -> None:
-        # no geometry ROIs
-        pass
-
-    def _setup_thickness_rois(self) -> None:
-        """We invert the thickness ROIs because they are air gaps, not high-density wires"""
-        self.thickness_image.invert()
-        for name, setting in self.thickness_roi_settings.items():
-            self.thickness_rois[name] = ThicknessROI(
-                self.thickness_image,
-                setting["width_pixels"],
-                setting["height_pixels"],
-                setting["angle_corrected"],
-                setting["distance_pixels"],
-                self.phan_center,
-            )
-
-    @property
-    def meas_slice_thickness(self) -> float:
-        """The average slice thickness for the 4 wire measurements in mm."""
-        INCLINATION_CORRECTION = 0.577  # per manual; tan(30)
-        return np.mean(
-            sorted(
-                roi.wire_fwhm * self.mm_per_pixel * INCLINATION_CORRECTION
-                for roi in self.thickness_rois.values()
-            )
-        ) / (1 + 2 * self.pad)
-
-    @property
-    def signal_to_noise(self) -> float:
-        """Calculate the SNR based on the suggested procedure in the manual:
-        SNR = (HU + 1000) / sigma,
-        where HU is the mean HU of a chosen insert and sigma is the stdev of the HU insert.
-        We choose to use the Polystyrene as the target HU insert"""
-        return (self.rois["Poly"].pixel_value + 1000) / self.rois["Poly"].std
-
-    @property
-    def contrast_to_noise(self) -> float:
-        """Calculate the CNR based on the suggested procedure in the manual:
-        CNR = abs(HU_target - HU_background) / sigma,
-        where HU_target is the mean HU of a chosen insert, HU_background is the mean HU of the background insert
-        and sigma is the stdev of the HU background.
-        We choose to use the Polystyrene as the target HU insert and Acrylic (base phantom material) as the background
-        """
-        return (
-            abs(self.rois["Poly"].pixel_value - self.rois["Acrylic"].pixel_value)
-            / self.rois["Acrylic"].std
-        )
-
-
-class HypersightQuartHUModule(QuartHUModule):
-    roi_dist_mm = 52.5
-    roi_radius_mm = 6
-    roi_settings = {
-        "Air": {
-            "value": AIR,
-            "angle": -90,
-            "distance": roi_dist_mm,
-            "radius": roi_radius_mm,
-        },
-        "Poly": {
-            "value": POLY,
-            "angle": 0,
-            "distance": roi_dist_mm,
-            "radius": roi_radius_mm,
-        },
-        "Acrylic": {
-            "value": ACRYLIC,
-            "angle": 45,
-            "distance": roi_dist_mm,
-            "radius": roi_radius_mm,
-        },
-        "Teflon": {
-            "value": TEFLON,
-            "angle": 180,
-            "distance": roi_dist_mm,
-            "radius": roi_radius_mm,
-        },
-        "Water": {
-            "value": WATER,
-            "angle": -45,
-            "distance": roi_dist_mm,
-            "radius": 12,
-        },
-    }
-
-
-class QuartUniformityModule(CTP486):
-    """Class for analysis of the Uniformity slice of the CTP module. Measures 5 ROIs around the slice that
-    should all be close to the same value.
-    """
-
-    common_name = "HU Uniformity"
-    roi_dist_mm = 53
-    roi_radius_mm = 10
-    nominal_value = 120
-    roi_settings = {
-        "Top": {
-            "value": nominal_value,
-            "angle": -90,
-            "distance": roi_dist_mm,
-            "radius": roi_radius_mm,
-        },
-        "Right": {
-            "value": nominal_value,
-            "angle": 0,
-            "distance": roi_dist_mm,
-            "radius": roi_radius_mm,
-        },
-        "Bottom": {
-            "value": nominal_value,
-            "angle": 90,
-            "distance": roi_dist_mm,
-            "radius": roi_radius_mm,
-        },
-        "Left": {
-            "value": nominal_value,
-            "angle": 180,
-            "distance": roi_dist_mm,
-            "radius": roi_radius_mm,
-        },
-        "Center": {
-            "value": nominal_value,
-            "angle": 0,
-            "distance": 0,
-            "radius": roi_radius_mm,
-        },
-    }
-
-
-class QuartGeometryModule(CatPhanModule):
-    """Class for analysis of the Uniformity slice of the CTP module. Measures 5 ROIs around the slice that
-    should all be close to the same value.
-    """
-
-    attr_name = "geometry_module"
-    common_name = "Geometric Distortion"
-    profiles: dict
-    horiz_array: np.ndarray
-    vert_array: np.ndarray
-
-    def _setup_rois(self) -> None:
-        self.profiles = {}
-        img = (
-            self.image.array.copy()
-        )  # we copy so we don't overwrite the existing image pixels
-        img = scipy.ndimage.median_filter(img, size=3)
-        img = img - img.min()  # ground the profile
-        # calculate horizontal
-        self.horiz_array = img[int(self.phan_center.y), :]
-        prof = FWXMProfilePhysical(
-            values=self.horiz_array,
-            dpmm=1 / self.mm_per_pixel,
-        )
-        line = Line(
-            Point(round(prof.field_edge_idx("left")), self.phan_center.y),
-            Point(round(prof.field_edge_idx("right")), self.phan_center.y),
-        )
-        self.profiles["horizontal"] = {
-            "width (mm)": prof.field_width_mm,
-            "line": line,
-        }
-        # calculate vertical
-        self.vert_array = img[:, int(self.phan_center.x)]
-        prof = FWXMProfilePhysical(
-            values=self.vert_array,
-            dpmm=1 / self.mm_per_pixel,
-        )
-        line = Line(
-            Point(self.phan_center.x, round(prof.field_edge_idx("left"))),
-            Point(self.phan_center.x, round(prof.field_edge_idx("right"))),
-        )
-        self.profiles["vertical"] = {
-            "width (mm)": prof.field_width_mm,
-            "line": line,
-        }
-
-    def plot_rois(self, axis: plt.Axes):
-        for name, profile_data in self.profiles.items():
-            profile_data["line"].plot2axes(axis, width=2, color="blue")
-
-    def distances(self) -> dict[str, float]:
-        """The measurements of the phantom size for the two lines in mm"""
-        return {f"{name} mm": p["width (mm)"] for name, p in self.profiles.items()}
-
-    def high_contrast_resolutions(self) -> dict:
-        """The distance in mm from the -700 HU index to the -200 HU index.
-
-        This calculates the distance on each edge of the horizontal and vertical
-        geometric profiles for a total of 4 measurements. The result is the
-        average of the 4 values. The DICOM data is already HU-corrected so
-        -1000 => 0. This means we will search for 300 HU (-1000 + 700) and 800 HU (-1000 + 200) respectively.
-
-        This cuts the profile in half, searches for the highest-gradient index (where the phantom edge is),
-        then further cuts it down to +/-10 pixels. The 300/800 HU are then found from linear interpolation.
-        It was found that artifacts in the image could drastically influence these values, so hence the +/-10
-        subset.
-
-        Assumptions:
-        -The phantom does not cross the halfway point of the image FOV (i.e. not offset by an obscene amount).
-        -10 pixels about the phantom edge is adequate to capture the full dropoff.
-        -300 and 800 HU values will be in the profile"""
-        dists = {"Top": np.nan, "Bottom": np.nan, "Left": np.nan, "Right": np.nan}
-        edge_5mm = int(5 / self.mm_per_pixel)  # physical 5mm distance
-        keys = (key for key in dists)
-        for array in (self.horiz_array, self.vert_array):
-            split_idx = len(array) // 2  # we need not be exact, just close
-            left_data, right_data = array[:split_idx], array[split_idx:][::-1]
-            for profile_data in (left_data, right_data):
-                # find the phantom edge and chop about it
-                edge_idx = np.argmax(np.diff(profile_data))
-                edge_data = profile_data[edge_idx - edge_5mm : edge_idx + edge_5mm]
-                interp_func = interp1d(edge_data, np.arange(len(edge_data)))
-                idx_300, idx_800 = interp_func([300, 800])
-                dists[next(keys)] = abs(idx_800 - idx_300) * self.mm_per_pixel
-        return dists
-
-    def mean_high_contrast_resolution(self) -> float:
-        """Mean high-contrast resolution"""
-        return float(np.mean(list(self.high_contrast_resolutions().values())))
-
-
-class QuartDVT(CatPhanBase):
-    """A class for loading and analyzing CT DICOM files of a Quart phantom that comes with the Halcyon.
-    Analyzes: HU Uniformity, Image Scaling & HU Linearity.
-    """
-
-    _demo_url = "quart.zip"
-    _model = "Quart DVT"
-    hu_origin_slice_variance = 300
-    catphan_radius_mm = 80
-    hu_module: QuartHUModule
-    hu_module_class = QuartHUModule
-    uniformity_module: QuartUniformityModule
-    uniformity_module_class = QuartUniformityModule
-    geometry_module: QuartGeometryModule
-    geometry_module_class = QuartGeometryModule
-
-    @staticmethod
-    def run_demo(show: bool = True):
-        """Run the Quart algorithm with a head dataset."""
-        quart = QuartDVT.from_demo_images()
-        quart.analyze()
-        print(quart.results())
-        quart.plot_analyzed_image(show)
-
-    def analyze(
-        self,
-        hu_tolerance: int | float = 40,
-        scaling_tolerance: int | float = 1,
-        thickness_tolerance: int | float = 0.2,
-        cnr_threshold: int | float = 5,
-    ):
-        self.localize()
-        self.hu_module = self.hu_module_class(
-            self,
-            offset=0,
-            hu_tolerance=hu_tolerance,
-            thickness_tolerance=thickness_tolerance,
-            scaling_tolerance=scaling_tolerance,
-        )
-        self.uniformity_module = self.uniformity_module_class(
-            self, offset=UNIFORMITY_OFFSET_MM, tolerance=hu_tolerance
-        )
-        self.geometry_module = self.geometry_module_class(
-            self, tolerance=3, offset=GEOMETRY_OFFSET_MM
-        )
-
-    def plot_analyzed_image(self, show: bool = True, **plt_kwargs) -> None:
-        """Plot the images used in the calculation and summary data.
-
-        Parameters
-        ----------
-        show : bool
-            Whether to plot the image or not.
-        plt_kwargs : dict
-            Keyword args passed to the plt.figure() method. Allows one to set things like figure size.
-        """
-        # set up grid and axes
-        plt.figure(**plt_kwargs)
-        grid_size = (2, 3)
-        hu_ax = plt.subplot2grid(grid_size, (0, 1))
-        self.hu_module.plot(hu_ax)
-        hu_lin_ax = plt.subplot2grid(grid_size, (0, 2))
-        self.hu_module.plot_linearity(hu_lin_ax)
-        unif_ax = plt.subplot2grid(grid_size, (1, 0))
-        self.uniformity_module.plot(unif_ax)
-        unif_prof_ax = plt.subplot2grid(grid_size, (1, 2))
-        self.uniformity_module.plot_profiles(unif_prof_ax)
-        geometry_ax = plt.subplot2grid(grid_size, (0, 0))
-        self.geometry_module.plot(geometry_ax)
-        side_view_ax = plt.subplot2grid(grid_size, (1, 1))
-        self.plot_side_view(side_view_ax)
-
-        # finish up
-        plt.tight_layout()
-        if show:
-            plt.show()
-
-    def plot_analyzed_subimage(self, *args, **kwargs) -> None:
-        raise NotImplementedError()
-
-    def results(self, as_str: bool = True) -> str | tuple[str, ...]:
-        """Return the results of the analysis as a string. Use with print()."""
-        items = (
-            f"\n - {self._model} QA Test - \n",
-            f"HU Linearity ROIs: {self.hu_module.roi_vals_as_str}\n",
-            f"HU Passed?: {self.hu_module.passed_hu}\n",
-            f"Measured Slice Thickness (mm): {self.hu_module.meas_slice_thickness:2.3f}\n",
-            f"Slice Thickness Passed? {self.hu_module.passed_thickness}\n",
-            f"Uniformity ROIs: {self.uniformity_module.roi_vals_as_str}\n",
-            f"Uniformity Passed?: {self.uniformity_module.overall_passed}\n",
-            f"Geometric width: {self.geometry_module.distances()}",
-            f"High-Contrast distance (mm): {self.geometry_module.mean_high_contrast_resolution():2.3f}",
-        )
-        if as_str:
-            return "\n".join(items)
-        else:
-            return items
-
-    def results_data(self, as_dict: bool = False) -> QuartDVTResult | dict:
-        """Return results in a data structure for more programmatic use."""
-        data = QuartDVTResult(
-            phantom_model=self._model,
-            phantom_roll_deg=self.catphan_roll,
-            origin_slice=self.origin_slice,
-            num_images=self.num_images,
-            uniformity_module=QuartUniformityModuleOutput(
-                offset=UNIFORMITY_OFFSET_MM,
-                roi_settings=self.uniformity_module.roi_settings,
-                rois=rois_to_results(self.uniformity_module.rois),
-                passed=self.uniformity_module.overall_passed,
-            ),
-            geometric_module=QuartGeometryModuleOutput(
-                offset=GEOMETRY_OFFSET_MM,
-                roi_settings=self.geometry_module.roi_settings,
-                rois=rois_to_results(self.geometry_module.rois),
-                distances=self.geometry_module.distances(),
-                high_contrast_distances=self.geometry_module.high_contrast_resolutions(),
-                mean_high_contrast_distance=self.geometry_module.mean_high_contrast_resolution(),
-            ),
-            hu_module=QuartHUModuleOutput(
-                offset=0,
-                roi_settings=self.hu_module.roi_settings,
-                rois=rois_to_results(self.hu_module.rois),
-                measured_slice_thickness_mm=self.hu_module.meas_slice_thickness,
-                signal_to_noise=self.hu_module.signal_to_noise,
-                contrast_to_noise=self.hu_module.contrast_to_noise,
-            ),
-        )
-        if as_dict:
-            return dataclasses.asdict(data)
-        else:
-            return data
-
-    def plot_images(self, show: bool = True, **plt_kwargs) -> dict[str, plt.Figure]:
-        """Plot all the individual images separately.
-
-        Parameters
-        ----------
-        show
-            Whether to show the images.
-        plt_kwargs
-            Keywords to pass to matplotlib for figure customization.
-        """
-        figs = {}
-        # plot the images
-        modules = {
-            "HU linearity": self.hu_module,
-            "HU uniformity": self.uniformity_module,
-            "Geometry": self.geometry_module,
-        }
-        for key, module in modules.items():
-            fig, ax = plt.subplots(**plt_kwargs)
-            module.plot(ax)
-            figs[key] = fig
-        # add side-view
-        fig, ax = plt.subplots(**plt_kwargs)
-        self.plot_side_view(ax)
-        figs["side"] = fig
-
-        if show:
-            plt.show()
-        return figs
-
-    def save_images(
-        self,
-        directory: Path | str | None = None,
-        to_stream: bool = False,
-        **plt_kwargs,
-    ) -> list[Path] | dict[str, BytesIO]:
-        """Save separate images to disk or stream.
-
-        Parameters
-        ----------
-        directory
-            The directory to write the images to. If None, will use current working directory
-        to_stream
-            Whether to write to stream or disk. If True, will return streams. Directory is ignored in that scenario.
-        plt_kwargs
-            Keywords to pass to matplotlib for figure customization.
-        """
-        figs = self.plot_images(show=False, **plt_kwargs)
-        paths = []
-        streams = {}
-        for name, fig in figs.items():
-            if to_stream:
-                path = io.BytesIO()
-            else:
-                destination = Path(directory) or Path.cwd()
-                path = (destination / name).with_suffix(".png").absolute()
-            fig.savefig(path)
-            paths.append(path)
-            streams[name] = path
-        if to_stream:
-            return streams
-        else:
-            return paths
-
-    def publish_pdf(
-        self,
-        filename: str | Path,
-        notes: str | None = None,
-        open_file: bool = False,
-        metadata: dict | None = None,
-        logo: Path | str | None = None,
-    ) -> None:
-        """Publish (print) a PDF containing the analysis and quantitative results.
-
-        Parameters
-        ----------
-        filename : (str, file-like object}
-            The file to write the results to.
-        notes : str, list of strings
-            Text; if str, prints single line.
-            If list of strings, each list item is printed on its own line.
-        open_file : bool
-            Whether to open the file using the default program after creation.
-        metadata : dict
-            Extra data to be passed and shown in the PDF. The key and value will be shown with a colon.
-            E.g. passing {'Author': 'James', 'Unit': 'TrueBeam'} would result in text in the PDF like:
-            --------------
-            Author: James
-            Unit: TrueBeam
-            --------------
-        logo: Path, str
-            A custom logo to use in the PDF report. If nothing is passed, the default pylinac logo is used.
-        """
-        analysis_title = f"{self._model} Analysis"
-        analysis_images = self.save_images(to_stream=True)
-
-        canvas = pdf.PylinacCanvas(
-            filename, page_title=analysis_title, metadata=metadata, logo=logo
-        )
-        if notes is not None:
-            canvas.add_text(text="Notes:", location=(1, 4.5), font_size=14)
-            canvas.add_text(text=notes, location=(1, 4))
-
-        shortened_texts = [
-            textwrap.wrap(r, width=110) for r in self.results(as_str=False)
-        ]
-        idx = 0
-        for items in enumerate(shortened_texts):
-            for text in items:
-                canvas.add_text(text=text, location=(1.5, 25 - idx * 0.5))
-                idx += 1
-        for page, img in enumerate(analysis_images.values()):
-            canvas.add_new_page()
-            canvas.add_image(img, location=(1, 5), dimensions=(18, 18))
-        canvas.finish()
-
-        if open_file:
-            webbrowser.open(filename)
-
-    def _module_offsets(self) -> list[float]:
-        absolute_origin_position = self.dicom_stack[self.origin_slice].z_position
-        relative_offsets_mm = [0, UNIFORMITY_OFFSET_MM, GEOMETRY_OFFSET_MM]
-        return [
-            absolute_origin_position + offset_mm for offset_mm in relative_offsets_mm
-        ]
-
-    def _detected_modules(self) -> list[CatPhanModule]:
-        return [self.uniformity_module, self.hu_module, self.geometry_module]
-
-
-class HypersightQuartDVT(QuartDVT):
-    """A class for loading and analyzing CT DICOM files of a Quart phantom that comes with the Halcyon, specifically
-    for the Hypersight version, which includes a water ROI.
-    Analyzes: HU Uniformity, Image Scaling & HU Linearity.
-    """
-
-    _model = "Hypersight Quart DVT"
-    hu_module = HypersightQuartHUModule
-    hu_module_class = HypersightQuartHUModule
+from __future__ import annotations
+
+import io
+import textwrap
+import webbrowser
+from io import BytesIO
+from pathlib import Path
+
+import numpy as np
+import scipy.ndimage
+from matplotlib import pyplot as plt
+from pydantic import BaseModel
+from scipy.interpolate import interp1d
+
+from .core import pdf
+from .core.geometry import Line, Point
+from .core.profile import FWXMProfilePhysical
+from .core.utilities import ResultBase, ResultsDataMixin
+from .ct import (
+    AIR,
+    CTP404CP504,
+    CTP486,
+    WATER,
+    CatPhanBase,
+    CatPhanModule,
+    ThicknessROI,
+    rois_to_results,
+)
+
+UNIFORMITY_OFFSET_MM = -45
+GEOMETRY_OFFSET_MM = 45
+ACRYLIC = 120
+POLY = -35
+TEFLON = 990
+
+
+class QuartHUModuleOutput(BaseModel):
+    """This class should not be called directly. It is returned by the ``results_data()`` method.
+    It is a dataclass under the hood and thus comes with all the dunder magic.
+
+    Use the following attributes as normal class attributes."""
+
+    offset: int
+    roi_settings: dict
+    rois: dict
+    measured_slice_thickness_mm: float
+    signal_to_noise: float
+    contrast_to_noise: float
+
+
+class QuartGeometryModuleOutput(BaseModel):
+    """This class should not be called directly. It is returned by the ``results_data()`` method.
+    It is a dataclass under the hood and thus comes with all the dunder magic.
+
+    Use the following attributes as normal class attributes."""
+
+    offset: int
+    roi_settings: dict
+    rois: dict
+    distances: dict
+    high_contrast_distances: dict
+    mean_high_contrast_distance: float
+
+
+class QuartUniformityModuleOutput(BaseModel):
+    """This class should not be called directly. It is returned by the ``results_data()`` method.
+    It is a dataclass under the hood and thus comes with all the dunder magic.
+
+    Use the following attributes as normal class attributes."""
+
+    offset: int
+    roi_settings: dict
+    rois: dict
+    passed: bool
+
+
+class QuartDVTResult(ResultBase):
+    """This class should not be called directly. It is returned by the ``results_data()`` method.
+    It is a dataclass under the hood and thus comes with all the dunder magic.
+
+    Use the following attributes as normal class attributes."""
+
+    phantom_model: str  #:
+    phantom_roll_deg: float  #:
+    origin_slice: int  #:
+    num_images: int  #:
+    hu_module: QuartHUModuleOutput  #:
+    uniformity_module: QuartUniformityModuleOutput  #:
+    geometric_module: QuartGeometryModuleOutput  #:
+
+
+class QuartHUModule(CTP404CP504):
+    roi_dist_mm = 52.5
+    roi_radius_mm = 6
+    roi_settings = {
+        "Air": {
+            "value": AIR,
+            "angle": -90,
+            "distance": roi_dist_mm,
+            "radius": roi_radius_mm,
+        },
+        "Poly": {
+            "value": POLY,
+            "angle": 0,
+            "distance": roi_dist_mm,
+            "radius": roi_radius_mm,
+        },
+        "Acrylic": {
+            "value": ACRYLIC,
+            "angle": 45,
+            "distance": roi_dist_mm,
+            "radius": roi_radius_mm,
+        },
+        "Teflon": {
+            "value": TEFLON,
+            "angle": 180,
+            "distance": roi_dist_mm,
+            "radius": roi_radius_mm,
+        },
+    }
+    background_roi_settings = {}
+    thickness_roi_height = 25
+    thickness_roi_width = 15
+    thickness_roi_distance_mm = 32
+    thickness_roi_settings = {
+        "Bottom": {
+            "angle": 90,
+            "width": thickness_roi_height,
+            "height": thickness_roi_width,
+            "distance": thickness_roi_distance_mm,
+        },
+        "Top": {
+            "angle": -90,
+            "width": thickness_roi_height,
+            "height": thickness_roi_width,
+            "distance": thickness_roi_distance_mm,
+        },
+    }
+
+    def _setup_geometry_rois(self) -> None:
+        # no geometry ROIs
+        pass
+
+    def _setup_thickness_rois(self) -> None:
+        """We invert the thickness ROIs because they are air gaps, not high-density wires"""
+        self.thickness_image.invert()
+        for name, setting in self.thickness_roi_settings.items():
+            self.thickness_rois[name] = ThicknessROI(
+                self.thickness_image,
+                setting["width_pixels"],
+                setting["height_pixels"],
+                setting["angle_corrected"],
+                setting["distance_pixels"],
+                self.phan_center,
+            )
+
+    @property
+    def meas_slice_thickness(self) -> float:
+        """The average slice thickness for the 4 wire measurements in mm."""
+        INCLINATION_CORRECTION = 0.577  # per manual; tan(30)
+        return np.mean(
+            sorted(
+                roi.wire_fwhm * self.mm_per_pixel * INCLINATION_CORRECTION
+                for roi in self.thickness_rois.values()
+            )
+        ) / (1 + 2 * self.pad)
+
+    @property
+    def signal_to_noise(self) -> float:
+        """Calculate the SNR based on the suggested procedure in the manual:
+        SNR = (HU + 1000) / sigma,
+        where HU is the mean HU of a chosen insert and sigma is the stdev of the HU insert.
+        We choose to use the Polystyrene as the target HU insert"""
+        return (self.rois["Poly"].pixel_value + 1000) / self.rois["Poly"].std
+
+    @property
+    def contrast_to_noise(self) -> float:
+        """Calculate the CNR based on the suggested procedure in the manual:
+        CNR = abs(HU_target - HU_background) / sigma,
+        where HU_target is the mean HU of a chosen insert, HU_background is the mean HU of the background insert
+        and sigma is the stdev of the HU background.
+        We choose to use the Polystyrene as the target HU insert and Acrylic (base phantom material) as the background
+        """
+        return (
+            abs(self.rois["Poly"].pixel_value - self.rois["Acrylic"].pixel_value)
+            / self.rois["Acrylic"].std
+        )
+
+
+class HypersightQuartHUModule(QuartHUModule):
+    roi_dist_mm = 52.5
+    roi_radius_mm = 6
+    roi_settings = {
+        "Air": {
+            "value": AIR,
+            "angle": -90,
+            "distance": roi_dist_mm,
+            "radius": roi_radius_mm,
+        },
+        "Poly": {
+            "value": POLY,
+            "angle": 0,
+            "distance": roi_dist_mm,
+            "radius": roi_radius_mm,
+        },
+        "Acrylic": {
+            "value": ACRYLIC,
+            "angle": 45,
+            "distance": roi_dist_mm,
+            "radius": roi_radius_mm,
+        },
+        "Teflon": {
+            "value": TEFLON,
+            "angle": 180,
+            "distance": roi_dist_mm,
+            "radius": roi_radius_mm,
+        },
+        "Water": {
+            "value": WATER,
+            "angle": -45,
+            "distance": roi_dist_mm,
+            "radius": 12,
+        },
+    }
+
+
+class QuartUniformityModule(CTP486):
+    """Class for analysis of the Uniformity slice of the CTP module. Measures 5 ROIs around the slice that
+    should all be close to the same value.
+    """
+
+    common_name = "HU Uniformity"
+    roi_dist_mm = 53
+    roi_radius_mm = 10
+    nominal_value = 120
+    roi_settings = {
+        "Top": {
+            "value": nominal_value,
+            "angle": -90,
+            "distance": roi_dist_mm,
+            "radius": roi_radius_mm,
+        },
+        "Right": {
+            "value": nominal_value,
+            "angle": 0,
+            "distance": roi_dist_mm,
+            "radius": roi_radius_mm,
+        },
+        "Bottom": {
+            "value": nominal_value,
+            "angle": 90,
+            "distance": roi_dist_mm,
+            "radius": roi_radius_mm,
+        },
+        "Left": {
+            "value": nominal_value,
+            "angle": 180,
+            "distance": roi_dist_mm,
+            "radius": roi_radius_mm,
+        },
+        "Center": {
+            "value": nominal_value,
+            "angle": 0,
+            "distance": 0,
+            "radius": roi_radius_mm,
+        },
+    }
+
+
+class QuartGeometryModule(CatPhanModule):
+    """Class for analysis of the Uniformity slice of the CTP module. Measures 5 ROIs around the slice that
+    should all be close to the same value.
+    """
+
+    attr_name = "geometry_module"
+    common_name = "Geometric Distortion"
+    profiles: dict
+    horiz_array: np.ndarray
+    vert_array: np.ndarray
+
+    def _setup_rois(self) -> None:
+        self.profiles = {}
+        img = (
+            self.image.array.copy()
+        )  # we copy so we don't overwrite the existing image pixels
+        img = scipy.ndimage.median_filter(img, size=3)
+        img = img - img.min()  # ground the profile
+        # calculate horizontal
+        self.horiz_array = img[int(self.phan_center.y), :]
+        prof = FWXMProfilePhysical(
+            values=self.horiz_array,
+            dpmm=1 / self.mm_per_pixel,
+        )
+        line = Line(
+            Point(round(prof.field_edge_idx("left")), self.phan_center.y),
+            Point(round(prof.field_edge_idx("right")), self.phan_center.y),
+        )
+        self.profiles["horizontal"] = {
+            "width (mm)": prof.field_width_mm,
+            "line": line,
+        }
+        # calculate vertical
+        self.vert_array = img[:, int(self.phan_center.x)]
+        prof = FWXMProfilePhysical(
+            values=self.vert_array,
+            dpmm=1 / self.mm_per_pixel,
+        )
+        line = Line(
+            Point(self.phan_center.x, round(prof.field_edge_idx("left"))),
+            Point(self.phan_center.x, round(prof.field_edge_idx("right"))),
+        )
+        self.profiles["vertical"] = {
+            "width (mm)": prof.field_width_mm,
+            "line": line,
+        }
+
+    def plot_rois(self, axis: plt.Axes):
+        for name, profile_data in self.profiles.items():
+            profile_data["line"].plot2axes(axis, width=2, color="blue")
+
+    def distances(self) -> dict[str, float]:
+        """The measurements of the phantom size for the two lines in mm"""
+        return {f"{name} mm": p["width (mm)"] for name, p in self.profiles.items()}
+
+    def high_contrast_resolutions(self) -> dict:
+        """The distance in mm from the -700 HU index to the -200 HU index.
+
+        This calculates the distance on each edge of the horizontal and vertical
+        geometric profiles for a total of 4 measurements. The result is the
+        average of the 4 values. The DICOM data is already HU-corrected so
+        -1000 => 0. This means we will search for 300 HU (-1000 + 700) and 800 HU (-1000 + 200) respectively.
+
+        This cuts the profile in half, searches for the highest-gradient index (where the phantom edge is),
+        then further cuts it down to +/-10 pixels. The 300/800 HU are then found from linear interpolation.
+        It was found that artifacts in the image could drastically influence these values, so hence the +/-10
+        subset.
+
+        Assumptions:
+        -The phantom does not cross the halfway point of the image FOV (i.e. not offset by an obscene amount).
+        -10 pixels about the phantom edge is adequate to capture the full dropoff.
+        -300 and 800 HU values will be in the profile"""
+        dists = {"Top": np.nan, "Bottom": np.nan, "Left": np.nan, "Right": np.nan}
+        edge_5mm = int(5 / self.mm_per_pixel)  # physical 5mm distance
+        keys = (key for key in dists)
+        for array in (self.horiz_array, self.vert_array):
+            split_idx = len(array) // 2  # we need not be exact, just close
+            left_data, right_data = array[:split_idx], array[split_idx:][::-1]
+            for profile_data in (left_data, right_data):
+                # find the phantom edge and chop about it
+                edge_idx = np.argmax(np.diff(profile_data))
+                edge_data = profile_data[edge_idx - edge_5mm : edge_idx + edge_5mm]
+                interp_func = interp1d(edge_data, np.arange(len(edge_data)))
+                idx_300, idx_800 = interp_func([300, 800])
+                dists[next(keys)] = abs(idx_800 - idx_300) * self.mm_per_pixel
+        return dists
+
+    def mean_high_contrast_resolution(self) -> float:
+        """Mean high-contrast resolution"""
+        return float(np.mean(list(self.high_contrast_resolutions().values())))
+
+
+class QuartDVT(CatPhanBase, ResultsDataMixin[QuartDVTResult]):
+    """A class for loading and analyzing CT DICOM files of a Quart phantom that comes with the Halcyon.
+    Analyzes: HU Uniformity, Image Scaling & HU Linearity.
+    """
+
+    _demo_url = "quart.zip"
+    _model = "Quart DVT"
+    hu_origin_slice_variance = 300
+    catphan_radius_mm = 80
+    hu_module: QuartHUModule
+    hu_module_class = QuartHUModule
+    uniformity_module: QuartUniformityModule
+    uniformity_module_class = QuartUniformityModule
+    geometry_module: QuartGeometryModule
+    geometry_module_class = QuartGeometryModule
+
+    @staticmethod
+    def run_demo(show: bool = True):
+        """Run the Quart algorithm with a head dataset."""
+        quart = QuartDVT.from_demo_images()
+        quart.analyze()
+        print(quart.results())
+        quart.plot_analyzed_image(show)
+
+    def analyze(
+        self,
+        hu_tolerance: int | float = 40,
+        scaling_tolerance: int | float = 1,
+        thickness_tolerance: int | float = 0.2,
+        cnr_threshold: int | float = 5,
+    ):
+        self.localize()
+        self.hu_module = self.hu_module_class(
+            self,
+            offset=0,
+            hu_tolerance=hu_tolerance,
+            thickness_tolerance=thickness_tolerance,
+            scaling_tolerance=scaling_tolerance,
+        )
+        self.uniformity_module = self.uniformity_module_class(
+            self, offset=UNIFORMITY_OFFSET_MM, tolerance=hu_tolerance
+        )
+        self.geometry_module = self.geometry_module_class(
+            self, tolerance=3, offset=GEOMETRY_OFFSET_MM
+        )
+
+    def plot_analyzed_image(self, show: bool = True, **plt_kwargs) -> None:
+        """Plot the images used in the calculation and summary data.
+
+        Parameters
+        ----------
+        show : bool
+            Whether to plot the image or not.
+        plt_kwargs : dict
+            Keyword args passed to the plt.figure() method. Allows one to set things like figure size.
+        """
+        # set up grid and axes
+        plt.figure(**plt_kwargs)
+        grid_size = (2, 3)
+        hu_ax = plt.subplot2grid(grid_size, (0, 1))
+        self.hu_module.plot(hu_ax)
+        hu_lin_ax = plt.subplot2grid(grid_size, (0, 2))
+        self.hu_module.plot_linearity(hu_lin_ax)
+        unif_ax = plt.subplot2grid(grid_size, (1, 0))
+        self.uniformity_module.plot(unif_ax)
+        unif_prof_ax = plt.subplot2grid(grid_size, (1, 2))
+        self.uniformity_module.plot_profiles(unif_prof_ax)
+        geometry_ax = plt.subplot2grid(grid_size, (0, 0))
+        self.geometry_module.plot(geometry_ax)
+        side_view_ax = plt.subplot2grid(grid_size, (1, 1))
+        self.plot_side_view(side_view_ax)
+
+        # finish up
+        plt.tight_layout()
+        if show:
+            plt.show()
+
+    def plot_analyzed_subimage(self, *args, **kwargs) -> None:
+        raise NotImplementedError()
+
+    def results(self, as_str: bool = True) -> str | tuple[str, ...]:
+        """Return the results of the analysis as a string. Use with print()."""
+        items = (
+            f"\n - {self._model} QA Test - \n",
+            f"HU Linearity ROIs: {self.hu_module.roi_vals_as_str}\n",
+            f"HU Passed?: {self.hu_module.passed_hu}\n",
+            f"Measured Slice Thickness (mm): {self.hu_module.meas_slice_thickness:2.3f}\n",
+            f"Slice Thickness Passed? {self.hu_module.passed_thickness}\n",
+            f"Uniformity ROIs: {self.uniformity_module.roi_vals_as_str}\n",
+            f"Uniformity Passed?: {self.uniformity_module.overall_passed}\n",
+            f"Geometric width: {self.geometry_module.distances()}",
+            f"High-Contrast distance (mm): {self.geometry_module.mean_high_contrast_resolution():2.3f}",
+        )
+        if as_str:
+            return "\n".join(items)
+        else:
+            return items
+
+    def _generate_results_data(self) -> QuartDVTResult:
+        """Return results in a data structure for more programmatic use."""
+        return QuartDVTResult(
+            phantom_model=self._model,
+            phantom_roll_deg=self.catphan_roll,
+            origin_slice=self.origin_slice,
+            num_images=self.num_images,
+            uniformity_module=QuartUniformityModuleOutput(
+                offset=UNIFORMITY_OFFSET_MM,
+                roi_settings=self.uniformity_module.roi_settings,
+                rois=rois_to_results(self.uniformity_module.rois),
+                passed=self.uniformity_module.overall_passed,
+            ),
+            geometric_module=QuartGeometryModuleOutput(
+                offset=GEOMETRY_OFFSET_MM,
+                roi_settings=self.geometry_module.roi_settings,
+                rois=rois_to_results(self.geometry_module.rois),
+                distances=self.geometry_module.distances(),
+                high_contrast_distances=self.geometry_module.high_contrast_resolutions(),
+                mean_high_contrast_distance=self.geometry_module.mean_high_contrast_resolution(),
+            ),
+            hu_module=QuartHUModuleOutput(
+                offset=0,
+                roi_settings=self.hu_module.roi_settings,
+                rois=rois_to_results(self.hu_module.rois),
+                measured_slice_thickness_mm=self.hu_module.meas_slice_thickness,
+                signal_to_noise=self.hu_module.signal_to_noise,
+                contrast_to_noise=self.hu_module.contrast_to_noise,
+            ),
+        )
+
+    def plot_images(self, show: bool = True, **plt_kwargs) -> dict[str, plt.Figure]:
+        """Plot all the individual images separately.
+
+        Parameters
+        ----------
+        show
+            Whether to show the images.
+        plt_kwargs
+            Keywords to pass to matplotlib for figure customization.
+        """
+        figs = {}
+        # plot the images
+        modules = {
+            "HU linearity": self.hu_module,
+            "HU uniformity": self.uniformity_module,
+            "Geometry": self.geometry_module,
+        }
+        for key, module in modules.items():
+            fig, ax = plt.subplots(**plt_kwargs)
+            module.plot(ax)
+            figs[key] = fig
+        # add side-view
+        fig, ax = plt.subplots(**plt_kwargs)
+        self.plot_side_view(ax)
+        figs["side"] = fig
+
+        if show:
+            plt.show()
+        return figs
+
+    def save_images(
+        self,
+        directory: Path | str | None = None,
+        to_stream: bool = False,
+        **plt_kwargs,
+    ) -> list[Path] | dict[str, BytesIO]:
+        """Save separate images to disk or stream.
+
+        Parameters
+        ----------
+        directory
+            The directory to write the images to. If None, will use current working directory
+        to_stream
+            Whether to write to stream or disk. If True, will return streams. Directory is ignored in that scenario.
+        plt_kwargs
+            Keywords to pass to matplotlib for figure customization.
+        """
+        figs = self.plot_images(show=False, **plt_kwargs)
+        paths = []
+        streams = {}
+        for name, fig in figs.items():
+            if to_stream:
+                path = io.BytesIO()
+            else:
+                destination = Path(directory) or Path.cwd()
+                path = (destination / name).with_suffix(".png").absolute()
+            fig.savefig(path)
+            paths.append(path)
+            streams[name] = path
+        if to_stream:
+            return streams
+        else:
+            return paths
+
+    def publish_pdf(
+        self,
+        filename: str | Path,
+        notes: str | None = None,
+        open_file: bool = False,
+        metadata: dict | None = None,
+        logo: Path | str | None = None,
+    ) -> None:
+        """Publish (print) a PDF containing the analysis and quantitative results.
+
+        Parameters
+        ----------
+        filename : (str, file-like object}
+            The file to write the results to.
+        notes : str, list of strings
+            Text; if str, prints single line.
+            If list of strings, each list item is printed on its own line.
+        open_file : bool
+            Whether to open the file using the default program after creation.
+        metadata : dict
+            Extra data to be passed and shown in the PDF. The key and value will be shown with a colon.
+            E.g. passing {'Author': 'James', 'Unit': 'TrueBeam'} would result in text in the PDF like:
+            --------------
+            Author: James
+            Unit: TrueBeam
+            --------------
+        logo: Path, str
+            A custom logo to use in the PDF report. If nothing is passed, the default pylinac logo is used.
+        """
+        analysis_title = f"{self._model} Analysis"
+        analysis_images = self.save_images(to_stream=True)
+
+        canvas = pdf.PylinacCanvas(
+            filename, page_title=analysis_title, metadata=metadata, logo=logo
+        )
+        if notes is not None:
+            canvas.add_text(text="Notes:", location=(1, 4.5), font_size=14)
+            canvas.add_text(text=notes, location=(1, 4))
+
+        shortened_texts = [
+            textwrap.wrap(r, width=110) for r in self.results(as_str=False)
+        ]
+        idx = 0
+        for items in enumerate(shortened_texts):
+            for text in items:
+                canvas.add_text(text=text, location=(1.5, 25 - idx * 0.5))
+                idx += 1
+        for page, img in enumerate(analysis_images.values()):
+            canvas.add_new_page()
+            canvas.add_image(img, location=(1, 5), dimensions=(18, 18))
+        canvas.finish()
+
+        if open_file:
+            webbrowser.open(filename)
+
+    def _module_offsets(self) -> list[float]:
+        absolute_origin_position = self.dicom_stack[self.origin_slice].z_position
+        relative_offsets_mm = [0, UNIFORMITY_OFFSET_MM, GEOMETRY_OFFSET_MM]
+        return [
+            absolute_origin_position + offset_mm for offset_mm in relative_offsets_mm
+        ]
+
+    def _detected_modules(self) -> list[CatPhanModule]:
+        return [self.uniformity_module, self.hu_module, self.geometry_module]
+
+
+class HypersightQuartDVT(QuartDVT):
+    """A class for loading and analyzing CT DICOM files of a Quart phantom that comes with the Halcyon, specifically
+    for the Hypersight version, which includes a water ROI.
+    Analyzes: HU Uniformity, Image Scaling & HU Linearity.
+    """
+
+    _model = "Hypersight Quart DVT"
+    hu_module = HypersightQuartHUModule
+    hu_module_class = HypersightQuartHUModule
```

### Comparing `manteia_qa_pylinac-1.0.0/pylinac/settings.py` & `manteia_qa_pylinac-1.1.0/pylinac/settings.py`

 * *Ordering differences only*

 * *Files 26% similar despite different names*

```diff
@@ -1,18 +1,18 @@
-"""Pylinac settings"""
-from matplotlib.colors import LinearSegmentedColormap
-from matplotlib.pyplot import cm
-
-# use a string or colormap option. See options here: http://matplotlib.org/examples/color/colormaps_reference.html
-DICOM_COLORMAP = cm.gray
-ARRAY_COLORMAP = cm.gray
-PATH_TRUNCATION_LENGTH = 80
-
-
-def get_dicom_cmap() -> LinearSegmentedColormap:
-    """Return the DICOM colormap. Passed to cmap parameter in matplotlib calls."""
-    return DICOM_COLORMAP
-
-
-def get_array_cmap() -> LinearSegmentedColormap:
-    """Return the array colormap. Passed to cmap parameter in matplotlib calls."""
-    return ARRAY_COLORMAP
+"""Pylinac settings"""
+from matplotlib.colors import LinearSegmentedColormap
+from matplotlib.pyplot import cm
+
+# use a string or colormap option. See options here: http://matplotlib.org/examples/color/colormaps_reference.html
+DICOM_COLORMAP = cm.gray
+ARRAY_COLORMAP = cm.gray
+PATH_TRUNCATION_LENGTH = 80
+
+
+def get_dicom_cmap() -> LinearSegmentedColormap:
+    """Return the DICOM colormap. Passed to cmap parameter in matplotlib calls."""
+    return DICOM_COLORMAP
+
+
+def get_array_cmap() -> LinearSegmentedColormap:
+    """Return the array colormap. Passed to cmap parameter in matplotlib calls."""
+    return ARRAY_COLORMAP
```

### Comparing `manteia_qa_pylinac-1.0.0/pylinac/starshot.py` & `manteia_qa_pylinac-1.1.0/pylinac/starshot.py`

 * *Files 11% similar despite different names*

```diff
@@ -1,699 +1,693 @@
-"""
-The Starshot module analyses a starshot image made of radiation spokes, whether gantry, collimator, MLC or couch.
-It is based on ideas from `Depuydt et al <http://iopscience.iop.org/0031-9155/57/10/2997>`_
-and `Gonzalez et al <http://dx.doi.org/10.1118/1.1755491>`_.
-
-Features:
-
-* **Analyze scanned film images, single EPID images, or a set of EPID images** -
-  Any image that you can load in can be analyzed, including 1 or a set of EPID DICOM images and
-  films that have been digitally scanned.
-* **Any image size** - Have machines with different EPIDs? Scanned your film at different resolutions? No problem.
-* **Dose/OD can be inverted** - Whether your device/image views dose as an increase in value or a decrease, pylinac
-  will detect it and invert if necessary.
-* **Automatic noise detection & correction** - Sometimes there's dirt on the scanned film; sometimes there's a dead pixel on the EPID.
-  Pylinac will detect these spurious noise signals and can avoid or account for them.
-* **Accurate, FWHM star line detection** - Pylinac uses not simply the maximum value to find the center of a star line,
-  but analyzes the entire star profile to determine the center of the FWHM, ensuring small noise or maximum value bias is avoided.
-* **Adaptive searching** - If you passed pylinac a set of parameters and a good result wasn't found, pylinac can recover and
-  do an adaptive search by adjusting parameters to find a "reasonable" wobble.
-"""
-from __future__ import annotations
-
-import copy
-import dataclasses
-import io
-import webbrowser
-from dataclasses import dataclass
-from pathlib import Path
-from typing import BinaryIO
-
-import argue
-import matplotlib.pyplot as plt
-import numpy as np
-from scipy import optimize
-
-from .core import image, pdf
-from .core.geometry import Circle, Line, Point
-from .core.io import TemporaryZipDirectory, get_url, retrieve_demo_file
-from .core.profile import CollapsedCircleProfile, FWXMProfile
-from .core.utilities import ResultBase
-from .settings import get_dicom_cmap
-
-
-@dataclass
-class StarshotResults(ResultBase):
-    """This class should not be called directly. It is returned by the ``results_data()`` method.
-    It is a dataclass under the hood and thus comes with all the dunder magic.
-
-    Use the following attributes as normal class attributes.
-    """
-
-    tolerance_mm: float  #:
-    circle_diameter_mm: float  #:
-    circle_radius_mm: float  #:
-    passed: bool  #:
-    circle_center_x_y: tuple[float, float]  #:
-
-
-class Starshot:
-    """Class that can determine the wobble in a "starshot" image, be it gantry, collimator,
-    couch or MLC. The image can be a scanned film (TIF, JPG, etc) or a sequence of EPID DICOM images.
-
-    Attributes
-    ----------
-    image : :class:`~pylinac.core.image.Image`
-    circle_profile : :class:`~pylinac.starshot.StarProfile`
-    lines : :class:`~pylinac.starshot.LineManager`
-    wobble : :class:`~pylinac.starshot.Wobble`
-    tolerance : :class:`~pylinac.starshot.Tolerance`
-
-    Examples
-    --------
-    Run the demo:
-        >>> Starshot.run_demo()
-
-    Typical session:
-        >>> img_path = r"C:/QA/Starshots/Coll.jpeg"
-        >>> mystar = Starshot(img_path, dpi=105, sid=1000)
-        >>> mystar.analyze()
-        >>> print(mystar.results())
-        >>> mystar.plot_analyzed_image()
-    """
-
-    def __init__(self, filepath: str | BinaryIO, **kwargs):
-        """
-        Parameters
-        ----------
-        filepath
-            The path to the image file.
-        kwargs
-            Passed to :func:`~pylinac.core.image.load`.
-        """
-        self.image = image.load(filepath, **kwargs)
-        self.wobble = Wobble()
-        self.tolerance = 1
-        if self.image.dpmm is None:
-            raise ValueError(
-                "DPI was not a tag in the image nor was it passed in. Please pass a DPI value"
-            )
-        if self.image.sid is None:
-            raise ValueError(
-                "Source-to-Image distance was not an image tag and was not passed in. Please pass an SID value."
-            )
-
-    @classmethod
-    def from_url(cls, url: str, **kwargs):
-        """Instantiate from a URL.
-
-        Parameters
-        ----------
-        url : str
-            URL of the raw file.
-        kwargs
-            Passed to :func:`~pylinac.core.image.load`.
-        """
-        filename = get_url(url)
-        return cls(filename, **kwargs)
-
-    @classmethod
-    def from_demo_image(cls):
-        """Construct a Starshot instance and load the demo image."""
-        demo_file = retrieve_demo_file(name="starshot.tif")
-        return cls(demo_file, sid=1000)
-
-    @classmethod
-    def from_multiple_images(
-        cls,
-        filepath_list: list,
-        stretch_each: bool = True,
-        method: str = "sum",
-        **kwargs,
-    ):
-        """Construct a Starshot instance and load in and combine multiple images.
-
-        Parameters
-        ----------
-        filepath_list : iterable
-            An iterable of file paths to starshot images that are to be superimposed.
-        stretch_each : bool
-            Whether to stretch each image individually before combining. See ``load_multiples``.
-        method : {'sum', 'mean'}
-            The method to combine the images. See ``load_multiples``.
-        kwargs
-            Passed to :func:`~pylinac.core.image.load_multiples`.
-        """
-        with io.BytesIO() as stream:
-            img = image.load_multiples(
-                filepath_list, stretch_each=stretch_each, method=method, **kwargs
-            )
-            img.save(stream)
-            stream.seek(0)
-            return cls(stream, **kwargs)
-
-    @classmethod
-    def from_zip(cls, zip_file: str, **kwargs):
-        """Construct a Starshot instance from a ZIP archive.
-
-        Parameters
-        ----------
-        zip_file : str
-            Points to the ZIP archive. Can contain a single or multiple images. If multiple images
-            the images are combined and thus should be from the same test sequence.
-        kwargs
-            Passed to :func:`~pylinac.core.image.load_multiples`.
-        """
-        with TemporaryZipDirectory(zip_file) as tmpdir:
-            image_files = image.retrieve_image_files(tmpdir)
-            if not image_files:
-                raise IndexError(f"No valid starshot images were found in {zip_file}")
-            if len(image_files) > 1:
-                return cls.from_multiple_images(image_files, **kwargs)
-            else:
-                return cls(image_files[0], **kwargs)
-
-    def _get_reasonable_start_point(self) -> Point:
-        """Set the algorithm starting point automatically.
-
-        Notes
-        -----
-        The determination of an automatic start point is accomplished by finding the Full-Width-80%-Max.
-        Finding the maximum pixel does not consistently work, esp. in the presence of a pin prick. The
-        FW80M is a more consistent metric for finding a good start point.
-        """
-        # sum the image along each axis within the central 1/3 (avoids outlier influence from say, gantry shots)
-        top_third = int(self.image.array.shape[0] / 3)
-        bottom_third = int(top_third * 2)
-        left_third = int(self.image.array.shape[1] / 3)
-        right_third = int(left_third * 2)
-        central_array = self.image.array[top_third:bottom_third, left_third:right_third]
-
-        x_sum = np.sum(central_array, 0)
-        y_sum = np.sum(central_array, 1)
-
-        # Calculate Full-Width, 80% Maximum center
-        fwxm_x_point = (
-            round(FWXMProfile(values=x_sum, fwxm_height=80).center_idx) + left_third
-        )
-        fwxm_y_point = (
-            round(FWXMProfile(values=y_sum, fwxm_height=80).center_idx) + top_third
-        )
-        center_point = Point(fwxm_x_point, fwxm_y_point)
-        return center_point
-
-    @argue.bounds(radius=(0.2, 0.95), min_peak_height=(0.05, 0.95))
-    def analyze(
-        self,
-        radius: float = 0.85,
-        min_peak_height: float = 0.25,
-        tolerance: float = 1.0,
-        start_point: Point | tuple | None = None,
-        fwhm: bool = True,
-        recursive: bool = True,
-        invert: bool = False,
-    ):
-        """Analyze the starshot image.
-
-        Analyze finds the minimum radius and center of a circle that touches all the lines
-        (i.e. the wobble circle diameter and wobble center).
-
-        Parameters
-        ----------
-        radius : float, optional
-            Distance in % between starting point and closest image edge; used to build the circular profile which finds
-            the radiation lines. Must be between 0.05 and 0.95.
-        min_peak_height : float, optional
-            The percentage minimum height a peak must be to be considered a valid peak. A lower value catches
-            radiation peaks that vary in magnitude (e.g. different MU delivered or gantry shot), but could also pick up noise.
-            If necessary, lower value for gantry shots and increase for noisy images.
-        tolerance : int, float, optional
-            The tolerance in mm to test against for a pass/fail result.
-        start_point : 2-element iterable, optional
-            The point where the algorithm should center the circle profile, given as (x-value, y-value).
-            If None (default), will search for a reasonable maximum point nearest the center of the image.
-        fwhm : bool
-            If True (default), the center of the FWHM of the spokes will be determined.
-            If False, the peak value location is used as the spoke center.
-
-            .. note:: In practice, this ends up being a very small difference. Set to false if peak locations are offset or unexpected.
-        recursive : bool
-            If True (default), will recursively search for a "reasonable" wobble, meaning the wobble radius is
-            <3mm. If the wobble found was unreasonable,
-            the minimum peak height is iteratively adjusted from low to high at the passed radius.
-            If for all peak heights at the given radius the wobble is still unreasonable, the
-            radius is then iterated over from most distant inward, iterating over minimum peak heights at each radius.
-            If False, will simply return the first determined value or raise error if a reasonable wobble could not be determined.
-
-            .. warning:: It is strongly recommended to leave this setting at True.
-
-        invert : bool
-            Whether to force invert the image values. This should be set to True if the automatically-determined
-            pylinac inversion is incorrect.
-
-        Raises
-        ------
-        RuntimeError
-            If a reasonable wobble value was not found.
-        """
-        self.tolerance = tolerance
-        self.image.check_inversion_by_histogram(percentiles=[4, 50, 96])
-        if invert:
-            self.image.invert()
-
-        if start_point is None:
-            start_point = self._get_reasonable_start_point()
-
-        self._get_reasonable_wobble(
-            start_point, fwhm, min_peak_height, radius, recursive
-        )
-
-    def _get_reasonable_wobble(
-        self, start_point, fwhm, min_peak_height, radius, recursive
-    ):
-        """Determine a wobble that is "reasonable". If recursive is false, the first iteration will be passed,
-        otherwise the parameters will be tweaked to search for a reasonable wobble."""
-        wobble_unreasonable = True
-        focus_point = copy.copy(start_point)
-        peak_gen = get_peak_height()
-        radius_gen = get_radius()
-        while wobble_unreasonable:
-            try:
-                self.circle_profile = StarProfile(
-                    self.image, focus_point, radius, min_peak_height, fwhm
-                )
-                if (len(self.circle_profile.peaks) < 6) or (
-                    len(self.circle_profile.peaks) % 2 != 0
-                ):
-                    raise ValueError
-                self.lines = LineManager(self.circle_profile.peaks)
-                self._find_wobble_minimize()
-            except ValueError:
-                if not recursive:
-                    raise RuntimeError(
-                        "The algorithm was unable to properly detect the radiation lines. Try setting "
-                        "recursive to True or lower the minimum peak height"
-                    )
-                else:
-                    try:
-                        min_peak_height = next(peak_gen)
-                    except StopIteration:
-                        # if no height setting works, change the radius and reset the height
-                        try:
-                            radius = next(radius_gen)
-                            peak_gen = get_peak_height()
-                        except StopIteration:
-                            raise RuntimeError(
-                                "The algorithm was unable to determine a reasonable wobble. Try setting "
-                                "recursive to False and manually adjusting algorithm parameters"
-                            )
-
-            else:  # if no errors are raised
-                # set the focus point to the wobble minimum
-                # focus_point = self.wobble.center
-                # finally:
-                # stop after first iteration if not recursive
-                if not recursive:
-                    wobble_unreasonable = False
-                # otherwise, check if the wobble is reasonable
-                else:
-                    # if so, stop
-                    if self.wobble.diameter_mm < 2:
-                        focus_near_center = (
-                            self.wobble.center.distance_to(focus_point) < 5
-                        )
-                        if focus_near_center:
-                            wobble_unreasonable = False
-                        else:
-                            focus_point = self.wobble.center
-                    # otherwise, iterate through peak height
-                    else:
-                        try:
-                            min_peak_height = next(peak_gen)
-                        except StopIteration:
-                            # if no height setting works, change the radius and reset the height
-                            try:
-                                radius = next(radius_gen)
-                                peak_gen = get_peak_height()
-                            except StopIteration:
-                                raise RuntimeError(
-                                    "The algorithm was unable to determine a reasonable wobble. Try setting "
-                                    "recursive to False and manually adjusting algorithm parameters"
-                                )
-
-    def _find_wobble_minimize(self) -> None:
-        """Find the minimum distance wobble location and radius to all radiation lines.
-
-        The minimum is found using a scipy minimization function.
-        """
-        # starting point
-        sp = copy.copy(self.circle_profile.center)
-
-        def distance(p, lines):
-            """Calculate the maximum distance to any line from the given point."""
-            return max(line.distance_to(Point(p[0], p[1])) for line in lines)
-
-        res = optimize.minimize(
-            distance,
-            sp.as_array(),
-            args=(self.lines,),
-            method="Nelder-Mead",
-            options={"fatol": 0.001},
-        )
-        # res = optimize.least_squares(distance, sp.as_array(), args=(self.lines,), ftol=0.001)
-
-        self.wobble.radius = res.fun
-        self.wobble.radius_mm = res.fun / self.image.dpmm
-        self.wobble.center = Point(res.x[0], res.x[1])
-
-    @property
-    def passed(self) -> bool:
-        """Boolean specifying whether the determined wobble was within tolerance."""
-        return self.wobble.radius_mm * 2 < self.tolerance
-
-    @property
-    def _passfail_str(self) -> str:
-        """Return a pass/fail string."""
-        return "PASS" if self.passed else "FAIL"
-
-    def results(self, as_list: bool = False) -> str | list[str]:
-        """Return the results of the analysis.
-
-        Parameters
-        ----------
-        as_list : bool
-            Whether to return as a list of strings vs single string. Pretty much for internal usage.
-        """
-        results = [
-            " - Starshot Results - ",
-            f"Result: {self._passfail_str}",
-            f"The minimum circle that touches all the star lines has a diameter of {self.wobble.radius_mm*2:2.3f} mm.",
-            f"The center of the minimum circle is at {self.wobble.center.x:3.1f}, {self.wobble.center.y:3.1f}",
-        ]
-        if not as_list:
-            results = "\n".join(results)
-        return results
-
-    def results_data(self, as_dict: bool = False) -> StarshotResults | dict:
-        """Present the results data and metadata as a dataclass or dict.
-        The default return type is a dataclass."""
-        data = StarshotResults(
-            tolerance_mm=self.tolerance,
-            circle_diameter_mm=self.wobble.radius_mm * 2,
-            circle_radius_mm=self.wobble.radius_mm,
-            circle_center_x_y=(self.wobble.center.x, self.wobble.center.y),
-            passed=self.passed,
-        )
-        if as_dict:
-            return dataclasses.asdict(data)
-        return data
-
-    def plot_analyzed_image(self, show: bool = True, **plt_kwargs: dict):
-        """Draw the star lines, profile circle, and wobble circle on a matplotlib figure.
-
-        Parameters
-        ----------
-        show : bool
-            Whether to actually show the image.
-        plt_kwargs : dict
-            Keyword args passed to the plt.subplots() method. Allows one to set things like figure size.
-        """
-        fig, axes = plt.subplots(ncols=2, **plt_kwargs)
-        subimages = ("whole", "wobble")
-        titles = ("Analyzed Image", "Wobble Circle")
-
-        # show images
-        for ax, subimage, title in zip(axes, subimages, titles):
-            self.plot_analyzed_subimage(ax=ax, show=False, subimage=subimage)
-            ax.set_title(title)
-
-        if show:
-            plt.show()
-
-    def plot_analyzed_subimage(
-        self,
-        subimage: str = "wobble",
-        ax: plt.Axes | None = None,
-        show: bool = True,
-        **plt_kwargs: dict,
-    ):
-        """Plot a subimage of the starshot analysis. Current options are the zoomed out image and the zoomed in image.
-
-        Parameters
-        ----------
-        subimage : str
-            If 'wobble', will show a zoomed in plot of the wobble circle.
-            Any other string will show the zoomed out plot.
-        ax : None, matplotlib Axes
-            If None (default), will create a new figure to plot on, otherwise plot to the passed axes.
-        show : bool
-            Whether to actually show the image.
-        plt_kwargs : dict
-            Keyword args passed to the plt.figure() method. Allows one to set things like figure size. Only used if ax is not passed.
-        """
-        if ax is None:
-            fig, ax = plt.subplots(**plt_kwargs)
-        # show analyzed image
-        ax.imshow(self.image.array, cmap=get_dicom_cmap())
-        self.lines.plot(ax)
-        self.wobble.plot2axes(ax, edgecolor="green")
-        self.circle_profile.plot2axes(ax, edgecolor="green")
-        ax.autoscale(tight=True)
-        ax.axis("off")
-
-        # zoom in if wobble plot
-        if subimage == "wobble":
-            xlims = [
-                self.wobble.center.x + self.wobble.diameter,
-                self.wobble.center.x - self.wobble.diameter,
-            ]
-            ylims = [
-                self.wobble.center.y + self.wobble.diameter,
-                self.wobble.center.y - self.wobble.diameter,
-            ]
-            ax.set_xlim(xlims)
-            ax.set_ylim(ylims)
-            ax.axis("on")
-
-        if show:
-            plt.show()
-
-    def save_analyzed_image(self, filename: str, **kwargs):
-        """Save the analyzed image plot to a file.
-
-        Parameters
-        ----------
-        filename : str, IO stream
-            The filename to save as. Format is deduced from string extention, if there is one. E.g. 'mystar.png' will
-            produce a PNG image.
-        kwargs
-            All other kwargs are passed to plt.savefig().
-        """
-        self.plot_analyzed_image(show=False)
-        plt.savefig(filename, **kwargs)
-
-    def save_analyzed_subimage(self, filename: str, subimage: str = "wobble", **kwargs):
-        """Save the analyzed subimage to a file.
-
-        Parameters
-        ----------
-        filename : str, file-object
-            Where to save the file to.
-        subimage : str
-            If 'wobble', will show a zoomed in plot of the wobble circle.
-            Any other string will show the zoomed out plot.
-        kwargs
-            Passed to matplotlib.
-        """
-        self.plot_analyzed_subimage(subimage=subimage, show=False)
-        plt.savefig(filename, **kwargs)
-
-    def publish_pdf(
-        self,
-        filename: str | BinaryIO,
-        notes: str | list[str] | None = None,
-        open_file: bool = False,
-        metadata: dict | None = None,
-        logo: Path | str | None = None,
-    ):
-        """Publish (print) a PDF containing the analysis, images, and quantitative results.
-
-        Parameters
-        ----------
-        filename : (str, file-like object}
-            The file to write the results to.
-        notes : str, list of strings
-            Text; if str, prints single line.
-            If list of strings, each list item is printed on its own line.
-        open_file : bool
-            Whether to open the file using the default program after creation.
-        metadata : dict
-            Extra data to be passed and shown in the PDF. The key and value will be shown with a colon.
-            E.g. passing {'Author': 'James', 'Unit': 'TrueBeam'} would result in text in the PDF like:
-            --------------
-            Author: James
-            Unit: TrueBeam
-            --------------
-        logo: Path, str
-            A custom logo to use in the PDF report. If nothing is passed, the default pylinac logo is used.
-        """
-        canvas = pdf.PylinacCanvas(
-            filename, page_title="Starshot Analysis", metadata=metadata, logo=logo
-        )
-        for img, height in zip(("wobble", "asdf"), (2, 11.5)):
-            data = io.BytesIO()
-            self.save_analyzed_subimage(data, img)
-            canvas.add_image(data, location=(4, height), dimensions=(13, 13))
-        text = [
-            "Starshot results:",
-            f"Source-to-Image Distance (mm): {self.image.sid:2.0f}",
-            f"Tolerance (mm): {self.tolerance:2.1f}",
-            f"Minimum circle diameter (mm): {self.wobble.radius_mm*2:2.2f}",
-        ]
-        canvas.add_text(text=text, location=(10, 25.5), font_size=12)
-        if notes is not None:
-            canvas.add_text(text="Notes:", location=(1, 5.5), font_size=14)
-            canvas.add_text(text=notes, location=(1, 5))
-        canvas.finish()
-
-        if open_file:
-            webbrowser.open(filename)
-
-    @staticmethod
-    def run_demo():
-        """Demonstrate the Starshot module using the demo image."""
-        star = Starshot.from_demo_image()
-        star.analyze()
-        print(star.results())
-        star.plot_analyzed_image()
-
-
-class Wobble(Circle):
-    """A class that holds the wobble information of the Starshot analysis.
-
-    Attributes
-    ----------
-    radius_mm : The radius of the Circle in **mm**.
-    """
-
-    def __init__(self, center_point=None, radius=None):
-        super().__init__(center_point=center_point, radius=radius)
-        self.radius_mm = 0  # The radius of the wobble in mm; as opposed to pixels.
-
-    @property
-    def diameter_mm(self) -> float:
-        """Diameter of the wobble in mm."""
-        return self.radius_mm * 2
-
-
-class LineManager:
-    """Manages the radiation lines found."""
-
-    def __init__(self, points: list[Point]):
-        """
-        Parameters
-        ----------
-        points :
-            The peak points found by the StarProfile
-        """
-        self.lines = []
-        self.construct_rad_lines(points)
-
-    def __getitem__(self, item):
-        return self.lines[item]
-
-    def __len__(self):
-        return len(self.lines)
-
-    def construct_rad_lines(self, points: list[Point]):
-        """Find and match the positions of peaks in the circle profile (radiation lines)
-            and map their positions to the starshot image.
-
-        Radiation lines are found by finding the FWHM of the radiation spokes, then matching them
-        to form lines.
-
-        Returns
-        -------
-        lines : list
-            A list of Lines (radiation lines) found.
-
-        See Also
-        --------
-        Starshot.analyze() : min_peak_height parameter info
-        core.profile.CircleProfile.find_FWXM_peaks : min_peak_distance parameter info.
-        geometry.Line : returning object
-        """
-        self.match_points(points)
-
-    def match_points(self, points: list[Point]):
-        """Match the peaks found to the same radiation lines.
-
-        Peaks are matched by connecting the existing peaks based on an offset of peaks. E.g. if there are
-        12 peaks, there must be 6 radiation lines. Furthermore, assuming star lines go all the way across the CAX,
-        the 7th peak will be the opposite peak of the 1st peak, forming a line. This method is robust to
-        starting points far away from the real center.
-        """
-        num_rad_lines = int(len(points) / 2)
-        offset = num_rad_lines
-        self.lines = [
-            Line(points[line], points[line + offset]) for line in range(num_rad_lines)
-        ]
-
-    def plot(self, axis: plt.Axes):
-        """Plot the lines to the axis."""
-        for line in self.lines:
-            line.plot2axes(axis, color="blue")
-
-
-class StarProfile(CollapsedCircleProfile):
-    """Class that holds and analyzes the circular profile which finds the radiation lines."""
-
-    def __init__(self, image, start_point, radius, min_peak_height, fwhm):
-        radius = self._convert_radius_perc2pix(image, start_point, radius)
-        super().__init__(
-            center=start_point,
-            radius=radius,
-            image_array=image.array,
-            width_ratio=0.1,
-            sampling_ratio=3,
-        )
-        self.get_peaks(min_peak_height, fwhm=fwhm)
-
-    @staticmethod
-    def _convert_radius_perc2pix(image, start_point, radius):
-        """Convert a percent radius to distance in pixels, based on the distance from center point to image
-            edge.
-
-        Parameters
-        ----------
-        radius : float
-            The radius ratio (e.g. 0.5).
-        """
-        return image.dist2edge_min(start_point) * radius
-
-    def _roll_prof_to_midvalley(self) -> int:
-        """Roll the circle profile so that its edges are not near a radiation line.
-        This is a prerequisite for properly finding star lines.
-        """
-        roll_amount = np.where(self.values == self.values.min())[0][0]
-        self.roll(roll_amount)
-        return roll_amount
-
-    def get_peaks(self, min_peak_height, min_peak_distance=0.02, fwhm=True):
-        """Determine the peaks of the profile."""
-        self._roll_prof_to_midvalley()
-        self.filter(size=0.003, kind="gaussian")
-        self.ground()
-        if fwhm:
-            self.find_fwxm_peaks(
-                threshold=min_peak_height, min_distance=min_peak_distance
-            )
-        else:
-            self.find_peaks(min_peak_height, min_peak_distance)
-
-
-def get_peak_height():
-    yield from np.linspace(0.05, 0.95, 10)
-
-
-def get_radius():
-    yield from np.linspace(0.95, 0.1, 10)
+"""
+The Starshot module analyses a starshot image made of radiation spokes, whether gantry, collimator, MLC or couch.
+It is based on ideas from `Depuydt et al <http://iopscience.iop.org/0031-9155/57/10/2997>`_
+and `Gonzalez et al <http://dx.doi.org/10.1118/1.1755491>`_.
+
+Features:
+
+* **Analyze scanned film images, single EPID images, or a set of EPID images** -
+  Any image that you can load in can be analyzed, including 1 or a set of EPID DICOM images and
+  films that have been digitally scanned.
+* **Any image size** - Have machines with different EPIDs? Scanned your film at different resolutions? No problem.
+* **Dose/OD can be inverted** - Whether your device/image views dose as an increase in value or a decrease, pylinac
+  will detect it and invert if necessary.
+* **Automatic noise detection & correction** - Sometimes there's dirt on the scanned film; sometimes there's a dead pixel on the EPID.
+  Pylinac will detect these spurious noise signals and can avoid or account for them.
+* **Accurate, FWHM star line detection** - Pylinac uses not simply the maximum value to find the center of a star line,
+  but analyzes the entire star profile to determine the center of the FWHM, ensuring small noise or maximum value bias is avoided.
+* **Adaptive searching** - If you passed pylinac a set of parameters and a good result wasn't found, pylinac can recover and
+  do an adaptive search by adjusting parameters to find a "reasonable" wobble.
+"""
+from __future__ import annotations
+
+import copy
+import io
+import webbrowser
+from pathlib import Path
+from typing import BinaryIO
+
+import argue
+import matplotlib.pyplot as plt
+import numpy as np
+from scipy import optimize
+
+from .core import image, pdf
+from .core.geometry import Circle, Line, Point
+from .core.io import TemporaryZipDirectory, get_url, retrieve_demo_file
+from .core.profile import CollapsedCircleProfile, FWXMProfile
+from .core.utilities import ResultBase, ResultsDataMixin
+from .settings import get_dicom_cmap
+
+
+class StarshotResults(ResultBase):
+    """This class should not be called directly. It is returned by the ``results_data()`` method.
+    It is a dataclass under the hood and thus comes with all the dunder magic.
+
+    Use the following attributes as normal class attributes.
+    """
+
+    tolerance_mm: float  #:
+    circle_diameter_mm: float  #:
+    circle_radius_mm: float  #:
+    passed: bool  #:
+    circle_center_x_y: tuple[float, float]  #:
+
+
+class Starshot(ResultsDataMixin[StarshotResults]):
+    """Class that can determine the wobble in a "starshot" image, be it gantry, collimator,
+    couch or MLC. The image can be a scanned film (TIF, JPG, etc) or a sequence of EPID DICOM images.
+
+    Attributes
+    ----------
+    image : :class:`~pylinac.core.image.Image`
+    circle_profile : :class:`~pylinac.starshot.StarProfile`
+    lines : :class:`~pylinac.starshot.LineManager`
+    wobble : :class:`~pylinac.starshot.Wobble`
+    tolerance : :class:`~pylinac.starshot.Tolerance`
+
+    Examples
+    --------
+    Run the demo:
+        >>> Starshot.run_demo()
+
+    Typical session:
+        >>> img_path = r"C:/QA/Starshots/Coll.jpeg"
+        >>> mystar = Starshot(img_path, dpi=105, sid=1000)
+        >>> mystar.analyze()
+        >>> print(mystar.results())
+        >>> mystar.plot_analyzed_image()
+    """
+
+    def __init__(self, filepath: str | BinaryIO, **kwargs):
+        """
+        Parameters
+        ----------
+        filepath
+            The path to the image file.
+        kwargs
+            Passed to :func:`~pylinac.core.image.load`.
+        """
+        self.image = image.load(filepath, **kwargs)
+        self.wobble = Wobble()
+        self.tolerance = 1
+        if self.image.dpmm is None:
+            raise ValueError(
+                "DPI was not a tag in the image nor was it passed in. Please pass a DPI value"
+            )
+        if self.image.sid is None:
+            raise ValueError(
+                "Source-to-Image distance was not an image tag and was not passed in. Please pass an SID value."
+            )
+
+    @classmethod
+    def from_url(cls, url: str, **kwargs):
+        """Instantiate from a URL.
+
+        Parameters
+        ----------
+        url : str
+            URL of the raw file.
+        kwargs
+            Passed to :func:`~pylinac.core.image.load`.
+        """
+        filename = get_url(url)
+        return cls(filename, **kwargs)
+
+    @classmethod
+    def from_demo_image(cls):
+        """Construct a Starshot instance and load the demo image."""
+        demo_file = retrieve_demo_file(name="starshot.tif")
+        return cls(demo_file, sid=1000)
+
+    @classmethod
+    def from_multiple_images(
+        cls,
+        filepath_list: list,
+        stretch_each: bool = True,
+        method: str = "sum",
+        **kwargs,
+    ):
+        """Construct a Starshot instance and load in and combine multiple images.
+
+        Parameters
+        ----------
+        filepath_list : iterable
+            An iterable of file paths to starshot images that are to be superimposed.
+        stretch_each : bool
+            Whether to stretch each image individually before combining. See ``load_multiples``.
+        method : {'sum', 'mean'}
+            The method to combine the images. See ``load_multiples``.
+        kwargs
+            Passed to :func:`~pylinac.core.image.load_multiples`.
+        """
+        with io.BytesIO() as stream:
+            img = image.load_multiples(
+                filepath_list, stretch_each=stretch_each, method=method, **kwargs
+            )
+            img.save(stream)
+            stream.seek(0)
+            return cls(stream, **kwargs)
+
+    @classmethod
+    def from_zip(cls, zip_file: str, **kwargs):
+        """Construct a Starshot instance from a ZIP archive.
+
+        Parameters
+        ----------
+        zip_file : str
+            Points to the ZIP archive. Can contain a single or multiple images. If multiple images
+            the images are combined and thus should be from the same test sequence.
+        kwargs
+            Passed to :func:`~pylinac.core.image.load_multiples`.
+        """
+        with TemporaryZipDirectory(zip_file) as tmpdir:
+            image_files = image.retrieve_image_files(tmpdir)
+            if not image_files:
+                raise IndexError(f"No valid starshot images were found in {zip_file}")
+            if len(image_files) > 1:
+                return cls.from_multiple_images(image_files, **kwargs)
+            else:
+                return cls(image_files[0], **kwargs)
+
+    def _get_reasonable_start_point(self) -> Point:
+        """Set the algorithm starting point automatically.
+
+        Notes
+        -----
+        The determination of an automatic start point is accomplished by finding the Full-Width-80%-Max.
+        Finding the maximum pixel does not consistently work, esp. in the presence of a pin prick. The
+        FW80M is a more consistent metric for finding a good start point.
+        """
+        # sum the image along each axis within the central 1/3 (avoids outlier influence from say, gantry shots)
+        top_third = int(self.image.array.shape[0] / 3)
+        bottom_third = int(top_third * 2)
+        left_third = int(self.image.array.shape[1] / 3)
+        right_third = int(left_third * 2)
+        central_array = self.image.array[top_third:bottom_third, left_third:right_third]
+
+        x_sum = np.sum(central_array, 0)
+        y_sum = np.sum(central_array, 1)
+
+        # Calculate Full-Width, 80% Maximum center
+        fwxm_x_point = (
+            round(FWXMProfile(values=x_sum, fwxm_height=80).center_idx) + left_third
+        )
+        fwxm_y_point = (
+            round(FWXMProfile(values=y_sum, fwxm_height=80).center_idx) + top_third
+        )
+        center_point = Point(fwxm_x_point, fwxm_y_point)
+        return center_point
+
+    @argue.bounds(radius=(0.2, 0.95), min_peak_height=(0.05, 0.95))
+    def analyze(
+        self,
+        radius: float = 0.85,
+        min_peak_height: float = 0.25,
+        tolerance: float = 1.0,
+        start_point: Point | tuple | None = None,
+        fwhm: bool = True,
+        recursive: bool = True,
+        invert: bool = False,
+    ):
+        """Analyze the starshot image.
+
+        Analyze finds the minimum radius and center of a circle that touches all the lines
+        (i.e. the wobble circle diameter and wobble center).
+
+        Parameters
+        ----------
+        radius : float, optional
+            Distance in % between starting point and closest image edge; used to build the circular profile which finds
+            the radiation lines. Must be between 0.05 and 0.95.
+        min_peak_height : float, optional
+            The percentage minimum height a peak must be to be considered a valid peak. A lower value catches
+            radiation peaks that vary in magnitude (e.g. different MU delivered or gantry shot), but could also pick up noise.
+            If necessary, lower value for gantry shots and increase for noisy images.
+        tolerance : int, float, optional
+            The tolerance in mm to test against for a pass/fail result.
+        start_point : 2-element iterable, optional
+            The point where the algorithm should center the circle profile, given as (x-value, y-value).
+            If None (default), will search for a reasonable maximum point nearest the center of the image.
+        fwhm : bool
+            If True (default), the center of the FWHM of the spokes will be determined.
+            If False, the peak value location is used as the spoke center.
+
+            .. note:: In practice, this ends up being a very small difference. Set to false if peak locations are offset or unexpected.
+        recursive : bool
+            If True (default), will recursively search for a "reasonable" wobble, meaning the wobble radius is
+            <3mm. If the wobble found was unreasonable,
+            the minimum peak height is iteratively adjusted from low to high at the passed radius.
+            If for all peak heights at the given radius the wobble is still unreasonable, the
+            radius is then iterated over from most distant inward, iterating over minimum peak heights at each radius.
+            If False, will simply return the first determined value or raise error if a reasonable wobble could not be determined.
+
+            .. warning:: It is strongly recommended to leave this setting at True.
+
+        invert : bool
+            Whether to force invert the image values. This should be set to True if the automatically-determined
+            pylinac inversion is incorrect.
+
+        Raises
+        ------
+        RuntimeError
+            If a reasonable wobble value was not found.
+        """
+        self.tolerance = tolerance
+        self.image.check_inversion_by_histogram(percentiles=[4, 50, 96])
+        if invert:
+            self.image.invert()
+
+        if start_point is None:
+            start_point = self._get_reasonable_start_point()
+
+        self._get_reasonable_wobble(
+            start_point, fwhm, min_peak_height, radius, recursive
+        )
+
+    def _get_reasonable_wobble(
+        self, start_point, fwhm, min_peak_height, radius, recursive
+    ):
+        """Determine a wobble that is "reasonable". If recursive is false, the first iteration will be passed,
+        otherwise the parameters will be tweaked to search for a reasonable wobble."""
+        wobble_unreasonable = True
+        focus_point = copy.copy(start_point)
+        peak_gen = get_peak_height()
+        radius_gen = get_radius()
+        while wobble_unreasonable:
+            try:
+                self.circle_profile = StarProfile(
+                    self.image, focus_point, radius, min_peak_height, fwhm
+                )
+                if (len(self.circle_profile.peaks) < 6) or (
+                    len(self.circle_profile.peaks) % 2 != 0
+                ):
+                    raise ValueError
+                self.lines = LineManager(self.circle_profile.peaks)
+                self._find_wobble_minimize()
+            except ValueError:
+                if not recursive:
+                    raise RuntimeError(
+                        "The algorithm was unable to properly detect the radiation lines. Try setting "
+                        "recursive to True or lower the minimum peak height"
+                    )
+                else:
+                    try:
+                        min_peak_height = next(peak_gen)
+                    except StopIteration:
+                        # if no height setting works, change the radius and reset the height
+                        try:
+                            radius = next(radius_gen)
+                            peak_gen = get_peak_height()
+                        except StopIteration:
+                            raise RuntimeError(
+                                "The algorithm was unable to determine a reasonable wobble. Try setting "
+                                "recursive to False and manually adjusting algorithm parameters"
+                            )
+
+            else:  # if no errors are raised
+                # set the focus point to the wobble minimum
+                # focus_point = self.wobble.center
+                # finally:
+                # stop after first iteration if not recursive
+                if not recursive:
+                    wobble_unreasonable = False
+                # otherwise, check if the wobble is reasonable
+                else:
+                    # if so, stop
+                    if self.wobble.diameter_mm < 2:
+                        focus_near_center = (
+                            self.wobble.center.distance_to(focus_point) < 5
+                        )
+                        if focus_near_center:
+                            wobble_unreasonable = False
+                        else:
+                            focus_point = self.wobble.center
+                    # otherwise, iterate through peak height
+                    else:
+                        try:
+                            min_peak_height = next(peak_gen)
+                        except StopIteration:
+                            # if no height setting works, change the radius and reset the height
+                            try:
+                                radius = next(radius_gen)
+                                peak_gen = get_peak_height()
+                            except StopIteration:
+                                raise RuntimeError(
+                                    "The algorithm was unable to determine a reasonable wobble. Try setting "
+                                    "recursive to False and manually adjusting algorithm parameters"
+                                )
+
+    def _find_wobble_minimize(self) -> None:
+        """Find the minimum distance wobble location and radius to all radiation lines.
+
+        The minimum is found using a scipy minimization function.
+        """
+        # starting point
+        sp = copy.copy(self.circle_profile.center)
+
+        def distance(p, lines):
+            """Calculate the maximum distance to any line from the given point."""
+            return max(line.distance_to(Point(p[0], p[1])) for line in lines)
+
+        res = optimize.minimize(
+            distance,
+            sp.as_array(),
+            args=(self.lines,),
+            method="Nelder-Mead",
+            options={"fatol": 0.001},
+        )
+        # res = optimize.least_squares(distance, sp.as_array(), args=(self.lines,), ftol=0.001)
+
+        self.wobble.radius = res.fun
+        self.wobble.radius_mm = res.fun / self.image.dpmm
+        self.wobble.center = Point(res.x[0], res.x[1])
+
+    @property
+    def passed(self) -> bool:
+        """Boolean specifying whether the determined wobble was within tolerance."""
+        return self.wobble.radius_mm * 2 < self.tolerance
+
+    @property
+    def _passfail_str(self) -> str:
+        """Return a pass/fail string."""
+        return "PASS" if self.passed else "FAIL"
+
+    def results(self, as_list: bool = False) -> str | list[str]:
+        """Return the results of the analysis.
+
+        Parameters
+        ----------
+        as_list : bool
+            Whether to return as a list of strings vs single string. Pretty much for internal usage.
+        """
+        results = [
+            " - Starshot Results - ",
+            f"Result: {self._passfail_str}",
+            f"The minimum circle that touches all the star lines has a diameter of {self.wobble.radius_mm*2:2.3f} mm.",
+            f"The center of the minimum circle is at {self.wobble.center.x:3.1f}, {self.wobble.center.y:3.1f}",
+        ]
+        if not as_list:
+            results = "\n".join(results)
+        return results
+
+    def _generate_results_data(self) -> StarshotResults:
+        """Present the results data and metadata as a dataclass or dict.
+        The default return type is a dataclass."""
+        return StarshotResults(
+            tolerance_mm=self.tolerance,
+            circle_diameter_mm=self.wobble.radius_mm * 2,
+            circle_radius_mm=self.wobble.radius_mm,
+            circle_center_x_y=(self.wobble.center.x, self.wobble.center.y),
+            passed=self.passed,
+        )
+
+    def plot_analyzed_image(self, show: bool = True, **plt_kwargs: dict):
+        """Draw the star lines, profile circle, and wobble circle on a matplotlib figure.
+
+        Parameters
+        ----------
+        show : bool
+            Whether to actually show the image.
+        plt_kwargs : dict
+            Keyword args passed to the plt.subplots() method. Allows one to set things like figure size.
+        """
+        fig, axes = plt.subplots(ncols=2, **plt_kwargs)
+        subimages = ("whole", "wobble")
+        titles = ("Analyzed Image", "Wobble Circle")
+
+        # show images
+        for ax, subimage, title in zip(axes, subimages, titles):
+            self.plot_analyzed_subimage(ax=ax, show=False, subimage=subimage)
+            ax.set_title(title)
+
+        if show:
+            plt.show()
+
+    def plot_analyzed_subimage(
+        self,
+        subimage: str = "wobble",
+        ax: plt.Axes | None = None,
+        show: bool = True,
+        **plt_kwargs: dict,
+    ):
+        """Plot a subimage of the starshot analysis. Current options are the zoomed out image and the zoomed in image.
+
+        Parameters
+        ----------
+        subimage : str
+            If 'wobble', will show a zoomed in plot of the wobble circle.
+            Any other string will show the zoomed out plot.
+        ax : None, matplotlib Axes
+            If None (default), will create a new figure to plot on, otherwise plot to the passed axes.
+        show : bool
+            Whether to actually show the image.
+        plt_kwargs : dict
+            Keyword args passed to the plt.figure() method. Allows one to set things like figure size. Only used if ax is not passed.
+        """
+        if ax is None:
+            fig, ax = plt.subplots(**plt_kwargs)
+        # show analyzed image
+        ax.imshow(self.image.array, cmap=get_dicom_cmap())
+        self.lines.plot(ax)
+        self.wobble.plot2axes(ax, edgecolor="green")
+        self.circle_profile.plot2axes(ax, edgecolor="green")
+        ax.autoscale(tight=True)
+        ax.axis("off")
+
+        # zoom in if wobble plot
+        if subimage == "wobble":
+            xlims = [
+                self.wobble.center.x + self.wobble.diameter,
+                self.wobble.center.x - self.wobble.diameter,
+            ]
+            ylims = [
+                self.wobble.center.y + self.wobble.diameter,
+                self.wobble.center.y - self.wobble.diameter,
+            ]
+            ax.set_xlim(xlims)
+            ax.set_ylim(ylims)
+            ax.axis("on")
+
+        if show:
+            plt.show()
+
+    def save_analyzed_image(self, filename: str, **kwargs):
+        """Save the analyzed image plot to a file.
+
+        Parameters
+        ----------
+        filename : str, IO stream
+            The filename to save as. Format is deduced from string extention, if there is one. E.g. 'mystar.png' will
+            produce a PNG image.
+        kwargs
+            All other kwargs are passed to plt.savefig().
+        """
+        self.plot_analyzed_image(show=False)
+        plt.savefig(filename, **kwargs)
+
+    def save_analyzed_subimage(self, filename: str, subimage: str = "wobble", **kwargs):
+        """Save the analyzed subimage to a file.
+
+        Parameters
+        ----------
+        filename : str, file-object
+            Where to save the file to.
+        subimage : str
+            If 'wobble', will show a zoomed in plot of the wobble circle.
+            Any other string will show the zoomed out plot.
+        kwargs
+            Passed to matplotlib.
+        """
+        self.plot_analyzed_subimage(subimage=subimage, show=False)
+        plt.savefig(filename, **kwargs)
+
+    def publish_pdf(
+        self,
+        filename: str | BinaryIO,
+        notes: str | list[str] | None = None,
+        open_file: bool = False,
+        metadata: dict | None = None,
+        logo: Path | str | None = None,
+    ):
+        """Publish (print) a PDF containing the analysis, images, and quantitative results.
+
+        Parameters
+        ----------
+        filename : (str, file-like object}
+            The file to write the results to.
+        notes : str, list of strings
+            Text; if str, prints single line.
+            If list of strings, each list item is printed on its own line.
+        open_file : bool
+            Whether to open the file using the default program after creation.
+        metadata : dict
+            Extra data to be passed and shown in the PDF. The key and value will be shown with a colon.
+            E.g. passing {'Author': 'James', 'Unit': 'TrueBeam'} would result in text in the PDF like:
+            --------------
+            Author: James
+            Unit: TrueBeam
+            --------------
+        logo: Path, str
+            A custom logo to use in the PDF report. If nothing is passed, the default pylinac logo is used.
+        """
+        canvas = pdf.PylinacCanvas(
+            filename, page_title="Starshot Analysis", metadata=metadata, logo=logo
+        )
+        for img, height in zip(("wobble", "asdf"), (2, 11.5)):
+            data = io.BytesIO()
+            self.save_analyzed_subimage(data, img)
+            canvas.add_image(data, location=(4, height), dimensions=(13, 13))
+        text = [
+            "Starshot results:",
+            f"Source-to-Image Distance (mm): {self.image.sid:2.0f}",
+            f"Tolerance (mm): {self.tolerance:2.1f}",
+            f"Minimum circle diameter (mm): {self.wobble.radius_mm*2:2.2f}",
+        ]
+        canvas.add_text(text=text, location=(10, 25.5), font_size=12)
+        if notes is not None:
+            canvas.add_text(text="Notes:", location=(1, 5.5), font_size=14)
+            canvas.add_text(text=notes, location=(1, 5))
+        canvas.finish()
+
+        if open_file:
+            webbrowser.open(filename)
+
+    @staticmethod
+    def run_demo():
+        """Demonstrate the Starshot module using the demo image."""
+        star = Starshot.from_demo_image()
+        star.analyze()
+        print(star.results())
+        star.plot_analyzed_image()
+
+
+class Wobble(Circle):
+    """A class that holds the wobble information of the Starshot analysis.
+
+    Attributes
+    ----------
+    radius_mm : The radius of the Circle in **mm**.
+    """
+
+    def __init__(self, center_point=None, radius=None):
+        super().__init__(center_point=center_point, radius=radius)
+        self.radius_mm = 0  # The radius of the wobble in mm; as opposed to pixels.
+
+    @property
+    def diameter_mm(self) -> float:
+        """Diameter of the wobble in mm."""
+        return self.radius_mm * 2
+
+
+class LineManager:
+    """Manages the radiation lines found."""
+
+    def __init__(self, points: list[Point]):
+        """
+        Parameters
+        ----------
+        points :
+            The peak points found by the StarProfile
+        """
+        self.lines = []
+        self.construct_rad_lines(points)
+
+    def __getitem__(self, item):
+        return self.lines[item]
+
+    def __len__(self):
+        return len(self.lines)
+
+    def construct_rad_lines(self, points: list[Point]):
+        """Find and match the positions of peaks in the circle profile (radiation lines)
+            and map their positions to the starshot image.
+
+        Radiation lines are found by finding the FWHM of the radiation spokes, then matching them
+        to form lines.
+
+        Returns
+        -------
+        lines : list
+            A list of Lines (radiation lines) found.
+
+        See Also
+        --------
+        Starshot.analyze() : min_peak_height parameter info
+        core.profile.CircleProfile.find_FWXM_peaks : min_peak_distance parameter info.
+        geometry.Line : returning object
+        """
+        self.match_points(points)
+
+    def match_points(self, points: list[Point]):
+        """Match the peaks found to the same radiation lines.
+
+        Peaks are matched by connecting the existing peaks based on an offset of peaks. E.g. if there are
+        12 peaks, there must be 6 radiation lines. Furthermore, assuming star lines go all the way across the CAX,
+        the 7th peak will be the opposite peak of the 1st peak, forming a line. This method is robust to
+        starting points far away from the real center.
+        """
+        num_rad_lines = int(len(points) / 2)
+        offset = num_rad_lines
+        self.lines = [
+            Line(points[line], points[line + offset]) for line in range(num_rad_lines)
+        ]
+
+    def plot(self, axis: plt.Axes):
+        """Plot the lines to the axis."""
+        for line in self.lines:
+            line.plot2axes(axis, color="blue")
+
+
+class StarProfile(CollapsedCircleProfile):
+    """Class that holds and analyzes the circular profile which finds the radiation lines."""
+
+    def __init__(self, image, start_point, radius, min_peak_height, fwhm):
+        radius = self._convert_radius_perc2pix(image, start_point, radius)
+        super().__init__(
+            center=start_point,
+            radius=radius,
+            image_array=image.array,
+            width_ratio=0.1,
+            sampling_ratio=3,
+        )
+        self.get_peaks(min_peak_height, fwhm=fwhm)
+
+    @staticmethod
+    def _convert_radius_perc2pix(image, start_point, radius):
+        """Convert a percent radius to distance in pixels, based on the distance from center point to image
+            edge.
+
+        Parameters
+        ----------
+        radius : float
+            The radius ratio (e.g. 0.5).
+        """
+        return image.dist2edge_min(start_point) * radius
+
+    def _roll_prof_to_midvalley(self) -> int:
+        """Roll the circle profile so that its edges are not near a radiation line.
+        This is a prerequisite for properly finding star lines.
+        """
+        roll_amount = np.where(self.values == self.values.min())[0][0]
+        self.roll(roll_amount)
+        return roll_amount
+
+    def get_peaks(self, min_peak_height, min_peak_distance=0.02, fwhm=True):
+        """Determine the peaks of the profile."""
+        self._roll_prof_to_midvalley()
+        self.filter(size=0.003, kind="gaussian")
+        self.ground()
+        if fwhm:
+            self.find_fwxm_peaks(
+                threshold=min_peak_height, min_distance=min_peak_distance
+            )
+        else:
+            self.find_peaks(min_peak_height, min_peak_distance)
+
+
+def get_peak_height():
+    yield from np.linspace(0.05, 0.95, 10)
+
+
+def get_radius():
+    yield from np.linspace(0.95, 0.1, 10)
```

### Comparing `manteia_qa_pylinac-1.0.0/pylinac/vmat.py` & `manteia_qa_pylinac-1.1.0/pylinac/vmat.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,622 +1,632 @@
-"""The VMAT module consists of the class VMAT, which is capable of loading an EPID DICOM Open field image and MLC field image and analyzing the
-images according to the Varian RapidArc QA tests and procedures, specifically the Dose-Rate & Gantry-Speed (DRGS)
-and Dose-Rate & MLC speed (DRMLC) tests.
-
-Features:
-
-* **Do both tests** - Pylinac can handle either DRGS or DRMLC tests.
-* **Automatic offset correction** - Older VMAT tests had the ROIs offset, newer ones are centered. No worries, pylinac finds the ROIs automatically.
-* **Automatic open/DMLC identification** - Pass in both images--don't worry about naming. Pylinac will automatically identify the right images.
-"""
-from __future__ import annotations
-
-import copy
-import dataclasses
-import enum
-import typing
-import webbrowser
-from dataclasses import dataclass
-from io import BytesIO
-from pathlib import Path
-from typing import BinaryIO, Sequence
-
-import matplotlib.pyplot as plt
-import numpy as np
-
-from . import Normalization
-from .core import image
-from .core.geometry import Point, Rectangle
-from .core.image import DicomImage, ImageLike
-from .core.io import TemporaryZipDirectory, get_url, retrieve_demo_file
-from .core.pdf import PylinacCanvas
-from .core.profile import InflectionDerivativeProfile
-from .core.utilities import ResultBase
-from .settings import get_dicom_cmap
-
-
-class ImageType(enum.Enum):
-    """The image type options"""
-
-    DMLC = "dmlc"  #:
-    OPEN = "open"  #:
-    PROFILE = "profile"  #:
-
-
-@dataclass
-class SegmentResult:
-    """An individual segment/ROI result"""
-
-    passed: bool  #:
-    x_position_mm: float  #:
-    r_corr: float  #:
-    r_dev: float  #:
-    center_x_y: float  #:
-    stdev: float  #:
-
-
-@dataclass
-class VMATResult(ResultBase):
-    """This class should not be called directly. It is returned by the ``results_data()`` method.
-    It is a dataclass under the hood and thus comes with all the dunder magic.
-
-    Use the following attributes as normal class attributes."""
-
-    test_type: str  #:
-    tolerance_percent: float  #:
-    max_deviation_percent: float  #:
-    abs_mean_deviation: float  #:
-    passed: bool  #:
-    segment_data: typing.Iterable[SegmentResult]  #:
-    named_segment_data: dict[str, SegmentResult]  #:
-
-
-class Segment(Rectangle):
-    """A class for holding and analyzing segment data of VMAT tests.
-
-    For VMAT tests, there are either 4 or 7 'segments', which represents a section of the image that received
-    radiation under the same conditions.
-
-    Attributes
-    ----------
-    r_dev : float
-            The reading deviation (R_dev) from the average readings of all the segments. See documentation for equation info.
-    """
-
-    # width of the segment (i.e. parallel to MLC motion) in pixels under reference conditions
-    _nominal_width_mm: int
-    _nominal_height_mm: int
-    r_dev: float
-
-    def __init__(
-        self,
-        center_point: Point,
-        open_image: image.DicomImage,
-        dmlc_image: image.DicomImage,
-        tolerance: float | int,
-    ):
-        self.r_dev: float = 0.0  # is assigned after all segments constructed
-        self._tolerance = tolerance
-        self._open_image = open_image
-        self._dmlc_image = dmlc_image
-        width = self._nominal_width_mm * dmlc_image.dpmm
-        height = self._nominal_height_mm * dmlc_image.dpmm
-        super().__init__(width, height, center=center_point, as_int=True)
-
-    @property
-    def r_corr(self) -> float:
-        """Return the ratio of the mean pixel values of DMLC/OPEN images."""
-        dmlc_value = self._dmlc_image.array[
-            self.bl_corner.y : self.bl_corner.y + self.height,
-            self.bl_corner.x : self.bl_corner.x + self.width,
-        ].mean()
-        open_value = self._open_image.array[
-            self.bl_corner.y : self.bl_corner.y + self.height,
-            self.bl_corner.x : self.bl_corner.x + self.width,
-        ].mean()
-        ratio = (dmlc_value / open_value) * 100
-        return ratio
-
-    @property
-    def stdev(self) -> float:
-        """Return the standard deviation of the segment."""
-        dmlc_value = self._dmlc_image.array[
-            self.bl_corner.y : self.bl_corner.y + self.height,
-            self.bl_corner.x : self.bl_corner.x + self.width,
-        ]
-        open_value = self._open_image.array[
-            self.bl_corner.y : self.bl_corner.y + self.height,
-            self.bl_corner.x : self.bl_corner.x + self.width,
-        ]
-        # we multiply by 100 to be consistent w/ r_corr. I.e. this is a % value.
-        return float(np.std(dmlc_value / open_value))
-
-    @property
-    def passed(self) -> bool:
-        """Return whether the segment passed or failed."""
-        return abs(self.r_dev) < self._tolerance * 100
-
-    def get_bg_color(self) -> str:
-        """Get the background color of the segment when plotted, based on the pass/fail status."""
-        return "blue" if self.passed else "red"
-
-
-class VMATBase:
-    _url_suffix: str
-    _result_header: str
-    _result_short_header: str
-    roi_config: dict
-    default_roi_config: dict
-    dmlc_image: image.DicomImage
-    open_image: image.DicomImage
-    segments: list[Segment]
-    _tolerance: float
-
-    def __init__(
-        self,
-        image_paths: Sequence[str | BinaryIO | Path],
-        ground=True,
-        check_inversion=True,
-        **kwargs,
-    ):
-        """
-        Parameters
-        ----------
-        image_paths : iterable (list, tuple, etc)
-            A sequence of paths to the image files.
-        kwargs
-            Passed to the image loading function. See :func:`~pylinac.core.image.load`.
-        """
-        ground = kwargs.get("ground", False) or ground
-        check_inversion = kwargs.get("check_inversion", False) or check_inversion
-        if len(image_paths) != 2:
-            raise ValueError("Exactly 2 images (open, DMLC) must be passed")
-        image1, image2 = self._load_images(image_paths, ground=ground, **kwargs)
-        if check_inversion:
-            image1, image2 = self._check_inversion(image1, image2)
-        self._identify_images(image1, image2)
-        self.segments = []
-        self._tolerance = 0
-
-    @classmethod
-    def from_url(cls, url: str):
-        """Load a ZIP archive from a URL.  Must follow the naming convention.
-
-        Parameters
-        ----------
-        url : str
-            Must point to a valid URL that is a ZIP archive of two VMAT images.
-        """
-        zfile = get_url(url)
-        return cls.from_zip(zfile)
-
-    @classmethod
-    def from_zip(cls, path: str | Path, **kwargs):
-        """Load VMAT images from a ZIP file that contains both images. Must follow the naming convention.
-
-        Parameters
-        ----------
-        path : str
-            Path to the ZIP archive which holds the VMAT image files.
-        kwargs
-            Passed to the constructor.
-        """
-        with TemporaryZipDirectory(path) as tmpzip:
-            image_files = image.retrieve_image_files(tmpzip)
-            return cls(image_paths=image_files, **kwargs)
-
-    @classmethod
-    def from_demo_images(cls, **kwargs):
-        """Construct a VMAT instance using the demo images."""
-        demo_file = retrieve_demo_file(name=cls._url_suffix)
-        return cls.from_zip(demo_file, **kwargs)
-
-    def analyze(
-        self,
-        tolerance: float | int = 1.5,
-        segment_size_mm: tuple = (5, 100),
-        roi_config: dict | None = None,
-    ):
-        """Analyze the open and DMLC field VMAT images, according to 1 of 2 possible tests.
-
-        Parameters
-        ----------
-        tolerance : float, int, optional
-            The tolerance of the sample deviations in percent. Default is 1.5.
-            Must be between 0 and 8.
-        segment_size_mm : tuple(int, int)
-            The (width, height) of the ROI segments in mm.
-        roi_config : dict
-            A dict of the ROI settings. The keys are the names of the ROIs and each value is a dict containing the offset in mm 'offset_mm'.
-        """
-        self._tolerance = tolerance / 100
-        self.roi_config = roi_config or self.default_roi_config
-
-        """Analysis"""
-        points = self._calculate_segment_centers()
-        Segment._nominal_width_mm = segment_size_mm[0]
-        Segment._nominal_height_mm = segment_size_mm[1]
-        self._construct_segments(points)
-
-    @staticmethod
-    def _load_images(
-        image_paths: Sequence[str | BytesIO], ground, **kwargs
-    ) -> tuple[ImageLike, ImageLike]:
-        image1 = image.load(image_paths[0], **kwargs)
-        image2 = image.load(image_paths[1], **kwargs)
-        if ground:
-            image1.ground()
-            image2.ground()
-        return image1, image2
-
-    def _identify_images(self, image1: DicomImage, image2: DicomImage):
-        """Identify which image is the DMLC and which is the open field."""
-        profile1, profile2 = self._median_profiles(image1=image1, image2=image2)
-        field_profile1 = profile1.field_values()
-        field_profile2 = profile2.field_values()
-        if np.std(field_profile1) > np.std(field_profile2):
-            self.dmlc_image = image1
-            self.open_image = image2
-        else:
-            self.dmlc_image = image2
-            self.open_image = image1
-
-    def results(self) -> str:
-        """A string of the summary of the analysis results.
-
-        Returns
-        -------
-        str
-            The results string showing the overall result and deviation statistics by segment.
-        """
-        if self.passed:
-            passfail_str = "PASS"
-        else:
-            passfail_str = "FAIL"
-
-        string = f"{self._result_header}\nTest Results (Tol. +/-{self._tolerance*100:2.2}%): {passfail_str}\n"
-
-        string += f"Max Deviation: {self.max_r_deviation:2.3}%\nAbsolute Mean Deviation: {self.avg_abs_r_deviation:2.3}%"
-        return string
-
-    def results_data(self, as_dict=False) -> VMATResult | dict:
-        """Present the results data and metadata as a dataclass or dict.
-        The default return type is a dataclass."""
-        segment_data = []
-        named_segment_data = {}
-        for segment, (roi_name, roi_data) in zip(
-            self.segments, self.roi_config.items()
-        ):
-            segment = SegmentResult(
-                passed=segment.passed,
-                r_corr=segment.r_corr,
-                r_dev=segment.r_dev,
-                center_x_y=segment.center.as_array(),
-                x_position_mm=roi_data["offset_mm"],
-                stdev=segment.stdev,
-            )
-            segment_data.append(segment)
-            named_segment_data[roi_name] = segment
-        data = VMATResult(
-            test_type=self._result_header,
-            tolerance_percent=self._tolerance * 100,
-            max_deviation_percent=self.max_r_deviation,
-            abs_mean_deviation=self.avg_abs_r_deviation,
-            passed=self.passed,
-            segment_data=segment_data,
-            named_segment_data=named_segment_data,
-        )
-
-        if as_dict:
-            return dataclasses.asdict(data)
-        return data
-
-    def _calculate_segment_centers(self) -> list[Point]:
-        """Construct the center points of the segments based on the field center and known x-offsets."""
-        points = []
-        dmlc_prof, _ = self._median_profiles(self.dmlc_image, self.open_image)
-        x_field_center = round(dmlc_prof.center_idx)
-        for roi_data in self.roi_config.values():
-            x_offset_mm = roi_data["offset_mm"]
-            y = self.open_image.center.y
-            x_offset_pixels = x_offset_mm * self.open_image.dpmm
-            x = x_field_center + x_offset_pixels
-            points.append(Point(x, y))
-        return points
-
-    def _construct_segments(self, points: list[Point]):
-        for point in points:
-            segment = Segment(point, self.open_image, self.dmlc_image, self._tolerance)
-            self.segments.append(segment)
-        # post-analysis to update R_corr values
-        self._update_r_corrs()
-
-    def _update_r_corrs(self):
-        """After the Segment constructions, the R_corr must be set for each segment."""
-        avg_r_corr = np.array([segment.r_corr for segment in self.segments]).mean()
-        for segment in self.segments:
-            segment.r_dev = ((segment.r_corr / avg_r_corr) * 100) - 100
-
-    @property
-    def passed(self) -> bool:
-        return all(segment.passed for segment in self.segments)
-
-    @property
-    def r_devs(self) -> np.ndarray:
-        """Return the deviations of all segments as an array."""
-        return np.array([segment.r_dev for segment in self.segments])
-
-    @property
-    def avg_abs_r_deviation(self) -> float:
-        """Return the average of the absolute R_deviation values."""
-        return np.abs(self.r_devs).mean()
-
-    @property
-    def avg_r_deviation(self) -> float:
-        """Return the average of the R_deviation values, including the sign."""
-        return self.r_devs.mean()
-
-    @property
-    def max_r_deviation(self) -> float:
-        """Return the value of the maximum R_deviation segment."""
-        return np.max(np.abs(self.r_devs))
-
-    def plot_analyzed_image(
-        self, show: bool = True, show_text: bool = True, **plt_kwargs: dict
-    ):
-        """Plot the analyzed images. Shows the open and dmlc images with the segments drawn; also plots the median
-        profiles of the two images for visual comparison.
-
-        Parameters
-        ----------
-        show : bool
-            Whether to actually show the image.
-        show_text : bool
-            Whether to show the ROI names on the image.
-        plt_kwargs : dict
-            Keyword args passed to the plt.subplots() method. Allows one to set things like figure size.
-        """
-        fig, axes = plt.subplots(ncols=3, sharex=True, **plt_kwargs)
-        subimages = (ImageType.OPEN, ImageType.DMLC, ImageType.PROFILE)
-        titles = ("Open", "DMLC", "Median Profiles")
-        for subimage, axis, title in zip(subimages, axes, titles):
-            self._plot_analyzed_subimage(
-                subimage=subimage, ax=axis, show=False, show_text=show_text
-            )
-            axis.set_title(title)
-        axis.set_ylabel("Normalized Response")
-        axis.legend(loc="lower center")
-
-        if show:
-            plt.tight_layout(h_pad=1.5)
-            plt.show()
-
-    def _save_analyzed_subimage(
-        self,
-        filename: str | BytesIO,
-        subimage: ImageType,
-        show_text: bool,
-        **kwargs,
-    ):
-        """Save the analyzed images as a png file.
-
-        Parameters
-        ----------
-        filename : str, file-object
-            Where to save the file to.
-        kwargs
-            Passed to matplotlib.
-        """
-        self._plot_analyzed_subimage(subimage=subimage, show=False, show_text=show_text)
-        plt.savefig(filename, **kwargs)
-
-    def _plot_analyzed_subimage(
-        self,
-        subimage: ImageType,
-        show: bool = True,
-        ax: plt.Axes | None = None,
-        show_text: bool = True,
-    ):
-        """Plot an individual piece of the VMAT analysis.
-
-        Parameters
-        ----------
-        subimage : str
-            Specifies which image to plot.
-        show : bool
-            Whether to actually plot the image.
-        ax : matplotlib Axes, None
-            If None (default), creates a new figure to plot to, otherwise plots to the given axes.
-        show_text : bool
-            Whether to show the ROI names on the image.
-        """
-        plt.ioff()
-        if ax is None:
-            fig, ax = plt.subplots()
-
-        # plot DMLC or OPEN image
-        if subimage in (ImageType.DMLC, ImageType.OPEN):
-            if subimage == ImageType.DMLC:
-                img = self.dmlc_image
-            elif subimage == ImageType.OPEN:
-                img = self.open_image
-            ax.imshow(img, cmap=get_dicom_cmap())
-            self._draw_segments(ax, show_text)
-            plt.sca(ax)
-            plt.axis("off")
-            plt.tight_layout()
-
-        # plot profile
-        elif subimage == ImageType.PROFILE:
-            dmlc_prof, open_prof = self._median_profiles(
-                self.dmlc_image, self.open_image
-            )
-            ax.plot(dmlc_prof.values, label="DMLC")
-            ax.plot(open_prof.values, label="Open")
-            ax.autoscale(axis="x", tight=True)
-            ax.legend(loc=8, fontsize="large")
-            ax.grid()
-
-        if show:
-            plt.show()
-
-    def _draw_segments(self, axis: plt.Axes, show_text: bool):
-        """Draw the segments onto a plot.
-
-        Parameters
-        ----------
-        axis : matplotlib.axes.Axes
-            The plot to draw the objects on.
-        show_text : bool
-            Whether to show the ROI name on the image
-        """
-        for segment, roi_name in zip(self.segments, self.roi_config.keys()):
-            color = segment.get_bg_color()
-            if show_text:
-                text = f"{roi_name} : {segment.r_dev:2.2f}%"
-            else:
-                text = ""
-            segment.plot2axes(
-                axis, edgecolor=color, text=text, text_rotation=90, fontsize="small"
-            )
-
-    @classmethod
-    def _median_profiles(
-        cls, image1: DicomImage, image2: DicomImage
-    ) -> list[InflectionDerivativeProfile, InflectionDerivativeProfile]:
-        """Return two median profiles from the open and DMLC image. Only used for visual purposes.
-        Evaluation is not based on these profiles."""
-        profiles = []
-        for orig_img in (image1, image2):
-            img = copy.deepcopy(orig_img)
-            img.ground()
-            img.check_inversion()
-            profile = InflectionDerivativeProfile(
-                np.mean(img.array, axis=0),
-                ground=True,
-                normalization=Normalization.BEAM_CENTER,
-            )
-            profile.stretch()
-            norm_val = np.percentile(profile.values, 90)
-            profile.normalize(norm_val)
-            profiles.append(profile)
-        return profiles
-
-    def publish_pdf(
-        self,
-        filename: str,
-        notes: str = None,
-        open_file: bool = False,
-        metadata: dict | None = None,
-        logo: Path | str | None = None,
-    ):
-        """Publish (print) a PDF containing the analysis, images, and quantitative results.
-
-        Parameters
-        ----------
-        filename : (str, file-like object}
-            The file to write the results to.
-        notes : str, list of strings
-            Text; if str, prints single line.
-            If list of strings, each list item is printed on its own line.
-        open_file : bool
-            Whether to open the file using the default program after creation.
-        metadata : dict
-            Extra data to be passed and shown in the PDF. The key and value will be shown with a colon.
-            E.g. passing {'Author': 'James', 'Unit': 'TrueBeam'} would result in text in the PDF like:
-            --------------
-            Author: James
-            Unit: TrueBeam
-            --------------
-        logo: Path, str
-            A custom logo to use in the PDF report. If nothing is passed, the default pylinac logo is used.
-        """
-        canvas = PylinacCanvas(
-            filename=filename,
-            page_title=f"{self._result_short_header} VMAT Analysis",
-            metadata=metadata,
-            logo=logo,
-        )
-        for y, x, width, img in zip(
-            (9, 9, -2),
-            (1, 11, 3),
-            (9, 9, 14),
-            (ImageType.OPEN, ImageType.DMLC, ImageType.PROFILE),
-        ):
-            data = BytesIO()
-            self._save_analyzed_subimage(data, subimage=img, show_text=True)
-            canvas.add_image(data, location=(x, y), dimensions=(width, 18))
-            # canvas.add_text(text=f"{img} Image", location=(x + 2, y + 10), font_size=18)
-        canvas.add_text(text="Open Image", location=(4, 22), font_size=18)
-        canvas.add_text(text=f"{self.open_image.base_path}", location=(4, 21.5))
-        canvas.add_text(text="DMLC Image", location=(14, 22), font_size=18)
-        canvas.add_text(text=f"{self.dmlc_image.base_path}", location=(14, 21.5))
-        canvas.add_text(text="Median profiles", location=(8, 12), font_size=18)
-        text = [
-            f"{self._result_header} VMAT results:",
-            f"Source-to-Image Distance (mm): {self.open_image.sid:2.0f}",
-            f"Tolerance (%): {self._tolerance*100:2.1f}",
-            f"Absolute mean deviation (%): {self.avg_abs_r_deviation:2.2f}",
-            f"Maximum deviation (%): {self.max_r_deviation:2.2f}",
-        ]
-        canvas.add_text(text=text, location=(10, 25.5))
-        if notes is not None:
-            canvas.add_text(text="Notes:", location=(1, 5.5), font_size=14)
-            canvas.add_text(text=notes, location=(1, 5))
-
-        canvas.finish()
-
-        if open_file:
-            webbrowser.open(filename)
-
-    @staticmethod
-    def _check_inversion(image1, image2):
-        for img in (image1, image2):
-            img.check_inversion()
-        return image1, image2
-
-
-class DRGS(VMATBase):
-    """Class representing a Dose-Rate, Gantry-speed VMAT test. Will accept, analyze, and return the results."""
-
-    _url_suffix = "drgs.zip"
-    _result_header = "Dose Rate & Gantry Speed"
-    _result_short_header = "DR/GS"
-    default_roi_config = {
-        "ROI 1": {"offset_mm": -60},
-        "ROI 2": {"offset_mm": -40},
-        "ROI 3": {"offset_mm": -20},
-        "ROI 4": {"offset_mm": 0},
-        "ROI 5": {"offset_mm": 20},
-        "ROI 6": {"offset_mm": 40},
-        "ROI 7": {"offset_mm": 60},
-    }
-
-    @staticmethod
-    def run_demo():
-        """Run the demo for the Dose Rate & Gantry Speed test."""
-        vmat = DRGS.from_demo_images()
-        vmat.analyze()  # old images (rev1, not new rev2's), which are offset
-        print(vmat.results())
-        vmat.plot_analyzed_image()
-
-
-class DRMLC(VMATBase):
-    """Class representing a Dose-Rate, MLC speed VMAT test. Will accept, analyze, and return the results."""
-
-    _url_suffix = "drmlc.zip"
-    _result_header = "Dose Rate & MLC Speed"
-    _result_short_header = "DR/MLCS"
-    default_roi_config = {
-        "ROI 1": {"offset_mm": -45},
-        "ROI 2": {"offset_mm": -15},
-        "ROI 3": {"offset_mm": 15},
-        "ROI 4": {"offset_mm": 45},
-    }
-
-    @staticmethod
-    def run_demo():
-        """Run the demo for the MLC leaf speed test."""
-        vmat = DRMLC.from_demo_images()
-        vmat.analyze()
-        print(vmat.results())
-        vmat.plot_analyzed_image()
+"""The VMAT module consists of the class VMAT, which is capable of loading an EPID DICOM Open field image and MLC field image and analyzing the
+images according to the Varian RapidArc QA tests and procedures, specifically the Dose-Rate & Gantry-Speed (DRGS)
+and Dose-Rate & MLC speed (DRMLC) tests.
+
+Features:
+
+* **Do both tests** - Pylinac can handle either DRGS or DRMLC tests.
+* **Automatic offset correction** - Older VMAT tests had the ROIs offset, newer ones are centered. No worries, pylinac finds the ROIs automatically.
+* **Automatic open/DMLC identification** - Pass in both images--don't worry about naming. Pylinac will automatically identify the right images.
+"""
+from __future__ import annotations
+
+import copy
+import enum
+import typing
+import webbrowser
+from io import BytesIO
+from pathlib import Path
+from typing import BinaryIO, Sequence
+
+import matplotlib.pyplot as plt
+import numpy as np
+from pydantic import BaseModel, ConfigDict
+
+from . import Normalization
+from .core import image
+from .core.geometry import Point, PointSerialized, Rectangle
+from .core.image import DicomImage, ImageLike
+from .core.io import TemporaryZipDirectory, get_url, retrieve_demo_file
+from .core.pdf import PylinacCanvas
+from .core.profile import FWXMProfile
+from .core.utilities import ResultBase, ResultsDataMixin
+from .settings import get_dicom_cmap
+
+
+class ImageType(enum.Enum):
+    """The image type options"""
+
+    DMLC = "dmlc"  #:
+    OPEN = "open"  #:
+    PROFILE = "profile"  #:
+
+
+class SegmentResult(BaseModel):
+    """An individual segment/ROI result"""
+
+    model_config = ConfigDict(arbitrary_types_allowed=True)
+
+    passed: bool  #:
+    x_position_mm: float  #:
+    r_corr: float  #:
+    r_dev: float  #:
+    center_x_y: PointSerialized  #:
+    stdev: float  #:
+
+
+class VMATResult(ResultBase):
+    """This class should not be called directly. It is returned by the ``results_data()`` method.
+    It is a dataclass under the hood and thus comes with all the dunder magic.
+
+    Use the following attributes as normal class attributes."""
+
+    test_type: str  #:
+    tolerance_percent: float  #:
+    max_deviation_percent: float  #:
+    abs_mean_deviation: float  #:
+    passed: bool  #:
+    segment_data: typing.Iterable[SegmentResult]  #:
+    named_segment_data: dict[str, SegmentResult]  #:
+
+
+class Segment(Rectangle):
+    """A class for holding and analyzing segment data of VMAT tests.
+
+    For VMAT tests, there are either 4 or 7 'segments', which represents a section of the image that received
+    radiation under the same conditions.
+
+    Attributes
+    ----------
+    r_dev : float
+            The reading deviation (R_dev) from the average readings of all the segments. See documentation for equation info.
+    """
+
+    # width of the segment (i.e. parallel to MLC motion) in pixels under reference conditions
+    _nominal_width_mm: int
+    _nominal_height_mm: int
+    r_dev: float
+
+    def __init__(
+        self,
+        center_point: Point,
+        open_image: image.DicomImage,
+        dmlc_image: image.DicomImage,
+        tolerance: float | int,
+    ):
+        self.r_dev: float = 0.0  # is assigned after all segments constructed
+        self._tolerance = tolerance
+        self._open_image = open_image
+        self._dmlc_image = dmlc_image
+        width = self._nominal_width_mm * dmlc_image.dpmm
+        height = self._nominal_height_mm * dmlc_image.dpmm
+        super().__init__(width, height, center=center_point, as_int=True)
+
+    @property
+    def r_corr(self) -> float:
+        """Return the ratio of the mean pixel values of DMLC/OPEN images."""
+        dmlc_value = self._dmlc_image.array[
+            self.bl_corner.y : self.bl_corner.y + self.height,
+            self.bl_corner.x : self.bl_corner.x + self.width,
+        ].mean()
+        open_value = self._open_image.array[
+            self.bl_corner.y : self.bl_corner.y + self.height,
+            self.bl_corner.x : self.bl_corner.x + self.width,
+        ].mean()
+        ratio = (dmlc_value / open_value) * 100
+        return ratio
+
+    @property
+    def stdev(self) -> float:
+        """Return the standard deviation of the segment."""
+        dmlc_value = self._dmlc_image.array[
+            self.bl_corner.y : self.bl_corner.y + self.height,
+            self.bl_corner.x : self.bl_corner.x + self.width,
+        ]
+        open_value = self._open_image.array[
+            self.bl_corner.y : self.bl_corner.y + self.height,
+            self.bl_corner.x : self.bl_corner.x + self.width,
+        ]
+        # we multiply by 100 to be consistent w/ r_corr. I.e. this is a % value.
+        return float(np.std(dmlc_value / open_value))
+
+    @property
+    def passed(self) -> bool:
+        """Return whether the segment passed or failed."""
+        return abs(self.r_dev) < self._tolerance * 100
+
+    def get_bg_color(self) -> str:
+        """Get the background color of the segment when plotted, based on the pass/fail status."""
+        return "blue" if self.passed else "red"
+
+
+class VMATBase(ResultsDataMixin[VMATResult]):
+    _url_suffix: str
+    _result_header: str
+    _result_short_header: str
+    roi_config: dict
+    default_roi_config: dict
+    dmlc_image: image.DicomImage
+    open_image: image.DicomImage
+    segments: list[Segment]
+    _tolerance: float
+
+    def __init__(
+        self,
+        image_paths: Sequence[str | BinaryIO | Path],
+        ground=True,
+        check_inversion=True,
+        **kwargs,
+    ):
+        """
+        Parameters
+        ----------
+        image_paths : iterable (list, tuple, etc)
+            A sequence of paths to the image files.
+        kwargs
+            Passed to the image loading function. See :func:`~pylinac.core.image.load`.
+        """
+        ground = kwargs.get("ground", False) or ground
+        check_inversion = kwargs.get("check_inversion", False) or check_inversion
+        if len(image_paths) != 2:
+            raise ValueError("Exactly 2 images (open, DMLC) must be passed")
+        image1, image2 = self._load_images(image_paths, ground=ground, **kwargs)
+        if check_inversion:
+            image1, image2 = self._check_inversion(image1, image2)
+        self._identify_images(image1, image2)
+        self.segments = []
+        self._tolerance = 0
+
+    @classmethod
+    def from_url(cls, url: str):
+        """Load a ZIP archive from a URL.  Must follow the naming convention.
+
+        Parameters
+        ----------
+        url : str
+            Must point to a valid URL that is a ZIP archive of two VMAT images.
+        """
+        zfile = get_url(url)
+        return cls.from_zip(zfile)
+
+    @classmethod
+    def from_zip(cls, path: str | Path, **kwargs):
+        """Load VMAT images from a ZIP file that contains both images. Must follow the naming convention.
+
+        Parameters
+        ----------
+        path : str
+            Path to the ZIP archive which holds the VMAT image files.
+        kwargs
+            Passed to the constructor.
+        """
+        with TemporaryZipDirectory(path) as tmpzip:
+            image_files = image.retrieve_image_files(tmpzip)
+            return cls(image_paths=image_files, **kwargs)
+
+    @classmethod
+    def from_demo_images(cls, **kwargs):
+        """Construct a VMAT instance using the demo images."""
+        demo_file = retrieve_demo_file(name=cls._url_suffix)
+        return cls.from_zip(demo_file, **kwargs)
+
+    def analyze(
+        self,
+        tolerance: float | int = 1.5,
+        segment_size_mm: tuple = (5, 100),
+        roi_config: dict | None = None,
+    ):
+        """Analyze the open and DMLC field VMAT images, according to 1 of 2 possible tests.
+
+        Parameters
+        ----------
+        tolerance : float, int, optional
+            The tolerance of the sample deviations in percent. Default is 1.5.
+            Must be between 0 and 8.
+        segment_size_mm : tuple(int, int)
+            The (width, height) of the ROI segments in mm.
+        roi_config : dict
+            A dict of the ROI settings. The keys are the names of the ROIs and each value is a dict containing the offset in mm 'offset_mm'.
+        """
+        self._tolerance = tolerance / 100
+        self.roi_config = roi_config or self.default_roi_config
+
+        """Analysis"""
+        points = self._calculate_segment_centers()
+        Segment._nominal_width_mm = segment_size_mm[0]
+        Segment._nominal_height_mm = segment_size_mm[1]
+        self._construct_segments(points)
+
+    @staticmethod
+    def _load_images(
+        image_paths: Sequence[str | BytesIO], ground, **kwargs
+    ) -> tuple[ImageLike, ImageLike]:
+        image1 = image.load(image_paths[0], **kwargs)
+        image2 = image.load(image_paths[1], **kwargs)
+        if ground:
+            image1.ground()
+            image2.ground()
+        return image1, image2
+
+    def _identify_images(self, image1: DicomImage, image2: DicomImage):
+        """Identify which image is the DMLC and which is the open field."""
+        profile1, profile2 = self._median_profiles(image1=image1, image2=image2)
+        field_profile1 = profile1.field_values()
+        field_profile2 = profile2.field_values()
+        # first check if the profiles have a very different length
+        # if so, the longer one is the open field
+        # this leverages the shortcoming in FWXMProfile where the field might be very small because
+        # it "caught" on one of the first dips of the DMLC image
+        # catches most often with Halcyon images
+        if abs(len(field_profile1) - len(field_profile2)) > min(
+            len(field_profile1), len(field_profile2)
+        ):
+            if len(field_profile1) > len(field_profile2):
+                self.open_image = image1
+                self.dmlc_image = image2
+            else:
+                self.open_image = image2
+                self.dmlc_image = image1
+        # normal check of the STD compared; for flat-ish beams this works well.
+        elif np.std(field_profile1) > np.std(field_profile2):
+            self.dmlc_image = image1
+            self.open_image = image2
+        else:
+            self.dmlc_image = image2
+            self.open_image = image1
+
+    def results(self) -> str:
+        """A string of the summary of the analysis results.
+
+        Returns
+        -------
+        str
+            The results string showing the overall result and deviation statistics by segment.
+        """
+        if self.passed:
+            passfail_str = "PASS"
+        else:
+            passfail_str = "FAIL"
+
+        string = f"{self._result_header}\nTest Results (Tol. +/-{self._tolerance*100:2.2}%): {passfail_str}\n"
+
+        string += f"Max Deviation: {self.max_r_deviation:2.3}%\nAbsolute Mean Deviation: {self.avg_abs_r_deviation:2.3}%"
+        return string
+
+    def _generate_results_data(self) -> VMATResult:
+        """Present the results data and metadata as a dataclass or dict.
+        The default return type is a dataclass."""
+        segment_data = []
+        named_segment_data = {}
+        for segment, (roi_name, roi_data) in zip(
+            self.segments, self.roi_config.items()
+        ):
+            segment = SegmentResult(
+                passed=segment.passed,
+                r_corr=segment.r_corr,
+                r_dev=segment.r_dev,
+                center_x_y=segment.center,
+                x_position_mm=roi_data["offset_mm"],
+                stdev=segment.stdev,
+            )
+            segment_data.append(segment)
+            named_segment_data[roi_name] = segment
+        return VMATResult(
+            test_type=self._result_header,
+            tolerance_percent=self._tolerance * 100,
+            max_deviation_percent=self.max_r_deviation,
+            abs_mean_deviation=self.avg_abs_r_deviation,
+            passed=self.passed,
+            segment_data=segment_data,
+            named_segment_data=named_segment_data,
+        )
+
+    def _calculate_segment_centers(self) -> list[Point]:
+        """Construct the center points of the segments based on the field center and known x-offsets."""
+        points = []
+        _, open_prof = self._median_profiles(self.dmlc_image, self.open_image)
+        x_field_center = round(open_prof.center_idx)
+        for roi_data in self.roi_config.values():
+            x_offset_mm = roi_data["offset_mm"]
+            y = self.open_image.center.y
+            x_offset_pixels = x_offset_mm * self.open_image.dpmm
+            x = x_field_center + x_offset_pixels
+            points.append(Point(x, y))
+        return points
+
+    def _construct_segments(self, points: list[Point]):
+        for point in points:
+            segment = Segment(point, self.open_image, self.dmlc_image, self._tolerance)
+            self.segments.append(segment)
+        # post-analysis to update R_corr values
+        self._update_r_corrs()
+
+    def _update_r_corrs(self):
+        """After the Segment constructions, the R_corr must be set for each segment."""
+        avg_r_corr = np.array([segment.r_corr for segment in self.segments]).mean()
+        for segment in self.segments:
+            segment.r_dev = ((segment.r_corr / avg_r_corr) * 100) - 100
+
+    @property
+    def passed(self) -> bool:
+        return all(segment.passed for segment in self.segments)
+
+    @property
+    def r_devs(self) -> np.ndarray:
+        """Return the deviations of all segments as an array."""
+        return np.array([segment.r_dev for segment in self.segments])
+
+    @property
+    def avg_abs_r_deviation(self) -> float:
+        """Return the average of the absolute R_deviation values."""
+        return np.abs(self.r_devs).mean()
+
+    @property
+    def avg_r_deviation(self) -> float:
+        """Return the average of the R_deviation values, including the sign."""
+        return self.r_devs.mean()
+
+    @property
+    def max_r_deviation(self) -> float:
+        """Return the value of the maximum R_deviation segment."""
+        return np.max(np.abs(self.r_devs))
+
+    def plot_analyzed_image(
+        self, show: bool = True, show_text: bool = True, **plt_kwargs: dict
+    ):
+        """Plot the analyzed images. Shows the open and dmlc images with the segments drawn; also plots the median
+        profiles of the two images for visual comparison.
+
+        Parameters
+        ----------
+        show : bool
+            Whether to actually show the image.
+        show_text : bool
+            Whether to show the ROI names on the image.
+        plt_kwargs : dict
+            Keyword args passed to the plt.subplots() method. Allows one to set things like figure size.
+        """
+        fig, axes = plt.subplots(ncols=3, sharex=True, **plt_kwargs)
+        subimages = (ImageType.OPEN, ImageType.DMLC, ImageType.PROFILE)
+        titles = ("Open", "DMLC", "Median Profiles")
+        for subimage, axis, title in zip(subimages, axes, titles):
+            self._plot_analyzed_subimage(
+                subimage=subimage, ax=axis, show=False, show_text=show_text
+            )
+            axis.set_title(title)
+        axis.set_ylabel("Normalized Response")
+        axis.legend(loc="lower center")
+
+        if show:
+            plt.tight_layout(h_pad=1.5)
+            plt.show()
+
+    def _save_analyzed_subimage(
+        self,
+        filename: str | BytesIO,
+        subimage: ImageType,
+        show_text: bool,
+        **kwargs,
+    ):
+        """Save the analyzed images as a png file.
+
+        Parameters
+        ----------
+        filename : str, file-object
+            Where to save the file to.
+        kwargs
+            Passed to matplotlib.
+        """
+        self._plot_analyzed_subimage(subimage=subimage, show=False, show_text=show_text)
+        plt.savefig(filename, **kwargs)
+
+    def _plot_analyzed_subimage(
+        self,
+        subimage: ImageType,
+        show: bool = True,
+        ax: plt.Axes | None = None,
+        show_text: bool = True,
+    ):
+        """Plot an individual piece of the VMAT analysis.
+
+        Parameters
+        ----------
+        subimage : str
+            Specifies which image to plot.
+        show : bool
+            Whether to actually plot the image.
+        ax : matplotlib Axes, None
+            If None (default), creates a new figure to plot to, otherwise plots to the given axes.
+        show_text : bool
+            Whether to show the ROI names on the image.
+        """
+        plt.ioff()
+        if ax is None:
+            fig, ax = plt.subplots()
+
+        # plot DMLC or OPEN image
+        if subimage in (ImageType.DMLC, ImageType.OPEN):
+            if subimage == ImageType.DMLC:
+                img = self.dmlc_image
+            elif subimage == ImageType.OPEN:
+                img = self.open_image
+            ax.imshow(img, cmap=get_dicom_cmap())
+            self._draw_segments(ax, show_text)
+            plt.sca(ax)
+            plt.axis("off")
+            plt.tight_layout()
+
+        # plot profile
+        elif subimage == ImageType.PROFILE:
+            dmlc_prof, open_prof = self._median_profiles(
+                self.dmlc_image, self.open_image
+            )
+            ax.plot(dmlc_prof.values, label="DMLC")
+            ax.plot(open_prof.values, label="Open")
+            ax.autoscale(axis="x", tight=True)
+            ax.legend(loc=8, fontsize="large")
+            ax.grid()
+
+        if show:
+            plt.show()
+
+    def _draw_segments(self, axis: plt.Axes, show_text: bool):
+        """Draw the segments onto a plot.
+
+        Parameters
+        ----------
+        axis : matplotlib.axes.Axes
+            The plot to draw the objects on.
+        show_text : bool
+            Whether to show the ROI name on the image
+        """
+        for segment, roi_name in zip(self.segments, self.roi_config.keys()):
+            color = segment.get_bg_color()
+            if show_text:
+                text = f"{roi_name} : {segment.r_dev:2.2f}%"
+            else:
+                text = ""
+            segment.plot2axes(
+                axis, edgecolor=color, text=text, text_rotation=90, fontsize="small"
+            )
+
+    @classmethod
+    def _median_profiles(
+        cls, image1: DicomImage, image2: DicomImage
+    ) -> list[FWXMProfile, FWXMProfile]:
+        """Return two median profiles from the open and DMLC image. Only used for visual purposes.
+        Evaluation is not based on these profiles."""
+        profiles = []
+        for orig_img in (image1, image2):
+            img = copy.deepcopy(orig_img)
+            img.ground()
+            img.check_inversion()
+            profile = FWXMProfile(
+                np.mean(img.array, axis=0),
+                ground=True,
+                normalization=Normalization.BEAM_CENTER,
+            )
+            profile.stretch()
+            norm_val = np.percentile(profile.values, 90)
+            profile.normalize(norm_val)
+            profiles.append(profile)
+        return profiles
+
+    def publish_pdf(
+        self,
+        filename: str,
+        notes: str = None,
+        open_file: bool = False,
+        metadata: dict | None = None,
+        logo: Path | str | None = None,
+    ):
+        """Publish (print) a PDF containing the analysis, images, and quantitative results.
+
+        Parameters
+        ----------
+        filename : (str, file-like object}
+            The file to write the results to.
+        notes : str, list of strings
+            Text; if str, prints single line.
+            If list of strings, each list item is printed on its own line.
+        open_file : bool
+            Whether to open the file using the default program after creation.
+        metadata : dict
+            Extra data to be passed and shown in the PDF. The key and value will be shown with a colon.
+            E.g. passing {'Author': 'James', 'Unit': 'TrueBeam'} would result in text in the PDF like:
+            --------------
+            Author: James
+            Unit: TrueBeam
+            --------------
+        logo: Path, str
+            A custom logo to use in the PDF report. If nothing is passed, the default pylinac logo is used.
+        """
+        canvas = PylinacCanvas(
+            filename=filename,
+            page_title=f"{self._result_short_header} VMAT Analysis",
+            metadata=metadata,
+            logo=logo,
+        )
+        for y, x, width, img in zip(
+            (9, 9, -2),
+            (1, 11, 3),
+            (9, 9, 14),
+            (ImageType.OPEN, ImageType.DMLC, ImageType.PROFILE),
+        ):
+            data = BytesIO()
+            self._save_analyzed_subimage(data, subimage=img, show_text=True)
+            canvas.add_image(data, location=(x, y), dimensions=(width, 18))
+            # canvas.add_text(text=f"{img} Image", location=(x + 2, y + 10), font_size=18)
+        canvas.add_text(text="Open Image", location=(4, 22), font_size=18)
+        canvas.add_text(text=f"{self.open_image.base_path}", location=(4, 21.5))
+        canvas.add_text(text="DMLC Image", location=(14, 22), font_size=18)
+        canvas.add_text(text=f"{self.dmlc_image.base_path}", location=(14, 21.5))
+        canvas.add_text(text="Median profiles", location=(8, 12), font_size=18)
+        text = [
+            f"{self._result_header} VMAT results:",
+            f"Source-to-Image Distance (mm): {self.open_image.sid:2.0f}",
+            f"Tolerance (%): {self._tolerance*100:2.1f}",
+            f"Absolute mean deviation (%): {self.avg_abs_r_deviation:2.2f}",
+            f"Maximum deviation (%): {self.max_r_deviation:2.2f}",
+        ]
+        canvas.add_text(text=text, location=(10, 25.5))
+        if notes is not None:
+            canvas.add_text(text="Notes:", location=(1, 5.5), font_size=14)
+            canvas.add_text(text=notes, location=(1, 5))
+
+        canvas.finish()
+
+        if open_file:
+            webbrowser.open(filename)
+
+    @staticmethod
+    def _check_inversion(image1, image2):
+        for img in (image1, image2):
+            img.check_inversion()
+        return image1, image2
+
+
+class DRGS(VMATBase):
+    """Class representing a Dose-Rate, Gantry-speed VMAT test. Will accept, analyze, and return the results."""
+
+    _url_suffix = "drgs.zip"
+    _result_header = "Dose Rate & Gantry Speed"
+    _result_short_header = "DR/GS"
+    default_roi_config = {
+        "ROI 1": {"offset_mm": -60},
+        "ROI 2": {"offset_mm": -40},
+        "ROI 3": {"offset_mm": -20},
+        "ROI 4": {"offset_mm": 0},
+        "ROI 5": {"offset_mm": 20},
+        "ROI 6": {"offset_mm": 40},
+        "ROI 7": {"offset_mm": 60},
+    }
+
+    @staticmethod
+    def run_demo():
+        """Run the demo for the Dose Rate & Gantry Speed test."""
+        vmat = DRGS.from_demo_images()
+        vmat.analyze()  # old images (rev1, not new rev2's), which are offset
+        print(vmat.results())
+        vmat.plot_analyzed_image()
+
+
+class DRMLC(VMATBase):
+    """Class representing a Dose-Rate, MLC speed VMAT test. Will accept, analyze, and return the results."""
+
+    _url_suffix = "drmlc.zip"
+    _result_header = "Dose Rate & MLC Speed"
+    _result_short_header = "DR/MLCS"
+    default_roi_config = {
+        "ROI 1": {"offset_mm": -45},
+        "ROI 2": {"offset_mm": -15},
+        "ROI 3": {"offset_mm": 15},
+        "ROI 4": {"offset_mm": 45},
+    }
+
+    @staticmethod
+    def run_demo():
+        """Run the demo for the MLC leaf speed test."""
+        vmat = DRMLC.from_demo_images()
+        vmat.analyze()
+        print(vmat.results())
+        vmat.plot_analyzed_image()
```

### Comparing `manteia_qa_pylinac-1.0.0/pylinac/winston_lutz.py` & `manteia_qa_pylinac-1.1.0/pylinac/winston_lutz.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,5720 +1,6879 @@
 00000000: 2222 2254 6865 2057 696e 7374 6f6e 2d4c  """The Winston-L
 00000010: 7574 7a20 6d6f 6475 6c65 206c 6f61 6473  utz module loads
 00000020: 2061 6e64 2070 726f 6365 7373 6573 2045   and processes E
 00000030: 5049 4420 696d 6167 6573 2074 6861 7420  PID images that 
 00000040: 6861 7665 2061 6371 7569 7265 6420 5769  have acquired Wi
 00000050: 6e73 746f 6e2d 4c75 747a 2074 7970 6520  nston-Lutz type 
-00000060: 696d 6167 6573 2e0d 0a0d 0a46 6561 7475  images.....Featu
-00000070: 7265 733a 0d0a 0d0a 2a20 2a2a 436f 7563  res:....* **Couc
-00000080: 6820 7368 6966 7420 696e 7374 7275 6374  h shift instruct
-00000090: 696f 6e73 2a2a 202d 2041 6674 6572 2072  ions** - After r
-000000a0: 756e 6e69 6e67 2061 2057 4c20 7465 7374  unning a WL test
-000000b0: 2c20 6765 7420 696d 6d65 6469 6174 6520  , get immediate 
-000000c0: 6665 6564 6261 636b 206f 6e20 686f 7720  feedback on how 
-000000d0: 746f 2073 6869 6674 2074 6865 2063 6f75  to shift the cou
-000000e0: 6368 2e0d 0a20 2043 6f75 6368 2076 616c  ch...  Couch val
-000000f0: 7565 7320 6361 6e20 616c 736f 2062 6520  ues can also be 
-00000100: 7061 7373 6564 2069 6e20 616e 6420 7468  passed in and th
-00000110: 6520 6e65 7720 636f 7563 6820 7661 6c75  e new couch valu
-00000120: 6573 2077 696c 6c20 6265 2070 7265 7365  es will be prese
-00000130: 6e74 6564 2073 6f20 796f 7520 646f 6e27  nted so you don'
-00000140: 7420 6861 7665 2074 6f20 646f 2074 6861  t have to do tha
-00000150: 7420 7065 736b 7920 636f 6e76 6572 7369  t pesky conversi
-00000160: 6f6e 2e0d 0a20 2022 446f 2049 2073 7562  on...  "Do I sub
-00000170: 7472 6163 7420 7468 6174 206e 756d 6265  tract that numbe
-00000180: 7220 6f72 2061 6464 2069 743f 220d 0a2a  r or add it?"..*
-00000190: 202a 2a41 7574 6f6d 6174 6963 2066 6965   **Automatic fie
-000001a0: 6c64 2026 2042 4220 706f 7369 7469 6f6e  ld & BB position
-000001b0: 696e 672a 2a20 2d20 5768 656e 2061 6e20  ing** - When an 
-000001c0: 696d 6167 6520 6f72 2064 6972 6563 746f  image or directo
-000001d0: 7279 2069 7320 6c6f 6164 6564 2c20 7468  ry is loaded, th
-000001e0: 6520 6669 656c 6420 4341 5820 616e 6420  e field CAX and 
-000001f0: 7468 6520 4242 0d0a 2020 6172 6520 6175  the BB..  are au
-00000200: 746f 6d61 7469 6361 6c6c 7920 666f 756e  tomatically foun
-00000210: 642c 2061 6c6f 6e67 2077 6974 6820 7468  d, along with th
-00000220: 6520 7665 6374 6f72 2061 6e64 2073 6361  e vector and sca
-00000230: 6c61 7220 6469 7374 616e 6365 2062 6574  lar distance bet
-00000240: 7765 656e 2074 6865 6d2e 0d0a 2a20 2a2a  ween them...* **
-00000250: 4973 6f63 656e 7465 7220 7369 7a65 2064  Isocenter size d
-00000260: 6574 6572 6d69 6e61 7469 6f6e 2a2a 202d  etermination** -
-00000270: 2055 7369 6e67 2062 6163 6b70 726f 6a65   Using backproje
-00000280: 6374 696f 6e73 206f 6620 7468 6520 4550  ctions of the EP
-00000290: 4944 2069 6d61 6765 732c 2074 6865 2033  ID images, the 3
-000002a0: 4420 6761 6e74 7279 2069 736f 6365 6e74  D gantry isocent
-000002b0: 6572 2073 697a 650d 0a20 2061 6e64 2070  er size..  and p
-000002c0: 6f73 6974 696f 6e20 6361 6e20 6265 2064  osition can be d
-000002d0: 6574 6572 6d69 6e65 6420 2a69 6e64 6570  etermined *indep
-000002e0: 656e 6465 6e74 206f 6620 7468 6520 4242  endent of the BB
-000002f0: 2070 6f73 6974 696f 6e2a 2e20 4164 6469   position*. Addi
-00000300: 7469 6f6e 616c 6c79 2c20 7468 6520 3244  tionally, the 2D
-00000310: 2070 6c61 6e61 7220 6973 6f63 656e 7465   planar isocente
-00000320: 7220 7369 7a65 0d0a 2020 6f66 2074 6865  r size..  of the
-00000330: 2063 6f6c 6c69 6d61 746f 7220 616e 6420   collimator and 
-00000340: 636f 7563 6820 6361 6e20 616c 736f 2062  couch can also b
-00000350: 6520 6465 7465 726d 696e 6564 2e0d 0a2a  e determined...*
-00000360: 202a 2a49 6d61 6765 2070 6c6f 7474 696e   **Image plottin
-00000370: 672a 2a20 2d20 574c 2069 6d61 6765 7320  g** - WL images 
-00000380: 6361 6e20 6265 2070 6c6f 7474 6564 2073  can be plotted s
-00000390: 6570 6172 6174 656c 7920 6f72 2074 6f67  eparately or tog
-000003a0: 6574 6865 722c 2065 6163 6820 6f66 2077  ether, each of w
-000003b0: 6869 6368 2073 686f 7773 2074 6865 2066  hich shows the f
-000003c0: 6965 6c64 2043 4158 2c20 4242 2061 6e64  ield CAX, BB and
-000003d0: 0d0a 2020 7363 616c 6172 2064 6973 7461  ..  scalar dista
-000003e0: 6e63 6520 6672 6f6d 2042 4220 746f 2043  nce from BB to C
-000003f0: 4158 2e0d 0a2a 202a 2a41 7869 7320 6465  AX...* **Axis de
-00000400: 7669 6174 696f 6e20 706c 6f74 732a 2a20  viation plots** 
-00000410: 2d20 506c 6f74 2074 6865 2076 6172 6961  - Plot the varia
-00000420: 7469 6f6e 206f 6620 7468 6520 6761 6e74  tion of the gant
-00000430: 7279 2c20 636f 6c6c 696d 6174 6f72 2c20  ry, collimator, 
-00000440: 636f 7563 682c 2061 6e64 2045 5049 4420  couch, and EPID 
-00000450: 696e 2065 6163 6820 706c 616e 650d 0a20  in each plane.. 
-00000460: 2061 7320 7765 6c6c 2061 7320 524d 5320   as well as RMS 
-00000470: 7661 7269 6174 696f 6e2e 0d0a 2a20 2a2a  variation...* **
-00000480: 4669 6c65 206e 616d 6520 696e 7465 7270  File name interp
-00000490: 7265 7461 7469 6f6e 2a2a 202d 2052 656e  retation** - Ren
-000004a0: 616d 6520 4449 434f 4d20 6669 6c65 6e61  ame DICOM filena
-000004b0: 6d65 7320 746f 2069 6e63 6c75 6465 2061  mes to include a
-000004c0: 7869 7320 696e 666f 726d 6174 696f 6e20  xis information 
-000004d0: 666f 7220 6c69 6e61 6373 2074 6861 7420  for linacs that 
-000004e0: 646f 6e27 7420 696e 636c 7564 650d 0a20  don't include.. 
-000004f0: 2073 7563 6820 696e 666f 726d 6174 696f   such informatio
-00000500: 6e20 696e 2074 6865 2044 4943 4f4d 2074  n in the DICOM t
-00000510: 6167 732e 2045 2e67 2e20 226d 7957 4c5f  ags. E.g. "myWL_
-00000520: 6761 6e74 7279 3435 5f63 6f6c 6c30 5f63  gantry45_coll0_c
-00000530: 6f75 6368 3331 352e 6463 6d22 2e0d 0a22  ouch315.dcm"..."
-00000540: 2222 0d0a 6672 6f6d 205f 5f66 7574 7572  ""..from __futur
-00000550: 655f 5f20 696d 706f 7274 2061 6e6e 6f74  e__ import annot
-00000560: 6174 696f 6e73 0d0a 0d0a 696d 706f 7274  ations....import
-00000570: 2063 6f70 790d 0a69 6d70 6f72 7420 6461   copy..import da
-00000580: 7461 636c 6173 7365 730d 0a69 6d70 6f72  taclasses..impor
-00000590: 7420 656e 756d 0d0a 696d 706f 7274 2069  t enum..import i
-000005a0: 6f0d 0a69 6d70 6f72 7420 6d61 7468 0d0a  o..import math..
-000005b0: 696d 706f 7274 206f 732e 7061 7468 2061  import os.path a
-000005c0: 7320 6f73 700d 0a69 6d70 6f72 7420 7374  s osp..import st
-000005d0: 6174 6973 7469 6373 0d0a 696d 706f 7274  atistics..import
-000005e0: 2074 656d 7066 696c 650d 0a69 6d70 6f72   tempfile..impor
-000005f0: 7420 7765 6262 726f 7773 6572 0d0a 6672  t webbrowser..fr
-00000600: 6f6d 2064 6174 6163 6c61 7373 6573 2069  om dataclasses i
-00000610: 6d70 6f72 7420 6461 7461 636c 6173 730d  mport dataclass.
-00000620: 0a66 726f 6d20 6675 6e63 746f 6f6c 7320  .from functools 
-00000630: 696d 706f 7274 2063 6163 6865 645f 7072  import cached_pr
-00000640: 6f70 6572 7479 0d0a 6672 6f6d 2069 7465  operty..from ite
-00000650: 7274 6f6f 6c73 2069 6d70 6f72 7420 7a69  rtools import zi
-00000660: 705f 6c6f 6e67 6573 740d 0a66 726f 6d20  p_longest..from 
-00000670: 7061 7468 6c69 6220 696d 706f 7274 2050  pathlib import P
-00000680: 6174 680d 0a66 726f 6d20 7465 7874 7772  ath..from textwr
-00000690: 6170 2069 6d70 6f72 7420 7772 6170 0d0a  ap import wrap..
-000006a0: 6672 6f6d 2074 7970 696e 6720 696d 706f  from typing impo
-000006b0: 7274 2042 696e 6172 7949 4f2c 2049 7465  rt BinaryIO, Ite
-000006c0: 7261 626c 652c 2053 6571 7565 6e63 652c  rable, Sequence,
-000006d0: 2054 7970 6564 4469 6374 0d0a 0d0a 696d   TypedDict....im
-000006e0: 706f 7274 2061 7267 7565 0d0a 696d 706f  port argue..impo
-000006f0: 7274 206d 6174 706c 6f74 6c69 622e 7079  rt matplotlib.py
-00000700: 706c 6f74 2061 7320 706c 740d 0a69 6d70  plot as plt..imp
-00000710: 6f72 7420 6e75 6d70 7920 6173 206e 700d  ort numpy as np.
-00000720: 0a66 726f 6d20 6d70 6c5f 746f 6f6c 6b69  .from mpl_toolki
-00000730: 7473 2e6d 706c 6f74 3364 2069 6d70 6f72  ts.mplot3d impor
-00000740: 7420 6172 7433 640d 0a66 726f 6d20 7363  t art3d..from sc
-00000750: 6970 7920 696d 706f 7274 206c 696e 616c  ipy import linal
-00000760: 672c 206e 6469 6d61 6765 2c20 6f70 7469  g, ndimage, opti
-00000770: 6d69 7a65 0d0a 6672 6f6d 2073 6369 7079  mize..from scipy
-00000780: 2e6e 6469 6d61 6765 2069 6d70 6f72 7420  .ndimage import 
-00000790: 7a6f 6f6d 0d0a 6672 6f6d 2073 6369 7079  zoom..from scipy
-000007a0: 2e73 7061 7469 616c 2e74 7261 6e73 666f  .spatial.transfo
-000007b0: 726d 2069 6d70 6f72 7420 526f 7461 7469  rm import Rotati
-000007c0: 6f6e 0d0a 6672 6f6d 2073 6b69 6d61 6765  on..from skimage
-000007d0: 2069 6d70 6f72 7420 6d65 6173 7572 650d   import measure.
-000007e0: 0a66 726f 6d20 736b 696d 6167 652e 6d65  .from skimage.me
-000007f0: 6173 7572 652e 5f72 6567 696f 6e70 726f  asure._regionpro
-00000800: 7073 2069 6d70 6f72 7420 5265 6769 6f6e  ps import Region
-00000810: 5072 6f70 6572 7469 6573 0d0a 6672 6f6d  Properties..from
-00000820: 2074 6162 756c 6174 6520 696d 706f 7274   tabulate import
-00000830: 2074 6162 756c 6174 650d 0a0d 0a66 726f   tabulate....fro
-00000840: 6d20 2e63 6f72 6520 696d 706f 7274 2069  m .core import i
-00000850: 6d61 6765 2c20 7064 660d 0a66 726f 6d20  mage, pdf..from 
-00000860: 2e63 6f72 652e 6172 7261 795f 7574 696c  .core.array_util
-00000870: 7320 696d 706f 7274 2061 7272 6179 5f74  s import array_t
-00000880: 6f5f 6469 636f 6d0d 0a66 726f 6d20 2e63  o_dicom..from .c
-00000890: 6f72 652e 6465 636f 7261 746f 7273 2069  ore.decorators i
-000008a0: 6d70 6f72 7420 6c72 755f 6361 6368 650d  mport lru_cache.
-000008b0: 0a66 726f 6d20 2e63 6f72 652e 6765 6f6d  .from .core.geom
-000008c0: 6574 7279 2069 6d70 6f72 7420 4c69 6e65  etry import Line
-000008d0: 2c20 506f 696e 742c 2056 6563 746f 722c  , Point, Vector,
-000008e0: 2063 6f73 2c20 7369 6e0d 0a66 726f 6d20   cos, sin..from 
-000008f0: 2e63 6f72 652e 696d 6167 6520 696d 706f  .core.image impo
-00000900: 7274 2044 6963 6f6d 496d 6167 6553 7461  rt DicomImageSta
-00000910: 636b 2c20 4c69 6e61 6344 6963 6f6d 496d  ck, LinacDicomIm
-00000920: 6167 652c 2069 735f 696d 6167 652c 2074  age, is_image, t
-00000930: 6966 665f 746f 5f64 6963 6f6d 0d0a 6672  iff_to_dicom..fr
-00000940: 6f6d 202e 636f 7265 2e69 6f20 696d 706f  om .core.io impo
-00000950: 7274 2054 656d 706f 7261 7279 5a69 7044  rt TemporaryZipD
-00000960: 6972 6563 746f 7279 2c20 6765 745f 7572  irectory, get_ur
-00000970: 6c2c 2072 6574 7269 6576 655f 6465 6d6f  l, retrieve_demo
-00000980: 5f66 696c 650d 0a66 726f 6d20 2e63 6f72  _file..from .cor
-00000990: 652e 6d61 736b 2069 6d70 6f72 7420 626f  e.mask import bo
-000009a0: 756e 6469 6e67 5f62 6f78 0d0a 6672 6f6d  unding_box..from
-000009b0: 202e 636f 7265 2e73 6361 6c65 2069 6d70   .core.scale imp
-000009c0: 6f72 7420 4d61 6368 696e 6553 6361 6c65  ort MachineScale
-000009d0: 2c20 636f 6e76 6572 740d 0a66 726f 6d20  , convert..from 
-000009e0: 2e63 6f72 652e 7574 696c 6974 6965 7320  .core.utilities 
-000009f0: 696d 706f 7274 2052 6573 756c 7442 6173  import ResultBas
-00000a00: 652c 2063 6f6e 7665 7274 5f74 6f5f 656e  e, convert_to_en
-00000a10: 756d 2c20 6973 5f63 6c6f 7365 0d0a 6672  um, is_close..fr
-00000a20: 6f6d 202e 6d65 7472 6963 732e 6665 6174  om .metrics.feat
-00000a30: 7572 6573 2069 6d70 6f72 7420 280d 0a20  ures import (.. 
-00000a40: 2020 2069 735f 7269 6768 745f 6369 7263     is_right_circ
-00000a50: 756d 6665 7265 6e63 652c 0d0a 2020 2020  umference,..    
-00000a60: 6973 5f72 6967 6874 5f73 697a 655f 6262  is_right_size_bb
-00000a70: 2c0d 0a20 2020 2069 735f 726f 756e 642c  ,..    is_round,
-00000a80: 0d0a 2020 2020 6973 5f73 6f6c 6964 2c0d  ..    is_solid,.
-00000a90: 0a20 2020 2069 735f 7379 6d6d 6574 7269  .    is_symmetri
-00000aa0: 632c 0d0a 290d 0a66 726f 6d20 2e6d 6574  c,..)..from .met
-00000ab0: 7269 6373 2e69 6d61 6765 2069 6d70 6f72  rics.image impor
-00000ac0: 7420 5369 7a65 6444 6973 6b4c 6f63 6174  t SizedDiskLocat
-00000ad0: 6f72 0d0a 0d0a 4242 5f45 5252 4f52 5f4d  or....BB_ERROR_M
-00000ae0: 4553 5341 4745 203d 2028 0d0a 2020 2020  ESSAGE = (..    
-00000af0: 2255 6e61 626c 6520 746f 206c 6f63 6174  "Unable to locat
-00000b00: 6520 7468 6520 4242 2e20 4d61 6b65 2073  e the BB. Make s
-00000b10: 7572 6520 7468 6520 6669 656c 6420 6564  ure the field ed
-00000b20: 6765 7320 646f 206e 6f74 206f 6273 6375  ges do not obscu
-00000b30: 7265 2074 6865 2042 422c 2074 6861 7420  re the BB, that 
-00000b40: 7468 6572 6520 6172 6520 6e6f 2061 7274  there are no art
-00000b50: 6966 6163 7473 2069 6e20 7468 6520 696d  ifacts in the im
-00000b60: 6167 6573 2c20 7468 6174 2074 6865 2027  ages, that the '
-00000b70: 6262 5f73 697a 6527 2070 6172 616d 6574  bb_size' paramet
-00000b80: 6572 2069 7320 636c 6f73 6520 746f 2072  er is close to r
-00000b90: 6561 6c69 7479 2c20 220d 0a20 2020 2022  eality, "..    "
+00000060: 696d 6167 6573 2e0a 0a46 6561 7475 7265  images...Feature
+00000070: 733a 0a0a 2a20 2a2a 436f 7563 6820 7368  s:..* **Couch sh
+00000080: 6966 7420 696e 7374 7275 6374 696f 6e73  ift instructions
+00000090: 2a2a 202d 2041 6674 6572 2072 756e 6e69  ** - After runni
+000000a0: 6e67 2061 2057 4c20 7465 7374 2c20 6765  ng a WL test, ge
+000000b0: 7420 696d 6d65 6469 6174 6520 6665 6564  t immediate feed
+000000c0: 6261 636b 206f 6e20 686f 7720 746f 2073  back on how to s
+000000d0: 6869 6674 2074 6865 2063 6f75 6368 2e0a  hift the couch..
+000000e0: 2020 436f 7563 6820 7661 6c75 6573 2063    Couch values c
+000000f0: 616e 2061 6c73 6f20 6265 2070 6173 7365  an also be passe
+00000100: 6420 696e 2061 6e64 2074 6865 206e 6577  d in and the new
+00000110: 2063 6f75 6368 2076 616c 7565 7320 7769   couch values wi
+00000120: 6c6c 2062 6520 7072 6573 656e 7465 6420  ll be presented 
+00000130: 736f 2079 6f75 2064 6f6e 2774 2068 6176  so you don't hav
+00000140: 6520 746f 2064 6f20 7468 6174 2070 6573  e to do that pes
+00000150: 6b79 2063 6f6e 7665 7273 696f 6e2e 0a20  ky conversion.. 
+00000160: 2022 446f 2049 2073 7562 7472 6163 7420   "Do I subtract 
+00000170: 7468 6174 206e 756d 6265 7220 6f72 2061  that number or a
+00000180: 6464 2069 743f 220a 2a20 2a2a 4175 746f  dd it?".* **Auto
+00000190: 6d61 7469 6320 6669 656c 6420 2620 4242  matic field & BB
+000001a0: 2070 6f73 6974 696f 6e69 6e67 2a2a 202d   positioning** -
+000001b0: 2057 6865 6e20 616e 2069 6d61 6765 206f   When an image o
+000001c0: 7220 6469 7265 6374 6f72 7920 6973 206c  r directory is l
+000001d0: 6f61 6465 642c 2074 6865 2066 6965 6c64  oaded, the field
+000001e0: 2043 4158 2061 6e64 2074 6865 2042 420a   CAX and the BB.
+000001f0: 2020 6172 6520 6175 746f 6d61 7469 6361    are automatica
+00000200: 6c6c 7920 666f 756e 642c 2061 6c6f 6e67  lly found, along
+00000210: 2077 6974 6820 7468 6520 7665 6374 6f72   with the vector
+00000220: 2061 6e64 2073 6361 6c61 7220 6469 7374   and scalar dist
+00000230: 616e 6365 2062 6574 7765 656e 2074 6865  ance between the
+00000240: 6d2e 0a2a 202a 2a49 736f 6365 6e74 6572  m..* **Isocenter
+00000250: 2073 697a 6520 6465 7465 726d 696e 6174   size determinat
+00000260: 696f 6e2a 2a20 2d20 5573 696e 6720 6261  ion** - Using ba
+00000270: 636b 7072 6f6a 6563 7469 6f6e 7320 6f66  ckprojections of
+00000280: 2074 6865 2045 5049 4420 696d 6167 6573   the EPID images
+00000290: 2c20 7468 6520 3344 2067 616e 7472 7920  , the 3D gantry 
+000002a0: 6973 6f63 656e 7465 7220 7369 7a65 0a20  isocenter size. 
+000002b0: 2061 6e64 2070 6f73 6974 696f 6e20 6361   and position ca
+000002c0: 6e20 6265 2064 6574 6572 6d69 6e65 6420  n be determined 
+000002d0: 2a69 6e64 6570 656e 6465 6e74 206f 6620  *independent of 
+000002e0: 7468 6520 4242 2070 6f73 6974 696f 6e2a  the BB position*
+000002f0: 2e20 4164 6469 7469 6f6e 616c 6c79 2c20  . Additionally, 
+00000300: 7468 6520 3244 2070 6c61 6e61 7220 6973  the 2D planar is
+00000310: 6f63 656e 7465 7220 7369 7a65 0a20 206f  ocenter size.  o
+00000320: 6620 7468 6520 636f 6c6c 696d 6174 6f72  f the collimator
+00000330: 2061 6e64 2063 6f75 6368 2063 616e 2061   and couch can a
+00000340: 6c73 6f20 6265 2064 6574 6572 6d69 6e65  lso be determine
+00000350: 642e 0a2a 202a 2a49 6d61 6765 2070 6c6f  d..* **Image plo
+00000360: 7474 696e 672a 2a20 2d20 574c 2069 6d61  tting** - WL ima
+00000370: 6765 7320 6361 6e20 6265 2070 6c6f 7474  ges can be plott
+00000380: 6564 2073 6570 6172 6174 656c 7920 6f72  ed separately or
+00000390: 2074 6f67 6574 6865 722c 2065 6163 6820   together, each 
+000003a0: 6f66 2077 6869 6368 2073 686f 7773 2074  of which shows t
+000003b0: 6865 2066 6965 6c64 2043 4158 2c20 4242  he field CAX, BB
+000003c0: 2061 6e64 0a20 2073 6361 6c61 7220 6469   and.  scalar di
+000003d0: 7374 616e 6365 2066 726f 6d20 4242 2074  stance from BB t
+000003e0: 6f20 4341 582e 0a2a 202a 2a41 7869 7320  o CAX..* **Axis 
+000003f0: 6465 7669 6174 696f 6e20 706c 6f74 732a  deviation plots*
+00000400: 2a20 2d20 506c 6f74 2074 6865 2076 6172  * - Plot the var
+00000410: 6961 7469 6f6e 206f 6620 7468 6520 6761  iation of the ga
+00000420: 6e74 7279 2c20 636f 6c6c 696d 6174 6f72  ntry, collimator
+00000430: 2c20 636f 7563 682c 2061 6e64 2045 5049  , couch, and EPI
+00000440: 4420 696e 2065 6163 6820 706c 616e 650a  D in each plane.
+00000450: 2020 6173 2077 656c 6c20 6173 2052 4d53    as well as RMS
+00000460: 2076 6172 6961 7469 6f6e 2e0a 2a20 2a2a   variation..* **
+00000470: 4669 6c65 206e 616d 6520 696e 7465 7270  File name interp
+00000480: 7265 7461 7469 6f6e 2a2a 202d 2052 656e  retation** - Ren
+00000490: 616d 6520 4449 434f 4d20 6669 6c65 6e61  ame DICOM filena
+000004a0: 6d65 7320 746f 2069 6e63 6c75 6465 2061  mes to include a
+000004b0: 7869 7320 696e 666f 726d 6174 696f 6e20  xis information 
+000004c0: 666f 7220 6c69 6e61 6373 2074 6861 7420  for linacs that 
+000004d0: 646f 6e27 7420 696e 636c 7564 650a 2020  don't include.  
+000004e0: 7375 6368 2069 6e66 6f72 6d61 7469 6f6e  such information
+000004f0: 2069 6e20 7468 6520 4449 434f 4d20 7461   in the DICOM ta
+00000500: 6773 2e20 452e 672e 2022 6d79 574c 5f67  gs. E.g. "myWL_g
+00000510: 616e 7472 7934 355f 636f 6c6c 305f 636f  antry45_coll0_co
+00000520: 7563 6833 3135 2e64 636d 222e 0a22 2222  uch315.dcm".."""
+00000530: 0a66 726f 6d20 5f5f 6675 7475 7265 5f5f  .from __future__
+00000540: 2069 6d70 6f72 7420 616e 6e6f 7461 7469   import annotati
+00000550: 6f6e 730a 0a69 6d70 6f72 7420 6461 7461  ons..import data
+00000560: 636c 6173 7365 730a 696d 706f 7274 2065  classes.import e
+00000570: 6e75 6d0a 696d 706f 7274 2069 6f0a 696d  num.import io.im
+00000580: 706f 7274 206d 6174 680a 696d 706f 7274  port math.import
+00000590: 206f 732e 7061 7468 2061 7320 6f73 700a   os.path as osp.
+000005a0: 696d 706f 7274 2073 7461 7469 7374 6963  import statistic
+000005b0: 730a 696d 706f 7274 2074 656d 7066 696c  s.import tempfil
+000005c0: 650a 696d 706f 7274 2077 6562 6272 6f77  e.import webbrow
+000005d0: 7365 720a 6672 6f6d 2066 756e 6374 6f6f  ser.from functoo
+000005e0: 6c73 2069 6d70 6f72 7420 6361 6368 6564  ls import cached
+000005f0: 5f70 726f 7065 7274 790a 6672 6f6d 2069  _property.from i
+00000600: 7465 7274 6f6f 6c73 2069 6d70 6f72 7420  tertools import 
+00000610: 7a69 705f 6c6f 6e67 6573 740a 6672 6f6d  zip_longest.from
+00000620: 2070 6174 686c 6962 2069 6d70 6f72 7420   pathlib import 
+00000630: 5061 7468 0a66 726f 6d20 7465 7874 7772  Path.from textwr
+00000640: 6170 2069 6d70 6f72 7420 7772 6170 0a66  ap import wrap.f
+00000650: 726f 6d20 7479 7069 6e67 2069 6d70 6f72  rom typing impor
+00000660: 7420 4269 6e61 7279 494f 2c20 4974 6572  t BinaryIO, Iter
+00000670: 6162 6c65 2c20 5365 7175 656e 6365 0a0a  able, Sequence..
+00000680: 696d 706f 7274 2061 7267 7565 0a69 6d70  import argue.imp
+00000690: 6f72 7420 6d61 7470 6c6f 746c 6962 2e70  ort matplotlib.p
+000006a0: 7970 6c6f 7420 6173 2070 6c74 0a69 6d70  yplot as plt.imp
+000006b0: 6f72 7420 6e75 6d70 7920 6173 206e 700a  ort numpy as np.
+000006c0: 6672 6f6d 206d 706c 5f74 6f6f 6c6b 6974  from mpl_toolkit
+000006d0: 732e 6d70 6c6f 7433 6420 696d 706f 7274  s.mplot3d import
+000006e0: 2061 7274 3364 0a66 726f 6d20 7079 5f6c   art3d.from py_l
+000006f0: 696e 7120 696d 706f 7274 2045 6e75 6d65  inq import Enume
+00000700: 7261 626c 650a 6672 6f6d 2070 7964 616e  rable.from pydan
+00000710: 7469 6320 696d 706f 7274 2042 6173 654d  tic import BaseM
+00000720: 6f64 656c 0a66 726f 6d20 7363 6970 7920  odel.from scipy 
+00000730: 696d 706f 7274 206e 6469 6d61 6765 2c20  import ndimage, 
+00000740: 6f70 7469 6d69 7a65 0a66 726f 6d20 7363  optimize.from sc
+00000750: 6970 792e 6e64 696d 6167 6520 696d 706f  ipy.ndimage impo
+00000760: 7274 207a 6f6f 6d0a 6672 6f6d 2073 6369  rt zoom.from sci
+00000770: 7079 2e73 7061 7469 616c 2e74 7261 6e73  py.spatial.trans
+00000780: 666f 726d 2069 6d70 6f72 7420 526f 7461  form import Rota
+00000790: 7469 6f6e 0a66 726f 6d20 736b 696d 6167  tion.from skimag
+000007a0: 652e 6d65 6173 7572 652e 5f72 6567 696f  e.measure._regio
+000007b0: 6e70 726f 7073 2069 6d70 6f72 7420 5265  nprops import Re
+000007c0: 6769 6f6e 5072 6f70 6572 7469 6573 0a66  gionProperties.f
+000007d0: 726f 6d20 7461 6275 6c61 7465 2069 6d70  rom tabulate imp
+000007e0: 6f72 7420 7461 6275 6c61 7465 0a0a 6672  ort tabulate..fr
+000007f0: 6f6d 202e 636f 7265 2069 6d70 6f72 7420  om .core import 
+00000800: 696d 6167 652c 2070 6466 0a66 726f 6d20  image, pdf.from 
+00000810: 2e63 6f72 652e 6172 7261 795f 7574 696c  .core.array_util
+00000820: 7320 696d 706f 7274 2061 7272 6179 5f74  s import array_t
+00000830: 6f5f 6469 636f 6d0a 6672 6f6d 202e 636f  o_dicom.from .co
+00000840: 7265 2e64 6563 6f72 6174 6f72 7320 696d  re.decorators im
+00000850: 706f 7274 206c 7275 5f63 6163 6865 0a66  port lru_cache.f
+00000860: 726f 6d20 2e63 6f72 652e 6765 6f6d 6574  rom .core.geomet
+00000870: 7279 2069 6d70 6f72 7420 280a 2020 2020  ry import (.    
+00000880: 4c69 6e65 2c0a 2020 2020 506f 696e 742c  Line,.    Point,
+00000890: 0a20 2020 2050 6f69 6e74 5365 7269 616c  .    PointSerial
+000008a0: 697a 6564 2c0a 2020 2020 5665 6374 6f72  ized,.    Vector
+000008b0: 2c0a 2020 2020 5665 6374 6f72 5365 7269  ,.    VectorSeri
+000008c0: 616c 697a 6564 2c0a 2020 2020 636f 732c  alized,.    cos,
+000008d0: 0a20 2020 2073 696e 2c0a 290a 6672 6f6d  .    sin,.).from
+000008e0: 202e 636f 7265 2e69 6d61 6765 2069 6d70   .core.image imp
+000008f0: 6f72 7420 4469 636f 6d49 6d61 6765 5374  ort DicomImageSt
+00000900: 6163 6b2c 2069 735f 696d 6167 652c 2074  ack, is_image, t
+00000910: 6966 665f 746f 5f64 6963 6f6d 0a66 726f  iff_to_dicom.fro
+00000920: 6d20 2e63 6f72 652e 696f 2069 6d70 6f72  m .core.io impor
+00000930: 7420 5465 6d70 6f72 6172 795a 6970 4469  t TemporaryZipDi
+00000940: 7265 6374 6f72 792c 2067 6574 5f75 726c  rectory, get_url
+00000950: 2c20 7265 7472 6965 7665 5f64 656d 6f5f  , retrieve_demo_
+00000960: 6669 6c65 0a66 726f 6d20 2e63 6f72 652e  file.from .core.
+00000970: 7363 616c 6520 696d 706f 7274 204d 6163  scale import Mac
+00000980: 6869 6e65 5363 616c 652c 2063 6f6e 7665  hineScale, conve
+00000990: 7274 0a66 726f 6d20 2e63 6f72 652e 7574  rt.from .core.ut
+000009a0: 696c 6974 6965 7320 696d 706f 7274 2052  ilities import R
+000009b0: 6573 756c 7442 6173 652c 2052 6573 756c  esultBase, Resul
+000009c0: 7473 4461 7461 4d69 7869 6e2c 2063 6f6e  tsDataMixin, con
+000009d0: 7665 7274 5f74 6f5f 656e 756d 2c20 6973  vert_to_enum, is
+000009e0: 5f63 6c6f 7365 0a66 726f 6d20 2e6d 6574  _close.from .met
+000009f0: 7269 6373 2e66 6561 7475 7265 7320 696d  rics.features im
+00000a00: 706f 7274 2028 0a20 2020 2069 735f 7269  port (.    is_ri
+00000a10: 6768 745f 6369 7263 756d 6665 7265 6e63  ght_circumferenc
+00000a20: 652c 0a20 2020 2069 735f 7269 6768 745f  e,.    is_right_
+00000a30: 7369 7a65 5f62 622c 0a20 2020 2069 735f  size_bb,.    is_
+00000a40: 726f 756e 642c 0a20 2020 2069 735f 736f  round,.    is_so
+00000a50: 6c69 642c 0a20 2020 2069 735f 7379 6d6d  lid,.    is_symm
+00000a60: 6574 7269 632c 0a29 0a66 726f 6d20 2e6d  etric,.).from .m
+00000a70: 6574 7269 6373 2e69 6d61 6765 2069 6d70  etrics.image imp
+00000a80: 6f72 7420 280a 2020 2020 476c 6f62 616c  ort (.    Global
+00000a90: 5369 7a65 6444 6973 6b4c 6f63 6174 6f72  SizedDiskLocator
+00000aa0: 2c0a 2020 2020 476c 6f62 616c 5369 7a65  ,.    GlobalSize
+00000ab0: 6446 6965 6c64 4c6f 6361 746f 722c 0a20  dFieldLocator,. 
+00000ac0: 2020 2053 697a 6564 4469 736b 4c6f 6361     SizedDiskLoca
+00000ad0: 746f 722c 0a29 0a0a 4242 5f45 5252 4f52  tor,.)..BB_ERROR
+00000ae0: 5f4d 4553 5341 4745 203d 2028 0a20 2020  _MESSAGE = (.   
+00000af0: 2022 556e 6162 6c65 2074 6f20 6c6f 6361   "Unable to loca
+00000b00: 7465 2074 6865 2042 422e 204d 616b 6520  te the BB. Make 
+00000b10: 7375 7265 2074 6865 2066 6965 6c64 2065  sure the field e
+00000b20: 6467 6573 2064 6f20 6e6f 7420 6f62 7363  dges do not obsc
+00000b30: 7572 6520 7468 6520 4242 2c20 7468 6174  ure the BB, that
+00000b40: 2074 6865 7265 2061 7265 206e 6f20 6172   there are no ar
+00000b50: 7469 6661 6374 7320 696e 2074 6865 2069  tifacts in the i
+00000b60: 6d61 6765 732c 2074 6861 7420 7468 6520  mages, that the 
+00000b70: 2762 625f 7369 7a65 2720 7061 7261 6d65  'bb_size' parame
+00000b80: 7465 7220 6973 2063 6c6f 7365 2074 6f20  ter is close to 
+00000b90: 7265 616c 6974 792c 2022 0a20 2020 2022  reality, ".    "
 00000ba0: 616e 6420 7468 6174 2074 6865 2042 4220  and that the BB 
 00000bb0: 6973 206e 6561 7220 7468 6520 6365 6e74  is near the cent
 00000bc0: 6572 2028 7769 7468 696e 2032 636d 292e  er (within 2cm).
 00000bd0: 2049 6620 7468 6973 2069 7320 6120 6c61   If this is a la
 00000be0: 7267 652d 6669 656c 6420 696d 6167 6520  rge-field image 
 00000bf0: 6f72 206b 5620 696d 6167 6520 7472 7920  or kV image try 
 00000c00: 7365 7474 696e 6720 276c 6f77 5f64 656e  setting 'low_den
 00000c10: 7369 7479 5f62 6227 2074 6f20 5472 7565  sity_bb' to True
-00000c20: 2e22 0d0a 290d 0a0d 0a0d 0a63 6c61 7373  ."..)......class
-00000c30: 2042 4241 7272 616e 6765 6d65 6e74 3a0d   BBArrangement:.
-00000c40: 0a20 2020 2022 2222 5072 6573 6574 7320  .    """Presets 
-00000c50: 666f 7220 6d75 6c74 692d 7461 7267 6574  for multi-target
-00000c60: 2070 6861 6e74 6f6d 732e 2222 220d 0a0d   phantoms."""...
-00000c70: 0a20 2020 2023 206c 6f63 6174 696f 6e73  .    # locations
-00000c80: 3a20 6874 7470 733a 2f2f 7777 772e 706f  : https://www.po
-00000c90: 7374 6572 7365 7373 696f 6e6f 6e6c 696e  stersessiononlin
-00000ca0: 652e 6575 2f31 3733 3538 3033 3438 5f65  e.eu/173580348_e
-00000cb0: 752f 636f 6e67 7265 736f 732f 4553 5452  u/congresos/ESTR
-00000cc0: 4f32 3032 302f 6175 6c61 2f2d 504f 5f31  O2020/aula/-PO_1
-00000cd0: 3332 305f 4553 5452 4f32 3032 302e 7064  320_ESTRO2020.pd
-00000ce0: 660d 0a20 2020 2053 4e43 5f4d 554c 5449  f..    SNC_MULTI
-00000cf0: 4d45 5420 3d20 280d 0a20 2020 2020 2020  MET = (..       
-00000d00: 207b 0d0a 2020 2020 2020 2020 2020 2020   {..            
-00000d10: 226e 616d 6522 3a20 2249 736f 222c 0d0a  "name": "Iso",..
-00000d20: 2020 2020 2020 2020 2020 2020 226f 6666              "off
-00000d30: 7365 745f 6c65 6674 5f6d 6d22 3a20 302c  set_left_mm": 0,
-00000d40: 0d0a 2020 2020 2020 2020 2020 2020 226f  ..            "o
-00000d50: 6666 7365 745f 7570 5f6d 6d22 3a20 302c  ffset_up_mm": 0,
-00000d60: 0d0a 2020 2020 2020 2020 2020 2020 226f  ..            "o
-00000d70: 6666 7365 745f 696e 5f6d 6d22 3a20 302c  ffset_in_mm": 0,
-00000d80: 0d0a 2020 2020 2020 2020 2020 2020 2262  ..            "b
-00000d90: 625f 7369 7a65 5f6d 6d22 3a20 352c 0d0a  b_size_mm": 5,..
-00000da0: 2020 2020 2020 2020 2020 2020 2272 6164              "rad
-00000db0: 5f73 697a 655f 6d6d 223a 2032 302c 0d0a  _size_mm": 20,..
-00000dc0: 2020 2020 2020 2020 7d2c 0d0a 2020 2020          },..    
-00000dd0: 2020 2020 7b0d 0a20 2020 2020 2020 2020      {..         
-00000de0: 2020 2022 6e61 6d65 223a 2022 3122 2c0d     "name": "1",.
-00000df0: 0a20 2020 2020 2020 2020 2020 2022 6f66  .            "of
-00000e00: 6673 6574 5f6c 6566 745f 6d6d 223a 2030  fset_left_mm": 0
-00000e10: 2c0d 0a20 2020 2020 2020 2020 2020 2022  ,..            "
-00000e20: 6f66 6673 6574 5f75 705f 6d6d 223a 2030  offset_up_mm": 0
-00000e30: 2c0d 0a20 2020 2020 2020 2020 2020 2022  ,..            "
-00000e40: 6f66 6673 6574 5f69 6e5f 6d6d 223a 2033  offset_in_mm": 3
-00000e50: 302c 0d0a 2020 2020 2020 2020 2020 2020  0,..            
-00000e60: 2262 625f 7369 7a65 5f6d 6d22 3a20 352c  "bb_size_mm": 5,
-00000e70: 0d0a 2020 2020 2020 2020 2020 2020 2272  ..            "r
-00000e80: 6164 5f73 697a 655f 6d6d 223a 2032 302c  ad_size_mm": 20,
-00000e90: 0d0a 2020 2020 2020 2020 7d2c 0d0a 2020  ..        },..  
-00000ea0: 2020 2020 2020 7b0d 0a20 2020 2020 2020        {..       
-00000eb0: 2020 2020 2022 6e61 6d65 223a 2022 3222       "name": "2"
-00000ec0: 2c0d 0a20 2020 2020 2020 2020 2020 2022  ,..            "
-00000ed0: 6f66 6673 6574 5f6c 6566 745f 6d6d 223a  offset_left_mm":
-00000ee0: 202d 3330 2c0d 0a20 2020 2020 2020 2020   -30,..         
-00000ef0: 2020 2022 6f66 6673 6574 5f75 705f 6d6d     "offset_up_mm
-00000f00: 223a 2030 2c0d 0a20 2020 2020 2020 2020  ": 0,..         
-00000f10: 2020 2022 6f66 6673 6574 5f69 6e5f 6d6d     "offset_in_mm
-00000f20: 223a 2031 352c 0d0a 2020 2020 2020 2020  ": 15,..        
-00000f30: 2020 2020 2262 625f 7369 7a65 5f6d 6d22      "bb_size_mm"
-00000f40: 3a20 352c 0d0a 2020 2020 2020 2020 2020  : 5,..          
-00000f50: 2020 2272 6164 5f73 697a 655f 6d6d 223a    "rad_size_mm":
-00000f60: 2032 302c 0d0a 2020 2020 2020 2020 7d2c   20,..        },
-00000f70: 0d0a 2020 2020 2020 2020 7b0d 0a20 2020  ..        {..   
-00000f80: 2020 2020 2020 2020 2022 6e61 6d65 223a           "name":
-00000f90: 2022 3322 2c0d 0a20 2020 2020 2020 2020   "3",..         
-00000fa0: 2020 2022 6f66 6673 6574 5f6c 6566 745f     "offset_left_
-00000fb0: 6d6d 223a 2030 2c0d 0a20 2020 2020 2020  mm": 0,..       
-00000fc0: 2020 2020 2022 6f66 6673 6574 5f75 705f       "offset_up_
-00000fd0: 6d6d 223a 2030 2c0d 0a20 2020 2020 2020  mm": 0,..       
-00000fe0: 2020 2020 2022 6f66 6673 6574 5f69 6e5f       "offset_in_
-00000ff0: 6d6d 223a 202d 3330 2c0d 0a20 2020 2020  mm": -30,..     
-00001000: 2020 2020 2020 2022 6262 5f73 697a 655f         "bb_size_
-00001010: 6d6d 223a 2035 2c0d 0a20 2020 2020 2020  mm": 5,..       
-00001020: 2020 2020 2022 7261 645f 7369 7a65 5f6d       "rad_size_m
-00001030: 6d22 3a20 3230 2c0d 0a20 2020 2020 2020  m": 20,..       
-00001040: 207d 2c0d 0a20 2020 2020 2020 207b 0d0a   },..        {..
-00001050: 2020 2020 2020 2020 2020 2020 226e 616d              "nam
-00001060: 6522 3a20 2234 222c 0d0a 2020 2020 2020  e": "4",..      
-00001070: 2020 2020 2020 226f 6666 7365 745f 6c65        "offset_le
-00001080: 6674 5f6d 6d22 3a20 3330 2c0d 0a20 2020  ft_mm": 30,..   
-00001090: 2020 2020 2020 2020 2022 6f66 6673 6574           "offset
-000010a0: 5f75 705f 6d6d 223a 2030 2c0d 0a20 2020  _up_mm": 0,..   
-000010b0: 2020 2020 2020 2020 2022 6f66 6673 6574           "offset
-000010c0: 5f69 6e5f 6d6d 223a 202d 3530 2c0d 0a20  _in_mm": -50,.. 
-000010d0: 2020 2020 2020 2020 2020 2022 6262 5f73             "bb_s
-000010e0: 697a 655f 6d6d 223a 2035 2c0d 0a20 2020  ize_mm": 5,..   
-000010f0: 2020 2020 2020 2020 2022 7261 645f 7369           "rad_si
-00001100: 7a65 5f6d 6d22 3a20 3230 2c0d 0a20 2020  ze_mm": 20,..   
-00001110: 2020 2020 207d 2c0d 0a20 2020 2020 2020       },..       
-00001120: 207b 0d0a 2020 2020 2020 2020 2020 2020   {..            
-00001130: 226e 616d 6522 3a20 2235 222c 0d0a 2020  "name": "5",..  
-00001140: 2020 2020 2020 2020 2020 226f 6666 7365            "offse
-00001150: 745f 6c65 6674 5f6d 6d22 3a20 302c 0d0a  t_left_mm": 0,..
-00001160: 2020 2020 2020 2020 2020 2020 226f 6666              "off
-00001170: 7365 745f 7570 5f6d 6d22 3a20 302c 0d0a  set_up_mm": 0,..
-00001180: 2020 2020 2020 2020 2020 2020 226f 6666              "off
-00001190: 7365 745f 696e 5f6d 6d22 3a20 2d37 302c  set_in_mm": -70,
-000011a0: 0d0a 2020 2020 2020 2020 2020 2020 2262  ..            "b
-000011b0: 625f 7369 7a65 5f6d 6d22 3a20 352c 0d0a  b_size_mm": 5,..
-000011c0: 2020 2020 2020 2020 2020 2020 2272 6164              "rad
-000011d0: 5f73 697a 655f 6d6d 223a 2032 302c 0d0a  _size_mm": 20,..
-000011e0: 2020 2020 2020 2020 7d2c 0d0a 2020 2020          },..    
-000011f0: 290d 0a20 2020 2044 454d 4f20 3d20 280d  )..    DEMO = (.
-00001200: 0a20 2020 2020 2020 207b 0d0a 2020 2020  .        {..    
-00001210: 2020 2020 2020 2020 226e 616d 6522 3a20          "name": 
-00001220: 2249 736f 222c 0d0a 2020 2020 2020 2020  "Iso",..        
-00001230: 2020 2020 226f 6666 7365 745f 6c65 6674      "offset_left
-00001240: 5f6d 6d22 3a20 302c 0d0a 2020 2020 2020  _mm": 0,..      
-00001250: 2020 2020 2020 226f 6666 7365 745f 7570        "offset_up
-00001260: 5f6d 6d22 3a20 302c 0d0a 2020 2020 2020  _mm": 0,..      
-00001270: 2020 2020 2020 226f 6666 7365 745f 696e        "offset_in
-00001280: 5f6d 6d22 3a20 302c 0d0a 2020 2020 2020  _mm": 0,..      
-00001290: 2020 2020 2020 2262 625f 7369 7a65 5f6d        "bb_size_m
-000012a0: 6d22 3a20 352c 0d0a 2020 2020 2020 2020  m": 5,..        
-000012b0: 2020 2020 2272 6164 5f73 697a 655f 6d6d      "rad_size_mm
-000012c0: 223a 2032 302c 0d0a 2020 2020 2020 2020  ": 20,..        
-000012d0: 7d2c 0d0a 2020 2020 2020 2020 7b0d 0a20  },..        {.. 
-000012e0: 2020 2020 2020 2020 2020 2022 6e61 6d65             "name
-000012f0: 223a 2022 4c65 6674 2c44 6f77 6e2c 496e  ": "Left,Down,In
-00001300: 222c 0d0a 2020 2020 2020 2020 2020 2020  ",..            
-00001310: 226f 6666 7365 745f 6c65 6674 5f6d 6d22  "offset_left_mm"
-00001320: 3a20 3230 2c0d 0a20 2020 2020 2020 2020  : 20,..         
-00001330: 2020 2022 6f66 6673 6574 5f75 705f 6d6d     "offset_up_mm
-00001340: 223a 202d 3230 2c0d 0a20 2020 2020 2020  ": -20,..       
-00001350: 2020 2020 2022 6f66 6673 6574 5f69 6e5f       "offset_in_
-00001360: 6d6d 223a 2036 302c 0d0a 2020 2020 2020  mm": 60,..      
-00001370: 2020 2020 2020 2262 625f 7369 7a65 5f6d        "bb_size_m
-00001380: 6d22 3a20 352c 0d0a 2020 2020 2020 2020  m": 5,..        
-00001390: 2020 2020 2272 6164 5f73 697a 655f 6d6d      "rad_size_mm
-000013a0: 223a 2032 302c 0d0a 2020 2020 2020 2020  ": 20,..        
-000013b0: 7d2c 0d0a 2020 2020 290d 0a0d 0a20 2020  },..    )....   
-000013c0: 2040 7374 6174 6963 6d65 7468 6f64 0d0a   @staticmethod..
-000013d0: 2020 2020 6465 6620 746f 5f68 756d 616e      def to_human
-000013e0: 2861 7272 616e 6765 6d65 6e74 3a20 6469  (arrangement: di
-000013f0: 6374 2920 2d3e 2073 7472 3a0d 0a20 2020  ct) -> str:..   
-00001400: 2020 2020 2022 2222 436f 6e76 6572 7420       """Convert 
-00001410: 6f6e 6520 4242 206c 6f63 6174 696f 6e20  one BB location 
-00001420: 746f 2061 2068 756d 616e 2d72 6561 6461  to a human-reada
-00001430: 626c 6520 7374 7222 2222 0d0a 2020 2020  ble str"""..    
-00001440: 2020 2020 6120 3d20 6172 7261 6e67 656d      a = arrangem
-00001450: 656e 740d 0a20 2020 2020 2020 206c 7220  ent..        lr 
-00001460: 3d20 224c 6566 7422 2069 6620 615b 226f  = "Left" if a["o
-00001470: 6666 7365 745f 6c65 6674 5f6d 6d22 5d20  ffset_left_mm"] 
-00001480: 3e3d 2030 2065 6c73 6520 2252 6967 6874  >= 0 else "Right
-00001490: 220d 0a20 2020 2020 2020 2075 6420 3d20  "..        ud = 
-000014a0: 2255 7022 2069 6620 615b 226f 6666 7365  "Up" if a["offse
-000014b0: 745f 7570 5f6d 6d22 5d20 3e3d 2030 2065  t_up_mm"] >= 0 e
-000014c0: 6c73 6520 2244 6f77 6e22 0d0a 2020 2020  lse "Down"..    
-000014d0: 2020 2020 696f 203d 2022 496e 2220 6966      io = "In" if
-000014e0: 2061 5b22 6f66 6673 6574 5f69 6e5f 6d6d   a["offset_in_mm
-000014f0: 225d 203e 3d20 3020 656c 7365 2022 4f75  "] >= 0 else "Ou
-00001500: 7422 0d0a 2020 2020 2020 2020 7265 7475  t"..        retu
-00001510: 726e 2066 2227 7b61 5b27 6e61 6d65 275d  rn f"'{a['name']
-00001520: 7d27 3a20 7b6c 727d 207b 6162 7328 615b  }': {lr} {abs(a[
-00001530: 276f 6666 7365 745f 6c65 6674 5f6d 6d27  'offset_left_mm'
-00001540: 5d29 7d6d 6d2c 207b 7564 7d20 7b61 6273  ])}mm, {ud} {abs
-00001550: 2861 5b27 6f66 6673 6574 5f75 705f 6d6d  (a['offset_up_mm
-00001560: 275d 297d 6d6d 2c20 7b69 6f7d 207b 6162  '])}mm, {io} {ab
-00001570: 7328 615b 276f 6666 7365 745f 696e 5f6d  s(a['offset_in_m
-00001580: 6d27 5d29 7d6d 6d22 0d0a 0d0a 0d0a 636c  m'])}mm"......cl
-00001590: 6173 7320 4e6f 6d69 6e61 6c42 4228 5479  ass NominalBB(Ty
-000015a0: 7065 6444 6963 7429 3a0d 0a20 2020 2022  pedDict):..    "
-000015b0: 2222 496e 7075 7420 666f 7220 4242 206c  ""Input for BB l
-000015c0: 6f63 6174 696f 6e22 2222 0d0a 0d0a 2020  ocation"""....  
-000015d0: 2020 6f66 6673 6574 5f6c 6566 745f 6d6d    offset_left_mm
-000015e0: 3a20 666c 6f61 740d 0a20 2020 206f 6666  : float..    off
-000015f0: 7365 745f 7570 5f6d 6d3a 2066 6c6f 6174  set_up_mm: float
-00001600: 0d0a 2020 2020 6f66 6673 6574 5f69 6e5f  ..    offset_in_
-00001610: 6d6d 3a20 666c 6f61 740d 0a20 2020 2062  mm: float..    b
-00001620: 625f 6469 616d 6574 6572 5f6d 6d3a 2066  b_diameter_mm: f
-00001630: 6c6f 6174 0d0a 0d0a 0d0a 636c 6173 7320  loat......class 
-00001640: 4242 3a0d 0a20 2020 2022 2222 4120 7265  BB:..    """A re
-00001650: 7072 6573 656e 7461 7469 6f6e 206f 6620  presentation of 
-00001660: 6120 4242 2069 6e20 3344 2073 7061 6365  a BB in 3D space
-00001670: 2222 220d 0a0d 0a20 2020 2064 6566 205f  """....    def _
-00001680: 5f72 6570 725f 5f28 7365 6c66 293a 0d0a  _repr__(self):..
-00001690: 2020 2020 2020 2020 7265 7475 726e 2073          return s
-000016a0: 656c 662e 6e6f 6d69 6e61 6c5f 706f 7369  elf.nominal_posi
-000016b0: 7469 6f6e 0d0a 0d0a 2020 2020 6465 6620  tion....    def 
-000016c0: 5f5f 696e 6974 5f5f 2873 656c 662c 206e  __init__(self, n
-000016d0: 6f6d 696e 616c 5f62 623a 204e 6f6d 696e  ominal_bb: Nomin
-000016e0: 616c 4242 2c20 7261 795f 6c69 6e65 733a  alBB, ray_lines:
-000016f0: 206c 6973 745b 4c69 6e65 5d29 3a0d 0a20   list[Line]):.. 
-00001700: 2020 2020 2020 2073 656c 662e 6e6f 6d69         self.nomi
-00001710: 6e61 6c5f 6262 203d 206e 6f6d 696e 616c  nal_bb = nominal
-00001720: 5f62 620d 0a20 2020 2020 2020 2073 656c  _bb..        sel
-00001730: 662e 7261 795f 6c69 6e65 7320 3d20 7261  f.ray_lines = ra
-00001740: 795f 6c69 6e65 730d 0a0d 0a20 2020 2040  y_lines....    @
-00001750: 6361 6368 6564 5f70 726f 7065 7274 790d  cached_property.
-00001760: 0a20 2020 2064 6566 206d 6561 7375 7265  .    def measure
-00001770: 645f 706f 7369 7469 6f6e 2873 656c 6629  d_position(self)
-00001780: 202d 3e20 506f 696e 743a 0d0a 2020 2020   -> Point:..    
-00001790: 2020 2020 2222 2254 6865 2033 4420 6d65      """The 3D me
-000017a0: 6173 7572 6564 2070 6f73 6974 696f 6e20  asured position 
-000017b0: 6f66 2074 6865 2042 4220 6261 7365 6420  of the BB based 
-000017c0: 6f6e 2074 6865 2072 6179 2d74 7261 6369  on the ray-traci
-000017d0: 6e67 206c 696e 6573 2069 6e20 4d4d 2222  ng lines in MM""
-000017e0: 220d 0a20 2020 2020 2020 2069 6e69 7469  "..        initi
-000017f0: 616c 5f67 7565 7373 203d 2073 656c 662e  al_guess = self.
-00001800: 6e6f 6d69 6e61 6c5f 706f 7369 7469 6f6e  nominal_position
-00001810: 2e61 735f 6172 7261 7928 290d 0a20 2020  .as_array()..   
-00001820: 2020 2020 2062 6f75 6e64 7320 3d20 5b28       bounds = [(
-00001830: 2d32 3030 2c20 3230 3029 2c20 282d 3230  -200, 200), (-20
-00001840: 302c 2032 3030 292c 2028 2d32 3030 2c20  0, 200), (-200, 
-00001850: 3230 3029 5d0d 0a20 2020 2020 2020 2072  200)]..        r
-00001860: 6573 756c 7420 3d20 6f70 7469 6d69 7a65  esult = optimize
-00001870: 2e6d 696e 696d 697a 6528 0d0a 2020 2020  .minimize(..    
-00001880: 2020 2020 2020 2020 6d61 785f 6469 7374          max_dist
-00001890: 616e 6365 5f74 6f5f 6c69 6e65 732c 2069  ance_to_lines, i
-000018a0: 6e69 7469 616c 5f67 7565 7373 2c20 6172  nitial_guess, ar
-000018b0: 6773 3d73 656c 662e 7261 795f 6c69 6e65  gs=self.ray_line
-000018c0: 732c 2062 6f75 6e64 733d 626f 756e 6473  s, bounds=bounds
-000018d0: 0d0a 2020 2020 2020 2020 290d 0a20 2020  ..        )..   
-000018e0: 2020 2020 2072 6574 7572 6e20 506f 696e       return Poin
-000018f0: 7428 7265 7375 6c74 2e78 290d 0a0d 0a20  t(result.x).... 
-00001900: 2020 2040 6361 6368 6564 5f70 726f 7065     @cached_prope
-00001910: 7274 790d 0a20 2020 2064 6566 206e 6f6d  rty..    def nom
-00001920: 696e 616c 5f70 6f73 6974 696f 6e28 7365  inal_position(se
-00001930: 6c66 2920 2d3e 2050 6f69 6e74 3a0d 0a20  lf) -> Point:.. 
-00001940: 2020 2020 2020 2022 2222 5468 6520 6e6f         """The no
-00001950: 6d69 6e61 6c20 6c6f 6361 7469 6f6e 206f  minal location o
-00001960: 6620 7468 6520 4242 2069 6e20 4d4d 2222  f the BB in MM""
-00001970: 220d 0a20 2020 2020 2020 2072 6574 7572  "..        retur
-00001980: 6e20 506f 696e 7428 0d0a 2020 2020 2020  n Point(..      
-00001990: 2020 2020 2020 783d 2d73 656c 662e 6e6f        x=-self.no
-000019a0: 6d69 6e61 6c5f 6262 5b22 6f66 6673 6574  minal_bb["offset
-000019b0: 5f6c 6566 745f 6d6d 225d 2c0d 0a20 2020  _left_mm"],..   
-000019c0: 2020 2020 2020 2020 2079 3d2d 7365 6c66           y=-self
-000019d0: 2e6e 6f6d 696e 616c 5f62 625b 226f 6666  .nominal_bb["off
-000019e0: 7365 745f 696e 5f6d 6d22 5d2c 0d0a 2020  set_in_mm"],..  
-000019f0: 2020 2020 2020 2020 2020 7a3d 7365 6c66            z=self
-00001a00: 2e6e 6f6d 696e 616c 5f62 625b 226f 6666  .nominal_bb["off
-00001a10: 7365 745f 7570 5f6d 6d22 5d2c 0d0a 2020  set_up_mm"],..  
-00001a20: 2020 2020 2020 290d 0a0d 0a20 2020 2040        )....    @
-00001a30: 6361 6368 6564 5f70 726f 7065 7274 790d  cached_property.
-00001a40: 0a20 2020 2064 6566 2064 656c 7461 5f76  .    def delta_v
-00001a50: 6563 746f 7228 7365 6c66 2920 2d3e 2056  ector(self) -> V
-00001a60: 6563 746f 723a 0d0a 2020 2020 2020 2020  ector:..        
-00001a70: 2222 2254 6865 2073 6869 6674 2066 726f  """The shift fro
-00001a80: 6d20 6d65 6173 7572 6564 2042 4220 6c6f  m measured BB lo
-00001a90: 6361 7469 6f6e 2074 6f20 6e6f 6d69 6e61  cation to nomina
-00001aa0: 6c20 6173 2061 2076 6563 746f 7220 696e  l as a vector in
-00001ab0: 204d 4d22 2222 0d0a 2020 2020 2020 2020   MM"""..        
-00001ac0: 7265 7475 726e 2073 656c 662e 6d65 6173  return self.meas
-00001ad0: 7572 6564 5f70 6f73 6974 696f 6e20 2d20  ured_position - 
-00001ae0: 7365 6c66 2e6e 6f6d 696e 616c 5f70 6f73  self.nominal_pos
-00001af0: 6974 696f 6e0d 0a0d 0a20 2020 2040 6361  ition....    @ca
-00001b00: 6368 6564 5f70 726f 7065 7274 790d 0a20  ched_property.. 
-00001b10: 2020 2064 6566 2064 656c 7461 5f64 6973     def delta_dis
-00001b20: 7461 6e63 6528 7365 6c66 293a 0d0a 2020  tance(self):..  
-00001b30: 2020 2020 2020 2222 2254 6865 2073 6361        """The sca
-00001b40: 6c61 7220 6469 7374 616e 6365 2062 6574  lar distance bet
-00001b50: 7765 656e 2074 6865 206d 6561 7375 7265  ween the measure
-00001b60: 6420 4242 206c 6f63 6174 696f 6e20 616e  d BB location an
-00001b70: 6420 6e6f 6d69 6e61 6c20 696e 204d 4d22  d nominal in MM"
-00001b80: 2222 0d0a 2020 2020 2020 2020 7265 7475  ""..        retu
-00001b90: 726e 2073 656c 662e 6d65 6173 7572 6564  rn self.measured
-00001ba0: 5f70 6f73 6974 696f 6e2e 6469 7374 616e  _position.distan
-00001bb0: 6365 5f74 6f28 7365 6c66 2e6e 6f6d 696e  ce_to(self.nomin
-00001bc0: 616c 5f70 6f73 6974 696f 6e29 0d0a 0d0a  al_position)....
-00001bd0: 2020 2020 6465 6620 706c 6f74 5f6e 6f6d      def plot_nom
-00001be0: 696e 616c 2873 656c 662c 2061 7865 733a  inal(self, axes:
-00001bf0: 2070 6c74 2e41 7865 732c 2063 6f6c 6f72   plt.Axes, color
-00001c00: 3a20 7374 722c 202a 2a6b 7761 7267 7329  : str, **kwargs)
-00001c10: 3a0d 0a20 2020 2020 2020 2022 2222 506c  :..        """Pl
-00001c20: 6f74 2074 6865 2042 4220 6e6f 6d69 6e61  ot the BB nomina
-00001c30: 6c20 706f 7369 7469 6f6e 2222 220d 0a20  l position""".. 
-00001c40: 2020 2020 2020 2078 2c20 792c 207a 203d         x, y, z =
-00001c50: 2063 7265 6174 655f 7370 6865 7265 5f73   create_sphere_s
-00001c60: 7572 6661 6365 280d 0a20 2020 2020 2020  urface(..       
-00001c70: 2020 2020 2072 6164 6975 733d 7365 6c66       radius=self
-00001c80: 2e6e 6f6d 696e 616c 5f62 625b 2262 625f  .nominal_bb["bb_
-00001c90: 6469 616d 6574 6572 5f6d 6d22 5d20 2f20  diameter_mm"] / 
-00001ca0: 322c 2063 656e 7465 723d 7365 6c66 2e6e  2, center=self.n
-00001cb0: 6f6d 696e 616c 5f70 6f73 6974 696f 6e0d  ominal_position.
-00001cc0: 0a20 2020 2020 2020 2029 0d0a 2020 2020  .        )..    
-00001cd0: 2020 2020 6178 6573 2e70 6c6f 745f 7375      axes.plot_su
-00001ce0: 7266 6163 6528 782c 2079 2c20 7a2c 2063  rface(x, y, z, c
-00001cf0: 6f6c 6f72 3d63 6f6c 6f72 2c20 2a2a 6b77  olor=color, **kw
-00001d00: 6172 6773 290d 0a0d 0a20 2020 2064 6566  args)....    def
-00001d10: 2070 6c6f 745f 6d65 6173 7572 6564 2873   plot_measured(s
-00001d20: 656c 662c 2061 7865 733a 2070 6c74 2e41  elf, axes: plt.A
-00001d30: 7865 732c 2063 6f6c 6f72 3a20 7374 722c  xes, color: str,
-00001d40: 202a 2a6b 7761 7267 7329 3a0d 0a20 2020   **kwargs):..   
-00001d50: 2020 2020 2022 2222 506c 6f74 2074 6865       """Plot the
-00001d60: 2042 4220 6d65 6173 7572 6564 2070 6f73   BB measured pos
-00001d70: 6974 696f 6e22 2222 0d0a 2020 2020 2020  ition"""..      
-00001d80: 2020 782c 2079 2c20 7a20 3d20 6372 6561    x, y, z = crea
-00001d90: 7465 5f73 7068 6572 655f 7375 7266 6163  te_sphere_surfac
-00001da0: 6528 0d0a 2020 2020 2020 2020 2020 2020  e(..            
-00001db0: 7261 6469 7573 3d73 656c 662e 6e6f 6d69  radius=self.nomi
-00001dc0: 6e61 6c5f 6262 5b22 6262 5f64 6961 6d65  nal_bb["bb_diame
-00001dd0: 7465 725f 6d6d 225d 202f 2032 2c20 6365  ter_mm"] / 2, ce
-00001de0: 6e74 6572 3d73 656c 662e 6d65 6173 7572  nter=self.measur
-00001df0: 6564 5f70 6f73 6974 696f 6e0d 0a20 2020  ed_position..   
-00001e00: 2020 2020 2029 0d0a 2020 2020 2020 2020       )..        
-00001e10: 6178 6573 2e70 6c6f 745f 7375 7266 6163  axes.plot_surfac
-00001e20: 6528 782c 2079 2c20 7a2c 2063 6f6c 6f72  e(x, y, z, color
-00001e30: 3d63 6f6c 6f72 2c20 2a2a 6b77 6172 6773  =color, **kwargs
-00001e40: 290d 0a0d 0a0d 0a64 6566 2063 7265 6174  )......def creat
-00001e50: 655f 7370 6865 7265 5f73 7572 6661 6365  e_sphere_surface
-00001e60: 280d 0a20 2020 2072 6164 6975 733a 2066  (..    radius: f
-00001e70: 6c6f 6174 2c20 6365 6e74 6572 3a20 506f  loat, center: Po
-00001e80: 696e 740d 0a29 202d 3e20 7475 706c 655b  int..) -> tuple[
-00001e90: 6e70 2e6e 6461 7272 6179 2c20 6e70 2e6e  np.ndarray, np.n
-00001ea0: 6461 7272 6179 2c20 6e70 2e6e 6461 7272  darray, np.ndarr
-00001eb0: 6179 5d3a 0d0a 2020 2020 2222 2243 7265  ay]:..    """Cre
-00001ec0: 6174 6520 6120 7370 6865 7265 2073 7572  ate a sphere sur
-00001ed0: 6661 6365 2066 6f72 2070 6c6f 7474 696e  face for plottin
-00001ee0: 6722 2222 0d0a 2020 2020 7520 3d20 6e70  g"""..    u = np
-00001ef0: 2e6c 696e 7370 6163 6528 302c 2032 202a  .linspace(0, 2 *
-00001f00: 206e 702e 7069 2c20 3130 3029 0d0a 2020   np.pi, 100)..  
-00001f10: 2020 7620 3d20 6e70 2e6c 696e 7370 6163    v = np.linspac
-00001f20: 6528 302c 206e 702e 7069 2c20 3130 3029  e(0, np.pi, 100)
-00001f30: 0d0a 2020 2020 7820 3d20 7261 6469 7573  ..    x = radius
-00001f40: 202a 206e 702e 6f75 7465 7228 6e70 2e63   * np.outer(np.c
-00001f50: 6f73 2875 292c 206e 702e 7369 6e28 7629  os(u), np.sin(v)
-00001f60: 2920 2b20 6365 6e74 6572 2e78 0d0a 2020  ) + center.x..  
-00001f70: 2020 7920 3d20 7261 6469 7573 202a 206e    y = radius * n
-00001f80: 702e 6f75 7465 7228 6e70 2e73 696e 2875  p.outer(np.sin(u
-00001f90: 292c 206e 702e 7369 6e28 7629 2920 2b20  ), np.sin(v)) + 
-00001fa0: 6365 6e74 6572 2e79 0d0a 2020 2020 7a20  center.y..    z 
-00001fb0: 3d20 7261 6469 7573 202a 206e 702e 6f75  = radius * np.ou
-00001fc0: 7465 7228 6e70 2e6f 6e65 7328 6e70 2e73  ter(np.ones(np.s
-00001fd0: 697a 6528 7529 292c 206e 702e 636f 7328  ize(u)), np.cos(
-00001fe0: 7629 2920 2b20 6365 6e74 6572 2e7a 0d0a  v)) + center.z..
-00001ff0: 2020 2020 7265 7475 726e 2078 2c20 792c      return x, y,
-00002000: 207a 0d0a 0d0a 0d0a 636c 6173 7320 4178   z......class Ax
-00002010: 6973 2865 6e75 6d2e 456e 756d 293a 0d0a  is(enum.Enum):..
-00002020: 2020 2020 4741 4e54 5259 203d 2022 4761      GANTRY = "Ga
-00002030: 6e74 7279 2220 2023 3a0d 0a20 2020 2043  ntry"  #:..    C
-00002040: 4f4c 4c49 4d41 544f 5220 3d20 2243 6f6c  OLLIMATOR = "Col
-00002050: 6c69 6d61 746f 7222 2020 233a 0d0a 2020  limator"  #:..  
-00002060: 2020 434f 5543 4820 3d20 2243 6f75 6368    COUCH = "Couch
-00002070: 2220 2023 3a0d 0a20 2020 2047 425f 434f  "  #:..    GB_CO
-00002080: 4d42 4f20 3d20 2247 4220 436f 6d62 6f22  MBO = "GB Combo"
-00002090: 2020 233a 0d0a 2020 2020 4742 505f 434f    #:..    GBP_CO
-000020a0: 4d42 4f20 3d20 2247 4250 2043 6f6d 626f  MBO = "GBP Combo
-000020b0: 2220 2023 3a0d 0a20 2020 2045 5049 4420  "  #:..    EPID 
-000020c0: 3d20 2245 7069 6422 2020 233a 0d0a 2020  = "Epid"  #:..  
-000020d0: 2020 5245 4645 5245 4e43 4520 3d20 2252    REFERENCE = "R
-000020e0: 6566 6572 656e 6365 2220 2023 3a0d 0a0d  eference"  #:...
-000020f0: 0a0d 0a40 6461 7461 636c 6173 730d 0a63  ...@dataclass..c
-00002100: 6c61 7373 2057 696e 7374 6f6e 4c75 747a  lass WinstonLutz
-00002110: 3244 5265 7375 6c74 2852 6573 756c 7442  2DResult(ResultB
-00002120: 6173 6529 3a0d 0a20 2020 2076 6172 6961  ase):..    varia
-00002130: 626c 655f 6178 6973 3a20 7374 7220 2023  ble_axis: str  #
-00002140: 3a0d 0a20 2020 2063 6178 3265 7069 645f  :..    cax2epid_
-00002150: 7665 6374 6f72 3a20 5665 6374 6f72 2020  vector: Vector  
-00002160: 233a 0d0a 2020 2020 6361 7832 6570 6964  #:..    cax2epid
-00002170: 5f64 6973 7461 6e63 653a 2066 6c6f 6174  _distance: float
-00002180: 2020 233a 0d0a 2020 2020 6361 7832 6262    #:..    cax2bb
-00002190: 5f64 6973 7461 6e63 653a 2066 6c6f 6174  _distance: float
-000021a0: 2020 233a 0d0a 2020 2020 6361 7832 6262    #:..    cax2bb
-000021b0: 5f76 6563 746f 723a 2056 6563 746f 7220  _vector: Vector 
-000021c0: 2023 3a0d 0a20 2020 2062 625f 6c6f 6361   #:..    bb_loca
-000021d0: 7469 6f6e 3a20 506f 696e 7420 2023 3a0d  tion: Point  #:.
-000021e0: 0a20 2020 2066 6965 6c64 5f63 6178 3a20  .    field_cax: 
-000021f0: 506f 696e 7420 2023 3a0d 0a0d 0a0d 0a40  Point  #:......@
-00002200: 6461 7461 636c 6173 730d 0a63 6c61 7373  dataclass..class
-00002210: 2057 696e 7374 6f6e 4c75 747a 5265 7375   WinstonLutzResu
-00002220: 6c74 2852 6573 756c 7442 6173 6529 3a0d  lt(ResultBase):.
-00002230: 0a20 2020 2022 2222 5468 6973 2063 6c61  .    """This cla
-00002240: 7373 2073 686f 756c 6420 6e6f 7420 6265  ss should not be
-00002250: 2063 616c 6c65 6420 6469 7265 6374 6c79   called directly
-00002260: 2e20 4974 2069 7320 7265 7475 726e 6564  . It is returned
-00002270: 2062 7920 7468 6520 6060 7265 7375 6c74   by the ``result
-00002280: 735f 6461 7461 2829 6060 206d 6574 686f  s_data()`` metho
-00002290: 642e 0d0a 2020 2020 4974 2069 7320 6120  d...    It is a 
-000022a0: 6461 7461 636c 6173 7320 756e 6465 7220  dataclass under 
-000022b0: 7468 6520 686f 6f64 2061 6e64 2074 6875  the hood and thu
-000022c0: 7320 636f 6d65 7320 7769 7468 2061 6c6c  s comes with all
-000022d0: 2074 6865 2064 756e 6465 7220 6d61 6769   the dunder magi
-000022e0: 632e 0d0a 0d0a 2020 2020 5573 6520 7468  c.....    Use th
-000022f0: 6520 666f 6c6c 6f77 696e 6720 6174 7472  e following attr
-00002300: 6962 7574 6573 2061 7320 6e6f 726d 616c  ibutes as normal
-00002310: 2063 6c61 7373 2061 7474 7269 6275 7465   class attribute
-00002320: 732e 2222 220d 0a0d 0a20 2020 206e 756d  s."""....    num
-00002330: 5f67 616e 7472 795f 696d 6167 6573 3a20  _gantry_images: 
-00002340: 696e 7420 2023 3a0d 0a20 2020 206e 756d  int  #:..    num
-00002350: 5f67 616e 7472 795f 636f 6c6c 5f69 6d61  _gantry_coll_ima
-00002360: 6765 733a 2069 6e74 2020 233a 0d0a 2020  ges: int  #:..  
-00002370: 2020 6e75 6d5f 636f 6c6c 5f69 6d61 6765    num_coll_image
-00002380: 733a 2069 6e74 2020 233a 0d0a 2020 2020  s: int  #:..    
-00002390: 6e75 6d5f 636f 7563 685f 696d 6167 6573  num_couch_images
-000023a0: 3a20 696e 7420 2023 3a0d 0a20 2020 206e  : int  #:..    n
-000023b0: 756d 5f74 6f74 616c 5f69 6d61 6765 733a  um_total_images:
-000023c0: 2069 6e74 2020 233a 0d0a 2020 2020 6d61   int  #:..    ma
-000023d0: 785f 3264 5f63 6178 5f74 6f5f 6262 5f6d  x_2d_cax_to_bb_m
-000023e0: 6d3a 2066 6c6f 6174 2020 233a 0d0a 2020  m: float  #:..  
-000023f0: 2020 6d65 6469 616e 5f32 645f 6361 785f    median_2d_cax_
-00002400: 746f 5f62 625f 6d6d 3a20 666c 6f61 7420  to_bb_mm: float 
-00002410: 2023 3a0d 0a20 2020 206d 6561 6e5f 3264   #:..    mean_2d
-00002420: 5f63 6178 5f74 6f5f 6262 5f6d 6d3a 2066  _cax_to_bb_mm: f
-00002430: 6c6f 6174 2020 233a 0d0a 2020 2020 6d61  loat  #:..    ma
-00002440: 785f 3264 5f63 6178 5f74 6f5f 6570 6964  x_2d_cax_to_epid
-00002450: 5f6d 6d3a 2066 6c6f 6174 2020 233a 0d0a  _mm: float  #:..
-00002460: 2020 2020 6d65 6469 616e 5f32 645f 6361      median_2d_ca
-00002470: 785f 746f 5f65 7069 645f 6d6d 3a20 666c  x_to_epid_mm: fl
-00002480: 6f61 7420 2023 3a0d 0a20 2020 206d 6561  oat  #:..    mea
-00002490: 6e5f 3264 5f63 6178 5f74 6f5f 6570 6964  n_2d_cax_to_epid
-000024a0: 5f6d 6d3a 2066 6c6f 6174 2020 233a 0d0a  _mm: float  #:..
-000024b0: 2020 2020 6761 6e74 7279 5f33 645f 6973      gantry_3d_is
-000024c0: 6f5f 6469 616d 6574 6572 5f6d 6d3a 2066  o_diameter_mm: f
-000024d0: 6c6f 6174 2020 233a 0d0a 2020 2020 6d61  loat  #:..    ma
-000024e0: 785f 6761 6e74 7279 5f72 6d73 5f64 6576  x_gantry_rms_dev
-000024f0: 6961 7469 6f6e 5f6d 6d3a 2066 6c6f 6174  iation_mm: float
-00002500: 2020 233a 0d0a 2020 2020 6d61 785f 6570    #:..    max_ep
-00002510: 6964 5f72 6d73 5f64 6576 6961 7469 6f6e  id_rms_deviation
-00002520: 5f6d 6d3a 2066 6c6f 6174 2020 233a 0d0a  _mm: float  #:..
-00002530: 2020 2020 6761 6e74 7279 5f63 6f6c 6c5f      gantry_coll_
-00002540: 3364 5f69 736f 5f64 6961 6d65 7465 725f  3d_iso_diameter_
-00002550: 6d6d 3a20 666c 6f61 7420 2023 3a0d 0a20  mm: float  #:.. 
-00002560: 2020 2063 6f6c 6c5f 3264 5f69 736f 5f64     coll_2d_iso_d
-00002570: 6961 6d65 7465 725f 6d6d 3a20 666c 6f61  iameter_mm: floa
-00002580: 7420 2023 3a0d 0a20 2020 206d 6178 5f63  t  #:..    max_c
-00002590: 6f6c 6c5f 726d 735f 6465 7669 6174 696f  oll_rms_deviatio
-000025a0: 6e5f 6d6d 3a20 666c 6f61 7420 2023 3a0d  n_mm: float  #:.
-000025b0: 0a20 2020 2063 6f75 6368 5f32 645f 6973  .    couch_2d_is
-000025c0: 6f5f 6469 616d 6574 6572 5f6d 6d3a 2066  o_diameter_mm: f
-000025d0: 6c6f 6174 2020 233a 0d0a 2020 2020 6d61  loat  #:..    ma
-000025e0: 785f 636f 7563 685f 726d 735f 6465 7669  x_couch_rms_devi
-000025f0: 6174 696f 6e5f 6d6d 3a20 666c 6f61 7420  ation_mm: float 
-00002600: 2023 3a0d 0a20 2020 2069 6d61 6765 5f64   #:..    image_d
-00002610: 6574 6169 6c73 3a20 6c69 7374 5b57 696e  etails: list[Win
-00002620: 7374 6f6e 4c75 747a 3244 5265 7375 6c74  stonLutz2DResult
-00002630: 5d20 2023 3a0d 0a20 2020 206b 6579 6564  ]  #:..    keyed
-00002640: 5f69 6d61 6765 5f64 6574 6169 6c73 3a20  _image_details: 
-00002650: 6469 6374 5b73 7472 2c20 5769 6e73 746f  dict[str, Winsto
-00002660: 6e4c 7574 7a32 4452 6573 756c 745d 2020  nLutz2DResult]  
-00002670: 233a 0d0a 0d0a 0d0a 4064 6174 6163 6c61  #:......@datacla
-00002680: 7373 0d0a 636c 6173 7320 5769 6e73 746f  ss..class Winsto
-00002690: 6e4c 7574 7a4d 756c 7469 5461 7267 6574  nLutzMultiTarget
-000026a0: 4d75 6c74 6946 6965 6c64 5265 7375 6c74  MultiFieldResult
-000026b0: 2852 6573 756c 7442 6173 6529 3a0d 0a20  (ResultBase):.. 
-000026c0: 2020 2022 2222 5468 6973 2063 6c61 7373     """This class
-000026d0: 2073 686f 756c 6420 6e6f 7420 6265 2063   should not be c
-000026e0: 616c 6c65 6420 6469 7265 6374 6c79 2e20  alled directly. 
-000026f0: 4974 2069 7320 7265 7475 726e 6564 2062  It is returned b
-00002700: 7920 7468 6520 6060 7265 7375 6c74 735f  y the ``results_
-00002710: 6461 7461 2829 6060 206d 6574 686f 642e  data()`` method.
-00002720: 0d0a 2020 2020 4974 2069 7320 6120 6461  ..    It is a da
-00002730: 7461 636c 6173 7320 756e 6465 7220 7468  taclass under th
-00002740: 6520 686f 6f64 2061 6e64 2074 6875 7320  e hood and thus 
-00002750: 636f 6d65 7320 7769 7468 2061 6c6c 2074  comes with all t
-00002760: 6865 2064 756e 6465 7220 6d61 6769 632e  he dunder magic.
-00002770: 0d0a 0d0a 2020 2020 5573 6520 7468 6520  ....    Use the 
-00002780: 666f 6c6c 6f77 696e 6720 6174 7472 6962  following attrib
-00002790: 7574 6573 2061 7320 6e6f 726d 616c 2063  utes as normal c
-000027a0: 6c61 7373 2061 7474 7269 6275 7465 732e  lass attributes.
-000027b0: 2222 220d 0a0d 0a20 2020 206e 756d 5f74  """....    num_t
-000027c0: 6f74 616c 5f69 6d61 6765 733a 2069 6e74  otal_images: int
-000027d0: 2020 233a 0d0a 2020 2020 6d61 785f 3264    #:..    max_2d
-000027e0: 5f66 6965 6c64 5f74 6f5f 6262 5f6d 6d3a  _field_to_bb_mm:
-000027f0: 2066 6c6f 6174 2020 233a 0d0a 2020 2020   float  #:..    
-00002800: 6d65 6469 616e 5f32 645f 6669 656c 645f  median_2d_field_
-00002810: 746f 5f62 625f 6d6d 3a20 666c 6f61 7420  to_bb_mm: float 
-00002820: 2023 3a0d 0a20 2020 206d 6561 6e5f 3264   #:..    mean_2d
-00002830: 5f66 6965 6c64 5f74 6f5f 6262 5f6d 6d3a  _field_to_bb_mm:
-00002840: 2066 6c6f 6174 2020 233a 0d0a 2020 2020   float  #:..    
-00002850: 6262 5f61 7272 616e 6765 6d65 6e74 3a20  bb_arrangement: 
-00002860: 4974 6572 6162 6c65 5b64 6963 745d 2020  Iterable[dict]  
-00002870: 233a 0d0a 2020 2020 6262 5f6d 6178 6573  #:..    bb_maxes
-00002880: 3a20 6469 6374 2020 233a 0d0a 0d0a 0d0a  : dict  #:......
-00002890: 6465 6620 706c 6f74 5f69 6d61 6765 2869  def plot_image(i
-000028a0: 6d67 3a20 5769 6e73 746f 6e4c 7574 7a32  mg: WinstonLutz2
-000028b0: 4420 7c20 4e6f 6e65 2c20 6178 6973 3a20  D | None, axis: 
-000028c0: 706c 742e 4178 6573 2920 2d3e 204e 6f6e  plt.Axes) -> Non
-000028d0: 653a 0d0a 2020 2020 2222 2248 656c 7065  e:..    """Helpe
-000028e0: 7220 6675 6e63 7469 6f6e 2074 6f20 706c  r function to pl
-000028f0: 6f74 2061 2057 4c49 6d61 6765 2074 6f20  ot a WLImage to 
-00002900: 616e 2061 7869 732e 2222 220d 0a20 2020  an axis."""..   
-00002910: 2069 6620 696d 6720 6973 204e 6f6e 653a   if img is None:
-00002920: 0d0a 2020 2020 2020 2020 6178 6973 2e73  ..        axis.s
-00002930: 6574 5f66 7261 6d65 5f6f 6e28 4661 6c73  et_frame_on(Fals
-00002940: 6529 0d0a 2020 2020 2020 2020 6178 6973  e)..        axis
-00002950: 2e61 7869 7328 226f 6666 2229 0d0a 2020  .axis("off")..  
-00002960: 2020 656c 7365 3a0d 0a20 2020 2020 2020    else:..       
-00002970: 2069 6d67 2e70 6c6f 7428 6178 3d61 7869   img.plot(ax=axi
-00002980: 732c 2073 686f 773d 4661 6c73 6529 0d0a  s, show=False)..
-00002990: 0d0a 0d0a 6465 6620 6973 5f6e 6561 725f  ....def is_near_
-000029a0: 6365 6e74 6572 2872 6567 696f 6e3a 2052  center(region: R
-000029b0: 6567 696f 6e50 726f 7065 7274 6965 732c  egionProperties,
-000029c0: 202a 6172 6773 2c20 2a2a 6b77 6172 6773   *args, **kwargs
-000029d0: 2920 2d3e 2062 6f6f 6c3a 0d0a 2020 2020  ) -> bool:..    
-000029e0: 2222 2257 6865 7468 6572 2074 6865 2062  """Whether the b
-000029f0: 6220 6973 203c 3263 6d20 6672 6f6d 2074  b is <2cm from t
-00002a00: 6865 2063 656e 7465 7220 6f66 2074 6865  he center of the
-00002a10: 2066 6965 6c64 2222 220d 0a20 2020 2064   field"""..    d
-00002a20: 706d 6d20 3d20 6b77 6172 6773 5b22 6470  pmm = kwargs["dp
-00002a30: 6d6d 225d 0d0a 2020 2020 7368 6170 6520  mm"]..    shape 
-00002a40: 3d20 6b77 6172 6773 5b22 7368 6170 6522  = kwargs["shape"
-00002a50: 5d0d 0a20 2020 2065 7874 656e 745f 6c69  ]..    extent_li
-00002a60: 6d69 745f 6d6d 203d 2032 300d 0a20 2020  mit_mm = 20..   
-00002a70: 2062 6f74 746f 6d2c 206c 6566 742c 2074   bottom, left, t
-00002a80: 6f70 2c20 7269 6768 7420 3d20 7265 6769  op, right = regi
-00002a90: 6f6e 2e62 626f 780d 0a20 2020 2062 625f  on.bbox..    bb_
-00002aa0: 6365 6e74 6572 5f78 203d 206c 6566 7420  center_x = left 
-00002ab0: 2b20 2872 6967 6874 202d 206c 6566 7429  + (right - left)
-00002ac0: 202f 2032 0d0a 2020 2020 6262 5f63 656e   / 2..    bb_cen
-00002ad0: 7465 725f 7920 3d20 626f 7474 6f6d 202b  ter_y = bottom +
-00002ae0: 2028 746f 7020 2d20 626f 7474 6f6d 2920   (top - bottom) 
-00002af0: 2f20 320d 0a20 2020 2078 5f6c 6f5f 6c69  / 2..    x_lo_li
-00002b00: 6d69 7420 3d20 7368 6170 655b 315d 202f  mit = shape[1] /
-00002b10: 2032 202d 2064 706d 6d20 2a20 6578 7465   2 - dpmm * exte
-00002b20: 6e74 5f6c 696d 6974 5f6d 6d0d 0a20 2020  nt_limit_mm..   
-00002b30: 2078 5f68 695f 6c69 6d69 7420 3d20 7368   x_hi_limit = sh
-00002b40: 6170 655b 315d 202f 2032 202b 2064 706d  ape[1] / 2 + dpm
-00002b50: 6d20 2a20 6578 7465 6e74 5f6c 696d 6974  m * extent_limit
-00002b60: 5f6d 6d0d 0a20 2020 2069 735f 6262 5f78  _mm..    is_bb_x
-00002b70: 5f63 656e 7465 7265 6420 3d20 785f 6c6f  _centered = x_lo
-00002b80: 5f6c 696d 6974 203c 2062 625f 6365 6e74  _limit < bb_cent
-00002b90: 6572 5f78 203c 2078 5f68 695f 6c69 6d69  er_x < x_hi_limi
-00002ba0: 740d 0a20 2020 2079 5f6c 6f5f 6c69 6d69  t..    y_lo_limi
-00002bb0: 7420 3d20 7368 6170 655b 305d 202f 2032  t = shape[0] / 2
-00002bc0: 202d 2064 706d 6d20 2a20 6578 7465 6e74   - dpmm * extent
-00002bd0: 5f6c 696d 6974 5f6d 6d0d 0a20 2020 2079  _limit_mm..    y
-00002be0: 5f68 695f 6c69 6d69 7420 3d20 7368 6170  _hi_limit = shap
-00002bf0: 655b 305d 202f 2032 202b 2064 706d 6d20  e[0] / 2 + dpmm 
-00002c00: 2a20 6578 7465 6e74 5f6c 696d 6974 5f6d  * extent_limit_m
-00002c10: 6d0d 0a20 2020 2069 735f 6262 5f79 5f63  m..    is_bb_y_c
-00002c20: 656e 7465 7265 6420 3d20 795f 6c6f 5f6c  entered = y_lo_l
-00002c30: 696d 6974 203c 2062 625f 6365 6e74 6572  imit < bb_center
-00002c40: 5f79 203c 2079 5f68 695f 6c69 6d69 740d  _y < y_hi_limit.
-00002c50: 0a20 2020 2072 6574 7572 6e20 6973 5f62  .    return is_b
-00002c60: 625f 785f 6365 6e74 6572 6564 2061 6e64  b_x_centered and
-00002c70: 2069 735f 6262 5f79 5f63 656e 7465 7265   is_bb_y_centere
-00002c80: 640d 0a0d 0a0d 0a64 6566 2069 735f 6d6f  d......def is_mo
-00002c90: 6465 7374 5f73 697a 6528 7265 6769 6f6e  dest_size(region
-00002ca0: 3a20 5265 6769 6f6e 5072 6f70 6572 7469  : RegionProperti
-00002cb0: 6573 2c20 2a61 7267 732c 202a 2a6b 7761  es, *args, **kwa
-00002cc0: 7267 7329 202d 3e20 626f 6f6c 3a0d 0a20  rgs) -> bool:.. 
-00002cd0: 2020 2022 2222 4465 6369 6465 2077 6865     """Decide whe
-00002ce0: 7468 6572 2074 6865 2052 4f49 2069 7320  ther the ROI is 
-00002cf0: 726f 7567 686c 7920 7468 6520 7369 7a65  roughly the size
-00002d00: 206f 6620 6120 4242 3b20 6e6f 7420 6e6f   of a BB; not no
-00002d10: 6973 6520 616e 6420 6e6f 7420 616e 2061  ise and not an a
-00002d20: 7274 6966 6163 742e 2055 7365 6420 746f  rtifact. Used to
-00002d30: 2066 696e 6420 7468 6520 4242 2e22 2222   find the BB."""
-00002d40: 0d0a 2020 2020 6262 5f61 7265 6120 3d20  ..    bb_area = 
-00002d50: 7265 6769 6f6e 2e61 7265 615f 6669 6c6c  region.area_fill
-00002d60: 6564 202f 2028 6b77 6172 6773 5b22 6470  ed / (kwargs["dp
-00002d70: 6d6d 225d 202a 2a20 3229 0d0a 2020 2020  mm"] ** 2)..    
-00002d80: 6262 5f73 697a 6520 3d20 6b77 6172 6773  bb_size = kwargs
-00002d90: 5b22 6262 5f73 697a 6522 5d0d 0a20 2020  ["bb_size"]..   
-00002da0: 206c 6172 6765 725f 6262 5f61 7265 6120   larger_bb_area 
-00002db0: 3d20 6e70 2e70 6920 2a20 2828 6262 5f73  = np.pi * ((bb_s
-00002dc0: 697a 6520 2b20 3229 202f 2032 2920 2a2a  ize + 2) / 2) **
-00002dd0: 2032 0d0a 2020 2020 736d 616c 6c65 725f   2..    smaller_
-00002de0: 6262 5f61 7265 6120 3d20 6d61 7828 0d0a  bb_area = max(..
-00002df0: 2020 2020 2020 2020 286e 702e 7069 202a          (np.pi *
-00002e00: 2028 2862 625f 7369 7a65 202d 2032 2920   ((bb_size - 2) 
-00002e10: 2f20 3229 202a 2a20 322c 2032 290d 0a20  / 2) ** 2, 2).. 
-00002e20: 2020 2029 2020 2320 7365 7420 6120 6d69     )  # set a mi
-00002e30: 6e20 6f66 2032 2074 6f20 6176 6f69 6420  n of 2 to avoid 
-00002e40: 6120 6c6f 7765 7220 626f 756e 6420 6f66  a lower bound of
-00002e50: 2030 2077 6865 6e20 7261 6469 7573 3d32   0 when radius=2
-00002e60: 2e20 5468 6973 2069 7320 6d75 6368 206d  . This is much m
-00002e70: 6f72 6520 6c69 6b65 6c79 2074 6f20 6669  ore likely to fi
-00002e80: 6e64 206e 6f69 7365 2069 6e20 6120 626c  nd noise in a bl
-00002e90: 6f63 6b2e 0d0a 2020 2020 7265 7475 726e  ock...    return
-00002ea0: 2073 6d61 6c6c 6572 5f62 625f 6172 6561   smaller_bb_area
-00002eb0: 203c 2062 625f 6172 6561 203c 206c 6172   < bb_area < lar
-00002ec0: 6765 725f 6262 5f61 7265 610d 0a0d 0a0d  ger_bb_area.....
-00002ed0: 0a64 6566 2069 735f 7371 7561 7265 2872  .def is_square(r
-00002ee0: 6567 696f 6e3a 2052 6567 696f 6e50 726f  egion: RegionPro
-00002ef0: 7065 7274 6965 732c 202a 6172 6773 2c20  perties, *args, 
-00002f00: 2a2a 6b77 6172 6773 2920 2d3e 2062 6f6f  **kwargs) -> boo
-00002f10: 6c3a 0d0a 2020 2020 2222 2244 6563 6964  l:..    """Decid
-00002f20: 6520 6966 2074 6865 2052 4f49 2069 7320  e if the ROI is 
-00002f30: 7371 7561 7265 2069 6e20 6e61 7475 7265  square in nature
-00002f40: 2062 7920 7465 7374 696e 6720 7468 6520   by testing the 
-00002f50: 6669 6c6c 6564 2061 7265 6120 7673 2062  filled area vs b
-00002f60: 6f75 6e64 696e 6720 626f 782e 2055 7365  ounding box. Use
-00002f70: 6420 746f 2066 696e 6420 7468 6520 4242  d to find the BB
-00002f80: 2e22 2222 0d0a 2020 2020 6163 7475 616c  ."""..    actual
-00002f90: 5f66 696c 6c5f 7261 7469 6f20 3d20 7265  _fill_ratio = re
-00002fa0: 6769 6f6e 2e66 696c 6c65 645f 6172 6561  gion.filled_area
-00002fb0: 202f 2072 6567 696f 6e2e 6262 6f78 5f61   / region.bbox_a
-00002fc0: 7265 610d 0a20 2020 2072 6574 7572 6e20  rea..    return 
-00002fd0: 6163 7475 616c 5f66 696c 6c5f 7261 7469  actual_fill_rati
-00002fe0: 6f20 3e20 302e 380d 0a0d 0a0d 0a64 6566  o > 0.8......def
-00002ff0: 2069 735f 7269 6768 745f 7371 7561 7265   is_right_square
-00003000: 5f73 697a 6528 7265 6769 6f6e 3a20 5265  _size(region: Re
-00003010: 6769 6f6e 5072 6f70 6572 7469 6573 2c20  gionProperties, 
-00003020: 2a61 7267 732c 202a 2a6b 7761 7267 7329  *args, **kwargs)
-00003030: 202d 3e20 626f 6f6c 3a0d 0a20 2020 2022   -> bool:..    "
-00003040: 2222 4465 6369 6465 2069 6620 7468 6520  ""Decide if the 
-00003050: 524f 4920 6973 2073 7175 6172 6520 696e  ROI is square in
-00003060: 206e 6174 7572 6520 6279 2074 6573 7469   nature by testi
-00003070: 6e67 2074 6865 2066 696c 6c65 6420 6172  ng the filled ar
-00003080: 6561 2076 7320 626f 756e 6469 6e67 2062  ea vs bounding b
-00003090: 6f78 2e20 5573 6564 2074 6f20 6669 6e64  ox. Used to find
-000030a0: 2074 6865 2042 422e 2222 220d 0a20 2020   the BB."""..   
-000030b0: 2066 6965 6c64 5f61 7265 6120 3d20 7265   field_area = re
-000030c0: 6769 6f6e 2e61 7265 615f 6669 6c6c 6564  gion.area_filled
-000030d0: 202f 2028 6b77 6172 6773 5b22 6470 6d6d   / (kwargs["dpmm
-000030e0: 225d 202a 2a20 3229 0d0a 2020 2020 7261  "] ** 2)..    ra
-000030f0: 645f 7369 7a65 203d 206d 6178 2828 6b77  d_size = max((kw
-00003100: 6172 6773 5b22 7261 645f 7369 7a65 225d  args["rad_size"]
-00003110: 2c20 3529 290d 0a20 2020 206c 6172 6765  , 5))..    large
-00003120: 725f 6262 5f61 7265 6120 3d20 2872 6164  r_bb_area = (rad
-00003130: 5f73 697a 6520 2b20 3529 202a 2a20 320d  _size + 5) ** 2.
-00003140: 0a20 2020 2073 6d61 6c6c 6572 5f62 625f  .    smaller_bb_
-00003150: 6172 6561 203d 2028 7261 645f 7369 7a65  area = (rad_size
-00003160: 202d 2035 2920 2a2a 2032 0d0a 2020 2020   - 5) ** 2..    
-00003170: 7265 7475 726e 2073 6d61 6c6c 6572 5f62  return smaller_b
-00003180: 625f 6172 6561 203c 2066 6965 6c64 5f61  b_area < field_a
-00003190: 7265 6120 3c20 6c61 7267 6572 5f62 625f  rea < larger_bb_
-000031a0: 6172 6561 0d0a 0d0a 0d0a 636c 6173 7320  area......class 
-000031b0: 5769 6e73 746f 6e4c 7574 7a32 4428 696d  WinstonLutz2D(im
-000031c0: 6167 652e 4c69 6e61 6344 6963 6f6d 496d  age.LinacDicomIm
-000031d0: 6167 6529 3a0d 0a20 2020 2022 2222 486f  age):..    """Ho
-000031e0: 6c64 7320 696e 6469 7669 6475 616c 2057  lds individual W
-000031f0: 696e 7374 6f6e 2d4c 7574 7a20 4550 4944  inston-Lutz EPID
-00003200: 2069 6d61 6765 732c 2069 6d61 6765 2070   images, image p
-00003210: 726f 7065 7274 6965 732c 2061 6e64 2061  roperties, and a
-00003220: 7574 6f6d 6174 6963 616c 6c79 2066 696e  utomatically fin
-00003230: 6473 2074 6865 2066 6965 6c64 2043 4158  ds the field CAX
-00003240: 2061 6e64 2042 422e 2222 220d 0a0d 0a20   and BB.""".... 
-00003250: 2020 2062 623a 2050 6f69 6e74 0d0a 2020     bb: Point..  
-00003260: 2020 6669 656c 645f 6361 783a 2050 6f69    field_cax: Poi
-00003270: 6e74 0d0a 2020 2020 5f72 6164 5f66 6965  nt..    _rad_fie
-00003280: 6c64 5f62 6f75 6e64 696e 675f 626f 783a  ld_bounding_box:
-00003290: 206c 6973 740d 0a20 2020 2069 735f 6672   list..    is_fr
-000032a0: 6f6d 5f74 6966 663a 2062 6f6f 6c20 3d20  om_tiff: bool = 
-000032b0: 4661 6c73 650d 0a20 2020 2064 6574 6563  False..    detec
-000032c0: 7469 6f6e 5f63 6f6e 6469 7469 6f6e 733a  tion_conditions:
-000032d0: 206c 6973 745b 6361 6c6c 6162 6c65 5d20   list[callable] 
-000032e0: 3d20 5b0d 0a20 2020 2020 2020 2069 735f  = [..        is_
-000032f0: 7269 6768 745f 7369 7a65 5f62 622c 0d0a  right_size_bb,..
-00003300: 2020 2020 2020 2020 6973 5f72 6f75 6e64          is_round
-00003310: 2c0d 0a20 2020 2020 2020 2069 735f 7269  ,..        is_ri
-00003320: 6768 745f 6369 7263 756d 6665 7265 6e63  ght_circumferenc
-00003330: 652c 0d0a 2020 2020 2020 2020 6973 5f73  e,..        is_s
-00003340: 796d 6d65 7472 6963 2c0d 0a20 2020 2020  ymmetric,..     
-00003350: 2020 2069 735f 736f 6c69 642c 0d0a 2020     is_solid,..  
-00003360: 2020 5d0d 0a0d 0a20 2020 2064 6566 205f    ]....    def _
-00003370: 5f69 6e69 745f 5f28 0d0a 2020 2020 2020  _init__(..      
-00003380: 2020 7365 6c66 2c0d 0a20 2020 2020 2020    self,..       
-00003390: 2066 696c 653a 2073 7472 207c 2042 696e   file: str | Bin
-000033a0: 6172 7949 4f20 7c20 5061 7468 2c0d 0a20  aryIO | Path,.. 
-000033b0: 2020 2020 2020 2075 7365 5f66 696c 656e         use_filen
-000033c0: 616d 6573 3a20 626f 6f6c 203d 2046 616c  ames: bool = Fal
-000033d0: 7365 2c0d 0a20 2020 2020 2020 202a 2a6b  se,..        **k
-000033e0: 7761 7267 732c 0d0a 2020 2020 293a 0d0a  wargs,..    ):..
-000033f0: 2020 2020 2020 2020 2222 220d 0a20 2020          """..   
-00003400: 2020 2020 2050 6172 616d 6574 6572 730d       Parameters.
-00003410: 0a20 2020 2020 2020 202d 2d2d 2d2d 2d2d  .        -------
-00003420: 2d2d 2d0d 0a20 2020 2020 2020 2066 696c  ---..        fil
-00003430: 6520 3a20 7374 720d 0a20 2020 2020 2020  e : str..       
-00003440: 2020 2020 2050 6174 6820 746f 2074 6865       Path to the
-00003450: 2069 6d61 6765 2066 696c 652e 0d0a 2020   image file...  
-00003460: 2020 2020 2020 7573 655f 6669 6c65 6e61        use_filena
-00003470: 6d65 733a 2062 6f6f 6c0d 0a20 2020 2020  mes: bool..     
-00003480: 2020 2020 2020 2057 6865 7468 6572 2074         Whether t
-00003490: 6f20 7472 7920 746f 2075 7365 2074 6865  o try to use the
-000034a0: 2066 696c 6520 6e61 6d65 2074 6f20 6465   file name to de
-000034b0: 7465 726d 696e 6520 6178 6973 2076 616c  termine axis val
-000034c0: 7565 732e 0d0a 2020 2020 2020 2020 2020  ues...          
-000034d0: 2020 5573 6566 756c 2066 6f72 2045 6c65    Useful for Ele
-000034e0: 6b74 6120 6d61 6368 696e 6573 2074 6861  kta machines tha
-000034f0: 7420 646f 206e 6f74 2069 6e63 6c75 6465  t do not include
-00003500: 2074 6861 7420 696e 666f 2069 6e20 7468   that info in th
-00003510: 6520 4449 434f 4d20 6461 7461 2e0d 0a20  e DICOM data... 
-00003520: 2020 2020 2020 2022 2222 0d0a 2020 2020         """..    
-00003530: 2020 2020 6966 2063 6f6e 6469 7469 6f6e      if condition
-00003540: 7320 3a3d 206b 7761 7267 732e 706f 7028  s := kwargs.pop(
-00003550: 2264 6574 6563 7469 6f6e 5f63 6f6e 6469  "detection_condi
-00003560: 7469 6f6e 7322 2c20 4661 6c73 6529 3a0d  tions", False):.
-00003570: 0a20 2020 2020 2020 2020 2020 2073 656c  .            sel
-00003580: 662e 6465 7465 6374 696f 6e5f 636f 6e64  f.detection_cond
-00003590: 6974 696f 6e73 203d 2063 6f6e 6469 7469  itions = conditi
-000035a0: 6f6e 730d 0a20 2020 2020 2020 2073 7570  ons..        sup
-000035b0: 6572 2829 2e5f 5f69 6e69 745f 5f28 6669  er().__init__(fi
-000035c0: 6c65 2c20 7573 655f 6669 6c65 6e61 6d65  le, use_filename
-000035d0: 733d 7573 655f 6669 6c65 6e61 6d65 732c  s=use_filenames,
-000035e0: 202a 2a6b 7761 7267 7329 0d0a 2020 2020   **kwargs)..    
-000035f0: 2020 2020 2320 6f76 6572 7269 6465 2064      # override d
-00003600: 6574 6563 7469 6f6e 2063 6f6e 6469 7469  etection conditi
-00003610: 6f6e 7320 6966 2070 6173 7365 640d 0a20  ons if passed.. 
-00003620: 2020 2020 2020 2073 656c 662e 5f69 735f         self._is_
-00003630: 616e 616c 797a 6564 203d 2046 616c 7365  analyzed = False
-00003640: 0d0a 2020 2020 2020 2020 7365 6c66 2e63  ..        self.c
-00003650: 6865 636b 5f69 6e76 6572 7369 6f6e 5f62  heck_inversion_b
-00003660: 795f 6869 7374 6f67 7261 6d28 7065 7263  y_histogram(perc
-00003670: 656e 7469 6c65 733d 2830 2e30 312c 2035  entiles=(0.01, 5
-00003680: 302c 2039 392e 3939 2929 0d0a 2020 2020  0, 99.99))..    
-00003690: 2020 2020 7365 6c66 2e66 6c69 7075 6428      self.flipud(
-000036a0: 290d 0a20 2020 2020 2020 2073 656c 662e  )..        self.
-000036b0: 5f63 6c65 616e 5f65 6467 6573 2829 0d0a  _clean_edges()..
-000036c0: 2020 2020 2020 2020 7365 6c66 2e67 726f          self.gro
-000036d0: 756e 6428 290d 0a20 2020 2020 2020 2073  und()..        s
-000036e0: 656c 662e 6e6f 726d 616c 697a 6528 290d  elf.normalize().
-000036f0: 0a0d 0a20 2020 2064 6566 2061 6e61 6c79  ...    def analy
-00003700: 7a65 280d 0a20 2020 2020 2020 2073 656c  ze(..        sel
-00003710: 662c 0d0a 2020 2020 2020 2020 6262 5f73  f,..        bb_s
-00003720: 697a 655f 6d6d 3a20 666c 6f61 7420 3d20  ize_mm: float = 
-00003730: 352c 0d0a 2020 2020 2020 2020 6c6f 775f  5,..        low_
-00003740: 6465 6e73 6974 795f 6262 3a20 626f 6f6c  density_bb: bool
-00003750: 203d 2046 616c 7365 2c0d 0a20 2020 2020   = False,..     
-00003760: 2020 206f 7065 6e5f 6669 656c 643a 2062     open_field: b
-00003770: 6f6f 6c20 3d20 4661 6c73 652c 0d0a 2020  ool = False,..  
-00003780: 2020 2920 2d3e 204e 6f6e 653a 0d0a 2020    ) -> None:..  
-00003790: 2020 2020 2020 2222 2241 6e61 6c79 7a65        """Analyze
-000037a0: 2074 6865 2069 6d61 6765 2e20 5365 6520   the image. See 
-000037b0: 5769 6e73 746f 6e4c 7574 7a2e 616e 616c  WinstonLutz.anal
-000037c0: 797a 6520 666f 7220 7061 7261 6d65 7465  yze for paramete
-000037d0: 7220 6465 7461 696c 732e 2222 220d 0a20  r details.""".. 
-000037e0: 2020 2020 2020 2073 656c 662e 6669 656c         self.fiel
-000037f0: 645f 6361 782c 2073 656c 662e 5f72 6164  d_cax, self._rad
-00003800: 5f66 6965 6c64 5f62 6f75 6e64 696e 675f  _field_bounding_
-00003810: 626f 7820 3d20 7365 6c66 2e5f 6669 6e64  box = self._find
-00003820: 5f66 6965 6c64 5f63 656e 7472 6f69 6428  _field_centroid(
-00003830: 0d0a 2020 2020 2020 2020 2020 2020 6f70  ..            op
-00003840: 656e 5f66 6965 6c64 0d0a 2020 2020 2020  en_field..      
-00003850: 2020 290d 0a20 2020 2020 2020 2073 656c    )..        sel
-00003860: 662e 6262 203d 2073 656c 662e 5f66 696e  f.bb = self._fin
-00003870: 645f 6262 2862 625f 7369 7a65 5f6d 6d2c  d_bb(bb_size_mm,
-00003880: 206c 6f77 5f64 656e 7369 7479 5f62 6229   low_density_bb)
-00003890: 0d0a 2020 2020 2020 2020 7365 6c66 2e5f  ..        self._
-000038a0: 6973 5f61 6e61 6c79 7a65 6420 3d20 5472  is_analyzed = Tr
-000038b0: 7565 0d0a 0d0a 2020 2020 6465 6620 5f5f  ue....    def __
-000038c0: 7265 7072 5f5f 2873 656c 6629 3a0d 0a20  repr__(self):.. 
-000038d0: 2020 2020 2020 2072 6574 7572 6e20 6622         return f"
-000038e0: 574c 496d 6167 6528 6761 6e74 7279 3d7b  WLImage(gantry={
-000038f0: 7365 6c66 2e67 616e 7472 795f 616e 676c  self.gantry_angl
-00003900: 653a 2e31 667d 2c20 636f 6c6c 3d7b 7365  e:.1f}, coll={se
-00003910: 6c66 2e63 6f6c 6c69 6d61 746f 725f 616e  lf.collimator_an
-00003920: 676c 653a 2e31 667d 2c20 636f 7563 683d  gle:.1f}, couch=
-00003930: 7b73 656c 662e 636f 7563 685f 616e 676c  {self.couch_angl
-00003940: 653a 2e31 667d 2922 0d0a 0d0a 2020 2020  e:.1f})"....    
-00003950: 6465 6620 746f 5f61 7865 7328 7365 6c66  def to_axes(self
-00003960: 2920 2d3e 2073 7472 3a0d 0a20 2020 2020  ) -> str:..     
-00003970: 2020 2022 2222 4769 7665 206a 7573 7420     """Give just 
-00003980: 7468 6520 6178 6573 2076 616c 7565 7320  the axes values 
-00003990: 6173 2061 2068 756d 616e 2d72 6561 6461  as a human-reada
-000039a0: 626c 6520 7374 7269 6e67 2222 220d 0a20  ble string""".. 
-000039b0: 2020 2020 2020 2072 6574 7572 6e20 6622         return f"
-000039c0: 4761 6e74 7279 3d7b 7365 6c66 2e67 616e  Gantry={self.gan
-000039d0: 7472 795f 616e 676c 653a 2e31 667d 2c20  try_angle:.1f}, 
-000039e0: 436f 6c6c 3d7b 7365 6c66 2e63 6f6c 6c69  Coll={self.colli
-000039f0: 6d61 746f 725f 616e 676c 653a 2e31 667d  mator_angle:.1f}
-00003a00: 2c20 436f 7563 683d 7b73 656c 662e 636f  , Couch={self.co
-00003a10: 7563 685f 616e 676c 653a 2e31 667d 220d  uch_angle:.1f}".
-00003a20: 0a0d 0a20 2020 2064 6566 205f 636c 6561  ...    def _clea
-00003a30: 6e5f 6564 6765 7328 7365 6c66 2c20 7769  n_edges(self, wi
-00003a40: 6e64 6f77 5f73 697a 653a 2069 6e74 203d  ndow_size: int =
-00003a50: 2032 2920 2d3e 204e 6f6e 653a 0d0a 2020   2) -> None:..  
-00003a60: 2020 2020 2020 2222 2243 6c65 616e 2074        """Clean t
-00003a70: 6865 2065 6467 6573 206f 6620 7468 6520  he edges of the 
-00003a80: 696d 6167 6520 746f 2062 6520 6e65 6172  image to be near
-00003a90: 2074 6865 2062 6163 6b67 726f 756e 6420   the background 
-00003aa0: 6c65 7665 6c2e 2222 220d 0a0d 0a20 2020  level."""....   
-00003ab0: 2020 2020 2064 6566 2068 6173 5f6e 6f69       def has_noi
-00003ac0: 7365 2873 656c 662c 2077 696e 646f 775f  se(self, window_
-00003ad0: 7369 7a65 293a 0d0a 2020 2020 2020 2020  size):..        
-00003ae0: 2020 2020 2222 2248 656c 7065 7220 6d65      """Helper me
-00003af0: 7468 6f64 2074 6f20 6465 7465 726d 696e  thod to determin
-00003b00: 6520 6966 2074 6865 7265 2069 7320 7370  e if there is sp
-00003b10: 7572 696f 7573 2073 6967 6e61 6c20 6174  urious signal at
-00003b20: 2061 6e79 206f 6620 7468 6520 696d 6167   any of the imag
-00003b30: 6520 6564 6765 732e 0d0a 0d0a 2020 2020  e edges.....    
-00003b40: 2020 2020 2020 2020 4465 7465 726d 696e          Determin
-00003b50: 6573 2069 6620 7468 6520 6d69 6e20 6f72  es if the min or
-00003b60: 206d 6178 206f 6620 616e 2065 6467 6520   max of an edge 
-00003b70: 6973 2077 6974 6869 6e20 3130 2520 6f66  is within 10% of
-00003b80: 2074 6865 2062 6173 656c 696e 6520 7661   the baseline va
-00003b90: 6c75 6520 616e 6420 7472 696d 7320 6966  lue and trims if
-00003ba0: 206e 6f74 2e0d 0a20 2020 2020 2020 2020   not...         
-00003bb0: 2020 2022 2222 0d0a 2020 2020 2020 2020     """..        
-00003bc0: 2020 2020 6e65 6172 5f6d 696e 2c20 6e65      near_min, ne
-00003bd0: 6172 5f6d 6178 203d 206e 702e 7065 7263  ar_max = np.perc
-00003be0: 656e 7469 6c65 2873 656c 662e 6172 7261  entile(self.arra
-00003bf0: 792c 205b 352c 2039 392e 355d 290d 0a20  y, [5, 99.5]).. 
-00003c00: 2020 2020 2020 2020 2020 2069 6d67 5f72             img_r
-00003c10: 616e 6765 203d 206e 6561 725f 6d61 7820  ange = near_max 
-00003c20: 2d20 6e65 6172 5f6d 696e 0d0a 2020 2020  - near_min..    
-00003c30: 2020 2020 2020 2020 746f 7020 3d20 7365          top = se
-00003c40: 6c66 5b3a 7769 6e64 6f77 5f73 697a 652c  lf[:window_size,
-00003c50: 203a 5d0d 0a20 2020 2020 2020 2020 2020   :]..           
-00003c60: 206c 6566 7420 3d20 7365 6c66 5b3a 2c20   left = self[:, 
-00003c70: 3a77 696e 646f 775f 7369 7a65 5d0d 0a20  :window_size].. 
-00003c80: 2020 2020 2020 2020 2020 2062 6f74 746f             botto
-00003c90: 6d20 3d20 7365 6c66 5b2d 7769 6e64 6f77  m = self[-window
-00003ca0: 5f73 697a 653a 2c20 3a5d 0d0a 2020 2020  _size:, :]..    
-00003cb0: 2020 2020 2020 2020 7269 6768 7420 3d20          right = 
-00003cc0: 7365 6c66 5b3a 2c20 2d77 696e 646f 775f  self[:, -window_
-00003cd0: 7369 7a65 3a5d 0d0a 2020 2020 2020 2020  size:]..        
-00003ce0: 2020 2020 6564 6765 5f61 7272 6179 203d      edge_array =
-00003cf0: 206e 702e 636f 6e63 6174 656e 6174 6528   np.concatenate(
-00003d00: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-00003d10: 2020 2874 6f70 2e66 6c61 7474 656e 2829    (top.flatten()
-00003d20: 2c20 6c65 6674 2e66 6c61 7474 656e 2829  , left.flatten()
-00003d30: 2c20 626f 7474 6f6d 2e66 6c61 7474 656e  , bottom.flatten
-00003d40: 2829 2c20 7269 6768 742e 666c 6174 7465  (), right.flatte
-00003d50: 6e28 2929 0d0a 2020 2020 2020 2020 2020  n())..          
-00003d60: 2020 290d 0a20 2020 2020 2020 2020 2020    )..           
-00003d70: 2065 6467 655f 746f 6f5f 6c6f 7720 3d20   edge_too_low = 
-00003d80: 6564 6765 5f61 7272 6179 2e6d 696e 2829  edge_array.min()
-00003d90: 203c 2028 6e65 6172 5f6d 696e 202d 2069   < (near_min - i
-00003da0: 6d67 5f72 616e 6765 202f 2031 3029 0d0a  mg_range / 10)..
-00003db0: 2020 2020 2020 2020 2020 2020 6564 6765              edge
-00003dc0: 5f74 6f6f 5f68 6967 6820 3d20 6564 6765  _too_high = edge
-00003dd0: 5f61 7272 6179 2e6d 6178 2829 203e 2028  _array.max() > (
-00003de0: 6e65 6172 5f6d 6178 202b 2069 6d67 5f72  near_max + img_r
-00003df0: 616e 6765 202f 2031 3029 0d0a 2020 2020  ange / 10)..    
-00003e00: 2020 2020 2020 2020 7265 7475 726e 2065          return e
-00003e10: 6467 655f 746f 6f5f 6c6f 7720 6f72 2065  dge_too_low or e
-00003e20: 6467 655f 746f 6f5f 6869 6768 0d0a 0d0a  dge_too_high....
-00003e30: 2020 2020 2020 2020 7361 6665 7479 5f73          safety_s
-00003e40: 746f 7020 3d20 6e70 2e6d 696e 2873 656c  top = np.min(sel
-00003e50: 662e 7368 6170 6529 202f 2031 300d 0a20  f.shape) / 10.. 
-00003e60: 2020 2020 2020 2077 6869 6c65 2068 6173         while has
-00003e70: 5f6e 6f69 7365 2873 656c 662c 2077 696e  _noise(self, win
-00003e80: 646f 775f 7369 7a65 2920 616e 6420 7361  dow_size) and sa
-00003e90: 6665 7479 5f73 746f 7020 3e20 303a 0d0a  fety_stop > 0:..
-00003ea0: 2020 2020 2020 2020 2020 2020 7365 6c66              self
-00003eb0: 2e63 726f 7028 7769 6e64 6f77 5f73 697a  .crop(window_siz
-00003ec0: 6529 0d0a 2020 2020 2020 2020 2020 2020  e)..            
-00003ed0: 7361 6665 7479 5f73 746f 7020 2d3d 2031  safety_stop -= 1
-00003ee0: 0d0a 0d0a 2020 2020 6465 6620 5f66 696e  ....    def _fin
-00003ef0: 645f 6669 656c 645f 6365 6e74 726f 6964  d_field_centroid
-00003f00: 2873 656c 662c 2069 735f 6f70 656e 5f66  (self, is_open_f
-00003f10: 6965 6c64 3a20 626f 6f6c 2920 2d3e 2074  ield: bool) -> t
-00003f20: 7570 6c65 5b50 6f69 6e74 2c20 6c69 7374  uple[Point, list
-00003f30: 5d3a 0d0a 2020 2020 2020 2020 2222 2246  ]:..        """F
-00003f40: 696e 6420 7468 6520 6365 6e74 726f 6964  ind the centroid
-00003f50: 206f 6620 7468 6520 7261 6469 6174 696f   of the radiatio
-00003f60: 6e20 6669 656c 642e 0d0a 0d0a 2020 2020  n field.....    
-00003f70: 2020 2020 5061 7261 6d65 7465 7273 0d0a      Parameters..
-00003f80: 2020 2020 2020 2020 2d2d 2d2d 2d2d 2d2d          --------
-00003f90: 2d2d 0d0a 2020 2020 2020 2020 6973 5f6f  --..        is_o
-00003fa0: 7065 6e5f 6669 656c 640d 0a20 2020 2020  pen_field..     
-00003fb0: 2020 2020 2020 2049 6620 5472 7565 2c20         If True, 
-00003fc0: 7369 6d70 6c79 2075 7365 7320 7468 6520  simply uses the 
-00003fd0: 696d 6167 652f 4550 4944 2063 656e 7465  image/EPID cente
-00003fe0: 7220 6173 2074 6865 2066 6965 6c64 2063  r as the field c
-00003ff0: 656e 7465 722e 0d0a 2020 2020 2020 2020  enter...        
-00004000: 2020 2020 4966 2046 616c 7365 2c20 6669      If False, fi
-00004010: 6e64 7320 7468 6520 7261 6469 6174 696f  nds the radiatio
-00004020: 6e20 6669 656c 6420 6261 7365 6420 6f6e  n field based on
-00004030: 2061 2035 3025 2068 6569 6768 7420 7468   a 50% height th
-00004040: 7265 7368 6f6c 642e 0d0a 0d0a 2020 2020  reshold.....    
-00004050: 2020 2020 5265 7475 726e 730d 0a20 2020      Returns..   
-00004060: 2020 2020 202d 2d2d 2d2d 2d2d 0d0a 2020       -------..  
-00004070: 2020 2020 2020 700d 0a20 2020 2020 2020        p..       
-00004080: 2020 2020 2054 6865 2043 4158 2070 6f69       The CAX poi
-00004090: 6e74 206c 6f63 6174 696f 6e2e 0d0a 2020  nt location...  
-000040a0: 2020 2020 2020 6564 6765 730d 0a20 2020        edges..   
-000040b0: 2020 2020 2020 2020 2054 6865 2062 6f75           The bou
-000040c0: 6e64 696e 6720 626f 7820 6f66 2074 6865  nding box of the
-000040d0: 2066 6965 6c64 2c20 706c 7573 2061 2073   field, plus a s
-000040e0: 6d61 6c6c 206d 6172 6769 6e2e 0d0a 2020  mall margin...  
-000040f0: 2020 2020 2020 2222 220d 0a20 2020 2020        """..     
-00004100: 2020 2069 6620 6973 5f6f 7065 6e5f 6669     if is_open_fi
-00004110: 656c 643a 0d0a 2020 2020 2020 2020 2020  eld:..          
-00004120: 2020 7020 3d20 7365 6c66 2e63 656e 7465    p = self.cente
-00004130: 720d 0a20 2020 2020 2020 2020 2020 2065  r..            e
-00004140: 6467 6573 203d 205b 302c 2073 656c 662e  dges = [0, self.
-00004150: 7368 6170 655b 305d 2c20 302c 2073 656c  shape[0], 0, sel
-00004160: 662e 7368 6170 655b 315d 5d0d 0a20 2020  f.shape[1]]..   
-00004170: 2020 2020 2065 6c73 653a 0d0a 2020 2020       else:..    
-00004180: 2020 2020 2020 2020 6d69 6e2c 206d 6178          min, max
-00004190: 203d 206e 702e 7065 7263 656e 7469 6c65   = np.percentile
-000041a0: 2873 656c 662e 6172 7261 792c 205b 352c  (self.array, [5,
-000041b0: 2039 392e 395d 290d 0a20 2020 2020 2020   99.9])..       
-000041c0: 2020 2020 2074 6872 6573 686f 6c64 5f69       threshold_i
-000041d0: 6d67 203d 2073 656c 662e 6173 5f62 696e  mg = self.as_bin
-000041e0: 6172 7928 286d 6178 202d 206d 696e 2920  ary((max - min) 
-000041f0: 2f20 3220 2b20 6d69 6e29 0d0a 2020 2020  / 2 + min)..    
-00004200: 2020 2020 2020 2020 6669 6c6c 6564 5f69          filled_i
-00004210: 6d67 203d 206e 6469 6d61 6765 2e62 696e  mg = ndimage.bin
-00004220: 6172 795f 6669 6c6c 5f68 6f6c 6573 2874  ary_fill_holes(t
-00004230: 6872 6573 686f 6c64 5f69 6d67 290d 0a20  hreshold_img).. 
-00004240: 2020 2020 2020 2020 2020 2023 2063 6c65             # cle
-00004250: 616e 2073 696e 676c 652d 7069 7865 6c20  an single-pixel 
-00004260: 6e6f 6973 6520 6672 6f6d 206f 7574 7369  noise from outsi
-00004270: 6465 2066 6965 6c64 0d0a 2020 2020 2020  de field..      
-00004280: 2020 2020 2020 636c 6561 6e65 645f 696d        cleaned_im
-00004290: 6720 3d20 6e64 696d 6167 652e 6269 6e61  g = ndimage.bina
-000042a0: 7279 5f65 726f 7369 6f6e 2874 6872 6573  ry_erosion(thres
-000042b0: 686f 6c64 5f69 6d67 290d 0a20 2020 2020  hold_img)..     
-000042c0: 2020 2020 2020 205b 2a65 6467 6573 5d20         [*edges] 
-000042d0: 3d20 626f 756e 6469 6e67 5f62 6f78 2863  = bounding_box(c
-000042e0: 6c65 616e 6564 5f69 6d67 290d 0a20 2020  leaned_img)..   
-000042f0: 2020 2020 2020 2020 2065 6467 6573 5b30           edges[0
-00004300: 5d20 2d3d 2031 300d 0a20 2020 2020 2020  ] -= 10..       
-00004310: 2020 2020 2065 6467 6573 5b31 5d20 2b3d       edges[1] +=
-00004320: 2031 300d 0a20 2020 2020 2020 2020 2020   10..           
-00004330: 2065 6467 6573 5b32 5d20 2d3d 2031 300d   edges[2] -= 10.
-00004340: 0a20 2020 2020 2020 2020 2020 2065 6467  .            edg
-00004350: 6573 5b33 5d20 2b3d 2031 300d 0a20 2020  es[3] += 10..   
-00004360: 2020 2020 2020 2020 2063 6f6f 7264 7320           coords 
-00004370: 3d20 6e64 696d 6167 652e 6365 6e74 6572  = ndimage.center
-00004380: 5f6f 665f 6d61 7373 2866 696c 6c65 645f  _of_mass(filled_
-00004390: 696d 6729 0d0a 2020 2020 2020 2020 2020  img)..          
-000043a0: 2020 7020 3d20 506f 696e 7428 783d 636f    p = Point(x=co
-000043b0: 6f72 6473 5b2d 315d 2c20 793d 636f 6f72  ords[-1], y=coor
-000043c0: 6473 5b30 5d29 0d0a 2020 2020 2020 2020  ds[0])..        
-000043d0: 7265 7475 726e 2070 2c20 6564 6765 730d  return p, edges.
-000043e0: 0a0d 0a20 2020 2064 6566 205f 6361 6c63  ...    def _calc
-000043f0: 756c 6174 655f 6262 5f74 6f6c 6572 616e  ulate_bb_toleran
-00004400: 6365 2873 656c 662c 2062 625f 6469 616d  ce(self, bb_diam
-00004410: 6574 6572 3a20 666c 6f61 7429 202d 3e20  eter: float) -> 
-00004420: 696e 743a 0d0a 2020 2020 2020 2020 2222  int:..        ""
-00004430: 2243 616c 6375 6c61 7465 2074 6865 2042  "Calculate the B
-00004440: 4220 746f 6c65 7261 6e63 6520 6261 7365  B tolerance base
-00004450: 6420 6f6e 2074 6865 2042 4220 6469 616d  d on the BB diam
-00004460: 6574 6572 2e0d 0a20 2020 2020 2020 204d  eter...        M
-00004470: 696e 2077 696c 6c20 6265 2032 2066 6f72  in will be 2 for
-00004480: 2031 2e35 6d6d 2061 6e64 2075 6e64 6572   1.5mm and under
-00004490: 2e20 5769 6c6c 2062 6520 3420 666f 7220  . Will be 4 for 
-000044a0: 6469 616d 6574 6572 7320 6174 206f 7220  diameters at or 
-000044b0: 6162 6f76 6520 3330 6d6d 2e22 2222 0d0a  above 30mm."""..
-000044c0: 2020 2020 2020 2020 7920 3d20 2832 2c20          y = (2, 
-000044d0: 3429 0d0a 2020 2020 2020 2020 7820 3d20  4)..        x = 
-000044e0: 2831 2e35 2c20 3330 290d 0a20 2020 2020  (1.5, 30)..     
-000044f0: 2020 2072 6574 7572 6e20 6e70 2e69 6e74     return np.int
-00004500: 6572 7028 6262 5f64 6961 6d65 7465 722c  erp(bb_diameter,
-00004510: 2078 2c20 7929 0d0a 0d0a 2020 2020 6465   x, y)....    de
-00004520: 6620 5f66 696e 645f 6262 2873 656c 662c  f _find_bb(self,
-00004530: 2062 625f 6469 616d 6574 6572 3a20 666c   bb_diameter: fl
-00004540: 6f61 742c 206c 6f77 5f64 656e 7369 7479  oat, low_density
-00004550: 3a20 626f 6f6c 2920 2d3e 2050 6f69 6e74  : bool) -> Point
-00004560: 3a0d 0a20 2020 2020 2020 2022 2222 4669  :..        """Fi
-00004570: 6e64 2074 6865 2042 4220 7769 7468 696e  nd the BB within
-00004580: 2074 6865 2072 6164 6961 7469 6f6e 2066   the radiation f
-00004590: 6965 6c64 2e20 4974 6572 6174 6976 656c  ield. Iterativel
-000045a0: 7920 7365 6172 6368 6573 2066 6f72 2061  y searches for a
-000045b0: 2063 6972 636c 652d 6c69 6b65 206f 626a   circle-like obj
-000045c0: 6563 740d 0a20 2020 2020 2020 2062 7920  ect..        by 
-000045d0: 6c6f 7765 7269 6e67 2061 206c 6f77 2d70  lowering a low-p
-000045e0: 6173 7320 7468 7265 7368 6f6c 6420 7661  ass threshold va
-000045f0: 6c75 6520 756e 7469 6c20 666f 756e 642e  lue until found.
-00004600: 0d0a 0d0a 2020 2020 2020 2020 5265 7475  ....        Retu
-00004610: 726e 730d 0a20 2020 2020 2020 202d 2d2d  rns..        ---
-00004620: 2d2d 2d2d 0d0a 2020 2020 2020 2020 506f  ----..        Po
-00004630: 696e 740d 0a20 2020 2020 2020 2020 2020  int..           
-00004640: 2054 6865 2077 6569 6768 7465 642d 7069   The weighted-pi
-00004650: 7865 6c20 7661 6c75 6520 6c6f 6361 7469  xel value locati
-00004660: 6f6e 206f 6620 7468 6520 4242 2e0d 0a20  on of the BB... 
-00004670: 2020 2020 2020 2022 2222 0d0a 2020 2020         """..    
-00004680: 2020 2020 6262 5f74 6f6c 6572 616e 6365      bb_tolerance
-00004690: 5f6d 6d20 3d20 7365 6c66 2e5f 6361 6c63  _mm = self._calc
-000046a0: 756c 6174 655f 6262 5f74 6f6c 6572 616e  ulate_bb_toleran
-000046b0: 6365 2862 625f 6469 616d 6574 6572 290d  ce(bb_diameter).
-000046c0: 0a20 2020 2020 2020 2063 656e 7465 7220  .        center 
-000046d0: 3d20 7365 6c66 2e63 6f6d 7075 7465 280d  = self.compute(.
-000046e0: 0a20 2020 2020 2020 2020 2020 206d 6574  .            met
-000046f0: 7269 6373 3d53 697a 6564 4469 736b 4c6f  rics=SizedDiskLo
-00004700: 6361 746f 722e 6672 6f6d 5f63 656e 7465  cator.from_cente
-00004710: 725f 7068 7973 6963 616c 280d 0a20 2020  r_physical(..   
-00004720: 2020 2020 2020 2020 2020 2020 2065 7870               exp
-00004730: 6563 7465 645f 706f 7369 7469 6f6e 5f6d  ected_position_m
-00004740: 6d3d 2830 2c20 3029 2c0d 0a20 2020 2020  m=(0, 0),..     
-00004750: 2020 2020 2020 2020 2020 2073 6561 7263             searc
-00004760: 685f 7769 6e64 6f77 5f6d 6d3d 2834 3020  h_window_mm=(40 
-00004770: 2b20 6262 5f64 6961 6d65 7465 722c 2034  + bb_diameter, 4
-00004780: 3020 2b20 6262 5f64 6961 6d65 7465 7229  0 + bb_diameter)
-00004790: 2c0d 0a20 2020 2020 2020 2020 2020 2020  ,..             
-000047a0: 2020 2072 6164 6975 735f 6d6d 3d62 625f     radius_mm=bb_
-000047b0: 6469 616d 6574 6572 202f 2032 2c0d 0a20  diameter / 2,.. 
-000047c0: 2020 2020 2020 2020 2020 2020 2020 2072                 r
-000047d0: 6164 6975 735f 746f 6c65 7261 6e63 655f  adius_tolerance_
-000047e0: 6d6d 3d62 625f 746f 6c65 7261 6e63 655f  mm=bb_tolerance_
-000047f0: 6d6d 2c0d 0a20 2020 2020 2020 2020 2020  mm,..           
-00004800: 2020 2020 2069 6e76 6572 743d 6e6f 7420       invert=not 
-00004810: 6c6f 775f 6465 6e73 6974 792c 0d0a 2020  low_density,..  
-00004820: 2020 2020 2020 2020 2020 2020 2020 6465                de
-00004830: 7465 6374 696f 6e5f 636f 6e64 6974 696f  tection_conditio
-00004840: 6e73 3d73 656c 662e 6465 7465 6374 696f  ns=self.detectio
-00004850: 6e5f 636f 6e64 6974 696f 6e73 2c0d 0a20  n_conditions,.. 
-00004860: 2020 2020 2020 2020 2020 2029 0d0a 2020             )..  
-00004870: 2020 2020 2020 290d 0a20 2020 2020 2020        )..       
-00004880: 2072 6574 7572 6e20 6365 6e74 6572 0d0a   return center..
-00004890: 0d0a 2020 2020 4070 726f 7065 7274 790d  ..    @property.
-000048a0: 0a20 2020 2064 6566 2065 7069 6428 7365  .    def epid(se
-000048b0: 6c66 2920 2d3e 2050 6f69 6e74 3a0d 0a20  lf) -> Point:.. 
-000048c0: 2020 2020 2020 2022 2222 4365 6e74 6572         """Center
-000048d0: 206f 6620 7468 6520 4550 4944 2070 616e   of the EPID pan
-000048e0: 656c 2222 220d 0a20 2020 2020 2020 2072  el"""..        r
-000048f0: 6574 7572 6e20 7365 6c66 2e63 656e 7465  eturn self.cente
-00004900: 720d 0a0d 0a20 2020 2040 7072 6f70 6572  r....    @proper
-00004910: 7479 0d0a 2020 2020 6465 6620 6361 785f  ty..    def cax_
-00004920: 6c69 6e65 5f70 726f 6a65 6374 696f 6e28  line_projection(
-00004930: 7365 6c66 2920 2d3e 204c 696e 653a 0d0a  self) -> Line:..
-00004940: 2020 2020 2020 2020 2222 2254 6865 2070          """The p
-00004950: 726f 6a65 6374 696f 6e20 6f66 2074 6865  rojection of the
-00004960: 2066 6965 6c64 2043 4158 2074 6872 6f75   field CAX throu
-00004970: 6768 2073 7061 6365 2061 726f 756e 6420  gh space around 
-00004980: 7468 6520 6172 6561 206f 6620 7468 6520  the area of the 
-00004990: 4242 2e0d 0a20 2020 2020 2020 2055 7365  BB...        Use
-000049a0: 6420 666f 7220 6465 7465 726d 696e 696e  d for determinin
-000049b0: 6720 6761 6e74 7279 2069 736f 6365 6e74  g gantry isocent
-000049c0: 6572 2073 697a 652e 0d0a 0d0a 2020 2020  er size.....    
-000049d0: 2020 2020 5265 7475 726e 730d 0a20 2020      Returns..   
-000049e0: 2020 2020 202d 2d2d 2d2d 2d2d 0d0a 2020       -------..  
-000049f0: 2020 2020 2020 4c69 6e65 0d0a 2020 2020        Line..    
-00004a00: 2020 2020 2020 2020 5468 6520 7669 7274          The virt
-00004a10: 7561 6c20 6c69 6e65 2069 6e20 7370 6163  ual line in spac
-00004a20: 6520 6d61 6465 2062 7920 7468 6520 6265  e made by the be
-00004a30: 616d 2043 4158 2e0d 0a20 2020 2020 2020  am CAX...       
-00004a40: 2022 2222 0d0a 2020 2020 2020 2020 7031   """..        p1
-00004a50: 203d 2050 6f69 6e74 2829 0d0a 2020 2020   = Point()..    
-00004a60: 2020 2020 7032 203d 2050 6f69 6e74 2829      p2 = Point()
-00004a70: 0d0a 2020 2020 2020 2020 2320 706f 696e  ..        # poin
-00004a80: 7420 3120 2d20 7261 7920 6f72 6967 696e  t 1 - ray origin
-00004a90: 0d0a 2020 2020 2020 2020 7031 2e78 203d  ..        p1.x =
-00004aa0: 2073 656c 662e 6361 7832 6262 5f76 6563   self.cax2bb_vec
-00004ab0: 746f 722e 7820 2a20 636f 7328 7365 6c66  tor.x * cos(self
-00004ac0: 2e67 616e 7472 795f 616e 676c 6529 202b  .gantry_angle) +
-00004ad0: 2032 3020 2a20 7369 6e28 0d0a 2020 2020   20 * sin(..    
-00004ae0: 2020 2020 2020 2020 7365 6c66 2e67 616e          self.gan
-00004af0: 7472 795f 616e 676c 650d 0a20 2020 2020  try_angle..     
-00004b00: 2020 2029 0d0a 2020 2020 2020 2020 7031     )..        p1
-00004b10: 2e7a 203d 2073 656c 662e 6361 7832 6262  .z = self.cax2bb
-00004b20: 5f76 6563 746f 722e 7820 2a20 2d73 696e  _vector.x * -sin
-00004b30: 2873 656c 662e 6761 6e74 7279 5f61 6e67  (self.gantry_ang
-00004b40: 6c65 2920 2b20 3230 202a 2063 6f73 280d  le) + 20 * cos(.
-00004b50: 0a20 2020 2020 2020 2020 2020 2073 656c  .            sel
-00004b60: 662e 6761 6e74 7279 5f61 6e67 6c65 0d0a  f.gantry_angle..
-00004b70: 2020 2020 2020 2020 290d 0a20 2020 2020          )..     
-00004b80: 2020 2070 312e 7920 3d20 7365 6c66 2e63     p1.y = self.c
-00004b90: 6178 3262 625f 7665 6374 6f72 2e79 0d0a  ax2bb_vector.y..
-00004ba0: 2020 2020 2020 2020 2320 706f 696e 7420          # point 
-00004bb0: 3220 2d20 7261 7920 6465 7374 696e 6174  2 - ray destinat
-00004bc0: 696f 6e0d 0a20 2020 2020 2020 2070 322e  ion..        p2.
-00004bd0: 7820 3d20 7365 6c66 2e63 6178 3262 625f  x = self.cax2bb_
-00004be0: 7665 6374 6f72 2e78 202a 2063 6f73 2873  vector.x * cos(s
-00004bf0: 656c 662e 6761 6e74 7279 5f61 6e67 6c65  elf.gantry_angle
-00004c00: 2920 2d20 3230 202a 2073 696e 280d 0a20  ) - 20 * sin(.. 
-00004c10: 2020 2020 2020 2020 2020 2073 656c 662e             self.
-00004c20: 6761 6e74 7279 5f61 6e67 6c65 0d0a 2020  gantry_angle..  
-00004c30: 2020 2020 2020 290d 0a20 2020 2020 2020        )..       
-00004c40: 2070 322e 7a20 3d20 7365 6c66 2e63 6178   p2.z = self.cax
-00004c50: 3262 625f 7665 6374 6f72 2e78 202a 202d  2bb_vector.x * -
-00004c60: 7369 6e28 7365 6c66 2e67 616e 7472 795f  sin(self.gantry_
-00004c70: 616e 676c 6529 202d 2032 3020 2a20 636f  angle) - 20 * co
-00004c80: 7328 0d0a 2020 2020 2020 2020 2020 2020  s(..            
-00004c90: 7365 6c66 2e67 616e 7472 795f 616e 676c  self.gantry_angl
-00004ca0: 650d 0a20 2020 2020 2020 2029 0d0a 2020  e..        )..  
-00004cb0: 2020 2020 2020 7032 2e79 203d 2073 656c        p2.y = sel
-00004cc0: 662e 6361 7832 6262 5f76 6563 746f 722e  f.cax2bb_vector.
-00004cd0: 790d 0a20 2020 2020 2020 206c 696e 6520  y..        line 
-00004ce0: 3d20 4c69 6e65 2870 312c 2070 3229 0d0a  = Line(p1, p2)..
-00004cf0: 2020 2020 2020 2020 7265 7475 726e 206c          return l
-00004d00: 696e 650d 0a0d 0a20 2020 2040 7072 6f70  ine....    @prop
-00004d10: 6572 7479 0d0a 2020 2020 6465 6620 6361  erty..    def ca
-00004d20: 7832 6262 5f76 6563 746f 7228 7365 6c66  x2bb_vector(self
-00004d30: 2920 2d3e 2056 6563 746f 723a 0d0a 2020  ) -> Vector:..  
-00004d40: 2020 2020 2020 2222 2254 6865 2076 6563        """The vec
-00004d50: 746f 7220 696e 206d 6d20 6672 6f6d 2074  tor in mm from t
-00004d60: 6865 2043 4158 2074 6f20 7468 6520 4242  he CAX to the BB
-00004d70: 2e22 2222 0d0a 2020 2020 2020 2020 6469  ."""..        di
-00004d80: 7374 203d 2028 7365 6c66 2e62 6220 2d20  st = (self.bb - 
-00004d90: 7365 6c66 2e66 6965 6c64 5f63 6178 2920  self.field_cax) 
-00004da0: 2f20 7365 6c66 2e64 706d 6d0d 0a20 2020  / self.dpmm..   
-00004db0: 2020 2020 2072 6574 7572 6e20 5665 6374       return Vect
-00004dc0: 6f72 2864 6973 742e 782c 2064 6973 742e  or(dist.x, dist.
-00004dd0: 792c 2064 6973 742e 7a29 0d0a 0d0a 2020  y, dist.z)....  
-00004de0: 2020 4070 726f 7065 7274 790d 0a20 2020    @property..   
-00004df0: 2064 6566 2063 6178 3262 625f 6469 7374   def cax2bb_dist
-00004e00: 616e 6365 2873 656c 6629 202d 3e20 666c  ance(self) -> fl
-00004e10: 6f61 743a 0d0a 2020 2020 2020 2020 2222  oat:..        ""
-00004e20: 2254 6865 2073 6361 6c61 7220 6469 7374  "The scalar dist
-00004e30: 616e 6365 2069 6e20 6d6d 2066 726f 6d20  ance in mm from 
-00004e40: 7468 6520 4341 5820 746f 2074 6865 2042  the CAX to the B
-00004e50: 422e 2222 220d 0a20 2020 2020 2020 2064  B."""..        d
-00004e60: 6973 7420 3d20 7365 6c66 2e66 6965 6c64  ist = self.field
-00004e70: 5f63 6178 2e64 6973 7461 6e63 655f 746f  _cax.distance_to
-00004e80: 2873 656c 662e 6262 290d 0a20 2020 2020  (self.bb)..     
-00004e90: 2020 2072 6574 7572 6e20 6469 7374 202f     return dist /
-00004ea0: 2073 656c 662e 6470 6d6d 0d0a 0d0a 2020   self.dpmm....  
-00004eb0: 2020 4070 726f 7065 7274 790d 0a20 2020    @property..   
-00004ec0: 2064 6566 2063 6178 3265 7069 645f 7665   def cax2epid_ve
-00004ed0: 6374 6f72 2873 656c 6629 202d 3e20 5665  ctor(self) -> Ve
-00004ee0: 6374 6f72 3a0d 0a20 2020 2020 2020 2022  ctor:..        "
-00004ef0: 2222 5468 6520 7665 6374 6f72 2069 6e20  ""The vector in 
-00004f00: 6d6d 2066 726f 6d20 7468 6520 4341 5820  mm from the CAX 
-00004f10: 746f 2074 6865 2045 5049 4420 6365 6e74  to the EPID cent
-00004f20: 6572 2070 6978 656c 2222 220d 0a20 2020  er pixel"""..   
-00004f30: 2020 2020 2064 6973 7420 3d20 2873 656c       dist = (sel
-00004f40: 662e 6570 6964 202d 2073 656c 662e 6669  f.epid - self.fi
-00004f50: 656c 645f 6361 7829 202f 2073 656c 662e  eld_cax) / self.
-00004f60: 6470 6d6d 0d0a 2020 2020 2020 2020 7265  dpmm..        re
-00004f70: 7475 726e 2056 6563 746f 7228 6469 7374  turn Vector(dist
-00004f80: 2e78 2c20 6469 7374 2e79 2c20 6469 7374  .x, dist.y, dist
-00004f90: 2e7a 290d 0a0d 0a20 2020 2040 7072 6f70  .z)....    @prop
-00004fa0: 6572 7479 0d0a 2020 2020 6465 6620 6361  erty..    def ca
-00004fb0: 7832 6570 6964 5f64 6973 7461 6e63 6528  x2epid_distance(
-00004fc0: 7365 6c66 2920 2d3e 2066 6c6f 6174 3a0d  self) -> float:.
-00004fd0: 0a20 2020 2020 2020 2022 2222 5468 6520  .        """The 
-00004fe0: 7363 616c 6172 2064 6973 7461 6e63 6520  scalar distance 
-00004ff0: 696e 206d 6d20 6672 6f6d 2074 6865 2043  in mm from the C
-00005000: 4158 2074 6f20 7468 6520 4550 4944 2063  AX to the EPID c
-00005010: 656e 7465 7220 7069 7865 6c22 2222 0d0a  enter pixel"""..
-00005020: 2020 2020 2020 2020 7265 7475 726e 2073          return s
-00005030: 656c 662e 6669 656c 645f 6361 782e 6469  elf.field_cax.di
-00005040: 7374 616e 6365 5f74 6f28 7365 6c66 2e65  stance_to(self.e
-00005050: 7069 6429 202f 2073 656c 662e 6470 6d6d  pid) / self.dpmm
-00005060: 0d0a 0d0a 2020 2020 6465 6620 706c 6f74  ....    def plot
-00005070: 280d 0a20 2020 2020 2020 2073 656c 662c  (..        self,
-00005080: 2061 783a 2070 6c74 2e41 7865 7320 7c20   ax: plt.Axes | 
-00005090: 4e6f 6e65 203d 204e 6f6e 652c 2073 686f  None = None, sho
-000050a0: 773a 2062 6f6f 6c20 3d20 5472 7565 2c20  w: bool = True, 
-000050b0: 636c 6561 725f 6669 673a 2062 6f6f 6c20  clear_fig: bool 
-000050c0: 3d20 4661 6c73 650d 0a20 2020 2029 202d  = False..    ) -
-000050d0: 3e20 706c 742e 4178 6573 3a0d 0a20 2020  > plt.Axes:..   
-000050e0: 2020 2020 2022 2222 506c 6f74 2074 6865       """Plot the
-000050f0: 2069 6d61 6765 2c20 7a6f 6f6d 6564 2d69   image, zoomed-i
-00005100: 6e20 6f6e 2074 6865 2072 6164 6961 7469  n on the radiati
-00005110: 6f6e 2066 6965 6c64 2c20 616c 6f6e 6720  on field, along 
-00005120: 7769 7468 2074 6865 2064 6574 6563 7465  with the detecte
-00005130: 640d 0a20 2020 2020 2020 2042 4220 6c6f  d..        BB lo
-00005140: 6361 7469 6f6e 2061 6e64 2066 6965 6c64  cation and field
-00005150: 2043 4158 206c 6f63 6174 696f 6e2e 0d0a   CAX location...
-00005160: 0d0a 2020 2020 2020 2020 5061 7261 6d65  ..        Parame
-00005170: 7465 7273 0d0a 2020 2020 2020 2020 2d2d  ters..        --
-00005180: 2d2d 2d2d 2d2d 2d2d 0d0a 2020 2020 2020  --------..      
-00005190: 2020 6178 203a 204e 6f6e 652c 206d 6174    ax : None, mat
-000051a0: 706c 6f74 6c69 6220 4178 6573 2069 6e73  plotlib Axes ins
-000051b0: 7461 6e63 650d 0a20 2020 2020 2020 2020  tance..         
-000051c0: 2020 2054 6865 2061 7869 7320 746f 2070     The axis to p
-000051d0: 6c6f 7420 746f 2e20 4966 204e 6f6e 652c  lot to. If None,
-000051e0: 2077 696c 6c20 6372 6561 7465 2061 206e   will create a n
-000051f0: 6577 2066 6967 7572 652e 0d0a 2020 2020  ew figure...    
-00005200: 2020 2020 7368 6f77 203a 2062 6f6f 6c0d      show : bool.
-00005210: 0a20 2020 2020 2020 2020 2020 2057 6865  .            Whe
-00005220: 7468 6572 2074 6f20 6163 7475 616c 6c79  ther to actually
-00005230: 2073 686f 7720 7468 6520 696d 6167 652e   show the image.
-00005240: 0d0a 2020 2020 2020 2020 636c 6561 725f  ..        clear_
-00005250: 6669 6720 3a20 626f 6f6c 0d0a 2020 2020  fig : bool..    
-00005260: 2020 2020 2020 2020 5768 6574 6865 7220          Whether 
-00005270: 746f 2063 6c65 6172 2074 6865 2066 6967  to clear the fig
-00005280: 7572 6520 6669 7273 7420 6265 666f 7265  ure first before
-00005290: 2064 7261 7769 6e67 2e0d 0a20 2020 2020   drawing...     
-000052a0: 2020 2022 2222 0d0a 2020 2020 2020 2020     """..        
-000052b0: 6178 203d 2073 7570 6572 2829 2e70 6c6f  ax = super().plo
-000052c0: 7428 6178 3d61 782c 2073 686f 773d 4661  t(ax=ax, show=Fa
-000052d0: 6c73 652c 2063 6c65 6172 5f66 6967 3d63  lse, clear_fig=c
-000052e0: 6c65 6172 5f66 6967 290d 0a20 2020 2020  lear_fig)..     
-000052f0: 2020 2061 782e 706c 6f74 2873 656c 662e     ax.plot(self.
-00005300: 6669 656c 645f 6361 782e 782c 2073 656c  field_cax.x, sel
-00005310: 662e 6669 656c 645f 6361 782e 792c 2022  f.field_cax.y, "
-00005320: 6773 222c 206d 733d 3829 0d0a 2020 2020  gs", ms=8)..    
-00005330: 2020 2020 6178 2e61 7876 6c69 6e65 2878      ax.axvline(x
-00005340: 3d73 656c 662e 6570 6964 2e78 2c20 636f  =self.epid.x, co
-00005350: 6c6f 723d 2262 2229 0d0a 2020 2020 2020  lor="b")..      
-00005360: 2020 6178 2e61 7868 6c69 6e65 2879 3d73    ax.axhline(y=s
-00005370: 656c 662e 6570 6964 2e79 2c20 636f 6c6f  elf.epid.y, colo
-00005380: 723d 2262 2229 0d0a 2020 2020 2020 2020  r="b")..        
-00005390: 6178 2e73 6574 5f79 6c69 6d28 5b73 656c  ax.set_ylim([sel
-000053a0: 662e 5f72 6164 5f66 6965 6c64 5f62 6f75  f._rad_field_bou
-000053b0: 6e64 696e 675f 626f 785b 305d 2c20 7365  nding_box[0], se
-000053c0: 6c66 2e5f 7261 645f 6669 656c 645f 626f  lf._rad_field_bo
-000053d0: 756e 6469 6e67 5f62 6f78 5b31 5d5d 290d  unding_box[1]]).
-000053e0: 0a20 2020 2020 2020 2061 782e 7365 745f  .        ax.set_
-000053f0: 786c 696d 285b 7365 6c66 2e5f 7261 645f  xlim([self._rad_
-00005400: 6669 656c 645f 626f 756e 6469 6e67 5f62  field_bounding_b
-00005410: 6f78 5b32 5d2c 2073 656c 662e 5f72 6164  ox[2], self._rad
-00005420: 5f66 6965 6c64 5f62 6f75 6e64 696e 675f  _field_bounding_
-00005430: 626f 785b 335d 5d29 0d0a 2020 2020 2020  box[3]])..      
-00005440: 2020 6178 2e73 6574 5f79 7469 636b 6c61    ax.set_ytickla
-00005450: 6265 6c73 285b 5d29 0d0a 2020 2020 2020  bels([])..      
-00005460: 2020 6178 2e73 6574 5f78 7469 636b 6c61    ax.set_xtickla
-00005470: 6265 6c73 285b 5d29 0d0a 2020 2020 2020  bels([])..      
-00005480: 2020 6178 2e73 6574 5f74 6974 6c65 2822    ax.set_title("
-00005490: 5c6e 222e 6a6f 696e 2877 7261 7028 7374  \n".join(wrap(st
-000054a0: 7228 7365 6c66 2e70 6174 6829 2c20 3330  r(self.path), 30
-000054b0: 2929 2c20 666f 6e74 7369 7a65 3d31 3029  )), fontsize=10)
-000054c0: 0d0a 2020 2020 2020 2020 6178 2e73 6574  ..        ax.set
-000054d0: 5f78 6c61 6265 6c28 0d0a 2020 2020 2020  _xlabel(..      
-000054e0: 2020 2020 2020 6622 473d 7b73 656c 662e        f"G={self.
-000054f0: 6761 6e74 7279 5f61 6e67 6c65 3a2e 3066  gantry_angle:.0f
-00005500: 7d2c 2042 3d7b 7365 6c66 2e63 6f6c 6c69  }, B={self.colli
-00005510: 6d61 746f 725f 616e 676c 653a 2e30 667d  mator_angle:.0f}
-00005520: 2c20 503d 7b73 656c 662e 636f 7563 685f  , P={self.couch_
-00005530: 616e 676c 653a 2e30 667d 220d 0a20 2020  angle:.0f}"..   
-00005540: 2020 2020 2029 0d0a 2020 2020 2020 2020       )..        
-00005550: 6178 2e73 6574 5f79 6c61 6265 6c28 0d0a  ax.set_ylabel(..
-00005560: 2020 2020 2020 2020 2020 2020 6622 4341              f"CA
-00005570: 5820 746f 2042 423a 207b 7365 6c66 2e63  X to BB: {self.c
-00005580: 6178 3262 625f 6469 7374 616e 6365 3a33  ax2bb_distance:3
-00005590: 2e32 667d 6d6d 5c6e 583a 207b 7365 6c66  .2f}mm\nX: {self
-000055a0: 2e63 6178 3262 625f 7665 6374 6f72 2e78  .cax2bb_vector.x
-000055b0: 3a33 2e32 667d 6d6d 3b20 593a 207b 7365  :3.2f}mm; Y: {se
-000055c0: 6c66 2e63 6178 3262 625f 7665 6374 6f72  lf.cax2bb_vector
-000055d0: 2e79 3a33 2e32 667d 6d6d 220d 0a20 2020  .y:3.2f}mm"..   
-000055e0: 2020 2020 2029 0d0a 2020 2020 2020 2020       )..        
-000055f0: 6966 2073 686f 773a 0d0a 2020 2020 2020  if show:..      
-00005600: 2020 2020 2020 706c 742e 7368 6f77 2829        plt.show()
-00005610: 0d0a 2020 2020 2020 2020 7265 7475 726e  ..        return
-00005620: 2061 780d 0a0d 0a20 2020 2064 6566 2073   ax....    def s
-00005630: 6176 655f 706c 6f74 2873 656c 662c 2066  ave_plot(self, f
-00005640: 696c 656e 616d 653a 2073 7472 2c20 2a2a  ilename: str, **
-00005650: 6b77 6172 6773 293a 0d0a 2020 2020 2020  kwargs):..      
-00005660: 2020 2222 2253 6176 6520 7468 6520 696d    """Save the im
-00005670: 6167 6520 706c 6f74 2074 6f20 6669 6c65  age plot to file
-00005680: 2e22 2222 0d0a 2020 2020 2020 2020 7365  ."""..        se
-00005690: 6c66 2e70 6c6f 7428 7368 6f77 3d46 616c  lf.plot(show=Fal
-000056a0: 7365 290d 0a20 2020 2020 2020 2070 6c74  se)..        plt
-000056b0: 2e74 6967 6874 5f6c 6179 6f75 7428 290d  .tight_layout().
-000056c0: 0a20 2020 2020 2020 2070 6c74 2e73 6176  .        plt.sav
-000056d0: 6566 6967 2866 696c 656e 616d 652c 202a  efig(filename, *
-000056e0: 2a6b 7761 7267 7329 0d0a 0d0a 2020 2020  *kwargs)....    
-000056f0: 4070 726f 7065 7274 790d 0a20 2020 2064  @property..    d
-00005700: 6566 2076 6172 6961 626c 655f 6178 6973  ef variable_axis
-00005710: 2873 656c 6629 202d 3e20 4178 6973 3a0d  (self) -> Axis:.
-00005720: 0a20 2020 2020 2020 2022 2222 5468 6520  .        """The 
-00005730: 6178 6973 2074 6861 7420 6973 2076 6172  axis that is var
-00005740: 7969 6e67 2e0d 0a0d 0a20 2020 2020 2020  ying.....       
-00005750: 2054 6865 7265 2061 7265 2066 6976 6520   There are five 
-00005760: 7479 7065 7320 6f66 2069 6d61 6765 733a  types of images:
-00005770: 0d0a 0d0a 2020 2020 2020 2020 2a20 5265  ....        * Re
-00005780: 6665 7265 6e63 6520 3a20 416c 6c20 6178  ference : All ax
-00005790: 6573 2061 7265 2061 7420 302e 0d0a 2020  es are at 0...  
-000057a0: 2020 2020 2020 2a20 4761 6e74 7279 3a20        * Gantry: 
-000057b0: 416c 6c20 6178 6573 2062 7574 2067 616e  All axes but gan
-000057c0: 7472 7920 6174 2030 2e0d 0a20 2020 2020  try at 0...     
-000057d0: 2020 202a 2043 6f6c 6c69 6d61 746f 7220     * Collimator 
-000057e0: 3a20 416c 6c20 6178 6573 2062 7574 2063  : All axes but c
-000057f0: 6f6c 6c69 6d61 746f 7220 6174 2030 2e0d  ollimator at 0..
-00005800: 0a20 2020 2020 2020 202a 2043 6f75 6368  .        * Couch
-00005810: 203a 2041 6c6c 2061 7865 7320 6275 7420   : All axes but 
-00005820: 636f 7563 6820 6174 2030 2e0d 0a20 2020  couch at 0...   
-00005830: 2020 2020 202a 2043 6f6d 626f 203a 204d       * Combo : M
-00005840: 6f72 6520 7468 616e 206f 6e65 2061 7869  ore than one axi
-00005850: 7320 6973 206e 6f74 2061 7420 302e 0d0a  s is not at 0...
-00005860: 2020 2020 2020 2020 2222 220d 0a20 2020          """..   
-00005870: 2020 2020 2047 3020 3d20 6973 5f63 6c6f       G0 = is_clo
-00005880: 7365 2873 656c 662e 6761 6e74 7279 5f61  se(self.gantry_a
-00005890: 6e67 6c65 2c20 5b30 2c20 3336 305d 290d  ngle, [0, 360]).
-000058a0: 0a20 2020 2020 2020 2042 3020 3d20 6973  .        B0 = is
-000058b0: 5f63 6c6f 7365 2873 656c 662e 636f 6c6c  _close(self.coll
-000058c0: 696d 6174 6f72 5f61 6e67 6c65 2c20 5b30  imator_angle, [0
-000058d0: 2c20 3336 305d 290d 0a20 2020 2020 2020  , 360])..       
-000058e0: 2050 3020 3d20 6973 5f63 6c6f 7365 2873   P0 = is_close(s
-000058f0: 656c 662e 636f 7563 685f 616e 676c 652c  elf.couch_angle,
-00005900: 205b 302c 2033 3630 5d29 0d0a 2020 2020   [0, 360])..    
-00005910: 2020 2020 6966 2047 3020 616e 6420 4230      if G0 and B0
-00005920: 2061 6e64 206e 6f74 2050 303a 0d0a 2020   and not P0:..  
-00005930: 2020 2020 2020 2020 2020 7265 7475 726e            return
-00005940: 2041 7869 732e 434f 5543 480d 0a20 2020   Axis.COUCH..   
-00005950: 2020 2020 2065 6c69 6620 4730 2061 6e64       elif G0 and
-00005960: 2050 3020 616e 6420 6e6f 7420 4230 3a0d   P0 and not B0:.
-00005970: 0a20 2020 2020 2020 2020 2020 2072 6574  .            ret
-00005980: 7572 6e20 4178 6973 2e43 4f4c 4c49 4d41  urn Axis.COLLIMA
-00005990: 544f 520d 0a20 2020 2020 2020 2065 6c69  TOR..        eli
-000059a0: 6620 5030 2061 6e64 2042 3020 616e 6420  f P0 and B0 and 
-000059b0: 6e6f 7420 4730 3a0d 0a20 2020 2020 2020  not G0:..       
-000059c0: 2020 2020 2072 6574 7572 6e20 4178 6973       return Axis
-000059d0: 2e47 414e 5452 590d 0a20 2020 2020 2020  .GANTRY..       
-000059e0: 2065 6c69 6620 5030 2061 6e64 2042 3020   elif P0 and B0 
-000059f0: 616e 6420 4730 3a0d 0a20 2020 2020 2020  and G0:..       
-00005a00: 2020 2020 2072 6574 7572 6e20 4178 6973       return Axis
-00005a10: 2e52 4546 4552 454e 4345 0d0a 2020 2020  .REFERENCE..    
-00005a20: 2020 2020 656c 6966 2050 303a 0d0a 2020      elif P0:..  
-00005a30: 2020 2020 2020 2020 2020 7265 7475 726e            return
-00005a40: 2041 7869 732e 4742 5f43 4f4d 424f 0d0a   Axis.GB_COMBO..
-00005a50: 2020 2020 2020 2020 656c 7365 3a0d 0a20          else:.. 
-00005a60: 2020 2020 2020 2020 2020 2072 6574 7572             retur
-00005a70: 6e20 4178 6973 2e47 4250 5f43 4f4d 424f  n Axis.GBP_COMBO
-00005a80: 0d0a 0d0a 2020 2020 6465 6620 7265 7375  ....    def resu
-00005a90: 6c74 735f 6461 7461 2873 656c 662c 2061  lts_data(self, a
-00005aa0: 735f 6469 6374 3a20 626f 6f6c 203d 2046  s_dict: bool = F
-00005ab0: 616c 7365 2920 2d3e 2057 696e 7374 6f6e  alse) -> Winston
-00005ac0: 4c75 747a 3244 5265 7375 6c74 207c 2064  Lutz2DResult | d
-00005ad0: 6963 743a 0d0a 2020 2020 2020 2020 2222  ict:..        ""
-00005ae0: 2250 7265 7365 6e74 2074 6865 2072 6573  "Present the res
-00005af0: 756c 7473 2064 6174 6120 616e 6420 6d65  ults data and me
-00005b00: 7461 6461 7461 2061 7320 6120 6461 7461  tadata as a data
-00005b10: 636c 6173 7320 6f72 2064 6963 742e 0d0a  class or dict...
-00005b20: 2020 2020 2020 2020 5468 6520 6465 6661          The defa
-00005b30: 756c 7420 7265 7475 726e 2074 7970 6520  ult return type 
-00005b40: 6973 2061 2064 6174 6163 6c61 7373 2e22  is a dataclass."
-00005b50: 2222 0d0a 2020 2020 2020 2020 6966 206e  ""..        if n
-00005b60: 6f74 2073 656c 662e 5f69 735f 616e 616c  ot self._is_anal
-00005b70: 797a 6564 3a0d 0a20 2020 2020 2020 2020  yzed:..         
-00005b80: 2020 2072 6169 7365 2056 616c 7565 4572     raise ValueEr
-00005b90: 726f 7228 2254 6865 2069 6d61 6765 2069  ror("The image i
-00005ba0: 7320 6e6f 7420 616e 616c 797a 6564 2e20  s not analyzed. 
-00005bb0: 5573 6520 2e61 6e61 6c79 7a65 2829 2066  Use .analyze() f
-00005bc0: 6972 7374 2e22 290d 0a0d 0a20 2020 2020  irst.")....     
-00005bd0: 2020 2064 6174 6120 3d20 5769 6e73 746f     data = Winsto
-00005be0: 6e4c 7574 7a32 4452 6573 756c 7428 0d0a  nLutz2DResult(..
-00005bf0: 2020 2020 2020 2020 2020 2020 7661 7269              vari
-00005c00: 6162 6c65 5f61 7869 733d 7365 6c66 2e76  able_axis=self.v
-00005c10: 6172 6961 626c 655f 6178 6973 2e76 616c  ariable_axis.val
-00005c20: 7565 2c0d 0a20 2020 2020 2020 2020 2020  ue,..           
-00005c30: 2063 6178 3262 625f 7665 6374 6f72 3d73   cax2bb_vector=s
-00005c40: 656c 662e 6361 7832 6262 5f76 6563 746f  elf.cax2bb_vecto
-00005c50: 722c 0d0a 2020 2020 2020 2020 2020 2020  r,..            
-00005c60: 6361 7832 6570 6964 5f76 6563 746f 723d  cax2epid_vector=
-00005c70: 7365 6c66 2e63 6178 3265 7069 645f 7665  self.cax2epid_ve
-00005c80: 6374 6f72 2c0d 0a20 2020 2020 2020 2020  ctor,..         
-00005c90: 2020 2063 6178 3262 625f 6469 7374 616e     cax2bb_distan
-00005ca0: 6365 3d73 656c 662e 6361 7832 6262 5f64  ce=self.cax2bb_d
-00005cb0: 6973 7461 6e63 652c 0d0a 2020 2020 2020  istance,..      
-00005cc0: 2020 2020 2020 6361 7832 6570 6964 5f64        cax2epid_d
-00005cd0: 6973 7461 6e63 653d 7365 6c66 2e63 6178  istance=self.cax
-00005ce0: 3265 7069 645f 6469 7374 616e 6365 2c0d  2epid_distance,.
-00005cf0: 0a20 2020 2020 2020 2020 2020 2062 625f  .            bb_
-00005d00: 6c6f 6361 7469 6f6e 3d73 656c 662e 6262  location=self.bb
-00005d10: 2c0d 0a20 2020 2020 2020 2020 2020 2066  ,..            f
-00005d20: 6965 6c64 5f63 6178 3d73 656c 662e 6669  ield_cax=self.fi
-00005d30: 656c 645f 6361 782c 0d0a 2020 2020 2020  eld_cax,..      
-00005d40: 2020 290d 0a20 2020 2020 2020 2069 6620    )..        if 
-00005d50: 6173 5f64 6963 743a 0d0a 2020 2020 2020  as_dict:..      
-00005d60: 2020 2020 2020 7265 7475 726e 2064 6174        return dat
-00005d70: 6163 6c61 7373 6573 2e61 7364 6963 7428  aclasses.asdict(
-00005d80: 6461 7461 290d 0a20 2020 2020 2020 2072  data)..        r
-00005d90: 6574 7572 6e20 6461 7461 0d0a 0d0a 0d0a  eturn data......
-00005da0: 636c 6173 7320 5769 6e73 746f 6e4c 7574  class WinstonLut
-00005db0: 7a3a 0d0a 2020 2020 2222 2243 6c61 7373  z:..    """Class
-00005dc0: 2066 6f72 2070 6572 666f 726d 696e 6720   for performing 
-00005dd0: 6120 5769 6e73 746f 6e2d 4c75 747a 2074  a Winston-Lutz t
-00005de0: 6573 7420 6f66 2074 6865 2072 6164 6961  est of the radia
-00005df0: 7469 6f6e 2069 736f 6365 6e74 6572 2e22  tion isocenter."
-00005e00: 2222 0d0a 0d0a 2020 2020 696d 6167 6573  ""....    images
-00005e10: 3a20 6c69 7374 5b57 696e 7374 6f6e 4c75  : list[WinstonLu
-00005e20: 747a 3244 5d20 2023 3a0d 0a20 2020 206d  tz2D]  #:..    m
-00005e30: 6163 6869 6e65 5f73 6361 6c65 3a20 4d61  achine_scale: Ma
-00005e40: 6368 696e 6553 6361 6c65 2020 233a 0d0a  chineScale  #:..
-00005e50: 2020 2020 696d 6167 655f 7479 7065 203d      image_type =
-00005e60: 2057 696e 7374 6f6e 4c75 747a 3244 0d0a   WinstonLutz2D..
-00005e70: 2020 2020 6973 5f66 726f 6d5f 6362 6374      is_from_cbct
-00005e80: 3a20 626f 6f6c 203d 2046 616c 7365 0d0a  : bool = False..
-00005e90: 2020 2020 5f62 625f 6469 616d 6574 6572      _bb_diameter
-00005ea0: 203d 2066 6c6f 6174 0d0a 2020 2020 6465   = float..    de
-00005eb0: 7465 6374 696f 6e5f 636f 6e64 6974 696f  tection_conditio
-00005ec0: 6e73 3a20 6c69 7374 5b63 616c 6c61 626c  ns: list[callabl
-00005ed0: 655d 203d 205b 0d0a 2020 2020 2020 2020  e] = [..        
-00005ee0: 6973 5f72 6967 6874 5f73 697a 655f 6262  is_right_size_bb
-00005ef0: 2c0d 0a20 2020 2020 2020 2069 735f 726f  ,..        is_ro
-00005f00: 756e 642c 0d0a 2020 2020 2020 2020 6973  und,..        is
-00005f10: 5f72 6967 6874 5f63 6972 6375 6d66 6572  _right_circumfer
-00005f20: 656e 6365 2c0d 0a20 2020 2020 2020 2069  ence,..        i
-00005f30: 735f 7379 6d6d 6574 7269 632c 0d0a 2020  s_symmetric,..  
-00005f40: 2020 2020 2020 6973 5f73 6f6c 6964 2c0d        is_solid,.
-00005f50: 0a20 2020 205d 0d0a 0d0a 2020 2020 6465  .    ]....    de
-00005f60: 6620 5f5f 696e 6974 5f5f 280d 0a20 2020  f __init__(..   
-00005f70: 2020 2020 2073 656c 662c 0d0a 2020 2020       self,..    
-00005f80: 2020 2020 6469 7265 6374 6f72 793a 2073      directory: s
-00005f90: 7472 207c 206c 6973 745b 7374 725d 207c  tr | list[str] |
-00005fa0: 2050 6174 682c 0d0a 2020 2020 2020 2020   Path,..        
-00005fb0: 7573 655f 6669 6c65 6e61 6d65 733a 2062  use_filenames: b
-00005fc0: 6f6f 6c20 3d20 4661 6c73 652c 0d0a 2020  ool = False,..  
-00005fd0: 2020 2020 2020 6178 6973 5f6d 6170 7069        axis_mappi
-00005fe0: 6e67 3a20 6469 6374 5b73 7472 2c20 7475  ng: dict[str, tu
-00005ff0: 706c 655b 696e 742c 2069 6e74 2c20 696e  ple[int, int, in
-00006000: 745d 5d20 7c20 4e6f 6e65 203d 204e 6f6e  t]] | None = Non
-00006010: 652c 0d0a 2020 2020 2020 2020 6178 6573  e,..        axes
-00006020: 5f70 7265 6369 7369 6f6e 3a20 696e 7420  _precision: int 
-00006030: 7c20 4e6f 6e65 203d 204e 6f6e 652c 0d0a  | None = None,..
-00006040: 2020 2020 2020 2020 6470 693a 2066 6c6f          dpi: flo
-00006050: 6174 207c 204e 6f6e 6520 3d20 4e6f 6e65  at | None = None
-00006060: 2c0d 0a20 2020 2020 2020 2073 6964 3a20  ,..        sid: 
-00006070: 666c 6f61 7420 7c20 4e6f 6e65 203d 204e  float | None = N
-00006080: 6f6e 652c 0d0a 2020 2020 293a 0d0a 2020  one,..    ):..  
-00006090: 2020 2020 2020 2222 220d 0a20 2020 2020        """..     
-000060a0: 2020 2050 6172 616d 6574 6572 730d 0a20     Parameters.. 
-000060b0: 2020 2020 2020 202d 2d2d 2d2d 2d2d 2d2d         ---------
-000060c0: 2d0d 0a20 2020 2020 2020 2064 6972 6563  -..        direc
-000060d0: 746f 7279 203a 2073 7472 2c20 6c69 7374  tory : str, list
-000060e0: 5b73 7472 5d0d 0a20 2020 2020 2020 2020  [str]..         
-000060f0: 2020 2050 6174 6820 746f 2074 6865 2064     Path to the d
-00006100: 6972 6563 746f 7279 206f 6620 7468 6520  irectory of the 
-00006110: 5769 6e73 746f 6e2d 4c75 747a 2045 5049  Winston-Lutz EPI
-00006120: 4420 696d 6167 6573 206f 7220 6120 6c69  D images or a li
-00006130: 7374 206f 6620 7468 6520 696d 6167 6520  st of the image 
-00006140: 7061 7468 730d 0a20 2020 2020 2020 2075  paths..        u
-00006150: 7365 5f66 696c 656e 616d 6573 3a20 626f  se_filenames: bo
-00006160: 6f6c 0d0a 2020 2020 2020 2020 2020 2020  ol..            
-00006170: 5768 6574 6865 7220 746f 2074 7279 2074  Whether to try t
-00006180: 6f20 7573 6520 7468 6520 6669 6c65 206e  o use the file n
-00006190: 616d 6520 746f 2064 6574 6572 6d69 6e65  ame to determine
-000061a0: 2061 7869 7320 7661 6c75 6573 2e0d 0a20   axis values... 
-000061b0: 2020 2020 2020 2020 2020 2055 7365 6675             Usefu
-000061c0: 6c20 666f 7220 456c 656b 7461 206d 6163  l for Elekta mac
-000061d0: 6869 6e65 7320 7468 6174 2064 6f20 6e6f  hines that do no
-000061e0: 7420 696e 636c 7564 6520 7468 6174 2069  t include that i
-000061f0: 6e66 6f20 696e 2074 6865 2044 4943 4f4d  nfo in the DICOM
-00006200: 2064 6174 612e 0d0a 2020 2020 2020 2020   data...        
-00006210: 2020 2020 5468 6973 2069 7320 6d75 7475      This is mutu
-00006220: 616c 6c79 2065 7863 6c75 7369 7665 2074  ally exclusive t
-00006230: 6f20 6178 6973 5f6d 6170 7069 6e67 2e20  o axis_mapping. 
-00006240: 4966 2054 7275 652c 2061 7869 735f 6d61  If True, axis_ma
-00006250: 7070 696e 6720 6973 2069 676e 6f72 6564  pping is ignored
-00006260: 2e0d 0a20 2020 2020 2020 2061 7869 735f  ...        axis_
-00006270: 6d61 7070 696e 673a 2064 6963 740d 0a20  mapping: dict.. 
-00006280: 2020 2020 2020 2020 2020 2041 6e20 6f70             An op
-00006290: 7469 6f6e 616c 2077 6179 206f 6620 696e  tional way of in
-000062a0: 7374 616e 7469 6174 696e 6720 6279 2070  stantiating by p
-000062b0: 6173 7369 6e67 2065 6163 6820 6669 6c65  assing each file
-000062c0: 2061 6c6f 6e67 2077 6974 6820 7468 6520   along with the 
-000062d0: 6178 6973 2076 616c 7565 732e 0d0a 2020  axis values...  
-000062e0: 2020 2020 2020 2020 2020 5374 7275 6374            Struct
-000062f0: 7572 6520 7368 6f75 6c64 2062 6520 3c66  ure should be <f
-00006300: 696c 656e 616d 653e 3a20 283c 6761 6e74  ilename>: (<gant
-00006310: 7279 3e2c 203c 636f 6c6c 3e2c 203c 636f  ry>, <coll>, <co
-00006320: 7563 683e 292e 0d0a 2020 2020 2020 2020  uch>)...        
-00006330: 6178 6573 5f70 7265 6369 7369 6f6e 3a20  axes_precision: 
-00006340: 696e 7420 7c20 4e6f 6e65 0d0a 2020 2020  int | None..    
-00006350: 2020 2020 2020 2020 486f 7720 6d61 6e79          How many
-00006360: 2073 6967 6e69 6669 6361 6e74 2064 6967   significant dig
-00006370: 6974 7320 746f 2072 6570 7265 7365 6e74  its to represent
-00006380: 2074 6865 2061 7865 7320 7661 6c75 6573   the axes values
-00006390: 2e20 4966 204e 6f6e 652c 206e 6f20 7072  . If None, no pr
-000063a0: 6563 6973 696f 6e20 6973 2073 6574 2061  ecision is set a
-000063b0: 6e64 2074 6865 2069 6e70 7574 2f44 4943  nd the input/DIC
-000063c0: 4f4d 2076 616c 7565 7320 6172 6520 7573  OM values are us
-000063d0: 6564 2072 6177 2e0d 0a20 2020 2020 2020  ed raw...       
-000063e0: 2020 2020 2049 6620 7365 7420 746f 2061       If set to a
-000063f0: 6e20 696e 7465 6765 722c 2072 6f75 6e64  n integer, round
-00006400: 7320 7468 6520 6178 6573 2076 616c 7565  s the axes value
-00006410: 7320 2867 616e 7472 792c 2063 6f6c 6c2c  s (gantry, coll,
-00006420: 2063 6f75 6368 2920 746f 2074 6861 7420   couch) to that 
-00006430: 6d61 6e79 2076 616c 7565 732e 2045 2e67  many values. E.g
-00006440: 2e20 6761 6e74 7279 3d30 2e31 3233 3420  . gantry=0.1234 
-00006450: 3d3e 2030 2e31 2077 6974 6820 7072 6563  => 0.1 with prec
-00006460: 6973 696f 6e3d 312e 0d0a 2020 2020 2020  ision=1...      
-00006470: 2020 2020 2020 5468 6973 2069 7320 6d6f        This is mo
-00006480: 7374 6c79 2075 7365 6675 6c20 666f 7220  stly useful for 
-00006490: 706c 6f74 7469 6e67 2f72 6f75 6e64 696e  plotting/roundin
-000064a0: 6720 2833 3539 2e39 3d3e 3029 2061 6e64  g (359.9=>0) and
-000064b0: 2069 6620 7573 696e 6720 7468 6520 6060   if using the ``
-000064c0: 6b65 7965 645f 696d 6167 655f 6465 7461  keyed_image_deta
-000064d0: 696c 7360 6020 7769 7468 2060 6072 6573  ils`` with ``res
-000064e0: 756c 7473 5f64 6174 6160 602e 0d0a 2020  ults_data``...  
-000064f0: 2020 2020 2020 6470 690d 0a20 2020 2020        dpi..     
-00006500: 2020 2020 2020 2054 6865 2064 6f74 732d         The dots-
-00006510: 7065 722d 696e 6368 2073 6574 7469 6e67  per-inch setting
-00006520: 2e20 4f6e 6c79 206e 6565 6465 6420 6966  . Only needed if
-00006530: 2075 7369 6e67 2054 4946 4620 696d 6167   using TIFF imag
-00006540: 6573 2061 6e64 2074 6865 2069 6d61 6765  es and the image
-00006550: 7320 646f 206e 6f74 2063 6f6e 7461 696e  s do not contain
-00006560: 2074 6865 2072 6573 6f6c 7574 696f 6e20   the resolution 
-00006570: 7461 672e 0d0a 2020 2020 2020 2020 2020  tag...          
-00006580: 2020 416e 2065 7272 6f72 2077 696c 6c20    An error will 
-00006590: 7261 6973 6520 6966 2064 7069 2069 7320  raise if dpi is 
-000065a0: 6e6f 7420 7061 7373 6564 2061 6e64 2074  not passed and t
-000065b0: 6865 2054 4946 4620 7265 736f 6c75 7469  he TIFF resoluti
-000065c0: 6f6e 2063 616e 6e6f 7420 6265 2064 6574  on cannot be det
-000065d0: 6572 6d69 6e65 642e 0d0a 2020 2020 2020  ermined...      
-000065e0: 2020 7369 640d 0a20 2020 2020 2020 2020    sid..         
-000065f0: 2020 2054 6865 2053 6f75 7263 652d 746f     The Source-to
-00006600: 2d49 6d61 6765 2064 6973 7461 6e63 6520  -Image distance 
-00006610: 696e 206d 6d2e 204f 6e6c 7920 6e65 6564  in mm. Only need
-00006620: 6564 2077 6865 6e20 7573 696e 6720 5449  ed when using TI
-00006630: 4646 2069 6d61 6765 732e 0d0a 2020 2020  FF images...    
-00006640: 2020 2020 2222 220d 0a20 2020 2020 2020      """..       
-00006650: 2073 656c 662e 696d 6167 6573 203d 205b   self.images = [
-00006660: 5d0d 0a20 2020 2020 2020 2069 6620 6178  ]..        if ax
-00006670: 6973 5f6d 6170 7069 6e67 2061 6e64 206e  is_mapping and n
-00006680: 6f74 2075 7365 5f66 696c 656e 616d 6573  ot use_filenames
-00006690: 3a0d 0a20 2020 2020 2020 2020 2020 2066  :..            f
-000066a0: 6f72 2066 696c 656e 616d 652c 2028 6761  or filename, (ga
-000066b0: 6e74 7279 2c20 636f 6c6c 2c20 636f 7563  ntry, coll, couc
-000066c0: 6829 2069 6e20 6178 6973 5f6d 6170 7069  h) in axis_mappi
-000066d0: 6e67 2e69 7465 6d73 2829 3a0d 0a20 2020  ng.items():..   
-000066e0: 2020 2020 2020 2020 2020 2020 2073 656c               sel
-000066f0: 662e 696d 6167 6573 2e61 7070 656e 6428  f.images.append(
-00006700: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-00006710: 2020 2020 2020 7365 6c66 2e5f 6c6f 6164        self._load
-00006720: 5f69 6d61 6765 280d 0a20 2020 2020 2020  _image(..       
-00006730: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00006740: 2050 6174 6828 6469 7265 6374 6f72 7929   Path(directory)
-00006750: 202f 2066 696c 656e 616d 652c 0d0a 2020   / filename,..  
-00006760: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00006770: 2020 2020 2020 7369 643d 7369 642c 0d0a        sid=sid,..
-00006780: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00006790: 2020 2020 2020 2020 6470 693d 6470 692c          dpi=dpi,
-000067a0: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-000067b0: 2020 2020 2020 2020 2020 6761 6e74 7279            gantry
-000067c0: 3d67 616e 7472 792c 0d0a 2020 2020 2020  =gantry,..      
+00000c20: 2e22 0a29 0a0a 0a63 6c61 7373 2042 4243  .".)...class BBC
+00000c30: 6f6e 6669 6728 4261 7365 4d6f 6465 6c29  onfig(BaseModel)
+00000c40: 3a0a 2020 2020 6e61 6d65 3a20 7374 720a  :.    name: str.
+00000c50: 2020 2020 6f66 6673 6574 5f6c 6566 745f      offset_left_
+00000c60: 6d6d 3a20 666c 6f61 740a 2020 2020 6f66  mm: float.    of
+00000c70: 6673 6574 5f75 705f 6d6d 3a20 666c 6f61  fset_up_mm: floa
+00000c80: 740a 2020 2020 6f66 6673 6574 5f69 6e5f  t.    offset_in_
+00000c90: 6d6d 3a20 666c 6f61 740a 2020 2020 6262  mm: float.    bb
+00000ca0: 5f73 697a 655f 6d6d 3a20 666c 6f61 740a  _size_mm: float.
+00000cb0: 2020 2020 7261 645f 7369 7a65 5f6d 6d3a      rad_size_mm:
+00000cc0: 2066 6c6f 6174 0a0a 2020 2020 6465 6620   float..    def 
+00000cd0: 746f 5f68 756d 616e 2873 656c 6629 202d  to_human(self) -
+00000ce0: 3e20 7374 723a 0a20 2020 2020 2020 2022  > str:.        "
+00000cf0: 2222 436f 6e76 6572 7420 6f6e 6520 4242  ""Convert one BB
+00000d00: 206c 6f63 6174 696f 6e20 746f 2061 2068   location to a h
+00000d10: 756d 616e 2d72 6561 6461 626c 6520 7374  uman-readable st
+00000d20: 7222 2222 0a20 2020 2020 2020 206c 7220  r""".        lr 
+00000d30: 3d20 224c 6566 7422 2069 6620 7365 6c66  = "Left" if self
+00000d40: 2e6f 6666 7365 745f 6c65 6674 5f6d 6d20  .offset_left_mm 
+00000d50: 3e3d 2030 2065 6c73 6520 2252 6967 6874  >= 0 else "Right
+00000d60: 220a 2020 2020 2020 2020 7564 203d 2022  ".        ud = "
+00000d70: 5570 2220 6966 2073 656c 662e 6f66 6673  Up" if self.offs
+00000d80: 6574 5f75 705f 6d6d 203e 3d20 3020 656c  et_up_mm >= 0 el
+00000d90: 7365 2022 446f 776e 220a 2020 2020 2020  se "Down".      
+00000da0: 2020 696f 203d 2022 496e 2220 6966 2073    io = "In" if s
+00000db0: 656c 662e 6f66 6673 6574 5f69 6e5f 6d6d  elf.offset_in_mm
+00000dc0: 203e 3d20 3020 656c 7365 2022 4f75 7422   >= 0 else "Out"
+00000dd0: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
+00000de0: 6622 7b6c 727d 207b 6162 7328 7365 6c66  f"{lr} {abs(self
+00000df0: 2e6f 6666 7365 745f 6c65 6674 5f6d 6d29  .offset_left_mm)
+00000e00: 7d6d 6d2c 207b 7564 7d20 7b61 6273 2873  }mm, {ud} {abs(s
+00000e10: 656c 662e 6f66 6673 6574 5f75 705f 6d6d  elf.offset_up_mm
+00000e20: 297d 6d6d 2c20 7b69 6f7d 207b 6162 7328  )}mm, {io} {abs(
+00000e30: 7365 6c66 2e6f 6666 7365 745f 696e 5f6d  self.offset_in_m
+00000e40: 6d29 7d6d 6d22 0a0a 0a63 6c61 7373 2042  m)}mm"...class B
+00000e50: 4241 7272 616e 6765 6d65 6e74 3a0a 2020  BArrangement:.  
+00000e60: 2020 2222 2250 7265 7365 7473 2066 6f72    """Presets for
+00000e70: 206d 756c 7469 2d74 6172 6765 7420 7068   multi-target ph
+00000e80: 616e 746f 6d73 2e22 2222 0a0a 2020 2020  antoms."""..    
+00000e90: 2320 6120 4242 2061 7420 6973 6f3b 2072  # a BB at iso; r
+00000ea0: 6570 7265 7365 6e74 7320 7468 6520 7369  epresents the si
+00000eb0: 6d70 6c65 7374 2063 6173 650a 2020 2020  mplest case.    
+00000ec0: 4953 4f20 3d20 280a 2020 2020 2020 2020  ISO = (.        
+00000ed0: 4242 436f 6e66 6967 280a 2020 2020 2020  BBConfig(.      
+00000ee0: 2020 2020 2020 6e61 6d65 3d22 4973 6f22        name="Iso"
+00000ef0: 2c0a 2020 2020 2020 2020 2020 2020 6f66  ,.            of
+00000f00: 6673 6574 5f6c 6566 745f 6d6d 3d30 2c0a  fset_left_mm=0,.
+00000f10: 2020 2020 2020 2020 2020 2020 6f66 6673              offs
+00000f20: 6574 5f75 705f 6d6d 3d30 2c0a 2020 2020  et_up_mm=0,.    
+00000f30: 2020 2020 2020 2020 6f66 6673 6574 5f69          offset_i
+00000f40: 6e5f 6d6d 3d30 2c0a 2020 2020 2020 2020  n_mm=0,.        
+00000f50: 2020 2020 6262 5f73 697a 655f 6d6d 3d35      bb_size_mm=5
+00000f60: 2c20 2023 206f 7665 7272 6964 6465 6e20  ,  # overridden 
+00000f70: 6c61 7465 7220 6479 6e61 6d69 6361 6c6c  later dynamicall
+00000f80: 790a 2020 2020 2020 2020 2020 2020 7261  y.            ra
+00000f90: 645f 7369 7a65 5f6d 6d3d 3230 2c20 2023  d_size_mm=20,  #
+00000fa0: 206e 6f74 2075 7365 643b 0a20 2020 2020   not used;.     
+00000fb0: 2020 2029 2c0a 2020 2020 290a 2020 2020     ),.    ).    
+00000fc0: 2320 4953 4f43 414c 203d 2028 0a20 2020  # ISOCAL = (.   
+00000fd0: 2023 2020 2020 2042 4243 6f6e 6669 6728   #     BBConfig(
+00000fe0: 0a20 2020 2023 2020 2020 2020 2020 206e  .    #         n
+00000ff0: 616d 653d 2231 222c 0a20 2020 2023 2020  ame="1",.    #  
+00001000: 2020 2020 2020 206f 6666 7365 745f 6c65         offset_le
+00001010: 6674 5f6d 6d3d 302c 0a20 2020 2023 2020  ft_mm=0,.    #  
+00001020: 2020 2020 2020 206f 6666 7365 745f 7570         offset_up
+00001030: 5f6d 6d3d 2d31 3730 2c0a 2020 2020 2320  _mm=-170,.    # 
+00001040: 2020 2020 2020 2020 6f66 6673 6574 5f69          offset_i
+00001050: 6e5f 6d6d 3d2d 3330 2c0a 2020 2020 2320  n_mm=-30,.    # 
+00001060: 2020 2020 2020 2020 6262 5f73 697a 655f          bb_size_
+00001070: 6d6d 3d35 2c0a 2020 2020 2320 2020 2020  mm=5,.    #     
+00001080: 2020 2020 7261 645f 7369 7a65 5f6d 6d3d      rad_size_mm=
+00001090: 3230 2c0a 2020 2020 2320 2020 2020 292c  20,.    #     ),
+000010a0: 0a20 2020 2023 207b 0a20 2020 2023 2020  .    # {.    #  
+000010b0: 2020 2027 6e61 6d65 273a 2027 3227 2c0a     'name': '2',.
+000010c0: 2020 2020 2320 2020 2020 276f 6666 7365      #     'offse
+000010d0: 745f 6c65 6674 5f6d 6d27 3a20 2d31 3730  t_left_mm': -170
+000010e0: 2c0a 2020 2020 2320 2020 2020 276f 6666  ,.    #     'off
+000010f0: 7365 745f 7570 5f6d 6d27 3a20 302c 0a20  set_up_mm': 0,. 
+00001100: 2020 2023 2020 2020 2027 6f66 6673 6574     #     'offset
+00001110: 5f69 6e5f 6d6d 273a 202d 3435 2c0a 2020  _in_mm': -45,.  
+00001120: 2020 2320 2020 2020 2262 625f 7369 7a65    #     "bb_size
+00001130: 5f6d 6d22 3a20 352c 0a20 2020 2023 2020  _mm": 5,.    #  
+00001140: 2020 2027 7261 645f 7369 7a65 5f6d 6d27     'rad_size_mm'
+00001150: 3a20 3230 2c0a 2020 2020 2320 7d0a 2020  : 20,.    # }.  
+00001160: 2020 2320 290a 2020 2020 2320 6c6f 6361    # ).    # loca
+00001170: 7469 6f6e 733a 2068 7474 7073 3a2f 2f77  tions: https://w
+00001180: 7777 2e70 6f73 7465 7273 6573 7369 6f6e  ww.postersession
+00001190: 6f6e 6c69 6e65 2e65 752f 3137 3335 3830  online.eu/173580
+000011a0: 3334 385f 6575 2f63 6f6e 6772 6573 6f73  348_eu/congresos
+000011b0: 2f45 5354 524f 3230 3230 2f61 756c 612f  /ESTRO2020/aula/
+000011c0: 2d50 4f5f 3133 3230 5f45 5354 524f 3230  -PO_1320_ESTRO20
+000011d0: 3230 2e70 6466 0a20 2020 2053 4e43 5f4d  20.pdf.    SNC_M
+000011e0: 554c 5449 4d45 5420 3d20 280a 2020 2020  ULTIMET = (.    
+000011f0: 2020 2020 4242 436f 6e66 6967 280a 2020      BBConfig(.  
+00001200: 2020 2020 2020 2020 2020 6e61 6d65 3d22            name="
+00001210: 4973 6f22 2c0a 2020 2020 2020 2020 2020  Iso",.          
+00001220: 2020 6f66 6673 6574 5f6c 6566 745f 6d6d    offset_left_mm
+00001230: 3d30 2c0a 2020 2020 2020 2020 2020 2020  =0,.            
+00001240: 6f66 6673 6574 5f75 705f 6d6d 3d30 2c0a  offset_up_mm=0,.
+00001250: 2020 2020 2020 2020 2020 2020 6f66 6673              offs
+00001260: 6574 5f69 6e5f 6d6d 3d30 2c0a 2020 2020  et_in_mm=0,.    
+00001270: 2020 2020 2020 2020 6262 5f73 697a 655f          bb_size_
+00001280: 6d6d 3d35 2c0a 2020 2020 2020 2020 2020  mm=5,.          
+00001290: 2020 7261 645f 7369 7a65 5f6d 6d3d 3230    rad_size_mm=20
+000012a0: 2c0a 2020 2020 2020 2020 292c 0a20 2020  ,.        ),.   
+000012b0: 2020 2020 2042 4243 6f6e 6669 6728 0a20       BBConfig(. 
+000012c0: 2020 2020 2020 2020 2020 206e 616d 653d             name=
+000012d0: 2231 222c 0a20 2020 2020 2020 2020 2020  "1",.           
+000012e0: 206f 6666 7365 745f 6c65 6674 5f6d 6d3d   offset_left_mm=
+000012f0: 302c 0a20 2020 2020 2020 2020 2020 206f  0,.            o
+00001300: 6666 7365 745f 7570 5f6d 6d3d 302c 0a20  ffset_up_mm=0,. 
+00001310: 2020 2020 2020 2020 2020 206f 6666 7365             offse
+00001320: 745f 696e 5f6d 6d3d 3330 2c0a 2020 2020  t_in_mm=30,.    
+00001330: 2020 2020 2020 2020 6262 5f73 697a 655f          bb_size_
+00001340: 6d6d 3d35 2c0a 2020 2020 2020 2020 2020  mm=5,.          
+00001350: 2020 7261 645f 7369 7a65 5f6d 6d3d 3230    rad_size_mm=20
+00001360: 2c0a 2020 2020 2020 2020 292c 0a20 2020  ,.        ),.   
+00001370: 2020 2020 2042 4243 6f6e 6669 6728 0a20       BBConfig(. 
+00001380: 2020 2020 2020 2020 2020 206e 616d 653d             name=
+00001390: 2232 222c 0a20 2020 2020 2020 2020 2020  "2",.           
+000013a0: 206f 6666 7365 745f 6c65 6674 5f6d 6d3d   offset_left_mm=
+000013b0: 2d33 302c 0a20 2020 2020 2020 2020 2020  -30,.           
+000013c0: 206f 6666 7365 745f 7570 5f6d 6d3d 302c   offset_up_mm=0,
+000013d0: 0a20 2020 2020 2020 2020 2020 206f 6666  .            off
+000013e0: 7365 745f 696e 5f6d 6d3d 3135 2c0a 2020  set_in_mm=15,.  
+000013f0: 2020 2020 2020 2020 2020 6262 5f73 697a            bb_siz
+00001400: 655f 6d6d 3d35 2c0a 2020 2020 2020 2020  e_mm=5,.        
+00001410: 2020 2020 7261 645f 7369 7a65 5f6d 6d3d      rad_size_mm=
+00001420: 3230 2c0a 2020 2020 2020 2020 292c 0a20  20,.        ),. 
+00001430: 2020 2020 2020 2042 4243 6f6e 6669 6728         BBConfig(
+00001440: 0a20 2020 2020 2020 2020 2020 206e 616d  .            nam
+00001450: 653d 2233 222c 0a20 2020 2020 2020 2020  e="3",.         
+00001460: 2020 206f 6666 7365 745f 6c65 6674 5f6d     offset_left_m
+00001470: 6d3d 302c 0a20 2020 2020 2020 2020 2020  m=0,.           
+00001480: 206f 6666 7365 745f 7570 5f6d 6d3d 302c   offset_up_mm=0,
+00001490: 0a20 2020 2020 2020 2020 2020 206f 6666  .            off
+000014a0: 7365 745f 696e 5f6d 6d3d 2d33 302c 0a20  set_in_mm=-30,. 
+000014b0: 2020 2020 2020 2020 2020 2062 625f 7369             bb_si
+000014c0: 7a65 5f6d 6d3d 352c 0a20 2020 2020 2020  ze_mm=5,.       
+000014d0: 2020 2020 2072 6164 5f73 697a 655f 6d6d       rad_size_mm
+000014e0: 3d32 302c 0a20 2020 2020 2020 2029 2c0a  =20,.        ),.
+000014f0: 2020 2020 2020 2020 4242 436f 6e66 6967          BBConfig
+00001500: 280a 2020 2020 2020 2020 2020 2020 6e61  (.            na
+00001510: 6d65 3d22 3422 2c0a 2020 2020 2020 2020  me="4",.        
+00001520: 2020 2020 6f66 6673 6574 5f6c 6566 745f      offset_left_
+00001530: 6d6d 3d33 302c 0a20 2020 2020 2020 2020  mm=30,.         
+00001540: 2020 206f 6666 7365 745f 7570 5f6d 6d3d     offset_up_mm=
+00001550: 302c 0a20 2020 2020 2020 2020 2020 206f  0,.            o
+00001560: 6666 7365 745f 696e 5f6d 6d3d 2d35 302c  ffset_in_mm=-50,
+00001570: 0a20 2020 2020 2020 2020 2020 2062 625f  .            bb_
+00001580: 7369 7a65 5f6d 6d3d 352c 0a20 2020 2020  size_mm=5,.     
+00001590: 2020 2020 2020 2072 6164 5f73 697a 655f         rad_size_
+000015a0: 6d6d 3d32 302c 0a20 2020 2020 2020 2029  mm=20,.        )
+000015b0: 2c0a 2020 2020 2020 2020 4242 436f 6e66  ,.        BBConf
+000015c0: 6967 280a 2020 2020 2020 2020 2020 2020  ig(.            
+000015d0: 6e61 6d65 3d22 3522 2c0a 2020 2020 2020  name="5",.      
+000015e0: 2020 2020 2020 6f66 6673 6574 5f6c 6566        offset_lef
+000015f0: 745f 6d6d 3d30 2c0a 2020 2020 2020 2020  t_mm=0,.        
+00001600: 2020 2020 6f66 6673 6574 5f75 705f 6d6d      offset_up_mm
+00001610: 3d30 2c0a 2020 2020 2020 2020 2020 2020  =0,.            
+00001620: 6f66 6673 6574 5f69 6e5f 6d6d 3d2d 3730  offset_in_mm=-70
+00001630: 2c0a 2020 2020 2020 2020 2020 2020 6262  ,.            bb
+00001640: 5f73 697a 655f 6d6d 3d35 2c0a 2020 2020  _size_mm=5,.    
+00001650: 2020 2020 2020 2020 7261 645f 7369 7a65          rad_size
+00001660: 5f6d 6d3d 3230 2c0a 2020 2020 2020 2020  _mm=20,.        
+00001670: 292c 0a20 2020 2029 0a20 2020 2044 454d  ),.    ).    DEM
+00001680: 4f20 3d20 280a 2020 2020 2020 2020 4242  O = (.        BB
+00001690: 436f 6e66 6967 280a 2020 2020 2020 2020  Config(.        
+000016a0: 2020 2020 6e61 6d65 3d22 4973 6f22 2c0a      name="Iso",.
+000016b0: 2020 2020 2020 2020 2020 2020 6f66 6673              offs
+000016c0: 6574 5f6c 6566 745f 6d6d 3d30 2c0a 2020  et_left_mm=0,.  
+000016d0: 2020 2020 2020 2020 2020 6f66 6673 6574            offset
+000016e0: 5f75 705f 6d6d 3d35 2c0a 2020 2020 2020  _up_mm=5,.      
+000016f0: 2020 2020 2020 6f66 6673 6574 5f69 6e5f        offset_in_
+00001700: 6d6d 3d30 2c0a 2020 2020 2020 2020 2020  mm=0,.          
+00001710: 2020 6262 5f73 697a 655f 6d6d 3d35 2c0a    bb_size_mm=5,.
+00001720: 2020 2020 2020 2020 2020 2020 7261 645f              rad_
+00001730: 7369 7a65 5f6d 6d3d 3230 2c0a 2020 2020  size_mm=20,.    
+00001740: 2020 2020 292c 0a20 2020 2020 2020 2042      ),.        B
+00001750: 4243 6f6e 6669 6728 0a20 2020 2020 2020  BConfig(.       
+00001760: 2020 2020 206e 616d 653d 224f 7574 222c       name="Out",
+00001770: 0a20 2020 2020 2020 2020 2020 206f 6666  .            off
+00001780: 7365 745f 6c65 6674 5f6d 6d3d 302c 0a20  set_left_mm=0,. 
+00001790: 2020 2020 2020 2020 2020 206f 6666 7365             offse
+000017a0: 745f 7570 5f6d 6d3d 3030 2c0a 2020 2020  t_up_mm=00,.    
+000017b0: 2020 2020 2020 2020 6f66 6673 6574 5f69          offset_i
+000017c0: 6e5f 6d6d 3d2d 3630 2c0a 2020 2020 2020  n_mm=-60,.      
+000017d0: 2020 2020 2020 6262 5f73 697a 655f 6d6d        bb_size_mm
+000017e0: 3d35 2c0a 2020 2020 2020 2020 2020 2020  =5,.            
+000017f0: 7261 645f 7369 7a65 5f6d 6d3d 3230 2c0a  rad_size_mm=20,.
+00001800: 2020 2020 2020 2020 292c 0a20 2020 2020          ),.     
+00001810: 2020 2042 4243 6f6e 6669 6728 0a20 2020     BBConfig(.   
+00001820: 2020 2020 2020 2020 206e 616d 653d 2249           name="I
+00001830: 6e22 2c0a 2020 2020 2020 2020 2020 2020  n",.            
+00001840: 6f66 6673 6574 5f6c 6566 745f 6d6d 3d30  offset_left_mm=0
+00001850: 2c0a 2020 2020 2020 2020 2020 2020 6f66  ,.            of
+00001860: 6673 6574 5f75 705f 6d6d 3d30 302c 0a20  fset_up_mm=00,. 
+00001870: 2020 2020 2020 2020 2020 206f 6666 7365             offse
+00001880: 745f 696e 5f6d 6d3d 3330 2c0a 2020 2020  t_in_mm=30,.    
+00001890: 2020 2020 2020 2020 6262 5f73 697a 655f          bb_size_
+000018a0: 6d6d 3d35 2c0a 2020 2020 2020 2020 2020  mm=5,.          
+000018b0: 2020 7261 645f 7369 7a65 5f6d 6d3d 3230    rad_size_mm=20
+000018c0: 2c0a 2020 2020 2020 2020 292c 0a20 2020  ,.        ),.   
+000018d0: 2020 2020 2042 4243 6f6e 6669 6728 0a20       BBConfig(. 
+000018e0: 2020 2020 2020 2020 2020 206e 616d 653d             name=
+000018f0: 224c 6566 742f 4f75 7422 2c0a 2020 2020  "Left/Out",.    
+00001900: 2020 2020 2020 2020 6f66 6673 6574 5f6c          offset_l
+00001910: 6566 745f 6d6d 3d31 302c 0a20 2020 2020  eft_mm=10,.     
+00001920: 2020 2020 2020 206f 6666 7365 745f 7570         offset_up
+00001930: 5f6d 6d3d 3130 2c0a 2020 2020 2020 2020  _mm=10,.        
+00001940: 2020 2020 6f66 6673 6574 5f69 6e5f 6d6d      offset_in_mm
+00001950: 3d2d 3330 2c0a 2020 2020 2020 2020 2020  =-30,.          
+00001960: 2020 6262 5f73 697a 655f 6d6d 3d35 2c0a    bb_size_mm=5,.
+00001970: 2020 2020 2020 2020 2020 2020 7261 645f              rad_
+00001980: 7369 7a65 5f6d 6d3d 3230 2c0a 2020 2020  size_mm=20,.    
+00001990: 2020 2020 292c 0a20 2020 2029 0a0a 2020      ),.    )..  
+000019a0: 2020 4073 7461 7469 636d 6574 686f 640a    @staticmethod.
+000019b0: 2020 2020 6465 6620 746f 5f68 756d 616e      def to_human
+000019c0: 2861 7272 616e 6765 6d65 6e74 3a20 6469  (arrangement: di
+000019d0: 6374 2920 2d3e 2073 7472 3a0a 2020 2020  ct) -> str:.    
+000019e0: 2020 2020 2222 2243 6f6e 7665 7274 206f      """Convert o
+000019f0: 6e65 2042 4220 6c6f 6361 7469 6f6e 2074  ne BB location t
+00001a00: 6f20 6120 6875 6d61 6e2d 7265 6164 6162  o a human-readab
+00001a10: 6c65 2073 7472 2222 220a 2020 2020 2020  le str""".      
+00001a20: 2020 6120 3d20 6172 7261 6e67 656d 656e    a = arrangemen
+00001a30: 740a 2020 2020 2020 2020 6c72 203d 2022  t.        lr = "
+00001a40: 4c65 6674 2220 6966 2061 5b22 6f66 6673  Left" if a["offs
+00001a50: 6574 5f6c 6566 745f 6d6d 225d 203e 3d20  et_left_mm"] >= 
+00001a60: 3020 656c 7365 2022 5269 6768 7422 0a20  0 else "Right". 
+00001a70: 2020 2020 2020 2075 6420 3d20 2255 7022         ud = "Up"
+00001a80: 2069 6620 615b 226f 6666 7365 745f 7570   if a["offset_up
+00001a90: 5f6d 6d22 5d20 3e3d 2030 2065 6c73 6520  _mm"] >= 0 else 
+00001aa0: 2244 6f77 6e22 0a20 2020 2020 2020 2069  "Down".        i
+00001ab0: 6f20 3d20 2249 6e22 2069 6620 615b 226f  o = "In" if a["o
+00001ac0: 6666 7365 745f 696e 5f6d 6d22 5d20 3e3d  ffset_in_mm"] >=
+00001ad0: 2030 2065 6c73 6520 224f 7574 220a 2020   0 else "Out".  
+00001ae0: 2020 2020 2020 7265 7475 726e 2066 2227        return f"'
+00001af0: 7b61 5b27 6e61 6d65 275d 7d27 3a20 7b6c  {a['name']}': {l
+00001b00: 727d 207b 6162 7328 615b 276f 6666 7365  r} {abs(a['offse
+00001b10: 745f 6c65 6674 5f6d 6d27 5d29 7d6d 6d2c  t_left_mm'])}mm,
+00001b20: 207b 7564 7d20 7b61 6273 2861 5b27 6f66   {ud} {abs(a['of
+00001b30: 6673 6574 5f75 705f 6d6d 275d 297d 6d6d  fset_up_mm'])}mm
+00001b40: 2c20 7b69 6f7d 207b 6162 7328 615b 276f  , {io} {abs(a['o
+00001b50: 6666 7365 745f 696e 5f6d 6d27 5d29 7d6d  ffset_in_mm'])}m
+00001b60: 6d22 0a0a 0a40 6461 7461 636c 6173 7365  m"...@dataclasse
+00001b70: 732e 6461 7461 636c 6173 730a 636c 6173  s.dataclass.clas
+00001b80: 7320 4242 4669 656c 644d 6174 6368 3a0a  s BBFieldMatch:.
+00001b90: 2020 2020 2222 2241 206d 6174 6368 206f      """A match o
+00001ba0: 6620 6120 4242 2061 6e64 2066 6965 6c64  f a BB and field
+00001bb0: 2074 6f20 616e 2065 7870 6563 7465 6420   to an expected 
+00001bc0: 6172 7261 6e67 656d 656e 7420 706f 7369  arrangement posi
+00001bd0: 7469 6f6e 2e20 492e 652e 2074 6865 206e  tion. I.e. the n
+00001be0: 6f6d 696e 616c 2042 422c 206d 6561 7375  ominal BB, measu
+00001bf0: 7265 6420 4242 2c20 616e 6420 6669 656c  red BB, and fiel
+00001c00: 642e 0a20 2020 2054 6869 7320 6361 6e20  d..    This can 
+00001c10: 6361 6c63 756c 6174 6520 6469 7374 616e  calculate distan
+00001c20: 6365 732c 2063 7265 6174 6520 6261 636b  ces, create back
+00001c30: 7072 6f6a 6563 7469 6f6e 732c 2065 7463  projections, etc
+00001c40: 2066 6f72 2061 2073 696e 676c 6520 4242   for a single BB
+00001c50: 2f46 6965 6c64 2e22 2222 0a0a 2020 2020  /Field."""..    
+00001c60: 6570 6964 3a20 506f 696e 740a 2020 2020  epid: Point.    
+00001c70: 6669 656c 643a 2050 6f69 6e74 0a20 2020  field: Point.   
+00001c80: 2062 623a 2050 6f69 6e74 0a20 2020 2064   bb: Point.    d
+00001c90: 706d 6d3a 2066 6c6f 6174 0a20 2020 2067  pmm: float.    g
+00001ca0: 616e 7472 795f 616e 676c 653a 2066 6c6f  antry_angle: flo
+00001cb0: 6174 0a20 2020 2063 6f75 6368 5f61 6e67  at.    couch_ang
+00001cc0: 6c65 3a20 666c 6f61 740a 2020 2020 7361  le: float.    sa
+00001cd0: 643a 2066 6c6f 6174 0a0a 2020 2020 4070  d: float..    @p
+00001ce0: 726f 7065 7274 790a 2020 2020 6465 6620  roperty.    def 
+00001cf0: 6669 656c 645f 6570 6964 5f76 6563 746f  field_epid_vecto
+00001d00: 725f 6d6d 2873 656c 6629 202d 3e20 5665  r_mm(self) -> Ve
+00001d10: 6374 6f72 3a0a 2020 2020 2020 2020 2222  ctor:.        ""
+00001d20: 2254 6865 2076 6563 746f 7220 6672 6f6d  "The vector from
+00001d30: 2074 6865 2066 6965 6c64 2043 4158 2074   the field CAX t
+00001d40: 6f20 7468 6520 4550 4944 2063 656e 7465  o the EPID cente
+00001d50: 7220 2a49 4e20 434f 4f52 4449 4e41 5445  r *IN COORDINATE
+00001d60: 2053 5041 4345 2a2e 2222 220a 2020 2020   SPACE*.""".    
+00001d70: 2020 2020 7620 3d20 2873 656c 662e 6669      v = (self.fi
+00001d80: 656c 6420 2d20 7365 6c66 2e65 7069 6429  eld - self.epid)
+00001d90: 202f 2073 656c 662e 6470 6d6d 0a20 2020   / self.dpmm.   
+00001da0: 2020 2020 2076 2e79 203d 2028 0a20 2020       v.y = (.   
+00001db0: 2020 2020 2020 2020 202d 762e 790a 2020           -v.y.  
+00001dc0: 2020 2020 2020 2920 2023 2069 6e76 6572        )  # inver
+00001dd0: 7420 7468 6520 792d 6178 6973 3b20 706f  t the y-axis; po
+00001de0: 7369 7469 7665 2069 7320 646f 776e 2069  sitive is down i
+00001df0: 6e20 696d 6167 6520 7370 6163 6520 6275  n image space bu
+00001e00: 7420 6e65 6761 7469 7665 2069 6e20 636f  t negative in co
+00001e10: 6f72 6469 6e61 7465 2073 7061 6365 0a20  ordinate space. 
+00001e20: 2020 2020 2020 2072 6574 7572 6e20 760a         return v.
+00001e30: 0a20 2020 2040 7072 6f70 6572 7479 0a20  .    @property. 
+00001e40: 2020 2064 6566 2062 625f 6669 656c 645f     def bb_field_
+00001e50: 7665 6374 6f72 5f6d 6d28 7365 6c66 2920  vector_mm(self) 
+00001e60: 2d3e 2056 6563 746f 723a 0a20 2020 2020  -> Vector:.     
+00001e70: 2020 2022 2222 5468 6520 7665 6374 6f72     """The vector
+00001e80: 2066 726f 6d20 7468 6520 4242 2074 6f20   from the BB to 
+00001e90: 7468 6520 6669 656c 6420 4341 5820 2a49  the field CAX *I
+00001ea0: 4e20 434f 4f52 4449 4e41 5445 2053 5041  N COORDINATE SPA
+00001eb0: 4345 2a2e 2222 220a 2020 2020 2020 2020  CE*.""".        
+00001ec0: 7620 3d20 2873 656c 662e 6262 202d 2073  v = (self.bb - s
+00001ed0: 656c 662e 6669 656c 6429 202f 2073 656c  elf.field) / sel
+00001ee0: 662e 6470 6d6d 0a20 2020 2020 2020 2076  f.dpmm.        v
+00001ef0: 2e79 203d 2028 0a20 2020 2020 2020 2020  .y = (.         
+00001f00: 2020 202d 762e 790a 2020 2020 2020 2020     -v.y.        
+00001f10: 2920 2023 2069 6e76 6572 7420 7468 6520  )  # invert the 
+00001f20: 792d 6178 6973 3b20 706f 7369 7469 7665  y-axis; positive
+00001f30: 2069 7320 646f 776e 2069 6e20 696d 6167   is down in imag
+00001f40: 6520 7370 6163 6520 6275 7420 6e65 6761  e space but nega
+00001f50: 7469 7665 2069 6e20 636f 6f72 6469 6e61  tive in coordina
+00001f60: 7465 2073 7061 6365 0a20 2020 2020 2020  te space.       
+00001f70: 2072 6574 7572 6e20 760a 0a20 2020 2040   return v..    @
+00001f80: 7072 6f70 6572 7479 0a20 2020 2064 6566  property.    def
+00001f90: 2062 625f 6570 6964 5f76 6563 746f 725f   bb_epid_vector_
+00001fa0: 6d6d 2873 656c 6629 202d 3e20 5665 6374  mm(self) -> Vect
+00001fb0: 6f72 3a0a 2020 2020 2020 2020 2222 2254  or:.        """T
+00001fc0: 6865 2076 6563 746f 7220 6672 6f6d 2074  he vector from t
+00001fd0: 6865 2042 4220 746f 2074 6865 2066 6965  he BB to the fie
+00001fe0: 6c64 2043 4158 202a 494e 2043 4f4f 5244  ld CAX *IN COORD
+00001ff0: 494e 4154 4520 5350 4143 452a 2e22 2222  INATE SPACE*."""
+00002000: 0a20 2020 2020 2020 2076 203d 2028 7365  .        v = (se
+00002010: 6c66 2e62 6220 2d20 7365 6c66 2e65 7069  lf.bb - self.epi
+00002020: 6429 202f 2073 656c 662e 6470 6d6d 0a20  d) / self.dpmm. 
+00002030: 2020 2020 2020 2076 2e79 203d 2028 0a20         v.y = (. 
+00002040: 2020 2020 2020 2020 2020 202d 762e 790a             -v.y.
+00002050: 2020 2020 2020 2020 2920 2023 2069 6e76          )  # inv
+00002060: 6572 7420 7468 6520 792d 6178 6973 3b20  ert the y-axis; 
+00002070: 706f 7369 7469 7665 2069 7320 646f 776e  positive is down
+00002080: 2069 6e20 696d 6167 6520 7370 6163 6520   in image space 
+00002090: 6275 7420 6e65 6761 7469 7665 2069 6e20  but negative in 
+000020a0: 636f 6f72 6469 6e61 7465 2073 7061 6365  coordinate space
+000020b0: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
+000020c0: 760a 0a20 2020 2040 7072 6f70 6572 7479  v..    @property
+000020d0: 0a20 2020 2064 6566 2062 625f 6669 656c  .    def bb_fiel
+000020e0: 645f 6469 7374 616e 6365 5f6d 6d28 7365  d_distance_mm(se
+000020f0: 6c66 2920 2d3e 2066 6c6f 6174 3a0a 2020  lf) -> float:.  
+00002100: 2020 2020 2020 2222 2254 6865 2064 6973        """The dis
+00002110: 7461 6e63 6520 6672 6f6d 2074 6865 2042  tance from the B
+00002120: 4220 746f 2074 6865 2066 6965 6c64 2043  B to the field C
+00002130: 4158 2069 6e20 6d6d 2e22 2222 0a20 2020  AX in mm.""".   
+00002140: 2020 2020 2072 6574 7572 6e20 7365 6c66       return self
+00002150: 2e66 6965 6c64 2e64 6973 7461 6e63 655f  .field.distance_
+00002160: 746f 2873 656c 662e 6262 2920 2f20 7365  to(self.bb) / se
+00002170: 6c66 2e64 706d 6d0a 0a20 2020 2040 7072  lf.dpmm..    @pr
+00002180: 6f70 6572 7479 0a20 2020 2064 6566 2062  operty.    def b
+00002190: 625f 6570 6964 5f64 6973 7461 6e63 655f  b_epid_distance_
+000021a0: 6d6d 2873 656c 6629 202d 3e20 666c 6f61  mm(self) -> floa
+000021b0: 743a 0a20 2020 2020 2020 2022 2222 5468  t:.        """Th
+000021c0: 6520 6469 7374 616e 6365 2066 726f 6d20  e distance from 
+000021d0: 7468 6520 4242 2074 6f20 7468 6520 4550  the BB to the EP
+000021e0: 4944 2063 656e 7465 7220 696e 206d 6d2e  ID center in mm.
+000021f0: 2222 220a 2020 2020 2020 2020 7265 7475  """.        retu
+00002200: 726e 2073 656c 662e 6570 6964 2e64 6973  rn self.epid.dis
+00002210: 7461 6e63 655f 746f 2873 656c 662e 6262  tance_to(self.bb
+00002220: 2920 2f20 7365 6c66 2e64 706d 6d0a 0a20  ) / self.dpmm.. 
+00002230: 2020 2040 7072 6f70 6572 7479 0a20 2020     @property.   
+00002240: 2064 6566 2066 6965 6c64 5f65 7069 645f   def field_epid_
+00002250: 6469 7374 616e 6365 5f6d 6d28 7365 6c66  distance_mm(self
+00002260: 2920 2d3e 2066 6c6f 6174 3a0a 2020 2020  ) -> float:.    
+00002270: 2020 2020 2222 2254 6865 2064 6973 7461      """The dista
+00002280: 6e63 6520 6672 6f6d 2074 6865 2066 6965  nce from the fie
+00002290: 6c64 2043 4158 2074 6f20 7468 6520 4550  ld CAX to the EP
+000022a0: 4944 2063 656e 7465 7220 696e 206d 6d2e  ID center in mm.
+000022b0: 2222 220a 2020 2020 2020 2020 7265 7475  """.        retu
+000022c0: 726e 2073 656c 662e 6570 6964 2e64 6973  rn self.epid.dis
+000022d0: 7461 6e63 655f 746f 2873 656c 662e 6669  tance_to(self.fi
+000022e0: 656c 6429 202f 2073 656c 662e 6470 6d6d  eld) / self.dpmm
+000022f0: 0a0a 2020 2020 4070 726f 7065 7274 790a  ..    @property.
+00002300: 2020 2020 6465 6620 6262 5f74 6f5f 6669      def bb_to_fi
+00002310: 656c 645f 7072 6f6a 6563 7469 6f6e 2873  eld_projection(s
+00002320: 656c 6629 3a0a 2020 2020 2020 2020 2222  elf):.        ""
+00002330: 2254 6865 2070 726f 6a65 6374 696f 6e20  "The projection 
+00002340: 6672 6f6d 2074 6865 2042 4220 746f 2074  from the BB to t
+00002350: 6865 2066 6965 6c64 2e20 5573 6564 2062  he field. Used b
+00002360: 7920 7661 6e69 6c6c 6120 574c 0a20 2020  y vanilla WL.   
+00002370: 2020 2020 2074 6f20 6465 7465 726d 696e       to determin
+00002380: 6520 7468 6520 6761 6e74 7279 2c20 636f  e the gantry, co
+00002390: 6c6c 2c20 636f 7563 6820 6973 6f63 656e  ll, couch isocen
+000023a0: 7465 7220 7369 7a65 2062 6563 6175 7365  ter size because
+000023b0: 2074 6865 7265 2074 6865 2042 4220 6973   there the BB is
+000023c0: 2074 6865 2072 6566 6572 656e 6365 2070   the reference p
+000023d0: 6f69 6e74 2e0a 0a20 2020 2020 2020 2052  oint...        R
+000023e0: 6574 7572 6e73 0a20 2020 2020 2020 202d  eturns.        -
+000023f0: 2d2d 2d2d 2d2d 0a20 2020 2020 2020 204c  ------.        L
+00002400: 696e 650a 2020 2020 2020 2020 2020 2020  ine.            
+00002410: 5468 6520 7669 7274 7561 6c20 6c69 6e65  The virtual line
+00002420: 2069 6e20 7370 6163 6520 6d61 6465 2062   in space made b
+00002430: 7920 7468 6520 4242 2e0a 2020 2020 2020  y the BB..      
+00002440: 2020 2222 220a 2020 2020 2020 2020 7265    """.        re
+00002450: 7475 726e 2073 7472 6169 6768 745f 7261  turn straight_ra
+00002460: 7928 7365 6c66 2e62 625f 6669 656c 645f  y(self.bb_field_
+00002470: 7665 6374 6f72 5f6d 6d2c 2073 656c 662e  vector_mm, self.
+00002480: 6761 6e74 7279 5f61 6e67 6c65 290a 0a0a  gantry_angle)...
+00002490: 636c 6173 7320 4242 3344 3a0a 2020 2020  class BB3D:.    
+000024a0: 2222 2241 2072 6570 7265 7365 6e74 6174  """A representat
+000024b0: 696f 6e20 6f66 2061 2042 4220 696e 2033  ion of a BB in 3
+000024c0: 4420 7370 6163 6522 2222 0a0a 2020 2020  D space"""..    
+000024d0: 6465 6620 5f5f 7265 7072 5f5f 2873 656c  def __repr__(sel
+000024e0: 6629 3a0a 2020 2020 2020 2020 7265 7475  f):.        retu
+000024f0: 726e 2073 656c 662e 6e6f 6d69 6e61 6c5f  rn self.nominal_
+00002500: 6262 5f70 6f73 6974 696f 6e0a 0a20 2020  bb_position..   
+00002510: 2064 6566 205f 5f69 6e69 745f 5f28 0a20   def __init__(. 
+00002520: 2020 2020 2020 2073 656c 662c 0a20 2020         self,.   
+00002530: 2020 2020 2062 625f 636f 6e66 6967 3a20       bb_config: 
+00002540: 4242 436f 6e66 6967 2c0a 2020 2020 2020  BBConfig,.      
+00002550: 2020 6262 5f6d 6174 6368 6573 3a20 5365    bb_matches: Se
+00002560: 7175 656e 6365 5b42 4246 6965 6c64 4d61  quence[BBFieldMa
+00002570: 7463 682c 202e 2e2e 5d2c 0a20 2020 2020  tch, ...],.     
+00002580: 2020 2073 6361 6c65 3a20 4d61 6368 696e     scale: Machin
+00002590: 6553 6361 6c65 2c0a 2020 2020 293a 0a20  eScale,.    ):. 
+000025a0: 2020 2020 2020 2073 656c 662e 6262 5f63         self.bb_c
+000025b0: 6f6e 6669 6720 3d20 6262 5f63 6f6e 6669  onfig = bb_confi
+000025c0: 670a 2020 2020 2020 2020 7365 6c66 2e6d  g.        self.m
+000025d0: 6174 6368 6573 203d 2062 625f 6d61 7463  atches = bb_matc
+000025e0: 6865 730a 2020 2020 2020 2020 7365 6c66  hes.        self
+000025f0: 2e73 6361 6c65 203d 2073 6361 6c65 0a0a  .scale = scale..
+00002600: 2020 2020 4063 6163 6865 645f 7072 6f70      @cached_prop
+00002610: 6572 7479 0a20 2020 2064 6566 206d 6561  erty.    def mea
+00002620: 7375 7265 645f 6262 5f70 6f73 6974 696f  sured_bb_positio
+00002630: 6e28 7365 6c66 2920 2d3e 2050 6f69 6e74  n(self) -> Point
+00002640: 3a0a 2020 2020 2020 2020 2222 2254 6865  :.        """The
+00002650: 2033 4420 6d65 6173 7572 6564 2070 6f73   3D measured pos
+00002660: 6974 696f 6e20 6f66 2074 6865 2042 4220  ition of the BB 
+00002670: 6261 7365 6420 6f6e 2072 6f74 6174 696f  based on rotatio
+00002680: 6e20 6d61 7472 6963 6573 2061 6e64 2067  n matrices and g
+00002690: 616e 7472 792f 636f 7563 6820 616e 676c  antry/couch angl
+000026a0: 6573 2e22 2222 0a20 2020 2020 2020 2078  es.""".        x
+000026b0: 7320 3d20 5b6d 2e62 625f 6570 6964 5f76  s = [m.bb_epid_v
+000026c0: 6563 746f 725f 6d6d 2e78 2066 6f72 206d  ector_mm.x for m
+000026d0: 2069 6e20 7365 6c66 2e6d 6174 6368 6573   in self.matches
+000026e0: 5d0a 2020 2020 2020 2020 7973 203d 205b  ].        ys = [
+000026f0: 6d2e 6262 5f65 7069 645f 7665 6374 6f72  m.bb_epid_vector
+00002700: 5f6d 6d2e 7920 666f 7220 6d20 696e 2073  _mm.y for m in s
+00002710: 656c 662e 6d61 7463 6865 735d 0a20 2020  elf.matches].   
+00002720: 2020 2020 2074 6865 7461 7320 3d20 5b6d       thetas = [m
+00002730: 2e67 616e 7472 795f 616e 676c 6520 666f  .gantry_angle fo
+00002740: 7220 6d20 696e 2073 656c 662e 6d61 7463  r m in self.matc
+00002750: 6865 735d 0a20 2020 2020 2020 2070 6869  hes].        phi
+00002760: 7320 3d20 5b6d 2e63 6f75 6368 5f61 6e67  s = [m.couch_ang
+00002770: 6c65 2066 6f72 206d 2069 6e20 7365 6c66  le for m in self
+00002780: 2e6d 6174 6368 6573 5d0a 2020 2020 2020  .matches].      
+00002790: 2020 7665 6374 6f72 203d 2073 6f6c 7665    vector = solve
+000027a0: 5f33 645f 706f 7369 7469 6f6e 5f66 726f  _3d_position_fro
+000027b0: 6d5f 3264 5f70 6c61 6e65 7328 0a20 2020  m_2d_planes(.   
+000027c0: 2020 2020 2020 2020 2078 733d 7873 2c20           xs=xs, 
+000027d0: 7973 3d79 732c 2074 6865 7461 733d 7468  ys=ys, thetas=th
+000027e0: 6574 6173 2c20 7068 6973 3d70 6869 732c  etas, phis=phis,
+000027f0: 2073 6361 6c65 3d73 656c 662e 7363 616c   scale=self.scal
+00002800: 650a 2020 2020 2020 2020 290a 2020 2020  e.        ).    
+00002810: 2020 2020 2320 7665 6374 6f72 7320 616e      # vectors an
+00002820: 6420 706f 696e 7473 2061 7265 2065 6666  d points are eff
+00002830: 6563 7469 7665 6c79 2074 6865 2073 616d  ectively the sam
+00002840: 6520 7468 696e 6720 6865 7265 2062 7574  e thing here but
+00002850: 2077 6520 636f 6e76 6572 7420 746f 2061   we convert to a
+00002860: 2070 6f69 6e74 2066 6f72 2063 6c61 7269   point for clari
+00002870: 7479 0a20 2020 2020 2020 2072 6574 7572  ty.        retur
+00002880: 6e20 506f 696e 7428 783d 7665 6374 6f72  n Point(x=vector
+00002890: 2e78 2c20 793d 7665 6374 6f72 2e79 2c20  .x, y=vector.y, 
+000028a0: 7a3d 7665 6374 6f72 2e7a 290a 0a20 2020  z=vector.z)..   
+000028b0: 2040 6361 6368 6564 5f70 726f 7065 7274   @cached_propert
+000028c0: 790a 2020 2020 6465 6620 6e6f 6d69 6e61  y.    def nomina
+000028d0: 6c5f 6262 5f70 6f73 6974 696f 6e28 7365  l_bb_position(se
+000028e0: 6c66 2920 2d3e 2050 6f69 6e74 3a0a 2020  lf) -> Point:.  
+000028f0: 2020 2020 2020 2222 2254 6865 206e 6f6d        """The nom
+00002900: 696e 616c 206c 6f63 6174 696f 6e20 6f66  inal location of
+00002910: 2074 6865 2042 4220 696e 204d 4d20 696e   the BB in MM in
+00002920: 2063 6f6f 7264 696e 6174 6520 7370 6163   coordinate spac
+00002930: 6522 2222 0a20 2020 2020 2020 2072 6574  e""".        ret
+00002940: 7572 6e20 506f 696e 7428 0a20 2020 2020  urn Point(.     
+00002950: 2020 2020 2020 2078 3d2d 7365 6c66 2e62         x=-self.b
+00002960: 625f 636f 6e66 6967 2e6f 6666 7365 745f  b_config.offset_
+00002970: 6c65 6674 5f6d 6d2c 0a20 2020 2020 2020  left_mm,.       
+00002980: 2020 2020 2079 3d73 656c 662e 6262 5f63       y=self.bb_c
+00002990: 6f6e 6669 672e 6f66 6673 6574 5f69 6e5f  onfig.offset_in_
+000029a0: 6d6d 2c0a 2020 2020 2020 2020 2020 2020  mm,.            
+000029b0: 7a3d 7365 6c66 2e62 625f 636f 6e66 6967  z=self.bb_config
+000029c0: 2e6f 6666 7365 745f 7570 5f6d 6d2c 0a20  .offset_up_mm,. 
+000029d0: 2020 2020 2020 2029 0a0a 2020 2020 4063         )..    @c
+000029e0: 6163 6865 645f 7072 6f70 6572 7479 0a20  ached_property. 
+000029f0: 2020 2064 6566 206d 6561 7375 7265 645f     def measured_
+00002a00: 6669 656c 645f 706f 7369 7469 6f6e 2873  field_position(s
+00002a10: 656c 6629 202d 3e20 506f 696e 743a 0a20  elf) -> Point:. 
+00002a20: 2020 2020 2020 2022 2222 5468 6520 706f         """The po
+00002a30: 7369 7469 6f6e 206f 6620 7468 6520 6669  sition of the fi
+00002a40: 656c 6420 4341 5873 2069 6e20 3344 2073  eld CAXs in 3D s
+00002a50: 7061 6365 2222 220a 2020 2020 2020 2020  pace""".        
+00002a60: 7873 203d 205b 6d2e 6669 656c 645f 6570  xs = [m.field_ep
+00002a70: 6964 5f76 6563 746f 725f 6d6d 2e78 2066  id_vector_mm.x f
+00002a80: 6f72 206d 2069 6e20 7365 6c66 2e6d 6174  or m in self.mat
+00002a90: 6368 6573 5d0a 2020 2020 2020 2020 7973  ches].        ys
+00002aa0: 203d 205b 6d2e 6669 656c 645f 6570 6964   = [m.field_epid
+00002ab0: 5f76 6563 746f 725f 6d6d 2e79 2066 6f72  _vector_mm.y for
+00002ac0: 206d 2069 6e20 7365 6c66 2e6d 6174 6368   m in self.match
+00002ad0: 6573 5d0a 2020 2020 2020 2020 7468 6574  es].        thet
+00002ae0: 6173 203d 205b 6d2e 6761 6e74 7279 5f61  as = [m.gantry_a
+00002af0: 6e67 6c65 2066 6f72 206d 2069 6e20 7365  ngle for m in se
+00002b00: 6c66 2e6d 6174 6368 6573 5d0a 2020 2020  lf.matches].    
+00002b10: 2020 2020 7068 6973 203d 205b 6d2e 636f      phis = [m.co
+00002b20: 7563 685f 616e 676c 6520 666f 7220 6d20  uch_angle for m 
+00002b30: 696e 2073 656c 662e 6d61 7463 6865 735d  in self.matches]
+00002b40: 0a20 2020 2020 2020 2076 6563 746f 7220  .        vector 
+00002b50: 3d20 736f 6c76 655f 3364 5f70 6f73 6974  = solve_3d_posit
+00002b60: 696f 6e5f 6672 6f6d 5f32 645f 706c 616e  ion_from_2d_plan
+00002b70: 6573 280a 2020 2020 2020 2020 2020 2020  es(.            
+00002b80: 7873 3d78 732c 2079 733d 7973 2c20 7468  xs=xs, ys=ys, th
+00002b90: 6574 6173 3d74 6865 7461 732c 2070 6869  etas=thetas, phi
+00002ba0: 733d 7068 6973 2c20 7363 616c 653d 7365  s=phis, scale=se
+00002bb0: 6c66 2e73 6361 6c65 0a20 2020 2020 2020  lf.scale.       
+00002bc0: 2029 0a20 2020 2020 2020 2023 2076 6563   ).        # vec
+00002bd0: 746f 7273 2061 6e64 2070 6f69 6e74 7320  tors and points 
+00002be0: 6172 6520 6566 6665 6374 6976 656c 7920  are effectively 
+00002bf0: 7468 6520 7361 6d65 2074 6869 6e67 2068  the same thing h
+00002c00: 6572 6520 6275 7420 7765 2063 6f6e 7665  ere but we conve
+00002c10: 7274 2074 6f20 6120 706f 696e 7420 666f  rt to a point fo
+00002c20: 7220 636c 6172 6974 790a 2020 2020 2020  r clarity.      
+00002c30: 2020 7265 7475 726e 2050 6f69 6e74 2878    return Point(x
+00002c40: 3d76 6563 746f 722e 782c 2079 3d76 6563  =vector.x, y=vec
+00002c50: 746f 722e 792c 207a 3d76 6563 746f 722e  tor.y, z=vector.
+00002c60: 7a29 0a0a 2020 2020 6465 6620 706c 6f74  z)..    def plot
+00002c70: 5f6e 6f6d 696e 616c 2873 656c 662c 2061  _nominal(self, a
+00002c80: 7865 733a 2070 6c74 2e41 7865 732c 2063  xes: plt.Axes, c
+00002c90: 6f6c 6f72 3a20 7374 722c 202a 2a6b 7761  olor: str, **kwa
+00002ca0: 7267 7329 3a0a 2020 2020 2020 2020 2222  rgs):.        ""
+00002cb0: 2250 6c6f 7420 7468 6520 4242 206e 6f6d  "Plot the BB nom
+00002cc0: 696e 616c 2070 6f73 6974 696f 6e22 2222  inal position"""
+00002cd0: 0a20 2020 2020 2020 2078 2c20 792c 207a  .        x, y, z
+00002ce0: 203d 2063 7265 6174 655f 7370 6865 7265   = create_sphere
+00002cf0: 5f73 7572 6661 6365 280a 2020 2020 2020  _surface(.      
+00002d00: 2020 2020 2020 7261 6469 7573 3d73 656c        radius=sel
+00002d10: 662e 6262 5f63 6f6e 6669 672e 6262 5f73  f.bb_config.bb_s
+00002d20: 697a 655f 6d6d 202f 2032 2c20 6365 6e74  ize_mm / 2, cent
+00002d30: 6572 3d73 656c 662e 6e6f 6d69 6e61 6c5f  er=self.nominal_
+00002d40: 6262 5f70 6f73 6974 696f 6e0a 2020 2020  bb_position.    
+00002d50: 2020 2020 290a 2020 2020 2020 2020 6178      ).        ax
+00002d60: 6573 2e70 6c6f 745f 7375 7266 6163 6528  es.plot_surface(
+00002d70: 782c 2079 2c20 7a2c 2063 6f6c 6f72 3d63  x, y, z, color=c
+00002d80: 6f6c 6f72 2c20 2a2a 6b77 6172 6773 290a  olor, **kwargs).
+00002d90: 0a20 2020 2064 6566 2070 6c6f 745f 6d65  .    def plot_me
+00002da0: 6173 7572 6564 2873 656c 662c 2061 7865  asured(self, axe
+00002db0: 733a 2070 6c74 2e41 7865 732c 2063 6f6c  s: plt.Axes, col
+00002dc0: 6f72 3a20 7374 722c 202a 2a6b 7761 7267  or: str, **kwarg
+00002dd0: 7329 3a0a 2020 2020 2020 2020 2222 2250  s):.        """P
+00002de0: 6c6f 7420 7468 6520 4242 206d 6561 7375  lot the BB measu
+00002df0: 7265 6420 706f 7369 7469 6f6e 2222 220a  red position""".
+00002e00: 2020 2020 2020 2020 782c 2079 2c20 7a20          x, y, z 
+00002e10: 3d20 6372 6561 7465 5f73 7068 6572 655f  = create_sphere_
+00002e20: 7375 7266 6163 6528 0a20 2020 2020 2020  surface(.       
+00002e30: 2020 2020 2072 6164 6975 733d 7365 6c66       radius=self
+00002e40: 2e62 625f 636f 6e66 6967 2e62 625f 7369  .bb_config.bb_si
+00002e50: 7a65 5f6d 6d20 2f20 322c 2063 656e 7465  ze_mm / 2, cente
+00002e60: 723d 7365 6c66 2e6d 6561 7375 7265 645f  r=self.measured_
+00002e70: 6262 5f70 6f73 6974 696f 6e0a 2020 2020  bb_position.    
+00002e80: 2020 2020 290a 2020 2020 2020 2020 6178      ).        ax
+00002e90: 6573 2e70 6c6f 745f 7375 7266 6163 6528  es.plot_surface(
+00002ea0: 782c 2079 2c20 7a2c 2063 6f6c 6f72 3d63  x, y, z, color=c
+00002eb0: 6f6c 6f72 2c20 2a2a 6b77 6172 6773 290a  olor, **kwargs).
+00002ec0: 0a0a 6465 6620 6372 6561 7465 5f73 7068  ..def create_sph
+00002ed0: 6572 655f 7375 7266 6163 6528 0a20 2020  ere_surface(.   
+00002ee0: 2072 6164 6975 733a 2066 6c6f 6174 2c20   radius: float, 
+00002ef0: 6365 6e74 6572 3a20 506f 696e 740a 2920  center: Point.) 
+00002f00: 2d3e 2074 7570 6c65 5b6e 702e 6e64 6172  -> tuple[np.ndar
+00002f10: 7261 792c 206e 702e 6e64 6172 7261 792c  ray, np.ndarray,
+00002f20: 206e 702e 6e64 6172 7261 795d 3a0a 2020   np.ndarray]:.  
+00002f30: 2020 2222 2243 7265 6174 6520 6120 7370    """Create a sp
+00002f40: 6865 7265 2073 7572 6661 6365 2066 6f72  here surface for
+00002f50: 2070 6c6f 7474 696e 6722 2222 0a20 2020   plotting""".   
+00002f60: 2075 203d 206e 702e 6c69 6e73 7061 6365   u = np.linspace
+00002f70: 2830 2c20 3220 2a20 6e70 2e70 692c 2031  (0, 2 * np.pi, 1
+00002f80: 3030 290a 2020 2020 7620 3d20 6e70 2e6c  00).    v = np.l
+00002f90: 696e 7370 6163 6528 302c 206e 702e 7069  inspace(0, np.pi
+00002fa0: 2c20 3130 3029 0a20 2020 2078 203d 2072  , 100).    x = r
+00002fb0: 6164 6975 7320 2a20 6e70 2e6f 7574 6572  adius * np.outer
+00002fc0: 286e 702e 636f 7328 7529 2c20 6e70 2e73  (np.cos(u), np.s
+00002fd0: 696e 2876 2929 202b 2063 656e 7465 722e  in(v)) + center.
+00002fe0: 780a 2020 2020 7920 3d20 7261 6469 7573  x.    y = radius
+00002ff0: 202a 206e 702e 6f75 7465 7228 6e70 2e73   * np.outer(np.s
+00003000: 696e 2875 292c 206e 702e 7369 6e28 7629  in(u), np.sin(v)
+00003010: 2920 2b20 6365 6e74 6572 2e79 0a20 2020  ) + center.y.   
+00003020: 207a 203d 2072 6164 6975 7320 2a20 6e70   z = radius * np
+00003030: 2e6f 7574 6572 286e 702e 6f6e 6573 286e  .outer(np.ones(n
+00003040: 702e 7369 7a65 2875 2929 2c20 6e70 2e63  p.size(u)), np.c
+00003050: 6f73 2876 2929 202b 2063 656e 7465 722e  os(v)) + center.
+00003060: 7a0a 2020 2020 7265 7475 726e 2078 2c20  z.    return x, 
+00003070: 792c 207a 0a0a 0a63 6c61 7373 2041 7869  y, z...class Axi
+00003080: 7328 656e 756d 2e45 6e75 6d29 3a0a 2020  s(enum.Enum):.  
+00003090: 2020 4741 4e54 5259 203d 2022 4761 6e74    GANTRY = "Gant
+000030a0: 7279 2220 2023 3a0a 2020 2020 434f 4c4c  ry"  #:.    COLL
+000030b0: 494d 4154 4f52 203d 2022 436f 6c6c 696d  IMATOR = "Collim
+000030c0: 6174 6f72 2220 2023 3a0a 2020 2020 434f  ator"  #:.    CO
+000030d0: 5543 4820 3d20 2243 6f75 6368 2220 2023  UCH = "Couch"  #
+000030e0: 3a0a 2020 2020 4742 5f43 4f4d 424f 203d  :.    GB_COMBO =
+000030f0: 2022 4742 2043 6f6d 626f 2220 2023 3a0a   "GB Combo"  #:.
+00003100: 2020 2020 4742 505f 434f 4d42 4f20 3d20      GBP_COMBO = 
+00003110: 2247 4250 2043 6f6d 626f 2220 2023 3a0a  "GBP Combo"  #:.
+00003120: 2020 2020 4550 4944 203d 2022 4570 6964      EPID = "Epid
+00003130: 2220 2023 3a0a 2020 2020 5245 4645 5245  "  #:.    REFERE
+00003140: 4e43 4520 3d20 2252 6566 6572 656e 6365  NCE = "Reference
+00003150: 2220 2023 3a0a 0a0a 636c 6173 7320 5769  "  #:...class Wi
+00003160: 6e73 746f 6e4c 7574 7a32 4452 6573 756c  nstonLutz2DResul
+00003170: 7428 5265 7375 6c74 4261 7365 293a 0a20  t(ResultBase):. 
+00003180: 2020 2076 6172 6961 626c 655f 6178 6973     variable_axis
+00003190: 3a20 7374 7220 2023 3a0a 2020 2020 6262  : str  #:.    bb
+000031a0: 5f6c 6f63 6174 696f 6e3a 2050 6f69 6e74  _location: Point
+000031b0: 5365 7269 616c 697a 6564 2020 233a 0a20  Serialized  #:. 
+000031c0: 2020 2063 6178 3265 7069 645f 7665 6374     cax2epid_vect
+000031d0: 6f72 3a20 5665 6374 6f72 5365 7269 616c  or: VectorSerial
+000031e0: 697a 6564 2020 233a 0a20 2020 2063 6178  ized  #:.    cax
+000031f0: 3265 7069 645f 6469 7374 616e 6365 3a20  2epid_distance: 
+00003200: 666c 6f61 7420 2023 3a0a 2020 2020 6361  float  #:.    ca
+00003210: 7832 6262 5f64 6973 7461 6e63 653a 2066  x2bb_distance: f
+00003220: 6c6f 6174 2020 233a 0a20 2020 2063 6178  loat  #:.    cax
+00003230: 3262 625f 7665 6374 6f72 3a20 5665 6374  2bb_vector: Vect
+00003240: 6f72 5365 7269 616c 697a 6564 2020 233a  orSerialized  #:
+00003250: 0a20 2020 2066 6965 6c64 5f63 6178 3a20  .    field_cax: 
+00003260: 506f 696e 7453 6572 6961 6c69 7a65 6420  PointSerialized 
+00003270: 2023 3a0a 0a0a 636c 6173 7320 5769 6e73   #:...class Wins
+00003280: 746f 6e4c 7574 7a52 6573 756c 7428 5265  tonLutzResult(Re
+00003290: 7375 6c74 4261 7365 293a 0a20 2020 2022  sultBase):.    "
+000032a0: 2222 5468 6973 2063 6c61 7373 2073 686f  ""This class sho
+000032b0: 756c 6420 6e6f 7420 6265 2063 616c 6c65  uld not be calle
+000032c0: 6420 6469 7265 6374 6c79 2e20 4974 2069  d directly. It i
+000032d0: 7320 7265 7475 726e 6564 2062 7920 7468  s returned by th
+000032e0: 6520 6060 7265 7375 6c74 735f 6461 7461  e ``results_data
+000032f0: 2829 6060 206d 6574 686f 642e 0a20 2020  ()`` method..   
+00003300: 2049 7420 6973 2061 2064 6174 6163 6c61   It is a datacla
+00003310: 7373 2075 6e64 6572 2074 6865 2068 6f6f  ss under the hoo
+00003320: 6420 616e 6420 7468 7573 2063 6f6d 6573  d and thus comes
+00003330: 2077 6974 6820 616c 6c20 7468 6520 6475   with all the du
+00003340: 6e64 6572 206d 6167 6963 2e0a 0a20 2020  nder magic...   
+00003350: 2055 7365 2074 6865 2066 6f6c 6c6f 7769   Use the followi
+00003360: 6e67 2061 7474 7269 6275 7465 7320 6173  ng attributes as
+00003370: 206e 6f72 6d61 6c20 636c 6173 7320 6174   normal class at
+00003380: 7472 6962 7574 6573 2e22 2222 0a0a 2020  tributes."""..  
+00003390: 2020 6e75 6d5f 6761 6e74 7279 5f69 6d61    num_gantry_ima
+000033a0: 6765 733a 2069 6e74 2020 233a 0a20 2020  ges: int  #:.   
+000033b0: 206e 756d 5f67 616e 7472 795f 636f 6c6c   num_gantry_coll
+000033c0: 5f69 6d61 6765 733a 2069 6e74 2020 233a  _images: int  #:
+000033d0: 0a20 2020 206e 756d 5f63 6f6c 6c5f 696d  .    num_coll_im
+000033e0: 6167 6573 3a20 696e 7420 2023 3a0a 2020  ages: int  #:.  
+000033f0: 2020 6e75 6d5f 636f 7563 685f 696d 6167    num_couch_imag
+00003400: 6573 3a20 696e 7420 2023 3a0a 2020 2020  es: int  #:.    
+00003410: 6e75 6d5f 746f 7461 6c5f 696d 6167 6573  num_total_images
+00003420: 3a20 696e 7420 2023 3a0a 2020 2020 6d61  : int  #:.    ma
+00003430: 785f 3264 5f63 6178 5f74 6f5f 6262 5f6d  x_2d_cax_to_bb_m
+00003440: 6d3a 2066 6c6f 6174 2020 233a 0a20 2020  m: float  #:.   
+00003450: 206d 6564 6961 6e5f 3264 5f63 6178 5f74   median_2d_cax_t
+00003460: 6f5f 6262 5f6d 6d3a 2066 6c6f 6174 2020  o_bb_mm: float  
+00003470: 233a 0a20 2020 206d 6561 6e5f 3264 5f63  #:.    mean_2d_c
+00003480: 6178 5f74 6f5f 6262 5f6d 6d3a 2066 6c6f  ax_to_bb_mm: flo
+00003490: 6174 2020 233a 0a20 2020 206d 6178 5f32  at  #:.    max_2
+000034a0: 645f 6361 785f 746f 5f65 7069 645f 6d6d  d_cax_to_epid_mm
+000034b0: 3a20 666c 6f61 7420 2023 3a0a 2020 2020  : float  #:.    
+000034c0: 6d65 6469 616e 5f32 645f 6361 785f 746f  median_2d_cax_to
+000034d0: 5f65 7069 645f 6d6d 3a20 666c 6f61 7420  _epid_mm: float 
+000034e0: 2023 3a0a 2020 2020 6d65 616e 5f32 645f   #:.    mean_2d_
+000034f0: 6361 785f 746f 5f65 7069 645f 6d6d 3a20  cax_to_epid_mm: 
+00003500: 666c 6f61 7420 2023 3a0a 2020 2020 6761  float  #:.    ga
+00003510: 6e74 7279 5f33 645f 6973 6f5f 6469 616d  ntry_3d_iso_diam
+00003520: 6574 6572 5f6d 6d3a 2066 6c6f 6174 2020  eter_mm: float  
+00003530: 233a 0a20 2020 206d 6178 5f67 616e 7472  #:.    max_gantr
+00003540: 795f 726d 735f 6465 7669 6174 696f 6e5f  y_rms_deviation_
+00003550: 6d6d 3a20 666c 6f61 7420 2023 3a0a 2020  mm: float  #:.  
+00003560: 2020 6d61 785f 6570 6964 5f72 6d73 5f64    max_epid_rms_d
+00003570: 6576 6961 7469 6f6e 5f6d 6d3a 2066 6c6f  eviation_mm: flo
+00003580: 6174 2020 233a 0a20 2020 2067 616e 7472  at  #:.    gantr
+00003590: 795f 636f 6c6c 5f33 645f 6973 6f5f 6469  y_coll_3d_iso_di
+000035a0: 616d 6574 6572 5f6d 6d3a 2066 6c6f 6174  ameter_mm: float
+000035b0: 2020 233a 0a20 2020 2063 6f6c 6c5f 3264    #:.    coll_2d
+000035c0: 5f69 736f 5f64 6961 6d65 7465 725f 6d6d  _iso_diameter_mm
+000035d0: 3a20 666c 6f61 7420 2023 3a0a 2020 2020  : float  #:.    
+000035e0: 6d61 785f 636f 6c6c 5f72 6d73 5f64 6576  max_coll_rms_dev
+000035f0: 6961 7469 6f6e 5f6d 6d3a 2066 6c6f 6174  iation_mm: float
+00003600: 2020 233a 0a20 2020 2063 6f75 6368 5f32    #:.    couch_2
+00003610: 645f 6973 6f5f 6469 616d 6574 6572 5f6d  d_iso_diameter_m
+00003620: 6d3a 2066 6c6f 6174 2020 233a 0a20 2020  m: float  #:.   
+00003630: 206d 6178 5f63 6f75 6368 5f72 6d73 5f64   max_couch_rms_d
+00003640: 6576 6961 7469 6f6e 5f6d 6d3a 2066 6c6f  eviation_mm: flo
+00003650: 6174 2020 233a 0a20 2020 2069 6d61 6765  at  #:.    image
+00003660: 5f64 6574 6169 6c73 3a20 6c69 7374 5b57  _details: list[W
+00003670: 696e 7374 6f6e 4c75 747a 3244 5265 7375  instonLutz2DResu
+00003680: 6c74 5d20 2023 3a0a 2020 2020 6b65 7965  lt]  #:.    keye
+00003690: 645f 696d 6167 655f 6465 7461 696c 733a  d_image_details:
+000036a0: 2064 6963 745b 7374 722c 2057 696e 7374   dict[str, Winst
+000036b0: 6f6e 4c75 747a 3244 5265 7375 6c74 5d20  onLutz2DResult] 
+000036c0: 2023 3a0a 0a0a 636c 6173 7320 5769 6e73   #:...class Wins
+000036d0: 746f 6e4c 7574 7a4d 756c 7469 5461 7267  tonLutzMultiTarg
+000036e0: 6574 4d75 6c74 6946 6965 6c64 5265 7375  etMultiFieldResu
+000036f0: 6c74 2852 6573 756c 7442 6173 6529 3a0a  lt(ResultBase):.
+00003700: 2020 2020 2222 2254 6869 7320 636c 6173      """This clas
+00003710: 7320 7368 6f75 6c64 206e 6f74 2062 6520  s should not be 
+00003720: 6361 6c6c 6564 2064 6972 6563 746c 792e  called directly.
+00003730: 2049 7420 6973 2072 6574 7572 6e65 6420   It is returned 
+00003740: 6279 2074 6865 2060 6072 6573 756c 7473  by the ``results
+00003750: 5f64 6174 6128 2960 6020 6d65 7468 6f64  _data()`` method
+00003760: 2e0a 2020 2020 4974 2069 7320 6120 6461  ..    It is a da
+00003770: 7461 636c 6173 7320 756e 6465 7220 7468  taclass under th
+00003780: 6520 686f 6f64 2061 6e64 2074 6875 7320  e hood and thus 
+00003790: 636f 6d65 7320 7769 7468 2061 6c6c 2074  comes with all t
+000037a0: 6865 2064 756e 6465 7220 6d61 6769 632e  he dunder magic.
+000037b0: 0a0a 2020 2020 5573 6520 7468 6520 666f  ..    Use the fo
+000037c0: 6c6c 6f77 696e 6720 6174 7472 6962 7574  llowing attribut
+000037d0: 6573 2061 7320 6e6f 726d 616c 2063 6c61  es as normal cla
+000037e0: 7373 2061 7474 7269 6275 7465 732e 2222  ss attributes.""
+000037f0: 220a 0a20 2020 206e 756d 5f74 6f74 616c  "..    num_total
+00003800: 5f69 6d61 6765 733a 2069 6e74 2020 233a  _images: int  #:
+00003810: 0a20 2020 206d 6178 5f32 645f 6669 656c  .    max_2d_fiel
+00003820: 645f 746f 5f62 625f 6d6d 3a20 666c 6f61  d_to_bb_mm: floa
+00003830: 7420 2023 3a0a 2020 2020 6d65 6469 616e  t  #:.    median
+00003840: 5f32 645f 6669 656c 645f 746f 5f62 625f  _2d_field_to_bb_
+00003850: 6d6d 3a20 666c 6f61 7420 2023 3a0a 2020  mm: float  #:.  
+00003860: 2020 6d65 616e 5f32 645f 6669 656c 645f    mean_2d_field_
+00003870: 746f 5f62 625f 6d6d 3a20 666c 6f61 7420  to_bb_mm: float 
+00003880: 2023 3a0a 2020 2020 6262 5f61 7272 616e   #:.    bb_arran
+00003890: 6765 6d65 6e74 3a20 7475 706c 655b 4242  gement: tuple[BB
+000038a0: 436f 6e66 6967 2c20 2e2e 2e5d 2020 233a  Config, ...]  #:
+000038b0: 0a20 2020 2062 625f 6d61 7865 733a 2064  .    bb_maxes: d
+000038c0: 6963 745b 7374 722c 2066 6c6f 6174 5d20  ict[str, float] 
+000038d0: 2023 3a0a 2020 2020 6262 5f73 6869 6674   #:.    bb_shift
+000038e0: 5f76 6563 746f 723a 2056 6563 746f 7253  _vector: VectorS
+000038f0: 6572 6961 6c69 7a65 6420 2023 3a0a 2020  erialized  #:.  
+00003900: 2020 6262 5f73 6869 6674 5f79 6177 3a20    bb_shift_yaw: 
+00003910: 666c 6f61 7420 2023 3a0a 2020 2020 6262  float  #:.    bb
+00003920: 5f73 6869 6674 5f70 6974 6368 3a20 666c  _shift_pitch: fl
+00003930: 6f61 7420 2023 3a0a 2020 2020 6262 5f73  oat  #:.    bb_s
+00003940: 6869 6674 5f72 6f6c 6c3a 2066 6c6f 6174  hift_roll: float
+00003950: 2020 233a 0a0a 0a64 6566 2069 735f 6e65    #:...def is_ne
+00003960: 6172 5f63 656e 7465 7228 7265 6769 6f6e  ar_center(region
+00003970: 3a20 5265 6769 6f6e 5072 6f70 6572 7469  : RegionProperti
+00003980: 6573 2c20 2a61 7267 732c 202a 2a6b 7761  es, *args, **kwa
+00003990: 7267 7329 202d 3e20 626f 6f6c 3a0a 2020  rgs) -> bool:.  
+000039a0: 2020 2222 2257 6865 7468 6572 2074 6865    """Whether the
+000039b0: 2062 6220 6973 203c 3263 6d20 6672 6f6d   bb is <2cm from
+000039c0: 2074 6865 2063 656e 7465 7220 6f66 2074   the center of t
+000039d0: 6865 2066 6965 6c64 2222 220a 2020 2020  he field""".    
+000039e0: 6470 6d6d 203d 206b 7761 7267 735b 2264  dpmm = kwargs["d
+000039f0: 706d 6d22 5d0a 2020 2020 7368 6170 6520  pmm"].    shape 
+00003a00: 3d20 6b77 6172 6773 5b22 7368 6170 6522  = kwargs["shape"
+00003a10: 5d0a 2020 2020 6578 7465 6e74 5f6c 696d  ].    extent_lim
+00003a20: 6974 5f6d 6d20 3d20 3230 0a20 2020 2062  it_mm = 20.    b
+00003a30: 6f74 746f 6d2c 206c 6566 742c 2074 6f70  ottom, left, top
+00003a40: 2c20 7269 6768 7420 3d20 7265 6769 6f6e  , right = region
+00003a50: 2e62 626f 780a 2020 2020 6262 5f63 656e  .bbox.    bb_cen
+00003a60: 7465 725f 7820 3d20 6c65 6674 202b 2028  ter_x = left + (
+00003a70: 7269 6768 7420 2d20 6c65 6674 2920 2f20  right - left) / 
+00003a80: 320a 2020 2020 6262 5f63 656e 7465 725f  2.    bb_center_
+00003a90: 7920 3d20 626f 7474 6f6d 202b 2028 746f  y = bottom + (to
+00003aa0: 7020 2d20 626f 7474 6f6d 2920 2f20 320a  p - bottom) / 2.
+00003ab0: 2020 2020 785f 6c6f 5f6c 696d 6974 203d      x_lo_limit =
+00003ac0: 2073 6861 7065 5b31 5d20 2f20 3220 2d20   shape[1] / 2 - 
+00003ad0: 6470 6d6d 202a 2065 7874 656e 745f 6c69  dpmm * extent_li
+00003ae0: 6d69 745f 6d6d 0a20 2020 2078 5f68 695f  mit_mm.    x_hi_
+00003af0: 6c69 6d69 7420 3d20 7368 6170 655b 315d  limit = shape[1]
+00003b00: 202f 2032 202b 2064 706d 6d20 2a20 6578   / 2 + dpmm * ex
+00003b10: 7465 6e74 5f6c 696d 6974 5f6d 6d0a 2020  tent_limit_mm.  
+00003b20: 2020 6973 5f62 625f 785f 6365 6e74 6572    is_bb_x_center
+00003b30: 6564 203d 2078 5f6c 6f5f 6c69 6d69 7420  ed = x_lo_limit 
+00003b40: 3c20 6262 5f63 656e 7465 725f 7820 3c20  < bb_center_x < 
+00003b50: 785f 6869 5f6c 696d 6974 0a20 2020 2079  x_hi_limit.    y
+00003b60: 5f6c 6f5f 6c69 6d69 7420 3d20 7368 6170  _lo_limit = shap
+00003b70: 655b 305d 202f 2032 202d 2064 706d 6d20  e[0] / 2 - dpmm 
+00003b80: 2a20 6578 7465 6e74 5f6c 696d 6974 5f6d  * extent_limit_m
+00003b90: 6d0a 2020 2020 795f 6869 5f6c 696d 6974  m.    y_hi_limit
+00003ba0: 203d 2073 6861 7065 5b30 5d20 2f20 3220   = shape[0] / 2 
+00003bb0: 2b20 6470 6d6d 202a 2065 7874 656e 745f  + dpmm * extent_
+00003bc0: 6c69 6d69 745f 6d6d 0a20 2020 2069 735f  limit_mm.    is_
+00003bd0: 6262 5f79 5f63 656e 7465 7265 6420 3d20  bb_y_centered = 
+00003be0: 795f 6c6f 5f6c 696d 6974 203c 2062 625f  y_lo_limit < bb_
+00003bf0: 6365 6e74 6572 5f79 203c 2079 5f68 695f  center_y < y_hi_
+00003c00: 6c69 6d69 740a 2020 2020 7265 7475 726e  limit.    return
+00003c10: 2069 735f 6262 5f78 5f63 656e 7465 7265   is_bb_x_centere
+00003c20: 6420 616e 6420 6973 5f62 625f 795f 6365  d and is_bb_y_ce
+00003c30: 6e74 6572 6564 0a0a 0a64 6566 2069 735f  ntered...def is_
+00003c40: 6d6f 6465 7374 5f73 697a 6528 7265 6769  modest_size(regi
+00003c50: 6f6e 3a20 5265 6769 6f6e 5072 6f70 6572  on: RegionProper
+00003c60: 7469 6573 2c20 2a61 7267 732c 202a 2a6b  ties, *args, **k
+00003c70: 7761 7267 7329 202d 3e20 626f 6f6c 3a0a  wargs) -> bool:.
+00003c80: 2020 2020 2222 2244 6563 6964 6520 7768      """Decide wh
+00003c90: 6574 6865 7220 7468 6520 524f 4920 6973  ether the ROI is
+00003ca0: 2072 6f75 6768 6c79 2074 6865 2073 697a   roughly the siz
+00003cb0: 6520 6f66 2061 2042 423b 206e 6f74 206e  e of a BB; not n
+00003cc0: 6f69 7365 2061 6e64 206e 6f74 2061 6e20  oise and not an 
+00003cd0: 6172 7469 6661 6374 2e20 5573 6564 2074  artifact. Used t
+00003ce0: 6f20 6669 6e64 2074 6865 2042 422e 2222  o find the BB.""
+00003cf0: 220a 2020 2020 6262 5f61 7265 6120 3d20  ".    bb_area = 
+00003d00: 7265 6769 6f6e 2e61 7265 615f 6669 6c6c  region.area_fill
+00003d10: 6564 202f 2028 6b77 6172 6773 5b22 6470  ed / (kwargs["dp
+00003d20: 6d6d 225d 202a 2a20 3229 0a20 2020 2062  mm"] ** 2).    b
+00003d30: 625f 7369 7a65 203d 206b 7761 7267 735b  b_size = kwargs[
+00003d40: 2262 625f 7369 7a65 225d 0a20 2020 206c  "bb_size"].    l
+00003d50: 6172 6765 725f 6262 5f61 7265 6120 3d20  arger_bb_area = 
+00003d60: 6e70 2e70 6920 2a20 2828 6262 5f73 697a  np.pi * ((bb_siz
+00003d70: 6520 2b20 3229 202f 2032 2920 2a2a 2032  e + 2) / 2) ** 2
+00003d80: 0a20 2020 2073 6d61 6c6c 6572 5f62 625f  .    smaller_bb_
+00003d90: 6172 6561 203d 206d 6178 280a 2020 2020  area = max(.    
+00003da0: 2020 2020 286e 702e 7069 202a 2028 2862      (np.pi * ((b
+00003db0: 625f 7369 7a65 202d 2032 2920 2f20 3229  b_size - 2) / 2)
+00003dc0: 202a 2a20 322c 2032 290a 2020 2020 2920   ** 2, 2).    ) 
+00003dd0: 2023 2073 6574 2061 206d 696e 206f 6620   # set a min of 
+00003de0: 3220 746f 2061 766f 6964 2061 206c 6f77  2 to avoid a low
+00003df0: 6572 2062 6f75 6e64 206f 6620 3020 7768  er bound of 0 wh
+00003e00: 656e 2072 6164 6975 733d 322e 2054 6869  en radius=2. Thi
+00003e10: 7320 6973 206d 7563 6820 6d6f 7265 206c  s is much more l
+00003e20: 696b 656c 7920 746f 2066 696e 6420 6e6f  ikely to find no
+00003e30: 6973 6520 696e 2061 2062 6c6f 636b 2e0a  ise in a block..
+00003e40: 2020 2020 7265 7475 726e 2073 6d61 6c6c      return small
+00003e50: 6572 5f62 625f 6172 6561 203c 2062 625f  er_bb_area < bb_
+00003e60: 6172 6561 203c 206c 6172 6765 725f 6262  area < larger_bb
+00003e70: 5f61 7265 610a 0a0a 6465 6620 6973 5f73  _area...def is_s
+00003e80: 7175 6172 6528 7265 6769 6f6e 3a20 5265  quare(region: Re
+00003e90: 6769 6f6e 5072 6f70 6572 7469 6573 2c20  gionProperties, 
+00003ea0: 2a61 7267 732c 202a 2a6b 7761 7267 7329  *args, **kwargs)
+00003eb0: 202d 3e20 626f 6f6c 3a0a 2020 2020 2222   -> bool:.    ""
+00003ec0: 2244 6563 6964 6520 6966 2074 6865 2052  "Decide if the R
+00003ed0: 4f49 2069 7320 7371 7561 7265 2069 6e20  OI is square in 
+00003ee0: 6e61 7475 7265 2062 7920 7465 7374 696e  nature by testin
+00003ef0: 6720 7468 6520 6669 6c6c 6564 2061 7265  g the filled are
+00003f00: 6120 7673 2062 6f75 6e64 696e 6720 626f  a vs bounding bo
+00003f10: 782e 2055 7365 6420 746f 2066 696e 6420  x. Used to find 
+00003f20: 7468 6520 4242 2e22 2222 0a20 2020 2061  the BB.""".    a
+00003f30: 6374 7561 6c5f 6669 6c6c 5f72 6174 696f  ctual_fill_ratio
+00003f40: 203d 2072 6567 696f 6e2e 6669 6c6c 6564   = region.filled
+00003f50: 5f61 7265 6120 2f20 7265 6769 6f6e 2e62  _area / region.b
+00003f60: 626f 785f 6172 6561 0a20 2020 2072 6574  box_area.    ret
+00003f70: 7572 6e20 6163 7475 616c 5f66 696c 6c5f  urn actual_fill_
+00003f80: 7261 7469 6f20 3e20 302e 380a 0a0a 6465  ratio > 0.8...de
+00003f90: 6620 6973 5f72 6967 6874 5f73 7175 6172  f is_right_squar
+00003fa0: 655f 7369 7a65 2872 6567 696f 6e3a 2052  e_size(region: R
+00003fb0: 6567 696f 6e50 726f 7065 7274 6965 732c  egionProperties,
+00003fc0: 202a 6172 6773 2c20 2a2a 6b77 6172 6773   *args, **kwargs
+00003fd0: 2920 2d3e 2062 6f6f 6c3a 0a20 2020 2022  ) -> bool:.    "
+00003fe0: 2222 4465 6369 6465 2069 6620 7468 6520  ""Decide if the 
+00003ff0: 524f 4920 6973 2073 7175 6172 6520 696e  ROI is square in
+00004000: 206e 6174 7572 6520 6279 2074 6573 7469   nature by testi
+00004010: 6e67 2074 6865 2066 696c 6c65 6420 6172  ng the filled ar
+00004020: 6561 2076 7320 626f 756e 6469 6e67 2062  ea vs bounding b
+00004030: 6f78 2e20 5573 6564 2074 6f20 6669 6e64  ox. Used to find
+00004040: 2074 6865 2042 422e 2222 220a 2020 2020   the BB.""".    
+00004050: 6669 656c 645f 6172 6561 203d 2072 6567  field_area = reg
+00004060: 696f 6e2e 6172 6561 5f66 696c 6c65 6420  ion.area_filled 
+00004070: 2f20 286b 7761 7267 735b 2264 706d 6d22  / (kwargs["dpmm"
+00004080: 5d20 2a2a 2032 290a 2020 2020 7261 645f  ] ** 2).    rad_
+00004090: 7369 7a65 203d 206d 6178 2828 6b77 6172  size = max((kwar
+000040a0: 6773 5b22 7261 645f 7369 7a65 225d 2c20  gs["rad_size"], 
+000040b0: 3529 290a 2020 2020 6c61 7267 6572 5f62  5)).    larger_b
+000040c0: 625f 6172 6561 203d 2028 7261 645f 7369  b_area = (rad_si
+000040d0: 7a65 202b 2035 2920 2a2a 2032 0a20 2020  ze + 5) ** 2.   
+000040e0: 2073 6d61 6c6c 6572 5f62 625f 6172 6561   smaller_bb_area
+000040f0: 203d 2028 7261 645f 7369 7a65 202d 2035   = (rad_size - 5
+00004100: 2920 2a2a 2032 0a20 2020 2072 6574 7572  ) ** 2.    retur
+00004110: 6e20 736d 616c 6c65 725f 6262 5f61 7265  n smaller_bb_are
+00004120: 6120 3c20 6669 656c 645f 6172 6561 203c  a < field_area <
+00004130: 206c 6172 6765 725f 6262 5f61 7265 610a   larger_bb_area.
+00004140: 0a0a 636c 6173 7320 574c 4261 7365 496d  ..class WLBaseIm
+00004150: 6167 6528 696d 6167 652e 4c69 6e61 6344  age(image.LinacD
+00004160: 6963 6f6d 496d 6167 6529 3a0a 2020 2020  icomImage):.    
+00004170: 2222 2242 6173 6520 636c 6173 7320 666f  """Base class fo
+00004180: 7220 6120 574c 2049 6d61 6765 2e20 5265  r a WL Image. Re
+00004190: 7072 6573 656e 7473 2061 2073 696e 676c  presents a singl
+000041a0: 6520 696d 6167 6520 7769 7468 204e 2066  e image with N f
+000041b0: 6965 6c64 7320 616e 6420 4d20 4242 732e  ields and M BBs.
+000041c0: 0a0a 2020 2020 4d65 7468 6f64 7320 6172  ..    Methods ar
+000041d0: 6520 7072 6f76 6964 6564 2074 6f20 6669  e provided to fi
+000041e0: 6e64 2074 6865 2066 6965 6c64 2043 4158  nd the field CAX
+000041f0: 7320 616e 6420 4242 7320 616e 6420 6d61  s and BBs and ma
+00004200: 7463 6869 6e67 2074 6f20 7468 6520 6578  tching to the ex
+00004210: 7065 6374 6564 206c 6f63 6174 696f 6e73  pected locations
+00004220: 2e0a 2020 2020 2222 220a 0a20 2020 2066  ..    """..    f
+00004230: 6965 6c64 5f63 6178 733a 206c 6973 745b  ield_caxs: list[
+00004240: 506f 696e 745d 0a20 2020 2062 625f 706f  Point].    bb_po
+00004250: 7369 7469 6f6e 733a 206c 6973 745b 506f  sitions: list[Po
+00004260: 696e 745d 0a20 2020 2062 625f 6172 7261  int].    bb_arra
+00004270: 6e67 656d 656e 743a 2074 7570 6c65 5b42  ngement: tuple[B
+00004280: 4243 6f6e 6669 675d 0a20 2020 2061 7272  BConfig].    arr
+00004290: 616e 6765 6d65 6e74 5f6d 6174 6368 6573  angement_matches
+000042a0: 3a20 6469 6374 5b0a 2020 2020 2020 2020  : dict[.        
+000042b0: 7374 722c 2042 4246 6965 6c64 4d61 7463  str, BBFieldMatc
+000042c0: 680a 2020 2020 5d20 2023 2061 2066 6965  h.    ]  # a fie
+000042d0: 6c64 2043 4158 2061 6e64 2042 4220 6d61  ld CAX and BB ma
+000042e0: 7463 6865 6420 746f 2074 6865 6972 2072  tched to their r
+000042f0: 6573 7065 6374 6976 6520 6e6f 6d69 6e61  espective nomina
+00004300: 6c20 6c6f 6361 7469 6f6e 730a 0a20 2020  l locations..   
+00004310: 2064 6566 205f 5f69 6e69 745f 5f28 0a20   def __init__(. 
+00004320: 2020 2020 2020 2073 656c 662c 0a20 2020         self,.   
+00004330: 2020 2020 2066 696c 653a 2073 7472 207c       file: str |
+00004340: 2042 696e 6172 7949 4f20 7c20 5061 7468   BinaryIO | Path
+00004350: 2c0a 2020 2020 2020 2020 7573 655f 6669  ,.        use_fi
+00004360: 6c65 6e61 6d65 733a 2062 6f6f 6c20 3d20  lenames: bool = 
+00004370: 4661 6c73 652c 0a20 2020 2020 2020 202a  False,.        *
+00004380: 2a6b 7761 7267 732c 0a20 2020 2029 3a0a  *kwargs,.    ):.
+00004390: 2020 2020 2020 2020 2222 220a 2020 2020          """.    
+000043a0: 2020 2020 5061 7261 6d65 7465 7273 0a20      Parameters. 
+000043b0: 2020 2020 2020 202d 2d2d 2d2d 2d2d 2d2d         ---------
+000043c0: 2d0a 2020 2020 2020 2020 6669 6c65 203a  -.        file :
+000043d0: 2073 7472 0a20 2020 2020 2020 2020 2020   str.           
+000043e0: 2050 6174 6820 746f 2074 6865 2069 6d61   Path to the ima
+000043f0: 6765 2066 696c 652e 0a20 2020 2020 2020  ge file..       
+00004400: 2075 7365 5f66 696c 656e 616d 6573 3a20   use_filenames: 
+00004410: 626f 6f6c 0a20 2020 2020 2020 2020 2020  bool.           
+00004420: 2057 6865 7468 6572 2074 6f20 7472 7920   Whether to try 
+00004430: 746f 2075 7365 2074 6865 2066 696c 6520  to use the file 
+00004440: 6e61 6d65 2074 6f20 6465 7465 726d 696e  name to determin
+00004450: 6520 6178 6973 2076 616c 7565 732e 0a20  e axis values.. 
+00004460: 2020 2020 2020 2020 2020 2055 7365 6675             Usefu
+00004470: 6c20 666f 7220 456c 656b 7461 206d 6163  l for Elekta mac
+00004480: 6869 6e65 7320 7468 6174 2064 6f20 6e6f  hines that do no
+00004490: 7420 696e 636c 7564 6520 7468 6174 2069  t include that i
+000044a0: 6e66 6f20 696e 2074 6865 2044 4943 4f4d  nfo in the DICOM
+000044b0: 2064 6174 612e 0a20 2020 2020 2020 2022   data..        "
+000044c0: 2222 0a20 2020 2020 2020 2023 206f 7665  "".        # ove
+000044d0: 7272 6964 6520 6465 7465 6374 696f 6e20  rride detection 
+000044e0: 636f 6e64 6974 696f 6e73 2069 6620 7061  conditions if pa
+000044f0: 7373 6564 0a20 2020 2020 2020 2069 6620  ssed.        if 
+00004500: 636f 6e64 6974 696f 6e73 203a 3d20 6b77  conditions := kw
+00004510: 6172 6773 2e70 6f70 2822 6465 7465 6374  args.pop("detect
+00004520: 696f 6e5f 636f 6e64 6974 696f 6e73 222c  ion_conditions",
+00004530: 2046 616c 7365 293a 0a20 2020 2020 2020   False):.       
+00004540: 2020 2020 2073 656c 662e 6465 7465 6374       self.detect
+00004550: 696f 6e5f 636f 6e64 6974 696f 6e73 203d  ion_conditions =
+00004560: 2063 6f6e 6469 7469 6f6e 730a 2020 2020   conditions.    
+00004570: 2020 2020 7375 7065 7228 292e 5f5f 696e      super().__in
+00004580: 6974 5f5f 2866 696c 652c 2075 7365 5f66  it__(file, use_f
+00004590: 696c 656e 616d 6573 3d75 7365 5f66 696c  ilenames=use_fil
+000045a0: 656e 616d 6573 2c20 2a2a 6b77 6172 6773  enames, **kwargs
+000045b0: 290a 2020 2020 2020 2020 7365 6c66 2e5f  ).        self._
+000045c0: 6973 5f61 6e61 6c79 7a65 6420 3d20 4661  is_analyzed = Fa
+000045d0: 6c73 650a 0a20 2020 2064 6566 2061 6e61  lse..    def ana
+000045e0: 6c79 7a65 280a 2020 2020 2020 2020 7365  lyze(.        se
+000045f0: 6c66 2c0a 2020 2020 2020 2020 6262 5f61  lf,.        bb_a
+00004600: 7272 616e 6765 6d65 6e74 3a20 7475 706c  rrangement: tupl
+00004610: 655b 4242 436f 6e66 6967 5d2c 0a20 2020  e[BBConfig],.   
+00004620: 2020 2020 2069 735f 6f70 656e 5f66 6965       is_open_fie
+00004630: 6c64 3a20 626f 6f6c 203d 2046 616c 7365  ld: bool = False
+00004640: 2c0a 2020 2020 2020 2020 6973 5f6c 6f77  ,.        is_low
+00004650: 5f64 656e 7369 7479 3a20 626f 6f6c 203d  _density: bool =
+00004660: 2046 616c 7365 2c0a 2020 2020 2020 2020   False,.        
+00004670: 7368 6966 745f 7665 6374 6f72 3a20 5665  shift_vector: Ve
+00004680: 6374 6f72 207c 204e 6f6e 6520 3d20 4e6f  ctor | None = No
+00004690: 6e65 2c0a 2020 2020 2920 2d3e 2028 7475  ne,.    ) -> (tu
+000046a0: 706c 655b 506f 696e 745d 2c20 7475 706c  ple[Point], tupl
+000046b0: 655b 506f 696e 745d 293a 0a20 2020 2020  e[Point]):.     
+000046c0: 2020 2022 2222 416e 616c 797a 6520 7468     """Analyze th
+000046d0: 6520 696d 6167 6520 666f 7220 4242 7320  e image for BBs 
+000046e0: 616e 6420 6669 656c 6420 4341 5873 2e0a  and field CAXs..
+000046f0: 0a20 2020 2020 2020 2050 6172 616d 6574  .        Paramet
+00004700: 6572 730a 2020 2020 2020 2020 2d2d 2d2d  ers.        ----
+00004710: 2d2d 2d2d 2d2d 0a20 2020 2020 2020 2062  ------.        b
+00004720: 625f 6172 7261 6e67 656d 656e 7420 3a20  b_arrangement : 
+00004730: 7475 706c 655b 4242 436f 6e66 6967 5d0a  tuple[BBConfig].
+00004740: 2020 2020 2020 2020 2020 2020 5468 6520              The 
+00004750: 6578 7065 6374 6564 2042 4220 6c6f 6361  expected BB loca
+00004760: 7469 6f6e 732e 0a20 2020 2020 2020 2069  tions..        i
+00004770: 735f 6f70 656e 5f66 6965 6c64 203a 2062  s_open_field : b
+00004780: 6f6f 6c0a 2020 2020 2020 2020 2020 2020  ool.            
+00004790: 5768 6574 6865 7220 7468 6520 6669 656c  Whether the fiel
+000047a0: 6420 6973 206f 7065 6e20 6f72 206e 6f74  d is open or not
+000047b0: 2e20 4966 206f 7065 6e2c 206f 6e6c 7920  . If open, only 
+000047c0: 6f6e 6520 4341 5820 6973 2065 7870 6563  one CAX is expec
+000047d0: 7465 642e 0a20 2020 2020 2020 2069 735f  ted..        is_
+000047e0: 6c6f 775f 6465 6e73 6974 7920 3a20 626f  low_density : bo
+000047f0: 6f6c 0a20 2020 2020 2020 2020 2020 2057  ol.            W
+00004800: 6865 7468 6572 2074 6865 2042 4273 2061  hether the BBs a
+00004810: 7265 206c 6f77 2064 656e 7369 7479 2028  re low density (
+00004820: 652e 672e 206b 5620 696d 6167 6573 292e  e.g. kV images).
+00004830: 0a20 2020 2020 2020 2073 6869 6674 5f76  .        shift_v
+00004840: 6563 746f 7220 3a20 5665 6374 6f72 2c20  ector : Vector, 
+00004850: 6f70 7469 6f6e 616c 0a20 2020 2020 2020  optional.       
+00004860: 2020 2020 2041 2076 6563 746f 7220 746f       A vector to
+00004870: 2073 6869 6674 2074 6865 2064 6574 6563   shift the detec
+00004880: 7465 6420 4242 7320 6279 2e20 5573 6566  ted BBs by. Usef
+00004890: 756c 2066 6f72 2069 6d61 6765 7320 7468  ul for images th
+000048a0: 6174 2061 7265 206e 6f74 2070 6572 6665  at are not perfe
+000048b0: 6374 6c79 2061 6c69 676e 6564 2e0a 2020  ctly aligned..  
+000048c0: 2020 2020 2020 2222 220a 2020 2020 2020        """.      
+000048d0: 2020 7365 6c66 2e63 6865 636b 5f69 6e76    self.check_inv
+000048e0: 6572 7369 6f6e 5f62 795f 6869 7374 6f67  ersion_by_histog
+000048f0: 7261 6d28 7065 7263 656e 7469 6c65 733d  ram(percentiles=
+00004900: 2830 2e30 312c 2035 302c 2039 392e 3939  (0.01, 50, 99.99
+00004910: 2929 0a20 2020 2020 2020 2073 656c 662e  )).        self.
+00004920: 5f63 6c65 616e 5f65 6467 6573 2829 0a20  _clean_edges(). 
+00004930: 2020 2020 2020 2073 656c 662e 6772 6f75         self.grou
+00004940: 6e64 2829 0a20 2020 2020 2020 2073 656c  nd().        sel
+00004950: 662e 6e6f 726d 616c 697a 6528 290a 2020  f.normalize().  
+00004960: 2020 2020 2020 7365 6c66 2e62 625f 6172        self.bb_ar
+00004970: 7261 6e67 656d 656e 7420 3d20 6262 5f61  rangement = bb_a
+00004980: 7272 616e 6765 6d65 6e74 0a20 2020 2020  rrangement.     
+00004990: 2020 2066 6965 6c64 5f63 6178 7320 3d20     field_caxs = 
+000049a0: 7365 6c66 2e66 696e 645f 6669 656c 645f  self.find_field_
+000049b0: 6365 6e74 726f 6964 7328 6973 5f6f 7065  centroids(is_ope
+000049c0: 6e5f 6669 656c 643d 6973 5f6f 7065 6e5f  n_field=is_open_
+000049d0: 6669 656c 6429 0a20 2020 2020 2020 2066  field).        f
+000049e0: 6965 6c64 5f6d 6174 6368 6573 203d 2073  ield_matches = s
+000049f0: 656c 662e 6669 6e64 5f66 6965 6c64 5f6d  elf.find_field_m
+00004a00: 6174 6368 6573 2866 6965 6c64 5f63 6178  atches(field_cax
+00004a10: 7329 0a20 2020 2020 2020 2064 6574 6563  s).        detec
+00004a20: 7465 645f 6262 5f70 6f69 6e74 7320 3d20  ted_bb_points = 
+00004a30: 7365 6c66 2e66 696e 645f 6262 5f63 656e  self.find_bb_cen
+00004a40: 7472 6f69 6473 280a 2020 2020 2020 2020  troids(.        
+00004a50: 2020 2020 6262 5f64 6961 6d65 7465 725f      bb_diameter_
+00004a60: 6d6d 3d62 625f 6172 7261 6e67 656d 656e  mm=bb_arrangemen
+00004a70: 745b 305d 2e62 625f 7369 7a65 5f6d 6d2c  t[0].bb_size_mm,
+00004a80: 0a20 2020 2020 2020 2020 2020 206c 6f77  .            low
+00004a90: 5f64 656e 7369 7479 3d69 735f 6c6f 775f  _density=is_low_
+00004aa0: 6465 6e73 6974 792c 0a20 2020 2020 2020  density,.       
+00004ab0: 2029 0a20 2020 2020 2020 2069 6620 7368   ).        if sh
+00004ac0: 6966 745f 7665 6374 6f72 3a0a 2020 2020  ift_vector:.    
+00004ad0: 2020 2020 2020 2020 2320 6170 706c 7920          # apply 
+00004ae0: 7368 6966 7420 746f 2064 6574 6563 7465  shift to detecte
+00004af0: 6420 4242 2070 6f69 6e74 730a 2020 2020  d BB points.    
+00004b00: 2020 2020 2020 2020 6c61 742c 2073 7570          lat, sup
+00004b10: 5f69 6e66 203d 2062 625f 7072 6f6a 6563  _inf = bb_projec
+00004b20: 7469 6f6e 5f77 6974 685f 726f 7461 7469  tion_with_rotati
+00004b30: 6f6e 280a 2020 2020 2020 2020 2020 2020  on(.            
+00004b40: 2020 2020 6f66 6673 6574 5f6c 6566 743d      offset_left=
+00004b50: 2d73 6869 6674 5f76 6563 746f 722e 782c  -shift_vector.x,
+00004b60: 2020 2320 6e65 6761 7469 7665 2062 6563    # negative bec
+00004b70: 6175 7365 206c 6566 7420 6973 206e 6567  ause left is neg
+00004b80: 6174 6976 6520 780a 2020 2020 2020 2020  ative x.        
+00004b90: 2020 2020 2020 2020 6f66 6673 6574 5f75          offset_u
+00004ba0: 703d 7368 6966 745f 7665 6374 6f72 2e7a  p=shift_vector.z
+00004bb0: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+00004bc0: 2020 6f66 6673 6574 5f69 6e3d 7368 6966    offset_in=shif
+00004bd0: 745f 7665 6374 6f72 2e79 2c0a 2020 2020  t_vector.y,.    
+00004be0: 2020 2020 2020 2020 2020 2020 7361 643d              sad=
+00004bf0: 7365 6c66 2e73 6164 2c0a 2020 2020 2020  self.sad,.      
+00004c00: 2020 2020 2020 2020 2020 6761 6e74 7279            gantry
+00004c10: 3d73 656c 662e 6761 6e74 7279 5f61 6e67  =self.gantry_ang
+00004c20: 6c65 2c0a 2020 2020 2020 2020 2020 2020  le,.            
+00004c30: 2020 2020 636f 7563 683d 7365 6c66 2e63      couch=self.c
+00004c40: 6f75 6368 5f61 6e67 6c65 2c0a 2020 2020  ouch_angle,.    
+00004c50: 2020 2020 2020 2020 290a 2020 2020 2020          ).      
+00004c60: 2020 2020 2020 2320 636f 6e76 6572 7420        # convert 
+00004c70: 6672 6f6d 206d 6d20 746f 2070 6978 656c  from mm to pixel
+00004c80: 7320 616e 6420 6164 6420 746f 2074 6865  s and add to the
+00004c90: 2064 6574 6563 7465 6420 706f 696e 7473   detected points
+00004ca0: 0a20 2020 2020 2020 2020 2020 2066 6f72  .            for
+00004cb0: 2070 2069 6e20 6465 7465 6374 6564 5f62   p in detected_b
+00004cc0: 625f 706f 696e 7473 3a0a 2020 2020 2020  b_points:.      
+00004cd0: 2020 2020 2020 2020 2020 702e 7820 2b3d            p.x +=
+00004ce0: 206c 6174 202a 2073 656c 662e 6470 6d6d   lat * self.dpmm
+00004cf0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00004d00: 2070 2e79 202d 3d20 280a 2020 2020 2020   p.y -= (.      
+00004d10: 2020 2020 2020 2020 2020 2020 2020 7375                su
+00004d20: 705f 696e 6620 2a20 7365 6c66 2e64 706d  p_inf * self.dpm
+00004d30: 6d0a 2020 2020 2020 2020 2020 2020 2020  m.              
+00004d40: 2020 2920 2023 2077 6520 7375 6274 7261    )  # we subtra
+00004d50: 6374 2062 6563 6175 7365 2074 6865 2064  ct because the d
+00004d60: 6574 6563 7465 6420 706f 696e 7420 6973  etected point is
+00004d70: 2069 6e20 696d 6167 6520 7370 6163 652c   in image space,
+00004d80: 206e 6f74 2063 6f6f 7264 696e 6174 6520   not coordinate 
+00004d90: 7370 6163 6520 736f 2077 6520 636f 6e76  space so we conv
+00004da0: 6572 7420 7468 6520 7368 6966 7420 6672  ert the shift fr
+00004db0: 6f6d 2063 6f6f 7264 696e 6174 6520 746f  om coordinate to
+00004dc0: 2069 6d61 6765 2073 7061 6365 0a20 2020   image space.   
+00004dd0: 2020 2020 2062 625f 6d61 7463 6865 7320       bb_matches 
+00004de0: 3d20 7365 6c66 2e66 696e 645f 6262 5f6d  = self.find_bb_m
+00004df0: 6174 6368 6573 2864 6574 6563 7465 645f  atches(detected_
+00004e00: 706f 696e 7473 3d64 6574 6563 7465 645f  points=detected_
+00004e10: 6262 5f70 6f69 6e74 7329 0a20 2020 2020  bb_points).     
+00004e20: 2020 2069 6620 6c65 6e28 6262 5f6d 6174     if len(bb_mat
+00004e30: 6368 6573 2920 213d 206c 656e 2866 6965  ches) != len(fie
+00004e40: 6c64 5f6d 6174 6368 6573 293a 0a20 2020  ld_matches):.   
+00004e50: 2020 2020 2020 2020 2072 6169 7365 2056           raise V
+00004e60: 616c 7565 4572 726f 7228 2254 6865 206e  alueError("The n
+00004e70: 756d 6265 7220 6f66 2064 6574 6563 7465  umber of detecte
+00004e80: 6420 6669 656c 6473 2061 6e64 2042 4273  d fields and BBs
+00004e90: 2064 6f20 6e6f 7420 6d61 7463 6822 290a   do not match").
+00004ea0: 2020 2020 2020 2020 6966 206e 6f74 2066          if not f
+00004eb0: 6965 6c64 5f6d 6174 6368 6573 3a0a 2020  ield_matches:.  
+00004ec0: 2020 2020 2020 2020 2020 7261 6973 6520            raise 
+00004ed0: 5661 6c75 6545 7272 6f72 2822 4e6f 2066  ValueError("No f
+00004ee0: 6965 6c64 7320 7765 7265 2064 6574 6563  ields were detec
+00004ef0: 7465 6422 290a 2020 2020 2020 2020 6966  ted").        if
+00004f00: 206e 6f74 2062 625f 6d61 7463 6865 733a   not bb_matches:
+00004f10: 0a20 2020 2020 2020 2020 2020 2072 6169  .            rai
+00004f20: 7365 2056 616c 7565 4572 726f 7228 4242  se ValueError(BB
+00004f30: 5f45 5252 4f52 5f4d 4553 5341 4745 290a  _ERROR_MESSAGE).
+00004f40: 2020 2020 2020 2020 2320 7765 206e 6f77          # we now
+00004f50: 2068 6176 6520 6669 656c 6420 4341 5873   have field CAXs
+00004f60: 2061 6e64 2042 4273 206d 6174 6368 6564   and BBs matched
+00004f70: 2074 6f20 7468 6569 7220 7265 7370 6563   to their respec
+00004f80: 7469 7665 206e 6f6d 696e 616c 206c 6f63  tive nominal loc
+00004f90: 6174 696f 6e73 0a20 2020 2020 2020 2023  ations.        #
+00004fa0: 206d 6572 6765 2074 6865 2066 6965 6c64   merge the field
+00004fb0: 2061 6e64 2042 4273 2070 6572 2061 7272   and BBs per arr
+00004fc0: 616e 6765 6d65 6e74 2070 6f73 6974 696f  angement positio
+00004fd0: 6e0a 2020 2020 2020 2020 636f 6d62 696e  n.        combin
+00004fe0: 6564 5f6d 6174 6368 6573 203d 207b 7d0a  ed_matches = {}.
+00004ff0: 2020 2020 2020 2020 666f 7220 6262 5f6e          for bb_n
+00005000: 616d 652c 2062 625f 6d61 7463 6820 696e  ame, bb_match in
+00005010: 2062 625f 6d61 7463 6865 732e 6974 656d   bb_matches.item
+00005020: 7328 293a 0a20 2020 2020 2020 2020 2020  s():.           
+00005030: 2063 6f6d 6269 6e65 645f 6d61 7463 6865   combined_matche
+00005040: 735b 6262 5f6e 616d 655d 203d 2042 4246  s[bb_name] = BBF
+00005050: 6965 6c64 4d61 7463 6828 0a20 2020 2020  ieldMatch(.     
+00005060: 2020 2020 2020 2020 2020 2065 7069 643d             epid=
+00005070: 7365 6c66 2e63 656e 7465 722c 0a20 2020  self.center,.   
+00005080: 2020 2020 2020 2020 2020 2020 2066 6965               fie
+00005090: 6c64 3d66 6965 6c64 5f6d 6174 6368 6573  ld=field_matches
+000050a0: 5b62 625f 6e61 6d65 5d2c 0a20 2020 2020  [bb_name],.     
+000050b0: 2020 2020 2020 2020 2020 2062 623d 6262             bb=bb
+000050c0: 5f6d 6174 6368 2c0a 2020 2020 2020 2020  _match,.        
+000050d0: 2020 2020 2020 2020 6470 6d6d 3d73 656c          dpmm=sel
+000050e0: 662e 6470 6d6d 2c0a 2020 2020 2020 2020  f.dpmm,.        
+000050f0: 2020 2020 2020 2020 6761 6e74 7279 5f61          gantry_a
+00005100: 6e67 6c65 3d73 656c 662e 6761 6e74 7279  ngle=self.gantry
+00005110: 5f61 6e67 6c65 2c0a 2020 2020 2020 2020  _angle,.        
+00005120: 2020 2020 2020 2020 636f 7563 685f 616e          couch_an
+00005130: 676c 653d 7365 6c66 2e63 6f75 6368 5f61  gle=self.couch_a
+00005140: 6e67 6c65 2c0a 2020 2020 2020 2020 2020  ngle,.          
+00005150: 2020 2020 2020 7361 643d 7365 6c66 2e73        sad=self.s
+00005160: 6164 2c0a 2020 2020 2020 2020 2020 2020  ad,.            
+00005170: 290a 2020 2020 2020 2020 7365 6c66 2e5f  ).        self._
+00005180: 6973 5f61 6e61 6c79 7a65 6420 3d20 5472  is_analyzed = Tr
+00005190: 7565 0a20 2020 2020 2020 2073 656c 662e  ue.        self.
+000051a0: 6172 7261 6e67 656d 656e 745f 6d61 7463  arrangement_matc
+000051b0: 6865 7320 3d20 636f 6d62 696e 6564 5f6d  hes = combined_m
+000051c0: 6174 6368 6573 0a0a 2020 2020 6465 6620  atches..    def 
+000051d0: 6669 6e64 5f66 6965 6c64 5f63 656e 7472  find_field_centr
+000051e0: 6f69 6473 2873 656c 662c 2069 735f 6f70  oids(self, is_op
+000051f0: 656e 5f66 6965 6c64 3a20 626f 6f6c 2920  en_field: bool) 
+00005200: 2d3e 206c 6973 745b 506f 696e 745d 3a0a  -> list[Point]:.
+00005210: 2020 2020 2020 2020 2222 2246 696e 6420          """Find 
+00005220: 7468 6520 6669 656c 6420 4341 5828 7329  the field CAX(s)
+00005230: 2069 6e20 7468 6520 696d 6167 652e 2049   in the image. I
+00005240: 6620 7468 6520 6669 656c 6420 6973 206f  f the field is o
+00005250: 7065 6e20 6f72 2074 6869 7320 6973 2061  pen or this is a
+00005260: 2076 616e 696c 6c61 2057 4c2c 206f 6e6c   vanilla WL, onl
+00005270: 7920 6f6e 6520 4341 5820 6973 2066 6f75  y one CAX is fou
+00005280: 6e64 2e22 2222 0a20 2020 2020 2020 2069  nd.""".        i
+00005290: 6620 6973 5f6f 7065 6e5f 6669 656c 643a  f is_open_field:
+000052a0: 0a20 2020 2020 2020 2020 2020 2070 203d  .            p =
+000052b0: 2073 656c 662e 6365 6e74 6572 0a20 2020   self.center.   
+000052c0: 2020 2020 2065 6c73 653a 0a20 2020 2020       else:.     
+000052d0: 2020 2020 2020 2023 2054 4f44 4f3a 2055         # TODO: U
+000052e0: 7365 206d 6574 7269 6373 2066 6965 6c64  se metrics field
+000052f0: 2066 696e 6465 720a 2020 2020 2020 2020   finder.        
+00005300: 2020 2020 2320 6361 6e27 7420 7573 6520      # can't use 
+00005310: 6974 206f 7574 206f 6620 7468 6520 626f  it out of the bo
+00005320: 7820 6265 6361 7573 6520 7468 650a 2020  x because the.  
+00005330: 2020 2020 2020 2020 2020 2320 616e 616c            # anal
+00005340: 797a 6520 6d65 7468 6f64 2064 6f65 736e  yze method doesn
+00005350: 2774 2070 6173 7320 7468 6520 6669 656c  't pass the fiel
+00005360: 6420 7369 7a65 0a20 2020 2020 2020 2020  d size.         
+00005370: 2020 2023 2075 7369 6e67 2074 6865 2067     # using the g
+00005380: 6c6f 6261 6c20 6669 656c 6420 6c6f 6361  lobal field loca
+00005390: 746f 7220 7769 7468 6f75 7420 7369 7a65  tor without size
+000053a0: 2077 696c 6c0a 2020 2020 2020 2020 2020   will.          
+000053b0: 2020 2320 6669 6e64 2073 6576 6572 616c    # find several
+000053c0: 206f 7468 6572 2075 6e72 656c 6174 6564   other unrelated
+000053d0: 2066 6965 6c64 7320 616e 6420 7368 6f77   fields and show
+000053e0: 2075 7020 696e 2074 6865 2069 6d61 6765   up in the image
+000053f0: 0a20 2020 2020 2020 2020 2020 2023 2074  .            # t
+00005400: 6865 206d 6574 7269 6320 616c 676f 7269  he metric algori
+00005410: 7468 6d20 7368 6f75 6c64 2068 6176 6520  thm should have 
+00005420: 6120 706f 7374 2d70 726f 6365 7373 696e  a post-processin
+00005430: 6720 6675 6e63 7469 6f6e 2070 6172 616d  g function param
+00005440: 6574 6572 0a20 2020 2020 2020 2020 2020  eter.           
+00005450: 206d 696e 2c20 6d61 7820 3d20 6e70 2e70   min, max = np.p
+00005460: 6572 6365 6e74 696c 6528 7365 6c66 2e61  ercentile(self.a
+00005470: 7272 6179 2c20 5b35 2c20 3939 2e39 5d29  rray, [5, 99.9])
+00005480: 0a20 2020 2020 2020 2020 2020 2074 6872  .            thr
+00005490: 6573 686f 6c64 5f69 6d67 203d 2073 656c  eshold_img = sel
+000054a0: 662e 6173 5f62 696e 6172 7928 286d 6178  f.as_binary((max
+000054b0: 202d 206d 696e 2920 2f20 3220 2b20 6d69   - min) / 2 + mi
+000054c0: 6e29 0a20 2020 2020 2020 2020 2020 2066  n).            f
+000054d0: 696c 6c65 645f 696d 6720 3d20 6e64 696d  illed_img = ndim
+000054e0: 6167 652e 6269 6e61 7279 5f66 696c 6c5f  age.binary_fill_
+000054f0: 686f 6c65 7328 7468 7265 7368 6f6c 645f  holes(threshold_
+00005500: 696d 6729 0a20 2020 2020 2020 2020 2020  img).           
+00005510: 2063 6f6f 7264 7320 3d20 6e64 696d 6167   coords = ndimag
+00005520: 652e 6365 6e74 6572 5f6f 665f 6d61 7373  e.center_of_mass
+00005530: 2866 696c 6c65 645f 696d 6729 0a20 2020  (filled_img).   
+00005540: 2020 2020 2020 2020 2070 203d 2050 6f69           p = Poi
+00005550: 6e74 2878 3d63 6f6f 7264 735b 2d31 5d2c  nt(x=coords[-1],
+00005560: 2079 3d63 6f6f 7264 735b 305d 290a 2020   y=coords[0]).  
+00005570: 2020 2020 2020 7265 7475 726e 205b 705d        return [p]
+00005580: 0a0a 2020 2020 6465 6620 6669 6e64 5f66  ..    def find_f
+00005590: 6965 6c64 5f6d 6174 6368 6573 2873 656c  ield_matches(sel
+000055a0: 662c 2064 6574 6563 7465 645f 706f 696e  f, detected_poin
+000055b0: 7473 3a20 6c69 7374 5b50 6f69 6e74 5d29  ts: list[Point])
+000055c0: 202d 3e20 6469 6374 5b73 7472 2c20 506f   -> dict[str, Po
+000055d0: 696e 745d 3a0a 2020 2020 2020 2020 2222  int]:.        ""
+000055e0: 2246 696e 6420 6d61 7463 6865 7320 6265  "Find matches be
+000055f0: 7477 6565 6e20 6465 7465 6374 6564 2066  tween detected f
+00005600: 6965 6c64 2070 6f69 6e74 7320 616e 6420  ield points and 
+00005610: 7468 6520 6172 7261 6e67 656d 656e 742e  the arrangement.
+00005620: 2053 6565 2060 6066 696e 645f 6262 5f6d   See ``find_bb_m
+00005630: 6174 6368 6573 6060 2066 6f72 206d 6f72  atches`` for mor
+00005640: 6520 696e 666f 2e22 2222 0a20 2020 2020  e info.""".     
+00005650: 2020 2072 6574 7572 6e20 7365 6c66 2e66     return self.f
+00005660: 696e 645f 6262 5f6d 6174 6368 6573 2864  ind_bb_matches(d
+00005670: 6574 6563 7465 645f 706f 696e 7473 290a  etected_points).
+00005680: 0a20 2020 2064 6566 2066 696e 645f 6262  .    def find_bb
+00005690: 5f63 656e 7472 6f69 6473 280a 2020 2020  _centroids(.    
+000056a0: 2020 2020 7365 6c66 2c20 6262 5f64 6961      self, bb_dia
+000056b0: 6d65 7465 725f 6d6d 3a20 666c 6f61 742c  meter_mm: float,
+000056c0: 206c 6f77 5f64 656e 7369 7479 3a20 626f   low_density: bo
+000056d0: 6f6c 0a20 2020 2029 202d 3e20 6c69 7374  ol.    ) -> list
+000056e0: 5b50 6f69 6e74 5d3a 0a20 2020 2020 2020  [Point]:.       
+000056f0: 2022 2222 4669 6e64 2042 4273 2069 6e20   """Find BBs in 
+00005700: 7468 6520 696d 6167 652e 2054 6869 7320  the image. This 
+00005710: 6d65 7468 6f64 2063 616e 2072 6574 7572  method can retur
+00005720: 6e20 4d4f 5245 2074 6861 6e20 7468 6520  n MORE than the 
+00005730: 6465 7369 7265 6420 6e75 6d62 6572 206f  desired number o
+00005740: 6620 4242 732e 204d 6174 6368 696e 670a  f BBs. Matching.
+00005750: 2020 2020 2020 2020 6f66 2074 6865 2064          of the d
+00005760: 6574 6563 7465 6420 4242 7320 7673 2074  etected BBs vs t
+00005770: 6865 2065 7870 6563 7465 6420 4242 7320  he expected BBs 
+00005780: 6973 2064 6f6e 6520 696e 2074 6865 2060  is done in the `
+00005790: 6066 696e 645f 6262 5f6d 6174 6368 6573  `find_bb_matches
+000057a0: 6060 206d 6574 686f 642e 0a20 2020 2020  `` method..     
+000057b0: 2020 2022 2222 0a20 2020 2020 2020 2062     """.        b
+000057c0: 625f 746f 6c65 7261 6e63 655f 6d6d 203d  b_tolerance_mm =
+000057d0: 2073 656c 662e 5f63 616c 6375 6c61 7465   self._calculate
+000057e0: 5f62 625f 746f 6c65 7261 6e63 6528 6262  _bb_tolerance(bb
+000057f0: 5f64 6961 6d65 7465 725f 6d6d 290a 2020  _diameter_mm).  
+00005800: 2020 2020 2020 6365 6e74 6572 7320 3d20        centers = 
+00005810: 7365 6c66 2e63 6f6d 7075 7465 280a 2020  self.compute(.  
+00005820: 2020 2020 2020 2020 2020 6d65 7472 6963            metric
+00005830: 733d 5369 7a65 6444 6973 6b4c 6f63 6174  s=SizedDiskLocat
+00005840: 6f72 2e66 726f 6d5f 6365 6e74 6572 5f70  or.from_center_p
+00005850: 6879 7369 6361 6c28 0a20 2020 2020 2020  hysical(.       
+00005860: 2020 2020 2020 2020 2065 7870 6563 7465           expecte
+00005870: 645f 706f 7369 7469 6f6e 5f6d 6d3d 2830  d_position_mm=(0
+00005880: 2c20 3029 2c0a 2020 2020 2020 2020 2020  , 0),.          
+00005890: 2020 2020 2020 7365 6172 6368 5f77 696e        search_win
+000058a0: 646f 775f 6d6d 3d28 3430 202b 2062 625f  dow_mm=(40 + bb_
+000058b0: 6469 616d 6574 6572 5f6d 6d2c 2034 3020  diameter_mm, 40 
+000058c0: 2b20 6262 5f64 6961 6d65 7465 725f 6d6d  + bb_diameter_mm
+000058d0: 292c 0a20 2020 2020 2020 2020 2020 2020  ),.             
+000058e0: 2020 2072 6164 6975 735f 6d6d 3d62 625f     radius_mm=bb_
+000058f0: 6469 616d 6574 6572 5f6d 6d20 2f20 322c  diameter_mm / 2,
+00005900: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00005910: 2072 6164 6975 735f 746f 6c65 7261 6e63   radius_toleranc
+00005920: 655f 6d6d 3d62 625f 746f 6c65 7261 6e63  e_mm=bb_toleranc
+00005930: 655f 6d6d 2c0a 2020 2020 2020 2020 2020  e_mm,.          
+00005940: 2020 2020 2020 696e 7665 7274 3d6e 6f74        invert=not
+00005950: 206c 6f77 5f64 656e 7369 7479 2c0a 2020   low_density,.  
+00005960: 2020 2020 2020 2020 2020 2020 2020 6465                de
+00005970: 7465 6374 696f 6e5f 636f 6e64 6974 696f  tection_conditio
+00005980: 6e73 3d73 656c 662e 6465 7465 6374 696f  ns=self.detectio
+00005990: 6e5f 636f 6e64 6974 696f 6e73 2c0a 2020  n_conditions,.  
+000059a0: 2020 2020 2020 2020 2020 290a 2020 2020            ).    
+000059b0: 2020 2020 290a 2020 2020 2020 2020 7265      ).        re
+000059c0: 7475 726e 2063 656e 7465 7273 0a0a 2020  turn centers..  
+000059d0: 2020 6465 6620 6669 6e64 5f62 625f 6d61    def find_bb_ma
+000059e0: 7463 6865 7328 7365 6c66 2c20 6465 7465  tches(self, dete
+000059f0: 6374 6564 5f70 6f69 6e74 733a 206c 6973  cted_points: lis
+00005a00: 745b 506f 696e 745d 2920 2d3e 2064 6963  t[Point]) -> dic
+00005a10: 745b 7374 722c 2050 6f69 6e74 5d3a 0a20  t[str, Point]:. 
+00005a20: 2020 2020 2020 2022 2222 4769 7665 6e20         """Given 
+00005a30: 616e 2061 7272 616e 6765 6d65 6e74 2061  an arrangement a
+00005a40: 6e64 2064 6574 6563 7465 6420 4242 2070  nd detected BB p
+00005a50: 6f73 6974 696f 6e73 2c20 6669 6e64 2074  ositions, find t
+00005a60: 6865 2062 6273 2074 6861 7420 6172 6520  he bbs that are 
+00005a70: 636c 6f73 6573 7420 746f 2074 6865 2065  closest to the e
+00005a80: 7870 6563 7465 6420 706f 7369 7469 6f6e  xpected position
+00005a90: 732e 0a0a 2020 2020 2020 2020 5468 6973  s...        This
+00005aa0: 2069 7320 746f 2070 7265 7665 6e74 2066   is to prevent f
+00005ab0: 616c 7365 2070 6f73 6974 6976 6573 2066  alse positives f
+00005ac0: 726f 6d20 6265 696e 6720 6465 7465 6374  rom being detect
+00005ad0: 6564 2061 7320 4242 7320 2865 2e67 2e20  ed as BBs (e.g. 
+00005ae0: 6e6f 6973 652c 2063 6f75 6368 2c20 6574  noise, couch, et
+00005af0: 6329 2e0a 2020 2020 2020 2020 5468 6520  c)..        The 
+00005b00: 6465 7465 6374 6564 2042 4273 2061 7265  detected BBs are
+00005b10: 206d 6174 6368 6564 2074 6f20 7468 6520   matched to the 
+00005b20: 6578 7065 6374 6564 2042 4273 2062 6173  expected BBs bas
+00005b30: 6564 206f 6e20 7072 6f78 696d 6974 792e  ed on proximity.
+00005b40: 0a0a 2020 2020 2020 2020 5468 6573 6520  ..        These 
+00005b50: 6d61 7463 6865 7320 6172 6520 6c69 6e6b  matches are link
+00005b60: 6564 2074 6f20 7468 6520 696e 6469 7669  ed to the indivi
+00005b70: 6475 616c 2042 4220 6172 7261 6e67 656d  dual BB arrangem
+00005b80: 656e 7420 6279 2061 7272 616e 6765 6d65  ent by arrangeme
+00005b90: 6e74 206e 616d 652e 0a20 2020 2020 2020  nt name..       
+00005ba0: 2022 2222 0a20 2020 2020 2020 2062 6273   """.        bbs
+00005bb0: 203d 207b 7d0a 2020 2020 2020 2020 666f   = {}.        fo
+00005bc0: 7220 6262 5f61 726e 6720 696e 2073 656c  r bb_arng in sel
+00005bd0: 662e 6262 5f61 7272 616e 6765 6d65 6e74  f.bb_arrangement
+00005be0: 3a0a 2020 2020 2020 2020 2020 2020 6e6f  :.            no
+00005bf0: 6d69 6e61 6c5f 706f 696e 7420 3d20 7365  minal_point = se
+00005c00: 6c66 2e6e 6f6d 696e 616c 5f62 625f 706f  lf.nominal_bb_po
+00005c10: 7369 7469 6f6e 2862 625f 6172 6e67 290a  sition(bb_arng).
+00005c20: 2020 2020 2020 2020 2020 2020 6469 7374              dist
+00005c30: 616e 6365 7320 3d20 5b0a 2020 2020 2020  ances = [.      
+00005c40: 2020 2020 2020 2020 2020 6e6f 6d69 6e61            nomina
+00005c50: 6c5f 706f 696e 742e 6469 7374 616e 6365  l_point.distance
+00005c60: 5f74 6f28 666f 756e 645f 706f 696e 7429  _to(found_point)
+00005c70: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00005c80: 2066 6f72 2066 6f75 6e64 5f70 6f69 6e74   for found_point
+00005c90: 2069 6e20 6465 7465 6374 6564 5f70 6f69   in detected_poi
+00005ca0: 6e74 730a 2020 2020 2020 2020 2020 2020  nts.            
+00005cb0: 5d0a 2020 2020 2020 2020 2020 2020 6d69  ].            mi
+00005cc0: 6e5f 6469 7374 616e 6365 203d 206d 696e  n_distance = min
+00005cd0: 2864 6973 7461 6e63 6573 290a 2020 2020  (distances).    
+00005ce0: 2020 2020 2020 2020 6d69 6e5f 6469 7374          min_dist
+00005cf0: 616e 6365 5f69 6478 203d 2064 6973 7461  ance_idx = dista
+00005d00: 6e63 6573 2e69 6e64 6578 286d 696e 5f64  nces.index(min_d
+00005d10: 6973 7461 6e63 6529 0a20 2020 2020 2020  istance).       
+00005d20: 2020 2020 2069 6620 6d69 6e5f 6469 7374       if min_dist
+00005d30: 616e 6365 203c 2032 3020 2a20 7365 6c66  ance < 20 * self
+00005d40: 2e64 706d 6d3a 0a20 2020 2020 2020 2020  .dpmm:.         
+00005d50: 2020 2020 2020 2062 6273 5b62 625f 6172         bbs[bb_ar
+00005d60: 6e67 2e6e 616d 655d 203d 2064 6574 6563  ng.name] = detec
+00005d70: 7465 645f 706f 696e 7473 5b6d 696e 5f64  ted_points[min_d
+00005d80: 6973 7461 6e63 655f 6964 785d 0a20 2020  istance_idx].   
+00005d90: 2020 2020 2072 6574 7572 6e20 6262 730a       return bbs.
+00005da0: 0a20 2020 2064 6566 2066 6965 6c64 5f74  .    def field_t
+00005db0: 6f5f 6262 5f64 6973 7461 6e63 6573 2873  o_bb_distances(s
+00005dc0: 656c 6629 202d 3e20 6c69 7374 5b66 6c6f  elf) -> list[flo
+00005dd0: 6174 5d3a 0a20 2020 2020 2020 2022 2222  at]:.        """
+00005de0: 5468 6520 6469 7374 616e 6365 7320 6672  The distances fr
+00005df0: 6f6d 2074 6865 2066 6965 6c64 2043 4158  om the field CAX
+00005e00: 7320 746f 2074 6865 2042 4273 2069 6e20  s to the BBs in 
+00005e10: 6d6d 2e20 5573 6566 756c 2066 6f72 206d  mm. Useful for m
+00005e20: 6574 7269 6373 2061 7320 7468 6973 2069  etrics as this i
+00005e30: 7320 6f6e 6c79 0a20 2020 2020 2020 2074  s only.        t
+00005e40: 6865 2072 6573 756c 7469 6e67 2066 6c6f  he resulting flo
+00005e50: 6174 7320 7673 2061 2064 6963 7420 6f66  ats vs a dict of
+00005e60: 2070 6f69 6e74 732e 2222 220a 2020 2020   points.""".    
+00005e70: 2020 2020 7265 7475 726e 205b 0a20 2020      return [.   
+00005e80: 2020 2020 2020 2020 206d 6174 6368 2e62           match.b
+00005e90: 625f 6669 656c 645f 6469 7374 616e 6365  b_field_distance
+00005ea0: 5f6d 6d20 666f 7220 6d61 7463 6820 696e  _mm for match in
+00005eb0: 2073 656c 662e 6172 7261 6e67 656d 656e   self.arrangemen
+00005ec0: 745f 6d61 7463 6865 732e 7661 6c75 6573  t_matches.values
+00005ed0: 2829 0a20 2020 2020 2020 205d 0a0a 2020  ().        ]..  
+00005ee0: 2020 6465 6620 6570 6964 5f74 6f5f 6262    def epid_to_bb
+00005ef0: 5f64 6973 7461 6e63 6573 2873 656c 6629  _distances(self)
+00005f00: 202d 3e20 6c69 7374 5b66 6c6f 6174 5d3a   -> list[float]:
+00005f10: 0a20 2020 2020 2020 2022 2222 5468 6520  .        """The 
+00005f20: 6469 7374 616e 6365 7320 6672 6f6d 2074  distances from t
+00005f30: 6865 2045 5049 4420 6365 6e74 6572 2074  he EPID center t
+00005f40: 6f20 7468 6520 4242 7320 696e 206d 6d2e  o the BBs in mm.
+00005f50: 2055 7365 6675 6c20 666f 7220 6d65 7472   Useful for metr
+00005f60: 6963 7320 6173 2074 6869 7320 6973 206f  ics as this is o
+00005f70: 6e6c 790a 2020 2020 2020 2020 7468 6520  nly.        the 
+00005f80: 7265 7375 6c74 696e 6720 666c 6f61 7473  resulting floats
+00005f90: 2076 7320 6120 6469 6374 206f 6620 706f   vs a dict of po
+00005fa0: 696e 7473 2e22 2222 0a20 2020 2020 2020  ints.""".       
+00005fb0: 2072 6574 7572 6e20 5b0a 2020 2020 2020   return [.      
+00005fc0: 2020 2020 2020 6d61 7463 682e 6262 5f65        match.bb_e
+00005fd0: 7069 645f 6469 7374 616e 6365 5f6d 6d20  pid_distance_mm 
+00005fe0: 666f 7220 6d61 7463 6820 696e 2073 656c  for match in sel
+00005ff0: 662e 6172 7261 6e67 656d 656e 745f 6d61  f.arrangement_ma
+00006000: 7463 6865 732e 7661 6c75 6573 2829 0a20  tches.values(). 
+00006010: 2020 2020 2020 205d 0a0a 2020 2020 6465         ]..    de
+00006020: 6620 706c 6f74 280a 2020 2020 2020 2020  f plot(.        
+00006030: 7365 6c66 2c0a 2020 2020 2020 2020 6178  self,.        ax
+00006040: 3a20 706c 742e 4178 6573 207c 204e 6f6e  : plt.Axes | Non
+00006050: 6520 3d20 4e6f 6e65 2c0a 2020 2020 2020  e = None,.      
+00006060: 2020 7368 6f77 3a20 626f 6f6c 203d 2054    show: bool = T
+00006070: 7275 652c 0a20 2020 2020 2020 2063 6c65  rue,.        cle
+00006080: 6172 5f66 6967 3a20 626f 6f6c 203d 2046  ar_fig: bool = F
+00006090: 616c 7365 2c0a 2020 2020 2020 2020 7a6f  alse,.        zo
+000060a0: 6f6d 3a20 626f 6f6c 203d 2054 7275 652c  om: bool = True,
+000060b0: 0a20 2020 2020 2020 206c 6567 656e 643a  .        legend:
+000060c0: 2062 6f6f 6c20 3d20 5472 7565 2c0a 2020   bool = True,.  
+000060d0: 2020 2920 2d3e 2070 6c74 2e41 7865 733a    ) -> plt.Axes:
+000060e0: 0a20 2020 2020 2020 2022 2222 506c 6f74  .        """Plot
+000060f0: 2061 6e20 696e 6469 7669 6475 616c 2057   an individual W
+00006100: 4c20 696d 6167 652e 0a0a 2020 2020 2020  L image...      
+00006110: 2020 5061 7261 6d65 7465 7273 0a20 2020    Parameters.   
+00006120: 2020 2020 202d 2d2d 2d2d 2d2d 2d2d 2d0a       ----------.
+00006130: 2020 2020 2020 2020 6178 203a 204e 6f6e          ax : Non
+00006140: 652c 2070 6c74 2e41 7865 730a 2020 2020  e, plt.Axes.    
+00006150: 2020 2020 2020 2020 5468 6520 6178 6973          The axis
+00006160: 2074 6f20 706c 6f74 2074 6f2e 2049 6620   to plot to. If 
+00006170: 4e6f 6e65 2c20 6120 6e65 7720 6669 6775  None, a new figu
+00006180: 7265 2069 7320 6372 6561 7465 642e 0a20  re is created.. 
+00006190: 2020 2020 2020 2073 686f 7720 3a20 626f         show : bo
+000061a0: 6f6c 0a20 2020 2020 2020 2020 2020 2057  ol.            W
+000061b0: 6865 7468 6572 2074 6f20 7368 6f77 2074  hether to show t
+000061c0: 6865 2070 6c6f 742e 0a20 2020 2020 2020  he plot..       
+000061d0: 2063 6c65 6172 5f66 6967 203a 2062 6f6f   clear_fig : boo
+000061e0: 6c0a 2020 2020 2020 2020 2020 2020 5768  l.            Wh
+000061f0: 6574 6865 7220 746f 2063 6c65 6172 2074  ether to clear t
+00006200: 6865 2066 6967 7572 6520 6265 666f 7265  he figure before
+00006210: 2070 6c6f 7474 696e 672e 0a20 2020 2020   plotting..     
+00006220: 2020 207a 6f6f 6d20 3a20 626f 6f6c 0a20     zoom : bool. 
+00006230: 2020 2020 2020 2020 2020 2057 6865 7468             Wheth
+00006240: 6572 2074 6f20 7a6f 6f6d 2069 6e20 6f6e  er to zoom in on
+00006250: 2074 6865 2042 4273 2e20 4966 2046 616c   the BBs. If Fal
+00006260: 7365 2c20 6e6f 207a 6f6f 6d69 6e67 2069  se, no zooming i
+00006270: 7320 646f 6e65 2061 6e64 2074 6865 2065  s done and the e
+00006280: 6e74 6972 6520 696d 6167 6520 6973 2073  ntire image is s
+00006290: 686f 776e 2e0a 2020 2020 2020 2020 6c65  hown..        le
+000062a0: 6765 6e64 203a 2062 6f6f 6c0a 2020 2020  gend : bool.    
+000062b0: 2020 2020 2020 2020 5768 6574 6865 7220          Whether 
+000062c0: 746f 2073 686f 7720 7468 6520 6c65 6765  to show the lege
+000062d0: 6e64 2e0a 2020 2020 2020 2020 2222 220a  nd..        """.
+000062e0: 2020 2020 2020 2020 6178 203d 2073 7570          ax = sup
+000062f0: 6572 2829 2e70 6c6f 7428 6178 3d61 782c  er().plot(ax=ax,
+00006300: 2073 686f 773d 4661 6c73 652c 2063 6c65   show=False, cle
+00006310: 6172 5f66 6967 3d63 6c65 6172 5f66 6967  ar_fig=clear_fig
+00006320: 2c20 7368 6f77 5f6d 6574 7269 6373 3d54  , show_metrics=T
+00006330: 7275 6529 0a20 2020 2020 2020 2023 2073  rue).        # s
+00006340: 686f 7720 4550 4944 2063 656e 7465 720a  how EPID center.
+00006350: 2020 2020 2020 2020 6178 2e61 7876 6c69          ax.axvli
+00006360: 6e65 2878 3d73 656c 662e 6570 6964 2e78  ne(x=self.epid.x
+00006370: 2c20 636f 6c6f 723d 2262 2229 0a20 2020  , color="b").   
+00006380: 2020 2020 2065 7069 645f 6861 6e64 6c65       epid_handle
+00006390: 203d 2061 782e 6178 686c 696e 6528 793d   = ax.axhline(y=
+000063a0: 7365 6c66 2e65 7069 642e 792c 2063 6f6c  self.epid.y, col
+000063b0: 6f72 3d22 6222 290a 2020 2020 2020 2020  or="b").        
+000063c0: 2320 7368 6f77 2074 6865 2066 6965 6c64  # show the field
+000063d0: 2043 4158 730a 2020 2020 2020 2020 666f   CAXs.        fo
+000063e0: 7220 6d61 7463 6820 696e 2073 656c 662e  r match in self.
+000063f0: 6172 7261 6e67 656d 656e 745f 6d61 7463  arrangement_matc
+00006400: 6865 732e 7661 6c75 6573 2829 3a0a 2020  hes.values():.  
+00006410: 2020 2020 2020 2020 2020 2866 6965 6c64            (field
+00006420: 5f68 616e 646c 652c 2920 3d20 6178 2e70  _handle,) = ax.p
+00006430: 6c6f 7428 6d61 7463 682e 6669 656c 642e  lot(match.field.
+00006440: 782c 206d 6174 6368 2e66 6965 6c64 2e79  x, match.field.y
+00006450: 2c20 2267 7322 2c20 6d73 3d38 290a 2020  , "gs", ms=8).  
+00006460: 2020 2020 2020 2020 2020 2862 625f 6861            (bb_ha
+00006470: 6e64 6c65 2c29 203d 2061 782e 706c 6f74  ndle,) = ax.plot
+00006480: 286d 6174 6368 2e62 622e 782c 206d 6174  (match.bb.x, mat
+00006490: 6368 2e62 622e 792c 2022 636f 222c 206d  ch.bb.y, "co", m
+000064a0: 733d 3130 290a 2020 2020 2020 2020 6966  s=10).        if
+000064b0: 206c 6567 656e 643a 0a20 2020 2020 2020   legend:.       
+000064c0: 2020 2020 2061 782e 6c65 6765 6e64 280a       ax.legend(.
+000064d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000064e0: 2866 6965 6c64 5f68 616e 646c 652c 2062  (field_handle, b
+000064f0: 625f 6861 6e64 6c65 2c20 6570 6964 5f68  b_handle, epid_h
+00006500: 616e 646c 6529 2c0a 2020 2020 2020 2020  andle),.        
+00006510: 2020 2020 2020 2020 2822 4669 656c 6420          ("Field 
+00006520: 4341 5822 2c20 2244 6574 6563 7465 6420  CAX", "Detected 
+00006530: 4242 222c 2022 4550 4944 2043 656e 7465  BB", "EPID Cente
+00006540: 7222 292c 0a20 2020 2020 2020 2020 2020  r"),.           
+00006550: 2020 2020 206c 6f63 3d22 7570 7065 7220       loc="upper 
+00006560: 7269 6768 7422 2c0a 2020 2020 2020 2020  right",.        
+00006570: 2020 2020 290a 0a20 2020 2020 2020 2069      )..        i
+00006580: 6620 7a6f 6f6d 3a0a 2020 2020 2020 2020  f zoom:.        
+00006590: 2020 2020 2320 6669 6e64 2074 6865 2078      # find the x
+000065a0: 2061 6e64 2079 206c 696d 6974 7320 6261   and y limits ba
+000065b0: 7365 6420 6f6e 2074 6865 2064 6574 6563  sed on the detec
+000065c0: 7465 6420 4242 2070 6f73 6974 696f 6e73  ted BB positions
+000065d0: 0a20 2020 2020 2020 2020 2020 2023 2061  .            # a
+000065e0: 6e64 2061 6464 2061 206d 6172 6769 6e20  nd add a margin 
+000065f0: 6f66 2032 306d 6d0a 2020 2020 2020 2020  of 20mm.        
+00006600: 2020 2020 6d69 6e5f 7820 3d20 280a 2020      min_x = (.  
+00006610: 2020 2020 2020 2020 2020 2020 2020 6d69                mi
+00006620: 6e28 5b6d 6174 6368 2e62 622e 7820 666f  n([match.bb.x fo
+00006630: 7220 6d61 7463 6820 696e 2073 656c 662e  r match in self.
+00006640: 6172 7261 6e67 656d 656e 745f 6d61 7463  arrangement_matc
+00006650: 6865 732e 7661 6c75 6573 2829 5d29 0a20  hes.values()]). 
+00006660: 2020 2020 2020 2020 2020 2020 2020 202d                 -
+00006670: 2032 3020 2a20 7365 6c66 2e64 706d 6d0a   20 * self.dpmm.
+00006680: 2020 2020 2020 2020 2020 2020 290a 2020              ).  
+00006690: 2020 2020 2020 2020 2020 6d69 6e5f 7920            min_y 
+000066a0: 3d20 280a 2020 2020 2020 2020 2020 2020  = (.            
+000066b0: 2020 2020 6d69 6e28 5b6d 6174 6368 2e62      min([match.b
+000066c0: 622e 7920 666f 7220 6d61 7463 6820 696e  b.y for match in
+000066d0: 2073 656c 662e 6172 7261 6e67 656d 656e   self.arrangemen
+000066e0: 745f 6d61 7463 6865 732e 7661 6c75 6573  t_matches.values
+000066f0: 2829 5d29 0a20 2020 2020 2020 2020 2020  ()]).           
+00006700: 2020 2020 202d 2032 3020 2a20 7365 6c66       - 20 * self
+00006710: 2e64 706d 6d0a 2020 2020 2020 2020 2020  .dpmm.          
+00006720: 2020 290a 2020 2020 2020 2020 2020 2020    ).            
+00006730: 6d61 785f 7820 3d20 280a 2020 2020 2020  max_x = (.      
+00006740: 2020 2020 2020 2020 2020 6d61 7828 5b6d            max([m
+00006750: 6174 6368 2e62 622e 7820 666f 7220 6d61  atch.bb.x for ma
+00006760: 7463 6820 696e 2073 656c 662e 6172 7261  tch in self.arra
+00006770: 6e67 656d 656e 745f 6d61 7463 6865 732e  ngement_matches.
+00006780: 7661 6c75 6573 2829 5d29 0a20 2020 2020  values()]).     
+00006790: 2020 2020 2020 2020 2020 202b 2032 3020             + 20 
+000067a0: 2a20 7365 6c66 2e64 706d 6d0a 2020 2020  * self.dpmm.    
+000067b0: 2020 2020 2020 2020 290a 2020 2020 2020          ).      
+000067c0: 2020 2020 2020 6d61 785f 7920 3d20 280a        max_y = (.
 000067d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000067e0: 2020 636f 6c6c 3d63 6f6c 6c2c 0d0a 2020    coll=coll,..  
-000067f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00006800: 2020 2020 2020 636f 7563 683d 636f 7563        couch=couc
-00006810: 682c 0d0a 2020 2020 2020 2020 2020 2020  h,..            
-00006820: 2020 2020 2020 2020 2020 2020 6178 6573              axes
-00006830: 5f70 7265 6369 7369 6f6e 3d61 7865 735f  _precision=axes_
-00006840: 7072 6563 6973 696f 6e2c 0d0a 2020 2020  precision,..    
-00006850: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00006860: 290d 0a20 2020 2020 2020 2020 2020 2020  )..             
-00006870: 2020 2029 0d0a 2020 2020 2020 2020 656c     )..        el
-00006880: 6966 2069 7369 6e73 7461 6e63 6528 6469  if isinstance(di
-00006890: 7265 6374 6f72 792c 206c 6973 7429 3a0d  rectory, list):.
-000068a0: 0a20 2020 2020 2020 2020 2020 2066 6f72  .            for
-000068b0: 2066 696c 6520 696e 2064 6972 6563 746f   file in directo
-000068c0: 7279 3a0d 0a20 2020 2020 2020 2020 2020  ry:..           
-000068d0: 2020 2020 2069 6620 6973 5f69 6d61 6765       if is_image
-000068e0: 2866 696c 6529 3a0d 0a20 2020 2020 2020  (file):..       
-000068f0: 2020 2020 2020 2020 2020 2020 2073 656c               sel
-00006900: 662e 696d 6167 6573 2e61 7070 656e 6428  f.images.append(
-00006910: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-00006920: 2020 2020 2020 2020 2020 7365 6c66 2e5f            self._
-00006930: 6c6f 6164 5f69 6d61 6765 280d 0a20 2020  load_image(..   
-00006940: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00006950: 2020 2020 2020 2020 2066 696c 652c 0d0a           file,..
-00006960: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00006970: 2020 2020 2020 2020 2020 2020 6470 693d              dpi=
-00006980: 6470 692c 0d0a 2020 2020 2020 2020 2020  dpi,..          
-00006990: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000069a0: 2020 7369 643d 7369 642c 0d0a 2020 2020    sid=sid,..    
-000069b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000069c0: 2020 2020 2020 2020 7573 655f 6669 6c65          use_file
-000069d0: 6e61 6d65 733d 7573 655f 6669 6c65 6e61  names=use_filena
-000069e0: 6d65 732c 0d0a 2020 2020 2020 2020 2020  mes,..          
-000069f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00006a00: 2020 6178 6573 5f70 7265 6369 7369 6f6e    axes_precision
-00006a10: 3d61 7865 735f 7072 6563 6973 696f 6e2c  =axes_precision,
-00006a20: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-00006a30: 2020 2020 2020 2020 2020 290d 0a20 2020            )..   
-00006a40: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00006a50: 2029 0d0a 2020 2020 2020 2020 656c 6966   )..        elif
-00006a60: 206e 6f74 206f 7370 2e69 7364 6972 2864   not osp.isdir(d
-00006a70: 6972 6563 746f 7279 293a 0d0a 2020 2020  irectory):..    
-00006a80: 2020 2020 2020 2020 7261 6973 6520 5661          raise Va
-00006a90: 6c75 6545 7272 6f72 280d 0a20 2020 2020  lueError(..     
-00006aa0: 2020 2020 2020 2020 2020 2022 496e 7661             "Inva
-00006ab0: 6c69 6420 6469 7265 6374 6f72 7920 7061  lid directory pa
-00006ac0: 7373 6564 2e20 4368 6563 6b20 7468 6520  ssed. Check the 
-00006ad0: 636f 7272 6563 7420 6d65 7468 6f64 2061  correct method a
-00006ae0: 6e64 2066 696c 6520 7761 7320 7573 6564  nd file was used
-00006af0: 2e22 0d0a 2020 2020 2020 2020 2020 2020  ."..            
-00006b00: 290d 0a20 2020 2020 2020 2065 6c73 653a  )..        else:
-00006b10: 0d0a 2020 2020 2020 2020 2020 2020 696d  ..            im
-00006b20: 6167 655f 6669 6c65 7320 3d20 696d 6167  age_files = imag
-00006b30: 652e 7265 7472 6965 7665 5f69 6d61 6765  e.retrieve_image
-00006b40: 5f66 696c 6573 2864 6972 6563 746f 7279  _files(directory
-00006b50: 290d 0a20 2020 2020 2020 2020 2020 2066  )..            f
-00006b60: 6f72 2066 696c 6520 696e 2069 6d61 6765  or file in image
-00006b70: 5f66 696c 6573 3a0d 0a20 2020 2020 2020  _files:..       
-00006b80: 2020 2020 2020 2020 2073 656c 662e 696d           self.im
-00006b90: 6167 6573 2e61 7070 656e 6428 0d0a 2020  ages.append(..  
-00006ba0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00006bb0: 2020 7365 6c66 2e5f 6c6f 6164 5f69 6d61    self._load_ima
-00006bc0: 6765 280d 0a20 2020 2020 2020 2020 2020  ge(..           
-00006bd0: 2020 2020 2020 2020 2020 2020 2066 696c               fil
-00006be0: 652c 0d0a 2020 2020 2020 2020 2020 2020  e,..            
-00006bf0: 2020 2020 2020 2020 2020 2020 6470 693d              dpi=
-00006c00: 6470 692c 0d0a 2020 2020 2020 2020 2020  dpi,..          
-00006c10: 2020 2020 2020 2020 2020 2020 2020 7369                si
-00006c20: 643d 7369 642c 0d0a 2020 2020 2020 2020  d=sid,..        
-00006c30: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00006c40: 7573 655f 6669 6c65 6e61 6d65 733d 7573  use_filenames=us
-00006c50: 655f 6669 6c65 6e61 6d65 732c 0d0a 2020  e_filenames,..  
-00006c60: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00006c70: 2020 2020 2020 6178 6573 5f70 7265 6369        axes_preci
-00006c80: 7369 6f6e 3d61 7865 735f 7072 6563 6973  sion=axes_precis
-00006c90: 696f 6e2c 0d0a 2020 2020 2020 2020 2020  ion,..          
-00006ca0: 2020 2020 2020 2020 2020 290d 0a20 2020            )..   
-00006cb0: 2020 2020 2020 2020 2020 2020 2029 0d0a               )..
-00006cc0: 2020 2020 2020 2020 6966 206c 656e 2873          if len(s
-00006cd0: 656c 662e 696d 6167 6573 2920 3c20 323a  elf.images) < 2:
-00006ce0: 0d0a 2020 2020 2020 2020 2020 2020 7261  ..            ra
-00006cf0: 6973 6520 5661 6c75 6545 7272 6f72 280d  ise ValueError(.
-00006d00: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00006d10: 2022 3c32 2076 616c 6964 2057 4c20 696d   "<2 valid WL im
-00006d20: 6167 6573 2077 6572 6520 666f 756e 6420  ages were found 
-00006d30: 696e 2074 6865 2066 6f6c 6465 722f 6669  in the folder/fi
-00006d40: 6c65 206f 7220 7061 7373 6564 2e20 456e  le or passed. En
-00006d50: 7375 7265 2079 6f75 2063 686f 7365 2074  sure you chose t
-00006d60: 6865 2063 6f72 7265 6374 2066 6f6c 6465  he correct folde
-00006d70: 722f 6669 6c65 2066 6f72 2061 6e61 6c79  r/file for analy
-00006d80: 7369 732e 220d 0a20 2020 2020 2020 2020  sis."..         
-00006d90: 2020 2029 0d0a 2020 2020 2020 2020 7365     )..        se
-00006da0: 6c66 2e69 6d61 6765 732e 736f 7274 280d  lf.images.sort(.
-00006db0: 0a20 2020 2020 2020 2020 2020 206b 6579  .            key
-00006dc0: 3d6c 616d 6264 6120 693a 2028 692e 6761  =lambda i: (i.ga
-00006dd0: 6e74 7279 5f61 6e67 6c65 2c20 692e 636f  ntry_angle, i.co
-00006de0: 6c6c 696d 6174 6f72 5f61 6e67 6c65 2c20  llimator_angle, 
-00006df0: 692e 636f 7563 685f 616e 676c 6529 0d0a  i.couch_angle)..
-00006e00: 2020 2020 2020 2020 290d 0a20 2020 2020          )..     
-00006e10: 2020 2073 656c 662e 5f69 735f 616e 616c     self._is_anal
-00006e20: 797a 6564 203d 2046 616c 7365 0d0a 0d0a  yzed = False....
-00006e30: 2020 2020 6465 6620 5f6c 6f61 645f 696d      def _load_im
-00006e40: 6167 6528 0d0a 2020 2020 2020 2020 7365  age(..        se
-00006e50: 6c66 2c0d 0a20 2020 2020 2020 2066 696c  lf,..        fil
-00006e60: 653a 2073 7472 207c 2050 6174 682c 0d0a  e: str | Path,..
-00006e70: 2020 2020 2020 2020 7369 643a 2066 6c6f          sid: flo
-00006e80: 6174 207c 204e 6f6e 652c 0d0a 2020 2020  at | None,..    
-00006e90: 2020 2020 6470 693a 2066 6c6f 6174 207c      dpi: float |
-00006ea0: 204e 6f6e 652c 0d0a 2020 2020 2020 2020   None,..        
-00006eb0: 2a2a 6b77 6172 6773 2c0d 0a20 2020 2029  **kwargs,..    )
-00006ec0: 202d 3e20 5769 6e73 746f 6e4c 7574 7a32   -> WinstonLutz2
-00006ed0: 443a 0d0a 2020 2020 2020 2020 2222 2241  D:..        """A
-00006ee0: 2068 656c 7065 7220 6d65 7468 6f64 2074   helper method t
-00006ef0: 6f20 6c6f 6164 2065 6974 6865 7220 4449  o load either DI
-00006f00: 434f 4d20 6f72 2054 4946 4620 6669 6c65  COM or TIFF file
-00006f10: 7320 6170 7072 6f70 7269 6174 656c 792e  s appropriately.
-00006f20: 2222 220d 0a20 2020 2020 2020 2074 7279  """..        try
-00006f30: 3a0d 0a20 2020 2020 2020 2020 2020 2072  :..            r
-00006f40: 6574 7572 6e20 7365 6c66 2e69 6d61 6765  eturn self.image
-00006f50: 5f74 7970 6528 0d0a 2020 2020 2020 2020  _type(..        
-00006f60: 2020 2020 2020 2020 6669 6c65 2c20 6465          file, de
-00006f70: 7465 6374 696f 6e5f 636f 6e64 6974 696f  tection_conditio
-00006f80: 6e73 3d73 656c 662e 6465 7465 6374 696f  ns=self.detectio
-00006f90: 6e5f 636f 6e64 6974 696f 6e73 2c20 2a2a  n_conditions, **
-00006fa0: 6b77 6172 6773 0d0a 2020 2020 2020 2020  kwargs..        
-00006fb0: 2020 2020 290d 0a20 2020 2020 2020 2065      )..        e
-00006fc0: 7863 6570 7420 4174 7472 6962 7574 6545  xcept AttributeE
-00006fd0: 7272 6f72 3a0d 0a20 2020 2020 2020 2020  rror:..         
-00006fe0: 2020 2069 6620 6b77 6172 6773 2e67 6574     if kwargs.get
-00006ff0: 2822 6761 6e74 7279 2229 2069 7320 4e6f  ("gantry") is No
-00007000: 6e65 3a0d 0a20 2020 2020 2020 2020 2020  ne:..           
-00007010: 2020 2020 2072 6169 7365 2056 616c 7565       raise Value
-00007020: 4572 726f 7228 0d0a 2020 2020 2020 2020  Error(..        
-00007030: 2020 2020 2020 2020 2020 2020 2254 4946              "TIF
-00007040: 4620 696d 6167 6573 2064 6574 6563 7465  F images detecte
-00007050: 642e 204d 7573 7420 7061 7373 2060 6178  d. Must pass `ax
-00007060: 6973 5f6d 6170 7069 6e67 6020 7061 7261  is_mapping` para
-00007070: 6d65 7465 722e 220d 0a20 2020 2020 2020  meter."..       
-00007080: 2020 2020 2020 2020 2029 0d0a 2020 2020           )..    
-00007090: 2020 2020 2020 2020 6966 2073 6964 2069          if sid i
-000070a0: 7320 4e6f 6e65 3a0d 0a20 2020 2020 2020  s None:..       
-000070b0: 2020 2020 2020 2020 2072 6169 7365 2056           raise V
-000070c0: 616c 7565 4572 726f 7228 2254 4946 4620  alueError("TIFF 
-000070d0: 696d 6167 6573 2064 6574 6563 7465 642e  images detected.
-000070e0: 204d 7573 7420 7061 7373 2060 7369 6460   Must pass `sid`
-000070f0: 2070 6172 616d 6574 6572 2229 0d0a 2020   parameter")..  
-00007100: 2020 2020 2020 2020 2020 7769 7468 2069            with i
-00007110: 6f2e 4279 7465 7349 4f28 2920 6173 2073  o.BytesIO() as s
-00007120: 7472 6561 6d3a 0d0a 2020 2020 2020 2020  tream:..        
-00007130: 2020 2020 2020 2020 6473 203d 2074 6966          ds = tif
-00007140: 665f 746f 5f64 6963 6f6d 280d 0a20 2020  f_to_dicom(..   
-00007150: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00007160: 2074 6966 665f 6669 6c65 3d66 696c 652c   tiff_file=file,
-00007170: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-00007180: 2020 2020 2020 7369 643d 7369 642c 0d0a        sid=sid,..
-00007190: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000071a0: 2020 2020 6470 693d 6470 692c 0d0a 2020      dpi=dpi,..  
-000071b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000071c0: 2020 6761 6e74 7279 3d6b 7761 7267 732e    gantry=kwargs.
-000071d0: 706f 7028 2267 616e 7472 7922 292c 0d0a  pop("gantry"),..
-000071e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000071f0: 2020 2020 636f 6c6c 3d6b 7761 7267 732e      coll=kwargs.
-00007200: 706f 7028 2263 6f6c 6c22 292c 0d0a 2020  pop("coll"),..  
-00007210: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00007220: 2020 636f 7563 683d 6b77 6172 6773 2e70    couch=kwargs.p
-00007230: 6f70 2822 636f 7563 6822 292c 0d0a 2020  op("couch"),..  
-00007240: 2020 2020 2020 2020 2020 2020 2020 290d                ).
-00007250: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00007260: 2064 732e 7361 7665 5f61 7328 7374 7265   ds.save_as(stre
-00007270: 616d 2c20 7772 6974 655f 6c69 6b65 5f6f  am, write_like_o
-00007280: 7269 6769 6e61 6c3d 4661 6c73 6529 0d0a  riginal=False)..
-00007290: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000072a0: 696d 6720 3d20 7365 6c66 2e69 6d61 6765  img = self.image
-000072b0: 5f74 7970 6528 0d0a 2020 2020 2020 2020  _type(..        
-000072c0: 2020 2020 2020 2020 2020 2020 7374 7265              stre
-000072d0: 616d 2c20 6465 7465 6374 696f 6e5f 636f  am, detection_co
-000072e0: 6e64 6974 696f 6e73 3d73 656c 662e 6465  nditions=self.de
-000072f0: 7465 6374 696f 6e5f 636f 6e64 6974 696f  tection_conditio
-00007300: 6e73 2c20 2a2a 6b77 6172 6773 0d0a 2020  ns, **kwargs..  
-00007310: 2020 2020 2020 2020 2020 2020 2020 290d                ).
-00007320: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00007330: 2069 6620 6e6f 7420 696d 672e 6470 6d6d   if not img.dpmm
-00007340: 3a0d 0a20 2020 2020 2020 2020 2020 2020  :..             
-00007350: 2020 2020 2020 2072 6169 7365 2056 616c         raise Val
-00007360: 7565 4572 726f 7228 0d0a 2020 2020 2020  ueError(..      
-00007370: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00007380: 2020 2254 4946 4620 696d 6167 6573 2077    "TIFF images w
-00007390: 6572 6520 6465 7465 6374 6564 2062 7574  ere detected but
-000073a0: 2074 6865 2064 7069 2074 6167 2077 6173   the dpi tag was
-000073b0: 206e 6f74 2061 7661 696c 6162 6c65 2e20   not available. 
-000073c0: 5061 7373 2074 6865 2060 6470 6960 2070  Pass the `dpi` p
-000073d0: 6172 616d 6574 6572 206d 616e 7561 6c6c  arameter manuall
-000073e0: 792e 220d 0a20 2020 2020 2020 2020 2020  y."..           
-000073f0: 2020 2020 2020 2020 2029 0d0a 2020 2020           )..    
-00007400: 2020 2020 2020 2020 2020 2020 696d 672e              img.
-00007410: 6669 6c74 6572 2873 697a 653d 302e 3031  filter(size=0.01
-00007420: 2c20 6b69 6e64 3d22 6d65 6469 616e 2229  , kind="median")
-00007430: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-00007440: 2020 7265 7475 726e 2069 6d67 0d0a 0d0a    return img....
-00007450: 2020 2020 4063 6c61 7373 6d65 7468 6f64      @classmethod
-00007460: 0d0a 2020 2020 6465 6620 6672 6f6d 5f64  ..    def from_d
-00007470: 656d 6f5f 696d 6167 6573 2863 6c73 2c20  emo_images(cls, 
-00007480: 2a2a 6b77 6172 6773 293a 0d0a 2020 2020  **kwargs):..    
-00007490: 2020 2020 2222 2249 6e73 7461 6e74 6961      """Instantia
-000074a0: 7465 2075 7369 6e67 2074 6865 2064 656d  te using the dem
-000074b0: 6f20 696d 6167 6573 2e0d 0a0d 0a20 2020  o images.....   
-000074c0: 2020 2020 2050 6172 616d 6574 6572 730d       Parameters.
-000074d0: 0a20 2020 2020 2020 202d 2d2d 2d2d 2d2d  .        -------
-000074e0: 2d2d 2d0d 0a20 2020 2020 2020 206b 7761  ---..        kwa
-000074f0: 7267 730d 0a20 2020 2020 2020 2020 2020  rgs..           
-00007500: 2053 6565 2070 6172 616d 6574 6572 7320   See parameters 
-00007510: 6f66 2074 6865 205f 5f69 6e69 745f 5f20  of the __init__ 
-00007520: 6d65 7468 6f64 2066 6f72 2064 6574 6169  method for detai
-00007530: 6c73 2e0d 0a20 2020 2020 2020 2022 2222  ls...        """
-00007540: 0d0a 2020 2020 2020 2020 6465 6d6f 5f66  ..        demo_f
-00007550: 696c 6520 3d20 7265 7472 6965 7665 5f64  ile = retrieve_d
-00007560: 656d 6f5f 6669 6c65 286e 616d 653d 2277  emo_file(name="w
-00007570: 696e 7374 6f6e 5f6c 7574 7a2e 7a69 7022  inston_lutz.zip"
-00007580: 290d 0a20 2020 2020 2020 2072 6574 7572  )..        retur
-00007590: 6e20 636c 732e 6672 6f6d 5f7a 6970 2864  n cls.from_zip(d
-000075a0: 656d 6f5f 6669 6c65 2c20 2a2a 6b77 6172  emo_file, **kwar
-000075b0: 6773 290d 0a0d 0a20 2020 2040 636c 6173  gs)....    @clas
-000075c0: 736d 6574 686f 640d 0a20 2020 2064 6566  smethod..    def
-000075d0: 2066 726f 6d5f 7a69 7028 636c 732c 207a   from_zip(cls, z
-000075e0: 6669 6c65 3a20 7374 7220 7c20 4269 6e61  file: str | Bina
-000075f0: 7279 494f 2c20 2a2a 6b77 6172 6773 293a  ryIO, **kwargs):
-00007600: 0d0a 2020 2020 2020 2020 2222 2249 6e73  ..        """Ins
-00007610: 7461 6e74 6961 7465 2066 726f 6d20 6120  tantiate from a 
-00007620: 7a69 7020 6669 6c65 2072 6174 6865 7220  zip file rather 
-00007630: 7468 616e 2061 2064 6972 6563 746f 7279  than a directory
-00007640: 2e0d 0a0d 0a20 2020 2020 2020 2050 6172  .....        Par
-00007650: 616d 6574 6572 730d 0a20 2020 2020 2020  ameters..       
-00007660: 202d 2d2d 2d2d 2d2d 2d2d 2d0d 0a20 2020   ----------..   
-00007670: 2020 2020 207a 6669 6c65 0d0a 2020 2020       zfile..    
-00007680: 2020 2020 2020 2020 5061 7468 2074 6f20          Path to 
-00007690: 7468 6520 6172 6368 6976 6520 6669 6c65  the archive file
-000076a0: 2e0d 0a20 2020 2020 2020 206b 7761 7267  ...        kwarg
-000076b0: 730d 0a20 2020 2020 2020 2020 2020 2053  s..            S
-000076c0: 6565 2070 6172 616d 6574 6572 7320 6f66  ee parameters of
-000076d0: 2074 6865 205f 5f69 6e69 745f 5f20 6d65   the __init__ me
-000076e0: 7468 6f64 2066 6f72 2064 6574 6169 6c73  thod for details
-000076f0: 2e0d 0a20 2020 2020 2020 2022 2222 0d0a  ...        """..
-00007700: 2020 2020 2020 2020 7769 7468 2054 656d          with Tem
-00007710: 706f 7261 7279 5a69 7044 6972 6563 746f  poraryZipDirecto
-00007720: 7279 287a 6669 6c65 2920 6173 2074 6d70  ry(zfile) as tmp
-00007730: 7a3a 0d0a 2020 2020 2020 2020 2020 2020  z:..            
-00007740: 6f62 6a20 3d20 636c 7328 746d 707a 2c20  obj = cls(tmpz, 
-00007750: 2a2a 6b77 6172 6773 290d 0a20 2020 2020  **kwargs)..     
-00007760: 2020 2072 6574 7572 6e20 6f62 6a0d 0a0d     return obj...
-00007770: 0a20 2020 2040 636c 6173 736d 6574 686f  .    @classmetho
-00007780: 640d 0a20 2020 2064 6566 2066 726f 6d5f  d..    def from_
-00007790: 7572 6c28 636c 732c 2075 726c 3a20 7374  url(cls, url: st
-000077a0: 722c 202a 2a6b 7761 7267 7329 3a0d 0a20  r, **kwargs):.. 
-000077b0: 2020 2020 2020 2022 2222 496e 7374 616e         """Instan
-000077c0: 7469 6174 6520 6672 6f6d 2061 2055 524c  tiate from a URL
-000077d0: 2e0d 0a0d 0a20 2020 2020 2020 2050 6172  .....        Par
-000077e0: 616d 6574 6572 730d 0a20 2020 2020 2020  ameters..       
-000077f0: 202d 2d2d 2d2d 2d2d 2d2d 2d0d 0a20 2020   ----------..   
-00007800: 2020 2020 2075 726c 203a 2073 7472 0d0a       url : str..
-00007810: 2020 2020 2020 2020 2020 2020 5552 4c20              URL 
-00007820: 7468 6174 2070 6f69 6e74 7320 746f 2061  that points to a
-00007830: 207a 6970 2061 7263 6869 7665 206f 6620   zip archive of 
-00007840: 7468 6520 4449 434f 4d20 696d 6167 6573  the DICOM images
-00007850: 2e0d 0a20 2020 2020 2020 206b 7761 7267  ...        kwarg
-00007860: 730d 0a20 2020 2020 2020 2020 2020 2053  s..            S
-00007870: 6565 2070 6172 616d 6574 6572 7320 6f66  ee parameters of
-00007880: 2074 6865 205f 5f69 6e69 745f 5f20 6d65   the __init__ me
-00007890: 7468 6f64 2066 6f72 2064 6574 6169 6c73  thod for details
-000078a0: 2e0d 0a20 2020 2020 2020 2022 2222 0d0a  ...        """..
-000078b0: 2020 2020 2020 2020 7a66 696c 6520 3d20          zfile = 
-000078c0: 6765 745f 7572 6c28 7572 6c29 0d0a 2020  get_url(url)..  
-000078d0: 2020 2020 2020 7265 7475 726e 2063 6c73        return cls
-000078e0: 2e66 726f 6d5f 7a69 7028 7a66 696c 652c  .from_zip(zfile,
-000078f0: 202a 2a6b 7761 7267 7329 0d0a 0d0a 2020   **kwargs)....  
-00007900: 2020 4063 6c61 7373 6d65 7468 6f64 0d0a    @classmethod..
-00007910: 2020 2020 6465 6620 6672 6f6d 5f63 6263      def from_cbc
-00007920: 745f 7a69 7028 636c 732c 2066 696c 653a  t_zip(cls, file:
-00007930: 2050 6174 6820 7c20 7374 722c 2072 6177   Path | str, raw
-00007940: 5f70 6978 656c 733a 2062 6f6f 6c20 3d20  _pixels: bool = 
-00007950: 4661 6c73 652c 202a 2a6b 7761 7267 7329  False, **kwargs)
-00007960: 3a0d 0a20 2020 2020 2020 2022 2222 496e  :..        """In
-00007970: 7374 616e 7469 6174 6520 6672 6f6d 2061  stantiate from a
-00007980: 207a 6970 2066 696c 6520 636f 6e74 6169   zip file contai
-00007990: 6e69 6e67 2043 4243 5420 696d 6167 6573  ning CBCT images
-000079a0: 2e0d 0a0d 0a20 2020 2020 2020 2050 6172  .....        Par
-000079b0: 616d 6574 6572 730d 0a20 2020 2020 2020  ameters..       
-000079c0: 202d 2d2d 2d2d 2d2d 2d2d 2d0d 0a20 2020   ----------..   
-000079d0: 2020 2020 2066 696c 650d 0a20 2020 2020       file..     
-000079e0: 2020 2020 2020 2050 6174 6820 746f 2074         Path to t
-000079f0: 6865 2061 7263 6869 7665 2066 696c 652e  he archive file.
-00007a00: 0d0a 2020 2020 2020 2020 7261 775f 7069  ..        raw_pi
-00007a10: 7865 6c73 0d0a 2020 2020 2020 2020 2020  xels..          
-00007a20: 2020 4966 2054 7275 652c 2075 7365 7320    If True, uses 
-00007a30: 7468 6520 7261 7720 7069 7865 6c20 7661  the raw pixel va
-00007a40: 6c75 6573 206f 6620 7468 6520 4449 434f  lues of the DICO
-00007a50: 4d20 6669 6c65 732e 2049 6620 4661 6c73  M files. If Fals
-00007a60: 652c 2075 7365 7320 7468 6520 7265 7363  e, uses the resc
-00007a70: 616c 6564 2048 6f75 6e73 6669 656c 6420  aled Hounsfield 
-00007a80: 756e 6974 732e 0d0a 2020 2020 2020 2020  units...        
-00007a90: 2020 2020 4765 6e65 7261 6c6c 792c 2074      Generally, t
-00007aa0: 6869 7320 7368 6f75 6c64 2062 6520 7472  his should be tr
-00007ab0: 7565 2e0d 0a20 2020 2020 2020 206b 7761  ue...        kwa
-00007ac0: 7267 730d 0a20 2020 2020 2020 2020 2020  rgs..           
-00007ad0: 2053 6565 2070 6172 616d 6574 6572 7320   See parameters 
-00007ae0: 6f66 2074 6865 205f 5f69 6e69 745f 5f20  of the __init__ 
-00007af0: 6d65 7468 6f64 2066 6f72 2064 6574 6169  method for detai
-00007b00: 6c73 2e0d 0a20 2020 2020 2020 2022 2222  ls...        """
-00007b10: 0d0a 2020 2020 2020 2020 7769 7468 2054  ..        with T
-00007b20: 656d 706f 7261 7279 5a69 7044 6972 6563  emporaryZipDirec
-00007b30: 746f 7279 2866 696c 6529 2061 7320 746d  tory(file) as tm
-00007b40: 707a 3a0d 0a20 2020 2020 2020 2020 2020  pz:..           
-00007b50: 206f 626a 203d 2063 6c73 2e66 726f 6d5f   obj = cls.from_
-00007b60: 6362 6374 2874 6d70 7a2c 2072 6177 5f70  cbct(tmpz, raw_p
-00007b70: 6978 656c 733d 7261 775f 7069 7865 6c73  ixels=raw_pixels
-00007b80: 2c20 2a2a 6b77 6172 6773 290d 0a20 2020  , **kwargs)..   
-00007b90: 2020 2020 2072 6574 7572 6e20 6f62 6a0d       return obj.
-00007ba0: 0a0d 0a20 2020 2040 636c 6173 736d 6574  ...    @classmet
-00007bb0: 686f 640d 0a20 2020 2064 6566 2066 726f  hod..    def fro
-00007bc0: 6d5f 6362 6374 2863 6c73 2c20 6469 7265  m_cbct(cls, dire
-00007bd0: 6374 6f72 793a 2050 6174 6820 7c20 7374  ctory: Path | st
-00007be0: 722c 2072 6177 5f70 6978 656c 733a 2062  r, raw_pixels: b
-00007bf0: 6f6f 6c20 3d20 4661 6c73 652c 202a 2a6b  ool = False, **k
-00007c00: 7761 7267 7329 3a0d 0a20 2020 2020 2020  wargs):..       
-00007c10: 2022 2222 4372 6561 7465 2061 2034 2d61   """Create a 4-a
-00007c20: 6e67 6c65 2057 4c20 7465 7374 2066 726f  ngle WL test fro
-00007c30: 6d20 6120 4342 4354 2064 6174 6173 6574  m a CBCT dataset
-00007c40: 2e0d 0a0d 0a20 2020 2020 2020 2054 6865  .....        The
-00007c50: 2064 6174 6173 6574 2069 7320 6c6f 6164   dataset is load
-00007c60: 6564 2061 6e64 2074 6865 2061 7272 6179  ed and the array
-00007c70: 2069 7320 2276 6965 7765 6422 2066 726f   is "viewed" fro
-00007c80: 6d20 746f 702c 2062 6f74 746f 6d2c 206c  m top, bottom, l
-00007c90: 6566 742c 2061 6e64 2072 6967 6874 2074  eft, and right t
-00007ca0: 6f20 6372 6561 7465 2074 6865 2034 2061  o create the 4 a
-00007cb0: 6e67 6c65 732e 0d0a 2020 2020 2020 2020  ngles...        
-00007cc0: 5468 6520 6461 7461 7365 7420 6861 7320  The dataset has 
-00007cd0: 746f 2062 6520 7265 7363 616c 6564 2073  to be rescaled s
-00007ce0: 6f20 7468 6174 2074 6865 207a 2d61 7869  o that the z-axi
-00007cf0: 7320 7370 6163 696e 6720 6973 2065 7175  s spacing is equ
-00007d00: 616c 2074 6f20 7468 6520 782f 7920 6178  al to the x/y ax
-00007d10: 6973 2e20 5468 6973 2069 7320 6265 6361  is. This is beca
-00007d20: 7573 6520 7468 650d 0a20 2020 2020 2020  use the..       
-00007d30: 2074 7970 6963 616c 2073 6c69 6365 2074   typical slice t
-00007d40: 6869 636b 6e65 7373 2069 7320 6d75 6368  hickness is much
-00007d50: 206c 6172 6765 7220 7468 616e 2074 6865   larger than the
-00007d60: 2069 6e2d 706c 616e 6520 7265 736f 6c75   in-plane resolu
-00007d70: 7469 6f6e 2e0d 0a0d 0a20 2020 2020 2020  tion.....       
-00007d80: 2050 6172 616d 6574 6572 730d 0a20 2020   Parameters..   
-00007d90: 2020 2020 202d 2d2d 2d2d 2d2d 2d2d 2d0d       ----------.
-00007da0: 0a20 2020 2020 2020 2064 6972 6563 746f  .        directo
-00007db0: 7279 0d0a 2020 2020 2020 2020 2020 2020  ry..            
-00007dc0: 5468 6520 6469 7265 6374 6f72 7920 636f  The directory co
-00007dd0: 6e74 6169 6e69 6e67 2074 6865 2043 4243  ntaining the CBC
-00007de0: 5420 4449 434f 4d20 6669 6c65 732e 0d0a  T DICOM files...
-00007df0: 2020 2020 2020 2020 7261 775f 7069 7865          raw_pixe
-00007e00: 6c73 0d0a 2020 2020 2020 2020 2020 2020  ls..            
-00007e10: 4966 2054 7275 652c 2075 7365 7320 7468  If True, uses th
-00007e20: 6520 7261 7720 7069 7865 6c20 7661 6c75  e raw pixel valu
-00007e30: 6573 206f 6620 7468 6520 4449 434f 4d20  es of the DICOM 
-00007e40: 6669 6c65 732e 2049 6620 4661 6c73 652c  files. If False,
-00007e50: 2075 7365 7320 7468 6520 7265 7363 616c   uses the rescal
-00007e60: 6564 2048 6f75 6e73 6669 656c 6420 756e  ed Hounsfield un
-00007e70: 6974 732e 0d0a 2020 2020 2020 2020 2020  its...          
-00007e80: 2020 4765 6e65 7261 6c6c 792c 2074 6869    Generally, thi
-00007e90: 7320 7368 6f75 6c64 2062 6520 7472 7565  s should be true
-00007ea0: 2e0d 0a20 2020 2020 2020 206b 7761 7267  ...        kwarg
-00007eb0: 730d 0a20 2020 2020 2020 2020 2020 2053  s..            S
-00007ec0: 6565 2070 6172 616d 6574 6572 7320 6f66  ee parameters of
-00007ed0: 2074 6865 205f 5f69 6e69 745f 5f20 6d65   the __init__ me
-00007ee0: 7468 6f64 2066 6f72 2064 6574 6169 6c73  thod for details
-00007ef0: 2e0d 0a20 2020 2020 2020 2022 2222 0d0a  ...        """..
-00007f00: 2020 2020 2020 2020 6469 636f 6d5f 7374          dicom_st
-00007f10: 6163 6b20 3d20 4469 636f 6d49 6d61 6765  ack = DicomImage
-00007f20: 5374 6163 6b28 0d0a 2020 2020 2020 2020  Stack(..        
-00007f30: 2020 2020 666f 6c64 6572 3d64 6972 6563      folder=direc
-00007f40: 746f 7279 2c20 6d69 6e5f 6e75 6d62 6572  tory, min_number
-00007f50: 3d31 302c 2072 6177 5f70 6978 656c 733d  =10, raw_pixels=
-00007f60: 7261 775f 7069 7865 6c73 0d0a 2020 2020  raw_pixels..    
-00007f70: 2020 2020 290d 0a20 2020 2020 2020 206e      )..        n
-00007f80: 705f 7374 6163 6b20 3d20 6e70 2e73 7461  p_stack = np.sta
-00007f90: 636b 2864 6963 6f6d 5f73 7461 636b 2e69  ck(dicom_stack.i
-00007fa0: 6d61 6765 732c 2061 7869 733d 2d31 290d  mages, axis=-1).
-00007fb0: 0a20 2020 2020 2020 207a 6f6f 6d5f 7261  .        zoom_ra
-00007fc0: 7469 6f20 3d20 280d 0a20 2020 2020 2020  tio = (..       
-00007fd0: 2020 2020 2031 2c0d 0a20 2020 2020 2020       1,..       
-00007fe0: 2020 2020 2064 6963 6f6d 5f73 7461 636b       dicom_stack
-00007ff0: 2e6d 6574 6164 6174 612e 536c 6963 6554  .metadata.SliceT
-00008000: 6869 636b 6e65 7373 202f 2064 6963 6f6d  hickness / dicom
-00008010: 5f73 7461 636b 2e6d 6574 6164 6174 612e  _stack.metadata.
-00008020: 5069 7865 6c53 7061 6369 6e67 5b30 5d2c  PixelSpacing[0],
-00008030: 0d0a 2020 2020 2020 2020 290d 0a20 2020  ..        )..   
-00008040: 2020 2020 206c 6566 745f 6172 7220 3d20       left_arr = 
-00008050: 6e70 2e72 6f74 3930 280d 0a20 2020 2020  np.rot90(..     
-00008060: 2020 2020 2020 207a 6f6f 6d28 0d0a 2020         zoom(..  
-00008070: 2020 2020 2020 2020 2020 2020 2020 6e70                np
-00008080: 5f73 7461 636b 2e6d 6178 2861 7869 733d  _stack.max(axis=
-00008090: 3029 2c0d 0a20 2020 2020 2020 2020 2020  0),..           
-000080a0: 2020 2020 207a 6f6f 6d3d 7a6f 6f6d 5f72       zoom=zoom_r
-000080b0: 6174 696f 2c0d 0a20 2020 2020 2020 2020  atio,..         
-000080c0: 2020 2020 2020 2067 7269 645f 6d6f 6465         grid_mode
-000080d0: 3d54 7275 652c 0d0a 2020 2020 2020 2020  =True,..        
-000080e0: 2020 2020 2020 2020 6d6f 6465 3d22 6e65          mode="ne
-000080f0: 6172 6573 7422 2c0d 0a20 2020 2020 2020  arest",..       
-00008100: 2020 2020 2020 2020 206f 7264 6572 3d31           order=1
-00008110: 2c0d 0a20 2020 2020 2020 2020 2020 2029  ,..            )
-00008120: 2c0d 0a20 2020 2020 2020 2020 2020 206b  ,..            k
-00008130: 3d31 2c0d 0a20 2020 2020 2020 2029 0d0a  =1,..        )..
-00008140: 2020 2020 2020 2020 746f 705f 6172 7220          top_arr 
-00008150: 3d20 6e70 2e72 6f74 3930 280d 0a20 2020  = np.rot90(..   
-00008160: 2020 2020 2020 2020 207a 6f6f 6d28 0d0a           zoom(..
-00008170: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00008180: 6e70 5f73 7461 636b 2e6d 6178 2861 7869  np_stack.max(axi
-00008190: 733d 3129 2c0d 0a20 2020 2020 2020 2020  s=1),..         
-000081a0: 2020 2020 2020 207a 6f6f 6d3d 7a6f 6f6d         zoom=zoom
-000081b0: 5f72 6174 696f 2c0d 0a20 2020 2020 2020  _ratio,..       
-000081c0: 2020 2020 2020 2020 2067 7269 645f 6d6f           grid_mo
-000081d0: 6465 3d54 7275 652c 0d0a 2020 2020 2020  de=True,..      
-000081e0: 2020 2020 2020 2020 2020 6d6f 6465 3d22            mode="
-000081f0: 6e65 6172 6573 7422 2c0d 0a20 2020 2020  nearest",..     
-00008200: 2020 2020 2020 2020 2020 206f 7264 6572             order
-00008210: 3d31 2c0d 0a20 2020 2020 2020 2020 2020  =1,..           
-00008220: 2029 2c0d 0a20 2020 2020 2020 2020 2020   ),..           
-00008230: 206b 3d31 2c0d 0a20 2020 2020 2020 2029   k=1,..        )
-00008240: 0d0a 2020 2020 2020 2020 7269 6768 745f  ..        right_
-00008250: 6172 7220 3d20 6e70 2e66 6c69 706c 7228  arr = np.fliplr(
-00008260: 6c65 6674 5f61 7272 290d 0a20 2020 2020  left_arr)..     
-00008270: 2020 2062 6f74 746f 6d5f 6172 7220 3d20     bottom_arr = 
-00008280: 6e70 2e66 6c69 706c 7228 746f 705f 6172  np.fliplr(top_ar
-00008290: 7229 0d0a 2020 2020 2020 2020 6469 636f  r)..        dico
-000082a0: 6d5f 6469 7220 3d20 5061 7468 2874 656d  m_dir = Path(tem
-000082b0: 7066 696c 652e 6d6b 6474 656d 7028 2929  pfile.mkdtemp())
-000082c0: 0d0a 2020 2020 2020 2020 6470 6920 3d20  ..        dpi = 
-000082d0: 3235 2e34 202f 2064 6963 6f6d 5f73 7461  25.4 / dicom_sta
-000082e0: 636b 2e6d 6574 6164 6174 612e 5069 7865  ck.metadata.Pixe
-000082f0: 6c53 7061 6369 6e67 5b30 5d0d 0a20 2020  lSpacing[0]..   
-00008300: 2020 2020 2066 6f72 2061 7272 6179 2c20       for array, 
-00008310: 6761 6e74 7279 2069 6e20 7a69 7028 0d0a  gantry in zip(..
-00008320: 2020 2020 2020 2020 2020 2020 286c 6566              (lef
-00008330: 745f 6172 722c 2074 6f70 5f61 7272 2c20  t_arr, top_arr, 
-00008340: 7269 6768 745f 6172 722c 2062 6f74 746f  right_arr, botto
-00008350: 6d5f 6172 7229 2c20 2832 3730 2c20 302c  m_arr), (270, 0,
-00008360: 2039 302c 2031 3830 290d 0a20 2020 2020   90, 180)..     
-00008370: 2020 2029 3a0d 0a20 2020 2020 2020 2020     ):..         
-00008380: 2020 2064 7320 3d20 6172 7261 795f 746f     ds = array_to
-00008390: 5f64 6963 6f6d 280d 0a20 2020 2020 2020  _dicom(..       
-000083a0: 2020 2020 2020 2020 2061 7272 6179 3d6e           array=n
-000083b0: 702e 6173 636f 6e74 6967 756f 7573 6172  p.ascontiguousar
-000083c0: 7261 7928 6172 7261 7929 2c20 2023 2070  ray(array),  # p
-000083d0: 7964 6963 6f6d 2063 6f6d 706c 6169 6e73  ydicom complains
-000083e0: 2064 7565 2074 6f20 6e70 2e72 6f74 3930   due to np.rot90
-000083f0: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-00008400: 2020 7369 643d 3130 3030 2c0d 0a20 2020    sid=1000,..   
-00008410: 2020 2020 2020 2020 2020 2020 2067 616e               gan
-00008420: 7472 793d 6761 6e74 7279 2c0d 0a20 2020  try=gantry,..   
-00008430: 2020 2020 2020 2020 2020 2020 2063 6f6c               col
-00008440: 6c3d 302c 0d0a 2020 2020 2020 2020 2020  l=0,..          
-00008450: 2020 2020 2020 636f 7563 683d 302c 0d0a        couch=0,..
-00008460: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00008470: 6470 693d 6470 692c 0d0a 2020 2020 2020  dpi=dpi,..      
-00008480: 2020 2020 2020 290d 0a20 2020 2020 2020        )..       
-00008490: 2020 2020 2064 732e 7361 7665 5f61 7328       ds.save_as(
-000084a0: 6469 636f 6d5f 6469 7220 2f20 6622 473d  dicom_dir / f"G=
-000084b0: 7b67 616e 7472 797d 222c 2077 7269 7465  {gantry}", write
-000084c0: 5f6c 696b 655f 6f72 6967 696e 616c 3d46  _like_original=F
-000084d0: 616c 7365 290d 0a20 2020 2020 2020 2023  alse)..        #
-000084e0: 206e 6f77 2077 6520 6c6f 6164 2074 6865   now we load the
-000084f0: 7365 2061 7320 6e6f 726d 616c 2069 6d61  se as normal ima
-00008500: 6765 7320 696e 746f 2074 6865 2057 4c20  ges into the WL 
-00008510: 616c 676f 7269 7468 6d0d 0a20 2020 2020  algorithm..     
-00008520: 2020 2069 6e73 7461 6e63 6520 3d20 636c     instance = cl
-00008530: 7328 6469 636f 6d5f 6469 722c 202a 2a6b  s(dicom_dir, **k
-00008540: 7761 7267 7329 0d0a 2020 2020 2020 2020  wargs)..        
-00008550: 696e 7374 616e 6365 2e69 735f 6672 6f6d  instance.is_from
-00008560: 5f63 6263 7420 3d20 5472 7565 0d0a 2020  _cbct = True..  
-00008570: 2020 2020 2020 7265 7475 726e 2069 6e73        return ins
-00008580: 7461 6e63 650d 0a0d 0a20 2020 2040 7374  tance....    @st
-00008590: 6174 6963 6d65 7468 6f64 0d0a 2020 2020  aticmethod..    
-000085a0: 6465 6620 7275 6e5f 6465 6d6f 2829 202d  def run_demo() -
-000085b0: 3e20 4e6f 6e65 3a0d 0a20 2020 2020 2020  > None:..       
-000085c0: 2022 2222 5275 6e20 7468 6520 5769 6e73   """Run the Wins
-000085d0: 746f 6e2d 4c75 747a 2064 656d 6f2c 2077  ton-Lutz demo, w
-000085e0: 6869 6368 206c 6f61 6473 2074 6865 2064  hich loads the d
-000085f0: 656d 6f20 6669 6c65 732c 2070 7269 6e74  emo files, print
-00008600: 7320 7265 7375 6c74 732c 2061 6e64 2070  s results, and p
-00008610: 6c6f 7473 2061 2073 756d 6d61 7279 2069  lots a summary i
-00008620: 6d61 6765 2e22 2222 0d0a 2020 2020 2020  mage."""..      
-00008630: 2020 776c 203d 2057 696e 7374 6f6e 4c75    wl = WinstonLu
-00008640: 747a 2e66 726f 6d5f 6465 6d6f 5f69 6d61  tz.from_demo_ima
-00008650: 6765 7328 290d 0a20 2020 2020 2020 2077  ges()..        w
-00008660: 6c2e 616e 616c 797a 6528 6d61 6368 696e  l.analyze(machin
-00008670: 655f 7363 616c 653d 4d61 6368 696e 6553  e_scale=MachineS
-00008680: 6361 6c65 2e56 4152 4941 4e5f 4945 4329  cale.VARIAN_IEC)
-00008690: 0d0a 2020 2020 2020 2020 7072 696e 7428  ..        print(
-000086a0: 776c 2e72 6573 756c 7473 2829 290d 0a20  wl.results()).. 
-000086b0: 2020 2020 2020 2077 6c2e 706c 6f74 5f73         wl.plot_s
-000086c0: 756d 6d61 7279 2829 0d0a 0d0a 2020 2020  ummary()....    
-000086d0: 6465 6620 616e 616c 797a 6528 0d0a 2020  def analyze(..  
-000086e0: 2020 2020 2020 7365 6c66 2c0d 0a20 2020        self,..   
-000086f0: 2020 2020 2062 625f 7369 7a65 5f6d 6d3a       bb_size_mm:
-00008700: 2066 6c6f 6174 203d 2035 2c0d 0a20 2020   float = 5,..   
-00008710: 2020 2020 206d 6163 6869 6e65 5f73 6361       machine_sca
-00008720: 6c65 3a20 4d61 6368 696e 6553 6361 6c65  le: MachineScale
-00008730: 203d 204d 6163 6869 6e65 5363 616c 652e   = MachineScale.
-00008740: 4945 4336 3132 3137 2c0d 0a20 2020 2020  IEC61217,..     
-00008750: 2020 206c 6f77 5f64 656e 7369 7479 5f62     low_density_b
-00008760: 623a 2062 6f6f 6c20 3d20 4661 6c73 652c  b: bool = False,
-00008770: 0d0a 2020 2020 2020 2020 6f70 656e 5f66  ..        open_f
-00008780: 6965 6c64 3a20 626f 6f6c 203d 2046 616c  ield: bool = Fal
-00008790: 7365 2c0d 0a20 2020 2029 202d 3e20 4e6f  se,..    ) -> No
-000087a0: 6e65 3a0d 0a20 2020 2020 2020 2022 2222  ne:..        """
-000087b0: 416e 616c 797a 6520 7468 6520 574c 2069  Analyze the WL i
-000087c0: 6d61 6765 732e 0d0a 0d0a 2020 2020 2020  mages.....      
-000087d0: 2020 5061 7261 6d65 7465 7273 0d0a 2020    Parameters..  
-000087e0: 2020 2020 2020 2d2d 2d2d 2d2d 2d2d 2d2d        ----------
-000087f0: 0d0a 2020 2020 2020 2020 6262 5f73 697a  ..        bb_siz
-00008800: 655f 6d6d 0d0a 2020 2020 2020 2020 2020  e_mm..          
-00008810: 2020 5468 6520 6578 7065 6374 6564 2064    The expected d
-00008820: 6961 6d65 7465 7220 6f66 2074 6865 2042  iameter of the B
-00008830: 4220 696e 206d 6d2e 2054 6865 2061 6374  B in mm. The act
-00008840: 7561 6c20 7369 7a65 206f 6620 7468 6520  ual size of the 
-00008850: 4242 2063 616e 2062 6520 2b2f 2d32 6d6d  BB can be +/-2mm
-00008860: 2066 726f 6d20 7468 6520 7061 7373 6564   from the passed
-00008870: 2076 616c 7565 2e0d 0a20 2020 2020 2020   value...       
-00008880: 206d 6163 6869 6e65 5f73 6361 6c65 0d0a   machine_scale..
-00008890: 2020 2020 2020 2020 2020 2020 5468 6520              The 
-000088a0: 7363 616c 6520 6f66 2074 6865 206d 6163  scale of the mac
-000088b0: 6869 6e65 2e20 5368 6966 7420 7665 6374  hine. Shift vect
-000088c0: 6f72 7320 6465 7065 6e64 206f 6e20 7468  ors depend on th
-000088d0: 6973 2076 616c 7565 2e0d 0a20 2020 2020  is value...     
-000088e0: 2020 206c 6f77 5f64 656e 7369 7479 5f62     low_density_b
-000088f0: 620d 0a20 2020 2020 2020 2020 2020 2053  b..            S
-00008900: 6574 2074 6869 7320 666c 6167 2074 6f20  et this flag to 
-00008910: 5472 7565 2069 6620 7468 6520 4242 2069  True if the BB i
-00008920: 7320 6c6f 7765 7220 6465 6e73 6974 7920  s lower density 
-00008930: 7468 616e 2074 6865 206d 6174 6572 6961  than the materia
-00008940: 6c20 7375 7272 6f75 6e64 696e 6720 6974  l surrounding it
-00008950: 2e0d 0a20 2020 2020 2020 206f 7065 6e5f  ...        open_
-00008960: 6669 656c 640d 0a20 2020 2020 2020 2020  field..         
-00008970: 2020 2049 6620 5472 7565 2c20 7365 7473     If True, sets
-00008980: 2074 6865 2066 6965 6c64 2063 656e 7465   the field cente
-00008990: 7220 746f 2074 6865 2045 5049 4420 6365  r to the EPID ce
-000089a0: 6e74 6572 2075 6e64 6572 2074 6865 2061  nter under the a
-000089b0: 7373 756d 7074 696f 6e20 7468 6520 6669  ssumption the fi
-000089c0: 656c 6420 6973 206e 6f74 2074 6865 2066  eld is not the f
-000089d0: 6f63 7573 206f 6620 696e 7465 7265 7374  ocus of interest
-000089e0: 206f 7220 6973 2074 6f6f 2077 6964 6520   or is too wide 
-000089f0: 746f 2062 6520 6361 6c63 756c 6174 6564  to be calculated
-00008a00: 2e0d 0a20 2020 2020 2020 2020 2020 2054  ...            T
-00008a10: 6869 7320 6973 206f 6674 656e 2068 656c  his is often hel
-00008a20: 7066 756c 2066 6f72 206b 5620 574c 2061  pful for kV WL a
-00008a30: 6e61 6c79 7369 7320 7768 6572 6520 7468  nalysis where th
-00008a40: 6520 626c 6164 6573 2061 7265 2077 6964  e blades are wid
-00008a50: 6520 6f70 656e 2061 6e64 2065 7665 6e20  e open and even 
-00008a60: 7468 656e 2074 6865 2062 6c61 6465 2065  then the blade e
-00008a70: 6467 6520 6973 206f 660d 0a20 2020 2020  dge is of..     
-00008a80: 2020 2020 2020 206c 6573 7320 696e 7465         less inte
-00008a90: 7265 7374 2074 6861 6e20 7369 6d70 6c79  rest than simply
-00008aa0: 2074 6865 2069 6d61 6769 6e67 2069 736f   the imaging iso
-00008ab0: 2076 7320 7468 6520 4242 2e0d 0a20 2020   vs the BB...   
-00008ac0: 2020 2020 2022 2222 0d0a 2020 2020 2020       """..      
-00008ad0: 2020 7365 6c66 2e6d 6163 6869 6e65 5f73    self.machine_s
-00008ae0: 6361 6c65 203d 206d 6163 6869 6e65 5f73  cale = machine_s
-00008af0: 6361 6c65 0d0a 2020 2020 2020 2020 6966  cale..        if
-00008b00: 2073 656c 662e 6973 5f66 726f 6d5f 6362   self.is_from_cb
-00008b10: 6374 3a0d 0a20 2020 2020 2020 2020 2020  ct:..           
-00008b20: 206c 6f77 5f64 656e 7369 7479 5f62 6220   low_density_bb 
-00008b30: 3d20 5472 7565 0d0a 2020 2020 2020 2020  = True..        
-00008b40: 2020 2020 6f70 656e 5f66 6965 6c64 203d      open_field =
-00008b50: 2054 7275 650d 0a20 2020 2020 2020 2066   True..        f
-00008b60: 6f72 2069 6d67 2069 6e20 7365 6c66 2e69  or img in self.i
-00008b70: 6d61 6765 733a 0d0a 2020 2020 2020 2020  mages:..        
-00008b80: 2020 2020 696d 672e 616e 616c 797a 6528      img.analyze(
-00008b90: 6262 5f73 697a 655f 6d6d 2c20 6c6f 775f  bb_size_mm, low_
-00008ba0: 6465 6e73 6974 795f 6262 2c20 6f70 656e  density_bb, open
-00008bb0: 5f66 6965 6c64 290d 0a20 2020 2020 2020  _field)..       
-00008bc0: 2073 656c 662e 5f69 735f 616e 616c 797a   self._is_analyz
-00008bd0: 6564 203d 2054 7275 650d 0a20 2020 2020  ed = True..     
-00008be0: 2020 2073 656c 662e 5f62 625f 6469 616d     self._bb_diam
-00008bf0: 6574 6572 203d 2062 625f 7369 7a65 5f6d  eter = bb_size_m
-00008c00: 6d0d 0a0d 0a20 2020 2040 6c72 755f 6361  m....    @lru_ca
-00008c10: 6368 6528 290d 0a20 2020 2064 6566 205f  che()..    def _
-00008c20: 6d69 6e69 6d69 7a65 5f61 7869 7328 7365  minimize_axis(se
-00008c30: 6c66 2c20 6178 6573 3a20 4178 6973 207c  lf, axes: Axis |
-00008c40: 2074 7570 6c65 5b41 7869 732c 202e 2e2e   tuple[Axis, ...
-00008c50: 5d20 3d20 2841 7869 732e 4741 4e54 5259  ] = (Axis.GANTRY
-00008c60: 2c29 293a 0d0a 2020 2020 2020 2020 2222  ,)):..        ""
-00008c70: 2252 6574 7572 6e20 7468 6520 6d69 6e69  "Return the mini
-00008c80: 6d69 7a61 7469 6f6e 2072 6573 756c 7420  mization result 
-00008c90: 6f66 2074 6865 2067 6976 656e 2061 7869  of the given axi
-00008ca0: 732e 2222 220d 0a20 2020 2020 2020 2069  s."""..        i
-00008cb0: 6620 6973 696e 7374 616e 6365 2861 7865  f isinstance(axe
-00008cc0: 732c 2041 7869 7329 3a0d 0a20 2020 2020  s, Axis):..     
-00008cd0: 2020 2020 2020 2061 7865 7320 3d20 2861         axes = (a
-00008ce0: 7865 732c 290d 0a0d 0a20 2020 2020 2020  xes,)....       
-00008cf0: 2074 6869 6e67 7320 3d20 5b0d 0a20 2020   things = [..   
-00008d00: 2020 2020 2020 2020 2069 6d61 6765 2e63           image.c
-00008d10: 6178 5f6c 696e 655f 7072 6f6a 6563 7469  ax_line_projecti
-00008d20: 6f6e 0d0a 2020 2020 2020 2020 2020 2020  on..            
-00008d30: 666f 7220 696d 6167 6520 696e 2073 656c  for image in sel
-00008d40: 662e 696d 6167 6573 0d0a 2020 2020 2020  f.images..      
-00008d50: 2020 2020 2020 6966 2069 6d61 6765 2e76        if image.v
-00008d60: 6172 6961 626c 655f 6178 6973 2069 6e20  ariable_axis in 
-00008d70: 2861 7865 7320 2b20 2841 7869 732e 5245  (axes + (Axis.RE
-00008d80: 4645 5245 4e43 452c 2929 0d0a 2020 2020  FERENCE,))..    
-00008d90: 2020 2020 5d0d 0a20 2020 2020 2020 2069      ]..        i
-00008da0: 6620 6c65 6e28 7468 696e 6773 2920 3c3d  f len(things) <=
-00008db0: 2031 3a0d 0a20 2020 2020 2020 2020 2020   1:..           
-00008dc0: 2072 6169 7365 2056 616c 7565 4572 726f   raise ValueErro
-00008dd0: 7228 0d0a 2020 2020 2020 2020 2020 2020  r(..            
-00008de0: 2020 2020 224e 6f74 2065 6e6f 7567 6820      "Not enough 
-00008df0: 696d 6167 6573 206f 6620 7468 6520 6769  images of the gi
-00008e00: 7665 6e20 7479 7065 2074 6f20 6964 656e  ven type to iden
-00008e10: 7469 6679 2074 6865 2061 7869 7320 6973  tify the axis is
-00008e20: 6f63 656e 7465 7222 0d0a 2020 2020 2020  ocenter"..      
-00008e30: 2020 2020 2020 290d 0a20 2020 2020 2020        )..       
-00008e40: 2069 6e69 7469 616c 5f67 7565 7373 203d   initial_guess =
-00008e50: 206e 702e 6172 7261 7928 5b30 2c20 302c   np.array([0, 0,
-00008e60: 2030 5d29 0d0a 2020 2020 2020 2020 626f   0])..        bo
-00008e70: 756e 6473 203d 205b 282d 3230 2c20 3230  unds = [(-20, 20
-00008e80: 292c 2028 2d32 302c 2032 3029 2c20 282d  ), (-20, 20), (-
-00008e90: 3230 2c20 3230 295d 0d0a 2020 2020 2020  20, 20)]..      
-00008ea0: 2020 7265 7375 6c74 203d 206f 7074 696d    result = optim
-00008eb0: 697a 652e 6d69 6e69 6d69 7a65 280d 0a20  ize.minimize(.. 
-00008ec0: 2020 2020 2020 2020 2020 206d 6178 5f64             max_d
-00008ed0: 6973 7461 6e63 655f 746f 5f6c 696e 6573  istance_to_lines
-00008ee0: 2c20 696e 6974 6961 6c5f 6775 6573 732c  , initial_guess,
-00008ef0: 2061 7267 733d 7468 696e 6773 2c20 626f   args=things, bo
-00008f00: 756e 6473 3d62 6f75 6e64 730d 0a20 2020  unds=bounds..   
-00008f10: 2020 2020 2029 0d0a 2020 2020 2020 2020       )..        
-00008f20: 7265 7475 726e 2072 6573 756c 740d 0a0d  return result...
-00008f30: 0a20 2020 2040 7072 6f70 6572 7479 0d0a  .    @property..
-00008f40: 2020 2020 6465 6620 6761 6e74 7279 5f69      def gantry_i
-00008f50: 736f 5f73 697a 6528 7365 6c66 2920 2d3e  so_size(self) ->
-00008f60: 2066 6c6f 6174 3a0d 0a20 2020 2020 2020   float:..       
-00008f70: 2022 2222 5468 6520 6469 616d 6574 6572   """The diameter
-00008f80: 206f 6620 7468 6520 3344 2067 616e 7472   of the 3D gantr
-00008f90: 7920 6973 6f63 656e 7465 7220 7369 7a65  y isocenter size
-00008fa0: 2069 6e20 6d6d 2e20 4f6e 6c79 2069 6d61   in mm. Only ima
-00008fb0: 6765 7320 7768 6572 6520 7468 6520 636f  ges where the co
-00008fc0: 6c6c 696d 6174 6f72 0d0a 2020 2020 2020  llimator..      
-00008fd0: 2020 616e 6420 636f 7563 6820 7765 7265    and couch were
-00008fe0: 2061 7420 3020 6172 6520 7573 6564 2074   at 0 are used t
-00008ff0: 6f20 6465 7465 726d 696e 6520 7468 6973  o determine this
-00009000: 2076 616c 7565 2e22 2222 0d0a 2020 2020   value."""..    
-00009010: 2020 2020 6e75 6d5f 6761 6e74 7279 5f6c      num_gantry_l
-00009020: 696b 655f 696d 6167 6573 203d 2073 656c  ike_images = sel
-00009030: 662e 5f67 6574 5f69 6d61 6765 7328 2841  f._get_images((A
-00009040: 7869 732e 4741 4e54 5259 2c20 4178 6973  xis.GANTRY, Axis
-00009050: 2e52 4546 4552 454e 4345 2929 5b30 5d0d  .REFERENCE))[0].
-00009060: 0a20 2020 2020 2020 2069 6620 6e75 6d5f  .        if num_
-00009070: 6761 6e74 7279 5f6c 696b 655f 696d 6167  gantry_like_imag
-00009080: 6573 203e 2031 3a0d 0a20 2020 2020 2020  es > 1:..       
-00009090: 2020 2020 2072 6574 7572 6e20 7365 6c66       return self
-000090a0: 2e5f 6d69 6e69 6d69 7a65 5f61 7869 7328  ._minimize_axis(
-000090b0: 4178 6973 2e47 414e 5452 5929 2e66 756e  Axis.GANTRY).fun
-000090c0: 202a 2032 0d0a 2020 2020 2020 2020 656c   * 2..        el
-000090d0: 7365 3a0d 0a20 2020 2020 2020 2020 2020  se:..           
-000090e0: 2072 6574 7572 6e20 300d 0a0d 0a20 2020   return 0....   
-000090f0: 2040 7072 6f70 6572 7479 0d0a 2020 2020   @property..    
-00009100: 6465 6620 6761 6e74 7279 5f63 6f6c 6c5f  def gantry_coll_
-00009110: 6973 6f5f 7369 7a65 2873 656c 6629 202d  iso_size(self) -
-00009120: 3e20 666c 6f61 743a 0d0a 2020 2020 2020  > float:..      
-00009130: 2020 2222 2254 6865 2064 6961 6d65 7465    """The diamete
-00009140: 7220 6f66 2074 6865 2033 4420 6761 6e74  r of the 3D gant
-00009150: 7279 2069 736f 6365 6e74 6572 2073 697a  ry isocenter siz
-00009160: 6520 696e 206d 6d20 2a69 6e63 6c75 6469  e in mm *includi
-00009170: 6e67 2063 6f6c 6c69 6d61 746f 7220 616e  ng collimator an
-00009180: 6420 6761 6e74 7279 2f63 6f6c 6c20 636f  d gantry/coll co
-00009190: 6d62 6f20 696d 6167 6573 2a2e 0d0a 2020  mbo images*...  
-000091a0: 2020 2020 2020 496d 6167 6573 2077 6865        Images whe
-000091b0: 7265 2074 6865 2063 6f75 6368 213d 3020  re the couch!=0 
-000091c0: 6172 6520 6578 636c 7564 6564 2e22 2222  are excluded."""
-000091d0: 0d0a 2020 2020 2020 2020 6e75 6d5f 6761  ..        num_ga
-000091e0: 6e74 7279 5f6c 696b 655f 696d 6167 6573  ntry_like_images
-000091f0: 203d 2073 656c 662e 5f67 6574 5f69 6d61   = self._get_ima
-00009200: 6765 7328 0d0a 2020 2020 2020 2020 2020  ges(..          
-00009210: 2020 2841 7869 732e 4741 4e54 5259 2c20    (Axis.GANTRY, 
-00009220: 4178 6973 2e43 4f4c 4c49 4d41 544f 522c  Axis.COLLIMATOR,
-00009230: 2041 7869 732e 4742 5f43 4f4d 424f 2c20   Axis.GB_COMBO, 
-00009240: 4178 6973 2e52 4546 4552 454e 4345 290d  Axis.REFERENCE).
-00009250: 0a20 2020 2020 2020 2029 5b30 5d0d 0a20  .        )[0].. 
-00009260: 2020 2020 2020 2069 6620 6e75 6d5f 6761         if num_ga
-00009270: 6e74 7279 5f6c 696b 655f 696d 6167 6573  ntry_like_images
-00009280: 203e 2031 3a0d 0a20 2020 2020 2020 2020   > 1:..         
-00009290: 2020 2072 6574 7572 6e20 280d 0a20 2020     return (..   
-000092a0: 2020 2020 2020 2020 2020 2020 2073 656c               sel
-000092b0: 662e 5f6d 696e 696d 697a 655f 6178 6973  f._minimize_axis
-000092c0: 2828 4178 6973 2e47 414e 5452 592c 2041  ((Axis.GANTRY, A
-000092d0: 7869 732e 434f 4c4c 494d 4154 4f52 2c20  xis.COLLIMATOR, 
-000092e0: 4178 6973 2e47 425f 434f 4d42 4f29 292e  Axis.GB_COMBO)).
-000092f0: 6675 6e0d 0a20 2020 2020 2020 2020 2020  fun..           
-00009300: 2020 2020 202a 2032 0d0a 2020 2020 2020       * 2..      
-00009310: 2020 2020 2020 290d 0a20 2020 2020 2020        )..       
-00009320: 2065 6c73 653a 0d0a 2020 2020 2020 2020   else:..        
-00009330: 2020 2020 7265 7475 726e 2030 0d0a 0d0a      return 0....
-00009340: 2020 2020 4073 7461 7469 636d 6574 686f      @staticmetho
-00009350: 640d 0a20 2020 2064 6566 205f 6669 6e64  d..    def _find
-00009360: 5f6d 6178 5f64 6973 7461 6e63 655f 6265  _max_distance_be
-00009370: 7477 6565 6e5f 706f 696e 7473 2869 6d61  tween_points(ima
-00009380: 6765 7329 202d 3e20 666c 6f61 743a 0d0a  ges) -> float:..
-00009390: 2020 2020 2020 2020 2222 2246 696e 6420          """Find 
-000093a0: 7468 6520 6d61 7869 6d75 6d20 6469 7374  the maximum dist
-000093b0: 616e 6365 2062 6574 7765 656e 2061 2073  ance between a s
-000093c0: 6574 206f 6620 706f 696e 7473 2e20 5573  et of points. Us
-000093d0: 6564 2066 6f72 2032 4420 696d 6167 6573  ed for 2D images
-000093e0: 206c 696b 6520 636f 6c6c 696d 6174 6f72   like collimator
-000093f0: 2061 6e64 2063 6f75 6368 2e22 2222 0d0a   and couch."""..
-00009400: 2020 2020 2020 2020 706f 696e 7473 203d          points =
-00009410: 205b 0d0a 2020 2020 2020 2020 2020 2020   [..            
-00009420: 506f 696e 7428 696d 6167 652e 6361 7832  Point(image.cax2
-00009430: 6262 5f76 6563 746f 722e 782c 2069 6d61  bb_vector.x, ima
-00009440: 6765 2e63 6178 3262 625f 7665 6374 6f72  ge.cax2bb_vector
-00009450: 2e79 2920 666f 7220 696d 6167 6520 696e  .y) for image in
-00009460: 2069 6d61 6765 730d 0a20 2020 2020 2020   images..       
-00009470: 205d 0d0a 2020 2020 2020 2020 6469 7374   ]..        dist
-00009480: 7320 3d20 5b5d 0d0a 2020 2020 2020 2020  s = []..        
-00009490: 666f 7220 706f 696e 7431 2069 6e20 706f  for point1 in po
-000094a0: 696e 7473 3a0d 0a20 2020 2020 2020 2020  ints:..         
-000094b0: 2020 2066 6f72 2070 6f69 6e74 3220 696e     for point2 in
-000094c0: 2070 6f69 6e74 733a 0d0a 2020 2020 2020   points:..      
-000094d0: 2020 2020 2020 2020 2020 7020 3d20 706f            p = po
-000094e0: 696e 7431 2e64 6973 7461 6e63 655f 746f  int1.distance_to
-000094f0: 2870 6f69 6e74 3229 0d0a 2020 2020 2020  (point2)..      
-00009500: 2020 2020 2020 2020 2020 6469 7374 732e            dists.
-00009510: 6170 7065 6e64 2870 290d 0a20 2020 2020  append(p)..     
-00009520: 2020 2072 6574 7572 6e20 6d61 7828 6469     return max(di
-00009530: 7374 7329 0d0a 0d0a 2020 2020 4070 726f  sts)....    @pro
-00009540: 7065 7274 790d 0a20 2020 2064 6566 2063  perty..    def c
-00009550: 6f6c 6c69 6d61 746f 725f 6973 6f5f 7369  ollimator_iso_si
-00009560: 7a65 2873 656c 6629 202d 3e20 666c 6f61  ze(self) -> floa
-00009570: 743a 0d0a 2020 2020 2020 2020 2222 2254  t:..        """T
-00009580: 6865 2032 4420 636f 6c6c 696d 6174 6f72  he 2D collimator
-00009590: 2069 736f 6365 6e74 6572 2073 697a 6520   isocenter size 
-000095a0: 2864 6961 6d65 7465 7229 2069 6e20 6d6d  (diameter) in mm
-000095b0: 2e20 5468 6520 6973 6f20 7369 7a65 2069  . The iso size i
-000095c0: 7320 696e 2074 6865 2070 6c61 6e65 0d0a  s in the plane..
-000095d0: 2020 2020 2020 2020 6e6f 726d 616c 2074          normal t
-000095e0: 6f20 7468 6520 6761 6e74 7279 2e22 2222  o the gantry."""
-000095f0: 0d0a 2020 2020 2020 2020 6e75 6d5f 636f  ..        num_co
-00009600: 6c6c 696d 6174 6f72 5f6c 696b 655f 696d  llimator_like_im
-00009610: 6167 6573 2c20 696d 6167 6573 203d 2073  ages, images = s
-00009620: 656c 662e 5f67 6574 5f69 6d61 6765 7328  elf._get_images(
-00009630: 0d0a 2020 2020 2020 2020 2020 2020 2841  ..            (A
-00009640: 7869 732e 434f 4c4c 494d 4154 4f52 2c20  xis.COLLIMATOR, 
-00009650: 4178 6973 2e52 4546 4552 454e 4345 290d  Axis.REFERENCE).
-00009660: 0a20 2020 2020 2020 2029 0d0a 2020 2020  .        )..    
-00009670: 2020 2020 6966 206e 756d 5f63 6f6c 6c69      if num_colli
-00009680: 6d61 746f 725f 6c69 6b65 5f69 6d61 6765  mator_like_image
-00009690: 7320 3e20 313a 0d0a 2020 2020 2020 2020  s > 1:..        
-000096a0: 2020 2020 7265 7475 726e 2073 656c 662e      return self.
-000096b0: 5f66 696e 645f 6d61 785f 6469 7374 616e  _find_max_distan
-000096c0: 6365 5f62 6574 7765 656e 5f70 6f69 6e74  ce_between_point
-000096d0: 7328 696d 6167 6573 290d 0a20 2020 2020  s(images)..     
-000096e0: 2020 2065 6c73 653a 0d0a 2020 2020 2020     else:..      
-000096f0: 2020 2020 2020 7265 7475 726e 2030 0d0a        return 0..
-00009700: 0d0a 2020 2020 4070 726f 7065 7274 790d  ..    @property.
-00009710: 0a20 2020 2064 6566 2063 6f75 6368 5f69  .    def couch_i
-00009720: 736f 5f73 697a 6528 7365 6c66 2920 2d3e  so_size(self) ->
-00009730: 2066 6c6f 6174 3a0d 0a20 2020 2020 2020   float:..       
-00009740: 2022 2222 5468 6520 6469 616d 6574 6572   """The diameter
-00009750: 206f 6620 7468 6520 3244 2063 6f75 6368   of the 2D couch
-00009760: 2069 736f 6365 6e74 6572 2073 697a 6520   isocenter size 
-00009770: 696e 206d 6d2e 204f 6e6c 7920 696d 6167  in mm. Only imag
-00009780: 6573 2077 6865 7265 0d0a 2020 2020 2020  es where..      
-00009790: 2020 7468 6520 6761 6e74 7279 2061 6e64    the gantry and
-000097a0: 2063 6f6c 6c69 6d61 746f 7220 7765 7265   collimator were
-000097b0: 2061 7420 7a65 726f 2061 7265 2075 7365   at zero are use
-000097c0: 6420 746f 2064 6574 6572 6d69 6e65 2074  d to determine t
-000097d0: 6869 7320 7661 6c75 652e 2222 220d 0a20  his value.""".. 
-000097e0: 2020 2020 2020 206e 756d 5f63 6f75 6368         num_couch
-000097f0: 5f6c 696b 655f 696d 6167 6573 2c20 696d  _like_images, im
-00009800: 6167 6573 203d 2073 656c 662e 5f67 6574  ages = self._get
-00009810: 5f69 6d61 6765 7328 2841 7869 732e 434f  _images((Axis.CO
-00009820: 5543 482c 2041 7869 732e 5245 4645 5245  UCH, Axis.REFERE
-00009830: 4e43 4529 290d 0a20 2020 2020 2020 2069  NCE))..        i
-00009840: 6620 6e75 6d5f 636f 7563 685f 6c69 6b65  f num_couch_like
-00009850: 5f69 6d61 6765 7320 3e20 313a 0d0a 2020  _images > 1:..  
-00009860: 2020 2020 2020 2020 2020 7265 7475 726e            return
-00009870: 2073 656c 662e 5f66 696e 645f 6d61 785f   self._find_max_
-00009880: 6469 7374 616e 6365 5f62 6574 7765 656e  distance_between
-00009890: 5f70 6f69 6e74 7328 696d 6167 6573 290d  _points(images).
-000098a0: 0a20 2020 2020 2020 2065 6c73 653a 0d0a  .        else:..
-000098b0: 2020 2020 2020 2020 2020 2020 7265 7475              retu
-000098c0: 726e 2030 0d0a 0d0a 2020 2020 4070 726f  rn 0....    @pro
-000098d0: 7065 7274 790d 0a20 2020 2064 6566 2062  perty..    def b
-000098e0: 625f 7368 6966 745f 7665 6374 6f72 2873  b_shift_vector(s
-000098f0: 656c 6629 202d 3e20 5665 6374 6f72 3a0d  elf) -> Vector:.
-00009900: 0a20 2020 2020 2020 2022 2222 5468 6520  .        """The 
-00009910: 7368 6966 7420 6e65 6365 7373 6172 7920  shift necessary 
-00009920: 746f 2070 6c61 6365 2074 6865 2042 4220  to place the BB 
-00009930: 6174 2074 6865 2072 6164 6961 7469 6f6e  at the radiation
-00009940: 2069 736f 6365 6e74 6572 2e0d 0a20 2020   isocenter...   
-00009950: 2020 2020 2054 6865 2076 616c 7565 7320       The values 
-00009960: 6172 6520 696e 2074 6865 2063 6f6f 7264  are in the coord
-00009970: 696e 6174 6573 2064 6566 696e 6564 2069  inates defined i
-00009980: 6e20 7468 6520 646f 6375 6d65 6e74 6174  n the documentat
-00009990: 696f 6e2e 0d0a 0d0a 2020 2020 2020 2020  ion.....        
-000099a0: 5468 6520 7368 6966 7420 6973 2062 6173  The shift is bas
-000099b0: 6564 206f 6e20 7468 6520 7061 7065 7220  ed on the paper 
-000099c0: 6279 204c 6f77 2065 7420 616c 2e20 5365  by Low et al. Se
-000099d0: 6520 6f6e 6c69 6e65 2064 6f63 756d 656e  e online documen
-000099e0: 7461 7469 6f6e 2066 6f72 206d 6f72 652e  tation for more.
-000099f0: 0d0a 2020 2020 2020 2020 2222 220d 0a20  ..        """.. 
-00009a00: 2020 2020 2020 2041 203d 206e 702e 656d         A = np.em
-00009a10: 7074 7928 5b32 202a 206c 656e 2873 656c  pty([2 * len(sel
-00009a20: 662e 696d 6167 6573 292c 2033 5d29 0d0a  f.images), 3])..
-00009a30: 2020 2020 2020 2020 6570 7369 6c6f 6e20          epsilon 
-00009a40: 3d20 6e70 2e65 6d70 7479 285b 3220 2a20  = np.empty([2 * 
-00009a50: 6c65 6e28 7365 6c66 2e69 6d61 6765 7329  len(self.images)
-00009a60: 2c20 315d 290d 0a20 2020 2020 2020 2066  , 1])..        f
-00009a70: 6f72 2069 6478 2c20 696d 6720 696e 2065  or idx, img in e
-00009a80: 6e75 6d65 7261 7465 2873 656c 662e 696d  numerate(self.im
-00009a90: 6167 6573 293a 0d0a 2020 2020 2020 2020  ages):..        
-00009aa0: 2020 2020 2320 636f 6e76 6572 7420 6672      # convert fr
-00009ab0: 6f6d 2069 6e70 7574 2073 6361 6c65 2074  om input scale t
-00009ac0: 6f20 5661 7269 616e 2073 6361 6c65 0d0a  o Varian scale..
-00009ad0: 2020 2020 2020 2020 2020 2020 2320 4c6f              # Lo
-00009ae0: 7727 7320 7061 7065 7220 6173 7375 6d65  w's paper assume
-00009af0: 7320 5661 7269 616e 2073 6361 6c65 2069  s Varian scale i
-00009b00: 6e70 7574 2061 6e64 2074 6869 7320 6973  nput and this is
-00009b10: 2065 6173 6965 7220 7468 616e 2063 6861   easier than cha
-00009b20: 6e67 696e 6720 7468 6520 6163 7475 616c  nging the actual
-00009b30: 2073 6967 6e73 2069 6e20 7468 6520 6571   signs in the eq
-00009b40: 7561 7469 6f6e 2077 6869 6368 2068 6176  uation which hav
-00009b50: 6520 6120 6e6f 6e2d 696e 7475 6974 6976  e a non-intuitiv
-00009b60: 6520 7265 6c61 7469 6f6e 7368 6970 0d0a  e relationship..
-00009b70: 2020 2020 2020 2020 2020 2020 6761 6e74              gant
-00009b80: 7279 2c20 5f2c 2063 6f75 6368 203d 2063  ry, _, couch = c
-00009b90: 6f6e 7665 7274 280d 0a20 2020 2020 2020  onvert(..       
-00009ba0: 2020 2020 2020 2020 2069 6e70 7574 5f73           input_s
-00009bb0: 6361 6c65 3d73 656c 662e 6d61 6368 696e  cale=self.machin
-00009bc0: 655f 7363 616c 652c 0d0a 2020 2020 2020  e_scale,..      
-00009bd0: 2020 2020 2020 2020 2020 6f75 7470 7574            output
-00009be0: 5f73 6361 6c65 3d4d 6163 6869 6e65 5363  _scale=MachineSc
-00009bf0: 616c 652e 5641 5249 414e 5f53 5441 4e44  ale.VARIAN_STAND
-00009c00: 4152 442c 0d0a 2020 2020 2020 2020 2020  ARD,..          
-00009c10: 2020 2020 2020 6761 6e74 7279 3d69 6d67        gantry=img
-00009c20: 2e67 616e 7472 795f 616e 676c 652c 0d0a  .gantry_angle,..
-00009c30: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009c40: 636f 6c6c 696d 6174 6f72 3d69 6d67 2e63  collimator=img.c
-00009c50: 6f6c 6c69 6d61 746f 725f 616e 676c 652c  ollimator_angle,
-00009c60: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-00009c70: 2020 726f 7461 7469 6f6e 3d69 6d67 2e63    rotation=img.c
-00009c80: 6f75 6368 5f61 6e67 6c65 2c0d 0a20 2020  ouch_angle,..   
-00009c90: 2020 2020 2020 2020 2029 0d0a 2020 2020           )..    
-00009ca0: 2020 2020 2020 2020 415b 3220 2a20 6964          A[2 * id
-00009cb0: 7820 3a20 3220 2a20 6964 7820 2b20 322c  x : 2 * idx + 2,
-00009cc0: 203a 5d20 3d20 6e70 2e61 7272 6179 280d   :] = np.array(.
-00009cd0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00009ce0: 205b 0d0a 2020 2020 2020 2020 2020 2020   [..            
-00009cf0: 2020 2020 2020 2020 5b2d 636f 7328 636f          [-cos(co
-00009d00: 7563 6829 2c20 2d73 696e 2863 6f75 6368  uch), -sin(couch
-00009d10: 292c 2030 5d2c 0d0a 2020 2020 2020 2020  ), 0],..        
-00009d20: 2020 2020 2020 2020 2020 2020 5b2d 636f              [-co
-00009d30: 7328 6761 6e74 7279 2920 2a20 7369 6e28  s(gantry) * sin(
-00009d40: 636f 7563 6829 2c20 636f 7328 6761 6e74  couch), cos(gant
-00009d50: 7279 2920 2a20 636f 7328 636f 7563 6829  ry) * cos(couch)
-00009d60: 2c20 2d73 696e 2867 616e 7472 7929 5d2c  , -sin(gantry)],
-00009d70: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-00009d80: 2020 5d0d 0a20 2020 2020 2020 2020 2020    ]..           
-00009d90: 2029 2020 2320 6571 7561 7469 6f6e 2036   )  # equation 6
-00009da0: 2028 6d69 6e75 7320 6465 6c74 6129 0d0a   (minus delta)..
-00009db0: 2020 2020 2020 2020 2020 2020 6570 7369              epsi
-00009dc0: 6c6f 6e5b 3220 2a20 6964 7820 3a20 3220  lon[2 * idx : 2 
-00009dd0: 2a20 6964 7820 2b20 325d 203d 206e 702e  * idx + 2] = np.
-00009de0: 6172 7261 7928 0d0a 2020 2020 2020 2020  array(..        
-00009df0: 2020 2020 2020 2020 5b5b 696d 672e 6361          [[img.ca
-00009e00: 7832 6262 5f76 6563 746f 722e 795d 2c20  x2bb_vector.y], 
-00009e10: 5b69 6d67 2e63 6178 3262 625f 7665 6374  [img.cax2bb_vect
-00009e20: 6f72 2e78 5d5d 0d0a 2020 2020 2020 2020  or.x]]..        
-00009e30: 2020 2020 2920 2023 2065 7175 6174 696f      )  # equatio
-00009e40: 6e20 370d 0a0d 0a20 2020 2020 2020 2042  n 7....        B
-00009e50: 203d 206c 696e 616c 672e 7069 6e76 2841   = linalg.pinv(A
-00009e60: 290d 0a20 2020 2020 2020 2064 656c 7461  )..        delta
-00009e70: 203d 2042 2e64 6f74 2865 7073 696c 6f6e   = B.dot(epsilon
-00009e80: 2920 2023 2065 7175 6174 696f 6e20 390d  )  # equation 9.
-00009e90: 0a20 2020 2020 2020 2023 2077 6520 7573  .        # we us
-00009ea0: 6520 7468 6520 6e65 6761 7469 7665 2066  e the negative f
-00009eb0: 6f72 2061 6c6c 2076 616c 7565 7320 6265  or all values be
-00009ec0: 6361 7573 6520 6974 2773 2066 726f 6d20  cause it's from 
-00009ed0: 7468 6520 6973 6f20 504f 5620 2d3e 206c  the iso POV -> l
-00009ee0: 696e 6163 206e 6f74 2074 6865 206c 696e  inac not the lin
-00009ef0: 6163 202d 3e20 6973 6f20 504f 560d 0a20  ac -> iso POV.. 
-00009f00: 2020 2020 2020 2072 6574 7572 6e20 5665         return Ve
-00009f10: 6374 6f72 2878 3d2d 6465 6c74 615b 315d  ctor(x=-delta[1]
-00009f20: 5b30 5d2c 2079 3d2d 6465 6c74 615b 305d  [0], y=-delta[0]
-00009f30: 5b30 5d2c 207a 3d2d 6465 6c74 615b 325d  [0], z=-delta[2]
-00009f40: 5b30 5d29 0d0a 0d0a 2020 2020 6465 6620  [0])....    def 
-00009f50: 6262 5f73 6869 6674 5f69 6e73 7472 7563  bb_shift_instruc
-00009f60: 7469 6f6e 7328 0d0a 2020 2020 2020 2020  tions(..        
-00009f70: 7365 6c66 2c0d 0a20 2020 2020 2020 2063  self,..        c
-00009f80: 6f75 6368 5f76 7274 3a20 666c 6f61 7420  ouch_vrt: float 
-00009f90: 7c20 4e6f 6e65 203d 204e 6f6e 652c 0d0a  | None = None,..
-00009fa0: 2020 2020 2020 2020 636f 7563 685f 6c6e          couch_ln
-00009fb0: 673a 2066 6c6f 6174 207c 204e 6f6e 6520  g: float | None 
-00009fc0: 3d20 4e6f 6e65 2c0d 0a20 2020 2020 2020  = None,..       
-00009fd0: 2063 6f75 6368 5f6c 6174 3a20 666c 6f61   couch_lat: floa
-00009fe0: 7420 7c20 4e6f 6e65 203d 204e 6f6e 652c  t | None = None,
-00009ff0: 0d0a 2020 2020 2920 2d3e 2073 7472 3a0d  ..    ) -> str:.
-0000a000: 0a20 2020 2020 2020 2022 2222 5265 7475  .        """Retu
-0000a010: 726e 7320 6120 7374 7269 6e67 2064 6573  rns a string des
-0000a020: 6372 6962 696e 6720 686f 7720 746f 2073  cribing how to s
-0000a030: 6869 6674 2074 6865 2042 4220 746f 2074  hift the BB to t
-0000a040: 6865 2072 6164 6961 7469 6f6e 2069 736f  he radiation iso
-0000a050: 6365 6e74 6572 206c 6f6f 6b69 6e67 2066  center looking f
-0000a060: 726f 6d20 7468 6520 666f 6f74 206f 6620  rom the foot of 
-0000a070: 7468 6520 636f 7563 682e 0d0a 2020 2020  the couch...    
-0000a080: 2020 2020 4f70 7469 6f6e 616c 6c79 2c20      Optionally, 
-0000a090: 7468 6520 6375 7272 656e 7420 636f 7563  the current couc
-0000a0a0: 6820 7661 6c75 6573 2063 616e 2062 6520  h values can be 
-0000a0b0: 7061 7373 6564 2069 6e20 746f 2067 6574  passed in to get
-0000a0c0: 2074 6865 206e 6577 2063 6f75 6368 2076   the new couch v
-0000a0d0: 616c 7565 732e 2049 6620 7061 7373 696e  alues. If passin
-0000a0e0: 6720 7468 6520 6375 7272 656e 740d 0a20  g the current.. 
-0000a0f0: 2020 2020 2020 2063 6f75 6368 2070 6f73         couch pos
-0000a100: 6974 696f 6e20 616c 6c20 7661 6c75 6573  ition all values
-0000a110: 206d 7573 7420 6265 2070 6173 7365 642e   must be passed.
-0000a120: 0d0a 0d0a 2020 2020 2020 2020 5061 7261  ....        Para
-0000a130: 6d65 7465 7273 0d0a 2020 2020 2020 2020  meters..        
-0000a140: 2d2d 2d2d 2d2d 2d2d 2d2d 0d0a 2020 2020  ----------..    
-0000a150: 2020 2020 636f 7563 685f 7672 7420 3a20      couch_vrt : 
-0000a160: 666c 6f61 740d 0a20 2020 2020 2020 2020  float..         
-0000a170: 2020 2054 6865 2063 7572 7265 6e74 2063     The current c
-0000a180: 6f75 6368 2076 6572 7469 6361 6c20 706f  ouch vertical po
-0000a190: 7369 7469 6f6e 2069 6e20 636d 2e0d 0a20  sition in cm... 
-0000a1a0: 2020 2020 2020 2063 6f75 6368 5f6c 6e67         couch_lng
-0000a1b0: 203a 2066 6c6f 6174 0d0a 2020 2020 2020   : float..      
-0000a1c0: 2020 2020 2020 5468 6520 6375 7272 656e        The curren
-0000a1d0: 7420 636f 7563 6820 6c6f 6e67 6974 7564  t couch longitud
-0000a1e0: 696e 616c 2070 6f73 6974 696f 6e20 696e  inal position in
-0000a1f0: 2063 6d2e 0d0a 2020 2020 2020 2020 636f   cm...        co
-0000a200: 7563 685f 6c61 7420 3a20 666c 6f61 740d  uch_lat : float.
-0000a210: 0a20 2020 2020 2020 2020 2020 2054 6865  .            The
-0000a220: 2063 7572 7265 6e74 2063 6f75 6368 206c   current couch l
-0000a230: 6174 6572 616c 2070 6f73 6974 696f 6e20  ateral position 
-0000a240: 696e 2063 6d2e 0d0a 2020 2020 2020 2020  in cm...        
-0000a250: 2222 220d 0a20 2020 2020 2020 2073 7620  """..        sv 
-0000a260: 3d20 7365 6c66 2e62 625f 7368 6966 745f  = self.bb_shift_
-0000a270: 7665 6374 6f72 0d0a 2020 2020 2020 2020  vector..        
-0000a280: 785f 6469 7220 3d20 224c 4546 5422 2069  x_dir = "LEFT" i
-0000a290: 6620 7376 2e78 203c 2030 2065 6c73 6520  f sv.x < 0 else 
-0000a2a0: 2252 4947 4854 220d 0a20 2020 2020 2020  "RIGHT"..       
-0000a2b0: 2079 5f64 6972 203d 2022 494e 2220 6966   y_dir = "IN" if
-0000a2c0: 2073 762e 7920 3e20 3020 656c 7365 2022   sv.y > 0 else "
-0000a2d0: 4f55 5422 0d0a 2020 2020 2020 2020 7a5f  OUT"..        z_
-0000a2e0: 6469 7220 3d20 2255 5022 2069 6620 7376  dir = "UP" if sv
-0000a2f0: 2e7a 203e 2030 2065 6c73 6520 2244 4f57  .z > 0 else "DOW
-0000a300: 4e22 0d0a 2020 2020 2020 2020 6d6f 7665  N"..        move
-0000a310: 203d 2066 227b 785f 6469 727d 207b 6162   = f"{x_dir} {ab
-0000a320: 7328 7376 2e78 293a 322e 3266 7d6d 6d3b  s(sv.x):2.2f}mm;
-0000a330: 207b 795f 6469 727d 207b 6162 7328 7376   {y_dir} {abs(sv
-0000a340: 2e79 293a 322e 3266 7d6d 6d3b 207b 7a5f  .y):2.2f}mm; {z_
-0000a350: 6469 727d 207b 6162 7328 7376 2e7a 293a  dir} {abs(sv.z):
-0000a360: 322e 3266 7d6d 6d22 0d0a 2020 2020 2020  2.2f}mm"..      
-0000a370: 2020 6966 2061 6c6c 2876 616c 2069 7320    if all(val is 
-0000a380: 6e6f 7420 4e6f 6e65 2066 6f72 2076 616c  not None for val
-0000a390: 2069 6e20 5b63 6f75 6368 5f76 7274 2c20   in [couch_vrt, 
-0000a3a0: 636f 7563 685f 6c61 742c 2063 6f75 6368  couch_lat, couch
-0000a3b0: 5f6c 6e67 5d29 3a0d 0a20 2020 2020 2020  _lng]):..       
-0000a3c0: 2020 2020 206e 6577 5f6c 6174 203d 2072       new_lat = r
-0000a3d0: 6f75 6e64 2863 6f75 6368 5f6c 6174 202b  ound(couch_lat +
-0000a3e0: 2073 762e 7820 2f20 3130 2c20 3229 0d0a   sv.x / 10, 2)..
-0000a3f0: 2020 2020 2020 2020 2020 2020 6e65 775f              new_
-0000a400: 7672 7420 3d20 726f 756e 6428 636f 7563  vrt = round(couc
-0000a410: 685f 7672 7420 2b20 7376 2e7a 202f 2031  h_vrt + sv.z / 1
-0000a420: 302c 2032 290d 0a20 2020 2020 2020 2020  0, 2)..         
-0000a430: 2020 206e 6577 5f6c 6e67 203d 2072 6f75     new_lng = rou
-0000a440: 6e64 2863 6f75 6368 5f6c 6e67 202b 2073  nd(couch_lng + s
-0000a450: 762e 7920 2f20 3130 2c20 3229 0d0a 2020  v.y / 10, 2)..  
-0000a460: 2020 2020 2020 2020 2020 6d6f 7665 202b            move +
-0000a470: 3d20 6622 5c6e 4e65 7720 636f 7563 6820  = f"\nNew couch 
-0000a480: 636f 6f72 6469 6e61 7465 7320 286d 6d29  coordinates (mm)
-0000a490: 3a20 5652 543a 207b 6e65 775f 7672 743a  : VRT: {new_vrt:
-0000a4a0: 332e 3266 7d3b 204c 4e47 3a20 7b6e 6577  3.2f}; LNG: {new
-0000a4b0: 5f6c 6e67 3a33 2e32 667d 3b20 4c41 543a  _lng:3.2f}; LAT:
-0000a4c0: 207b 6e65 775f 6c61 743a 332e 3266 7d22   {new_lat:3.2f}"
-0000a4d0: 0d0a 2020 2020 2020 2020 7265 7475 726e  ..        return
-0000a4e0: 206d 6f76 650d 0a0d 0a20 2020 2040 6172   move....    @ar
-0000a4f0: 6775 652e 6f70 7469 6f6e 7328 7661 6c75  gue.options(valu
-0000a500: 653d 2822 616c 6c22 2c20 2272 616e 6765  e=("all", "range
-0000a510: 2229 290d 0a20 2020 2064 6566 2061 7869  "))..    def axi
-0000a520: 735f 726d 735f 6465 7669 6174 696f 6e28  s_rms_deviation(
-0000a530: 0d0a 2020 2020 2020 2020 7365 6c66 2c20  ..        self, 
-0000a540: 6178 6973 3a20 4178 6973 207c 2074 7570  axis: Axis | tup
-0000a550: 6c65 5b41 7869 732c 202e 2e2e 5d20 3d20  le[Axis, ...] = 
-0000a560: 4178 6973 2e47 414e 5452 592c 2076 616c  Axis.GANTRY, val
-0000a570: 7565 3a20 7374 7220 3d20 2261 6c6c 220d  ue: str = "all".
-0000a580: 0a20 2020 2029 202d 3e20 4974 6572 6162  .    ) -> Iterab
-0000a590: 6c65 207c 2066 6c6f 6174 3a0d 0a20 2020  le | float:..   
-0000a5a0: 2020 2020 2022 2222 5468 6520 524d 5320       """The RMS 
-0000a5b0: 6465 7669 6174 696f 6e73 206f 6620 6120  deviations of a 
-0000a5c0: 6769 7665 6e20 6178 6973 2f61 7865 732e  given axis/axes.
-0000a5d0: 0d0a 0d0a 2020 2020 2020 2020 5061 7261  ....        Para
-0000a5e0: 6d65 7465 7273 0d0a 2020 2020 2020 2020  meters..        
-0000a5f0: 2d2d 2d2d 2d2d 2d2d 2d2d 0d0a 2020 2020  ----------..    
-0000a600: 2020 2020 6178 6973 203a 2028 2747 616e      axis : ('Gan
-0000a610: 7472 7927 2c20 2743 6f6c 6c69 6d61 746f  try', 'Collimato
-0000a620: 7227 2c20 2743 6f75 6368 272c 2027 4570  r', 'Couch', 'Ep
-0000a630: 6964 272c 2027 4742 2043 6f6d 626f 272c  id', 'GB Combo',
-0000a640: 2020 2747 4250 2043 6f6d 626f 2729 0d0a    'GBP Combo')..
-0000a650: 2020 2020 2020 2020 2020 2020 5468 6520              The 
-0000a660: 6178 6973 2064 6573 6972 6564 2e0d 0a20  axis desired... 
-0000a670: 2020 2020 2020 2076 616c 7565 203a 207b         value : {
-0000a680: 2761 6c6c 272c 2027 7261 6e67 6527 7d0d  'all', 'range'}.
-0000a690: 0a20 2020 2020 2020 2020 2020 2057 6865  .            Whe
-0000a6a0: 7468 6572 2074 6f20 7265 7475 726e 2061  ther to return a
-0000a6b0: 6c6c 2074 6865 2052 4d53 2076 616c 7565  ll the RMS value
-0000a6c0: 7320 6672 6f6d 2061 6c6c 2069 6d61 6765  s from all image
-0000a6d0: 7320 666f 7220 7468 6174 2061 7869 732c  s for that axis,
-0000a6e0: 206f 7220 6f6e 6c79 2072 6574 7572 6e20   or only return 
-0000a6f0: 7468 6520 6d61 7869 6d75 6d20 7261 6e67  the maximum rang
-0000a700: 6520 6f66 0d0a 2020 2020 2020 2020 2020  e of..          
-0000a710: 2020 7661 6c75 6573 2c20 692e 652e 2074    values, i.e. t
-0000a720: 6865 2027 7361 6727 2e0d 0a20 2020 2020  he 'sag'...     
-0000a730: 2020 2022 2222 0d0a 2020 2020 2020 2020     """..        
-0000a740: 6966 2069 7369 6e73 7461 6e63 6528 6178  if isinstance(ax
-0000a750: 6973 2c20 4974 6572 6162 6c65 293a 0d0a  is, Iterable):..
-0000a760: 2020 2020 2020 2020 2020 2020 6178 6973              axis
-0000a770: 203d 205b 636f 6e76 6572 745f 746f 5f65   = [convert_to_e
-0000a780: 6e75 6d28 6178 2c20 4178 6973 2920 666f  num(ax, Axis) fo
-0000a790: 7220 6178 2069 6e20 6178 6973 5d0d 0a20  r ax in axis].. 
-0000a7a0: 2020 2020 2020 2065 6c73 653a 0d0a 2020         else:..  
-0000a7b0: 2020 2020 2020 2020 2020 6178 6973 203d            axis =
-0000a7c0: 2063 6f6e 7665 7274 5f74 6f5f 656e 756d   convert_to_enum
-0000a7d0: 2861 7869 732c 2041 7869 7329 0d0a 2020  (axis, Axis)..  
-0000a7e0: 2020 2020 2020 6966 2061 7869 7320 213d        if axis !=
-0000a7f0: 2041 7869 732e 4550 4944 3a0d 0a20 2020   Axis.EPID:..   
-0000a800: 2020 2020 2020 2020 2061 7474 7220 3d20           attr = 
-0000a810: 2263 6178 3262 625f 7665 6374 6f72 220d  "cax2bb_vector".
-0000a820: 0a20 2020 2020 2020 2065 6c73 653a 0d0a  .        else:..
-0000a830: 2020 2020 2020 2020 2020 2020 6174 7472              attr
-0000a840: 203d 2022 6361 7832 6570 6964 5f76 6563   = "cax2epid_vec
-0000a850: 746f 7222 0d0a 2020 2020 2020 2020 2020  tor"..          
-0000a860: 2020 6178 6973 203d 2028 4178 6973 2e47    axis = (Axis.G
-0000a870: 414e 5452 592c 2041 7869 732e 434f 4c4c  ANTRY, Axis.COLL
-0000a880: 494d 4154 4f52 2c20 4178 6973 2e52 4546  IMATOR, Axis.REF
-0000a890: 4552 454e 4345 290d 0a20 2020 2020 2020  ERENCE)..       
-0000a8a0: 2069 6d67 7320 3d20 7365 6c66 2e5f 6765   imgs = self._ge
-0000a8b0: 745f 696d 6167 6573 2861 7869 733d 6178  t_images(axis=ax
-0000a8c0: 6973 295b 315d 0d0a 2020 2020 2020 2020  is)[1]..        
-0000a8d0: 6966 206c 656e 2869 6d67 7329 203c 3d20  if len(imgs) <= 
-0000a8e0: 313a 0d0a 2020 2020 2020 2020 2020 2020  1:..            
-0000a8f0: 7265 7475 726e 2028 302c 290d 0a20 2020  return (0,)..   
-0000a900: 2020 2020 2072 6d73 203d 205b 6765 7461       rms = [geta
-0000a910: 7474 7228 696d 672c 2061 7474 7229 2e61  ttr(img, attr).a
-0000a920: 735f 7363 616c 6172 2829 2066 6f72 2069  s_scalar() for i
-0000a930: 6d67 2069 6e20 696d 6773 5d0d 0a20 2020  mg in imgs]..   
-0000a940: 2020 2020 2069 6620 7661 6c75 6520 3d3d       if value ==
-0000a950: 2022 7261 6e67 6522 3a0d 0a20 2020 2020   "range":..     
-0000a960: 2020 2020 2020 2072 6d73 203d 206d 6178         rms = max
-0000a970: 2872 6d73 2920 2d20 6d69 6e28 726d 7329  (rms) - min(rms)
-0000a980: 0d0a 2020 2020 2020 2020 7265 7475 726e  ..        return
-0000a990: 2072 6d73 0d0a 0d0a 2020 2020 4061 7267   rms....    @arg
-0000a9a0: 7565 2e6f 7074 696f 6e73 286d 6574 7269  ue.options(metri
-0000a9b0: 633d 2822 6d61 7822 2c20 226d 6564 6961  c=("max", "media
-0000a9c0: 6e22 2c20 226d 6561 6e22 2929 0d0a 2020  n", "mean"))..  
-0000a9d0: 2020 6465 6620 6361 7832 6262 5f64 6973    def cax2bb_dis
-0000a9e0: 7461 6e63 6528 7365 6c66 2c20 6d65 7472  tance(self, metr
-0000a9f0: 6963 3a20 7374 7220 3d20 226d 6178 2229  ic: str = "max")
-0000aa00: 202d 3e20 666c 6f61 743a 0d0a 2020 2020   -> float:..    
-0000aa10: 2020 2020 2222 2254 6865 2064 6973 7461      """The dista
-0000aa20: 6e63 6520 696e 206d 6d20 6265 7477 6565  nce in mm betwee
-0000aa30: 6e20 7468 6520 4341 5820 616e 6420 4242  n the CAX and BB
-0000aa40: 2066 6f72 2061 6c6c 2069 6d61 6765 7320   for all images 
-0000aa50: 6163 636f 7264 696e 6720 746f 2074 6865  according to the
-0000aa60: 2067 6976 656e 206d 6574 7269 632e 0d0a   given metric...
-0000aa70: 0d0a 2020 2020 2020 2020 5061 7261 6d65  ..        Parame
-0000aa80: 7465 7273 0d0a 2020 2020 2020 2020 2d2d  ters..        --
-0000aa90: 2d2d 2d2d 2d2d 2d2d 0d0a 2020 2020 2020  --------..      
-0000aaa0: 2020 6d65 7472 6963 203a 207b 276d 6178    metric : {'max
-0000aab0: 272c 2027 6d65 6469 616e 272c 2027 6d65  ', 'median', 'me
-0000aac0: 616e 277d 0d0a 2020 2020 2020 2020 2020  an'}..          
-0000aad0: 2020 5468 6520 6d65 7472 6963 206f 6620    The metric of 
-0000aae0: 6469 7374 616e 6365 2074 6f20 7573 652e  distance to use.
-0000aaf0: 0d0a 2020 2020 2020 2020 2222 220d 0a20  ..        """.. 
-0000ab00: 2020 2020 2020 2069 6620 6d65 7472 6963         if metric
-0000ab10: 203d 3d20 226d 6178 223a 0d0a 2020 2020   == "max":..    
-0000ab20: 2020 2020 2020 2020 7265 7475 726e 206d          return m
-0000ab30: 6178 2869 6d61 6765 2e63 6178 3262 625f  ax(image.cax2bb_
-0000ab40: 6469 7374 616e 6365 2066 6f72 2069 6d61  distance for ima
-0000ab50: 6765 2069 6e20 7365 6c66 2e69 6d61 6765  ge in self.image
-0000ab60: 7329 0d0a 2020 2020 2020 2020 656c 6966  s)..        elif
-0000ab70: 206d 6574 7269 6320 3d3d 2022 6d65 6469   metric == "medi
-0000ab80: 616e 223a 0d0a 2020 2020 2020 2020 2020  an":..          
-0000ab90: 2020 7265 7475 726e 2066 6c6f 6174 286e    return float(n
-0000aba0: 702e 6d65 6469 616e 285b 696d 6167 652e  p.median([image.
-0000abb0: 6361 7832 6262 5f64 6973 7461 6e63 6520  cax2bb_distance 
-0000abc0: 666f 7220 696d 6167 6520 696e 2073 656c  for image in sel
-0000abd0: 662e 696d 6167 6573 5d29 290d 0a20 2020  f.images]))..   
-0000abe0: 2020 2020 2065 6c69 6620 6d65 7472 6963       elif metric
-0000abf0: 203d 3d20 226d 6561 6e22 3a0d 0a20 2020   == "mean":..   
-0000ac00: 2020 2020 2020 2020 2072 6574 7572 6e20           return 
-0000ac10: 666c 6f61 7428 6e70 2e6d 6561 6e28 5b69  float(np.mean([i
-0000ac20: 6d61 6765 2e63 6178 3262 625f 6469 7374  mage.cax2bb_dist
-0000ac30: 616e 6365 2066 6f72 2069 6d61 6765 2069  ance for image i
-0000ac40: 6e20 7365 6c66 2e69 6d61 6765 735d 2929  n self.images]))
-0000ac50: 0d0a 0d0a 2020 2020 4061 7267 7565 2e6f  ....    @argue.o
-0000ac60: 7074 696f 6e73 286d 6574 7269 633d 2822  ptions(metric=("
-0000ac70: 6d61 7822 2c20 226d 6564 6961 6e22 2c20  max", "median", 
-0000ac80: 226d 6561 6e22 2929 0d0a 2020 2020 6465  "mean"))..    de
-0000ac90: 6620 6361 7832 6570 6964 5f64 6973 7461  f cax2epid_dista
-0000aca0: 6e63 6528 7365 6c66 2c20 6d65 7472 6963  nce(self, metric
-0000acb0: 3a20 7374 7220 3d20 226d 6178 2229 202d  : str = "max") -
-0000acc0: 3e20 666c 6f61 743a 0d0a 2020 2020 2020  > float:..      
-0000acd0: 2020 2222 2254 6865 2064 6973 7461 6e63    """The distanc
-0000ace0: 6520 696e 206d 6d20 6265 7477 6565 6e20  e in mm between 
-0000acf0: 7468 6520 4341 5820 616e 6420 4550 4944  the CAX and EPID
-0000ad00: 2063 656e 7465 7220 7069 7865 6c20 666f   center pixel fo
-0000ad10: 7220 616c 6c20 696d 6167 6573 2061 6363  r all images acc
-0000ad20: 6f72 6469 6e67 2074 6f20 7468 6520 6769  ording to the gi
-0000ad30: 7665 6e20 6d65 7472 6963 2e0d 0a0d 0a20  ven metric..... 
-0000ad40: 2020 2020 2020 2050 6172 616d 6574 6572         Parameter
-0000ad50: 730d 0a20 2020 2020 2020 202d 2d2d 2d2d  s..        -----
-0000ad60: 2d2d 2d2d 2d0d 0a20 2020 2020 2020 206d  -----..        m
-0000ad70: 6574 7269 6320 3a20 7b27 6d61 7827 2c20  etric : {'max', 
-0000ad80: 276d 6564 6961 6e27 2c20 276d 6561 6e27  'median', 'mean'
-0000ad90: 7d0d 0a20 2020 2020 2020 2020 2020 2054  }..            T
-0000ada0: 6865 206d 6574 7269 6320 6f66 2064 6973  he metric of dis
-0000adb0: 7461 6e63 6520 746f 2075 7365 2e0d 0a20  tance to use... 
-0000adc0: 2020 2020 2020 2022 2222 0d0a 2020 2020         """..    
-0000add0: 2020 2020 6966 206d 6574 7269 6320 3d3d      if metric ==
-0000ade0: 2022 6d61 7822 3a0d 0a20 2020 2020 2020   "max":..       
-0000adf0: 2020 2020 2072 6574 7572 6e20 6d61 7828       return max(
-0000ae00: 696d 6167 652e 6361 7832 6570 6964 5f64  image.cax2epid_d
-0000ae10: 6973 7461 6e63 6520 666f 7220 696d 6167  istance for imag
-0000ae20: 6520 696e 2073 656c 662e 696d 6167 6573  e in self.images
-0000ae30: 290d 0a20 2020 2020 2020 2065 6c69 6620  )..        elif 
-0000ae40: 6d65 7472 6963 203d 3d20 226d 6564 6961  metric == "media
-0000ae50: 6e22 3a0d 0a20 2020 2020 2020 2020 2020  n":..           
-0000ae60: 2072 6574 7572 6e20 666c 6f61 7428 6e70   return float(np
-0000ae70: 2e6d 6564 6961 6e28 5b69 6d61 6765 2e63  .median([image.c
-0000ae80: 6178 3265 7069 645f 6469 7374 616e 6365  ax2epid_distance
-0000ae90: 2066 6f72 2069 6d61 6765 2069 6e20 7365   for image in se
-0000aea0: 6c66 2e69 6d61 6765 735d 2929 0d0a 2020  lf.images]))..  
-0000aeb0: 2020 2020 2020 656c 6966 206d 6574 7269        elif metri
-0000aec0: 6320 3d3d 2022 6d65 616e 223a 0d0a 2020  c == "mean":..  
-0000aed0: 2020 2020 2020 2020 2020 7265 7475 726e            return
-0000aee0: 2066 6c6f 6174 286e 702e 6d65 616e 285b   float(np.mean([
-0000aef0: 696d 6167 652e 6361 7832 6570 6964 5f64  image.cax2epid_d
-0000af00: 6973 7461 6e63 6520 666f 7220 696d 6167  istance for imag
-0000af10: 6520 696e 2073 656c 662e 696d 6167 6573  e in self.images
-0000af20: 5d29 290d 0a0d 0a20 2020 2064 6566 205f  ]))....    def _
-0000af30: 706c 6f74 5f64 6576 6961 7469 6f6e 280d  plot_deviation(.
-0000af40: 0a20 2020 2020 2020 2073 656c 662c 2061  .        self, a
-0000af50: 7869 733a 2041 7869 732c 2061 783a 2070  xis: Axis, ax: p
-0000af60: 6c74 2e41 7865 7320 7c20 4e6f 6e65 203d  lt.Axes | None =
-0000af70: 204e 6f6e 652c 2073 686f 773a 2062 6f6f   None, show: boo
-0000af80: 6c20 3d20 5472 7565 0d0a 2020 2020 2920  l = True..    ) 
-0000af90: 2d3e 204e 6f6e 653a 0d0a 2020 2020 2020  -> None:..      
-0000afa0: 2020 2222 2248 656c 7065 7220 6675 6e63    """Helper func
-0000afb0: 7469 6f6e 3a20 506c 6f74 2074 6865 2073  tion: Plot the s
-0000afc0: 6167 2069 6e20 4361 7274 6573 6961 6e20  ag in Cartesian 
-0000afd0: 636f 6f72 6469 6e61 7465 732e 0d0a 0d0a  coordinates.....
-0000afe0: 2020 2020 2020 2020 5061 7261 6d65 7465          Paramete
-0000aff0: 7273 0d0a 2020 2020 2020 2020 2d2d 2d2d  rs..        ----
-0000b000: 2d2d 2d2d 2d2d 0d0a 2020 2020 2020 2020  ------..        
-0000b010: 6178 6973 203a 207b 2767 616e 7472 7927  axis : {'gantry'
-0000b020: 2c20 2765 7069 6427 2c20 2763 6f6c 6c69  , 'epid', 'colli
-0000b030: 6d61 746f 7227 2c20 2763 6f75 6368 277d  mator', 'couch'}
-0000b040: 0d0a 2020 2020 2020 2020 2020 2020 5468  ..            Th
-0000b050: 6520 6178 6973 2074 6f20 706c 6f74 2e0d  e axis to plot..
-0000b060: 0a20 2020 2020 2020 2061 7820 3a20 4e6f  .        ax : No
-0000b070: 6e65 2c20 6d61 7470 6c6f 746c 6962 2e41  ne, matplotlib.A
-0000b080: 7865 730d 0a20 2020 2020 2020 2020 2020  xes..           
-0000b090: 2054 6865 2061 7869 7320 746f 2070 6c6f   The axis to plo
-0000b0a0: 7420 746f 2e20 4966 204e 6f6e 652c 2063  t to. If None, c
-0000b0b0: 7265 6174 6573 2061 206e 6577 2070 6c6f  reates a new plo
-0000b0c0: 742e 0d0a 2020 2020 2020 2020 7368 6f77  t...        show
-0000b0d0: 203a 2062 6f6f 6c0d 0a20 2020 2020 2020   : bool..       
-0000b0e0: 2020 2020 2057 6865 7468 6572 2074 6f20       Whether to 
-0000b0f0: 7368 6f77 2074 6865 2069 6d61 6765 2e0d  show the image..
-0000b100: 0a20 2020 2020 2020 2022 2222 0d0a 2020  .        """..  
-0000b110: 2020 2020 2020 7469 746c 6520 3d20 6622        title = f"
-0000b120: 496e 2d70 6c61 6e65 207b 6178 6973 2e76  In-plane {axis.v
-0000b130: 616c 7565 7d20 6469 7370 6c61 6365 6d65  alue} displaceme
-0000b140: 6e74 220d 0a20 2020 2020 2020 2069 6620  nt"..        if 
-0000b150: 6178 6973 203d 3d20 4178 6973 2e45 5049  axis == Axis.EPI
-0000b160: 443a 0d0a 2020 2020 2020 2020 2020 2020  D:..            
-0000b170: 6174 7472 203d 2022 6361 7832 6570 6964  attr = "cax2epid
-0000b180: 5f76 6563 746f 7222 0d0a 2020 2020 2020  _vector"..      
-0000b190: 2020 2020 2020 6178 6973 203d 2041 7869        axis = Axi
-0000b1a0: 732e 4741 4e54 5259 0d0a 2020 2020 2020  s.GANTRY..      
-0000b1b0: 2020 656c 7365 3a0d 0a20 2020 2020 2020    else:..       
-0000b1c0: 2020 2020 2061 7474 7220 3d20 2263 6178       attr = "cax
-0000b1d0: 3262 625f 7665 6374 6f72 220d 0a20 2020  2bb_vector"..   
-0000b1e0: 2020 2020 2023 2067 6574 2061 7869 7320       # get axis 
-0000b1f0: 696d 6167 6573 2c20 616e 676c 6573 2c20  images, angles, 
-0000b200: 616e 6420 7368 6966 7473 0d0a 2020 2020  and shifts..    
-0000b210: 2020 2020 696d 6773 203d 205b 0d0a 2020      imgs = [..  
-0000b220: 2020 2020 2020 2020 2020 696d 6167 650d            image.
-0000b230: 0a20 2020 2020 2020 2020 2020 2066 6f72  .            for
-0000b240: 2069 6d61 6765 2069 6e20 7365 6c66 2e69   image in self.i
-0000b250: 6d61 6765 730d 0a20 2020 2020 2020 2020  mages..         
-0000b260: 2020 2069 6620 696d 6167 652e 7661 7269     if image.vari
-0000b270: 6162 6c65 5f61 7869 7320 696e 2028 6178  able_axis in (ax
-0000b280: 6973 2c20 4178 6973 2e52 4546 4552 454e  is, Axis.REFEREN
-0000b290: 4345 290d 0a20 2020 2020 2020 205d 0d0a  CE)..        ]..
-0000b2a0: 2020 2020 2020 2020 616e 676c 6573 203d          angles =
-0000b2b0: 205b 6765 7461 7474 7228 696d 6167 652c   [getattr(image,
-0000b2c0: 2066 227b 6178 6973 2e76 616c 7565 2e6c   f"{axis.value.l
-0000b2d0: 6f77 6572 2829 7d5f 616e 676c 6522 2920  ower()}_angle") 
-0000b2e0: 666f 7220 696d 6167 6520 696e 2069 6d67  for image in img
-0000b2f0: 735d 0d0a 2020 2020 2020 2020 787a 5f73  s]..        xz_s
-0000b300: 6167 203d 206e 702e 6172 7261 7928 5b67  ag = np.array([g
-0000b310: 6574 6174 7472 2869 6d67 2c20 6174 7472  etattr(img, attr
-0000b320: 292e 7820 666f 7220 696d 6720 696e 2069  ).x for img in i
-0000b330: 6d67 735d 290d 0a20 2020 2020 2020 2079  mgs])..        y
-0000b340: 5f73 6167 203d 206e 702e 6172 7261 7928  _sag = np.array(
-0000b350: 5b67 6574 6174 7472 2869 6d67 2c20 6174  [getattr(img, at
-0000b360: 7472 292e 7920 666f 7220 696d 6720 696e  tr).y for img in
-0000b370: 2069 6d67 735d 290d 0a20 2020 2020 2020   imgs])..       
-0000b380: 2072 6d73 203d 206e 702e 7371 7274 2878   rms = np.sqrt(x
-0000b390: 7a5f 7361 672a 2a32 202b 2079 5f73 6167  z_sag**2 + y_sag
-0000b3a0: 2a2a 3229 0d0a 0d0a 2020 2020 2020 2020  **2)....        
-0000b3b0: 2320 706c 6f74 2074 6865 2061 7869 7320  # plot the axis 
-0000b3c0: 6465 7669 6174 696f 6e0d 0a20 2020 2020  deviation..     
-0000b3d0: 2020 2069 6620 6178 2069 7320 4e6f 6e65     if ax is None
-0000b3e0: 3a0d 0a20 2020 2020 2020 2020 2020 2061  :..            a
-0000b3f0: 7820 3d20 706c 742e 7375 6270 6c6f 7428  x = plt.subplot(
-0000b400: 3131 3129 0d0a 2020 2020 2020 2020 6178  111)..        ax
-0000b410: 2e70 6c6f 7428 616e 676c 6573 2c20 795f  .plot(angles, y_
-0000b420: 7361 672c 2022 626f 222c 206c 6162 656c  sag, "bo", label
-0000b430: 3d22 592d 6178 6973 222c 206c 733d 222d  ="Y-axis", ls="-
-0000b440: 2e22 290d 0a20 2020 2020 2020 2061 782e  .")..        ax.
-0000b450: 706c 6f74 2861 6e67 6c65 732c 2078 7a5f  plot(angles, xz_
-0000b460: 7361 672c 2022 6d5e 222c 206c 6162 656c  sag, "m^", label
-0000b470: 3d22 582f 5a2d 6178 6973 222c 206c 733d  ="X/Z-axis", ls=
-0000b480: 222d 2e22 290d 0a20 2020 2020 2020 2061  "-.")..        a
-0000b490: 782e 706c 6f74 2861 6e67 6c65 732c 2072  x.plot(angles, r
-0000b4a0: 6d73 2c20 2267 2b22 2c20 6c61 6265 6c3d  ms, "g+", label=
-0000b4b0: 2252 4d53 222c 206c 733d 222d 2229 0d0a  "RMS", ls="-")..
-0000b4c0: 2020 2020 2020 2020 6178 2e73 6574 5f74          ax.set_t
-0000b4d0: 6974 6c65 2874 6974 6c65 290d 0a20 2020  itle(title)..   
-0000b4e0: 2020 2020 2061 782e 7365 745f 796c 6162       ax.set_ylab
-0000b4f0: 656c 2822 6d6d 2229 0d0a 2020 2020 2020  el("mm")..      
-0000b500: 2020 6178 2e73 6574 5f78 6c61 6265 6c28    ax.set_xlabel(
-0000b510: 6622 7b61 7869 732e 7661 6c75 657d 2061  f"{axis.value} a
-0000b520: 6e67 6c65 2229 0d0a 2020 2020 2020 2020  ngle")..        
-0000b530: 6178 2e73 6574 5f78 7469 636b 7328 6e70  ax.set_xticks(np
-0000b540: 2e61 7261 6e67 6528 302c 2033 3631 2c20  .arange(0, 361, 
-0000b550: 3435 2929 0d0a 2020 2020 2020 2020 6178  45))..        ax
-0000b560: 2e73 6574 5f78 6c69 6d28 2d31 352c 2033  .set_xlim(-15, 3
-0000b570: 3735 290d 0a20 2020 2020 2020 2061 782e  75)..        ax.
-0000b580: 6772 6964 2854 7275 6529 0d0a 2020 2020  grid(True)..    
-0000b590: 2020 2020 6178 2e6c 6567 656e 6428 6e75      ax.legend(nu
-0000b5a0: 6d70 6f69 6e74 733d 3129 0d0a 2020 2020  mpoints=1)..    
-0000b5b0: 2020 2020 6966 2073 686f 773a 0d0a 2020      if show:..  
-0000b5c0: 2020 2020 2020 2020 2020 706c 742e 7368            plt.sh
-0000b5d0: 6f77 2829 0d0a 0d0a 2020 2020 6465 6620  ow()....    def 
-0000b5e0: 5f67 6574 5f69 6d61 6765 7328 0d0a 2020  _get_images(..  
-0000b5f0: 2020 2020 2020 7365 6c66 2c20 6178 6973        self, axis
-0000b600: 3a20 4178 6973 207c 2074 7570 6c65 5b41  : Axis | tuple[A
-0000b610: 7869 732c 202e 2e2e 5d20 3d20 2841 7869  xis, ...] = (Axi
-0000b620: 732e 4741 4e54 5259 2c29 0d0a 2020 2020  s.GANTRY,)..    
-0000b630: 2920 2d3e 2074 7570 6c65 5b66 6c6f 6174  ) -> tuple[float
-0000b640: 2c20 6c69 7374 5d3a 0d0a 2020 2020 2020  , list]:..      
-0000b650: 2020 6966 2069 7369 6e73 7461 6e63 6528    if isinstance(
-0000b660: 6178 6973 2c20 4178 6973 293a 0d0a 2020  axis, Axis):..  
-0000b670: 2020 2020 2020 2020 2020 6178 6973 203d            axis =
-0000b680: 2028 6178 6973 2c29 0d0a 2020 2020 2020   (axis,)..      
-0000b690: 2020 696d 6167 6573 203d 205b 696d 6167    images = [imag
-0000b6a0: 6520 666f 7220 696d 6167 6520 696e 2073  e for image in s
-0000b6b0: 656c 662e 696d 6167 6573 2069 6620 696d  elf.images if im
-0000b6c0: 6167 652e 7661 7269 6162 6c65 5f61 7869  age.variable_axi
-0000b6d0: 7320 696e 2061 7869 735d 0d0a 2020 2020  s in axis]..    
-0000b6e0: 2020 2020 7265 7475 726e 206c 656e 2869      return len(i
-0000b6f0: 6d61 6765 7329 2c20 696d 6167 6573 0d0a  mages), images..
-0000b700: 0d0a 2020 2020 6465 6620 706c 6f74 5f61  ..    def plot_a
-0000b710: 7869 735f 696d 6167 6573 280d 0a20 2020  xis_images(..   
-0000b720: 2020 2020 2073 656c 662c 2061 7869 733a       self, axis:
-0000b730: 2041 7869 7320 3d20 4178 6973 2e47 414e   Axis = Axis.GAN
-0000b740: 5452 592c 2073 686f 773a 2062 6f6f 6c20  TRY, show: bool 
-0000b750: 3d20 5472 7565 2c20 6178 3a20 706c 742e  = True, ax: plt.
-0000b760: 4178 6573 207c 204e 6f6e 6520 3d20 4e6f  Axes | None = No
-0000b770: 6e65 0d0a 2020 2020 2920 2d3e 204e 6f6e  ne..    ) -> Non
-0000b780: 653a 0d0a 2020 2020 2020 2020 2222 2250  e:..        """P
-0000b790: 6c6f 7420 616c 6c20 4341 582f 4242 2f45  lot all CAX/BB/E
-0000b7a0: 5049 4420 706f 7369 7469 6f6e 7320 666f  PID positions fo
-0000b7b0: 7220 7468 6520 696d 6167 6573 206f 6620  r the images of 
-0000b7c0: 6120 6769 7665 6e20 6178 6973 2e0d 0a0d  a given axis....
-0000b7d0: 0a20 2020 2020 2020 2046 6f72 2065 7861  .        For exa
-0000b7e0: 6d70 6c65 2c20 6178 6973 3d27 436f 7563  mple, axis='Couc
-0000b7f0: 6827 2070 6c6f 7473 2061 2072 6566 6572  h' plots a refer
-0000b800: 656e 6365 2069 6d61 6765 2c20 616e 6420  ence image, and 
-0000b810: 616c 6c20 7468 6520 4242 2070 6f69 6e74  all the BB point
-0000b820: 7320 6f66 2074 6865 206f 7468 6572 0d0a  s of the other..
-0000b830: 2020 2020 2020 2020 696d 6167 6573 2077          images w
-0000b840: 6865 7265 2074 6865 2063 6f75 6368 2077  here the couch w
-0000b850: 6173 206d 6f76 696e 672e 0d0a 0d0a 2020  as moving.....  
-0000b860: 2020 2020 2020 5061 7261 6d65 7465 7273        Parameters
-0000b870: 0d0a 2020 2020 2020 2020 2d2d 2d2d 2d2d  ..        ------
-0000b880: 2d2d 2d2d 0d0a 2020 2020 2020 2020 6178  ----..        ax
-0000b890: 6973 203a 207b 2747 616e 7472 7927 2c20  is : {'Gantry', 
-0000b8a0: 2743 6f6c 6c69 6d61 746f 7227 2c20 2743  'Collimator', 'C
-0000b8b0: 6f75 6368 272c 2027 4742 2043 6f6d 626f  ouch', 'GB Combo
-0000b8c0: 272c 2020 2747 4250 2043 6f6d 626f 277d  ',  'GBP Combo'}
-0000b8d0: 0d0a 2020 2020 2020 2020 2020 2020 5468  ..            Th
-0000b8e0: 6520 696d 6167 6573 2f6d 6172 6b65 7273  e images/markers
-0000b8f0: 2066 726f 6d20 7768 6963 6820 6163 6365   from which acce
-0000b900: 6c65 7261 746f 7220 6178 6973 2074 6f20  lerator axis to 
-0000b910: 706c 6f74 2e0d 0a20 2020 2020 2020 2073  plot...        s
-0000b920: 686f 7720 3a20 626f 6f6c 0d0a 2020 2020  how : bool..    
-0000b930: 2020 2020 2020 2020 5768 6574 6865 7220          Whether 
-0000b940: 746f 2061 6374 7561 6c6c 7920 7368 6f77  to actually show
-0000b950: 2074 6865 2069 6d61 6765 732e 0d0a 2020   the images...  
-0000b960: 2020 2020 2020 6178 203a 204e 6f6e 652c        ax : None,
-0000b970: 206d 6174 706c 6f74 6c69 622e 4178 6573   matplotlib.Axes
-0000b980: 0d0a 2020 2020 2020 2020 2020 2020 5468  ..            Th
-0000b990: 6520 6178 6973 2074 6f20 706c 6f74 2074  e axis to plot t
-0000b9a0: 6f2e 2049 6620 4e6f 6e65 2c20 6372 6561  o. If None, crea
-0000b9b0: 7465 7320 6120 6e65 7720 706c 6f74 2e0d  tes a new plot..
-0000b9c0: 0a20 2020 2020 2020 2022 2222 0d0a 2020  .        """..  
-0000b9d0: 2020 2020 2020 6178 6973 203d 2063 6f6e        axis = con
-0000b9e0: 7665 7274 5f74 6f5f 656e 756d 2861 7869  vert_to_enum(axi
-0000b9f0: 732c 2041 7869 7329 0d0a 2020 2020 2020  s, Axis)..      
-0000ba00: 2020 696d 6167 6573 203d 205b 0d0a 2020    images = [..  
-0000ba10: 2020 2020 2020 2020 2020 696d 6167 650d            image.
-0000ba20: 0a20 2020 2020 2020 2020 2020 2066 6f72  .            for
-0000ba30: 2069 6d61 6765 2069 6e20 7365 6c66 2e69   image in self.i
-0000ba40: 6d61 6765 730d 0a20 2020 2020 2020 2020  mages..         
-0000ba50: 2020 2069 6620 696d 6167 652e 7661 7269     if image.vari
-0000ba60: 6162 6c65 5f61 7869 7320 696e 2028 6178  able_axis in (ax
-0000ba70: 6973 2c20 4178 6973 2e52 4546 4552 454e  is, Axis.REFEREN
-0000ba80: 4345 290d 0a20 2020 2020 2020 205d 0d0a  CE)..        ]..
-0000ba90: 2020 2020 2020 2020 6178 203d 2069 6d61          ax = ima
-0000baa0: 6765 735b 305d 2e70 6c6f 7428 0d0a 2020  ges[0].plot(..  
-0000bab0: 2020 2020 2020 2020 2020 7368 6f77 3d46            show=F
-0000bac0: 616c 7365 2c20 6178 3d61 780d 0a20 2020  alse, ax=ax..   
-0000bad0: 2020 2020 2029 2020 2320 706c 6f74 7320       )  # plots 
-0000bae0: 7468 6520 6669 7273 7420 6d61 726b 6572  the first marker
-0000baf0: 3b20 706c 6f74 2074 6865 2072 6573 7420  ; plot the rest 
-0000bb00: 6f66 2074 6865 206d 6172 6b65 7273 2062  of the markers b
-0000bb10: 656c 6f77 0d0a 2020 2020 2020 2020 6966  elow..        if
-0000bb20: 2061 7869 7320 213d 2041 7869 732e 434f   axis != Axis.CO
-0000bb30: 5543 483a 0d0a 2020 2020 2020 2020 2020  UCH:..          
-0000bb40: 2020 2320 706c 6f74 2045 5049 440d 0a20    # plot EPID.. 
-0000bb50: 2020 2020 2020 2020 2020 2065 7069 645f             epid_
-0000bb60: 7873 203d 205b 696d 672e 6570 6964 2e78  xs = [img.epid.x
-0000bb70: 2066 6f72 2069 6d67 2069 6e20 696d 6167   for img in imag
-0000bb80: 6573 5b31 3a5d 5d0d 0a20 2020 2020 2020  es[1:]]..       
-0000bb90: 2020 2020 2065 7069 645f 7973 203d 205b       epid_ys = [
-0000bba0: 696d 672e 6570 6964 2e79 2066 6f72 2069  img.epid.y for i
-0000bbb0: 6d67 2069 6e20 696d 6167 6573 5b31 3a5d  mg in images[1:]
-0000bbc0: 5d0d 0a20 2020 2020 2020 2020 2020 2061  ]..            a
-0000bbd0: 782e 706c 6f74 2865 7069 645f 7873 2c20  x.plot(epid_xs, 
-0000bbe0: 6570 6964 5f79 732c 2022 622b 222c 206d  epid_ys, "b+", m
-0000bbf0: 733d 3829 0d0a 2020 2020 2020 2020 2020  s=8)..          
-0000bc00: 2020 2320 6765 7420 4341 5820 706f 7369    # get CAX posi
-0000bc10: 7469 6f6e 730d 0a20 2020 2020 2020 2020  tions..         
-0000bc20: 2020 2078 7320 3d20 5b69 6d67 2e66 6965     xs = [img.fie
-0000bc30: 6c64 5f63 6178 2e78 2066 6f72 2069 6d67  ld_cax.x for img
-0000bc40: 2069 6e20 696d 6167 6573 5b31 3a5d 5d0d   in images[1:]].
-0000bc50: 0a20 2020 2020 2020 2020 2020 2079 7320  .            ys 
-0000bc60: 3d20 5b69 6d67 2e66 6965 6c64 5f63 6178  = [img.field_cax
-0000bc70: 2e79 2066 6f72 2069 6d67 2069 6e20 696d  .y for img in im
-0000bc80: 6167 6573 5b31 3a5d 5d0d 0a20 2020 2020  ages[1:]]..     
-0000bc90: 2020 2020 2020 206d 6172 6b65 7220 3d20         marker = 
-0000bca0: 2267 7322 0d0a 2020 2020 2020 2020 656c  "gs"..        el
-0000bcb0: 7365 3a0d 0a20 2020 2020 2020 2020 2020  se:..           
-0000bcc0: 2023 2067 6574 2042 4220 706f 7369 7469   # get BB positi
-0000bcd0: 6f6e 730d 0a20 2020 2020 2020 2020 2020  ons..           
-0000bce0: 2078 7320 3d20 5b69 6d67 2e62 622e 7820   xs = [img.bb.x 
-0000bcf0: 666f 7220 696d 6720 696e 2069 6d61 6765  for img in image
-0000bd00: 735b 313a 5d5d 0d0a 2020 2020 2020 2020  s[1:]]..        
-0000bd10: 2020 2020 7973 203d 205b 696d 672e 6262      ys = [img.bb
-0000bd20: 2e79 2066 6f72 2069 6d67 2069 6e20 696d  .y for img in im
-0000bd30: 6167 6573 5b31 3a5d 5d0d 0a20 2020 2020  ages[1:]]..     
-0000bd40: 2020 2020 2020 206d 6172 6b65 7220 3d20         marker = 
-0000bd50: 2272 6f22 0d0a 2020 2020 2020 2020 6178  "ro"..        ax
-0000bd60: 2e70 6c6f 7428 7873 2c20 7973 2c20 6d61  .plot(xs, ys, ma
-0000bd70: 726b 6572 2c20 6d73 3d38 290d 0a20 2020  rker, ms=8)..   
-0000bd80: 2020 2020 2023 2073 6574 206c 6162 656c       # set label
-0000bd90: 730d 0a20 2020 2020 2020 2061 782e 7365  s..        ax.se
-0000bda0: 745f 7469 746c 6528 6178 6973 2e76 616c  t_title(axis.val
-0000bdb0: 7565 202b 2022 2077 6f62 626c 6522 290d  ue + " wobble").
-0000bdc0: 0a20 2020 2020 2020 2061 782e 7365 745f  .        ax.set_
-0000bdd0: 786c 6162 656c 2861 7869 732e 7661 6c75  xlabel(axis.valu
-0000bde0: 6520 2b20 2220 706f 7369 7469 6f6e 7320  e + " positions 
-0000bdf0: 7375 7065 7269 6d70 6f73 6564 2229 0d0a  superimposed")..
-0000be00: 2020 2020 2020 2020 6178 2e73 6574 5f79          ax.set_y
-0000be10: 6c61 6265 6c28 0d0a 2020 2020 2020 2020  label(..        
-0000be20: 2020 2020 6178 6973 2e76 616c 7565 0d0a      axis.value..
-0000be30: 2020 2020 2020 2020 2020 2020 2b20 6622              + f"
-0000be40: 2069 736f 2073 697a 653a 207b 6765 7461   iso size: {geta
-0000be50: 7474 7228 7365 6c66 2c20 6178 6973 2e76  ttr(self, axis.v
-0000be60: 616c 7565 2e6c 6f77 6572 2829 202b 2027  alue.lower() + '
-0000be70: 5f69 736f 5f73 697a 6527 293a 332e 3266  _iso_size'):3.2f
-0000be80: 7d6d 6d22 0d0a 2020 2020 2020 2020 290d  }mm"..        ).
-0000be90: 0a20 2020 2020 2020 2069 6620 7368 6f77  .        if show
-0000bea0: 3a0d 0a20 2020 2020 2020 2020 2020 2070  :..            p
-0000beb0: 6c74 2e73 686f 7728 290d 0a0d 0a20 2020  lt.show()....   
-0000bec0: 2064 6566 2070 6c6f 745f 6c6f 6361 7469   def plot_locati
-0000bed0: 6f6e 280d 0a20 2020 2020 2020 2073 656c  on(..        sel
-0000bee0: 662c 0d0a 2020 2020 2020 2020 7368 6f77  f,..        show
-0000bef0: 3a20 626f 6f6c 203d 2054 7275 652c 0d0a  : bool = True,..
-0000bf00: 2020 2020 2020 2020 7669 6577 626f 785f          viewbox_
-0000bf10: 6d6d 3a20 666c 6f61 7420 7c20 4e6f 6e65  mm: float | None
-0000bf20: 203d 204e 6f6e 652c 0d0a 2020 2020 2020   = None,..      
-0000bf30: 2020 706c 6f74 5f62 623a 2062 6f6f 6c20    plot_bb: bool 
-0000bf40: 3d20 5472 7565 2c0d 0a20 2020 2020 2020  = True,..       
-0000bf50: 2070 6c6f 745f 6973 6f63 656e 7465 725f   plot_isocenter_
-0000bf60: 7370 6865 7265 3a20 626f 6f6c 203d 2054  sphere: bool = T
-0000bf70: 7275 652c 0d0a 2020 2020 2020 2020 706c  rue,..        pl
-0000bf80: 6f74 5f63 6f75 6368 5f69 736f 3a20 626f  ot_couch_iso: bo
-0000bf90: 6f6c 203d 2054 7275 652c 0d0a 2020 2020  ol = True,..    
-0000bfa0: 2020 2020 706c 6f74 5f63 6f6c 6c5f 6973      plot_coll_is
-0000bfb0: 6f3a 2062 6f6f 6c20 3d20 5472 7565 2c0d  o: bool = True,.
-0000bfc0: 0a20 2020 2020 2020 2073 686f 775f 6c65  .        show_le
-0000bfd0: 6765 6e64 3a20 626f 6f6c 203d 2054 7275  gend: bool = Tru
-0000bfe0: 652c 0d0a 2020 2020 293a 0d0a 2020 2020  e,..    ):..    
-0000bff0: 2020 2020 2222 2250 6c6f 7420 7468 6520      """Plot the 
-0000c000: 6973 6f63 656e 7465 7220 616e 6420 7369  isocenter and si
-0000c010: 7a65 2061 7320 6120 7370 6865 7265 2069  ze as a sphere i
-0000c020: 6e20 3344 2073 7061 6365 2072 656c 6174  n 3D space relat
-0000c030: 6976 6520 746f 2074 6865 2042 422e 2054  ive to the BB. T
-0000c040: 6865 0d0a 2020 2020 2020 2020 6973 6f20  he..        iso 
-0000c050: 6973 2061 7420 7468 6520 6f72 6967 696e  is at the origin
-0000c060: 2e0d 0a0d 0a20 2020 2020 2020 204f 6e6c  .....        Onl
-0000c070: 7920 696d 6167 6573 2077 6865 7265 2074  y images where t
-0000c080: 6865 2063 6f75 6368 2077 6173 2061 7420  he couch was at 
-0000c090: 7a65 726f 2061 7265 2063 6f6e 7369 6465  zero are conside
-0000c0a0: 7265 642e 0d0a 0d0a 2020 2020 2020 2020  red.....        
-0000c0b0: 5061 7261 6d65 7465 7273 0d0a 2020 2020  Parameters..    
-0000c0c0: 2020 2020 2d2d 2d2d 2d2d 2d2d 2d2d 0d0a      ----------..
-0000c0d0: 2020 2020 2020 2020 7368 6f77 203a 2062          show : b
-0000c0e0: 6f6f 6c0d 0a20 2020 2020 2020 2020 2020  ool..           
-0000c0f0: 2057 6865 7468 6572 2074 6f20 706c 6f74   Whether to plot
-0000c100: 2074 6865 2069 6d61 6765 2e0d 0a20 2020   the image...   
-0000c110: 2020 2020 2076 6965 7762 6f78 5f6d 6d20       viewbox_mm 
-0000c120: 3a20 666c 6f61 740d 0a20 2020 2020 2020  : float..       
-0000c130: 2020 2020 2054 6865 2064 6566 6175 6c74       The default
-0000c140: 2073 697a 6520 6f66 2074 6865 2033 4420   size of the 3D 
-0000c150: 7370 6163 6520 746f 2070 6c6f 7420 696e  space to plot in
-0000c160: 206d 6d20 696e 2065 6163 6820 6178 6973   mm in each axis
-0000c170: 2e0d 0a20 2020 2020 2020 2070 6c6f 745f  ...        plot_
-0000c180: 6262 203a 2062 6f6f 6c0d 0a20 2020 2020  bb : bool..     
-0000c190: 2020 2020 2020 2057 6865 7468 6572 2074         Whether t
-0000c1a0: 6f20 706c 6f74 2074 6865 2042 4220 6c6f  o plot the BB lo
-0000c1b0: 6361 7469 6f6e 3b20 7468 6520 7369 7a65  cation; the size
-0000c1c0: 2069 7320 616c 736f 2063 6f6e 7369 6465   is also conside
-0000c1d0: 7265 642e 0d0a 2020 2020 2020 2020 706c  red...        pl
-0000c1e0: 6f74 5f69 736f 6365 6e74 6572 5f73 7068  ot_isocenter_sph
-0000c1f0: 6572 6520 3a20 626f 6f6c 0d0a 2020 2020  ere : bool..    
-0000c200: 2020 2020 2020 2020 5768 6574 6865 7220          Whether 
-0000c210: 746f 2070 6c6f 7420 7468 6520 6761 6e74  to plot the gant
-0000c220: 7279 202b 2063 6f6c 6c69 6d61 746f 7220  ry + collimator 
-0000c230: 6973 6f63 656e 7465 7220 7369 7a65 2e0d  isocenter size..
-0000c240: 0a20 2020 2020 2020 2070 6c6f 745f 636f  .        plot_co
-0000c250: 7563 685f 6973 6f20 3a20 626f 6f6c 0d0a  uch_iso : bool..
-0000c260: 2020 2020 2020 2020 2020 2020 5768 6574              Whet
-0000c270: 6865 7220 746f 2070 6c6f 7420 7468 6520  her to plot the 
-0000c280: 636f 7563 682d 706c 616e 652d 6f6e 6c79  couch-plane-only
-0000c290: 2069 736f 6365 6e74 6572 2073 697a 652e   isocenter size.
-0000c2a0: 0d0a 2020 2020 2020 2020 2020 2020 5468  ..            Th
-0000c2b0: 6973 2077 696c 6c20 6265 207a 6572 6f20  is will be zero 
-0000c2c0: 6966 2074 6865 7265 2061 7265 206e 6f20  if there are no 
-0000c2d0: 696d 6167 6573 2077 6865 7265 2074 6865  images where the
-0000c2e0: 2063 6f75 6368 2072 6f74 6174 6564 2e0d   couch rotated..
-0000c2f0: 0a20 2020 2020 2020 2070 6c6f 745f 636f  .        plot_co
-0000c300: 6c6c 5f69 736f 203a 2062 6f6f 6c0d 0a20  ll_iso : bool.. 
-0000c310: 2020 2020 2020 2020 2020 2057 6865 7468             Wheth
-0000c320: 6572 2074 6f20 706c 6f74 2074 6865 2063  er to plot the c
-0000c330: 6f6c 6c69 6d61 746f 722d 706c 616e 652d  ollimator-plane-
-0000c340: 6f6e 6c79 2069 736f 6365 6e74 6572 2073  only isocenter s
-0000c350: 697a 652e 0d0a 2020 2020 2020 2020 2020  ize...          
-0000c360: 2020 5468 6973 2069 7320 7368 6f77 6e20    This is shown 
-0000c370: 616c 6f6e 6720 7468 6520 5a2f 5920 706c  along the Z/Y pl
-0000c380: 616e 6520 6f6e 6c79 2074 6f20 6469 6666  ane only to diff
-0000c390: 6572 656e 7469 6174 6520 6672 6f6d 2074  erentiate from t
-0000c3a0: 6865 2063 6f75 6368 2069 736f 2076 6973  he couch iso vis
-0000c3b0: 7561 6c69 7a61 7469 6f6e 2e0d 0a20 2020  ualization...   
-0000c3c0: 2020 2020 2020 2020 2054 6865 2063 6f6c           The col
-0000c3d0: 6c69 6d61 746f 7220 706c 616e 6520 6973  limator plane is
-0000c3e0: 2061 6c77 6179 7320 6e6f 726d 616c 2074   always normal t
-0000c3f0: 6f20 7468 6520 6761 6e74 7279 2061 6e67  o the gantry ang
-0000c400: 6c65 2e0d 0a20 2020 2020 2020 2020 2020  le...           
-0000c410: 2054 6869 7320 7769 6c6c 2062 6520 7a65   This will be ze
-0000c420: 726f 2069 6620 7468 6572 6520 6172 6520  ro if there are 
-0000c430: 6e6f 2069 6d61 6765 7320 7768 6572 6520  no images where 
-0000c440: 7468 6520 636f 6c6c 696d 6174 6f72 2072  the collimator r
-0000c450: 6f74 6174 6564 2e0d 0a20 2020 2020 2020  otated...       
-0000c460: 2073 686f 775f 6c65 6765 6e64 203a 2062   show_legend : b
-0000c470: 6f6f 6c0d 0a20 2020 2020 2020 2020 2020  ool..           
-0000c480: 2057 6865 7468 6572 2074 6f20 7368 6f77   Whether to show
-0000c490: 2074 6865 206c 6567 656e 642e 0d0a 2020   the legend...  
-0000c4a0: 2020 2020 2020 2222 220d 0a20 2020 2020        """..     
-0000c4b0: 2020 206c 696d 6974 203d 2028 0d0a 2020     limit = (..  
-0000c4c0: 2020 2020 2020 2020 2020 7669 6577 626f            viewbo
-0000c4d0: 785f 6d6d 0d0a 2020 2020 2020 2020 2020  x_mm..          
-0000c4e0: 2020 6f72 206d 6178 280d 0a20 2020 2020    or max(..     
-0000c4f0: 2020 2020 2020 2020 2020 206e 702e 6162             np.ab
-0000c500: 7328 0d0a 2020 2020 2020 2020 2020 2020  s(..            
-0000c510: 2020 2020 2020 2020 280d 0a20 2020 2020          (..     
-0000c520: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c530: 2020 2073 656c 662e 6262 5f73 6869 6674     self.bb_shift
-0000c540: 5f76 6563 746f 722e 782c 0d0a 2020 2020  _vector.x,..    
-0000c550: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c560: 2020 2020 7365 6c66 2e62 625f 7368 6966      self.bb_shif
-0000c570: 745f 7665 6374 6f72 2e79 2c0d 0a20 2020  t_vector.y,..   
-0000c580: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c590: 2020 2020 2073 656c 662e 6262 5f73 6869       self.bb_shi
-0000c5a0: 6674 5f76 6563 746f 722e 7a2c 0d0a 2020  ft_vector.z,..  
-0000c5b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c5c0: 2020 290d 0a20 2020 2020 2020 2020 2020    )..           
-0000c5d0: 2020 2020 2029 0d0a 2020 2020 2020 2020       )..        
-0000c5e0: 2020 2020 290d 0a20 2020 2020 2020 2020      )..         
-0000c5f0: 2020 202b 2073 656c 662e 5f62 625f 6469     + self._bb_di
-0000c600: 616d 6574 6572 0d0a 2020 2020 2020 2020  ameter..        
-0000c610: 290d 0a20 2020 2020 2020 2061 7820 3d20  )..        ax = 
-0000c620: 706c 742e 6178 6573 2870 726f 6a65 6374  plt.axes(project
-0000c630: 696f 6e3d 2233 6422 290d 0a20 2020 2020  ion="3d")..     
-0000c640: 2020 205f 2c20 7265 6c65 7661 6e74 5f69     _, relevant_i
-0000c650: 6d61 6765 7320 3d20 7365 6c66 2e5f 6765  mages = self._ge
-0000c660: 745f 696d 6167 6573 280d 0a20 2020 2020  t_images(..     
-0000c670: 2020 2020 2020 2061 7869 733d 2841 7869         axis=(Axi
-0000c680: 732e 5245 4645 5245 4e43 452c 2041 7869  s.REFERENCE, Axi
-0000c690: 732e 4742 5f43 4f4d 424f 2c20 4178 6973  s.GB_COMBO, Axis
-0000c6a0: 2e43 4f4c 4c49 4d41 544f 522c 2041 7869  .COLLIMATOR, Axi
-0000c6b0: 732e 4741 4e54 5259 290d 0a20 2020 2020  s.GANTRY)..     
-0000c6c0: 2020 2029 0d0a 2020 2020 2020 2020 2320     )..        # 
-0000c6d0: 7765 2063 616e 2072 6570 7265 7365 6e74  we can represent
-0000c6e0: 2074 6865 2069 736f 2073 7068 6572 6520   the iso sphere 
-0000c6f0: 6173 2061 2042 4220 6f62 6a65 6374 3b20  as a BB object; 
-0000c700: 7468 6520 6e6f 6d69 6e61 6c20 6f62 6a65  the nominal obje
-0000c710: 6374 2069 736e 2774 2075 7365 642c 206a  ct isn't used, j
-0000c720: 7573 7420 7468 6520 4242 2073 697a 650d  ust the BB size.
-0000c730: 0a20 2020 2020 2020 2023 2074 6865 2072  .        # the r
-0000c740: 6179 206c 696e 6573 2061 7265 2077 6861  ay lines are wha
-0000c750: 7420 7765 2077 616e 7420 746f 2070 6c6f  t we want to plo
-0000c760: 7420 6173 2061 2073 7068 6572 650d 0a20  t as a sphere.. 
-0000c770: 2020 2020 2020 2069 736f 5f73 7068 6572         iso_spher
-0000c780: 6520 3d20 4242 280d 0a20 2020 2020 2020  e = BB(..       
-0000c790: 2020 2020 206e 6f6d 696e 616c 5f62 623d       nominal_bb=
-0000c7a0: 7b0d 0a20 2020 2020 2020 2020 2020 2020  {..             
-0000c7b0: 2020 2022 6f66 6673 6574 5f6c 6566 745f     "offset_left_
-0000c7c0: 6d6d 223a 2030 2c0d 0a20 2020 2020 2020  mm": 0,..       
-0000c7d0: 2020 2020 2020 2020 2022 6f66 6673 6574           "offset
-0000c7e0: 5f69 6e5f 6d6d 223a 2030 2c0d 0a20 2020  _in_mm": 0,..   
-0000c7f0: 2020 2020 2020 2020 2020 2020 2022 6f66               "of
-0000c800: 6673 6574 5f75 705f 6d6d 223a 2030 2c0d  fset_up_mm": 0,.
-0000c810: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000c820: 2022 6262 5f64 6961 6d65 7465 725f 6d6d   "bb_diameter_mm
-0000c830: 223a 2073 656c 662e 5f62 625f 6469 616d  ": self._bb_diam
-0000c840: 6574 6572 2c0d 0a20 2020 2020 2020 2020  eter,..         
-0000c850: 2020 207d 2c0d 0a20 2020 2020 2020 2020     },..         
-0000c860: 2020 2072 6179 5f6c 696e 6573 3d5b 696d     ray_lines=[im
-0000c870: 6167 652e 6361 785f 6c69 6e65 5f70 726f  age.cax_line_pro
-0000c880: 6a65 6374 696f 6e20 666f 7220 696d 6167  jection for imag
-0000c890: 6520 696e 2072 656c 6576 616e 745f 696d  e in relevant_im
-0000c8a0: 6167 6573 5d2c 0d0a 2020 2020 2020 2020  ages],..        
-0000c8b0: 290d 0a20 2020 2020 2020 2023 2070 6c6f  )..        # plo
-0000c8c0: 7420 7468 6520 782c 792c 7a20 6f72 6967  t the x,y,z orig
-0000c8d0: 696e 206c 696e 6573 0d0a 2020 2020 2020  in lines..      
-0000c8e0: 2020 785f 6c69 6e65 203d 204c 696e 6528    x_line = Line(
-0000c8f0: 506f 696e 7428 2d6c 696d 6974 2c20 302c  Point(-limit, 0,
-0000c900: 2030 292c 2050 6f69 6e74 286c 696d 6974   0), Point(limit
-0000c910: 2c20 302c 2030 2929 0d0a 2020 2020 2020  , 0, 0))..      
-0000c920: 2020 785f 6c69 6e65 2e70 6c6f 7432 6178    x_line.plot2ax
-0000c930: 6573 2861 782c 2063 6f6c 6f72 3d22 6772  es(ax, color="gr
-0000c940: 6565 6e22 2c20 616c 7068 613d 302e 3529  een", alpha=0.5)
-0000c950: 0d0a 2020 2020 2020 2020 795f 6c69 6e65  ..        y_line
-0000c960: 203d 204c 696e 6528 506f 696e 7428 302c   = Line(Point(0,
-0000c970: 202d 6c69 6d69 742c 2030 292c 2050 6f69   -limit, 0), Poi
-0000c980: 6e74 2830 2c20 6c69 6d69 742c 2030 2929  nt(0, limit, 0))
-0000c990: 0d0a 2020 2020 2020 2020 795f 6c69 6e65  ..        y_line
-0000c9a0: 2e70 6c6f 7432 6178 6573 2861 782c 2063  .plot2axes(ax, c
-0000c9b0: 6f6c 6f72 3d22 6772 6565 6e22 2c20 616c  olor="green", al
-0000c9c0: 7068 613d 302e 3529 0d0a 2020 2020 2020  pha=0.5)..      
-0000c9d0: 2020 7a5f 6c69 6e65 203d 204c 696e 6528    z_line = Line(
-0000c9e0: 506f 696e 7428 302c 2030 2c20 2d6c 696d  Point(0, 0, -lim
-0000c9f0: 6974 292c 2050 6f69 6e74 2830 2c20 302c  it), Point(0, 0,
-0000ca00: 206c 696d 6974 2929 0d0a 2020 2020 2020   limit))..      
-0000ca10: 2020 7a5f 6c69 6e65 2e70 6c6f 7432 6178    z_line.plot2ax
-0000ca20: 6573 280d 0a20 2020 2020 2020 2020 2020  es(..           
-0000ca30: 2061 782c 2063 6f6c 6f72 3d22 6772 6565   ax, color="gree
-0000ca40: 6e22 2c20 616c 7068 613d 302e 352c 206c  n", alpha=0.5, l
-0000ca50: 6162 656c 3d22 4465 7465 726d 696e 6564  abel="Determined
-0000ca60: 2069 736f 6365 6e74 6572 2028 782c 792c   isocenter (x,y,
-0000ca70: 7a29 220d 0a20 2020 2020 2020 2029 0d0a  z)"..        )..
-0000ca80: 2020 2020 2020 2020 6966 2070 6c6f 745f          if plot_
-0000ca90: 6262 3a0d 0a20 2020 2020 2020 2020 2020  bb:..           
-0000caa0: 2069 736f 5f73 7068 6572 652e 706c 6f74   iso_sphere.plot
-0000cab0: 5f6d 6561 7375 7265 6428 6178 2c20 636f  _measured(ax, co
-0000cac0: 6c6f 723d 2263 7961 6e22 2c20 616c 7068  lor="cyan", alph
-0000cad0: 613d 302e 3629 0d0a 2020 2020 2020 2020  a=0.6)..        
-0000cae0: 2020 2020 2320 6372 6561 7465 2061 6e20      # create an 
-0000caf0: 656d 7074 792c 2066 616b 6520 6c69 6e65  empty, fake line
-0000cb00: 2073 6f20 7765 2063 616e 2061 6464 2061   so we can add a
-0000cb10: 206c 6162 656c 2066 6f72 2074 6865 206c   label for the l
-0000cb20: 6567 656e 640d 0a20 2020 2020 2020 2020  egend..         
-0000cb30: 2020 2066 616b 655f 6c69 6e65 203d 204c     fake_line = L
-0000cb40: 696e 6528 506f 696e 7428 302c 2030 2c20  ine(Point(0, 0, 
-0000cb50: 3029 2c20 506f 696e 7428 302c 2030 2c20  0), Point(0, 0, 
-0000cb60: 3029 290d 0a20 2020 2020 2020 2020 2020  0))..           
-0000cb70: 2066 616b 655f 6c69 6e65 2e70 6c6f 7432   fake_line.plot2
-0000cb80: 6178 6573 2861 782c 2063 6f6c 6f72 3d22  axes(ax, color="
-0000cb90: 6379 616e 222c 206c 6162 656c 3d66 2242  cyan", label=f"B
-0000cba0: 4220 287b 7365 6c66 2e5f 6262 5f64 6961  B ({self._bb_dia
-0000cbb0: 6d65 7465 727d 6d6d 2922 290d 0a20 2020  meter}mm)")..   
-0000cbc0: 2020 2020 2069 6620 706c 6f74 5f69 736f       if plot_iso
-0000cbd0: 6365 6e74 6572 5f73 7068 6572 653a 0d0a  center_sphere:..
-0000cbe0: 2020 2020 2020 2020 2020 2020 782c 2079              x, y
-0000cbf0: 2c20 7a20 3d20 6372 6561 7465 5f73 7068  , z = create_sph
-0000cc00: 6572 655f 7375 7266 6163 6528 0d0a 2020  ere_surface(..  
-0000cc10: 2020 2020 2020 2020 2020 2020 2020 7261                ra
-0000cc20: 6469 7573 3d73 656c 662e 6761 6e74 7279  dius=self.gantry
-0000cc30: 5f63 6f6c 6c5f 6973 6f5f 7369 7a65 202f  _coll_iso_size /
-0000cc40: 2032 2c20 6365 6e74 6572 3d50 6f69 6e74   2, center=Point
-0000cc50: 2830 2c20 302c 2030 290d 0a20 2020 2020  (0, 0, 0)..     
-0000cc60: 2020 2020 2020 2029 0d0a 2020 2020 2020         )..      
-0000cc70: 2020 2020 2020 6178 2e70 6c6f 745f 7375        ax.plot_su
-0000cc80: 7266 6163 6528 782c 2079 2c20 7a2c 2061  rface(x, y, z, a
-0000cc90: 6c70 6861 3d30 2e33 2c20 636f 6c6f 723d  lpha=0.3, color=
-0000cca0: 226d 6167 656e 7461 2229 0d0a 2020 2020  "magenta")..    
-0000ccb0: 2020 2020 2020 2020 2320 6372 6561 7465          # create
-0000ccc0: 2061 6e20 656d 7074 792c 2066 616b 6520   an empty, fake 
-0000ccd0: 6c69 6e65 2073 6f20 7765 2063 616e 2061  line so we can a
-0000cce0: 6464 2061 206c 6162 656c 2066 6f72 2074  dd a label for t
-0000ccf0: 6865 206c 6567 656e 640d 0a20 2020 2020  he legend..     
-0000cd00: 2020 2020 2020 2066 616b 655f 6c69 6e65         fake_line
-0000cd10: 203d 204c 696e 6528 506f 696e 7428 302c   = Line(Point(0,
-0000cd20: 2030 2c20 3029 2c20 506f 696e 7428 302c   0, 0), Point(0,
-0000cd30: 2030 2c20 3029 290d 0a20 2020 2020 2020   0, 0))..       
-0000cd40: 2020 2020 2066 616b 655f 6c69 6e65 2e70       fake_line.p
-0000cd50: 6c6f 7432 6178 6573 280d 0a20 2020 2020  lot2axes(..     
-0000cd60: 2020 2020 2020 2020 2020 2061 782c 0d0a             ax,..
-0000cd70: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000cd80: 636f 6c6f 723d 226d 6167 656e 7461 222c  color="magenta",
-0000cd90: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-0000cda0: 2020 6c61 6265 6c3d 6622 4761 6e74 7279    label=f"Gantry
-0000cdb0: 202b 2043 6f6c 6c20 4973 6f73 7068 6572   + Coll Isospher
-0000cdc0: 6520 287b 7365 6c66 2e67 616e 7472 795f  e ({self.gantry_
-0000cdd0: 636f 6c6c 5f69 736f 5f73 697a 653a 332e  coll_iso_size:3.
-0000cde0: 3266 7d6d 6d29 222c 0d0a 2020 2020 2020  2f}mm)",..      
-0000cdf0: 2020 2020 2020 290d 0a20 2020 2020 2020        )..       
-0000ce00: 2069 6620 706c 6f74 5f63 6f75 6368 5f69   if plot_couch_i
-0000ce10: 736f 3a0d 0a20 2020 2020 2020 2020 2020  so:..           
-0000ce20: 2063 6972 636c 6520 3d20 706c 742e 4369   circle = plt.Ci
-0000ce30: 7263 6c65 280d 0a20 2020 2020 2020 2020  rcle(..         
-0000ce40: 2020 2020 2020 2028 302c 2030 292c 0d0a         (0, 0),..
-0000ce50: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000ce60: 7261 6469 7573 3d73 656c 662e 636f 7563  radius=self.couc
-0000ce70: 685f 6973 6f5f 7369 7a65 202f 2032 2c0d  h_iso_size / 2,.
-0000ce80: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000ce90: 2066 696c 6c3d 5472 7565 2c0d 0a20 2020   fill=True,..   
-0000cea0: 2020 2020 2020 2020 2020 2020 2063 6f6c               col
-0000ceb0: 6f72 3d22 7965 6c6c 6f77 222c 0d0a 2020  or="yellow",..  
-0000cec0: 2020 2020 2020 2020 2020 2020 2020 616c                al
-0000ced0: 7068 613d 302e 342c 0d0a 2020 2020 2020  pha=0.4,..      
-0000cee0: 2020 2020 2020 2020 2020 6c61 6265 6c3d            label=
-0000cef0: 6622 436f 7563 682d 6f6e 6c79 2069 736f  f"Couch-only iso
-0000cf00: 2028 7b73 656c 662e 636f 7563 685f 6973   ({self.couch_is
-0000cf10: 6f5f 7369 7a65 3a33 2e32 667d 6d6d 2922  o_size:3.2f}mm)"
-0000cf20: 2c0d 0a20 2020 2020 2020 2020 2020 2029  ,..            )
-0000cf30: 0d0a 2020 2020 2020 2020 2020 2020 6178  ..            ax
-0000cf40: 2e61 6464 5f70 6174 6368 2863 6972 636c  .add_patch(circl
-0000cf50: 6529 0d0a 2020 2020 2020 2020 2020 2020  e)..            
-0000cf60: 6172 7433 642e 7061 7468 7061 7463 685f  art3d.pathpatch_
-0000cf70: 3264 5f74 6f5f 3364 2863 6972 636c 652c  2d_to_3d(circle,
-0000cf80: 207a 3d30 2c20 7a64 6972 3d22 7a22 290d   z=0, zdir="z").
-0000cf90: 0a20 2020 2020 2020 2069 6620 706c 6f74  .        if plot
-0000cfa0: 5f63 6f6c 6c5f 6973 6f3a 0d0a 2020 2020  _coll_iso:..    
-0000cfb0: 2020 2020 2020 2020 6369 7263 6c65 203d          circle =
-0000cfc0: 2070 6c74 2e43 6972 636c 6528 0d0a 2020   plt.Circle(..  
-0000cfd0: 2020 2020 2020 2020 2020 2020 2020 2830                (0
-0000cfe0: 2c20 3029 2c0d 0a20 2020 2020 2020 2020  , 0),..         
-0000cff0: 2020 2020 2020 2072 6164 6975 733d 7365         radius=se
-0000d000: 6c66 2e63 6f6c 6c69 6d61 746f 725f 6973  lf.collimator_is
-0000d010: 6f5f 7369 7a65 202f 2032 2c0d 0a20 2020  o_size / 2,..   
-0000d020: 2020 2020 2020 2020 2020 2020 2066 696c               fil
-0000d030: 6c3d 5472 7565 2c0d 0a20 2020 2020 2020  l=True,..       
-0000d040: 2020 2020 2020 2020 2063 6f6c 6f72 3d22           color="
-0000d050: 626c 7565 222c 0d0a 2020 2020 2020 2020  blue",..        
-0000d060: 2020 2020 2020 2020 616c 7068 613d 302e          alpha=0.
-0000d070: 342c 0d0a 2020 2020 2020 2020 2020 2020  4,..            
-0000d080: 2020 2020 6c61 6265 6c3d 6622 436f 6c6c      label=f"Coll
-0000d090: 696d 6174 6f72 2d6f 6e6c 7920 6973 6f20  imator-only iso 
-0000d0a0: 287b 7365 6c66 2e63 6f6c 6c69 6d61 746f  ({self.collimato
-0000d0b0: 725f 6973 6f5f 7369 7a65 3a33 2e32 667d  r_iso_size:3.2f}
-0000d0c0: 6d6d 2922 2c0d 0a20 2020 2020 2020 2020  mm)",..         
-0000d0d0: 2020 2029 0d0a 2020 2020 2020 2020 2020     )..          
-0000d0e0: 2020 6178 2e61 6464 5f70 6174 6368 2863    ax.add_patch(c
-0000d0f0: 6972 636c 6529 0d0a 2020 2020 2020 2020  ircle)..        
-0000d100: 2020 2020 6172 7433 642e 7061 7468 7061      art3d.pathpa
-0000d110: 7463 685f 3264 5f74 6f5f 3364 2863 6972  tch_2d_to_3d(cir
-0000d120: 636c 652c 207a 3d30 2c20 7a64 6972 3d22  cle, z=0, zdir="
-0000d130: 7822 290d 0a20 2020 2020 2020 2069 6620  x")..        if 
-0000d140: 7368 6f77 5f6c 6567 656e 643a 0d0a 2020  show_legend:..  
-0000d150: 2020 2020 2020 2020 2020 6178 2e6c 6567            ax.leg
-0000d160: 656e 6428 290d 0a20 2020 2020 2020 2023  end()..        #
-0000d170: 2073 6574 2074 6865 206c 696d 6974 7320   set the limits 
-0000d180: 6f66 2074 6865 2033 4420 706c 6f74 3b20  of the 3D plot; 
-0000d190: 7468 6579 206d 7573 7420 6265 2074 6865  they must be the
-0000d1a0: 2073 616d 6520 696e 2061 6c6c 2061 7865   same in all axe
-0000d1b0: 7320 666f 7220 6571 7561 6c20 6173 7065  s for equal aspe
-0000d1c0: 6374 2072 6174 696f 0d0a 2020 2020 2020  ct ratio..      
-0000d1d0: 2020 6178 2e73 6574 280d 0a20 2020 2020    ax.set(..     
-0000d1e0: 2020 2020 2020 2078 6c61 6265 6c3d 2258         xlabel="X
-0000d1f0: 2028 6d6d 292c 2052 6967 6874 2028 2b29   (mm), Right (+)
-0000d200: 222c 0d0a 2020 2020 2020 2020 2020 2020  ",..            
-0000d210: 796c 6162 656c 3d22 5920 286d 6d29 2c20  ylabel="Y (mm), 
-0000d220: 496e 2028 2b29 222c 0d0a 2020 2020 2020  In (+)",..      
-0000d230: 2020 2020 2020 7a6c 6162 656c 3d22 5a20        zlabel="Z 
-0000d240: 286d 6d29 2c20 5570 2028 2b29 222c 0d0a  (mm), Up (+)",..
-0000d250: 2020 2020 2020 2020 2020 2020 7469 746c              titl
-0000d260: 653d 2249 736f 6365 6e74 6572 2056 6973  e="Isocenter Vis
-0000d270: 7561 6c69 7a61 7469 6f6e 222c 0d0a 2020  ualization",..  
-0000d280: 2020 2020 2020 2020 2020 796c 696d 3d5b            ylim=[
-0000d290: 2d6c 696d 6974 2c20 6c69 6d69 745d 2c0d  -limit, limit],.
-0000d2a0: 0a20 2020 2020 2020 2020 2020 2078 6c69  .            xli
-0000d2b0: 6d3d 5b2d 6c69 6d69 742c 206c 696d 6974  m=[-limit, limit
-0000d2c0: 5d2c 0d0a 2020 2020 2020 2020 2020 2020  ],..            
-0000d2d0: 7a6c 696d 3d5b 2d6c 696d 6974 2c20 6c69  zlim=[-limit, li
-0000d2e0: 6d69 745d 2c0d 0a20 2020 2020 2020 2029  mit],..        )
-0000d2f0: 0d0a 0d0a 2020 2020 2020 2020 6966 2073  ....        if s
-0000d300: 686f 773a 0d0a 2020 2020 2020 2020 2020  how:..          
-0000d310: 2020 706c 742e 7368 6f77 2829 0d0a 0d0a    plt.show()....
-0000d320: 2020 2020 6465 6620 706c 6f74 5f69 6d61      def plot_ima
-0000d330: 6765 7328 0d0a 2020 2020 2020 2020 7365  ges(..        se
-0000d340: 6c66 2c0d 0a20 2020 2020 2020 2061 7869  lf,..        axi
-0000d350: 733a 2041 7869 7320 3d20 4178 6973 2e47  s: Axis = Axis.G
-0000d360: 414e 5452 592c 0d0a 2020 2020 2020 2020  ANTRY,..        
-0000d370: 7368 6f77 3a20 626f 6f6c 203d 2054 7275  show: bool = Tru
-0000d380: 652c 0d0a 2020 2020 2020 2020 7370 6c69  e,..        spli
-0000d390: 743a 2062 6f6f 6c20 3d20 4661 6c73 652c  t: bool = False,
-0000d3a0: 0d0a 2020 2020 2020 2020 2a2a 6b77 6172  ..        **kwar
-0000d3b0: 6773 2c0d 0a20 2020 2029 202d 3e20 286c  gs,..    ) -> (l
-0000d3c0: 6973 745b 706c 742e 4669 6775 7265 5d2c  ist[plt.Figure],
-0000d3d0: 206c 6973 745b 7374 725d 293a 0d0a 2020   list[str]):..  
-0000d3e0: 2020 2020 2020 2222 2250 6c6f 7420 6120        """Plot a 
-0000d3f0: 6772 6964 206f 6620 616c 6c20 7468 6520  grid of all the 
-0000d400: 696d 6167 6573 2061 6371 7569 7265 642e  images acquired.
-0000d410: 0d0a 0d0a 2020 2020 2020 2020 466f 7572  ....        Four
-0000d420: 2063 6f6c 756d 6e73 2061 7265 2070 6c6f   columns are plo
-0000d430: 7474 6564 2077 6974 6820 7468 6520 7469  tted with the ti
-0000d440: 746c 6573 2073 686f 7769 6e67 2077 6869  tles showing whi
-0000d450: 6368 2061 7869 7320 7468 6174 2063 6f6c  ch axis that col
-0000d460: 756d 6e20 7265 7072 6573 656e 7473 2e0d  umn represents..
-0000d470: 0a0d 0a20 2020 2020 2020 2050 6172 616d  ...        Param
-0000d480: 6574 6572 730d 0a20 2020 2020 2020 202d  eters..        -
-0000d490: 2d2d 2d2d 2d2d 2d2d 2d0d 0a20 2020 2020  ---------..     
-0000d4a0: 2020 2061 7869 7320 3a20 7b27 4761 6e74     axis : {'Gant
-0000d4b0: 7279 272c 2027 436f 6c6c 696d 6174 6f72  ry', 'Collimator
-0000d4c0: 272c 2027 436f 7563 6827 2c20 2747 4220  ', 'Couch', 'GB 
-0000d4d0: 436f 6d62 6f27 2c20 2747 4250 2043 6f6d  Combo', 'GBP Com
-0000d4e0: 626f 272c 2027 416c 6c27 7d0d 0a20 2020  bo', 'All'}..   
-0000d4f0: 2020 2020 2020 2020 2054 6865 2061 7869           The axi
-0000d500: 7320 746f 2070 6c6f 742e 0d0a 2020 2020  s to plot...    
-0000d510: 2020 2020 7368 6f77 203a 2062 6f6f 6c0d      show : bool.
-0000d520: 0a20 2020 2020 2020 2020 2020 2057 6865  .            Whe
-0000d530: 7468 6572 2074 6f20 7368 6f77 2074 6865  ther to show the
-0000d540: 2069 6d61 6765 2e0d 0a20 2020 2020 2020   image...       
-0000d550: 2073 706c 6974 203a 2062 6f6f 6c0d 0a20   split : bool.. 
-0000d560: 2020 2020 2020 2020 2020 2057 6865 7468             Wheth
-0000d570: 6572 2074 6f20 7368 6f77 2f70 6c6f 7420  er to show/plot 
-0000d580: 7468 6520 696d 6167 6573 2069 6e64 6976  the images indiv
-0000d590: 6964 7561 6c6c 7920 6f72 2061 7320 6f6e  idually or as on
-0000d5a0: 6520 6c61 7267 6520 6669 6775 7265 2e0d  e large figure..
-0000d5b0: 0a20 2020 2020 2020 2022 2222 0d0a 2020  .        """..  
-0000d5c0: 2020 2020 2020 6178 6973 203d 2063 6f6e        axis = con
-0000d5d0: 7665 7274 5f74 6f5f 656e 756d 2861 7869  vert_to_enum(axi
-0000d5e0: 732c 2041 7869 7329 0d0a 2020 2020 2020  s, Axis)..      
-0000d5f0: 2020 6966 206e 6f74 2073 656c 662e 5f69    if not self._i
-0000d600: 735f 616e 616c 797a 6564 3a0d 0a20 2020  s_analyzed:..   
-0000d610: 2020 2020 2020 2020 2072 6169 7365 2056           raise V
-0000d620: 616c 7565 4572 726f 7228 2254 6865 2073  alueError("The s
-0000d630: 6574 2069 7320 6e6f 7420 616e 616c 797a  et is not analyz
-0000d640: 6564 2e20 5573 6520 2e61 6e61 6c79 7a65  ed. Use .analyze
-0000d650: 2829 2066 6972 7374 2e22 290d 0a0d 0a20  () first.").... 
-0000d660: 2020 2020 2020 2023 2067 6574 2061 7869         # get axi
-0000d670: 7320 696d 6167 6573 0d0a 2020 2020 2020  s images..      
-0000d680: 2020 6966 2061 7869 7320 3d3d 2041 7869    if axis == Axi
-0000d690: 732e 4741 4e54 5259 3a0d 0a20 2020 2020  s.GANTRY:..     
-0000d6a0: 2020 2020 2020 2069 6d61 6765 7320 3d20         images = 
-0000d6b0: 5b0d 0a20 2020 2020 2020 2020 2020 2020  [..             
-0000d6c0: 2020 2069 6d61 6765 0d0a 2020 2020 2020     image..      
-0000d6d0: 2020 2020 2020 2020 2020 666f 7220 696d            for im
-0000d6e0: 6167 6520 696e 2073 656c 662e 696d 6167  age in self.imag
-0000d6f0: 6573 0d0a 2020 2020 2020 2020 2020 2020  es..            
-0000d700: 2020 2020 6966 2069 6d61 6765 2e76 6172      if image.var
-0000d710: 6961 626c 655f 6178 6973 2069 6e20 2841  iable_axis in (A
-0000d720: 7869 732e 4741 4e54 5259 2c20 4178 6973  xis.GANTRY, Axis
-0000d730: 2e52 4546 4552 454e 4345 290d 0a20 2020  .REFERENCE)..   
-0000d740: 2020 2020 2020 2020 205d 0d0a 2020 2020           ]..    
-0000d750: 2020 2020 656c 6966 2061 7869 7320 3d3d      elif axis ==
-0000d760: 2041 7869 732e 434f 4c4c 494d 4154 4f52   Axis.COLLIMATOR
-0000d770: 3a0d 0a20 2020 2020 2020 2020 2020 2069  :..            i
-0000d780: 6d61 6765 7320 3d20 5b0d 0a20 2020 2020  mages = [..     
-0000d790: 2020 2020 2020 2020 2020 2069 6d61 6765             image
-0000d7a0: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-0000d7b0: 2020 666f 7220 696d 6167 6520 696e 2073    for image in s
-0000d7c0: 656c 662e 696d 6167 6573 0d0a 2020 2020  elf.images..    
-0000d7d0: 2020 2020 2020 2020 2020 2020 6966 2069              if i
-0000d7e0: 6d61 6765 2e76 6172 6961 626c 655f 6178  mage.variable_ax
-0000d7f0: 6973 2069 6e20 2841 7869 732e 434f 4c4c  is in (Axis.COLL
-0000d800: 494d 4154 4f52 2c20 4178 6973 2e52 4546  IMATOR, Axis.REF
-0000d810: 4552 454e 4345 290d 0a20 2020 2020 2020  ERENCE)..       
-0000d820: 2020 2020 205d 0d0a 2020 2020 2020 2020       ]..        
-0000d830: 656c 6966 2061 7869 7320 3d3d 2041 7869  elif axis == Axi
-0000d840: 732e 434f 5543 483a 0d0a 2020 2020 2020  s.COUCH:..      
-0000d850: 2020 2020 2020 696d 6167 6573 203d 205b        images = [
-0000d860: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-0000d870: 2020 696d 6167 650d 0a20 2020 2020 2020    image..       
-0000d880: 2020 2020 2020 2020 2066 6f72 2069 6d61           for ima
-0000d890: 6765 2069 6e20 7365 6c66 2e69 6d61 6765  ge in self.image
-0000d8a0: 730d 0a20 2020 2020 2020 2020 2020 2020  s..             
-0000d8b0: 2020 2069 6620 696d 6167 652e 7661 7269     if image.vari
-0000d8c0: 6162 6c65 5f61 7869 7320 696e 2028 4178  able_axis in (Ax
-0000d8d0: 6973 2e43 4f55 4348 2c20 4178 6973 2e52  is.COUCH, Axis.R
-0000d8e0: 4546 4552 454e 4345 290d 0a20 2020 2020  EFERENCE)..     
-0000d8f0: 2020 2020 2020 205d 0d0a 2020 2020 2020         ]..      
-0000d900: 2020 656c 6966 2061 7869 7320 3d3d 2041    elif axis == A
-0000d910: 7869 732e 4742 5f43 4f4d 424f 3a0d 0a20  xis.GB_COMBO:.. 
-0000d920: 2020 2020 2020 2020 2020 2069 6d61 6765             image
-0000d930: 7320 3d20 5b0d 0a20 2020 2020 2020 2020  s = [..         
-0000d940: 2020 2020 2020 2069 6d61 6765 0d0a 2020         image..  
-0000d950: 2020 2020 2020 2020 2020 2020 2020 666f                fo
-0000d960: 7220 696d 6167 6520 696e 2073 656c 662e  r image in self.
-0000d970: 696d 6167 6573 0d0a 2020 2020 2020 2020  images..        
-0000d980: 2020 2020 2020 2020 6966 2069 6d61 6765          if image
-0000d990: 2e76 6172 6961 626c 655f 6178 6973 0d0a  .variable_axis..
-0000d9a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000d9b0: 696e 2028 4178 6973 2e47 425f 434f 4d42  in (Axis.GB_COMB
-0000d9c0: 4f2c 2041 7869 732e 4741 4e54 5259 2c20  O, Axis.GANTRY, 
-0000d9d0: 4178 6973 2e43 4f4c 4c49 4d41 544f 522c  Axis.COLLIMATOR,
-0000d9e0: 2041 7869 732e 5245 4645 5245 4e43 4529   Axis.REFERENCE)
-0000d9f0: 0d0a 2020 2020 2020 2020 2020 2020 5d0d  ..            ].
-0000da00: 0a20 2020 2020 2020 2065 6c69 6620 6178  .        elif ax
-0000da10: 6973 203d 3d20 4178 6973 2e47 4250 5f43  is == Axis.GBP_C
-0000da20: 4f4d 424f 3a0d 0a20 2020 2020 2020 2020  OMBO:..         
-0000da30: 2020 2069 6d61 6765 7320 3d20 7365 6c66     images = self
-0000da40: 2e69 6d61 6765 730d 0a0d 0a20 2020 2020  .images....     
-0000da50: 2020 2023 2073 6574 2074 6865 2066 6967     # set the fig
-0000da60: 7369 7a65 2069 6620 6974 2077 6173 6e27  size if it wasn'
-0000da70: 7420 7061 7373 6564 0d0a 2020 2020 2020  t passed..      
-0000da80: 2020 6966 206e 6f74 206b 7761 7267 732e    if not kwargs.
-0000da90: 6765 7428 2266 6967 7369 7a65 2229 3a0d  get("figsize"):.
-0000daa0: 0a20 2020 2020 2020 2020 2020 2064 7069  .            dpi
-0000dab0: 203d 2037 320d 0a20 2020 2020 2020 2020   = 72..         
-0000dac0: 2020 2077 6964 7468 5f70 7820 3d20 3130     width_px = 10
-0000dad0: 3830 0d0a 2020 2020 2020 2020 2020 2020  80..            
-0000dae0: 7769 6474 685f 696e 203d 2077 6964 7468  width_in = width
-0000daf0: 5f70 7820 2f20 6470 690d 0a20 2020 2020  _px / dpi..     
-0000db00: 2020 2020 2020 2069 6620 6e6f 7420 7370         if not sp
-0000db10: 6c69 743a 0d0a 2020 2020 2020 2020 2020  lit:..          
-0000db20: 2020 2020 2020 6d61 785f 6e75 6d5f 696d        max_num_im
-0000db30: 6167 6573 203d 206d 6174 682e 6365 696c  ages = math.ceil
-0000db40: 286c 656e 2869 6d61 6765 7329 202f 2034  (len(images) / 4
-0000db50: 290d 0a20 2020 2020 2020 2020 2020 2020  )..             
-0000db60: 2020 2068 6569 6768 745f 696e 203d 2028     height_in = (
-0000db70: 7769 6474 685f 696e 202f 2034 2920 2a20  width_in / 4) * 
-0000db80: 6d61 785f 6e75 6d5f 696d 6167 6573 0d0a  max_num_images..
-0000db90: 2020 2020 2020 2020 2020 2020 656c 7365              else
-0000dba0: 3a0d 0a20 2020 2020 2020 2020 2020 2020  :..             
-0000dbb0: 2020 2068 6569 6768 745f 696e 203d 2077     height_in = w
-0000dbc0: 6964 7468 5f69 6e20 3d20 330d 0a20 2020  idth_in = 3..   
-0000dbd0: 2020 2020 2020 2020 206b 7761 7267 735b           kwargs[
-0000dbe0: 2266 6967 7369 7a65 225d 203d 2028 7769  "figsize"] = (wi
-0000dbf0: 6474 685f 696e 2c20 6865 6967 6874 5f69  dth_in, height_i
-0000dc00: 6e29 0d0a 0d0a 2020 2020 2020 2020 6669  n)....        fi
-0000dc10: 6773 203d 205b 5d0d 0a20 2020 2020 2020  gs = []..       
-0000dc20: 206e 616d 6573 203d 205b 5d0d 0a20 2020   names = []..   
-0000dc30: 2020 2020 2023 2063 7265 6174 6520 706c       # create pl
-0000dc40: 6f74 730d 0a20 2020 2020 2020 2069 6620  ots..        if 
-0000dc50: 6e6f 7420 7370 6c69 743a 0d0a 2020 2020  not split:..    
-0000dc60: 2020 2020 2020 2020 6669 672c 2061 7865          fig, axe
-0000dc70: 7320 3d20 706c 742e 7375 6270 6c6f 7473  s = plt.subplots
-0000dc80: 286e 726f 7773 3d6d 6178 5f6e 756d 5f69  (nrows=max_num_i
-0000dc90: 6d61 6765 732c 206e 636f 6c73 3d34 2c20  mages, ncols=4, 
-0000dca0: 2a2a 6b77 6172 6773 290d 0a20 2020 2020  **kwargs)..     
-0000dcb0: 2020 2020 2020 2066 6f72 206d 706c 5f61         for mpl_a
-0000dcc0: 7869 732c 2077 6c5f 696d 6167 6520 696e  xis, wl_image in
-0000dcd0: 207a 6970 5f6c 6f6e 6765 7374 2861 7865   zip_longest(axe
-0000dce0: 732e 666c 6174 7465 6e28 292c 2069 6d61  s.flatten(), ima
-0000dcf0: 6765 7329 3a0d 0a20 2020 2020 2020 2020  ges):..         
-0000dd00: 2020 2020 2020 2070 6c6f 745f 696d 6167         plot_imag
-0000dd10: 6528 776c 5f69 6d61 6765 2c20 6d70 6c5f  e(wl_image, mpl_
-0000dd20: 6178 6973 290d 0a0d 0a20 2020 2020 2020  axis)....       
-0000dd30: 2020 2020 2023 2073 6574 2074 6974 6c65       # set title
-0000dd40: 730d 0a20 2020 2020 2020 2020 2020 2066  s..            f
-0000dd50: 6967 2e73 7570 7469 746c 6528 6622 7b61  ig.suptitle(f"{a
-0000dd60: 7869 732e 7661 6c75 657d 2069 6d61 6765  xis.value} image
-0000dd70: 7322 2c20 666f 6e74 7369 7a65 3d31 342c  s", fontsize=14,
-0000dd80: 2079 3d31 290d 0a20 2020 2020 2020 2020   y=1)..         
-0000dd90: 2020 2066 6967 2e74 6967 6874 5f6c 6179     fig.tight_lay
-0000dda0: 6f75 7428 290d 0a20 2020 2020 2020 2020  out()..         
-0000ddb0: 2020 2066 6967 732e 6170 7065 6e64 2866     figs.append(f
-0000ddc0: 6967 290d 0a20 2020 2020 2020 2020 2020  ig)..           
-0000ddd0: 206e 616d 6573 2e61 7070 656e 6428 2269   names.append("i
-0000dde0: 6d61 6765 2229 0d0a 2020 2020 2020 2020  mage")..        
-0000ddf0: 656c 7365 3a0d 0a20 2020 2020 2020 2020  else:..         
-0000de00: 2020 2066 6f72 2077 6c5f 696d 6167 6520     for wl_image 
-0000de10: 696e 2069 6d61 6765 733a 0d0a 2020 2020  in images:..    
-0000de20: 2020 2020 2020 2020 2020 2020 6669 672c              fig,
-0000de30: 2061 7865 7320 3d20 706c 742e 7375 6270   axes = plt.subp
-0000de40: 6c6f 7473 282a 2a6b 7761 7267 7329 0d0a  lots(**kwargs)..
-0000de50: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000de60: 706c 6f74 5f69 6d61 6765 2877 6c5f 696d  plot_image(wl_im
-0000de70: 6167 652c 2061 7865 7329 0d0a 2020 2020  age, axes)..    
-0000de80: 2020 2020 2020 2020 2020 2020 6669 6773              figs
-0000de90: 2e61 7070 656e 6428 6669 6729 0d0a 2020  .append(fig)..  
-0000dea0: 2020 2020 2020 2020 2020 2020 2020 6e61                na
-0000deb0: 6d65 732e 6170 7065 6e64 2873 7472 2877  mes.append(str(w
-0000dec0: 6c5f 696d 6167 6529 290d 0a0d 0a20 2020  l_image))....   
-0000ded0: 2020 2020 2069 6620 7368 6f77 3a0d 0a20       if show:.. 
-0000dee0: 2020 2020 2020 2020 2020 2070 6c74 2e73             plt.s
-0000def0: 686f 7728 290d 0a0d 0a20 2020 2020 2020  how()....       
-0000df00: 2072 6574 7572 6e20 6669 6773 2c20 6e61   return figs, na
-0000df10: 6d65 730d 0a0d 0a20 2020 2064 6566 2073  mes....    def s
-0000df20: 6176 655f 696d 6167 6573 280d 0a20 2020  ave_images(..   
-0000df30: 2020 2020 2073 656c 662c 2066 696c 656e       self, filen
-0000df40: 616d 653a 2073 7472 207c 2042 696e 6172  ame: str | Binar
-0000df50: 7949 4f2c 2061 7869 733a 2041 7869 7320  yIO, axis: Axis 
-0000df60: 3d20 4178 6973 2e47 414e 5452 592c 202a  = Axis.GANTRY, *
-0000df70: 2a6b 7761 7267 730d 0a20 2020 2029 202d  *kwargs..    ) -
-0000df80: 3e20 4e6f 6e65 3a0d 0a20 2020 2020 2020  > None:..       
-0000df90: 2022 2222 5361 7665 2074 6865 2066 6967   """Save the fig
-0000dfa0: 7572 6520 6f66 2060 706c 6f74 5f69 6d61  ure of `plot_ima
-0000dfb0: 6765 7328 2960 2074 6f20 6669 6c65 2e20  ges()` to file. 
-0000dfc0: 4b65 7977 6f72 6420 6172 6775 6d65 6e74  Keyword argument
-0000dfd0: 7320 6172 6520 7061 7373 6564 2074 6f20  s are passed to 
-0000dfe0: 606d 6174 706c 6f74 6c69 622e 7079 706c  `matplotlib.pypl
-0000dff0: 6f74 2e73 6176 6566 6967 2829 602e 0d0a  ot.savefig()`...
-0000e000: 0d0a 2020 2020 2020 2020 5061 7261 6d65  ..        Parame
-0000e010: 7465 7273 0d0a 2020 2020 2020 2020 2d2d  ters..        --
-0000e020: 2d2d 2d2d 2d2d 2d2d 0d0a 2020 2020 2020  --------..      
-0000e030: 2020 6669 6c65 6e61 6d65 203a 2073 7472    filename : str
-0000e040: 0d0a 2020 2020 2020 2020 2020 2020 5468  ..            Th
-0000e050: 6520 6e61 6d65 206f 6620 7468 6520 6669  e name of the fi
-0000e060: 6c65 2074 6f20 7361 7665 2074 6f2e 0d0a  le to save to...
-0000e070: 2020 2020 2020 2020 6178 6973 0d0a 2020          axis..  
-0000e080: 2020 2020 2020 2020 2020 5468 6520 6178            The ax
-0000e090: 6973 2074 6f20 7361 7665 2e0d 0a20 2020  is to save...   
-0000e0a0: 2020 2020 2022 2222 0d0a 2020 2020 2020       """..      
-0000e0b0: 2020 7365 6c66 2e70 6c6f 745f 696d 6167    self.plot_imag
-0000e0c0: 6573 2861 7869 733d 6178 6973 2c20 7368  es(axis=axis, sh
-0000e0d0: 6f77 3d46 616c 7365 290d 0a20 2020 2020  ow=False)..     
-0000e0e0: 2020 2070 6c74 2e73 6176 6566 6967 2866     plt.savefig(f
-0000e0f0: 696c 656e 616d 652c 202a 2a6b 7761 7267  ilename, **kwarg
-0000e100: 7329 0d0a 0d0a 2020 2020 6465 6620 7361  s)....    def sa
-0000e110: 7665 5f69 6d61 6765 735f 746f 5f73 7472  ve_images_to_str
-0000e120: 6561 6d28 7365 6c66 2c20 2a2a 6b77 6172  eam(self, **kwar
-0000e130: 6773 2920 2d3e 2064 6963 745b 7374 722c  gs) -> dict[str,
-0000e140: 2069 6f2e 4279 7465 7349 4f5d 3a0d 0a20   io.BytesIO]:.. 
-0000e150: 2020 2020 2020 2022 2222 5361 7665 2074         """Save t
-0000e160: 6865 2069 6e64 6976 6964 7561 6c20 696d  he individual im
-0000e170: 6167 6520 706c 6f74 7320 746f 2073 7472  age plots to str
-0000e180: 6561 6d22 2222 0d0a 2020 2020 2020 2020  eam"""..        
-0000e190: 6669 6773 2c20 6e61 6d65 7320 3d20 7365  figs, names = se
-0000e1a0: 6c66 2e70 6c6f 745f 696d 6167 6573 280d  lf.plot_images(.
-0000e1b0: 0a20 2020 2020 2020 2020 2020 2061 7869  .            axi
-0000e1c0: 733d 4178 6973 2e47 4250 5f43 4f4d 424f  s=Axis.GBP_COMBO
-0000e1d0: 2c20 7368 6f77 3d46 616c 7365 2c20 7370  , show=False, sp
-0000e1e0: 6c69 743d 5472 7565 0d0a 2020 2020 2020  lit=True..      
-0000e1f0: 2020 2920 2023 2061 6c6c 2069 6d61 6765    )  # all image
-0000e200: 730d 0a20 2020 2020 2020 2073 7472 6561  s..        strea
-0000e210: 6d73 203d 205b 696f 2e42 7974 6573 494f  ms = [io.BytesIO
-0000e220: 2829 2066 6f72 205f 2069 6e20 6669 6773  () for _ in figs
-0000e230: 5d0d 0a20 2020 2020 2020 2066 6f72 2066  ]..        for f
-0000e240: 6967 2c20 7374 7265 616d 2069 6e20 7a69  ig, stream in zi
-0000e250: 7028 6669 6773 2c20 7374 7265 616d 7329  p(figs, streams)
-0000e260: 3a0d 0a20 2020 2020 2020 2020 2020 2066  :..            f
-0000e270: 6967 2e73 6176 6566 6967 2873 7472 6561  ig.savefig(strea
-0000e280: 6d2c 202a 2a6b 7761 7267 7329 0d0a 2020  m, **kwargs)..  
-0000e290: 2020 2020 2020 7265 7475 726e 207b 6e61        return {na
-0000e2a0: 6d65 3a20 7374 7265 616d 2066 6f72 206e  me: stream for n
-0000e2b0: 616d 652c 2073 7472 6561 6d20 696e 207a  ame, stream in z
-0000e2c0: 6970 286e 616d 6573 2c20 7374 7265 616d  ip(names, stream
-0000e2d0: 7329 7d0d 0a0d 0a20 2020 2064 6566 2070  s)}....    def p
-0000e2e0: 6c6f 745f 7375 6d6d 6172 7928 7365 6c66  lot_summary(self
-0000e2f0: 2c20 7368 6f77 3a20 626f 6f6c 203d 2054  , show: bool = T
-0000e300: 7275 652c 2066 6967 5f73 697a 653a 2074  rue, fig_size: t
-0000e310: 7570 6c65 207c 204e 6f6e 6520 3d20 4e6f  uple | None = No
-0000e320: 6e65 2920 2d3e 204e 6f6e 653a 0d0a 2020  ne) -> None:..  
-0000e330: 2020 2020 2020 2222 2250 6c6f 7420 6120        """Plot a 
-0000e340: 7375 6d6d 6172 7920 6669 6775 7265 2073  summary figure s
-0000e350: 686f 7769 6e67 2074 6865 2067 616e 7472  howing the gantr
-0000e360: 7920 7361 6720 616e 6420 776f 6262 6c65  y sag and wobble
-0000e370: 2070 6c6f 7473 206f 6620 7468 6520 7468   plots of the th
-0000e380: 7265 6520 6178 6573 2e22 2222 0d0a 2020  ree axes."""..  
-0000e390: 2020 2020 2020 6966 206e 6f74 2073 656c        if not sel
-0000e3a0: 662e 5f69 735f 616e 616c 797a 6564 3a0d  f._is_analyzed:.
-0000e3b0: 0a20 2020 2020 2020 2020 2020 2072 6169  .            rai
-0000e3c0: 7365 2056 616c 7565 4572 726f 7228 2254  se ValueError("T
-0000e3d0: 6865 2073 6574 2069 7320 6e6f 7420 616e  he set is not an
-0000e3e0: 616c 797a 6564 2e20 5573 6520 2e61 6e61  alyzed. Use .ana
-0000e3f0: 6c79 7a65 2829 2066 6972 7374 2e22 290d  lyze() first.").
-0000e400: 0a20 2020 2020 2020 2066 6967 7369 7a65  .        figsize
-0000e410: 203d 2028 3131 2c20 3929 2069 6620 6669   = (11, 9) if fi
-0000e420: 675f 7369 7a65 2069 7320 4e6f 6e65 2065  g_size is None e
-0000e430: 6c73 6520 6669 675f 7369 7a65 0d0a 2020  lse fig_size..  
-0000e440: 2020 2020 2020 706c 742e 6669 6775 7265        plt.figure
-0000e450: 2866 6967 7369 7a65 3d66 6967 7369 7a65  (figsize=figsize
-0000e460: 290d 0a20 2020 2020 2020 2067 7269 6420  )..        grid 
-0000e470: 3d20 2833 2c20 3629 0d0a 2020 2020 2020  = (3, 6)..      
-0000e480: 2020 6761 6e74 7279 5f73 6167 5f61 7820    gantry_sag_ax 
-0000e490: 3d20 706c 742e 7375 6270 6c6f 7432 6772  = plt.subplot2gr
-0000e4a0: 6964 2867 7269 642c 2028 302c 2030 292c  id(grid, (0, 0),
-0000e4b0: 2063 6f6c 7370 616e 3d33 290d 0a20 2020   colspan=3)..   
-0000e4c0: 2020 2020 2073 656c 662e 5f70 6c6f 745f       self._plot_
-0000e4d0: 6465 7669 6174 696f 6e28 4178 6973 2e47  deviation(Axis.G
-0000e4e0: 414e 5452 592c 2067 616e 7472 795f 7361  ANTRY, gantry_sa
-0000e4f0: 675f 6178 2c20 7368 6f77 3d46 616c 7365  g_ax, show=False
-0000e500: 290d 0a20 2020 2020 2020 2065 7069 645f  )..        epid_
-0000e510: 7361 675f 6178 203d 2070 6c74 2e73 7562  sag_ax = plt.sub
-0000e520: 706c 6f74 3267 7269 6428 6772 6964 2c20  plot2grid(grid, 
-0000e530: 2830 2c20 3329 2c20 636f 6c73 7061 6e3d  (0, 3), colspan=
-0000e540: 3329 0d0a 2020 2020 2020 2020 7365 6c66  3)..        self
-0000e550: 2e5f 706c 6f74 5f64 6576 6961 7469 6f6e  ._plot_deviation
-0000e560: 2841 7869 732e 4550 4944 2c20 6570 6964  (Axis.EPID, epid
-0000e570: 5f73 6167 5f61 782c 2073 686f 773d 4661  _sag_ax, show=Fa
-0000e580: 6c73 6529 0d0a 2020 2020 2020 2020 6966  lse)..        if
-0000e590: 2073 656c 662e 5f67 6574 5f69 6d61 6765   self._get_image
-0000e5a0: 7328 2841 7869 732e 434f 4c4c 494d 4154  s((Axis.COLLIMAT
-0000e5b0: 4f52 2c20 4178 6973 2e52 4546 4552 454e  OR, Axis.REFEREN
-0000e5c0: 4345 2929 5b30 5d20 3e20 313a 0d0a 2020  CE))[0] > 1:..  
-0000e5d0: 2020 2020 2020 2020 2020 636f 6c6c 5f73            coll_s
-0000e5e0: 6167 5f61 7820 3d20 706c 742e 7375 6270  ag_ax = plt.subp
-0000e5f0: 6c6f 7432 6772 6964 2867 7269 642c 2028  lot2grid(grid, (
-0000e600: 312c 2030 292c 2063 6f6c 7370 616e 3d33  1, 0), colspan=3
-0000e610: 290d 0a20 2020 2020 2020 2020 2020 2073  )..            s
-0000e620: 656c 662e 5f70 6c6f 745f 6465 7669 6174  elf._plot_deviat
-0000e630: 696f 6e28 4178 6973 2e43 4f4c 4c49 4d41  ion(Axis.COLLIMA
-0000e640: 544f 522c 2063 6f6c 6c5f 7361 675f 6178  TOR, coll_sag_ax
-0000e650: 2c20 7368 6f77 3d46 616c 7365 290d 0a20  , show=False).. 
-0000e660: 2020 2020 2020 2069 6620 7365 6c66 2e5f         if self._
-0000e670: 6765 745f 696d 6167 6573 2828 4178 6973  get_images((Axis
-0000e680: 2e43 4f55 4348 2c20 4178 6973 2e52 4546  .COUCH, Axis.REF
-0000e690: 4552 454e 4345 2929 5b30 5d20 3e20 313a  ERENCE))[0] > 1:
-0000e6a0: 0d0a 2020 2020 2020 2020 2020 2020 636f  ..            co
-0000e6b0: 7563 685f 7361 675f 6178 203d 2070 6c74  uch_sag_ax = plt
-0000e6c0: 2e73 7562 706c 6f74 3267 7269 6428 6772  .subplot2grid(gr
-0000e6d0: 6964 2c20 2831 2c20 3329 2c20 636f 6c73  id, (1, 3), cols
-0000e6e0: 7061 6e3d 3329 0d0a 2020 2020 2020 2020  pan=3)..        
-0000e6f0: 2020 2020 7365 6c66 2e5f 706c 6f74 5f64      self._plot_d
-0000e700: 6576 6961 7469 6f6e 2841 7869 732e 434f  eviation(Axis.CO
-0000e710: 5543 482c 2063 6f75 6368 5f73 6167 5f61  UCH, couch_sag_a
-0000e720: 782c 2073 686f 773d 4661 6c73 6529 0d0a  x, show=False)..
-0000e730: 0d0a 2020 2020 2020 2020 666f 7220 6178  ..        for ax
-0000e740: 6973 2c20 6178 6e75 6d20 696e 207a 6970  is, axnum in zip
-0000e750: 2828 4178 6973 2e47 414e 5452 592c 2041  ((Axis.GANTRY, A
-0000e760: 7869 732e 434f 4c4c 494d 4154 4f52 2c20  xis.COLLIMATOR, 
-0000e770: 4178 6973 2e43 4f55 4348 292c 2028 302c  Axis.COUCH), (0,
-0000e780: 2032 2c20 3429 293a 0d0a 2020 2020 2020   2, 4)):..      
-0000e790: 2020 2020 2020 6966 2073 656c 662e 5f67        if self._g
-0000e7a0: 6574 5f69 6d61 6765 7328 2861 7869 732c  et_images((axis,
-0000e7b0: 2041 7869 732e 5245 4645 5245 4e43 4529   Axis.REFERENCE)
-0000e7c0: 295b 305d 203e 2031 3a0d 0a20 2020 2020  )[0] > 1:..     
-0000e7d0: 2020 2020 2020 2020 2020 2061 7820 3d20             ax = 
-0000e7e0: 706c 742e 7375 6270 6c6f 7432 6772 6964  plt.subplot2grid
-0000e7f0: 2867 7269 642c 2028 322c 2061 786e 756d  (grid, (2, axnum
-0000e800: 292c 2063 6f6c 7370 616e 3d32 290d 0a20  ), colspan=2).. 
-0000e810: 2020 2020 2020 2020 2020 2020 2020 2073                 s
-0000e820: 656c 662e 706c 6f74 5f61 7869 735f 696d  elf.plot_axis_im
-0000e830: 6167 6573 2861 7869 733d 6178 6973 2c20  ages(axis=axis, 
-0000e840: 6178 3d61 782c 2073 686f 773d 4661 6c73  ax=ax, show=Fals
-0000e850: 6529 0d0a 2020 2020 2020 2020 6966 2073  e)..        if s
-0000e860: 686f 773a 0d0a 2020 2020 2020 2020 2020  how:..          
-0000e870: 2020 706c 742e 7469 6768 745f 6c61 796f    plt.tight_layo
-0000e880: 7574 2829 0d0a 2020 2020 2020 2020 2020  ut()..          
-0000e890: 2020 706c 742e 7368 6f77 2829 0d0a 0d0a    plt.show()....
-0000e8a0: 2020 2020 6465 6620 7361 7665 5f73 756d      def save_sum
-0000e8b0: 6d61 7279 2873 656c 662c 2066 696c 656e  mary(self, filen
-0000e8c0: 616d 653a 2073 7472 207c 2042 696e 6172  ame: str | Binar
-0000e8d0: 7949 4f2c 202a 2a6b 7761 7267 7329 202d  yIO, **kwargs) -
-0000e8e0: 3e20 4e6f 6e65 3a0d 0a20 2020 2020 2020  > None:..       
-0000e8f0: 2022 2222 5361 7665 2074 6865 2073 756d   """Save the sum
-0000e900: 6d61 7279 2069 6d61 6765 2e22 2222 0d0a  mary image."""..
-0000e910: 2020 2020 2020 2020 7365 6c66 2e70 6c6f          self.plo
-0000e920: 745f 7375 6d6d 6172 7928 7368 6f77 3d46  t_summary(show=F
-0000e930: 616c 7365 2c20 6669 675f 7369 7a65 3d6b  alse, fig_size=k
-0000e940: 7761 7267 732e 706f 7028 2266 6967 5f73  wargs.pop("fig_s
-0000e950: 697a 6522 2c20 4e6f 6e65 2929 0d0a 2020  ize", None))..  
-0000e960: 2020 2020 2020 706c 742e 7469 6768 745f        plt.tight_
-0000e970: 6c61 796f 7574 2829 0d0a 2020 2020 2020  layout()..      
-0000e980: 2020 706c 742e 7361 7665 6669 6728 6669    plt.savefig(fi
-0000e990: 6c65 6e61 6d65 2c20 2a2a 6b77 6172 6773  lename, **kwargs
-0000e9a0: 290d 0a0d 0a20 2020 2064 6566 2072 6573  )....    def res
-0000e9b0: 756c 7473 2873 656c 662c 2061 735f 6c69  ults(self, as_li
-0000e9c0: 7374 3a20 626f 6f6c 203d 2046 616c 7365  st: bool = False
-0000e9d0: 2920 2d3e 2073 7472 3a0d 0a20 2020 2020  ) -> str:..     
-0000e9e0: 2020 2022 2222 5265 7475 726e 2074 6865     """Return the
-0000e9f0: 2061 6e61 6c79 7369 7320 7265 7375 6c74   analysis result
-0000ea00: 7320 7375 6d6d 6172 792e 0d0a 0d0a 2020  s summary.....  
+000067e0: 6d61 7828 5b6d 6174 6368 2e62 622e 7920  max([match.bb.y 
+000067f0: 666f 7220 6d61 7463 6820 696e 2073 656c  for match in sel
+00006800: 662e 6172 7261 6e67 656d 656e 745f 6d61  f.arrangement_ma
+00006810: 7463 6865 732e 7661 6c75 6573 2829 5d29  tches.values()])
+00006820: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00006830: 202b 2032 3020 2a20 7365 6c66 2e64 706d   + 20 * self.dpm
+00006840: 6d0a 2020 2020 2020 2020 2020 2020 290a  m.            ).
+00006850: 2020 2020 2020 2020 2020 2020 6178 2e73              ax.s
+00006860: 6574 5f79 6c69 6d28 5b6d 6178 5f79 2c20  et_ylim([max_y, 
+00006870: 6d69 6e5f 795d 290a 2020 2020 2020 2020  min_y]).        
+00006880: 2020 2020 6178 2e73 6574 5f78 6c69 6d28      ax.set_xlim(
+00006890: 5b6d 696e 5f78 2c20 6d61 785f 785d 290a  [min_x, max_x]).
+000068a0: 2020 2020 2020 2020 2320 6178 2e73 6574          # ax.set
+000068b0: 5f79 7469 636b 6c61 6265 6c73 285b 5d29  _yticklabels([])
+000068c0: 0a20 2020 2020 2020 2023 2061 782e 7365  .        # ax.se
+000068d0: 745f 7874 6963 6b6c 6162 656c 7328 5b5d  t_xticklabels([]
+000068e0: 290a 2020 2020 2020 2020 6178 2e73 6574  ).        ax.set
+000068f0: 5f74 6974 6c65 2822 5c6e 222e 6a6f 696e  _title("\n".join
+00006900: 2877 7261 7028 5061 7468 2873 656c 662e  (wrap(Path(self.
+00006910: 7061 7468 292e 6e61 6d65 2c20 3330 2929  path).name, 30))
+00006920: 2c20 666f 6e74 7369 7a65 3d31 3029 0a20  , fontsize=10). 
+00006930: 2020 2020 2020 2061 782e 7365 745f 786c         ax.set_xl
+00006940: 6162 656c 280a 2020 2020 2020 2020 2020  abel(.          
+00006950: 2020 6622 473d 7b73 656c 662e 6761 6e74    f"G={self.gant
+00006960: 7279 5f61 6e67 6c65 3a2e 3066 7d2c 2042  ry_angle:.0f}, B
+00006970: 3d7b 7365 6c66 2e63 6f6c 6c69 6d61 746f  ={self.collimato
+00006980: 725f 616e 676c 653a 2e30 667d 2c20 503d  r_angle:.0f}, P=
+00006990: 7b73 656c 662e 636f 7563 685f 616e 676c  {self.couch_angl
+000069a0: 653a 2e30 667d 220a 2020 2020 2020 2020  e:.0f}".        
+000069b0: 290a 2020 2020 2020 2020 6178 2e73 6574  ).        ax.set
+000069c0: 5f79 6c61 6265 6c28 6622 4d61 7820 4e6f  _ylabel(f"Max No
+000069d0: 6d69 6e61 6c20 746f 2042 423a 207b 6d61  minal to BB: {ma
+000069e0: 7828 7365 6c66 2e66 6965 6c64 5f74 6f5f  x(self.field_to_
+000069f0: 6262 5f64 6973 7461 6e63 6573 2829 293a  bb_distances()):
+00006a00: 332e 3266 7d6d 6d22 290a 2020 2020 2020  3.2f}mm").      
+00006a10: 2020 6966 2073 686f 773a 0a20 2020 2020    if show:.     
+00006a20: 2020 2020 2020 2070 6c74 2e73 686f 7728         plt.show(
+00006a30: 290a 2020 2020 2020 2020 7265 7475 726e  ).        return
+00006a40: 2061 780a 0a20 2020 2064 6566 206e 6f6d   ax..    def nom
+00006a50: 696e 616c 5f62 625f 706f 7369 7469 6f6e  inal_bb_position
+00006a60: 2873 656c 662c 2062 625f 636f 6e66 6967  (self, bb_config
+00006a70: 3a20 4242 436f 6e66 6967 2920 2d3e 2050  : BBConfig) -> P
+00006a80: 6f69 6e74 3a0a 2020 2020 2020 2020 2222  oint:.        ""
+00006a90: 2243 616c 6375 6c61 7465 2074 6865 2065  "Calculate the e
+00006aa0: 7870 6563 7465 6420 706f 696e 7420 706f  xpected point po
+00006ab0: 7369 7469 6f6e 2069 6e20 3244 2222 220a  sition in 2D""".
+00006ac0: 2020 2020 2020 2020 7368 6966 745f 785f          shift_x_
+00006ad0: 6d6d 2c20 7368 6966 745f 795f 6d6d 203d  mm, shift_y_mm =
+00006ae0: 2062 625f 7072 6f6a 6563 7469 6f6e 5f77   bb_projection_w
+00006af0: 6974 685f 726f 7461 7469 6f6e 280a 2020  ith_rotation(.  
+00006b00: 2020 2020 2020 2020 2020 6f66 6673 6574            offset
+00006b10: 5f6c 6566 743d 6262 5f63 6f6e 6669 672e  _left=bb_config.
+00006b20: 6f66 6673 6574 5f6c 6566 745f 6d6d 2c0a  offset_left_mm,.
+00006b30: 2020 2020 2020 2020 2020 2020 6f66 6673              offs
+00006b40: 6574 5f75 703d 6262 5f63 6f6e 6669 672e  et_up=bb_config.
+00006b50: 6f66 6673 6574 5f75 705f 6d6d 2c0a 2020  offset_up_mm,.  
+00006b60: 2020 2020 2020 2020 2020 6f66 6673 6574            offset
+00006b70: 5f69 6e3d 6262 5f63 6f6e 6669 672e 6f66  _in=bb_config.of
+00006b80: 6673 6574 5f69 6e5f 6d6d 2c0a 2020 2020  fset_in_mm,.    
+00006b90: 2020 2020 2020 2020 7361 643d 7365 6c66          sad=self
+00006ba0: 2e73 6164 2c0a 2020 2020 2020 2020 2020  .sad,.          
+00006bb0: 2020 6761 6e74 7279 3d73 656c 662e 6761    gantry=self.ga
+00006bc0: 6e74 7279 5f61 6e67 6c65 2c0a 2020 2020  ntry_angle,.    
+00006bd0: 2020 2020 2020 2020 636f 7563 683d 7365          couch=se
+00006be0: 6c66 2e63 6f75 6368 5f61 6e67 6c65 2c0a  lf.couch_angle,.
+00006bf0: 2020 2020 2020 2020 290a 2020 2020 2020          ).      
+00006c00: 2020 2320 7468 6520 6669 656c 6420 6361    # the field ca
+00006c10: 6e20 6265 2061 7379 6d6d 6574 7269 632c  n be asymmetric,
+00006c20: 2073 6f20 7573 6520 6365 6e74 6572 206f   so use center o
+00006c30: 6620 696d 6167 650a 2020 2020 2020 2020  f image.        
+00006c40: 6578 7065 6374 6564 5f79 203d 2073 656c  expected_y = sel
+00006c50: 662e 6570 6964 2e79 202d 2073 6869 6674  f.epid.y - shift
+00006c60: 5f79 5f6d 6d20 2a20 7365 6c66 2e64 706d  _y_mm * self.dpm
+00006c70: 6d0a 2020 2020 2020 2020 6578 7065 6374  m.        expect
+00006c80: 6564 5f78 203d 2073 656c 662e 6570 6964  ed_x = self.epid
+00006c90: 2e78 202b 2073 6869 6674 5f78 5f6d 6d20  .x + shift_x_mm 
+00006ca0: 2a20 7365 6c66 2e64 706d 6d0a 2020 2020  * self.dpmm.    
+00006cb0: 2020 2020 7265 7475 726e 2050 6f69 6e74      return Point
+00006cc0: 2878 3d65 7870 6563 7465 645f 782c 2079  (x=expected_x, y
+00006cd0: 3d65 7870 6563 7465 645f 7929 0a0a 2020  =expected_y)..  
+00006ce0: 2020 4070 726f 7065 7274 790a 2020 2020    @property.    
+00006cf0: 6465 6620 6570 6964 2873 656c 6629 202d  def epid(self) -
+00006d00: 3e20 506f 696e 743a 0a20 2020 2020 2020  > Point:.       
+00006d10: 2022 2222 4365 6e74 6572 206f 6620 7468   """Center of th
+00006d20: 6520 4550 4944 2070 616e 656c 2222 220a  e EPID panel""".
+00006d30: 2020 2020 2020 2020 7265 7475 726e 2073          return s
+00006d40: 656c 662e 6365 6e74 6572 0a0a 2020 2020  elf.center..    
+00006d50: 6465 6620 5f63 616c 6375 6c61 7465 5f62  def _calculate_b
+00006d60: 625f 746f 6c65 7261 6e63 6528 7365 6c66  b_tolerance(self
+00006d70: 2c20 6262 5f64 6961 6d65 7465 723a 2066  , bb_diameter: f
+00006d80: 6c6f 6174 2920 2d3e 2069 6e74 3a0a 2020  loat) -> int:.  
+00006d90: 2020 2020 2020 2222 2243 616c 6375 6c61        """Calcula
+00006da0: 7465 2074 6865 2042 4220 746f 6c65 7261  te the BB tolera
+00006db0: 6e63 6520 6261 7365 6420 6f6e 2074 6865  nce based on the
+00006dc0: 2042 4220 6469 616d 6574 6572 2e0a 2020   BB diameter..  
+00006dd0: 2020 2020 2020 4d69 6e20 7769 6c6c 2062        Min will b
+00006de0: 6520 3220 666f 7220 312e 356d 6d20 616e  e 2 for 1.5mm an
+00006df0: 6420 756e 6465 722e 2057 696c 6c20 6265  d under. Will be
+00006e00: 2034 2066 6f72 2064 6961 6d65 7465 7273   4 for diameters
+00006e10: 2061 7420 6f72 2061 626f 7665 2033 306d   at or above 30m
+00006e20: 6d2e 2222 220a 2020 2020 2020 2020 7920  m.""".        y 
+00006e30: 3d20 2832 2c20 3429 0a20 2020 2020 2020  = (2, 4).       
+00006e40: 2078 203d 2028 312e 352c 2033 3029 0a20   x = (1.5, 30). 
+00006e50: 2020 2020 2020 2072 6574 7572 6e20 6e70         return np
+00006e60: 2e69 6e74 6572 7028 6262 5f64 6961 6d65  .interp(bb_diame
+00006e70: 7465 722c 2078 2c20 7929 0a0a 2020 2020  ter, x, y)..    
+00006e80: 4070 726f 7065 7274 790a 2020 2020 6465  @property.    de
+00006e90: 6620 7661 7269 6162 6c65 5f61 7869 7328  f variable_axis(
+00006ea0: 7365 6c66 2920 2d3e 2041 7869 733a 0a20  self) -> Axis:. 
+00006eb0: 2020 2020 2020 2022 2222 5468 6520 6178         """The ax
+00006ec0: 6973 2074 6861 7420 6973 2076 6172 7969  is that is varyi
+00006ed0: 6e67 2e0a 0a20 2020 2020 2020 2054 6865  ng...        The
+00006ee0: 7265 2061 7265 2066 6976 6520 7479 7065  re are five type
+00006ef0: 7320 6f66 2069 6d61 6765 733a 0a0a 2020  s of images:..  
+00006f00: 2020 2020 2020 2a20 5265 6665 7265 6e63        * Referenc
+00006f10: 6520 3a20 416c 6c20 6178 6573 2061 7265  e : All axes are
+00006f20: 2061 7420 302e 0a20 2020 2020 2020 202a   at 0..        *
+00006f30: 2047 616e 7472 793a 2041 6c6c 2061 7865   Gantry: All axe
+00006f40: 7320 6275 7420 6761 6e74 7279 2061 7420  s but gantry at 
+00006f50: 302e 0a20 2020 2020 2020 202a 2043 6f6c  0..        * Col
+00006f60: 6c69 6d61 746f 7220 3a20 416c 6c20 6178  limator : All ax
+00006f70: 6573 2062 7574 2063 6f6c 6c69 6d61 746f  es but collimato
+00006f80: 7220 6174 2030 2e0a 2020 2020 2020 2020  r at 0..        
+00006f90: 2a20 436f 7563 6820 3a20 416c 6c20 6178  * Couch : All ax
+00006fa0: 6573 2062 7574 2063 6f75 6368 2061 7420  es but couch at 
+00006fb0: 302e 0a20 2020 2020 2020 202a 2043 6f6d  0..        * Com
+00006fc0: 626f 203a 204d 6f72 6520 7468 616e 206f  bo : More than o
+00006fd0: 6e65 2061 7869 7320 6973 206e 6f74 2061  ne axis is not a
+00006fe0: 7420 302e 0a20 2020 2020 2020 2022 2222  t 0..        """
+00006ff0: 0a20 2020 2020 2020 2047 3020 3d20 6973  .        G0 = is
+00007000: 5f63 6c6f 7365 2873 656c 662e 6761 6e74  _close(self.gant
+00007010: 7279 5f61 6e67 6c65 2c20 5b30 2c20 3336  ry_angle, [0, 36
+00007020: 305d 290a 2020 2020 2020 2020 4230 203d  0]).        B0 =
+00007030: 2069 735f 636c 6f73 6528 7365 6c66 2e63   is_close(self.c
+00007040: 6f6c 6c69 6d61 746f 725f 616e 676c 652c  ollimator_angle,
+00007050: 205b 302c 2033 3630 5d29 0a20 2020 2020   [0, 360]).     
+00007060: 2020 2050 3020 3d20 6973 5f63 6c6f 7365     P0 = is_close
+00007070: 2873 656c 662e 636f 7563 685f 616e 676c  (self.couch_angl
+00007080: 652c 205b 302c 2033 3630 5d29 0a20 2020  e, [0, 360]).   
+00007090: 2020 2020 2069 6620 4730 2061 6e64 2042       if G0 and B
+000070a0: 3020 616e 6420 6e6f 7420 5030 3a0a 2020  0 and not P0:.  
+000070b0: 2020 2020 2020 2020 2020 7265 7475 726e            return
+000070c0: 2041 7869 732e 434f 5543 480a 2020 2020   Axis.COUCH.    
+000070d0: 2020 2020 656c 6966 2047 3020 616e 6420      elif G0 and 
+000070e0: 5030 2061 6e64 206e 6f74 2042 303a 0a20  P0 and not B0:. 
+000070f0: 2020 2020 2020 2020 2020 2072 6574 7572             retur
+00007100: 6e20 4178 6973 2e43 4f4c 4c49 4d41 544f  n Axis.COLLIMATO
+00007110: 520a 2020 2020 2020 2020 656c 6966 2050  R.        elif P
+00007120: 3020 616e 6420 4230 2061 6e64 206e 6f74  0 and B0 and not
+00007130: 2047 303a 0a20 2020 2020 2020 2020 2020   G0:.           
+00007140: 2072 6574 7572 6e20 4178 6973 2e47 414e   return Axis.GAN
+00007150: 5452 590a 2020 2020 2020 2020 656c 6966  TRY.        elif
+00007160: 2050 3020 616e 6420 4230 2061 6e64 2047   P0 and B0 and G
+00007170: 303a 0a20 2020 2020 2020 2020 2020 2072  0:.            r
+00007180: 6574 7572 6e20 4178 6973 2e52 4546 4552  eturn Axis.REFER
+00007190: 454e 4345 0a20 2020 2020 2020 2065 6c69  ENCE.        eli
+000071a0: 6620 5030 3a0a 2020 2020 2020 2020 2020  f P0:.          
+000071b0: 2020 7265 7475 726e 2041 7869 732e 4742    return Axis.GB
+000071c0: 5f43 4f4d 424f 0a20 2020 2020 2020 2065  _COMBO.        e
+000071d0: 6c73 653a 0a20 2020 2020 2020 2020 2020  lse:.           
+000071e0: 2072 6574 7572 6e20 4178 6973 2e47 4250   return Axis.GBP
+000071f0: 5f43 4f4d 424f 0a0a 2020 2020 6465 6620  _COMBO..    def 
+00007200: 5f63 6c65 616e 5f65 6467 6573 2873 656c  _clean_edges(sel
+00007210: 662c 2077 696e 646f 775f 7369 7a65 3a20  f, window_size: 
+00007220: 696e 7420 3d20 3229 202d 3e20 4e6f 6e65  int = 2) -> None
+00007230: 3a0a 2020 2020 2020 2020 2222 2243 6c65  :.        """Cle
+00007240: 616e 2074 6865 2065 6467 6573 206f 6620  an the edges of 
+00007250: 7468 6520 696d 6167 6520 746f 2062 6520  the image to be 
+00007260: 6e65 6172 2074 6865 2062 6163 6b67 726f  near the backgro
+00007270: 756e 6420 6c65 7665 6c2e 2222 220a 0a20  und level.""".. 
+00007280: 2020 2020 2020 2064 6566 2068 6173 5f6e         def has_n
+00007290: 6f69 7365 2873 656c 662c 2077 696e 646f  oise(self, windo
+000072a0: 775f 7369 7a65 293a 0a20 2020 2020 2020  w_size):.       
+000072b0: 2020 2020 2022 2222 4865 6c70 6572 206d       """Helper m
+000072c0: 6574 686f 6420 746f 2064 6574 6572 6d69  ethod to determi
+000072d0: 6e65 2069 6620 7468 6572 6520 6973 2073  ne if there is s
+000072e0: 7075 7269 6f75 7320 7369 676e 616c 2061  purious signal a
+000072f0: 7420 616e 7920 6f66 2074 6865 2069 6d61  t any of the ima
+00007300: 6765 2065 6467 6573 2e0a 0a20 2020 2020  ge edges...     
+00007310: 2020 2020 2020 2044 6574 6572 6d69 6e65         Determine
+00007320: 7320 6966 2074 6865 206d 696e 206f 7220  s if the min or 
+00007330: 6d61 7820 6f66 2061 6e20 6564 6765 2069  max of an edge i
+00007340: 7320 7769 7468 696e 2031 3025 206f 6620  s within 10% of 
+00007350: 7468 6520 6261 7365 6c69 6e65 2076 616c  the baseline val
+00007360: 7565 2061 6e64 2074 7269 6d73 2069 6620  ue and trims if 
+00007370: 6e6f 742e 0a20 2020 2020 2020 2020 2020  not..           
+00007380: 2022 2222 0a20 2020 2020 2020 2020 2020   """.           
+00007390: 206e 6561 725f 6d69 6e2c 206e 6561 725f   near_min, near_
+000073a0: 6d61 7820 3d20 6e70 2e70 6572 6365 6e74  max = np.percent
+000073b0: 696c 6528 7365 6c66 2e61 7272 6179 2c20  ile(self.array, 
+000073c0: 5b35 2c20 3939 2e35 5d29 0a20 2020 2020  [5, 99.5]).     
+000073d0: 2020 2020 2020 2069 6d67 5f72 616e 6765         img_range
+000073e0: 203d 206e 6561 725f 6d61 7820 2d20 6e65   = near_max - ne
+000073f0: 6172 5f6d 696e 0a20 2020 2020 2020 2020  ar_min.         
+00007400: 2020 2074 6f70 203d 2073 656c 665b 3a77     top = self[:w
+00007410: 696e 646f 775f 7369 7a65 2c20 3a5d 0a20  indow_size, :]. 
+00007420: 2020 2020 2020 2020 2020 206c 6566 7420             left 
+00007430: 3d20 7365 6c66 5b3a 2c20 3a77 696e 646f  = self[:, :windo
+00007440: 775f 7369 7a65 5d0a 2020 2020 2020 2020  w_size].        
+00007450: 2020 2020 626f 7474 6f6d 203d 2073 656c      bottom = sel
+00007460: 665b 2d77 696e 646f 775f 7369 7a65 3a2c  f[-window_size:,
+00007470: 203a 5d0a 2020 2020 2020 2020 2020 2020   :].            
+00007480: 7269 6768 7420 3d20 7365 6c66 5b3a 2c20  right = self[:, 
+00007490: 2d77 696e 646f 775f 7369 7a65 3a5d 0a20  -window_size:]. 
+000074a0: 2020 2020 2020 2020 2020 2065 6467 655f             edge_
+000074b0: 6172 7261 7920 3d20 6e70 2e63 6f6e 6361  array = np.conca
+000074c0: 7465 6e61 7465 280a 2020 2020 2020 2020  tenate(.        
+000074d0: 2020 2020 2020 2020 2874 6f70 2e66 6c61          (top.fla
+000074e0: 7474 656e 2829 2c20 6c65 6674 2e66 6c61  tten(), left.fla
+000074f0: 7474 656e 2829 2c20 626f 7474 6f6d 2e66  tten(), bottom.f
+00007500: 6c61 7474 656e 2829 2c20 7269 6768 742e  latten(), right.
+00007510: 666c 6174 7465 6e28 2929 0a20 2020 2020  flatten()).     
+00007520: 2020 2020 2020 2029 0a20 2020 2020 2020         ).       
+00007530: 2020 2020 2065 6467 655f 746f 6f5f 6c6f       edge_too_lo
+00007540: 7720 3d20 6564 6765 5f61 7272 6179 2e6d  w = edge_array.m
+00007550: 696e 2829 203c 2028 6e65 6172 5f6d 696e  in() < (near_min
+00007560: 202d 2069 6d67 5f72 616e 6765 202f 2031   - img_range / 1
+00007570: 3029 0a20 2020 2020 2020 2020 2020 2065  0).            e
+00007580: 6467 655f 746f 6f5f 6869 6768 203d 2065  dge_too_high = e
+00007590: 6467 655f 6172 7261 792e 6d61 7828 2920  dge_array.max() 
+000075a0: 3e20 286e 6561 725f 6d61 7820 2b20 696d  > (near_max + im
+000075b0: 675f 7261 6e67 6520 2f20 3130 290a 2020  g_range / 10).  
+000075c0: 2020 2020 2020 2020 2020 7265 7475 726e            return
+000075d0: 2065 6467 655f 746f 6f5f 6c6f 7720 6f72   edge_too_low or
+000075e0: 2065 6467 655f 746f 6f5f 6869 6768 0a0a   edge_too_high..
+000075f0: 2020 2020 2020 2020 7361 6665 7479 5f73          safety_s
+00007600: 746f 7020 3d20 6e70 2e6d 696e 2873 656c  top = np.min(sel
+00007610: 662e 7368 6170 6529 202f 2031 300a 2020  f.shape) / 10.  
+00007620: 2020 2020 2020 7768 696c 6520 6861 735f        while has_
+00007630: 6e6f 6973 6528 7365 6c66 2c20 7769 6e64  noise(self, wind
+00007640: 6f77 5f73 697a 6529 2061 6e64 2073 6166  ow_size) and saf
+00007650: 6574 795f 7374 6f70 203e 2030 3a0a 2020  ety_stop > 0:.  
+00007660: 2020 2020 2020 2020 2020 7365 6c66 2e63            self.c
+00007670: 726f 7028 7769 6e64 6f77 5f73 697a 6529  rop(window_size)
+00007680: 0a20 2020 2020 2020 2020 2020 2073 6166  .            saf
+00007690: 6574 795f 7374 6f70 202d 3d20 310a 0a0a  ety_stop -= 1...
+000076a0: 636c 6173 7320 5769 6e73 746f 6e4c 7574  class WinstonLut
+000076b0: 7a32 4428 574c 4261 7365 496d 6167 652c  z2D(WLBaseImage,
+000076c0: 2052 6573 756c 7473 4461 7461 4d69 7869   ResultsDataMixi
+000076d0: 6e5b 5769 6e73 746f 6e4c 7574 7a32 4452  n[WinstonLutz2DR
+000076e0: 6573 756c 745d 293a 0a20 2020 2022 2222  esult]):.    """
+000076f0: 486f 6c64 7320 696e 6469 7669 6475 616c  Holds individual
+00007700: 2057 696e 7374 6f6e 2d4c 7574 7a20 4550   Winston-Lutz EP
+00007710: 4944 2069 6d61 6765 732c 2069 6d61 6765  ID images, image
+00007720: 2070 726f 7065 7274 6965 732c 2061 6e64   properties, and
+00007730: 2061 7574 6f6d 6174 6963 616c 6c79 2066   automatically f
+00007740: 696e 6473 2074 6865 2066 6965 6c64 2043  inds the field C
+00007750: 4158 2061 6e64 2042 422e 2222 220a 0a20  AX and BB.""".. 
+00007760: 2020 2062 623a 2050 6f69 6e74 0a20 2020     bb: Point.   
+00007770: 2066 6965 6c64 5f63 6178 3a20 506f 696e   field_cax: Poin
+00007780: 740a 2020 2020 6262 5f61 7272 616e 6765  t.    bb_arrange
+00007790: 6d65 6e74 3a20 7475 706c 655b 4242 436f  ment: tuple[BBCo
+000077a0: 6e66 6967 5d0a 2020 2020 6973 5f66 726f  nfig].    is_fro
+000077b0: 6d5f 7469 6666 3a20 626f 6f6c 203d 2046  m_tiff: bool = F
+000077c0: 616c 7365 0a20 2020 2064 6574 6563 7469  alse.    detecti
+000077d0: 6f6e 5f63 6f6e 6469 7469 6f6e 733a 206c  on_conditions: l
+000077e0: 6973 745b 6361 6c6c 6162 6c65 5d20 3d20  ist[callable] = 
+000077f0: 5b0a 2020 2020 2020 2020 6973 5f72 6967  [.        is_rig
+00007800: 6874 5f73 697a 655f 6262 2c0a 2020 2020  ht_size_bb,.    
+00007810: 2020 2020 6973 5f72 6f75 6e64 2c0a 2020      is_round,.  
+00007820: 2020 2020 2020 6973 5f72 6967 6874 5f63        is_right_c
+00007830: 6972 6375 6d66 6572 656e 6365 2c0a 2020  ircumference,.  
+00007840: 2020 2020 2020 6973 5f73 796d 6d65 7472        is_symmetr
+00007850: 6963 2c0a 2020 2020 2020 2020 6973 5f73  ic,.        is_s
+00007860: 6f6c 6964 2c0a 2020 2020 5d0a 0a20 2020  olid,.    ]..   
+00007870: 2064 6566 2061 6e61 6c79 7a65 280a 2020   def analyze(.  
+00007880: 2020 2020 2020 7365 6c66 2c0a 2020 2020        self,.    
+00007890: 2020 2020 6262 5f73 697a 655f 6d6d 3a20      bb_size_mm: 
+000078a0: 666c 6f61 7420 3d20 352c 0a20 2020 2020  float = 5,.     
+000078b0: 2020 206c 6f77 5f64 656e 7369 7479 5f62     low_density_b
+000078c0: 623a 2062 6f6f 6c20 3d20 4661 6c73 652c  b: bool = False,
+000078d0: 0a20 2020 2020 2020 206f 7065 6e5f 6669  .        open_fi
+000078e0: 656c 643a 2062 6f6f 6c20 3d20 4661 6c73  eld: bool = Fals
+000078f0: 652c 0a20 2020 2020 2020 2073 6869 6674  e,.        shift
+00007900: 5f76 6563 746f 723a 2056 6563 746f 7220  _vector: Vector 
+00007910: 7c20 4e6f 6e65 203d 204e 6f6e 652c 0a20  | None = None,. 
+00007920: 2020 2029 202d 3e20 4e6f 6e65 3a0a 2020     ) -> None:.  
+00007930: 2020 2020 2020 2222 2241 6e61 6c79 7a65        """Analyze
+00007940: 2074 6865 2069 6d61 6765 2e20 5365 6520   the image. See 
+00007950: 5769 6e73 746f 6e4c 7574 7a2e 616e 616c  WinstonLutz.anal
+00007960: 797a 6520 666f 7220 7061 7261 6d65 7465  yze for paramete
+00007970: 7220 6465 7461 696c 732e 2222 220a 2020  r details.""".  
+00007980: 2020 2020 2020 6262 5f63 6f6e 6669 6720        bb_config 
+00007990: 3d20 4242 4172 7261 6e67 656d 656e 742e  = BBArrangement.
+000079a0: 4953 4f0a 2020 2020 2020 2020 6262 5f63  ISO.        bb_c
+000079b0: 6f6e 6669 675b 305d 2e62 625f 7369 7a65  onfig[0].bb_size
+000079c0: 5f6d 6d20 3d20 6262 5f73 697a 655f 6d6d  _mm = bb_size_mm
+000079d0: 0a20 2020 2020 2020 2073 7570 6572 2829  .        super()
+000079e0: 2e61 6e61 6c79 7a65 280a 2020 2020 2020  .analyze(.      
+000079f0: 2020 2020 2020 6262 5f61 7272 616e 6765        bb_arrange
+00007a00: 6d65 6e74 3d62 625f 636f 6e66 6967 2c0a  ment=bb_config,.
+00007a10: 2020 2020 2020 2020 2020 2020 6973 5f6f              is_o
+00007a20: 7065 6e5f 6669 656c 643d 6f70 656e 5f66  pen_field=open_f
+00007a30: 6965 6c64 2c0a 2020 2020 2020 2020 2020  ield,.          
+00007a40: 2020 6973 5f6c 6f77 5f64 656e 7369 7479    is_low_density
+00007a50: 3d6c 6f77 5f64 656e 7369 7479 5f62 622c  =low_density_bb,
+00007a60: 0a20 2020 2020 2020 2020 2020 2073 6869  .            shi
+00007a70: 6674 5f76 6563 746f 723d 7368 6966 745f  ft_vector=shift_
+00007a80: 7665 6374 6f72 2c0a 2020 2020 2020 2020  vector,.        
+00007a90: 290a 2020 2020 2020 2020 7365 6c66 2e62  ).        self.b
+00007aa0: 625f 6172 7261 6e67 656d 656e 7420 3d20  b_arrangement = 
+00007ab0: 6262 5f63 6f6e 6669 670a 2020 2020 2020  bb_config.      
+00007ac0: 2020 2320 7468 6573 6520 6172 6520 7365    # these are se
+00007ad0: 7420 666f 7220 7468 6520 6465 7072 6563  t for the deprec
+00007ae0: 6174 6564 2070 726f 7065 7274 6965 7320  ated properties 
+00007af0: 6f66 2074 6865 2032 4420 616e 616c 7973  of the 2D analys
+00007b00: 6973 2073 7065 6369 6669 6361 6c6c 7920  is specifically 
+00007b10: 7768 6572 6520 3120 6669 656c 6420 616e  where 1 field an
+00007b20: 6420 3120 6262 2061 7265 2065 7870 6563  d 1 bb are expec
+00007b30: 7465 642e 0a20 2020 2020 2020 2073 656c  ted..        sel
+00007b40: 662e 6669 656c 645f 6361 7820 3d20 7365  f.field_cax = se
+00007b50: 6c66 2e61 7272 616e 6765 6d65 6e74 5f6d  lf.arrangement_m
+00007b60: 6174 6368 6573 5b22 4973 6f22 5d2e 6669  atches["Iso"].fi
+00007b70: 656c 640a 2020 2020 2020 2020 7365 6c66  eld.        self
+00007b80: 2e62 6220 3d20 7365 6c66 2e61 7272 616e  .bb = self.arran
+00007b90: 6765 6d65 6e74 5f6d 6174 6368 6573 5b22  gement_matches["
+00007ba0: 4973 6f22 5d2e 6262 0a0a 2020 2020 6465  Iso"].bb..    de
+00007bb0: 6620 5f5f 7265 7072 5f5f 2873 656c 6629  f __repr__(self)
+00007bc0: 3a0a 2020 2020 2020 2020 7265 7475 726e  :.        return
+00007bd0: 2066 2257 4c49 6d61 6765 2867 616e 7472   f"WLImage(gantr
+00007be0: 793d 7b73 656c 662e 6761 6e74 7279 5f61  y={self.gantry_a
+00007bf0: 6e67 6c65 3a2e 3166 7d2c 2063 6f6c 6c3d  ngle:.1f}, coll=
+00007c00: 7b73 656c 662e 636f 6c6c 696d 6174 6f72  {self.collimator
+00007c10: 5f61 6e67 6c65 3a2e 3166 7d2c 2063 6f75  _angle:.1f}, cou
+00007c20: 6368 3d7b 7365 6c66 2e63 6f75 6368 5f61  ch={self.couch_a
+00007c30: 6e67 6c65 3a2e 3166 7d29 220a 0a20 2020  ngle:.1f})"..   
+00007c40: 2064 6566 2074 6f5f 6178 6573 2873 656c   def to_axes(sel
+00007c50: 6629 202d 3e20 7374 723a 0a20 2020 2020  f) -> str:.     
+00007c60: 2020 2022 2222 4769 7665 206a 7573 7420     """Give just 
+00007c70: 7468 6520 6178 6573 2076 616c 7565 7320  the axes values 
+00007c80: 6173 2061 2068 756d 616e 2d72 6561 6461  as a human-reada
+00007c90: 626c 6520 7374 7269 6e67 2222 220a 2020  ble string""".  
+00007ca0: 2020 2020 2020 7265 7475 726e 2066 2247        return f"G
+00007cb0: 616e 7472 793d 7b73 656c 662e 6761 6e74  antry={self.gant
+00007cc0: 7279 5f61 6e67 6c65 3a2e 3166 7d2c 2043  ry_angle:.1f}, C
+00007cd0: 6f6c 6c3d 7b73 656c 662e 636f 6c6c 696d  oll={self.collim
+00007ce0: 6174 6f72 5f61 6e67 6c65 3a2e 3166 7d2c  ator_angle:.1f},
+00007cf0: 2043 6f75 6368 3d7b 7365 6c66 2e63 6f75   Couch={self.cou
+00007d00: 6368 5f61 6e67 6c65 3a2e 3166 7d22 0a0a  ch_angle:.1f}"..
+00007d10: 2020 2020 4070 726f 7065 7274 790a 2020      @property.  
+00007d20: 2020 6465 6620 6361 7832 6262 5f76 6563    def cax2bb_vec
+00007d30: 746f 7228 7365 6c66 2920 2d3e 2056 6563  tor(self) -> Vec
+00007d40: 746f 723a 0a20 2020 2020 2020 2022 2222  tor:.        """
+00007d50: 5468 6520 7665 6374 6f72 2069 6e20 6d6d  The vector in mm
+00007d60: 2066 726f 6d20 7468 6520 4341 5820 746f   from the CAX to
+00007d70: 2074 6865 2042 422e 2222 220a 2020 2020   the BB.""".    
+00007d80: 2020 2020 6469 7374 203d 2028 7365 6c66      dist = (self
+00007d90: 2e62 6220 2d20 7365 6c66 2e66 6965 6c64  .bb - self.field
+00007da0: 5f63 6178 2920 2f20 7365 6c66 2e64 706d  _cax) / self.dpm
+00007db0: 6d0a 2020 2020 2020 2020 7265 7475 726e  m.        return
+00007dc0: 2056 6563 746f 7228 6469 7374 2e78 2c20   Vector(dist.x, 
+00007dd0: 6469 7374 2e79 2c20 6469 7374 2e7a 290a  dist.y, dist.z).
+00007de0: 0a20 2020 2040 7072 6f70 6572 7479 0a20  .    @property. 
+00007df0: 2020 2064 6566 2063 6178 3262 625f 6469     def cax2bb_di
+00007e00: 7374 616e 6365 2873 656c 6629 202d 3e20  stance(self) -> 
+00007e10: 666c 6f61 743a 0a20 2020 2020 2020 2022  float:.        "
+00007e20: 2222 5468 6520 7363 616c 6172 2064 6973  ""The scalar dis
+00007e30: 7461 6e63 6520 696e 206d 6d20 6672 6f6d  tance in mm from
+00007e40: 2074 6865 2043 4158 2074 6f20 7468 6520   the CAX to the 
+00007e50: 4242 2e22 2222 0a20 2020 2020 2020 2064  BB.""".        d
+00007e60: 6973 7420 3d20 7365 6c66 2e66 6965 6c64  ist = self.field
+00007e70: 5f63 6178 2e64 6973 7461 6e63 655f 746f  _cax.distance_to
+00007e80: 2873 656c 662e 6262 290a 2020 2020 2020  (self.bb).      
+00007e90: 2020 7265 7475 726e 2064 6973 7420 2f20    return dist / 
+00007ea0: 7365 6c66 2e64 706d 6d0a 0a20 2020 2040  self.dpmm..    @
+00007eb0: 7072 6f70 6572 7479 0a20 2020 2064 6566  property.    def
+00007ec0: 2063 6178 3265 7069 645f 7665 6374 6f72   cax2epid_vector
+00007ed0: 2873 656c 6629 202d 3e20 5665 6374 6f72  (self) -> Vector
+00007ee0: 3a0a 2020 2020 2020 2020 2222 2254 6865  :.        """The
+00007ef0: 2076 6563 746f 7220 696e 206d 6d20 6672   vector in mm fr
+00007f00: 6f6d 2074 6865 2043 4158 2074 6f20 7468  om the CAX to th
+00007f10: 6520 4550 4944 2063 656e 7465 7220 7069  e EPID center pi
+00007f20: 7865 6c22 2222 0a20 2020 2020 2020 2064  xel""".        d
+00007f30: 6973 7420 3d20 2873 656c 662e 6570 6964  ist = (self.epid
+00007f40: 202d 2073 656c 662e 6669 656c 645f 6361   - self.field_ca
+00007f50: 7829 202f 2073 656c 662e 6470 6d6d 0a20  x) / self.dpmm. 
+00007f60: 2020 2020 2020 2072 6574 7572 6e20 5665         return Ve
+00007f70: 6374 6f72 2864 6973 742e 782c 2064 6973  ctor(dist.x, dis
+00007f80: 742e 792c 2064 6973 742e 7a29 0a0a 2020  t.y, dist.z)..  
+00007f90: 2020 4070 726f 7065 7274 790a 2020 2020    @property.    
+00007fa0: 6465 6620 6361 7832 6570 6964 5f64 6973  def cax2epid_dis
+00007fb0: 7461 6e63 6528 7365 6c66 2920 2d3e 2066  tance(self) -> f
+00007fc0: 6c6f 6174 3a0a 2020 2020 2020 2020 2222  loat:.        ""
+00007fd0: 2254 6865 2073 6361 6c61 7220 6469 7374  "The scalar dist
+00007fe0: 616e 6365 2069 6e20 6d6d 2066 726f 6d20  ance in mm from 
+00007ff0: 7468 6520 4341 5820 746f 2074 6865 2045  the CAX to the E
+00008000: 5049 4420 6365 6e74 6572 2070 6978 656c  PID center pixel
+00008010: 2222 220a 2020 2020 2020 2020 7265 7475  """.        retu
+00008020: 726e 2073 656c 662e 6669 656c 645f 6361  rn self.field_ca
+00008030: 782e 6469 7374 616e 6365 5f74 6f28 7365  x.distance_to(se
+00008040: 6c66 2e65 7069 6429 202f 2073 656c 662e  lf.epid) / self.
+00008050: 6470 6d6d 0a0a 2020 2020 6465 6620 7361  dpmm..    def sa
+00008060: 7665 5f70 6c6f 7428 7365 6c66 2c20 6669  ve_plot(self, fi
+00008070: 6c65 6e61 6d65 3a20 7374 722c 202a 2a6b  lename: str, **k
+00008080: 7761 7267 7329 3a0a 2020 2020 2020 2020  wargs):.        
+00008090: 2222 2253 6176 6520 7468 6520 696d 6167  """Save the imag
+000080a0: 6520 706c 6f74 2074 6f20 6669 6c65 2e22  e plot to file."
+000080b0: 2222 0a20 2020 2020 2020 2073 656c 662e  "".        self.
+000080c0: 706c 6f74 2873 686f 773d 4661 6c73 6529  plot(show=False)
+000080d0: 0a20 2020 2020 2020 2070 6c74 2e74 6967  .        plt.tig
+000080e0: 6874 5f6c 6179 6f75 7428 290a 2020 2020  ht_layout().    
+000080f0: 2020 2020 706c 742e 7361 7665 6669 6728      plt.savefig(
+00008100: 6669 6c65 6e61 6d65 2c20 2a2a 6b77 6172  filename, **kwar
+00008110: 6773 290a 0a20 2020 2040 7072 6f70 6572  gs)..    @proper
+00008120: 7479 0a20 2020 2064 6566 2076 6172 6961  ty.    def varia
+00008130: 626c 655f 6178 6973 2873 656c 6629 202d  ble_axis(self) -
+00008140: 3e20 4178 6973 3a0a 2020 2020 2020 2020  > Axis:.        
+00008150: 2222 2254 6865 2061 7869 7320 7468 6174  """The axis that
+00008160: 2069 7320 7661 7279 696e 672e 0a0a 2020   is varying...  
+00008170: 2020 2020 2020 5468 6572 6520 6172 6520        There are 
+00008180: 6669 7665 2074 7970 6573 206f 6620 696d  five types of im
+00008190: 6167 6573 3a0a 0a20 2020 2020 2020 202a  ages:..        *
+000081a0: 2052 6566 6572 656e 6365 203a 2041 6c6c   Reference : All
+000081b0: 2061 7865 7320 6172 6520 6174 2030 2e0a   axes are at 0..
+000081c0: 2020 2020 2020 2020 2a20 4761 6e74 7279          * Gantry
+000081d0: 3a20 416c 6c20 6178 6573 2062 7574 2067  : All axes but g
+000081e0: 616e 7472 7920 6174 2030 2e0a 2020 2020  antry at 0..    
+000081f0: 2020 2020 2a20 436f 6c6c 696d 6174 6f72      * Collimator
+00008200: 203a 2041 6c6c 2061 7865 7320 6275 7420   : All axes but 
+00008210: 636f 6c6c 696d 6174 6f72 2061 7420 302e  collimator at 0.
+00008220: 0a20 2020 2020 2020 202a 2043 6f75 6368  .        * Couch
+00008230: 203a 2041 6c6c 2061 7865 7320 6275 7420   : All axes but 
+00008240: 636f 7563 6820 6174 2030 2e0a 2020 2020  couch at 0..    
+00008250: 2020 2020 2a20 436f 6d62 6f20 3a20 4d6f      * Combo : Mo
+00008260: 7265 2074 6861 6e20 6f6e 6520 6178 6973  re than one axis
+00008270: 2069 7320 6e6f 7420 6174 2030 2e0a 2020   is not at 0..  
+00008280: 2020 2020 2020 2222 220a 2020 2020 2020        """.      
+00008290: 2020 4730 203d 2069 735f 636c 6f73 6528    G0 = is_close(
+000082a0: 7365 6c66 2e67 616e 7472 795f 616e 676c  self.gantry_angl
+000082b0: 652c 205b 302c 2033 3630 5d29 0a20 2020  e, [0, 360]).   
+000082c0: 2020 2020 2042 3020 3d20 6973 5f63 6c6f       B0 = is_clo
+000082d0: 7365 2873 656c 662e 636f 6c6c 696d 6174  se(self.collimat
+000082e0: 6f72 5f61 6e67 6c65 2c20 5b30 2c20 3336  or_angle, [0, 36
+000082f0: 305d 290a 2020 2020 2020 2020 5030 203d  0]).        P0 =
+00008300: 2069 735f 636c 6f73 6528 7365 6c66 2e63   is_close(self.c
+00008310: 6f75 6368 5f61 6e67 6c65 2c20 5b30 2c20  ouch_angle, [0, 
+00008320: 3336 305d 290a 2020 2020 2020 2020 6966  360]).        if
+00008330: 2047 3020 616e 6420 4230 2061 6e64 206e   G0 and B0 and n
+00008340: 6f74 2050 303a 0a20 2020 2020 2020 2020  ot P0:.         
+00008350: 2020 2072 6574 7572 6e20 4178 6973 2e43     return Axis.C
+00008360: 4f55 4348 0a20 2020 2020 2020 2065 6c69  OUCH.        eli
+00008370: 6620 4730 2061 6e64 2050 3020 616e 6420  f G0 and P0 and 
+00008380: 6e6f 7420 4230 3a0a 2020 2020 2020 2020  not B0:.        
+00008390: 2020 2020 7265 7475 726e 2041 7869 732e      return Axis.
+000083a0: 434f 4c4c 494d 4154 4f52 0a20 2020 2020  COLLIMATOR.     
+000083b0: 2020 2065 6c69 6620 5030 2061 6e64 2042     elif P0 and B
+000083c0: 3020 616e 6420 6e6f 7420 4730 3a0a 2020  0 and not G0:.  
+000083d0: 2020 2020 2020 2020 2020 7265 7475 726e            return
+000083e0: 2041 7869 732e 4741 4e54 5259 0a20 2020   Axis.GANTRY.   
+000083f0: 2020 2020 2065 6c69 6620 5030 2061 6e64       elif P0 and
+00008400: 2042 3020 616e 6420 4730 3a0a 2020 2020   B0 and G0:.    
+00008410: 2020 2020 2020 2020 7265 7475 726e 2041          return A
+00008420: 7869 732e 5245 4645 5245 4e43 450a 2020  xis.REFERENCE.  
+00008430: 2020 2020 2020 656c 6966 2050 303a 0a20        elif P0:. 
+00008440: 2020 2020 2020 2020 2020 2072 6574 7572             retur
+00008450: 6e20 4178 6973 2e47 425f 434f 4d42 4f0a  n Axis.GB_COMBO.
+00008460: 2020 2020 2020 2020 656c 7365 3a0a 2020          else:.  
+00008470: 2020 2020 2020 2020 2020 7265 7475 726e            return
+00008480: 2041 7869 732e 4742 505f 434f 4d42 4f0a   Axis.GBP_COMBO.
+00008490: 0a20 2020 2064 6566 205f 6765 6e65 7261  .    def _genera
+000084a0: 7465 5f72 6573 756c 7473 5f64 6174 6128  te_results_data(
+000084b0: 7365 6c66 2920 2d3e 2057 696e 7374 6f6e  self) -> Winston
+000084c0: 4c75 747a 3244 5265 7375 6c74 3a0a 2020  Lutz2DResult:.  
+000084d0: 2020 2020 2020 2222 2250 7265 7365 6e74        """Present
+000084e0: 2074 6865 2072 6573 756c 7473 2064 6174   the results dat
+000084f0: 6120 616e 6420 6d65 7461 6461 7461 2061  a and metadata a
+00008500: 7320 6120 6461 7461 636c 6173 7320 6f72  s a dataclass or
+00008510: 2064 6963 742e 0a20 2020 2020 2020 2054   dict..        T
+00008520: 6865 2064 6566 6175 6c74 2072 6574 7572  he default retur
+00008530: 6e20 7479 7065 2069 7320 6120 6461 7461  n type is a data
+00008540: 636c 6173 732e 2222 220a 2020 2020 2020  class.""".      
+00008550: 2020 6966 206e 6f74 2073 656c 662e 5f69    if not self._i
+00008560: 735f 616e 616c 797a 6564 3a0a 2020 2020  s_analyzed:.    
+00008570: 2020 2020 2020 2020 7261 6973 6520 5661          raise Va
+00008580: 6c75 6545 7272 6f72 2822 5468 6520 696d  lueError("The im
+00008590: 6167 6520 6973 206e 6f74 2061 6e61 6c79  age is not analy
+000085a0: 7a65 642e 2055 7365 202e 616e 616c 797a  zed. Use .analyz
+000085b0: 6528 2920 6669 7273 742e 2229 0a0a 2020  e() first.")..  
+000085c0: 2020 2020 2020 7265 7475 726e 2057 696e        return Win
+000085d0: 7374 6f6e 4c75 747a 3244 5265 7375 6c74  stonLutz2DResult
+000085e0: 280a 2020 2020 2020 2020 2020 2020 7661  (.            va
+000085f0: 7269 6162 6c65 5f61 7869 733d 7365 6c66  riable_axis=self
+00008600: 2e76 6172 6961 626c 655f 6178 6973 2e76  .variable_axis.v
+00008610: 616c 7565 2c0a 2020 2020 2020 2020 2020  alue,.          
+00008620: 2020 6361 7832 6262 5f76 6563 746f 723d    cax2bb_vector=
+00008630: 7365 6c66 2e63 6178 3262 625f 7665 6374  self.cax2bb_vect
+00008640: 6f72 2c0a 2020 2020 2020 2020 2020 2020  or,.            
+00008650: 6361 7832 6570 6964 5f76 6563 746f 723d  cax2epid_vector=
+00008660: 7365 6c66 2e63 6178 3265 7069 645f 7665  self.cax2epid_ve
+00008670: 6374 6f72 2c0a 2020 2020 2020 2020 2020  ctor,.          
+00008680: 2020 6361 7832 6262 5f64 6973 7461 6e63    cax2bb_distanc
+00008690: 653d 7365 6c66 2e63 6178 3262 625f 6469  e=self.cax2bb_di
+000086a0: 7374 616e 6365 2c0a 2020 2020 2020 2020  stance,.        
+000086b0: 2020 2020 6361 7832 6570 6964 5f64 6973      cax2epid_dis
+000086c0: 7461 6e63 653d 7365 6c66 2e63 6178 3265  tance=self.cax2e
+000086d0: 7069 645f 6469 7374 616e 6365 2c0a 2020  pid_distance,.  
+000086e0: 2020 2020 2020 2020 2020 6262 5f6c 6f63            bb_loc
+000086f0: 6174 696f 6e3d 7365 6c66 2e62 622c 0a20  ation=self.bb,. 
+00008700: 2020 2020 2020 2020 2020 2066 6965 6c64             field
+00008710: 5f63 6178 3d73 656c 662e 6669 656c 645f  _cax=self.field_
+00008720: 6361 782c 0a20 2020 2020 2020 2029 0a0a  cax,.        )..
+00008730: 0a63 6c61 7373 2057 696e 7374 6f6e 4c75  .class WinstonLu
+00008740: 747a 2852 6573 756c 7473 4461 7461 4d69  tz(ResultsDataMi
+00008750: 7869 6e5b 5769 6e73 746f 6e4c 7574 7a52  xin[WinstonLutzR
+00008760: 6573 756c 745d 293a 0a20 2020 2022 2222  esult]):.    """
+00008770: 436c 6173 7320 666f 7220 7065 7266 6f72  Class for perfor
+00008780: 6d69 6e67 2061 2057 696e 7374 6f6e 2d4c  ming a Winston-L
+00008790: 7574 7a20 7465 7374 206f 6620 7468 6520  utz test of the 
+000087a0: 7261 6469 6174 696f 6e20 6973 6f63 656e  radiation isocen
+000087b0: 7465 722e 2222 220a 0a20 2020 2069 6d61  ter."""..    ima
+000087c0: 6765 733a 206c 6973 745b 5769 6e73 746f  ges: list[Winsto
+000087d0: 6e4c 7574 7a32 445d 2020 233a 0a20 2020  nLutz2D]  #:.   
+000087e0: 206d 6163 6869 6e65 5f73 6361 6c65 3a20   machine_scale: 
+000087f0: 4d61 6368 696e 6553 6361 6c65 2020 233a  MachineScale  #:
+00008800: 0a20 2020 2069 6d61 6765 5f74 7970 6520  .    image_type 
+00008810: 3d20 5769 6e73 746f 6e4c 7574 7a32 440a  = WinstonLutz2D.
+00008820: 2020 2020 6262 3a20 4242 3344 2020 2320      bb: BB3D  # 
+00008830: 3344 2072 6570 7265 7365 6e74 6174 696f  3D representatio
+00008840: 6e20 6f66 2074 6865 2042 423b 2074 6865  n of the BB; the
+00008850: 7265 2069 7320 6120 2e62 6220 6f62 6a65  re is a .bb obje
+00008860: 6374 2066 6f72 2032 4420 696d 6167 6573  ct for 2D images
+00008870: 2062 7574 2069 7320 6120 3244 2072 6570   but is a 2D rep
+00008880: 7265 7365 6e74 6174 696f 6e0a 2020 2020  resentation.    
+00008890: 6973 5f66 726f 6d5f 6362 6374 3a20 626f  is_from_cbct: bo
+000088a0: 6f6c 203d 2046 616c 7365 0a20 2020 205f  ol = False.    _
+000088b0: 6262 5f64 6961 6d65 7465 723a 2066 6c6f  bb_diameter: flo
+000088c0: 6174 0a20 2020 205f 7669 7274 7561 6c5f  at.    _virtual_
+000088d0: 7368 6966 743a 2073 7472 207c 204e 6f6e  shift: str | Non
+000088e0: 6520 3d20 4e6f 6e65 0a20 2020 2064 6574  e = None.    det
+000088f0: 6563 7469 6f6e 5f63 6f6e 6469 7469 6f6e  ection_condition
+00008900: 733a 206c 6973 745b 6361 6c6c 6162 6c65  s: list[callable
+00008910: 5d20 3d20 5b0a 2020 2020 2020 2020 6973  ] = [.        is
+00008920: 5f72 6967 6874 5f73 697a 655f 6262 2c0a  _right_size_bb,.
+00008930: 2020 2020 2020 2020 6973 5f72 6f75 6e64          is_round
+00008940: 2c0a 2020 2020 2020 2020 6973 5f72 6967  ,.        is_rig
+00008950: 6874 5f63 6972 6375 6d66 6572 656e 6365  ht_circumference
+00008960: 2c0a 2020 2020 2020 2020 6973 5f73 796d  ,.        is_sym
+00008970: 6d65 7472 6963 2c0a 2020 2020 2020 2020  metric,.        
+00008980: 6973 5f73 6f6c 6964 2c0a 2020 2020 5d0a  is_solid,.    ].
+00008990: 0a20 2020 2064 6566 205f 5f69 6e69 745f  .    def __init_
+000089a0: 5f28 0a20 2020 2020 2020 2073 656c 662c  _(.        self,
+000089b0: 0a20 2020 2020 2020 2064 6972 6563 746f  .        directo
+000089c0: 7279 3a20 7374 7220 7c20 6c69 7374 5b73  ry: str | list[s
+000089d0: 7472 5d20 7c20 5061 7468 2c0a 2020 2020  tr] | Path,.    
+000089e0: 2020 2020 7573 655f 6669 6c65 6e61 6d65      use_filename
+000089f0: 733a 2062 6f6f 6c20 3d20 4661 6c73 652c  s: bool = False,
+00008a00: 0a20 2020 2020 2020 2061 7869 735f 6d61  .        axis_ma
+00008a10: 7070 696e 673a 2064 6963 745b 7374 722c  pping: dict[str,
+00008a20: 2074 7570 6c65 5b69 6e74 2c20 696e 742c   tuple[int, int,
+00008a30: 2069 6e74 5d5d 207c 204e 6f6e 6520 3d20   int]] | None = 
+00008a40: 4e6f 6e65 2c0a 2020 2020 2020 2020 6178  None,.        ax
+00008a50: 6573 5f70 7265 6369 7369 6f6e 3a20 696e  es_precision: in
+00008a60: 7420 7c20 4e6f 6e65 203d 204e 6f6e 652c  t | None = None,
+00008a70: 0a20 2020 2020 2020 2064 7069 3a20 666c  .        dpi: fl
+00008a80: 6f61 7420 7c20 4e6f 6e65 203d 204e 6f6e  oat | None = Non
+00008a90: 652c 0a20 2020 2020 2020 2073 6964 3a20  e,.        sid: 
+00008aa0: 666c 6f61 7420 7c20 4e6f 6e65 203d 204e  float | None = N
+00008ab0: 6f6e 652c 0a20 2020 2029 3a0a 2020 2020  one,.    ):.    
+00008ac0: 2020 2020 2222 220a 2020 2020 2020 2020      """.        
+00008ad0: 5061 7261 6d65 7465 7273 0a20 2020 2020  Parameters.     
+00008ae0: 2020 202d 2d2d 2d2d 2d2d 2d2d 2d0a 2020     ----------.  
+00008af0: 2020 2020 2020 6469 7265 6374 6f72 7920        directory 
+00008b00: 3a20 7374 722c 206c 6973 745b 7374 725d  : str, list[str]
+00008b10: 0a20 2020 2020 2020 2020 2020 2050 6174  .            Pat
+00008b20: 6820 746f 2074 6865 2064 6972 6563 746f  h to the directo
+00008b30: 7279 206f 6620 7468 6520 5769 6e73 746f  ry of the Winsto
+00008b40: 6e2d 4c75 747a 2045 5049 4420 696d 6167  n-Lutz EPID imag
+00008b50: 6573 206f 7220 6120 6c69 7374 206f 6620  es or a list of 
+00008b60: 7468 6520 696d 6167 6520 7061 7468 730a  the image paths.
+00008b70: 2020 2020 2020 2020 7573 655f 6669 6c65          use_file
+00008b80: 6e61 6d65 733a 2062 6f6f 6c0a 2020 2020  names: bool.    
+00008b90: 2020 2020 2020 2020 5768 6574 6865 7220          Whether 
+00008ba0: 746f 2074 7279 2074 6f20 7573 6520 7468  to try to use th
+00008bb0: 6520 6669 6c65 206e 616d 6520 746f 2064  e file name to d
+00008bc0: 6574 6572 6d69 6e65 2061 7869 7320 7661  etermine axis va
+00008bd0: 6c75 6573 2e0a 2020 2020 2020 2020 2020  lues..          
+00008be0: 2020 5573 6566 756c 2066 6f72 2045 6c65    Useful for Ele
+00008bf0: 6b74 6120 6d61 6368 696e 6573 2074 6861  kta machines tha
+00008c00: 7420 646f 206e 6f74 2069 6e63 6c75 6465  t do not include
+00008c10: 2074 6861 7420 696e 666f 2069 6e20 7468   that info in th
+00008c20: 6520 4449 434f 4d20 6461 7461 2e0a 2020  e DICOM data..  
+00008c30: 2020 2020 2020 2020 2020 5468 6973 2069            This i
+00008c40: 7320 6d75 7475 616c 6c79 2065 7863 6c75  s mutually exclu
+00008c50: 7369 7665 2074 6f20 6178 6973 5f6d 6170  sive to axis_map
+00008c60: 7069 6e67 2e20 4966 2054 7275 652c 2061  ping. If True, a
+00008c70: 7869 735f 6d61 7070 696e 6720 6973 2069  xis_mapping is i
+00008c80: 676e 6f72 6564 2e0a 2020 2020 2020 2020  gnored..        
+00008c90: 6178 6973 5f6d 6170 7069 6e67 3a20 6469  axis_mapping: di
+00008ca0: 6374 0a20 2020 2020 2020 2020 2020 2041  ct.            A
+00008cb0: 6e20 6f70 7469 6f6e 616c 2077 6179 206f  n optional way o
+00008cc0: 6620 696e 7374 616e 7469 6174 696e 6720  f instantiating 
+00008cd0: 6279 2070 6173 7369 6e67 2065 6163 6820  by passing each 
+00008ce0: 6669 6c65 2061 6c6f 6e67 2077 6974 6820  file along with 
+00008cf0: 7468 6520 6178 6973 2076 616c 7565 732e  the axis values.
+00008d00: 0a20 2020 2020 2020 2020 2020 2053 7472  .            Str
+00008d10: 7563 7475 7265 2073 686f 756c 6420 6265  ucture should be
+00008d20: 203c 6669 6c65 6e61 6d65 3e3a 2028 3c67   <filename>: (<g
+00008d30: 616e 7472 793e 2c20 3c63 6f6c 6c3e 2c20  antry>, <coll>, 
+00008d40: 3c63 6f75 6368 3e29 2e0a 2020 2020 2020  <couch>)..      
+00008d50: 2020 6178 6573 5f70 7265 6369 7369 6f6e    axes_precision
+00008d60: 3a20 696e 7420 7c20 4e6f 6e65 0a20 2020  : int | None.   
+00008d70: 2020 2020 2020 2020 2048 6f77 206d 616e           How man
+00008d80: 7920 7369 676e 6966 6963 616e 7420 6469  y significant di
+00008d90: 6769 7473 2074 6f20 7265 7072 6573 656e  gits to represen
+00008da0: 7420 7468 6520 6178 6573 2076 616c 7565  t the axes value
+00008db0: 732e 2049 6620 4e6f 6e65 2c20 6e6f 2070  s. If None, no p
+00008dc0: 7265 6369 7369 6f6e 2069 7320 7365 7420  recision is set 
+00008dd0: 616e 6420 7468 6520 696e 7075 742f 4449  and the input/DI
+00008de0: 434f 4d20 7661 6c75 6573 2061 7265 2075  COM values are u
+00008df0: 7365 6420 7261 772e 0a20 2020 2020 2020  sed raw..       
+00008e00: 2020 2020 2049 6620 7365 7420 746f 2061       If set to a
+00008e10: 6e20 696e 7465 6765 722c 2072 6f75 6e64  n integer, round
+00008e20: 7320 7468 6520 6178 6573 2076 616c 7565  s the axes value
+00008e30: 7320 2867 616e 7472 792c 2063 6f6c 6c2c  s (gantry, coll,
+00008e40: 2063 6f75 6368 2920 746f 2074 6861 7420   couch) to that 
+00008e50: 6d61 6e79 2076 616c 7565 732e 2045 2e67  many values. E.g
+00008e60: 2e20 6761 6e74 7279 3d30 2e31 3233 3420  . gantry=0.1234 
+00008e70: 3d3e 2030 2e31 2077 6974 6820 7072 6563  => 0.1 with prec
+00008e80: 6973 696f 6e3d 312e 0a20 2020 2020 2020  ision=1..       
+00008e90: 2020 2020 2054 6869 7320 6973 206d 6f73       This is mos
+00008ea0: 746c 7920 7573 6566 756c 2066 6f72 2070  tly useful for p
+00008eb0: 6c6f 7474 696e 672f 726f 756e 6469 6e67  lotting/rounding
+00008ec0: 2028 3335 392e 393d 3e30 2920 616e 6420   (359.9=>0) and 
+00008ed0: 6966 2075 7369 6e67 2074 6865 2060 606b  if using the ``k
+00008ee0: 6579 6564 5f69 6d61 6765 5f64 6574 6169  eyed_image_detai
+00008ef0: 6c73 6060 2077 6974 6820 6060 7265 7375  ls`` with ``resu
+00008f00: 6c74 735f 6461 7461 6060 2e0a 2020 2020  lts_data``..    
+00008f10: 2020 2020 6470 690a 2020 2020 2020 2020      dpi.        
+00008f20: 2020 2020 5468 6520 646f 7473 2d70 6572      The dots-per
+00008f30: 2d69 6e63 6820 7365 7474 696e 672e 204f  -inch setting. O
+00008f40: 6e6c 7920 6e65 6564 6564 2069 6620 7573  nly needed if us
+00008f50: 696e 6720 5449 4646 2069 6d61 6765 7320  ing TIFF images 
+00008f60: 616e 6420 7468 6520 696d 6167 6573 2064  and the images d
+00008f70: 6f20 6e6f 7420 636f 6e74 6169 6e20 7468  o not contain th
+00008f80: 6520 7265 736f 6c75 7469 6f6e 2074 6167  e resolution tag
+00008f90: 2e0a 2020 2020 2020 2020 2020 2020 416e  ..            An
+00008fa0: 2065 7272 6f72 2077 696c 6c20 7261 6973   error will rais
+00008fb0: 6520 6966 2064 7069 2069 7320 6e6f 7420  e if dpi is not 
+00008fc0: 7061 7373 6564 2061 6e64 2074 6865 2054  passed and the T
+00008fd0: 4946 4620 7265 736f 6c75 7469 6f6e 2063  IFF resolution c
+00008fe0: 616e 6e6f 7420 6265 2064 6574 6572 6d69  annot be determi
+00008ff0: 6e65 642e 0a20 2020 2020 2020 2073 6964  ned..        sid
+00009000: 0a20 2020 2020 2020 2020 2020 2054 6865  .            The
+00009010: 2053 6f75 7263 652d 746f 2d49 6d61 6765   Source-to-Image
+00009020: 2064 6973 7461 6e63 6520 696e 206d 6d2e   distance in mm.
+00009030: 204f 6e6c 7920 6e65 6564 6564 2077 6865   Only needed whe
+00009040: 6e20 7573 696e 6720 5449 4646 2069 6d61  n using TIFF ima
+00009050: 6765 732e 0a20 2020 2020 2020 2022 2222  ges..        """
+00009060: 0a20 2020 2020 2020 2073 656c 662e 696d  .        self.im
+00009070: 6167 6573 203d 205b 5d0a 2020 2020 2020  ages = [].      
+00009080: 2020 6966 2061 7869 735f 6d61 7070 696e    if axis_mappin
+00009090: 6720 616e 6420 6e6f 7420 7573 655f 6669  g and not use_fi
+000090a0: 6c65 6e61 6d65 733a 0a20 2020 2020 2020  lenames:.       
+000090b0: 2020 2020 2066 6f72 2066 696c 656e 616d       for filenam
+000090c0: 652c 2028 6761 6e74 7279 2c20 636f 6c6c  e, (gantry, coll
+000090d0: 2c20 636f 7563 6829 2069 6e20 6178 6973  , couch) in axis
+000090e0: 5f6d 6170 7069 6e67 2e69 7465 6d73 2829  _mapping.items()
+000090f0: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+00009100: 2020 7365 6c66 2e69 6d61 6765 732e 6170    self.images.ap
+00009110: 7065 6e64 280a 2020 2020 2020 2020 2020  pend(.          
+00009120: 2020 2020 2020 2020 2020 7365 6c66 2e5f            self._
+00009130: 6c6f 6164 5f69 6d61 6765 280a 2020 2020  load_image(.    
+00009140: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009150: 2020 2020 5061 7468 2864 6972 6563 746f      Path(directo
+00009160: 7279 2920 2f20 6669 6c65 6e61 6d65 2c0a  ry) / filename,.
+00009170: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009180: 2020 2020 2020 2020 7369 643d 7369 642c          sid=sid,
+00009190: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+000091a0: 2020 2020 2020 2020 2064 7069 3d64 7069           dpi=dpi
+000091b0: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+000091c0: 2020 2020 2020 2020 2020 6761 6e74 7279            gantry
+000091d0: 3d67 616e 7472 792c 0a20 2020 2020 2020  =gantry,.       
+000091e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000091f0: 2063 6f6c 6c3d 636f 6c6c 2c0a 2020 2020   coll=coll,.    
+00009200: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009210: 2020 2020 636f 7563 683d 636f 7563 682c      couch=couch,
+00009220: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00009230: 2020 2020 2020 2020 2061 7865 735f 7072           axes_pr
+00009240: 6563 6973 696f 6e3d 6178 6573 5f70 7265  ecision=axes_pre
+00009250: 6369 7369 6f6e 2c0a 2020 2020 2020 2020  cision,.        
+00009260: 2020 2020 2020 2020 2020 2020 290a 2020              ).  
+00009270: 2020 2020 2020 2020 2020 2020 2020 290a                ).
+00009280: 2020 2020 2020 2020 656c 6966 2069 7369          elif isi
+00009290: 6e73 7461 6e63 6528 6469 7265 6374 6f72  nstance(director
+000092a0: 792c 206c 6973 7429 3a0a 2020 2020 2020  y, list):.      
+000092b0: 2020 2020 2020 666f 7220 6669 6c65 2069        for file i
+000092c0: 6e20 6469 7265 6374 6f72 793a 0a20 2020  n directory:.   
+000092d0: 2020 2020 2020 2020 2020 2020 2069 6620               if 
+000092e0: 6973 5f69 6d61 6765 2866 696c 6529 3a0a  is_image(file):.
+000092f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009300: 2020 2020 7365 6c66 2e69 6d61 6765 732e      self.images.
+00009310: 6170 7065 6e64 280a 2020 2020 2020 2020  append(.        
+00009320: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009330: 7365 6c66 2e5f 6c6f 6164 5f69 6d61 6765  self._load_image
+00009340: 280a 2020 2020 2020 2020 2020 2020 2020  (.              
+00009350: 2020 2020 2020 2020 2020 2020 2020 6669                fi
+00009360: 6c65 2c0a 2020 2020 2020 2020 2020 2020  le,.            
+00009370: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009380: 6470 693d 6470 692c 0a20 2020 2020 2020  dpi=dpi,.       
+00009390: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000093a0: 2020 2020 2073 6964 3d73 6964 2c0a 2020       sid=sid,.  
+000093b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000093c0: 2020 2020 2020 2020 2020 7573 655f 6669            use_fi
+000093d0: 6c65 6e61 6d65 733d 7573 655f 6669 6c65  lenames=use_file
+000093e0: 6e61 6d65 732c 0a20 2020 2020 2020 2020  names,.         
+000093f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009400: 2020 2061 7865 735f 7072 6563 6973 696f     axes_precisio
+00009410: 6e3d 6178 6573 5f70 7265 6369 7369 6f6e  n=axes_precision
+00009420: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+00009430: 2020 2020 2020 2020 2020 290a 2020 2020            ).    
+00009440: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009450: 290a 2020 2020 2020 2020 656c 6966 206e  ).        elif n
+00009460: 6f74 206f 7370 2e69 7364 6972 2864 6972  ot osp.isdir(dir
+00009470: 6563 746f 7279 293a 0a20 2020 2020 2020  ectory):.       
+00009480: 2020 2020 2072 6169 7365 2056 616c 7565       raise Value
+00009490: 4572 726f 7228 0a20 2020 2020 2020 2020  Error(.         
+000094a0: 2020 2020 2020 2022 496e 7661 6c69 6420         "Invalid 
+000094b0: 6469 7265 6374 6f72 7920 7061 7373 6564  directory passed
+000094c0: 2e20 4368 6563 6b20 7468 6520 636f 7272  . Check the corr
+000094d0: 6563 7420 6d65 7468 6f64 2061 6e64 2066  ect method and f
+000094e0: 696c 6520 7761 7320 7573 6564 2e22 0a20  ile was used.". 
+000094f0: 2020 2020 2020 2020 2020 2029 0a20 2020             ).   
+00009500: 2020 2020 2065 6c73 653a 0a20 2020 2020       else:.     
+00009510: 2020 2020 2020 2069 6d61 6765 5f66 696c         image_fil
+00009520: 6573 203d 2069 6d61 6765 2e72 6574 7269  es = image.retri
+00009530: 6576 655f 696d 6167 655f 6669 6c65 7328  eve_image_files(
+00009540: 6469 7265 6374 6f72 7929 0a20 2020 2020  directory).     
+00009550: 2020 2020 2020 2066 6f72 2066 696c 6520         for file 
+00009560: 696e 2069 6d61 6765 5f66 696c 6573 3a0a  in image_files:.
+00009570: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009580: 7365 6c66 2e69 6d61 6765 732e 6170 7065  self.images.appe
+00009590: 6e64 280a 2020 2020 2020 2020 2020 2020  nd(.            
+000095a0: 2020 2020 2020 2020 7365 6c66 2e5f 6c6f          self._lo
+000095b0: 6164 5f69 6d61 6765 280a 2020 2020 2020  ad_image(.      
+000095c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000095d0: 2020 6669 6c65 2c0a 2020 2020 2020 2020    file,.        
+000095e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000095f0: 6470 693d 6470 692c 0a20 2020 2020 2020  dpi=dpi,.       
+00009600: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009610: 2073 6964 3d73 6964 2c0a 2020 2020 2020   sid=sid,.      
+00009620: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009630: 2020 7573 655f 6669 6c65 6e61 6d65 733d    use_filenames=
+00009640: 7573 655f 6669 6c65 6e61 6d65 732c 0a20  use_filenames,. 
+00009650: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009660: 2020 2020 2020 2061 7865 735f 7072 6563         axes_prec
+00009670: 6973 696f 6e3d 6178 6573 5f70 7265 6369  ision=axes_preci
+00009680: 7369 6f6e 2c0a 2020 2020 2020 2020 2020  sion,.          
+00009690: 2020 2020 2020 2020 2020 290a 2020 2020            ).    
+000096a0: 2020 2020 2020 2020 2020 2020 290a 2020              ).  
+000096b0: 2020 2020 2020 6966 206c 656e 2873 656c        if len(sel
+000096c0: 662e 696d 6167 6573 2920 3c20 323a 0a20  f.images) < 2:. 
+000096d0: 2020 2020 2020 2020 2020 2072 6169 7365             raise
+000096e0: 2056 616c 7565 4572 726f 7228 0a20 2020   ValueError(.   
+000096f0: 2020 2020 2020 2020 2020 2020 2022 3c32               "<2
+00009700: 2076 616c 6964 2057 4c20 696d 6167 6573   valid WL images
+00009710: 2077 6572 6520 666f 756e 6420 696e 2074   were found in t
+00009720: 6865 2066 6f6c 6465 722f 6669 6c65 206f  he folder/file o
+00009730: 7220 7061 7373 6564 2e20 456e 7375 7265  r passed. Ensure
+00009740: 2079 6f75 2063 686f 7365 2074 6865 2063   you chose the c
+00009750: 6f72 7265 6374 2066 6f6c 6465 722f 6669  orrect folder/fi
+00009760: 6c65 2066 6f72 2061 6e61 6c79 7369 732e  le for analysis.
+00009770: 220a 2020 2020 2020 2020 2020 2020 290a  ".            ).
+00009780: 2020 2020 2020 2020 7365 6c66 2e69 6d61          self.ima
+00009790: 6765 732e 736f 7274 280a 2020 2020 2020  ges.sort(.      
+000097a0: 2020 2020 2020 6b65 793d 6c61 6d62 6461        key=lambda
+000097b0: 2069 3a20 2869 2e67 616e 7472 795f 616e   i: (i.gantry_an
+000097c0: 676c 652c 2069 2e63 6f6c 6c69 6d61 746f  gle, i.collimato
+000097d0: 725f 616e 676c 652c 2069 2e63 6f75 6368  r_angle, i.couch
+000097e0: 5f61 6e67 6c65 290a 2020 2020 2020 2020  _angle).        
+000097f0: 290a 2020 2020 2020 2020 7365 6c66 2e5f  ).        self._
+00009800: 6973 5f61 6e61 6c79 7a65 6420 3d20 4661  is_analyzed = Fa
+00009810: 6c73 650a 0a20 2020 2064 6566 205f 6c6f  lse..    def _lo
+00009820: 6164 5f69 6d61 6765 280a 2020 2020 2020  ad_image(.      
+00009830: 2020 7365 6c66 2c0a 2020 2020 2020 2020    self,.        
+00009840: 6669 6c65 3a20 7374 7220 7c20 5061 7468  file: str | Path
+00009850: 2c0a 2020 2020 2020 2020 7369 643a 2066  ,.        sid: f
+00009860: 6c6f 6174 207c 204e 6f6e 652c 0a20 2020  loat | None,.   
+00009870: 2020 2020 2064 7069 3a20 666c 6f61 7420       dpi: float 
+00009880: 7c20 4e6f 6e65 2c0a 2020 2020 2020 2020  | None,.        
+00009890: 2a2a 6b77 6172 6773 2c0a 2020 2020 2920  **kwargs,.    ) 
+000098a0: 2d3e 2057 696e 7374 6f6e 4c75 747a 3244  -> WinstonLutz2D
+000098b0: 3a0a 2020 2020 2020 2020 2222 2241 2068  :.        """A h
+000098c0: 656c 7065 7220 6d65 7468 6f64 2074 6f20  elper method to 
+000098d0: 6c6f 6164 2065 6974 6865 7220 4449 434f  load either DICO
+000098e0: 4d20 6f72 2054 4946 4620 6669 6c65 7320  M or TIFF files 
+000098f0: 6170 7072 6f70 7269 6174 656c 792e 2222  appropriately.""
+00009900: 220a 2020 2020 2020 2020 7472 793a 0a20  ".        try:. 
+00009910: 2020 2020 2020 2020 2020 2072 6574 7572             retur
+00009920: 6e20 7365 6c66 2e69 6d61 6765 5f74 7970  n self.image_typ
+00009930: 6528 0a20 2020 2020 2020 2020 2020 2020  e(.             
+00009940: 2020 2066 696c 652c 2064 6574 6563 7469     file, detecti
+00009950: 6f6e 5f63 6f6e 6469 7469 6f6e 733d 7365  on_conditions=se
+00009960: 6c66 2e64 6574 6563 7469 6f6e 5f63 6f6e  lf.detection_con
+00009970: 6469 7469 6f6e 732c 202a 2a6b 7761 7267  ditions, **kwarg
+00009980: 730a 2020 2020 2020 2020 2020 2020 290a  s.            ).
+00009990: 2020 2020 2020 2020 6578 6365 7074 2041          except A
+000099a0: 7474 7269 6275 7465 4572 726f 723a 0a20  ttributeError:. 
+000099b0: 2020 2020 2020 2020 2020 2069 6620 6b77             if kw
+000099c0: 6172 6773 2e67 6574 2822 6761 6e74 7279  args.get("gantry
+000099d0: 2229 2069 7320 4e6f 6e65 3a0a 2020 2020  ") is None:.    
+000099e0: 2020 2020 2020 2020 2020 2020 7261 6973              rais
+000099f0: 6520 5661 6c75 6545 7272 6f72 280a 2020  e ValueError(.  
+00009a00: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009a10: 2020 2254 4946 4620 696d 6167 6573 2064    "TIFF images d
+00009a20: 6574 6563 7465 642e 204d 7573 7420 7061  etected. Must pa
+00009a30: 7373 2060 6178 6973 5f6d 6170 7069 6e67  ss `axis_mapping
+00009a40: 6020 7061 7261 6d65 7465 722e 220a 2020  ` parameter.".  
+00009a50: 2020 2020 2020 2020 2020 2020 2020 290a                ).
+00009a60: 2020 2020 2020 2020 2020 2020 6966 2073              if s
+00009a70: 6964 2069 7320 4e6f 6e65 3a0a 2020 2020  id is None:.    
+00009a80: 2020 2020 2020 2020 2020 2020 7261 6973              rais
+00009a90: 6520 5661 6c75 6545 7272 6f72 2822 5449  e ValueError("TI
+00009aa0: 4646 2069 6d61 6765 7320 6465 7465 6374  FF images detect
+00009ab0: 6564 2e20 4d75 7374 2070 6173 7320 6073  ed. Must pass `s
+00009ac0: 6964 6020 7061 7261 6d65 7465 7222 290a  id` parameter").
+00009ad0: 2020 2020 2020 2020 2020 2020 7769 7468              with
+00009ae0: 2069 6f2e 4279 7465 7349 4f28 2920 6173   io.BytesIO() as
+00009af0: 2073 7472 6561 6d3a 0a20 2020 2020 2020   stream:.       
+00009b00: 2020 2020 2020 2020 2064 7320 3d20 7469           ds = ti
+00009b10: 6666 5f74 6f5f 6469 636f 6d28 0a20 2020  ff_to_dicom(.   
+00009b20: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009b30: 2074 6966 665f 6669 6c65 3d66 696c 652c   tiff_file=file,
+00009b40: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00009b50: 2020 2020 2073 6964 3d73 6964 2c0a 2020       sid=sid,.  
+00009b60: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009b70: 2020 6470 693d 6470 692c 0a20 2020 2020    dpi=dpi,.     
+00009b80: 2020 2020 2020 2020 2020 2020 2020 2067                 g
+00009b90: 616e 7472 793d 6b77 6172 6773 2e70 6f70  antry=kwargs.pop
+00009ba0: 2822 6761 6e74 7279 2229 2c0a 2020 2020  ("gantry"),.    
+00009bb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009bc0: 636f 6c6c 3d6b 7761 7267 732e 706f 7028  coll=kwargs.pop(
+00009bd0: 2263 6f6c 6c22 292c 0a20 2020 2020 2020  "coll"),.       
+00009be0: 2020 2020 2020 2020 2020 2020 2063 6f75               cou
+00009bf0: 6368 3d6b 7761 7267 732e 706f 7028 2263  ch=kwargs.pop("c
+00009c00: 6f75 6368 2229 2c0a 2020 2020 2020 2020  ouch"),.        
+00009c10: 2020 2020 2020 2020 290a 2020 2020 2020          ).      
+00009c20: 2020 2020 2020 2020 2020 6473 2e73 6176            ds.sav
+00009c30: 655f 6173 2873 7472 6561 6d2c 2077 7269  e_as(stream, wri
+00009c40: 7465 5f6c 696b 655f 6f72 6967 696e 616c  te_like_original
+00009c50: 3d46 616c 7365 290a 2020 2020 2020 2020  =False).        
+00009c60: 2020 2020 2020 2020 696d 6720 3d20 7365          img = se
+00009c70: 6c66 2e69 6d61 6765 5f74 7970 6528 0a20  lf.image_type(. 
+00009c80: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009c90: 2020 2073 7472 6561 6d2c 2064 6574 6563     stream, detec
+00009ca0: 7469 6f6e 5f63 6f6e 6469 7469 6f6e 733d  tion_conditions=
+00009cb0: 7365 6c66 2e64 6574 6563 7469 6f6e 5f63  self.detection_c
+00009cc0: 6f6e 6469 7469 6f6e 732c 202a 2a6b 7761  onditions, **kwa
+00009cd0: 7267 730a 2020 2020 2020 2020 2020 2020  rgs.            
+00009ce0: 2020 2020 290a 2020 2020 2020 2020 2020      ).          
+00009cf0: 2020 2020 2020 6966 206e 6f74 2069 6d67        if not img
+00009d00: 2e64 706d 6d3a 0a20 2020 2020 2020 2020  .dpmm:.         
+00009d10: 2020 2020 2020 2020 2020 2072 6169 7365             raise
+00009d20: 2056 616c 7565 4572 726f 7228 0a20 2020   ValueError(.   
+00009d30: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009d40: 2020 2020 2022 5449 4646 2069 6d61 6765       "TIFF image
+00009d50: 7320 7765 7265 2064 6574 6563 7465 6420  s were detected 
+00009d60: 6275 7420 7468 6520 6470 6920 7461 6720  but the dpi tag 
+00009d70: 7761 7320 6e6f 7420 6176 6169 6c61 626c  was not availabl
+00009d80: 652e 2050 6173 7320 7468 6520 6064 7069  e. Pass the `dpi
+00009d90: 6020 7061 7261 6d65 7465 7220 6d61 6e75  ` parameter manu
+00009da0: 616c 6c79 2e22 0a20 2020 2020 2020 2020  ally.".         
+00009db0: 2020 2020 2020 2020 2020 2029 0a20 2020             ).   
+00009dc0: 2020 2020 2020 2020 2020 2020 2069 6d67               img
+00009dd0: 2e66 696c 7465 7228 7369 7a65 3d30 2e30  .filter(size=0.0
+00009de0: 312c 206b 696e 643d 226d 6564 6961 6e22  1, kind="median"
+00009df0: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
+00009e00: 2020 7265 7475 726e 2069 6d67 0a0a 2020    return img..  
+00009e10: 2020 4063 6c61 7373 6d65 7468 6f64 0a20    @classmethod. 
+00009e20: 2020 2064 6566 2066 726f 6d5f 6465 6d6f     def from_demo
+00009e30: 5f69 6d61 6765 7328 636c 732c 202a 2a6b  _images(cls, **k
+00009e40: 7761 7267 7329 3a0a 2020 2020 2020 2020  wargs):.        
+00009e50: 2222 2249 6e73 7461 6e74 6961 7465 2075  """Instantiate u
+00009e60: 7369 6e67 2074 6865 2064 656d 6f20 696d  sing the demo im
+00009e70: 6167 6573 2e0a 0a20 2020 2020 2020 2050  ages...        P
+00009e80: 6172 616d 6574 6572 730a 2020 2020 2020  arameters.      
+00009e90: 2020 2d2d 2d2d 2d2d 2d2d 2d2d 0a20 2020    ----------.   
+00009ea0: 2020 2020 206b 7761 7267 730a 2020 2020       kwargs.    
+00009eb0: 2020 2020 2020 2020 5365 6520 7061 7261          See para
+00009ec0: 6d65 7465 7273 206f 6620 7468 6520 5f5f  meters of the __
+00009ed0: 696e 6974 5f5f 206d 6574 686f 6420 666f  init__ method fo
+00009ee0: 7220 6465 7461 696c 732e 0a20 2020 2020  r details..     
+00009ef0: 2020 2022 2222 0a20 2020 2020 2020 2064     """.        d
+00009f00: 656d 6f5f 6669 6c65 203d 2072 6574 7269  emo_file = retri
+00009f10: 6576 655f 6465 6d6f 5f66 696c 6528 6e61  eve_demo_file(na
+00009f20: 6d65 3d22 7769 6e73 746f 6e5f 6c75 747a  me="winston_lutz
+00009f30: 2e7a 6970 2229 0a20 2020 2020 2020 2072  .zip").        r
+00009f40: 6574 7572 6e20 636c 732e 6672 6f6d 5f7a  eturn cls.from_z
+00009f50: 6970 2864 656d 6f5f 6669 6c65 2c20 2a2a  ip(demo_file, **
+00009f60: 6b77 6172 6773 290a 0a20 2020 2040 636c  kwargs)..    @cl
+00009f70: 6173 736d 6574 686f 640a 2020 2020 6465  assmethod.    de
+00009f80: 6620 6672 6f6d 5f7a 6970 2863 6c73 2c20  f from_zip(cls, 
+00009f90: 7a66 696c 653a 2073 7472 207c 2042 696e  zfile: str | Bin
+00009fa0: 6172 7949 4f20 7c20 5061 7468 2c20 2a2a  aryIO | Path, **
+00009fb0: 6b77 6172 6773 293a 0a20 2020 2020 2020  kwargs):.       
+00009fc0: 2022 2222 496e 7374 616e 7469 6174 6520   """Instantiate 
+00009fd0: 6672 6f6d 2061 207a 6970 2066 696c 6520  from a zip file 
+00009fe0: 7261 7468 6572 2074 6861 6e20 6120 6469  rather than a di
+00009ff0: 7265 6374 6f72 792e 0a0a 2020 2020 2020  rectory...      
+0000a000: 2020 5061 7261 6d65 7465 7273 0a20 2020    Parameters.   
+0000a010: 2020 2020 202d 2d2d 2d2d 2d2d 2d2d 2d0a       ----------.
+0000a020: 2020 2020 2020 2020 7a66 696c 650a 2020          zfile.  
+0000a030: 2020 2020 2020 2020 2020 5061 7468 2074            Path t
+0000a040: 6f20 7468 6520 6172 6368 6976 6520 6669  o the archive fi
+0000a050: 6c65 2e0a 2020 2020 2020 2020 6b77 6172  le..        kwar
+0000a060: 6773 0a20 2020 2020 2020 2020 2020 2053  gs.            S
+0000a070: 6565 2070 6172 616d 6574 6572 7320 6f66  ee parameters of
+0000a080: 2074 6865 205f 5f69 6e69 745f 5f20 6d65   the __init__ me
+0000a090: 7468 6f64 2066 6f72 2064 6574 6169 6c73  thod for details
+0000a0a0: 2e0a 2020 2020 2020 2020 2222 220a 2020  ..        """.  
+0000a0b0: 2020 2020 2020 7769 7468 2054 656d 706f        with Tempo
+0000a0c0: 7261 7279 5a69 7044 6972 6563 746f 7279  raryZipDirectory
+0000a0d0: 287a 6669 6c65 2920 6173 2074 6d70 7a3a  (zfile) as tmpz:
+0000a0e0: 0a20 2020 2020 2020 2020 2020 206f 626a  .            obj
+0000a0f0: 203d 2063 6c73 2874 6d70 7a2c 202a 2a6b   = cls(tmpz, **k
+0000a100: 7761 7267 7329 0a20 2020 2020 2020 2072  wargs).        r
+0000a110: 6574 7572 6e20 6f62 6a0a 0a20 2020 2040  eturn obj..    @
+0000a120: 636c 6173 736d 6574 686f 640a 2020 2020  classmethod.    
+0000a130: 6465 6620 6672 6f6d 5f75 726c 2863 6c73  def from_url(cls
+0000a140: 2c20 7572 6c3a 2073 7472 2c20 2a2a 6b77  , url: str, **kw
+0000a150: 6172 6773 293a 0a20 2020 2020 2020 2022  args):.        "
+0000a160: 2222 496e 7374 616e 7469 6174 6520 6672  ""Instantiate fr
+0000a170: 6f6d 2061 2055 524c 2e0a 0a20 2020 2020  om a URL...     
+0000a180: 2020 2050 6172 616d 6574 6572 730a 2020     Parameters.  
+0000a190: 2020 2020 2020 2d2d 2d2d 2d2d 2d2d 2d2d        ----------
+0000a1a0: 0a20 2020 2020 2020 2075 726c 203a 2073  .        url : s
+0000a1b0: 7472 0a20 2020 2020 2020 2020 2020 2055  tr.            U
+0000a1c0: 524c 2074 6861 7420 706f 696e 7473 2074  RL that points t
+0000a1d0: 6f20 6120 7a69 7020 6172 6368 6976 6520  o a zip archive 
+0000a1e0: 6f66 2074 6865 2044 4943 4f4d 2069 6d61  of the DICOM ima
+0000a1f0: 6765 732e 0a20 2020 2020 2020 206b 7761  ges..        kwa
+0000a200: 7267 730a 2020 2020 2020 2020 2020 2020  rgs.            
+0000a210: 5365 6520 7061 7261 6d65 7465 7273 206f  See parameters o
+0000a220: 6620 7468 6520 5f5f 696e 6974 5f5f 206d  f the __init__ m
+0000a230: 6574 686f 6420 666f 7220 6465 7461 696c  ethod for detail
+0000a240: 732e 0a20 2020 2020 2020 2022 2222 0a20  s..        """. 
+0000a250: 2020 2020 2020 207a 6669 6c65 203d 2067         zfile = g
+0000a260: 6574 5f75 726c 2875 726c 290a 2020 2020  et_url(url).    
+0000a270: 2020 2020 7265 7475 726e 2063 6c73 2e66      return cls.f
+0000a280: 726f 6d5f 7a69 7028 7a66 696c 652c 202a  rom_zip(zfile, *
+0000a290: 2a6b 7761 7267 7329 0a0a 2020 2020 4063  *kwargs)..    @c
+0000a2a0: 6c61 7373 6d65 7468 6f64 0a20 2020 2064  lassmethod.    d
+0000a2b0: 6566 2066 726f 6d5f 6362 6374 5f7a 6970  ef from_cbct_zip
+0000a2c0: 2863 6c73 2c20 6669 6c65 3a20 5061 7468  (cls, file: Path
+0000a2d0: 207c 2073 7472 2c20 7261 775f 7069 7865   | str, raw_pixe
+0000a2e0: 6c73 3a20 626f 6f6c 203d 2046 616c 7365  ls: bool = False
+0000a2f0: 2c20 2a2a 6b77 6172 6773 293a 0a20 2020  , **kwargs):.   
+0000a300: 2020 2020 2022 2222 496e 7374 616e 7469       """Instanti
+0000a310: 6174 6520 6672 6f6d 2061 207a 6970 2066  ate from a zip f
+0000a320: 696c 6520 636f 6e74 6169 6e69 6e67 2043  ile containing C
+0000a330: 4243 5420 696d 6167 6573 2e0a 0a20 2020  BCT images...   
+0000a340: 2020 2020 2050 6172 616d 6574 6572 730a       Parameters.
+0000a350: 2020 2020 2020 2020 2d2d 2d2d 2d2d 2d2d          --------
+0000a360: 2d2d 0a20 2020 2020 2020 2066 696c 650a  --.        file.
+0000a370: 2020 2020 2020 2020 2020 2020 5061 7468              Path
+0000a380: 2074 6f20 7468 6520 6172 6368 6976 6520   to the archive 
+0000a390: 6669 6c65 2e0a 2020 2020 2020 2020 7261  file..        ra
+0000a3a0: 775f 7069 7865 6c73 0a20 2020 2020 2020  w_pixels.       
+0000a3b0: 2020 2020 2049 6620 5472 7565 2c20 7573       If True, us
+0000a3c0: 6573 2074 6865 2072 6177 2070 6978 656c  es the raw pixel
+0000a3d0: 2076 616c 7565 7320 6f66 2074 6865 2044   values of the D
+0000a3e0: 4943 4f4d 2066 696c 6573 2e20 4966 2046  ICOM files. If F
+0000a3f0: 616c 7365 2c20 7573 6573 2074 6865 2072  alse, uses the r
+0000a400: 6573 6361 6c65 6420 486f 756e 7366 6965  escaled Hounsfie
+0000a410: 6c64 2075 6e69 7473 2e0a 2020 2020 2020  ld units..      
+0000a420: 2020 2020 2020 4765 6e65 7261 6c6c 792c        Generally,
+0000a430: 2074 6869 7320 7368 6f75 6c64 2062 6520   this should be 
+0000a440: 7472 7565 2e0a 2020 2020 2020 2020 6b77  true..        kw
+0000a450: 6172 6773 0a20 2020 2020 2020 2020 2020  args.           
+0000a460: 2053 6565 2070 6172 616d 6574 6572 7320   See parameters 
+0000a470: 6f66 2074 6865 205f 5f69 6e69 745f 5f20  of the __init__ 
+0000a480: 6d65 7468 6f64 2066 6f72 2064 6574 6169  method for detai
+0000a490: 6c73 2e0a 2020 2020 2020 2020 2222 220a  ls..        """.
+0000a4a0: 2020 2020 2020 2020 7769 7468 2054 656d          with Tem
+0000a4b0: 706f 7261 7279 5a69 7044 6972 6563 746f  poraryZipDirecto
+0000a4c0: 7279 2866 696c 6529 2061 7320 746d 707a  ry(file) as tmpz
+0000a4d0: 3a0a 2020 2020 2020 2020 2020 2020 6f62  :.            ob
+0000a4e0: 6a20 3d20 636c 732e 6672 6f6d 5f63 6263  j = cls.from_cbc
+0000a4f0: 7428 746d 707a 2c20 7261 775f 7069 7865  t(tmpz, raw_pixe
+0000a500: 6c73 3d72 6177 5f70 6978 656c 732c 202a  ls=raw_pixels, *
+0000a510: 2a6b 7761 7267 7329 0a20 2020 2020 2020  *kwargs).       
+0000a520: 2072 6574 7572 6e20 6f62 6a0a 0a20 2020   return obj..   
+0000a530: 2040 636c 6173 736d 6574 686f 640a 2020   @classmethod.  
+0000a540: 2020 6465 6620 6672 6f6d 5f63 6263 7428    def from_cbct(
+0000a550: 636c 732c 2064 6972 6563 746f 7279 3a20  cls, directory: 
+0000a560: 5061 7468 207c 2073 7472 2c20 7261 775f  Path | str, raw_
+0000a570: 7069 7865 6c73 3a20 626f 6f6c 203d 2046  pixels: bool = F
+0000a580: 616c 7365 2c20 2a2a 6b77 6172 6773 293a  alse, **kwargs):
+0000a590: 0a20 2020 2020 2020 2022 2222 4372 6561  .        """Crea
+0000a5a0: 7465 2061 2034 2d61 6e67 6c65 2057 4c20  te a 4-angle WL 
+0000a5b0: 7465 7374 2066 726f 6d20 6120 4342 4354  test from a CBCT
+0000a5c0: 2064 6174 6173 6574 2e0a 0a20 2020 2020   dataset...     
+0000a5d0: 2020 2054 6865 2064 6174 6173 6574 2069     The dataset i
+0000a5e0: 7320 6c6f 6164 6564 2061 6e64 2074 6865  s loaded and the
+0000a5f0: 2061 7272 6179 2069 7320 2276 6965 7765   array is "viewe
+0000a600: 6422 2066 726f 6d20 746f 702c 2062 6f74  d" from top, bot
+0000a610: 746f 6d2c 206c 6566 742c 2061 6e64 2072  tom, left, and r
+0000a620: 6967 6874 2074 6f20 6372 6561 7465 2074  ight to create t
+0000a630: 6865 2034 2061 6e67 6c65 732e 0a20 2020  he 4 angles..   
+0000a640: 2020 2020 2054 6865 2064 6174 6173 6574       The dataset
+0000a650: 2068 6173 2074 6f20 6265 2072 6573 6361   has to be resca
+0000a660: 6c65 6420 736f 2074 6861 7420 7468 6520  led so that the 
+0000a670: 7a2d 6178 6973 2073 7061 6369 6e67 2069  z-axis spacing i
+0000a680: 7320 6571 7561 6c20 746f 2074 6865 2078  s equal to the x
+0000a690: 2f79 2061 7869 732e 2054 6869 7320 6973  /y axis. This is
+0000a6a0: 2062 6563 6175 7365 2074 6865 0a20 2020   because the.   
+0000a6b0: 2020 2020 2074 7970 6963 616c 2073 6c69       typical sli
+0000a6c0: 6365 2074 6869 636b 6e65 7373 2069 7320  ce thickness is 
+0000a6d0: 6d75 6368 206c 6172 6765 7220 7468 616e  much larger than
+0000a6e0: 2074 6865 2069 6e2d 706c 616e 6520 7265   the in-plane re
+0000a6f0: 736f 6c75 7469 6f6e 2e0a 0a20 2020 2020  solution...     
+0000a700: 2020 2050 6172 616d 6574 6572 730a 2020     Parameters.  
+0000a710: 2020 2020 2020 2d2d 2d2d 2d2d 2d2d 2d2d        ----------
+0000a720: 0a20 2020 2020 2020 2064 6972 6563 746f  .        directo
+0000a730: 7279 0a20 2020 2020 2020 2020 2020 2054  ry.            T
+0000a740: 6865 2064 6972 6563 746f 7279 2063 6f6e  he directory con
+0000a750: 7461 696e 696e 6720 7468 6520 4342 4354  taining the CBCT
+0000a760: 2044 4943 4f4d 2066 696c 6573 2e0a 2020   DICOM files..  
+0000a770: 2020 2020 2020 7261 775f 7069 7865 6c73        raw_pixels
+0000a780: 0a20 2020 2020 2020 2020 2020 2049 6620  .            If 
+0000a790: 5472 7565 2c20 7573 6573 2074 6865 2072  True, uses the r
+0000a7a0: 6177 2070 6978 656c 2076 616c 7565 7320  aw pixel values 
+0000a7b0: 6f66 2074 6865 2044 4943 4f4d 2066 696c  of the DICOM fil
+0000a7c0: 6573 2e20 4966 2046 616c 7365 2c20 7573  es. If False, us
+0000a7d0: 6573 2074 6865 2072 6573 6361 6c65 6420  es the rescaled 
+0000a7e0: 486f 756e 7366 6965 6c64 2075 6e69 7473  Hounsfield units
+0000a7f0: 2e0a 2020 2020 2020 2020 2020 2020 4765  ..            Ge
+0000a800: 6e65 7261 6c6c 792c 2074 6869 7320 7368  nerally, this sh
+0000a810: 6f75 6c64 2062 6520 7472 7565 2e0a 2020  ould be true..  
+0000a820: 2020 2020 2020 6b77 6172 6773 0a20 2020        kwargs.   
+0000a830: 2020 2020 2020 2020 2053 6565 2070 6172           See par
+0000a840: 616d 6574 6572 7320 6f66 2074 6865 205f  ameters of the _
+0000a850: 5f69 6e69 745f 5f20 6d65 7468 6f64 2066  _init__ method f
+0000a860: 6f72 2064 6574 6169 6c73 2e0a 2020 2020  or details..    
+0000a870: 2020 2020 2222 220a 2020 2020 2020 2020      """.        
+0000a880: 6469 636f 6d5f 7374 6163 6b20 3d20 4469  dicom_stack = Di
+0000a890: 636f 6d49 6d61 6765 5374 6163 6b28 0a20  comImageStack(. 
+0000a8a0: 2020 2020 2020 2020 2020 2066 6f6c 6465             folde
+0000a8b0: 723d 6469 7265 6374 6f72 792c 206d 696e  r=directory, min
+0000a8c0: 5f6e 756d 6265 723d 3130 2c20 7261 775f  _number=10, raw_
+0000a8d0: 7069 7865 6c73 3d72 6177 5f70 6978 656c  pixels=raw_pixel
+0000a8e0: 730a 2020 2020 2020 2020 290a 2020 2020  s.        ).    
+0000a8f0: 2020 2020 6e70 5f73 7461 636b 203d 206e      np_stack = n
+0000a900: 702e 7374 6163 6b28 6469 636f 6d5f 7374  p.stack(dicom_st
+0000a910: 6163 6b2e 696d 6167 6573 2c20 6178 6973  ack.images, axis
+0000a920: 3d2d 3129 0a20 2020 2020 2020 207a 6f6f  =-1).        zoo
+0000a930: 6d5f 7261 7469 6f20 3d20 280a 2020 2020  m_ratio = (.    
+0000a940: 2020 2020 2020 2020 312c 0a20 2020 2020          1,.     
+0000a950: 2020 2020 2020 2064 6963 6f6d 5f73 7461         dicom_sta
+0000a960: 636b 2e6d 6574 6164 6174 612e 536c 6963  ck.metadata.Slic
+0000a970: 6554 6869 636b 6e65 7373 202f 2064 6963  eThickness / dic
+0000a980: 6f6d 5f73 7461 636b 2e6d 6574 6164 6174  om_stack.metadat
+0000a990: 612e 5069 7865 6c53 7061 6369 6e67 5b30  a.PixelSpacing[0
+0000a9a0: 5d2c 0a20 2020 2020 2020 2029 0a20 2020  ],.        ).   
+0000a9b0: 2020 2020 206c 6566 745f 6172 7220 3d20       left_arr = 
+0000a9c0: 6e70 2e72 6f74 3930 280a 2020 2020 2020  np.rot90(.      
+0000a9d0: 2020 2020 2020 7a6f 6f6d 280a 2020 2020        zoom(.    
+0000a9e0: 2020 2020 2020 2020 2020 2020 6e70 5f73              np_s
+0000a9f0: 7461 636b 2e6d 6178 2861 7869 733d 3029  tack.max(axis=0)
+0000aa00: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+0000aa10: 2020 7a6f 6f6d 3d7a 6f6f 6d5f 7261 7469    zoom=zoom_rati
+0000aa20: 6f2c 0a20 2020 2020 2020 2020 2020 2020  o,.             
+0000aa30: 2020 2067 7269 645f 6d6f 6465 3d54 7275     grid_mode=Tru
+0000aa40: 652c 0a20 2020 2020 2020 2020 2020 2020  e,.             
+0000aa50: 2020 206d 6f64 653d 226e 6561 7265 7374     mode="nearest
+0000aa60: 222c 0a20 2020 2020 2020 2020 2020 2020  ",.             
+0000aa70: 2020 206f 7264 6572 3d31 2c0a 2020 2020     order=1,.    
+0000aa80: 2020 2020 2020 2020 292c 0a20 2020 2020          ),.     
+0000aa90: 2020 2020 2020 206b 3d31 2c0a 2020 2020         k=1,.    
+0000aaa0: 2020 2020 290a 2020 2020 2020 2020 746f      ).        to
+0000aab0: 705f 6172 7220 3d20 6e70 2e72 6f74 3930  p_arr = np.rot90
+0000aac0: 280a 2020 2020 2020 2020 2020 2020 7a6f  (.            zo
+0000aad0: 6f6d 280a 2020 2020 2020 2020 2020 2020  om(.            
+0000aae0: 2020 2020 6e70 5f73 7461 636b 2e6d 6178      np_stack.max
+0000aaf0: 2861 7869 733d 3129 2c0a 2020 2020 2020  (axis=1),.      
+0000ab00: 2020 2020 2020 2020 2020 7a6f 6f6d 3d7a            zoom=z
+0000ab10: 6f6f 6d5f 7261 7469 6f2c 0a20 2020 2020  oom_ratio,.     
+0000ab20: 2020 2020 2020 2020 2020 2067 7269 645f             grid_
+0000ab30: 6d6f 6465 3d54 7275 652c 0a20 2020 2020  mode=True,.     
+0000ab40: 2020 2020 2020 2020 2020 206d 6f64 653d             mode=
+0000ab50: 226e 6561 7265 7374 222c 0a20 2020 2020  "nearest",.     
+0000ab60: 2020 2020 2020 2020 2020 206f 7264 6572             order
+0000ab70: 3d31 2c0a 2020 2020 2020 2020 2020 2020  =1,.            
+0000ab80: 292c 0a20 2020 2020 2020 2020 2020 206b  ),.            k
+0000ab90: 3d31 2c0a 2020 2020 2020 2020 290a 2020  =1,.        ).  
+0000aba0: 2020 2020 2020 7269 6768 745f 6172 7220        right_arr 
+0000abb0: 3d20 6e70 2e66 6c69 706c 7228 6c65 6674  = np.fliplr(left
+0000abc0: 5f61 7272 290a 2020 2020 2020 2020 626f  _arr).        bo
+0000abd0: 7474 6f6d 5f61 7272 203d 206e 702e 666c  ttom_arr = np.fl
+0000abe0: 6970 6c72 2874 6f70 5f61 7272 290a 2020  iplr(top_arr).  
+0000abf0: 2020 2020 2020 6469 636f 6d5f 6469 7220        dicom_dir 
+0000ac00: 3d20 5061 7468 2874 656d 7066 696c 652e  = Path(tempfile.
+0000ac10: 6d6b 6474 656d 7028 2929 0a20 2020 2020  mkdtemp()).     
+0000ac20: 2020 2064 7069 203d 2032 352e 3420 2f20     dpi = 25.4 / 
+0000ac30: 6469 636f 6d5f 7374 6163 6b2e 6d65 7461  dicom_stack.meta
+0000ac40: 6461 7461 2e50 6978 656c 5370 6163 696e  data.PixelSpacin
+0000ac50: 675b 305d 0a20 2020 2020 2020 2066 6f72  g[0].        for
+0000ac60: 2061 7272 6179 2c20 6761 6e74 7279 2069   array, gantry i
+0000ac70: 6e20 7a69 7028 0a20 2020 2020 2020 2020  n zip(.         
+0000ac80: 2020 2028 6c65 6674 5f61 7272 2c20 746f     (left_arr, to
+0000ac90: 705f 6172 722c 2072 6967 6874 5f61 7272  p_arr, right_arr
+0000aca0: 2c20 626f 7474 6f6d 5f61 7272 292c 2028  , bottom_arr), (
+0000acb0: 3237 302c 2030 2c20 3930 2c20 3138 3029  270, 0, 90, 180)
+0000acc0: 0a20 2020 2020 2020 2029 3a0a 2020 2020  .        ):.    
+0000acd0: 2020 2020 2020 2020 6473 203d 2061 7272          ds = arr
+0000ace0: 6179 5f74 6f5f 6469 636f 6d28 0a20 2020  ay_to_dicom(.   
+0000acf0: 2020 2020 2020 2020 2020 2020 2061 7272               arr
+0000ad00: 6179 3d6e 702e 6173 636f 6e74 6967 756f  ay=np.ascontiguo
+0000ad10: 7573 6172 7261 7928 6172 7261 7929 2c20  usarray(array), 
+0000ad20: 2023 2070 7964 6963 6f6d 2063 6f6d 706c   # pydicom compl
+0000ad30: 6169 6e73 2064 7565 2074 6f20 6e70 2e72  ains due to np.r
+0000ad40: 6f74 3930 0a20 2020 2020 2020 2020 2020  ot90.           
+0000ad50: 2020 2020 2073 6964 3d31 3030 302c 0a20       sid=1000,. 
+0000ad60: 2020 2020 2020 2020 2020 2020 2020 2067                 g
+0000ad70: 616e 7472 793d 6761 6e74 7279 2c0a 2020  antry=gantry,.  
+0000ad80: 2020 2020 2020 2020 2020 2020 2020 636f                co
+0000ad90: 6c6c 3d30 2c0a 2020 2020 2020 2020 2020  ll=0,.          
+0000ada0: 2020 2020 2020 636f 7563 683d 302c 0a20        couch=0,. 
+0000adb0: 2020 2020 2020 2020 2020 2020 2020 2064                 d
+0000adc0: 7069 3d64 7069 2c0a 2020 2020 2020 2020  pi=dpi,.        
+0000add0: 2020 2020 290a 2020 2020 2020 2020 2020      ).          
+0000ade0: 2020 6473 2e73 6176 655f 6173 2864 6963    ds.save_as(dic
+0000adf0: 6f6d 5f64 6972 202f 2066 2247 3d7b 6761  om_dir / f"G={ga
+0000ae00: 6e74 7279 7d22 2c20 7772 6974 655f 6c69  ntry}", write_li
+0000ae10: 6b65 5f6f 7269 6769 6e61 6c3d 4661 6c73  ke_original=Fals
+0000ae20: 6529 0a20 2020 2020 2020 2023 206e 6f77  e).        # now
+0000ae30: 2077 6520 6c6f 6164 2074 6865 7365 2061   we load these a
+0000ae40: 7320 6e6f 726d 616c 2069 6d61 6765 7320  s normal images 
+0000ae50: 696e 746f 2074 6865 2057 4c20 616c 676f  into the WL algo
+0000ae60: 7269 7468 6d0a 2020 2020 2020 2020 696e  rithm.        in
+0000ae70: 7374 616e 6365 203d 2063 6c73 2864 6963  stance = cls(dic
+0000ae80: 6f6d 5f64 6972 2c20 2a2a 6b77 6172 6773  om_dir, **kwargs
+0000ae90: 290a 2020 2020 2020 2020 696e 7374 616e  ).        instan
+0000aea0: 6365 2e69 735f 6672 6f6d 5f63 6263 7420  ce.is_from_cbct 
+0000aeb0: 3d20 5472 7565 0a20 2020 2020 2020 2072  = True.        r
+0000aec0: 6574 7572 6e20 696e 7374 616e 6365 0a0a  eturn instance..
+0000aed0: 2020 2020 4073 7461 7469 636d 6574 686f      @staticmetho
+0000aee0: 640a 2020 2020 6465 6620 7275 6e5f 6465  d.    def run_de
+0000aef0: 6d6f 2829 202d 3e20 4e6f 6e65 3a0a 2020  mo() -> None:.  
+0000af00: 2020 2020 2020 2222 2252 756e 2074 6865        """Run the
+0000af10: 2057 696e 7374 6f6e 2d4c 7574 7a20 6465   Winston-Lutz de
+0000af20: 6d6f 2c20 7768 6963 6820 6c6f 6164 7320  mo, which loads 
+0000af30: 7468 6520 6465 6d6f 2066 696c 6573 2c20  the demo files, 
+0000af40: 7072 696e 7473 2072 6573 756c 7473 2c20  prints results, 
+0000af50: 616e 6420 706c 6f74 7320 6120 7375 6d6d  and plots a summ
+0000af60: 6172 7920 696d 6167 652e 2222 220a 2020  ary image.""".  
+0000af70: 2020 2020 2020 776c 203d 2057 696e 7374        wl = Winst
+0000af80: 6f6e 4c75 747a 2e66 726f 6d5f 6465 6d6f  onLutz.from_demo
+0000af90: 5f69 6d61 6765 7328 290a 2020 2020 2020  _images().      
+0000afa0: 2020 776c 2e61 6e61 6c79 7a65 286d 6163    wl.analyze(mac
+0000afb0: 6869 6e65 5f73 6361 6c65 3d4d 6163 6869  hine_scale=Machi
+0000afc0: 6e65 5363 616c 652e 5641 5249 414e 5f49  neScale.VARIAN_I
+0000afd0: 4543 290a 2020 2020 2020 2020 7072 696e  EC).        prin
+0000afe0: 7428 776c 2e72 6573 756c 7473 2829 290a  t(wl.results()).
+0000aff0: 2020 2020 2020 2020 776c 2e70 6c6f 745f          wl.plot_
+0000b000: 7375 6d6d 6172 7928 290a 0a20 2020 2064  summary()..    d
+0000b010: 6566 2061 6e61 6c79 7a65 280a 2020 2020  ef analyze(.    
+0000b020: 2020 2020 7365 6c66 2c0a 2020 2020 2020      self,.      
+0000b030: 2020 6262 5f73 697a 655f 6d6d 3a20 666c    bb_size_mm: fl
+0000b040: 6f61 7420 3d20 352c 0a20 2020 2020 2020  oat = 5,.       
+0000b050: 206d 6163 6869 6e65 5f73 6361 6c65 3a20   machine_scale: 
+0000b060: 4d61 6368 696e 6553 6361 6c65 203d 204d  MachineScale = M
+0000b070: 6163 6869 6e65 5363 616c 652e 4945 4336  achineScale.IEC6
+0000b080: 3132 3137 2c0a 2020 2020 2020 2020 6c6f  1217,.        lo
+0000b090: 775f 6465 6e73 6974 795f 6262 3a20 626f  w_density_bb: bo
+0000b0a0: 6f6c 203d 2046 616c 7365 2c0a 2020 2020  ol = False,.    
+0000b0b0: 2020 2020 6f70 656e 5f66 6965 6c64 3a20      open_field: 
+0000b0c0: 626f 6f6c 203d 2046 616c 7365 2c0a 2020  bool = False,.  
+0000b0d0: 2020 2020 2020 6170 706c 795f 7669 7274        apply_virt
+0000b0e0: 7561 6c5f 7368 6966 743a 2062 6f6f 6c20  ual_shift: bool 
+0000b0f0: 3d20 4661 6c73 652c 0a20 2020 2029 202d  = False,.    ) -
+0000b100: 3e20 4e6f 6e65 3a0a 2020 2020 2020 2020  > None:.        
+0000b110: 2222 2241 6e61 6c79 7a65 2074 6865 2057  """Analyze the W
+0000b120: 4c20 696d 6167 6573 2e0a 0a20 2020 2020  L images...     
+0000b130: 2020 2050 6172 616d 6574 6572 730a 2020     Parameters.  
+0000b140: 2020 2020 2020 2d2d 2d2d 2d2d 2d2d 2d2d        ----------
+0000b150: 0a20 2020 2020 2020 2062 625f 7369 7a65  .        bb_size
+0000b160: 5f6d 6d0a 2020 2020 2020 2020 2020 2020  _mm.            
+0000b170: 5468 6520 6578 7065 6374 6564 2064 6961  The expected dia
+0000b180: 6d65 7465 7220 6f66 2074 6865 2042 4220  meter of the BB 
+0000b190: 696e 206d 6d2e 2054 6865 2061 6374 7561  in mm. The actua
+0000b1a0: 6c20 7369 7a65 206f 6620 7468 6520 4242  l size of the BB
+0000b1b0: 2063 616e 2062 6520 2b2f 2d32 6d6d 2066   can be +/-2mm f
+0000b1c0: 726f 6d20 7468 6520 7061 7373 6564 2076  rom the passed v
+0000b1d0: 616c 7565 2e0a 2020 2020 2020 2020 6d61  alue..        ma
+0000b1e0: 6368 696e 655f 7363 616c 650a 2020 2020  chine_scale.    
+0000b1f0: 2020 2020 2020 2020 5468 6520 7363 616c          The scal
+0000b200: 6520 6f66 2074 6865 206d 6163 6869 6e65  e of the machine
+0000b210: 2e20 5368 6966 7420 7665 6374 6f72 7320  . Shift vectors 
+0000b220: 6465 7065 6e64 206f 6e20 7468 6973 2076  depend on this v
+0000b230: 616c 7565 2e0a 2020 2020 2020 2020 6c6f  alue..        lo
+0000b240: 775f 6465 6e73 6974 795f 6262 0a20 2020  w_density_bb.   
+0000b250: 2020 2020 2020 2020 2053 6574 2074 6869           Set thi
+0000b260: 7320 666c 6167 2074 6f20 5472 7565 2069  s flag to True i
+0000b270: 6620 7468 6520 4242 2069 7320 6c6f 7765  f the BB is lowe
+0000b280: 7220 6465 6e73 6974 7920 7468 616e 2074  r density than t
+0000b290: 6865 206d 6174 6572 6961 6c20 7375 7272  he material surr
+0000b2a0: 6f75 6e64 696e 6720 6974 2e0a 2020 2020  ounding it..    
+0000b2b0: 2020 2020 6f70 656e 5f66 6965 6c64 0a20      open_field. 
+0000b2c0: 2020 2020 2020 2020 2020 2049 6620 5472             If Tr
+0000b2d0: 7565 2c20 7365 7473 2074 6865 2066 6965  ue, sets the fie
+0000b2e0: 6c64 2063 656e 7465 7220 746f 2074 6865  ld center to the
+0000b2f0: 2045 5049 4420 6365 6e74 6572 2075 6e64   EPID center und
+0000b300: 6572 2074 6865 2061 7373 756d 7074 696f  er the assumptio
+0000b310: 6e20 7468 6520 6669 656c 6420 6973 206e  n the field is n
+0000b320: 6f74 2074 6865 2066 6f63 7573 206f 6620  ot the focus of 
+0000b330: 696e 7465 7265 7374 206f 7220 6973 2074  interest or is t
+0000b340: 6f6f 2077 6964 6520 746f 2062 6520 6361  oo wide to be ca
+0000b350: 6c63 756c 6174 6564 2e0a 2020 2020 2020  lculated..      
+0000b360: 2020 2020 2020 5468 6973 2069 7320 6f66        This is of
+0000b370: 7465 6e20 6865 6c70 6675 6c20 666f 7220  ten helpful for 
+0000b380: 6b56 2057 4c20 616e 616c 7973 6973 2077  kV WL analysis w
+0000b390: 6865 7265 2074 6865 2062 6c61 6465 7320  here the blades 
+0000b3a0: 6172 6520 7769 6465 206f 7065 6e20 616e  are wide open an
+0000b3b0: 6420 6576 656e 2074 6865 6e20 7468 6520  d even then the 
+0000b3c0: 626c 6164 6520 6564 6765 2069 7320 6f66  blade edge is of
+0000b3d0: 0a20 2020 2020 2020 2020 2020 206c 6573  .            les
+0000b3e0: 7320 696e 7465 7265 7374 2074 6861 6e20  s interest than 
+0000b3f0: 7369 6d70 6c79 2074 6865 2069 6d61 6769  simply the imagi
+0000b400: 6e67 2069 736f 2076 7320 7468 6520 4242  ng iso vs the BB
+0000b410: 2e0a 2020 2020 2020 2020 6170 706c 795f  ..        apply_
+0000b420: 7669 7274 7561 6c5f 7368 6966 740a 2020  virtual_shift.  
+0000b430: 2020 2020 2020 2020 2020 4966 2054 7275            If Tru
+0000b440: 652c 2061 7070 6c69 6573 2061 2076 6972  e, applies a vir
+0000b450: 7475 616c 2073 6869 6674 2074 6f20 7468  tual shift to th
+0000b460: 6520 4242 7320 6261 7365 6420 6f6e 2074  e BBs based on t
+0000b470: 6865 2073 6869 6674 206e 6563 6573 7361  he shift necessa
+0000b480: 7279 2074 6f20 706c 6163 6520 7468 6520  ry to place the 
+0000b490: 4242 2061 7420 7468 6520 7261 6469 6174  BB at the radiat
+0000b4a0: 696f 6e20 6973 6f63 656e 7465 722e 0a20  ion isocenter.. 
+0000b4b0: 2020 2020 2020 2022 2222 0a20 2020 2020         """.     
+0000b4c0: 2020 2073 656c 662e 6d61 6368 696e 655f     self.machine_
+0000b4d0: 7363 616c 6520 3d20 6d61 6368 696e 655f  scale = machine_
+0000b4e0: 7363 616c 650a 2020 2020 2020 2020 6966  scale.        if
+0000b4f0: 2073 656c 662e 6973 5f66 726f 6d5f 6362   self.is_from_cb
+0000b500: 6374 3a0a 2020 2020 2020 2020 2020 2020  ct:.            
+0000b510: 6c6f 775f 6465 6e73 6974 795f 6262 203d  low_density_bb =
+0000b520: 2054 7275 650a 2020 2020 2020 2020 2020   True.          
+0000b530: 2020 6f70 656e 5f66 6965 6c64 203d 2054    open_field = T
+0000b540: 7275 650a 2020 2020 2020 2020 666f 7220  rue.        for 
+0000b550: 696d 6720 696e 2073 656c 662e 696d 6167  img in self.imag
+0000b560: 6573 3a0a 2020 2020 2020 2020 2020 2020  es:.            
+0000b570: 696d 672e 616e 616c 797a 6528 6262 5f73  img.analyze(bb_s
+0000b580: 697a 655f 6d6d 2c20 6c6f 775f 6465 6e73  ize_mm, low_dens
+0000b590: 6974 795f 6262 2c20 6f70 656e 5f66 6965  ity_bb, open_fie
+0000b5a0: 6c64 290a 2020 2020 2020 2020 2320 7765  ld).        # we
+0000b5b0: 206e 6565 6420 746f 2063 6f6e 7374 7275   need to constru
+0000b5c0: 6374 2074 6865 2042 4220 7265 7072 6573  ct the BB repres
+0000b5d0: 656e 7461 7469 6f6e 2074 6f20 6765 7420  entation to get 
+0000b5e0: 7468 6520 7368 6966 7420 7665 6374 6f72  the shift vector
+0000b5f0: 0a20 2020 2020 2020 2062 625f 636f 6e66  .        bb_conf
+0000b600: 6967 203d 2042 4241 7272 616e 6765 6d65  ig = BBArrangeme
+0000b610: 6e74 2e49 534f 5b30 5d0a 2020 2020 2020  nt.ISO[0].      
+0000b620: 2020 6262 5f63 6f6e 6669 672e 6262 5f73    bb_config.bb_s
+0000b630: 697a 655f 6d6d 203d 2062 625f 7369 7a65  ize_mm = bb_size
+0000b640: 5f6d 6d0a 2020 2020 2020 2020 7365 6c66  _mm.        self
+0000b650: 2e62 6220 3d20 4242 3344 280a 2020 2020  .bb = BB3D(.    
+0000b660: 2020 2020 2020 2020 6262 5f63 6f6e 6669          bb_confi
+0000b670: 673d 6262 5f63 6f6e 6669 672c 0a20 2020  g=bb_config,.   
+0000b680: 2020 2020 2020 2020 2062 625f 6d61 7463           bb_matc
+0000b690: 6865 733d 5b69 6d67 2e61 7272 616e 6765  hes=[img.arrange
+0000b6a0: 6d65 6e74 5f6d 6174 6368 6573 5b22 4973  ment_matches["Is
+0000b6b0: 6f22 5d20 666f 7220 696d 6720 696e 2073  o"] for img in s
+0000b6c0: 656c 662e 696d 6167 6573 5d2c 0a20 2020  elf.images],.   
+0000b6d0: 2020 2020 2020 2020 2073 6361 6c65 3d73           scale=s
+0000b6e0: 656c 662e 6d61 6368 696e 655f 7363 616c  elf.machine_scal
+0000b6f0: 652c 0a20 2020 2020 2020 2029 0a20 2020  e,.        ).   
+0000b700: 2020 2020 2069 6620 6170 706c 795f 7669       if apply_vi
+0000b710: 7274 7561 6c5f 7368 6966 743a 0a20 2020  rtual_shift:.   
+0000b720: 2020 2020 2020 2020 2073 6869 6674 203d           shift =
+0000b730: 2073 656c 662e 6262 5f73 6869 6674 5f76   self.bb_shift_v
+0000b740: 6563 746f 720a 2020 2020 2020 2020 2020  ector.          
+0000b750: 2020 7365 6c66 2e5f 7669 7274 7561 6c5f    self._virtual_
+0000b760: 7368 6966 7420 3d20 7365 6c66 2e62 625f  shift = self.bb_
+0000b770: 7368 6966 745f 696e 7374 7275 6374 696f  shift_instructio
+0000b780: 6e73 2829 0a20 2020 2020 2020 2020 2020  ns().           
+0000b790: 2066 6f72 2069 6d67 2069 6e20 7365 6c66   for img in self
+0000b7a0: 2e69 6d61 6765 733a 0a20 2020 2020 2020  .images:.       
+0000b7b0: 2020 2020 2020 2020 2069 6d67 2e61 6e61           img.ana
+0000b7c0: 6c79 7a65 2862 625f 7369 7a65 5f6d 6d2c  lyze(bb_size_mm,
+0000b7d0: 206c 6f77 5f64 656e 7369 7479 5f62 622c   low_density_bb,
+0000b7e0: 206f 7065 6e5f 6669 656c 642c 2073 6869   open_field, shi
+0000b7f0: 6674 5f76 6563 746f 723d 7368 6966 7429  ft_vector=shift)
+0000b800: 0a0a 2020 2020 2020 2020 2320 696e 2074  ..        # in t
+0000b810: 6865 2076 616e 696c 6c61 2057 4c20 6361  he vanilla WL ca
+0000b820: 7365 2c20 7468 6520 4242 2063 616e 206f  se, the BB can o
+0000b830: 6e6c 7920 6265 2072 6570 7265 7365 6e74  nly be represent
+0000b840: 6564 2062 7920 6e6f 6e2d 636f 7563 682d  ed by non-couch-
+0000b850: 6b69 636b 2069 6d61 6765 730a 2020 2020  kick images.    
+0000b860: 2020 2020 2320 7468 6520 7261 7920 7472      # the ray tr
+0000b870: 6163 6520 6361 6e6e 6f74 2068 616e 646c  ace cannot handl
+0000b880: 6520 7468 6520 6b69 636b 2063 7572 7265  e the kick curre
+0000b890: 6e74 6c79 0a20 2020 2020 2020 2073 656c  ntly.        sel
+0000b8a0: 662e 6262 203d 2042 4233 4428 0a20 2020  f.bb = BB3D(.   
+0000b8b0: 2020 2020 2020 2020 2062 625f 636f 6e66           bb_conf
+0000b8c0: 6967 3d62 625f 636f 6e66 6967 2c0a 2020  ig=bb_config,.  
+0000b8d0: 2020 2020 2020 2020 2020 6262 5f6d 6174            bb_mat
+0000b8e0: 6368 6573 3d5b 696d 672e 6172 7261 6e67  ches=[img.arrang
+0000b8f0: 656d 656e 745f 6d61 7463 6865 735b 2249  ement_matches["I
+0000b900: 736f 225d 2066 6f72 2069 6d67 2069 6e20  so"] for img in 
+0000b910: 7365 6c66 2e69 6d61 6765 735d 2c0a 2020  self.images],.  
+0000b920: 2020 2020 2020 2020 2020 7363 616c 653d            scale=
+0000b930: 7365 6c66 2e6d 6163 6869 6e65 5f73 6361  self.machine_sca
+0000b940: 6c65 2c0a 2020 2020 2020 2020 290a 2020  le,.        ).  
+0000b950: 2020 2020 2020 7365 6c66 2e5f 6973 5f61        self._is_a
+0000b960: 6e61 6c79 7a65 6420 3d20 5472 7565 0a20  nalyzed = True. 
+0000b970: 2020 2020 2020 2073 656c 662e 5f62 625f         self._bb_
+0000b980: 6469 616d 6574 6572 203d 2062 625f 7369  diameter = bb_si
+0000b990: 7a65 5f6d 6d0a 0a20 2020 2040 6c72 755f  ze_mm..    @lru_
+0000b9a0: 6361 6368 6528 290a 2020 2020 6465 6620  cache().    def 
+0000b9b0: 5f6d 696e 696d 697a 655f 6178 6973 2873  _minimize_axis(s
+0000b9c0: 656c 662c 2061 7865 733a 2041 7869 7320  elf, axes: Axis 
+0000b9d0: 7c20 7475 706c 655b 4178 6973 2c20 2e2e  | tuple[Axis, ..
+0000b9e0: 2e5d 203d 2028 4178 6973 2e47 414e 5452  .] = (Axis.GANTR
+0000b9f0: 592c 2929 3a0a 2020 2020 2020 2020 2222  Y,)):.        ""
+0000ba00: 2252 6574 7572 6e20 7468 6520 6d69 6e69  "Return the mini
+0000ba10: 6d69 7a61 7469 6f6e 2072 6573 756c 7420  mization result 
+0000ba20: 6f66 2074 6865 2067 6976 656e 2061 7869  of the given axi
+0000ba30: 732e 2222 220a 2020 2020 2020 2020 6966  s.""".        if
+0000ba40: 2069 7369 6e73 7461 6e63 6528 6178 6573   isinstance(axes
+0000ba50: 2c20 4178 6973 293a 0a20 2020 2020 2020  , Axis):.       
+0000ba60: 2020 2020 2061 7865 7320 3d20 2861 7865       axes = (axe
+0000ba70: 732c 290a 0a20 2020 2020 2020 2074 6869  s,)..        thi
+0000ba80: 6e67 7320 3d20 5b0a 2020 2020 2020 2020  ngs = [.        
+0000ba90: 2020 2020 2320 7765 2077 616e 7420 7468      # we want th
+0000baa0: 6520 6262 3c2d 3e66 6965 6c64 2062 6563  e bb<->field bec
+0000bab0: 6175 7365 2074 6865 2042 4220 6973 206f  ause the BB is o
+0000bac0: 7572 2072 6566 6572 656e 6365 2070 6f69  ur reference poi
+0000bad0: 6e74 2066 6f72 2076 616e 696c 6c61 2057  nt for vanilla W
+0000bae0: 4c0a 2020 2020 2020 2020 2020 2020 2320  L.            # 
+0000baf0: 7768 6574 6865 7220 6974 2773 2042 422d  whether it's BB-
+0000bb00: 3e66 6965 6c64 206f 7220 6669 656c 642d  >field or field-
+0000bb10: 3e42 4220 6973 2069 7272 656c 6576 616e  >BB is irrelevan
+0000bb20: 7420 666f 7220 7468 6973 2063 6173 653b  t for this case;
+0000bb30: 2077 6520 6172 6520 6e6f 7420 6465 7465   we are not dete
+0000bb40: 726d 696e 696e 6720 7368 6966 7420 6865  rmining shift he
+0000bb50: 7265 2e0a 2020 2020 2020 2020 2020 2020  re..            
+0000bb60: 696d 6167 652e 6172 7261 6e67 656d 656e  image.arrangemen
+0000bb70: 745f 6d61 7463 6865 735b 2249 736f 225d  t_matches["Iso"]
+0000bb80: 2e62 625f 746f 5f66 6965 6c64 5f70 726f  .bb_to_field_pro
+0000bb90: 6a65 6374 696f 6e0a 2020 2020 2020 2020  jection.        
+0000bba0: 2020 2020 666f 7220 696d 6167 6520 696e      for image in
+0000bbb0: 2073 656c 662e 696d 6167 6573 0a20 2020   self.images.   
+0000bbc0: 2020 2020 2020 2020 2069 6620 696d 6167           if imag
+0000bbd0: 652e 7661 7269 6162 6c65 5f61 7869 7320  e.variable_axis 
+0000bbe0: 696e 2028 6178 6573 202b 2028 4178 6973  in (axes + (Axis
+0000bbf0: 2e52 4546 4552 454e 4345 2c29 290a 2020  .REFERENCE,)).  
+0000bc00: 2020 2020 2020 5d0a 2020 2020 2020 2020        ].        
+0000bc10: 6966 206c 656e 2874 6869 6e67 7329 203c  if len(things) <
+0000bc20: 3d20 313a 0a20 2020 2020 2020 2020 2020  = 1:.           
+0000bc30: 2072 6169 7365 2056 616c 7565 4572 726f   raise ValueErro
+0000bc40: 7228 0a20 2020 2020 2020 2020 2020 2020  r(.             
+0000bc50: 2020 2022 4e6f 7420 656e 6f75 6768 2069     "Not enough i
+0000bc60: 6d61 6765 7320 6f66 2074 6865 2067 6976  mages of the giv
+0000bc70: 656e 2074 7970 6520 746f 2069 6465 6e74  en type to ident
+0000bc80: 6966 7920 7468 6520 6178 6973 2069 736f  ify the axis iso
+0000bc90: 6365 6e74 6572 220a 2020 2020 2020 2020  center".        
+0000bca0: 2020 2020 290a 2020 2020 2020 2020 696e      ).        in
+0000bcb0: 6974 6961 6c5f 6775 6573 7320 3d20 6e70  itial_guess = np
+0000bcc0: 2e61 7272 6179 285b 302c 2030 2c20 305d  .array([0, 0, 0]
+0000bcd0: 290a 2020 2020 2020 2020 626f 756e 6473  ).        bounds
+0000bce0: 203d 205b 282d 3230 2c20 3230 292c 2028   = [(-20, 20), (
+0000bcf0: 2d32 302c 2032 3029 2c20 282d 3230 2c20  -20, 20), (-20, 
+0000bd00: 3230 295d 0a20 2020 2020 2020 2072 6573  20)].        res
+0000bd10: 756c 7420 3d20 6f70 7469 6d69 7a65 2e6d  ult = optimize.m
+0000bd20: 696e 696d 697a 6528 0a20 2020 2020 2020  inimize(.       
+0000bd30: 2020 2020 206d 6178 5f64 6973 7461 6e63       max_distanc
+0000bd40: 655f 746f 5f6c 696e 6573 2c20 696e 6974  e_to_lines, init
+0000bd50: 6961 6c5f 6775 6573 732c 2061 7267 733d  ial_guess, args=
+0000bd60: 7468 696e 6773 2c20 626f 756e 6473 3d62  things, bounds=b
+0000bd70: 6f75 6e64 730a 2020 2020 2020 2020 290a  ounds.        ).
+0000bd80: 2020 2020 2020 2020 7265 7475 726e 2072          return r
+0000bd90: 6573 756c 740a 0a20 2020 2040 7072 6f70  esult..    @prop
+0000bda0: 6572 7479 0a20 2020 2064 6566 2067 616e  erty.    def gan
+0000bdb0: 7472 795f 6973 6f5f 7369 7a65 2873 656c  try_iso_size(sel
+0000bdc0: 6629 202d 3e20 666c 6f61 743a 0a20 2020  f) -> float:.   
+0000bdd0: 2020 2020 2022 2222 5468 6520 6469 616d       """The diam
+0000bde0: 6574 6572 206f 6620 7468 6520 3344 2067  eter of the 3D g
+0000bdf0: 616e 7472 7920 6973 6f63 656e 7465 7220  antry isocenter 
+0000be00: 7369 7a65 2069 6e20 6d6d 2e20 4f6e 6c79  size in mm. Only
+0000be10: 2069 6d61 6765 7320 7768 6572 6520 7468   images where th
+0000be20: 6520 636f 6c6c 696d 6174 6f72 0a20 2020  e collimator.   
+0000be30: 2020 2020 2061 6e64 2063 6f75 6368 2077       and couch w
+0000be40: 6572 6520 6174 2030 2061 7265 2075 7365  ere at 0 are use
+0000be50: 6420 746f 2064 6574 6572 6d69 6e65 2074  d to determine t
+0000be60: 6869 7320 7661 6c75 652e 2222 220a 2020  his value.""".  
+0000be70: 2020 2020 2020 6e75 6d5f 6761 6e74 7279        num_gantry
+0000be80: 5f6c 696b 655f 696d 6167 6573 203d 2073  _like_images = s
+0000be90: 656c 662e 5f67 6574 5f69 6d61 6765 7328  elf._get_images(
+0000bea0: 2841 7869 732e 4741 4e54 5259 2c20 4178  (Axis.GANTRY, Ax
+0000beb0: 6973 2e52 4546 4552 454e 4345 2929 5b30  is.REFERENCE))[0
+0000bec0: 5d0a 2020 2020 2020 2020 6966 206e 756d  ].        if num
+0000bed0: 5f67 616e 7472 795f 6c69 6b65 5f69 6d61  _gantry_like_ima
+0000bee0: 6765 7320 3e20 313a 0a20 2020 2020 2020  ges > 1:.       
+0000bef0: 2020 2020 2072 6574 7572 6e20 7365 6c66       return self
+0000bf00: 2e5f 6d69 6e69 6d69 7a65 5f61 7869 7328  ._minimize_axis(
+0000bf10: 4178 6973 2e47 414e 5452 5929 2e66 756e  Axis.GANTRY).fun
+0000bf20: 202a 2032 0a20 2020 2020 2020 2065 6c73   * 2.        els
+0000bf30: 653a 0a20 2020 2020 2020 2020 2020 2072  e:.            r
+0000bf40: 6574 7572 6e20 300a 0a20 2020 2040 7072  eturn 0..    @pr
+0000bf50: 6f70 6572 7479 0a20 2020 2064 6566 2067  operty.    def g
+0000bf60: 616e 7472 795f 636f 6c6c 5f69 736f 5f73  antry_coll_iso_s
+0000bf70: 697a 6528 7365 6c66 2920 2d3e 2066 6c6f  ize(self) -> flo
+0000bf80: 6174 3a0a 2020 2020 2020 2020 2222 2254  at:.        """T
+0000bf90: 6865 2064 6961 6d65 7465 7220 6f66 2074  he diameter of t
+0000bfa0: 6865 2033 4420 6761 6e74 7279 2069 736f  he 3D gantry iso
+0000bfb0: 6365 6e74 6572 2073 697a 6520 696e 206d  center size in m
+0000bfc0: 6d20 2a69 6e63 6c75 6469 6e67 2063 6f6c  m *including col
+0000bfd0: 6c69 6d61 746f 7220 616e 6420 6761 6e74  limator and gant
+0000bfe0: 7279 2f63 6f6c 6c20 636f 6d62 6f20 696d  ry/coll combo im
+0000bff0: 6167 6573 2a2e 0a20 2020 2020 2020 2049  ages*..        I
+0000c000: 6d61 6765 7320 7768 6572 6520 7468 6520  mages where the 
+0000c010: 636f 7563 6821 3d30 2061 7265 2065 7863  couch!=0 are exc
+0000c020: 6c75 6465 642e 2222 220a 2020 2020 2020  luded.""".      
+0000c030: 2020 6e75 6d5f 6761 6e74 7279 5f6c 696b    num_gantry_lik
+0000c040: 655f 696d 6167 6573 203d 2073 656c 662e  e_images = self.
+0000c050: 5f67 6574 5f69 6d61 6765 7328 0a20 2020  _get_images(.   
+0000c060: 2020 2020 2020 2020 2028 4178 6973 2e47           (Axis.G
+0000c070: 414e 5452 592c 2041 7869 732e 434f 4c4c  ANTRY, Axis.COLL
+0000c080: 494d 4154 4f52 2c20 4178 6973 2e47 425f  IMATOR, Axis.GB_
+0000c090: 434f 4d42 4f2c 2041 7869 732e 5245 4645  COMBO, Axis.REFE
+0000c0a0: 5245 4e43 4529 0a20 2020 2020 2020 2029  RENCE).        )
+0000c0b0: 5b30 5d0a 2020 2020 2020 2020 6966 206e  [0].        if n
+0000c0c0: 756d 5f67 616e 7472 795f 6c69 6b65 5f69  um_gantry_like_i
+0000c0d0: 6d61 6765 7320 3e20 313a 0a20 2020 2020  mages > 1:.     
+0000c0e0: 2020 2020 2020 2072 6574 7572 6e20 280a         return (.
+0000c0f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c100: 7365 6c66 2e5f 6d69 6e69 6d69 7a65 5f61  self._minimize_a
+0000c110: 7869 7328 2841 7869 732e 4741 4e54 5259  xis((Axis.GANTRY
+0000c120: 2c20 4178 6973 2e43 4f4c 4c49 4d41 544f  , Axis.COLLIMATO
+0000c130: 522c 2041 7869 732e 4742 5f43 4f4d 424f  R, Axis.GB_COMBO
+0000c140: 2929 2e66 756e 0a20 2020 2020 2020 2020  )).fun.         
+0000c150: 2020 2020 2020 202a 2032 0a20 2020 2020         * 2.     
+0000c160: 2020 2020 2020 2029 0a20 2020 2020 2020         ).       
+0000c170: 2065 6c73 653a 0a20 2020 2020 2020 2020   else:.         
+0000c180: 2020 2072 6574 7572 6e20 300a 0a20 2020     return 0..   
+0000c190: 2040 7374 6174 6963 6d65 7468 6f64 0a20   @staticmethod. 
+0000c1a0: 2020 2064 6566 205f 6669 6e64 5f6d 6178     def _find_max
+0000c1b0: 5f64 6973 7461 6e63 655f 6265 7477 6565  _distance_betwee
+0000c1c0: 6e5f 706f 696e 7473 2869 6d61 6765 7329  n_points(images)
+0000c1d0: 202d 3e20 666c 6f61 743a 0a20 2020 2020   -> float:.     
+0000c1e0: 2020 2022 2222 4669 6e64 2074 6865 206d     """Find the m
+0000c1f0: 6178 696d 756d 2064 6973 7461 6e63 6520  aximum distance 
+0000c200: 6265 7477 6565 6e20 6120 7365 7420 6f66  between a set of
+0000c210: 2070 6f69 6e74 732e 2055 7365 6420 666f   points. Used fo
+0000c220: 7220 3244 2069 6d61 6765 7320 6c69 6b65  r 2D images like
+0000c230: 2063 6f6c 6c69 6d61 746f 7220 616e 6420   collimator and 
+0000c240: 636f 7563 682e 2222 220a 2020 2020 2020  couch.""".      
+0000c250: 2020 706f 696e 7473 203d 205b 0a20 2020    points = [.   
+0000c260: 2020 2020 2020 2020 2050 6f69 6e74 2869           Point(i
+0000c270: 6d61 6765 2e63 6178 3262 625f 7665 6374  mage.cax2bb_vect
+0000c280: 6f72 2e78 2c20 696d 6167 652e 6361 7832  or.x, image.cax2
+0000c290: 6262 5f76 6563 746f 722e 7929 2066 6f72  bb_vector.y) for
+0000c2a0: 2069 6d61 6765 2069 6e20 696d 6167 6573   image in images
+0000c2b0: 0a20 2020 2020 2020 205d 0a20 2020 2020  .        ].     
+0000c2c0: 2020 2064 6973 7473 203d 205b 5d0a 2020     dists = [].  
+0000c2d0: 2020 2020 2020 666f 7220 706f 696e 7431        for point1
+0000c2e0: 2069 6e20 706f 696e 7473 3a0a 2020 2020   in points:.    
+0000c2f0: 2020 2020 2020 2020 666f 7220 706f 696e          for poin
+0000c300: 7432 2069 6e20 706f 696e 7473 3a0a 2020  t2 in points:.  
+0000c310: 2020 2020 2020 2020 2020 2020 2020 7020                p 
+0000c320: 3d20 706f 696e 7431 2e64 6973 7461 6e63  = point1.distanc
+0000c330: 655f 746f 2870 6f69 6e74 3229 0a20 2020  e_to(point2).   
+0000c340: 2020 2020 2020 2020 2020 2020 2064 6973               dis
+0000c350: 7473 2e61 7070 656e 6428 7029 0a20 2020  ts.append(p).   
+0000c360: 2020 2020 2072 6574 7572 6e20 6d61 7828       return max(
+0000c370: 6469 7374 7329 0a0a 2020 2020 4070 726f  dists)..    @pro
+0000c380: 7065 7274 790a 2020 2020 6465 6620 636f  perty.    def co
+0000c390: 6c6c 696d 6174 6f72 5f69 736f 5f73 697a  llimator_iso_siz
+0000c3a0: 6528 7365 6c66 2920 2d3e 2066 6c6f 6174  e(self) -> float
+0000c3b0: 3a0a 2020 2020 2020 2020 2222 2254 6865  :.        """The
+0000c3c0: 2032 4420 636f 6c6c 696d 6174 6f72 2069   2D collimator i
+0000c3d0: 736f 6365 6e74 6572 2073 697a 6520 2864  socenter size (d
+0000c3e0: 6961 6d65 7465 7229 2069 6e20 6d6d 2e20  iameter) in mm. 
+0000c3f0: 5468 6520 6973 6f20 7369 7a65 2069 7320  The iso size is 
+0000c400: 696e 2074 6865 2070 6c61 6e65 0a20 2020  in the plane.   
+0000c410: 2020 2020 206e 6f72 6d61 6c20 746f 2074       normal to t
+0000c420: 6865 2067 616e 7472 792e 2222 220a 2020  he gantry.""".  
+0000c430: 2020 2020 2020 6e75 6d5f 636f 6c6c 696d        num_collim
+0000c440: 6174 6f72 5f6c 696b 655f 696d 6167 6573  ator_like_images
+0000c450: 2c20 696d 6167 6573 203d 2073 656c 662e  , images = self.
+0000c460: 5f67 6574 5f69 6d61 6765 7328 0a20 2020  _get_images(.   
+0000c470: 2020 2020 2020 2020 2028 4178 6973 2e43           (Axis.C
+0000c480: 4f4c 4c49 4d41 544f 522c 2041 7869 732e  OLLIMATOR, Axis.
+0000c490: 5245 4645 5245 4e43 4529 0a20 2020 2020  REFERENCE).     
+0000c4a0: 2020 2029 0a20 2020 2020 2020 2069 6620     ).        if 
+0000c4b0: 6e75 6d5f 636f 6c6c 696d 6174 6f72 5f6c  num_collimator_l
+0000c4c0: 696b 655f 696d 6167 6573 203e 2031 3a0a  ike_images > 1:.
+0000c4d0: 2020 2020 2020 2020 2020 2020 7265 7475              retu
+0000c4e0: 726e 2073 656c 662e 5f66 696e 645f 6d61  rn self._find_ma
+0000c4f0: 785f 6469 7374 616e 6365 5f62 6574 7765  x_distance_betwe
+0000c500: 656e 5f70 6f69 6e74 7328 696d 6167 6573  en_points(images
+0000c510: 290a 2020 2020 2020 2020 656c 7365 3a0a  ).        else:.
+0000c520: 2020 2020 2020 2020 2020 2020 7265 7475              retu
+0000c530: 726e 2030 0a0a 2020 2020 4070 726f 7065  rn 0..    @prope
+0000c540: 7274 790a 2020 2020 6465 6620 636f 7563  rty.    def couc
+0000c550: 685f 6973 6f5f 7369 7a65 2873 656c 6629  h_iso_size(self)
+0000c560: 202d 3e20 666c 6f61 743a 0a20 2020 2020   -> float:.     
+0000c570: 2020 2022 2222 5468 6520 6469 616d 6574     """The diamet
+0000c580: 6572 206f 6620 7468 6520 3244 2063 6f75  er of the 2D cou
+0000c590: 6368 2069 736f 6365 6e74 6572 2073 697a  ch isocenter siz
+0000c5a0: 6520 696e 206d 6d2e 204f 6e6c 7920 696d  e in mm. Only im
+0000c5b0: 6167 6573 2077 6865 7265 0a20 2020 2020  ages where.     
+0000c5c0: 2020 2074 6865 2067 616e 7472 7920 616e     the gantry an
+0000c5d0: 6420 636f 6c6c 696d 6174 6f72 2077 6572  d collimator wer
+0000c5e0: 6520 6174 207a 6572 6f20 6172 6520 7573  e at zero are us
+0000c5f0: 6564 2074 6f20 6465 7465 726d 696e 6520  ed to determine 
+0000c600: 7468 6973 2076 616c 7565 2e22 2222 0a20  this value.""". 
+0000c610: 2020 2020 2020 206e 756d 5f63 6f75 6368         num_couch
+0000c620: 5f6c 696b 655f 696d 6167 6573 2c20 696d  _like_images, im
+0000c630: 6167 6573 203d 2073 656c 662e 5f67 6574  ages = self._get
+0000c640: 5f69 6d61 6765 7328 2841 7869 732e 434f  _images((Axis.CO
+0000c650: 5543 482c 2041 7869 732e 5245 4645 5245  UCH, Axis.REFERE
+0000c660: 4e43 4529 290a 2020 2020 2020 2020 6966  NCE)).        if
+0000c670: 206e 756d 5f63 6f75 6368 5f6c 696b 655f   num_couch_like_
+0000c680: 696d 6167 6573 203e 2031 3a0a 2020 2020  images > 1:.    
+0000c690: 2020 2020 2020 2020 7265 7475 726e 2073          return s
+0000c6a0: 656c 662e 5f66 696e 645f 6d61 785f 6469  elf._find_max_di
+0000c6b0: 7374 616e 6365 5f62 6574 7765 656e 5f70  stance_between_p
+0000c6c0: 6f69 6e74 7328 696d 6167 6573 290a 2020  oints(images).  
+0000c6d0: 2020 2020 2020 656c 7365 3a0a 2020 2020        else:.    
+0000c6e0: 2020 2020 2020 2020 7265 7475 726e 2030          return 0
+0000c6f0: 0a0a 2020 2020 4070 726f 7065 7274 790a  ..    @property.
+0000c700: 2020 2020 6465 6620 6262 5f73 6869 6674      def bb_shift
+0000c710: 5f76 6563 746f 7228 7365 6c66 2920 2d3e  _vector(self) ->
+0000c720: 2056 6563 746f 723a 0a20 2020 2020 2020   Vector:.       
+0000c730: 2022 2222 5468 6520 7368 6966 7420 6e65   """The shift ne
+0000c740: 6365 7373 6172 7920 746f 2070 6c61 6365  cessary to place
+0000c750: 2074 6865 2042 4220 6174 2074 6865 2072   the BB at the r
+0000c760: 6164 6961 7469 6f6e 2069 736f 6365 6e74  adiation isocent
+0000c770: 6572 2e0a 2020 2020 2020 2020 5468 6520  er..        The 
+0000c780: 7661 6c75 6573 2061 7265 2069 6e20 7468  values are in th
+0000c790: 6520 636f 6f72 6469 6e61 7465 7320 6465  e coordinates de
+0000c7a0: 6669 6e65 6420 696e 2074 6865 2064 6f63  fined in the doc
+0000c7b0: 756d 656e 7461 7469 6f6e 2e0a 0a20 2020  umentation...   
+0000c7c0: 2020 2020 2054 6865 2073 6869 6674 2069       The shift i
+0000c7d0: 7320 6261 7365 6420 6f6e 2074 6865 2070  s based on the p
+0000c7e0: 6170 6572 2062 7920 4c6f 7720 6574 2061  aper by Low et a
+0000c7f0: 6c2e 2053 6565 206f 6e6c 696e 6520 646f  l. See online do
+0000c800: 6375 6d65 6e74 6174 696f 6e20 616e 6420  cumentation and 
+0000c810: 7468 6520 6060 736f 6c76 655f 3364 5f73  the ``solve_3d_s
+0000c820: 6869 6674 5f76 6563 746f 725f 6672 6f6d  hift_vector_from
+0000c830: 5f32 645f 706c 616e 6573 6060 2066 756e  _2d_planes`` fun
+0000c840: 6374 696f 6e20 666f 7220 6d6f 7265 2e2c  ction for more.,
+0000c850: 0a20 2020 2020 2020 2077 6869 6368 2069  .        which i
+0000c860: 7320 686f 7720 7468 6520 6d65 6173 7572  s how the measur
+0000c870: 6564 2062 6220 616e 6420 6669 656c 6420  ed bb and field 
+0000c880: 706f 7369 7469 6f6e 7320 6172 6520 6465  positions are de
+0000c890: 7465 726d 696e 6564 2e0a 2020 2020 2020  termined..      
+0000c8a0: 2020 2222 220a 2020 2020 2020 2020 2320    """.        # 
+0000c8b0: 6669 656c 6420 6d69 6e75 7320 4242 2077  field minus BB w
+0000c8c0: 696c 6c20 6769 7665 2074 6865 2073 6869  ill give the shi
+0000c8d0: 6674 2076 6563 746f 7220 746f 2052 4554  ft vector to RET
+0000c8e0: 5552 4e20 544f 2049 534f 2077 6869 6368  URN TO ISO which
+0000c8f0: 2069 7320 7768 6174 2077 6520 7761 6e74   is what we want
+0000c900: 2e20 4242 206d 696e 7573 2066 6965 6c64  . BB minus field
+0000c910: 2077 6f75 6c64 2067 6976 6520 7468 6520   would give the 
+0000c920: 7665 6374 6f72 2066 726f 6d20 6669 656c  vector from fiel
+0000c930: 6420 746f 2074 6865 2042 422e 0a20 2020  d to the BB..   
+0000c940: 2020 2020 2072 6574 7572 6e20 7365 6c66       return self
+0000c950: 2e62 622e 6d65 6173 7572 6564 5f66 6965  .bb.measured_fie
+0000c960: 6c64 5f70 6f73 6974 696f 6e20 2d20 7365  ld_position - se
+0000c970: 6c66 2e62 622e 6d65 6173 7572 6564 5f62  lf.bb.measured_b
+0000c980: 625f 706f 7369 7469 6f6e 0a0a 2020 2020  b_position..    
+0000c990: 6465 6620 6262 5f73 6869 6674 5f69 6e73  def bb_shift_ins
+0000c9a0: 7472 7563 7469 6f6e 7328 0a20 2020 2020  tructions(.     
+0000c9b0: 2020 2073 656c 662c 0a20 2020 2020 2020     self,.       
+0000c9c0: 2063 6f75 6368 5f76 7274 3a20 666c 6f61   couch_vrt: floa
+0000c9d0: 7420 7c20 4e6f 6e65 203d 204e 6f6e 652c  t | None = None,
+0000c9e0: 0a20 2020 2020 2020 2063 6f75 6368 5f6c  .        couch_l
+0000c9f0: 6e67 3a20 666c 6f61 7420 7c20 4e6f 6e65  ng: float | None
+0000ca00: 203d 204e 6f6e 652c 0a20 2020 2020 2020   = None,.       
+0000ca10: 2063 6f75 6368 5f6c 6174 3a20 666c 6f61   couch_lat: floa
+0000ca20: 7420 7c20 4e6f 6e65 203d 204e 6f6e 652c  t | None = None,
+0000ca30: 0a20 2020 2029 202d 3e20 7374 723a 0a20  .    ) -> str:. 
+0000ca40: 2020 2020 2020 2022 2222 5265 7475 726e         """Return
+0000ca50: 7320 6120 7374 7269 6e67 2064 6573 6372  s a string descr
+0000ca60: 6962 696e 6720 686f 7720 746f 2073 6869  ibing how to shi
+0000ca70: 6674 2074 6865 2042 4220 746f 2074 6865  ft the BB to the
+0000ca80: 2072 6164 6961 7469 6f6e 2069 736f 6365   radiation isoce
+0000ca90: 6e74 6572 206c 6f6f 6b69 6e67 2066 726f  nter looking fro
+0000caa0: 6d20 7468 6520 666f 6f74 206f 6620 7468  m the foot of th
+0000cab0: 6520 636f 7563 682e 0a20 2020 2020 2020  e couch..       
+0000cac0: 204f 7074 696f 6e61 6c6c 792c 2074 6865   Optionally, the
+0000cad0: 2063 7572 7265 6e74 2063 6f75 6368 2076   current couch v
+0000cae0: 616c 7565 7320 6361 6e20 6265 2070 6173  alues can be pas
+0000caf0: 7365 6420 696e 2074 6f20 6765 7420 7468  sed in to get th
+0000cb00: 6520 6e65 7720 636f 7563 6820 7661 6c75  e new couch valu
+0000cb10: 6573 2e20 4966 2070 6173 7369 6e67 2074  es. If passing t
+0000cb20: 6865 2063 7572 7265 6e74 0a20 2020 2020  he current.     
+0000cb30: 2020 2063 6f75 6368 2070 6f73 6974 696f     couch positio
+0000cb40: 6e20 616c 6c20 7661 6c75 6573 206d 7573  n all values mus
+0000cb50: 7420 6265 2070 6173 7365 642e 0a0a 2020  t be passed...  
+0000cb60: 2020 2020 2020 5061 7261 6d65 7465 7273        Parameters
+0000cb70: 0a20 2020 2020 2020 202d 2d2d 2d2d 2d2d  .        -------
+0000cb80: 2d2d 2d0a 2020 2020 2020 2020 636f 7563  ---.        couc
+0000cb90: 685f 7672 7420 3a20 666c 6f61 740a 2020  h_vrt : float.  
+0000cba0: 2020 2020 2020 2020 2020 5468 6520 6375            The cu
+0000cbb0: 7272 656e 7420 636f 7563 6820 7665 7274  rrent couch vert
+0000cbc0: 6963 616c 2070 6f73 6974 696f 6e20 696e  ical position in
+0000cbd0: 2063 6d2e 0a20 2020 2020 2020 2063 6f75   cm..        cou
+0000cbe0: 6368 5f6c 6e67 203a 2066 6c6f 6174 0a20  ch_lng : float. 
+0000cbf0: 2020 2020 2020 2020 2020 2054 6865 2063             The c
+0000cc00: 7572 7265 6e74 2063 6f75 6368 206c 6f6e  urrent couch lon
+0000cc10: 6769 7475 6469 6e61 6c20 706f 7369 7469  gitudinal positi
+0000cc20: 6f6e 2069 6e20 636d 2e0a 2020 2020 2020  on in cm..      
+0000cc30: 2020 636f 7563 685f 6c61 7420 3a20 666c    couch_lat : fl
+0000cc40: 6f61 740a 2020 2020 2020 2020 2020 2020  oat.            
+0000cc50: 5468 6520 6375 7272 656e 7420 636f 7563  The current couc
+0000cc60: 6820 6c61 7465 7261 6c20 706f 7369 7469  h lateral positi
+0000cc70: 6f6e 2069 6e20 636d 2e0a 2020 2020 2020  on in cm..      
+0000cc80: 2020 2222 220a 2020 2020 2020 2020 7376    """.        sv
+0000cc90: 203d 2073 656c 662e 6262 5f73 6869 6674   = self.bb_shift
+0000cca0: 5f76 6563 746f 720a 2020 2020 2020 2020  _vector.        
+0000ccb0: 785f 6469 7220 3d20 224c 4546 5422 2069  x_dir = "LEFT" i
+0000ccc0: 6620 7376 2e78 203c 2030 2065 6c73 6520  f sv.x < 0 else 
+0000ccd0: 2252 4947 4854 220a 2020 2020 2020 2020  "RIGHT".        
+0000cce0: 795f 6469 7220 3d20 2249 4e22 2069 6620  y_dir = "IN" if 
+0000ccf0: 7376 2e79 203e 2030 2065 6c73 6520 224f  sv.y > 0 else "O
+0000cd00: 5554 220a 2020 2020 2020 2020 7a5f 6469  UT".        z_di
+0000cd10: 7220 3d20 2255 5022 2069 6620 7376 2e7a  r = "UP" if sv.z
+0000cd20: 203e 2030 2065 6c73 6520 2244 4f57 4e22   > 0 else "DOWN"
+0000cd30: 0a20 2020 2020 2020 206d 6f76 6520 3d20  .        move = 
+0000cd40: 6622 7b78 5f64 6972 7d20 7b61 6273 2873  f"{x_dir} {abs(s
+0000cd50: 762e 7829 3a32 2e32 667d 6d6d 3b20 7b79  v.x):2.2f}mm; {y
+0000cd60: 5f64 6972 7d20 7b61 6273 2873 762e 7929  _dir} {abs(sv.y)
+0000cd70: 3a32 2e32 667d 6d6d 3b20 7b7a 5f64 6972  :2.2f}mm; {z_dir
+0000cd80: 7d20 7b61 6273 2873 762e 7a29 3a32 2e32  } {abs(sv.z):2.2
+0000cd90: 667d 6d6d 220a 2020 2020 2020 2020 6966  f}mm".        if
+0000cda0: 2061 6c6c 2876 616c 2069 7320 6e6f 7420   all(val is not 
+0000cdb0: 4e6f 6e65 2066 6f72 2076 616c 2069 6e20  None for val in 
+0000cdc0: 5b63 6f75 6368 5f76 7274 2c20 636f 7563  [couch_vrt, couc
+0000cdd0: 685f 6c61 742c 2063 6f75 6368 5f6c 6e67  h_lat, couch_lng
+0000cde0: 5d29 3a0a 2020 2020 2020 2020 2020 2020  ]):.            
+0000cdf0: 6e65 775f 6c61 7420 3d20 726f 756e 6428  new_lat = round(
+0000ce00: 636f 7563 685f 6c61 7420 2b20 7376 2e78  couch_lat + sv.x
+0000ce10: 202f 2031 302c 2032 290a 2020 2020 2020   / 10, 2).      
+0000ce20: 2020 2020 2020 6e65 775f 7672 7420 3d20        new_vrt = 
+0000ce30: 726f 756e 6428 636f 7563 685f 7672 7420  round(couch_vrt 
+0000ce40: 2b20 7376 2e7a 202f 2031 302c 2032 290a  + sv.z / 10, 2).
+0000ce50: 2020 2020 2020 2020 2020 2020 6e65 775f              new_
+0000ce60: 6c6e 6720 3d20 726f 756e 6428 636f 7563  lng = round(couc
+0000ce70: 685f 6c6e 6720 2b20 7376 2e79 202f 2031  h_lng + sv.y / 1
+0000ce80: 302c 2032 290a 2020 2020 2020 2020 2020  0, 2).          
+0000ce90: 2020 6d6f 7665 202b 3d20 6622 5c6e 4e65    move += f"\nNe
+0000cea0: 7720 636f 7563 6820 636f 6f72 6469 6e61  w couch coordina
+0000ceb0: 7465 7320 286d 6d29 3a20 5652 543a 207b  tes (mm): VRT: {
+0000cec0: 6e65 775f 7672 743a 332e 3266 7d3b 204c  new_vrt:3.2f}; L
+0000ced0: 4e47 3a20 7b6e 6577 5f6c 6e67 3a33 2e32  NG: {new_lng:3.2
+0000cee0: 667d 3b20 4c41 543a 207b 6e65 775f 6c61  f}; LAT: {new_la
+0000cef0: 743a 332e 3266 7d22 0a20 2020 2020 2020  t:3.2f}".       
+0000cf00: 2072 6574 7572 6e20 6d6f 7665 0a0a 2020   return move..  
+0000cf10: 2020 4061 7267 7565 2e6f 7074 696f 6e73    @argue.options
+0000cf20: 2876 616c 7565 3d28 2261 6c6c 222c 2022  (value=("all", "
+0000cf30: 7261 6e67 6522 2929 0a20 2020 2064 6566  range")).    def
+0000cf40: 2061 7869 735f 726d 735f 6465 7669 6174   axis_rms_deviat
+0000cf50: 696f 6e28 0a20 2020 2020 2020 2073 656c  ion(.        sel
+0000cf60: 662c 2061 7869 733a 2041 7869 7320 7c20  f, axis: Axis | 
+0000cf70: 7475 706c 655b 4178 6973 2c20 2e2e 2e5d  tuple[Axis, ...]
+0000cf80: 203d 2041 7869 732e 4741 4e54 5259 2c20   = Axis.GANTRY, 
+0000cf90: 7661 6c75 653a 2073 7472 203d 2022 616c  value: str = "al
+0000cfa0: 6c22 0a20 2020 2029 202d 3e20 4974 6572  l".    ) -> Iter
+0000cfb0: 6162 6c65 207c 2066 6c6f 6174 3a0a 2020  able | float:.  
+0000cfc0: 2020 2020 2020 2222 2254 6865 2052 4d53        """The RMS
+0000cfd0: 2064 6576 6961 7469 6f6e 7320 6f66 2061   deviations of a
+0000cfe0: 2067 6976 656e 2061 7869 732f 6178 6573   given axis/axes
+0000cff0: 2e0a 0a20 2020 2020 2020 2050 6172 616d  ...        Param
+0000d000: 6574 6572 730a 2020 2020 2020 2020 2d2d  eters.        --
+0000d010: 2d2d 2d2d 2d2d 2d2d 0a20 2020 2020 2020  --------.       
+0000d020: 2061 7869 7320 3a20 2827 4761 6e74 7279   axis : ('Gantry
+0000d030: 272c 2027 436f 6c6c 696d 6174 6f72 272c  ', 'Collimator',
+0000d040: 2027 436f 7563 6827 2c20 2745 7069 6427   'Couch', 'Epid'
+0000d050: 2c20 2747 4220 436f 6d62 6f27 2c20 2027  , 'GB Combo',  '
+0000d060: 4742 5020 436f 6d62 6f27 290a 2020 2020  GBP Combo').    
+0000d070: 2020 2020 2020 2020 5468 6520 6178 6973          The axis
+0000d080: 2064 6573 6972 6564 2e0a 2020 2020 2020   desired..      
+0000d090: 2020 7661 6c75 6520 3a20 7b27 616c 6c27    value : {'all'
+0000d0a0: 2c20 2772 616e 6765 277d 0a20 2020 2020  , 'range'}.     
+0000d0b0: 2020 2020 2020 2057 6865 7468 6572 2074         Whether t
+0000d0c0: 6f20 7265 7475 726e 2061 6c6c 2074 6865  o return all the
+0000d0d0: 2052 4d53 2076 616c 7565 7320 6672 6f6d   RMS values from
+0000d0e0: 2061 6c6c 2069 6d61 6765 7320 666f 7220   all images for 
+0000d0f0: 7468 6174 2061 7869 732c 206f 7220 6f6e  that axis, or on
+0000d100: 6c79 2072 6574 7572 6e20 7468 6520 6d61  ly return the ma
+0000d110: 7869 6d75 6d20 7261 6e67 6520 6f66 0a20  ximum range of. 
+0000d120: 2020 2020 2020 2020 2020 2076 616c 7565             value
+0000d130: 732c 2069 2e65 2e20 7468 6520 2773 6167  s, i.e. the 'sag
+0000d140: 272e 0a20 2020 2020 2020 2022 2222 0a20  '..        """. 
+0000d150: 2020 2020 2020 2069 6620 6973 696e 7374         if isinst
+0000d160: 616e 6365 2861 7869 732c 2049 7465 7261  ance(axis, Itera
+0000d170: 626c 6529 3a0a 2020 2020 2020 2020 2020  ble):.          
+0000d180: 2020 6178 6973 203d 205b 636f 6e76 6572    axis = [conver
+0000d190: 745f 746f 5f65 6e75 6d28 6178 2c20 4178  t_to_enum(ax, Ax
+0000d1a0: 6973 2920 666f 7220 6178 2069 6e20 6178  is) for ax in ax
+0000d1b0: 6973 5d0a 2020 2020 2020 2020 656c 7365  is].        else
+0000d1c0: 3a0a 2020 2020 2020 2020 2020 2020 6178  :.            ax
+0000d1d0: 6973 203d 2063 6f6e 7665 7274 5f74 6f5f  is = convert_to_
+0000d1e0: 656e 756d 2861 7869 732c 2041 7869 7329  enum(axis, Axis)
+0000d1f0: 0a20 2020 2020 2020 2069 6620 6178 6973  .        if axis
+0000d200: 2021 3d20 4178 6973 2e45 5049 443a 0a20   != Axis.EPID:. 
+0000d210: 2020 2020 2020 2020 2020 2061 7474 7220             attr 
+0000d220: 3d20 2263 6178 3262 625f 7665 6374 6f72  = "cax2bb_vector
+0000d230: 220a 2020 2020 2020 2020 656c 7365 3a0a  ".        else:.
+0000d240: 2020 2020 2020 2020 2020 2020 6174 7472              attr
+0000d250: 203d 2022 6361 7832 6570 6964 5f76 6563   = "cax2epid_vec
+0000d260: 746f 7222 0a20 2020 2020 2020 2020 2020  tor".           
+0000d270: 2061 7869 7320 3d20 2841 7869 732e 4741   axis = (Axis.GA
+0000d280: 4e54 5259 2c20 4178 6973 2e43 4f4c 4c49  NTRY, Axis.COLLI
+0000d290: 4d41 544f 522c 2041 7869 732e 5245 4645  MATOR, Axis.REFE
+0000d2a0: 5245 4e43 4529 0a20 2020 2020 2020 2069  RENCE).        i
+0000d2b0: 6d67 7320 3d20 7365 6c66 2e5f 6765 745f  mgs = self._get_
+0000d2c0: 696d 6167 6573 2861 7869 733d 6178 6973  images(axis=axis
+0000d2d0: 295b 315d 0a20 2020 2020 2020 2069 6620  )[1].        if 
+0000d2e0: 6c65 6e28 696d 6773 2920 3c3d 2031 3a0a  len(imgs) <= 1:.
+0000d2f0: 2020 2020 2020 2020 2020 2020 7265 7475              retu
+0000d300: 726e 2028 302c 290a 2020 2020 2020 2020  rn (0,).        
+0000d310: 726d 7320 3d20 5b67 6574 6174 7472 2869  rms = [getattr(i
+0000d320: 6d67 2c20 6174 7472 292e 6173 5f73 6361  mg, attr).as_sca
+0000d330: 6c61 7228 2920 666f 7220 696d 6720 696e  lar() for img in
+0000d340: 2069 6d67 735d 0a20 2020 2020 2020 2069   imgs].        i
+0000d350: 6620 7661 6c75 6520 3d3d 2022 7261 6e67  f value == "rang
+0000d360: 6522 3a0a 2020 2020 2020 2020 2020 2020  e":.            
+0000d370: 726d 7320 3d20 6d61 7828 726d 7329 202d  rms = max(rms) -
+0000d380: 206d 696e 2872 6d73 290a 2020 2020 2020   min(rms).      
+0000d390: 2020 7265 7475 726e 2072 6d73 0a0a 2020    return rms..  
+0000d3a0: 2020 4061 7267 7565 2e6f 7074 696f 6e73    @argue.options
+0000d3b0: 286d 6574 7269 633d 2822 6d61 7822 2c20  (metric=("max", 
+0000d3c0: 226d 6564 6961 6e22 2c20 226d 6561 6e22  "median", "mean"
+0000d3d0: 2929 0a20 2020 2064 6566 2063 6178 3262  )).    def cax2b
+0000d3e0: 625f 6469 7374 616e 6365 2873 656c 662c  b_distance(self,
+0000d3f0: 206d 6574 7269 633a 2073 7472 203d 2022   metric: str = "
+0000d400: 6d61 7822 2920 2d3e 2066 6c6f 6174 3a0a  max") -> float:.
+0000d410: 2020 2020 2020 2020 2222 2254 6865 2064          """The d
+0000d420: 6973 7461 6e63 6520 696e 206d 6d20 6265  istance in mm be
+0000d430: 7477 6565 6e20 7468 6520 4341 5820 616e  tween the CAX an
+0000d440: 6420 4242 2066 6f72 2061 6c6c 2069 6d61  d BB for all ima
+0000d450: 6765 7320 6163 636f 7264 696e 6720 746f  ges according to
+0000d460: 2074 6865 2067 6976 656e 206d 6574 7269   the given metri
+0000d470: 632e 0a0a 2020 2020 2020 2020 5061 7261  c...        Para
+0000d480: 6d65 7465 7273 0a20 2020 2020 2020 202d  meters.        -
+0000d490: 2d2d 2d2d 2d2d 2d2d 2d0a 2020 2020 2020  ---------.      
+0000d4a0: 2020 6d65 7472 6963 203a 207b 276d 6178    metric : {'max
+0000d4b0: 272c 2027 6d65 6469 616e 272c 2027 6d65  ', 'median', 'me
+0000d4c0: 616e 277d 0a20 2020 2020 2020 2020 2020  an'}.           
+0000d4d0: 2054 6865 206d 6574 7269 6320 6f66 2064   The metric of d
+0000d4e0: 6973 7461 6e63 6520 746f 2075 7365 2e0a  istance to use..
+0000d4f0: 2020 2020 2020 2020 2222 220a 2020 2020          """.    
+0000d500: 2020 2020 6469 7374 616e 6365 7320 3d20      distances = 
+0000d510: 5b5d 0a20 2020 2020 2020 2066 6f72 2069  [].        for i
+0000d520: 6d67 2069 6e20 7365 6c66 2e69 6d61 6765  mg in self.image
+0000d530: 733a 0a20 2020 2020 2020 2020 2020 2064  s:.            d
+0000d540: 6973 7461 6e63 6573 2e65 7874 656e 6428  istances.extend(
+0000d550: 696d 672e 6669 656c 645f 746f 5f62 625f  img.field_to_bb_
+0000d560: 6469 7374 616e 6365 7328 2929 0a20 2020  distances()).   
+0000d570: 2020 2020 2069 6620 6d65 7472 6963 203d       if metric =
+0000d580: 3d20 226d 6178 223a 0a20 2020 2020 2020  = "max":.       
+0000d590: 2020 2020 2072 6574 7572 6e20 6d61 7828       return max(
+0000d5a0: 6469 7374 616e 6365 7329 0a20 2020 2020  distances).     
+0000d5b0: 2020 2065 6c69 6620 6d65 7472 6963 203d     elif metric =
+0000d5c0: 3d20 226d 6564 6961 6e22 3a0a 2020 2020  = "median":.    
+0000d5d0: 2020 2020 2020 2020 7265 7475 726e 2073          return s
+0000d5e0: 7461 7469 7374 6963 732e 6d65 6469 616e  tatistics.median
+0000d5f0: 2864 6973 7461 6e63 6573 290a 2020 2020  (distances).    
+0000d600: 2020 2020 656c 6966 206d 6574 7269 6320      elif metric 
+0000d610: 3d3d 2022 6d65 616e 223a 0a20 2020 2020  == "mean":.     
+0000d620: 2020 2020 2020 2072 6574 7572 6e20 7374         return st
+0000d630: 6174 6973 7469 6373 2e6d 6561 6e28 6469  atistics.mean(di
+0000d640: 7374 616e 6365 7329 0a0a 2020 2020 4061  stances)..    @a
+0000d650: 7267 7565 2e6f 7074 696f 6e73 286d 6574  rgue.options(met
+0000d660: 7269 633d 2822 6d61 7822 2c20 226d 6564  ric=("max", "med
+0000d670: 6961 6e22 2c20 226d 6561 6e22 2929 0a20  ian", "mean")). 
+0000d680: 2020 2064 6566 2063 6178 3265 7069 645f     def cax2epid_
+0000d690: 6469 7374 616e 6365 2873 656c 662c 206d  distance(self, m
+0000d6a0: 6574 7269 633a 2073 7472 203d 2022 6d61  etric: str = "ma
+0000d6b0: 7822 2920 2d3e 2066 6c6f 6174 3a0a 2020  x") -> float:.  
+0000d6c0: 2020 2020 2020 2222 2254 6865 2064 6973        """The dis
+0000d6d0: 7461 6e63 6520 696e 206d 6d20 6265 7477  tance in mm betw
+0000d6e0: 6565 6e20 7468 6520 4341 5820 616e 6420  een the CAX and 
+0000d6f0: 4550 4944 2063 656e 7465 7220 7069 7865  EPID center pixe
+0000d700: 6c20 666f 7220 616c 6c20 696d 6167 6573  l for all images
+0000d710: 2061 6363 6f72 6469 6e67 2074 6f20 7468   according to th
+0000d720: 6520 6769 7665 6e20 6d65 7472 6963 2e0a  e given metric..
+0000d730: 0a20 2020 2020 2020 2050 6172 616d 6574  .        Paramet
+0000d740: 6572 730a 2020 2020 2020 2020 2d2d 2d2d  ers.        ----
+0000d750: 2d2d 2d2d 2d2d 0a20 2020 2020 2020 206d  ------.        m
+0000d760: 6574 7269 6320 3a20 7b27 6d61 7827 2c20  etric : {'max', 
+0000d770: 276d 6564 6961 6e27 2c20 276d 6561 6e27  'median', 'mean'
+0000d780: 7d0a 2020 2020 2020 2020 2020 2020 5468  }.            Th
+0000d790: 6520 6d65 7472 6963 206f 6620 6469 7374  e metric of dist
+0000d7a0: 616e 6365 2074 6f20 7573 652e 0a20 2020  ance to use..   
+0000d7b0: 2020 2020 2022 2222 0a20 2020 2020 2020       """.       
+0000d7c0: 2064 6973 7461 6e63 6573 203d 205b 5d0a   distances = [].
+0000d7d0: 2020 2020 2020 2020 666f 7220 696d 6720          for img 
+0000d7e0: 696e 2073 656c 662e 696d 6167 6573 3a0a  in self.images:.
+0000d7f0: 2020 2020 2020 2020 2020 2020 6469 7374              dist
+0000d800: 616e 6365 732e 6578 7465 6e64 2869 6d67  ances.extend(img
+0000d810: 2e65 7069 645f 746f 5f62 625f 6469 7374  .epid_to_bb_dist
+0000d820: 616e 6365 7328 2929 0a20 2020 2020 2020  ances()).       
+0000d830: 2069 6620 6d65 7472 6963 203d 3d20 226d   if metric == "m
+0000d840: 6178 223a 0a20 2020 2020 2020 2020 2020  ax":.           
+0000d850: 2072 6574 7572 6e20 6d61 7828 6469 7374   return max(dist
+0000d860: 616e 6365 7329 0a20 2020 2020 2020 2065  ances).        e
+0000d870: 6c69 6620 6d65 7472 6963 203d 3d20 226d  lif metric == "m
+0000d880: 6564 6961 6e22 3a0a 2020 2020 2020 2020  edian":.        
+0000d890: 2020 2020 7265 7475 726e 2073 7461 7469      return stati
+0000d8a0: 7374 6963 732e 6d65 6469 616e 2864 6973  stics.median(dis
+0000d8b0: 7461 6e63 6573 290a 2020 2020 2020 2020  tances).        
+0000d8c0: 656c 6966 206d 6574 7269 6320 3d3d 2022  elif metric == "
+0000d8d0: 6d65 616e 223a 0a20 2020 2020 2020 2020  mean":.         
+0000d8e0: 2020 2072 6574 7572 6e20 7374 6174 6973     return statis
+0000d8f0: 7469 6373 2e6d 6561 6e28 6469 7374 616e  tics.mean(distan
+0000d900: 6365 7329 0a0a 2020 2020 6465 6620 5f70  ces)..    def _p
+0000d910: 6c6f 745f 6465 7669 6174 696f 6e28 0a20  lot_deviation(. 
+0000d920: 2020 2020 2020 2073 656c 662c 2061 7869         self, axi
+0000d930: 733a 2041 7869 732c 2061 783a 2070 6c74  s: Axis, ax: plt
+0000d940: 2e41 7865 7320 7c20 4e6f 6e65 203d 204e  .Axes | None = N
+0000d950: 6f6e 652c 2073 686f 773a 2062 6f6f 6c20  one, show: bool 
+0000d960: 3d20 5472 7565 0a20 2020 2029 202d 3e20  = True.    ) -> 
+0000d970: 4e6f 6e65 3a0a 2020 2020 2020 2020 2222  None:.        ""
+0000d980: 2248 656c 7065 7220 6675 6e63 7469 6f6e  "Helper function
+0000d990: 3a20 506c 6f74 2074 6865 2073 6167 2069  : Plot the sag i
+0000d9a0: 6e20 4361 7274 6573 6961 6e20 636f 6f72  n Cartesian coor
+0000d9b0: 6469 6e61 7465 732e 0a0a 2020 2020 2020  dinates...      
+0000d9c0: 2020 5061 7261 6d65 7465 7273 0a20 2020    Parameters.   
+0000d9d0: 2020 2020 202d 2d2d 2d2d 2d2d 2d2d 2d0a       ----------.
+0000d9e0: 2020 2020 2020 2020 6178 6973 203a 207b          axis : {
+0000d9f0: 2767 616e 7472 7927 2c20 2765 7069 6427  'gantry', 'epid'
+0000da00: 2c20 2763 6f6c 6c69 6d61 746f 7227 2c20  , 'collimator', 
+0000da10: 2763 6f75 6368 277d 0a20 2020 2020 2020  'couch'}.       
+0000da20: 2020 2020 2054 6865 2061 7869 7320 746f       The axis to
+0000da30: 2070 6c6f 742e 0a20 2020 2020 2020 2061   plot..        a
+0000da40: 7820 3a20 4e6f 6e65 2c20 6d61 7470 6c6f  x : None, matplo
+0000da50: 746c 6962 2e41 7865 730a 2020 2020 2020  tlib.Axes.      
+0000da60: 2020 2020 2020 5468 6520 6178 6973 2074        The axis t
+0000da70: 6f20 706c 6f74 2074 6f2e 2049 6620 4e6f  o plot to. If No
+0000da80: 6e65 2c20 6372 6561 7465 7320 6120 6e65  ne, creates a ne
+0000da90: 7720 706c 6f74 2e0a 2020 2020 2020 2020  w plot..        
+0000daa0: 7368 6f77 203a 2062 6f6f 6c0a 2020 2020  show : bool.    
+0000dab0: 2020 2020 2020 2020 5768 6574 6865 7220          Whether 
+0000dac0: 746f 2073 686f 7720 7468 6520 696d 6167  to show the imag
+0000dad0: 652e 0a20 2020 2020 2020 2022 2222 0a20  e..        """. 
+0000dae0: 2020 2020 2020 2074 6974 6c65 203d 2066         title = f
+0000daf0: 2249 6e2d 706c 616e 6520 7b61 7869 732e  "In-plane {axis.
+0000db00: 7661 6c75 657d 2064 6973 706c 6163 656d  value} displacem
+0000db10: 656e 7422 0a20 2020 2020 2020 2069 6620  ent".        if 
+0000db20: 6178 6973 203d 3d20 4178 6973 2e45 5049  axis == Axis.EPI
+0000db30: 443a 0a20 2020 2020 2020 2020 2020 2061  D:.            a
+0000db40: 7474 7220 3d20 2263 6178 3265 7069 645f  ttr = "cax2epid_
+0000db50: 7665 6374 6f72 220a 2020 2020 2020 2020  vector".        
+0000db60: 2020 2020 6178 6973 203d 2041 7869 732e      axis = Axis.
+0000db70: 4741 4e54 5259 0a20 2020 2020 2020 2065  GANTRY.        e
+0000db80: 6c73 653a 0a20 2020 2020 2020 2020 2020  lse:.           
+0000db90: 2061 7474 7220 3d20 2263 6178 3262 625f   attr = "cax2bb_
+0000dba0: 7665 6374 6f72 220a 2020 2020 2020 2020  vector".        
+0000dbb0: 2320 6765 7420 6178 6973 2069 6d61 6765  # get axis image
+0000dbc0: 732c 2061 6e67 6c65 732c 2061 6e64 2073  s, angles, and s
+0000dbd0: 6869 6674 730a 2020 2020 2020 2020 696d  hifts.        im
+0000dbe0: 6773 203d 205b 0a20 2020 2020 2020 2020  gs = [.         
+0000dbf0: 2020 2069 6d61 6765 0a20 2020 2020 2020     image.       
+0000dc00: 2020 2020 2066 6f72 2069 6d61 6765 2069       for image i
+0000dc10: 6e20 7365 6c66 2e69 6d61 6765 730a 2020  n self.images.  
+0000dc20: 2020 2020 2020 2020 2020 6966 2069 6d61            if ima
+0000dc30: 6765 2e76 6172 6961 626c 655f 6178 6973  ge.variable_axis
+0000dc40: 2069 6e20 2861 7869 732c 2041 7869 732e   in (axis, Axis.
+0000dc50: 5245 4645 5245 4e43 4529 0a20 2020 2020  REFERENCE).     
+0000dc60: 2020 205d 0a20 2020 2020 2020 2061 6e67     ].        ang
+0000dc70: 6c65 7320 3d20 5b67 6574 6174 7472 2869  les = [getattr(i
+0000dc80: 6d61 6765 2c20 6622 7b61 7869 732e 7661  mage, f"{axis.va
+0000dc90: 6c75 652e 6c6f 7765 7228 297d 5f61 6e67  lue.lower()}_ang
+0000dca0: 6c65 2229 2066 6f72 2069 6d61 6765 2069  le") for image i
+0000dcb0: 6e20 696d 6773 5d0a 2020 2020 2020 2020  n imgs].        
+0000dcc0: 787a 5f73 6167 203d 206e 702e 6172 7261  xz_sag = np.arra
+0000dcd0: 7928 5b67 6574 6174 7472 2869 6d67 2c20  y([getattr(img, 
+0000dce0: 6174 7472 292e 7820 666f 7220 696d 6720  attr).x for img 
+0000dcf0: 696e 2069 6d67 735d 290a 2020 2020 2020  in imgs]).      
+0000dd00: 2020 795f 7361 6720 3d20 6e70 2e61 7272    y_sag = np.arr
+0000dd10: 6179 285b 6765 7461 7474 7228 696d 672c  ay([getattr(img,
+0000dd20: 2061 7474 7229 2e79 2066 6f72 2069 6d67   attr).y for img
+0000dd30: 2069 6e20 696d 6773 5d29 0a20 2020 2020   in imgs]).     
+0000dd40: 2020 2072 6d73 203d 206e 702e 7371 7274     rms = np.sqrt
+0000dd50: 2878 7a5f 7361 672a 2a32 202b 2079 5f73  (xz_sag**2 + y_s
+0000dd60: 6167 2a2a 3229 0a0a 2020 2020 2020 2020  ag**2)..        
+0000dd70: 2320 706c 6f74 2074 6865 2061 7869 7320  # plot the axis 
+0000dd80: 6465 7669 6174 696f 6e0a 2020 2020 2020  deviation.      
+0000dd90: 2020 6966 2061 7820 6973 204e 6f6e 653a    if ax is None:
+0000dda0: 0a20 2020 2020 2020 2020 2020 2061 7820  .            ax 
+0000ddb0: 3d20 706c 742e 7375 6270 6c6f 7428 3131  = plt.subplot(11
+0000ddc0: 3129 0a20 2020 2020 2020 2061 782e 706c  1).        ax.pl
+0000ddd0: 6f74 2861 6e67 6c65 732c 2079 5f73 6167  ot(angles, y_sag
+0000dde0: 2c20 2262 6f22 2c20 6c61 6265 6c3d 2259  , "bo", label="Y
+0000ddf0: 2d61 7869 7322 2c20 6c73 3d22 2d2e 2229  -axis", ls="-.")
+0000de00: 0a20 2020 2020 2020 2061 782e 706c 6f74  .        ax.plot
+0000de10: 2861 6e67 6c65 732c 2078 7a5f 7361 672c  (angles, xz_sag,
+0000de20: 2022 6d5e 222c 206c 6162 656c 3d22 582f   "m^", label="X/
+0000de30: 5a2d 6178 6973 222c 206c 733d 222d 2e22  Z-axis", ls="-."
+0000de40: 290a 2020 2020 2020 2020 6178 2e70 6c6f  ).        ax.plo
+0000de50: 7428 616e 676c 6573 2c20 726d 732c 2022  t(angles, rms, "
+0000de60: 672b 222c 206c 6162 656c 3d22 524d 5322  g+", label="RMS"
+0000de70: 2c20 6c73 3d22 2d22 290a 2020 2020 2020  , ls="-").      
+0000de80: 2020 6178 2e73 6574 5f74 6974 6c65 2874    ax.set_title(t
+0000de90: 6974 6c65 290a 2020 2020 2020 2020 6178  itle).        ax
+0000dea0: 2e73 6574 5f79 6c61 6265 6c28 226d 6d22  .set_ylabel("mm"
+0000deb0: 290a 2020 2020 2020 2020 6178 2e73 6574  ).        ax.set
+0000dec0: 5f78 6c61 6265 6c28 6622 7b61 7869 732e  _xlabel(f"{axis.
+0000ded0: 7661 6c75 657d 2061 6e67 6c65 2229 0a20  value} angle"). 
+0000dee0: 2020 2020 2020 2061 782e 7365 745f 7874         ax.set_xt
+0000def0: 6963 6b73 286e 702e 6172 616e 6765 2830  icks(np.arange(0
+0000df00: 2c20 3336 312c 2034 3529 290a 2020 2020  , 361, 45)).    
+0000df10: 2020 2020 6178 2e73 6574 5f78 6c69 6d28      ax.set_xlim(
+0000df20: 2d31 352c 2033 3735 290a 2020 2020 2020  -15, 375).      
+0000df30: 2020 6178 2e67 7269 6428 5472 7565 290a    ax.grid(True).
+0000df40: 2020 2020 2020 2020 6178 2e6c 6567 656e          ax.legen
+0000df50: 6428 6e75 6d70 6f69 6e74 733d 3129 0a20  d(numpoints=1). 
+0000df60: 2020 2020 2020 2069 6620 7368 6f77 3a0a         if show:.
+0000df70: 2020 2020 2020 2020 2020 2020 706c 742e              plt.
+0000df80: 7368 6f77 2829 0a0a 2020 2020 6465 6620  show()..    def 
+0000df90: 5f67 6574 5f69 6d61 6765 7328 0a20 2020  _get_images(.   
+0000dfa0: 2020 2020 2073 656c 662c 2061 7869 733a       self, axis:
+0000dfb0: 2041 7869 7320 7c20 7475 706c 655b 4178   Axis | tuple[Ax
+0000dfc0: 6973 2c20 2e2e 2e5d 203d 2028 4178 6973  is, ...] = (Axis
+0000dfd0: 2e47 414e 5452 592c 290a 2020 2020 2920  .GANTRY,).    ) 
+0000dfe0: 2d3e 2074 7570 6c65 5b66 6c6f 6174 2c20  -> tuple[float, 
+0000dff0: 6c69 7374 5d3a 0a20 2020 2020 2020 2069  list]:.        i
+0000e000: 6620 6973 696e 7374 616e 6365 2861 7869  f isinstance(axi
+0000e010: 732c 2041 7869 7329 3a0a 2020 2020 2020  s, Axis):.      
+0000e020: 2020 2020 2020 6178 6973 203d 2028 6178        axis = (ax
+0000e030: 6973 2c29 0a20 2020 2020 2020 2069 6d61  is,).        ima
+0000e040: 6765 7320 3d20 5b69 6d61 6765 2066 6f72  ges = [image for
+0000e050: 2069 6d61 6765 2069 6e20 7365 6c66 2e69   image in self.i
+0000e060: 6d61 6765 7320 6966 2069 6d61 6765 2e76  mages if image.v
+0000e070: 6172 6961 626c 655f 6178 6973 2069 6e20  ariable_axis in 
+0000e080: 6178 6973 5d0a 2020 2020 2020 2020 7265  axis].        re
+0000e090: 7475 726e 206c 656e 2869 6d61 6765 7329  turn len(images)
+0000e0a0: 2c20 696d 6167 6573 0a0a 2020 2020 6465  , images..    de
+0000e0b0: 6620 706c 6f74 5f61 7869 735f 696d 6167  f plot_axis_imag
+0000e0c0: 6573 280a 2020 2020 2020 2020 7365 6c66  es(.        self
+0000e0d0: 2c20 6178 6973 3a20 4178 6973 203d 2041  , axis: Axis = A
+0000e0e0: 7869 732e 4741 4e54 5259 2c20 7368 6f77  xis.GANTRY, show
+0000e0f0: 3a20 626f 6f6c 203d 2054 7275 652c 2061  : bool = True, a
+0000e100: 783a 2070 6c74 2e41 7865 7320 7c20 4e6f  x: plt.Axes | No
+0000e110: 6e65 203d 204e 6f6e 650a 2020 2020 2920  ne = None.    ) 
+0000e120: 2d3e 204e 6f6e 653a 0a20 2020 2020 2020  -> None:.       
+0000e130: 2022 2222 506c 6f74 2061 6c6c 2043 4158   """Plot all CAX
+0000e140: 2f42 422f 4550 4944 2070 6f73 6974 696f  /BB/EPID positio
+0000e150: 6e73 2066 6f72 2074 6865 2069 6d61 6765  ns for the image
+0000e160: 7320 6f66 2061 2067 6976 656e 2061 7869  s of a given axi
+0000e170: 732e 0a0a 2020 2020 2020 2020 466f 7220  s...        For 
+0000e180: 6578 616d 706c 652c 2061 7869 733d 2743  example, axis='C
+0000e190: 6f75 6368 2720 706c 6f74 7320 6120 7265  ouch' plots a re
+0000e1a0: 6665 7265 6e63 6520 696d 6167 652c 2061  ference image, a
+0000e1b0: 6e64 2061 6c6c 2074 6865 2042 4220 706f  nd all the BB po
+0000e1c0: 696e 7473 206f 6620 7468 6520 6f74 6865  ints of the othe
+0000e1d0: 720a 2020 2020 2020 2020 696d 6167 6573  r.        images
+0000e1e0: 2077 6865 7265 2074 6865 2063 6f75 6368   where the couch
+0000e1f0: 2077 6173 206d 6f76 696e 672e 0a0a 2020   was moving...  
+0000e200: 2020 2020 2020 5061 7261 6d65 7465 7273        Parameters
+0000e210: 0a20 2020 2020 2020 202d 2d2d 2d2d 2d2d  .        -------
+0000e220: 2d2d 2d0a 2020 2020 2020 2020 6178 6973  ---.        axis
+0000e230: 203a 207b 2747 616e 7472 7927 2c20 2743   : {'Gantry', 'C
+0000e240: 6f6c 6c69 6d61 746f 7227 2c20 2743 6f75  ollimator', 'Cou
+0000e250: 6368 272c 2027 4742 2043 6f6d 626f 272c  ch', 'GB Combo',
+0000e260: 2020 2747 4250 2043 6f6d 626f 277d 0a20    'GBP Combo'}. 
+0000e270: 2020 2020 2020 2020 2020 2054 6865 2069             The i
+0000e280: 6d61 6765 732f 6d61 726b 6572 7320 6672  mages/markers fr
+0000e290: 6f6d 2077 6869 6368 2061 6363 656c 6572  om which acceler
+0000e2a0: 6174 6f72 2061 7869 7320 746f 2070 6c6f  ator axis to plo
+0000e2b0: 742e 0a20 2020 2020 2020 2073 686f 7720  t..        show 
+0000e2c0: 3a20 626f 6f6c 0a20 2020 2020 2020 2020  : bool.         
+0000e2d0: 2020 2057 6865 7468 6572 2074 6f20 6163     Whether to ac
+0000e2e0: 7475 616c 6c79 2073 686f 7720 7468 6520  tually show the 
+0000e2f0: 696d 6167 6573 2e0a 2020 2020 2020 2020  images..        
+0000e300: 6178 203a 204e 6f6e 652c 206d 6174 706c  ax : None, matpl
+0000e310: 6f74 6c69 622e 4178 6573 0a20 2020 2020  otlib.Axes.     
+0000e320: 2020 2020 2020 2054 6865 2061 7869 7320         The axis 
+0000e330: 746f 2070 6c6f 7420 746f 2e20 4966 204e  to plot to. If N
+0000e340: 6f6e 652c 2063 7265 6174 6573 2061 206e  one, creates a n
+0000e350: 6577 2070 6c6f 742e 0a20 2020 2020 2020  ew plot..       
+0000e360: 2022 2222 0a20 2020 2020 2020 2061 7869   """.        axi
+0000e370: 7320 3d20 636f 6e76 6572 745f 746f 5f65  s = convert_to_e
+0000e380: 6e75 6d28 6178 6973 2c20 4178 6973 290a  num(axis, Axis).
+0000e390: 2020 2020 2020 2020 696d 6167 6573 203d          images =
+0000e3a0: 205b 0a20 2020 2020 2020 2020 2020 2069   [.            i
+0000e3b0: 6d61 6765 0a20 2020 2020 2020 2020 2020  mage.           
+0000e3c0: 2066 6f72 2069 6d61 6765 2069 6e20 7365   for image in se
+0000e3d0: 6c66 2e69 6d61 6765 730a 2020 2020 2020  lf.images.      
+0000e3e0: 2020 2020 2020 6966 2069 6d61 6765 2e76        if image.v
+0000e3f0: 6172 6961 626c 655f 6178 6973 2069 6e20  ariable_axis in 
+0000e400: 2861 7869 732c 2041 7869 732e 5245 4645  (axis, Axis.REFE
+0000e410: 5245 4e43 4529 0a20 2020 2020 2020 205d  RENCE).        ]
+0000e420: 0a20 2020 2020 2020 2061 7820 3d20 696d  .        ax = im
+0000e430: 6167 6573 5b30 5d2e 706c 6f74 280a 2020  ages[0].plot(.  
+0000e440: 2020 2020 2020 2020 2020 7368 6f77 3d46            show=F
+0000e450: 616c 7365 2c20 6178 3d61 780a 2020 2020  alse, ax=ax.    
+0000e460: 2020 2020 2920 2023 2070 6c6f 7473 2074      )  # plots t
+0000e470: 6865 2066 6972 7374 206d 6172 6b65 723b  he first marker;
+0000e480: 2070 6c6f 7420 7468 6520 7265 7374 206f   plot the rest o
+0000e490: 6620 7468 6520 6d61 726b 6572 7320 6265  f the markers be
+0000e4a0: 6c6f 770a 2020 2020 2020 2020 6966 2061  low.        if a
+0000e4b0: 7869 7320 213d 2041 7869 732e 434f 5543  xis != Axis.COUC
+0000e4c0: 483a 0a20 2020 2020 2020 2020 2020 2023  H:.            #
+0000e4d0: 2070 6c6f 7420 4550 4944 0a20 2020 2020   plot EPID.     
+0000e4e0: 2020 2020 2020 2065 7069 645f 7873 203d         epid_xs =
+0000e4f0: 205b 696d 672e 6570 6964 2e78 2066 6f72   [img.epid.x for
+0000e500: 2069 6d67 2069 6e20 696d 6167 6573 5b31   img in images[1
+0000e510: 3a5d 5d0a 2020 2020 2020 2020 2020 2020  :]].            
+0000e520: 6570 6964 5f79 7320 3d20 5b69 6d67 2e65  epid_ys = [img.e
+0000e530: 7069 642e 7920 666f 7220 696d 6720 696e  pid.y for img in
+0000e540: 2069 6d61 6765 735b 313a 5d5d 0a20 2020   images[1:]].   
+0000e550: 2020 2020 2020 2020 2061 782e 706c 6f74           ax.plot
+0000e560: 2865 7069 645f 7873 2c20 6570 6964 5f79  (epid_xs, epid_y
+0000e570: 732c 2022 622b 222c 206d 733d 3829 0a20  s, "b+", ms=8). 
+0000e580: 2020 2020 2020 2020 2020 2023 2067 6574             # get
+0000e590: 2043 4158 2070 6f73 6974 696f 6e73 0a20   CAX positions. 
+0000e5a0: 2020 2020 2020 2020 2020 2078 7320 3d20             xs = 
+0000e5b0: 5b69 6d67 2e66 6965 6c64 5f63 6178 2e78  [img.field_cax.x
+0000e5c0: 2066 6f72 2069 6d67 2069 6e20 696d 6167   for img in imag
+0000e5d0: 6573 5b31 3a5d 5d0a 2020 2020 2020 2020  es[1:]].        
+0000e5e0: 2020 2020 7973 203d 205b 696d 672e 6669      ys = [img.fi
+0000e5f0: 656c 645f 6361 782e 7920 666f 7220 696d  eld_cax.y for im
+0000e600: 6720 696e 2069 6d61 6765 735b 313a 5d5d  g in images[1:]]
+0000e610: 0a20 2020 2020 2020 2020 2020 206d 6172  .            mar
+0000e620: 6b65 7220 3d20 2267 7322 0a20 2020 2020  ker = "gs".     
+0000e630: 2020 2065 6c73 653a 0a20 2020 2020 2020     else:.       
+0000e640: 2020 2020 2023 2067 6574 2042 4220 706f       # get BB po
+0000e650: 7369 7469 6f6e 730a 2020 2020 2020 2020  sitions.        
+0000e660: 2020 2020 7873 203d 205b 696d 672e 6262      xs = [img.bb
+0000e670: 2e78 2066 6f72 2069 6d67 2069 6e20 696d  .x for img in im
+0000e680: 6167 6573 5b31 3a5d 5d0a 2020 2020 2020  ages[1:]].      
+0000e690: 2020 2020 2020 7973 203d 205b 696d 672e        ys = [img.
+0000e6a0: 6262 2e79 2066 6f72 2069 6d67 2069 6e20  bb.y for img in 
+0000e6b0: 696d 6167 6573 5b31 3a5d 5d0a 2020 2020  images[1:]].    
+0000e6c0: 2020 2020 2020 2020 6d61 726b 6572 203d          marker =
+0000e6d0: 2022 726f 220a 2020 2020 2020 2020 6178   "ro".        ax
+0000e6e0: 2e70 6c6f 7428 7873 2c20 7973 2c20 6d61  .plot(xs, ys, ma
+0000e6f0: 726b 6572 2c20 6d73 3d38 290a 2020 2020  rker, ms=8).    
+0000e700: 2020 2020 2320 7365 7420 6c61 6265 6c73      # set labels
+0000e710: 0a20 2020 2020 2020 2061 782e 7365 745f  .        ax.set_
+0000e720: 7469 746c 6528 6178 6973 2e76 616c 7565  title(axis.value
+0000e730: 202b 2022 2077 6f62 626c 6522 290a 2020   + " wobble").  
+0000e740: 2020 2020 2020 6178 2e73 6574 5f78 6c61        ax.set_xla
+0000e750: 6265 6c28 6178 6973 2e76 616c 7565 202b  bel(axis.value +
+0000e760: 2022 2070 6f73 6974 696f 6e73 2073 7570   " positions sup
+0000e770: 6572 696d 706f 7365 6422 290a 2020 2020  erimposed").    
+0000e780: 2020 2020 6178 2e73 6574 5f79 6c61 6265      ax.set_ylabe
+0000e790: 6c28 0a20 2020 2020 2020 2020 2020 2061  l(.            a
+0000e7a0: 7869 732e 7661 6c75 650a 2020 2020 2020  xis.value.      
+0000e7b0: 2020 2020 2020 2b20 6622 2069 736f 2073        + f" iso s
+0000e7c0: 697a 653a 207b 6765 7461 7474 7228 7365  ize: {getattr(se
+0000e7d0: 6c66 2c20 6178 6973 2e76 616c 7565 2e6c  lf, axis.value.l
+0000e7e0: 6f77 6572 2829 202b 2027 5f69 736f 5f73  ower() + '_iso_s
+0000e7f0: 697a 6527 293a 332e 3266 7d6d 6d22 0a20  ize'):3.2f}mm". 
+0000e800: 2020 2020 2020 2029 0a20 2020 2020 2020         ).       
+0000e810: 2069 6620 7368 6f77 3a0a 2020 2020 2020   if show:.      
+0000e820: 2020 2020 2020 706c 742e 7368 6f77 2829        plt.show()
+0000e830: 0a0a 2020 2020 6465 6620 706c 6f74 5f6c  ..    def plot_l
+0000e840: 6f63 6174 696f 6e28 0a20 2020 2020 2020  ocation(.       
+0000e850: 2073 656c 662c 0a20 2020 2020 2020 2073   self,.        s
+0000e860: 686f 773a 2062 6f6f 6c20 3d20 5472 7565  how: bool = True
+0000e870: 2c0a 2020 2020 2020 2020 7669 6577 626f  ,.        viewbo
+0000e880: 785f 6d6d 3a20 666c 6f61 7420 7c20 4e6f  x_mm: float | No
+0000e890: 6e65 203d 204e 6f6e 652c 0a20 2020 2020  ne = None,.     
+0000e8a0: 2020 2070 6c6f 745f 6262 3a20 626f 6f6c     plot_bb: bool
+0000e8b0: 203d 2054 7275 652c 0a20 2020 2020 2020   = True,.       
+0000e8c0: 2070 6c6f 745f 6973 6f63 656e 7465 725f   plot_isocenter_
+0000e8d0: 7370 6865 7265 3a20 626f 6f6c 203d 2054  sphere: bool = T
+0000e8e0: 7275 652c 0a20 2020 2020 2020 2070 6c6f  rue,.        plo
+0000e8f0: 745f 636f 7563 685f 6973 6f3a 2062 6f6f  t_couch_iso: boo
+0000e900: 6c20 3d20 5472 7565 2c0a 2020 2020 2020  l = True,.      
+0000e910: 2020 706c 6f74 5f63 6f6c 6c5f 6973 6f3a    plot_coll_iso:
+0000e920: 2062 6f6f 6c20 3d20 5472 7565 2c0a 2020   bool = True,.  
+0000e930: 2020 2020 2020 7368 6f77 5f6c 6567 656e        show_legen
+0000e940: 643a 2062 6f6f 6c20 3d20 5472 7565 2c0a  d: bool = True,.
+0000e950: 2020 2020 293a 0a20 2020 2020 2020 2022      ):.        "
+0000e960: 2222 506c 6f74 2074 6865 2069 736f 6365  ""Plot the isoce
+0000e970: 6e74 6572 2061 6e64 2073 697a 6520 6173  nter and size as
+0000e980: 2061 2073 7068 6572 6520 696e 2033 4420   a sphere in 3D 
+0000e990: 7370 6163 6520 7265 6c61 7469 7665 2074  space relative t
+0000e9a0: 6f20 7468 6520 4242 2e20 5468 650a 2020  o the BB. The.  
+0000e9b0: 2020 2020 2020 6973 6f20 6973 2061 7420        iso is at 
+0000e9c0: 7468 6520 6f72 6967 696e 2e0a 0a20 2020  the origin...   
+0000e9d0: 2020 2020 204f 6e6c 7920 696d 6167 6573       Only images
+0000e9e0: 2077 6865 7265 2074 6865 2063 6f75 6368   where the couch
+0000e9f0: 2077 6173 2061 7420 7a65 726f 2061 7265   was at zero are
+0000ea00: 2063 6f6e 7369 6465 7265 642e 0a0a 2020   considered...  
 0000ea10: 2020 2020 2020 5061 7261 6d65 7465 7273        Parameters
-0000ea20: 0d0a 2020 2020 2020 2020 2d2d 2d2d 2d2d  ..        ------
-0000ea30: 2d2d 2d2d 0d0a 2020 2020 2020 2020 6173  ----..        as
-0000ea40: 5f6c 6973 7420 3a20 626f 6f6c 0d0a 2020  _list : bool..  
-0000ea50: 2020 2020 2020 2020 2020 5768 6574 6865            Whethe
-0000ea60: 7220 746f 2072 6574 7572 6e20 6173 2061  r to return as a
-0000ea70: 206c 6973 7420 6f66 2073 7472 696e 6773   list of strings
-0000ea80: 2076 7320 7369 6e67 6c65 2073 7472 696e   vs single strin
-0000ea90: 672e 2050 7265 7474 7920 6d75 6368 2066  g. Pretty much f
-0000eaa0: 6f72 2069 6e74 6572 6e61 6c20 7573 6167  or internal usag
-0000eab0: 652e 0d0a 2020 2020 2020 2020 2222 220d  e...        """.
-0000eac0: 0a20 2020 2020 2020 2069 6620 6e6f 7420  .        if not 
-0000ead0: 7365 6c66 2e5f 6973 5f61 6e61 6c79 7a65  self._is_analyze
-0000eae0: 643a 0d0a 2020 2020 2020 2020 2020 2020  d:..            
-0000eaf0: 7261 6973 6520 5661 6c75 6545 7272 6f72  raise ValueError
-0000eb00: 2822 5468 6520 7365 7420 6973 206e 6f74  ("The set is not
-0000eb10: 2061 6e61 6c79 7a65 642e 2055 7365 202e   analyzed. Use .
-0000eb20: 616e 616c 797a 6528 2920 6669 7273 742e  analyze() first.
-0000eb30: 2229 0d0a 2020 2020 2020 2020 6e75 6d5f  ")..        num_
-0000eb40: 6761 6e74 7279 5f69 6d67 7320 3d20 7365  gantry_imgs = se
-0000eb50: 6c66 2e5f 6765 745f 696d 6167 6573 2861  lf._get_images(a
-0000eb60: 7869 733d 2841 7869 732e 4741 4e54 5259  xis=(Axis.GANTRY
-0000eb70: 2c20 4178 6973 2e52 4546 4552 454e 4345  , Axis.REFERENCE
-0000eb80: 2929 5b30 5d0d 0a20 2020 2020 2020 206e  ))[0]..        n
-0000eb90: 756d 5f67 616e 7472 795f 636f 6c6c 5f69  um_gantry_coll_i
-0000eba0: 6d67 7320 3d20 7365 6c66 2e5f 6765 745f  mgs = self._get_
-0000ebb0: 696d 6167 6573 280d 0a20 2020 2020 2020  images(..       
-0000ebc0: 2020 2020 2061 7869 733d 2841 7869 732e       axis=(Axis.
-0000ebd0: 4741 4e54 5259 2c20 4178 6973 2e43 4f4c  GANTRY, Axis.COL
-0000ebe0: 4c49 4d41 544f 522c 2041 7869 732e 4742  LIMATOR, Axis.GB
-0000ebf0: 5f43 4f4d 424f 2c20 4178 6973 2e52 4546  _COMBO, Axis.REF
-0000ec00: 4552 454e 4345 290d 0a20 2020 2020 2020  ERENCE)..       
-0000ec10: 2029 5b30 5d0d 0a20 2020 2020 2020 206e   )[0]..        n
-0000ec20: 756d 5f63 6f6c 6c5f 696d 6773 203d 2073  um_coll_imgs = s
-0000ec30: 656c 662e 5f67 6574 5f69 6d61 6765 7328  elf._get_images(
-0000ec40: 6178 6973 3d28 4178 6973 2e43 4f4c 4c49  axis=(Axis.COLLI
-0000ec50: 4d41 544f 522c 2041 7869 732e 5245 4645  MATOR, Axis.REFE
-0000ec60: 5245 4e43 4529 295b 305d 0d0a 2020 2020  RENCE))[0]..    
-0000ec70: 2020 2020 6e75 6d5f 636f 7563 685f 696d      num_couch_im
-0000ec80: 6773 203d 2073 656c 662e 5f67 6574 5f69  gs = self._get_i
-0000ec90: 6d61 6765 7328 6178 6973 3d28 4178 6973  mages(axis=(Axis
-0000eca0: 2e43 4f55 4348 2c20 4178 6973 2e52 4546  .COUCH, Axis.REF
-0000ecb0: 4552 454e 4345 2929 5b30 5d0d 0a20 2020  ERENCE))[0]..   
-0000ecc0: 2020 2020 206e 756d 5f69 6d67 7320 3d20       num_imgs = 
-0000ecd0: 6c65 6e28 7365 6c66 2e69 6d61 6765 7329  len(self.images)
-0000ece0: 0d0a 2020 2020 2020 2020 7265 7375 6c74  ..        result
-0000ecf0: 203d 205b 0d0a 2020 2020 2020 2020 2020   = [..          
-0000ed00: 2020 2257 696e 7374 6f6e 2d4c 7574 7a20    "Winston-Lutz 
-0000ed10: 416e 616c 7973 6973 222c 0d0a 2020 2020  Analysis",..    
-0000ed20: 2020 2020 2020 2020 223d 3d3d 3d3d 3d3d          "=======
-0000ed30: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-0000ed40: 3d3d 3d3d 3d3d 3d3d 3d3d 222c 0d0a 2020  ==========",..  
-0000ed50: 2020 2020 2020 2020 2020 6622 4e75 6d62            f"Numb
-0000ed60: 6572 206f 6620 696d 6167 6573 3a20 7b6e  er of images: {n
-0000ed70: 756d 5f69 6d67 737d 222c 0d0a 2020 2020  um_imgs}",..    
-0000ed80: 2020 2020 2020 2020 6622 4d61 7869 6d75          f"Maximu
-0000ed90: 6d20 3244 2043 4158 2d3e 4242 2064 6973  m 2D CAX->BB dis
-0000eda0: 7461 6e63 653a 207b 7365 6c66 2e63 6178  tance: {self.cax
-0000edb0: 3262 625f 6469 7374 616e 6365 2827 6d61  2bb_distance('ma
-0000edc0: 7827 293a 2e32 667d 6d6d 222c 0d0a 2020  x'):.2f}mm",..  
-0000edd0: 2020 2020 2020 2020 2020 6622 4d65 6469            f"Medi
-0000ede0: 616e 2032 4420 4341 582d 3e42 4220 6469  an 2D CAX->BB di
-0000edf0: 7374 616e 6365 3a20 7b73 656c 662e 6361  stance: {self.ca
-0000ee00: 7832 6262 5f64 6973 7461 6e63 6528 276d  x2bb_distance('m
-0000ee10: 6564 6961 6e27 293a 2e32 667d 6d6d 222c  edian'):.2f}mm",
-0000ee20: 0d0a 2020 2020 2020 2020 2020 2020 6622  ..            f"
-0000ee30: 4d65 616e 2032 4420 4341 582d 3e42 4220  Mean 2D CAX->BB 
-0000ee40: 6469 7374 616e 6365 3a20 7b73 656c 662e  distance: {self.
-0000ee50: 6361 7832 6262 5f64 6973 7461 6e63 6528  cax2bb_distance(
-0000ee60: 276d 6561 6e27 293a 2e32 667d 6d6d 222c  'mean'):.2f}mm",
-0000ee70: 0d0a 2020 2020 2020 2020 2020 2020 6622  ..            f"
-0000ee80: 5368 6966 7420 746f 2069 736f 3a20 6661  Shift to iso: fa
-0000ee90: 6369 6e67 2067 616e 7472 792c 206d 6f76  cing gantry, mov
-0000eea0: 6520 4242 3a20 7b73 656c 662e 6262 5f73  e BB: {self.bb_s
-0000eeb0: 6869 6674 5f69 6e73 7472 7563 7469 6f6e  hift_instruction
-0000eec0: 7328 297d 222c 0d0a 2020 2020 2020 2020  s()}",..        
-0000eed0: 2020 2020 6622 4761 6e74 7279 2033 4420      f"Gantry 3D 
-0000eee0: 6973 6f63 656e 7465 7220 6469 616d 6574  isocenter diamet
-0000eef0: 6572 3a20 7b73 656c 662e 6761 6e74 7279  er: {self.gantry
-0000ef00: 5f69 736f 5f73 697a 653a 2e32 667d 6d6d  _iso_size:.2f}mm
-0000ef10: 2028 7b6e 756d 5f67 616e 7472 795f 696d   ({num_gantry_im
-0000ef20: 6773 7d2f 7b6e 756d 5f69 6d67 737d 2069  gs}/{num_imgs} i
-0000ef30: 6d61 6765 7320 636f 6e73 6964 6572 6564  mages considered
-0000ef40: 2922 2c0d 0a20 2020 2020 2020 2020 2020  )",..           
-0000ef50: 2066 224d 6178 696d 756d 2047 616e 7472   f"Maximum Gantr
-0000ef60: 7920 524d 5320 6465 7669 6174 696f 6e20  y RMS deviation 
-0000ef70: 286d 6d29 3a20 7b6d 6178 2873 656c 662e  (mm): {max(self.
-0000ef80: 6178 6973 5f72 6d73 5f64 6576 6961 7469  axis_rms_deviati
-0000ef90: 6f6e 2828 4178 6973 2e47 414e 5452 592c  on((Axis.GANTRY,
-0000efa0: 2041 7869 732e 5245 4645 5245 4e43 4529   Axis.REFERENCE)
-0000efb0: 2929 3a2e 3266 7d6d 6d22 2c0d 0a20 2020  )):.2f}mm",..   
-0000efc0: 2020 2020 2020 2020 2066 224d 6178 696d           f"Maxim
-0000efd0: 756d 2045 5049 4420 524d 5320 6465 7669  um EPID RMS devi
-0000efe0: 6174 696f 6e20 286d 6d29 3a20 7b6d 6178  ation (mm): {max
-0000eff0: 2873 656c 662e 6178 6973 5f72 6d73 5f64  (self.axis_rms_d
-0000f000: 6576 6961 7469 6f6e 2841 7869 732e 4550  eviation(Axis.EP
-0000f010: 4944 2929 3a2e 3266 7d6d 6d22 2c0d 0a20  ID)):.2f}mm",.. 
-0000f020: 2020 2020 2020 2020 2020 2066 2247 616e             f"Gan
-0000f030: 7472 792b 436f 6c6c 696d 6174 6f72 2033  try+Collimator 3
-0000f040: 4420 6973 6f63 656e 7465 7220 6469 616d  D isocenter diam
-0000f050: 6574 6572 3a20 7b73 656c 662e 6761 6e74  eter: {self.gant
-0000f060: 7279 5f63 6f6c 6c5f 6973 6f5f 7369 7a65  ry_coll_iso_size
-0000f070: 3a2e 3266 7d6d 6d20 287b 6e75 6d5f 6761  :.2f}mm ({num_ga
-0000f080: 6e74 7279 5f63 6f6c 6c5f 696d 6773 7d2f  ntry_coll_imgs}/
-0000f090: 7b6e 756d 5f69 6d67 737d 2069 6d61 6765  {num_imgs} image
-0000f0a0: 7320 636f 6e73 6964 6572 6564 2922 2c0d  s considered)",.
-0000f0b0: 0a20 2020 2020 2020 2020 2020 2066 2243  .            f"C
-0000f0c0: 6f6c 6c69 6d61 746f 7220 3244 2069 736f  ollimator 2D iso
-0000f0d0: 6365 6e74 6572 2064 6961 6d65 7465 723a  center diameter:
-0000f0e0: 207b 7365 6c66 2e63 6f6c 6c69 6d61 746f   {self.collimato
-0000f0f0: 725f 6973 6f5f 7369 7a65 3a2e 3266 7d6d  r_iso_size:.2f}m
-0000f100: 6d20 287b 6e75 6d5f 636f 6c6c 5f69 6d67  m ({num_coll_img
-0000f110: 737d 2f7b 6e75 6d5f 696d 6773 7d20 696d  s}/{num_imgs} im
-0000f120: 6167 6573 2063 6f6e 7369 6465 7265 6429  ages considered)
-0000f130: 222c 0d0a 2020 2020 2020 2020 2020 2020  ",..            
-0000f140: 6622 4d61 7869 6d75 6d20 436f 6c6c 696d  f"Maximum Collim
-0000f150: 6174 6f72 2052 4d53 2064 6576 6961 7469  ator RMS deviati
-0000f160: 6f6e 2028 6d6d 293a 207b 6d61 7828 7365  on (mm): {max(se
-0000f170: 6c66 2e61 7869 735f 726d 735f 6465 7669  lf.axis_rms_devi
-0000f180: 6174 696f 6e28 2841 7869 732e 434f 4c4c  ation((Axis.COLL
-0000f190: 494d 4154 4f52 2c20 4178 6973 2e52 4546  IMATOR, Axis.REF
-0000f1a0: 4552 454e 4345 2929 293a 2e32 667d 222c  ERENCE))):.2f}",
-0000f1b0: 0d0a 2020 2020 2020 2020 2020 2020 6622  ..            f"
-0000f1c0: 436f 7563 6820 3244 2069 736f 6365 6e74  Couch 2D isocent
-0000f1d0: 6572 2064 6961 6d65 7465 723a 207b 7365  er diameter: {se
-0000f1e0: 6c66 2e63 6f75 6368 5f69 736f 5f73 697a  lf.couch_iso_siz
-0000f1f0: 653a 2e32 667d 6d6d 2028 7b6e 756d 5f63  e:.2f}mm ({num_c
-0000f200: 6f75 6368 5f69 6d67 737d 2f7b 6e75 6d5f  ouch_imgs}/{num_
-0000f210: 696d 6773 7d20 696d 6167 6573 2063 6f6e  imgs} images con
-0000f220: 7369 6465 7265 6429 222c 0d0a 2020 2020  sidered)",..    
-0000f230: 2020 2020 2020 2020 6622 4d61 7869 6d75          f"Maximu
-0000f240: 6d20 436f 7563 6820 524d 5320 6465 7669  m Couch RMS devi
-0000f250: 6174 696f 6e20 286d 6d29 3a20 7b6d 6178  ation (mm): {max
-0000f260: 2873 656c 662e 6178 6973 5f72 6d73 5f64  (self.axis_rms_d
-0000f270: 6576 6961 7469 6f6e 2828 4178 6973 2e43  eviation((Axis.C
-0000f280: 4f55 4348 2c20 4178 6973 2e52 4546 4552  OUCH, Axis.REFER
-0000f290: 454e 4345 2929 293a 2e32 667d 222c 0d0a  ENCE))):.2f}",..
-0000f2a0: 2020 2020 2020 2020 5d0d 0a20 2020 2020          ]..     
-0000f2b0: 2020 2069 6620 6e6f 7420 6173 5f6c 6973     if not as_lis
-0000f2c0: 743a 0d0a 2020 2020 2020 2020 2020 2020  t:..            
-0000f2d0: 7265 7375 6c74 203d 2022 5c6e 222e 6a6f  result = "\n".jo
-0000f2e0: 696e 2872 6573 756c 7429 0d0a 2020 2020  in(result)..    
-0000f2f0: 2020 2020 7265 7475 726e 2072 6573 756c      return resul
-0000f300: 740d 0a0d 0a20 2020 2064 6566 2072 6573  t....    def res
-0000f310: 756c 7473 5f64 6174 6128 7365 6c66 2c20  ults_data(self, 
-0000f320: 6173 5f64 6963 743a 2062 6f6f 6c20 3d20  as_dict: bool = 
-0000f330: 4661 6c73 6529 202d 3e20 5769 6e73 746f  False) -> Winsto
-0000f340: 6e4c 7574 7a52 6573 756c 7420 7c20 6469  nLutzResult | di
-0000f350: 6374 3a0d 0a20 2020 2020 2020 2022 2222  ct:..        """
-0000f360: 5072 6573 656e 7420 7468 6520 7265 7375  Present the resu
-0000f370: 6c74 7320 6461 7461 2061 6e64 206d 6574  lts data and met
-0000f380: 6164 6174 6120 6173 2061 2064 6174 6163  adata as a datac
-0000f390: 6c61 7373 206f 7220 6469 6374 2e0d 0a20  lass or dict... 
-0000f3a0: 2020 2020 2020 2054 6865 2064 6566 6175         The defau
-0000f3b0: 6c74 2072 6574 7572 6e20 7479 7065 2069  lt return type i
-0000f3c0: 7320 6120 6461 7461 636c 6173 732e 2222  s a dataclass.""
-0000f3d0: 220d 0a20 2020 2020 2020 2069 6620 6e6f  "..        if no
-0000f3e0: 7420 7365 6c66 2e5f 6973 5f61 6e61 6c79  t self._is_analy
-0000f3f0: 7a65 643a 0d0a 2020 2020 2020 2020 2020  zed:..          
-0000f400: 2020 7261 6973 6520 5661 6c75 6545 7272    raise ValueErr
-0000f410: 6f72 2822 5468 6520 7365 7420 6973 206e  or("The set is n
-0000f420: 6f74 2061 6e61 6c79 7a65 642e 2055 7365  ot analyzed. Use
-0000f430: 202e 616e 616c 797a 6528 2920 6669 7273   .analyze() firs
-0000f440: 742e 2229 0d0a 2020 2020 2020 2020 6e75  t.")..        nu
-0000f450: 6d5f 6761 6e74 7279 5f69 6d67 7320 3d20  m_gantry_imgs = 
-0000f460: 7365 6c66 2e5f 6765 745f 696d 6167 6573  self._get_images
-0000f470: 2861 7869 733d 2841 7869 732e 4741 4e54  (axis=(Axis.GANT
-0000f480: 5259 2c20 4178 6973 2e52 4546 4552 454e  RY, Axis.REFEREN
-0000f490: 4345 2929 5b30 5d0d 0a20 2020 2020 2020  CE))[0]..       
-0000f4a0: 206e 756d 5f67 616e 7472 795f 636f 6c6c   num_gantry_coll
-0000f4b0: 5f69 6d67 7320 3d20 7365 6c66 2e5f 6765  _imgs = self._ge
-0000f4c0: 745f 696d 6167 6573 280d 0a20 2020 2020  t_images(..     
-0000f4d0: 2020 2020 2020 2061 7869 733d 2841 7869         axis=(Axi
-0000f4e0: 732e 4741 4e54 5259 2c20 4178 6973 2e43  s.GANTRY, Axis.C
-0000f4f0: 4f4c 4c49 4d41 544f 522c 2041 7869 732e  OLLIMATOR, Axis.
-0000f500: 4742 5f43 4f4d 424f 2c20 4178 6973 2e52  GB_COMBO, Axis.R
-0000f510: 4546 4552 454e 4345 290d 0a20 2020 2020  EFERENCE)..     
-0000f520: 2020 2029 5b30 5d0d 0a20 2020 2020 2020     )[0]..       
-0000f530: 206e 756d 5f63 6f6c 6c5f 696d 6773 203d   num_coll_imgs =
-0000f540: 2073 656c 662e 5f67 6574 5f69 6d61 6765   self._get_image
-0000f550: 7328 6178 6973 3d28 4178 6973 2e43 4f4c  s(axis=(Axis.COL
-0000f560: 4c49 4d41 544f 522c 2041 7869 732e 5245  LIMATOR, Axis.RE
-0000f570: 4645 5245 4e43 4529 295b 305d 0d0a 2020  FERENCE))[0]..  
-0000f580: 2020 2020 2020 6e75 6d5f 636f 7563 685f        num_couch_
-0000f590: 696d 6773 203d 2073 656c 662e 5f67 6574  imgs = self._get
-0000f5a0: 5f69 6d61 6765 7328 6178 6973 3d28 4178  _images(axis=(Ax
-0000f5b0: 6973 2e43 4f55 4348 2c20 4178 6973 2e52  is.COUCH, Axis.R
-0000f5c0: 4546 4552 454e 4345 2929 5b30 5d0d 0a0d  EFERENCE))[0]...
-0000f5d0: 0a20 2020 2020 2020 2069 6e64 6976 6964  .        individ
-0000f5e0: 7561 6c5f 696d 6167 655f 6461 7461 203d  ual_image_data =
-0000f5f0: 205b 692e 7265 7375 6c74 735f 6461 7461   [i.results_data
-0000f600: 2861 735f 6469 6374 3d61 735f 6469 6374  (as_dict=as_dict
-0000f610: 2920 666f 7220 6920 696e 2073 656c 662e  ) for i in self.
-0000f620: 696d 6167 6573 5d0d 0a20 2020 2020 2020  images]..       
-0000f630: 2069 6620 6173 5f64 6963 743a 0d0a 2020   if as_dict:..  
-0000f640: 2020 2020 2020 2020 2020 2320 636f 6e76            # conv
-0000f650: 6572 7420 636c 6173 7365 7320 746f 2064  ert classes to d
-0000f660: 6963 7473 3b20 6c69 7474 6c65 2077 6f6e  icts; little won
-0000f670: 6b79 2062 7574 2077 6520 6861 7665 2074  ky but we have t
-0000f680: 6f20 6765 7420 6974 2074 6872 6f75 6768  o get it through
-0000f690: 0d0a 2020 2020 2020 2020 2020 2020 2320  ..            # 
-0000f6a0: 746f 2072 6164 6d61 6368 696e 6520 616e  to radmachine an
-0000f6b0: 6420 7765 2077 616e 7420 746f 2064 796e  d we want to dyn
-0000f6c0: 616d 6963 616c 6c79 2063 6f6e 7665 7274  amically convert
-0000f6d0: 2063 6c61 7373 6573 2074 6f20 6469 6374   classes to dict
-0000f6e0: 730d 0a20 2020 2020 2020 2020 2020 2066  s..            f
-0000f6f0: 6f72 2069 6d67 2069 6e20 696e 6469 7669  or img in indivi
-0000f700: 6475 616c 5f69 6d61 6765 5f64 6174 613a  dual_image_data:
-0000f710: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-0000f720: 2020 666f 7220 6b65 792c 2076 616c 7565    for key, value
-0000f730: 2069 6e20 696d 672e 6974 656d 7328 293a   in img.items():
-0000f740: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-0000f750: 2020 2020 2020 7472 793a 0d0a 2020 2020        try:..    
-0000f760: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000f770: 2020 2020 696d 675b 6b65 795d 203d 2076      img[key] = v
-0000f780: 616c 7565 2e5f 5f64 6963 745f 5f0d 0a20  alue.__dict__.. 
-0000f790: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000f7a0: 2020 2065 7863 6570 7420 4174 7472 6962     except Attrib
-0000f7b0: 7574 6545 7272 6f72 3a0d 0a20 2020 2020  uteError:..     
-0000f7c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000f7d0: 2020 2070 6173 730d 0a0d 0a20 2020 2020     pass....     
-0000f7e0: 2020 2064 6174 6120 3d20 5769 6e73 746f     data = Winsto
-0000f7f0: 6e4c 7574 7a52 6573 756c 7428 0d0a 2020  nLutzResult(..  
-0000f800: 2020 2020 2020 2020 2020 6e75 6d5f 746f            num_to
-0000f810: 7461 6c5f 696d 6167 6573 3d6c 656e 2873  tal_images=len(s
-0000f820: 656c 662e 696d 6167 6573 292c 0d0a 2020  elf.images),..  
-0000f830: 2020 2020 2020 2020 2020 6e75 6d5f 6761            num_ga
-0000f840: 6e74 7279 5f69 6d61 6765 733d 6e75 6d5f  ntry_images=num_
-0000f850: 6761 6e74 7279 5f69 6d67 732c 0d0a 2020  gantry_imgs,..  
-0000f860: 2020 2020 2020 2020 2020 6e75 6d5f 636f            num_co
-0000f870: 6c6c 5f69 6d61 6765 733d 6e75 6d5f 636f  ll_images=num_co
-0000f880: 6c6c 5f69 6d67 732c 0d0a 2020 2020 2020  ll_imgs,..      
-0000f890: 2020 2020 2020 6e75 6d5f 6761 6e74 7279        num_gantry
-0000f8a0: 5f63 6f6c 6c5f 696d 6167 6573 3d6e 756d  _coll_images=num
-0000f8b0: 5f67 616e 7472 795f 636f 6c6c 5f69 6d67  _gantry_coll_img
-0000f8c0: 732c 0d0a 2020 2020 2020 2020 2020 2020  s,..            
-0000f8d0: 6e75 6d5f 636f 7563 685f 696d 6167 6573  num_couch_images
-0000f8e0: 3d6e 756d 5f63 6f75 6368 5f69 6d67 732c  =num_couch_imgs,
-0000f8f0: 0d0a 2020 2020 2020 2020 2020 2020 6d61  ..            ma
-0000f900: 785f 3264 5f63 6178 5f74 6f5f 6262 5f6d  x_2d_cax_to_bb_m
-0000f910: 6d3d 7365 6c66 2e63 6178 3262 625f 6469  m=self.cax2bb_di
-0000f920: 7374 616e 6365 2822 6d61 7822 292c 0d0a  stance("max"),..
-0000f930: 2020 2020 2020 2020 2020 2020 6d65 6469              medi
-0000f940: 616e 5f32 645f 6361 785f 746f 5f62 625f  an_2d_cax_to_bb_
-0000f950: 6d6d 3d73 656c 662e 6361 7832 6262 5f64  mm=self.cax2bb_d
-0000f960: 6973 7461 6e63 6528 226d 6564 6961 6e22  istance("median"
-0000f970: 292c 0d0a 2020 2020 2020 2020 2020 2020  ),..            
-0000f980: 6d65 616e 5f32 645f 6361 785f 746f 5f62  mean_2d_cax_to_b
-0000f990: 625f 6d6d 3d73 656c 662e 6361 7832 6262  b_mm=self.cax2bb
-0000f9a0: 5f64 6973 7461 6e63 6528 226d 6561 6e22  _distance("mean"
-0000f9b0: 292c 0d0a 2020 2020 2020 2020 2020 2020  ),..            
-0000f9c0: 6d61 785f 3264 5f63 6178 5f74 6f5f 6570  max_2d_cax_to_ep
-0000f9d0: 6964 5f6d 6d3d 7365 6c66 2e63 6178 3265  id_mm=self.cax2e
-0000f9e0: 7069 645f 6469 7374 616e 6365 2822 6d61  pid_distance("ma
-0000f9f0: 7822 292c 0d0a 2020 2020 2020 2020 2020  x"),..          
-0000fa00: 2020 6d65 6469 616e 5f32 645f 6361 785f    median_2d_cax_
-0000fa10: 746f 5f65 7069 645f 6d6d 3d73 656c 662e  to_epid_mm=self.
-0000fa20: 6361 7832 6570 6964 5f64 6973 7461 6e63  cax2epid_distanc
-0000fa30: 6528 226d 6564 6961 6e22 292c 0d0a 2020  e("median"),..  
-0000fa40: 2020 2020 2020 2020 2020 6d65 616e 5f32            mean_2
-0000fa50: 645f 6361 785f 746f 5f65 7069 645f 6d6d  d_cax_to_epid_mm
-0000fa60: 3d73 656c 662e 6361 7832 6570 6964 5f64  =self.cax2epid_d
-0000fa70: 6973 7461 6e63 6528 226d 6561 6e22 292c  istance("mean"),
-0000fa80: 0d0a 2020 2020 2020 2020 2020 2020 636f  ..            co
-0000fa90: 6c6c 5f32 645f 6973 6f5f 6469 616d 6574  ll_2d_iso_diamet
-0000faa0: 6572 5f6d 6d3d 7365 6c66 2e63 6f6c 6c69  er_mm=self.colli
-0000fab0: 6d61 746f 725f 6973 6f5f 7369 7a65 2c0d  mator_iso_size,.
-0000fac0: 0a20 2020 2020 2020 2020 2020 2063 6f75  .            cou
-0000fad0: 6368 5f32 645f 6973 6f5f 6469 616d 6574  ch_2d_iso_diamet
-0000fae0: 6572 5f6d 6d3d 7365 6c66 2e63 6f75 6368  er_mm=self.couch
-0000faf0: 5f69 736f 5f73 697a 652c 0d0a 2020 2020  _iso_size,..    
-0000fb00: 2020 2020 2020 2020 6761 6e74 7279 5f33          gantry_3
-0000fb10: 645f 6973 6f5f 6469 616d 6574 6572 5f6d  d_iso_diameter_m
-0000fb20: 6d3d 7365 6c66 2e67 616e 7472 795f 6973  m=self.gantry_is
-0000fb30: 6f5f 7369 7a65 2c0d 0a20 2020 2020 2020  o_size,..       
-0000fb40: 2020 2020 2067 616e 7472 795f 636f 6c6c       gantry_coll
-0000fb50: 5f33 645f 6973 6f5f 6469 616d 6574 6572  _3d_iso_diameter
-0000fb60: 5f6d 6d3d 7365 6c66 2e67 616e 7472 795f  _mm=self.gantry_
-0000fb70: 636f 6c6c 5f69 736f 5f73 697a 652c 0d0a  coll_iso_size,..
-0000fb80: 2020 2020 2020 2020 2020 2020 6d61 785f              max_
-0000fb90: 6761 6e74 7279 5f72 6d73 5f64 6576 6961  gantry_rms_devia
-0000fba0: 7469 6f6e 5f6d 6d3d 6d61 7828 0d0a 2020  tion_mm=max(..  
-0000fbb0: 2020 2020 2020 2020 2020 2020 2020 7365                se
-0000fbc0: 6c66 2e61 7869 735f 726d 735f 6465 7669  lf.axis_rms_devi
-0000fbd0: 6174 696f 6e28 6178 6973 3d28 4178 6973  ation(axis=(Axis
-0000fbe0: 2e47 414e 5452 592c 2041 7869 732e 5245  .GANTRY, Axis.RE
-0000fbf0: 4645 5245 4e43 4529 290d 0a20 2020 2020  FERENCE))..     
-0000fc00: 2020 2020 2020 2029 2c0d 0a20 2020 2020         ),..     
-0000fc10: 2020 2020 2020 206d 6178 5f63 6f6c 6c5f         max_coll_
-0000fc20: 726d 735f 6465 7669 6174 696f 6e5f 6d6d  rms_deviation_mm
-0000fc30: 3d6d 6178 280d 0a20 2020 2020 2020 2020  =max(..         
-0000fc40: 2020 2020 2020 2073 656c 662e 6178 6973         self.axis
-0000fc50: 5f72 6d73 5f64 6576 6961 7469 6f6e 2861  _rms_deviation(a
-0000fc60: 7869 733d 2841 7869 732e 434f 4c4c 494d  xis=(Axis.COLLIM
-0000fc70: 4154 4f52 2c20 4178 6973 2e52 4546 4552  ATOR, Axis.REFER
-0000fc80: 454e 4345 2929 0d0a 2020 2020 2020 2020  ENCE))..        
-0000fc90: 2020 2020 292c 0d0a 2020 2020 2020 2020      ),..        
-0000fca0: 2020 2020 6d61 785f 636f 7563 685f 726d      max_couch_rm
-0000fcb0: 735f 6465 7669 6174 696f 6e5f 6d6d 3d6d  s_deviation_mm=m
-0000fcc0: 6178 280d 0a20 2020 2020 2020 2020 2020  ax(..           
-0000fcd0: 2020 2020 2073 656c 662e 6178 6973 5f72       self.axis_r
-0000fce0: 6d73 5f64 6576 6961 7469 6f6e 2861 7869  ms_deviation(axi
-0000fcf0: 733d 2841 7869 732e 434f 5543 482c 2041  s=(Axis.COUCH, A
-0000fd00: 7869 732e 5245 4645 5245 4e43 4529 290d  xis.REFERENCE)).
-0000fd10: 0a20 2020 2020 2020 2020 2020 2029 2c0d  .            ),.
-0000fd20: 0a20 2020 2020 2020 2020 2020 206d 6178  .            max
-0000fd30: 5f65 7069 645f 726d 735f 6465 7669 6174  _epid_rms_deviat
-0000fd40: 696f 6e5f 6d6d 3d6d 6178 2873 656c 662e  ion_mm=max(self.
-0000fd50: 6178 6973 5f72 6d73 5f64 6576 6961 7469  axis_rms_deviati
-0000fd60: 6f6e 2861 7869 733d 4178 6973 2e45 5049  on(axis=Axis.EPI
-0000fd70: 4429 292c 0d0a 2020 2020 2020 2020 2020  D)),..          
-0000fd80: 2020 696d 6167 655f 6465 7461 696c 733d    image_details=
-0000fd90: 696e 6469 7669 6475 616c 5f69 6d61 6765  individual_image
-0000fda0: 5f64 6174 612c 0d0a 2020 2020 2020 2020  _data,..        
-0000fdb0: 2020 2020 6b65 7965 645f 696d 6167 655f      keyed_image_
-0000fdc0: 6465 7461 696c 733d 7365 6c66 2e5f 6765  details=self._ge
-0000fdd0: 6e65 7261 7465 5f6b 6579 6564 5f69 6d61  nerate_keyed_ima
-0000fde0: 6765 7328 696e 6469 7669 6475 616c 5f69  ges(individual_i
-0000fdf0: 6d61 6765 5f64 6174 6129 2c0d 0a20 2020  mage_data),..   
-0000fe00: 2020 2020 2029 0d0a 2020 2020 2020 2020       )..        
-0000fe10: 6966 2061 735f 6469 6374 3a0d 0a20 2020  if as_dict:..   
-0000fe20: 2020 2020 2020 2020 2072 6574 7572 6e20           return 
-0000fe30: 6461 7461 636c 6173 7365 732e 6173 6469  dataclasses.asdi
-0000fe40: 6374 2864 6174 6129 0d0a 2020 2020 2020  ct(data)..      
-0000fe50: 2020 7265 7475 726e 2064 6174 610d 0a0d    return data...
-0000fe60: 0a20 2020 2064 6566 205f 6765 6e65 7261  .    def _genera
-0000fe70: 7465 5f6b 6579 6564 5f69 6d61 6765 7328  te_keyed_images(
-0000fe80: 0d0a 2020 2020 2020 2020 7365 6c66 2c20  ..        self, 
-0000fe90: 696e 6469 7669 6475 616c 5f69 6d61 6765  individual_image
-0000fea0: 5f64 6174 613a 206c 6973 745b 5769 6e73  _data: list[Wins
-0000feb0: 746f 6e4c 7574 7a32 445d 207c 2064 6963  tonLutz2D] | dic
-0000fec0: 740d 0a20 2020 2029 202d 3e20 6469 6374  t..    ) -> dict
-0000fed0: 3a0d 0a20 2020 2020 2020 2022 2222 4765  :..        """Ge
-0000fee0: 6e65 7261 7465 2061 2064 6963 7420 7768  nerate a dict wh
-0000fef0: 6572 6520 6561 6368 206b 6579 2069 7320  ere each key is 
-0000ff00: 6261 7365 6420 6f6e 2074 6865 2061 7865  based on the axe
-0000ff10: 7320 7661 6c75 6573 2061 6e64 2074 6865  s values and the
-0000ff20: 206b 6579 2069 7320 616e 2069 6d61 6765   key is an image
-0000ff30: 2e20 5573 6564 2069 6e20 7468 6520 7265  . Used in the re
-0000ff40: 7375 6c74 735f 6461 7461 206d 6574 686f  sults_data metho
-0000ff50: 642e 0d0a 2020 2020 2020 2020 5765 2063  d...        We c
-0000ff60: 616e 2774 2064 6f20 6120 7369 6d70 6c65  an't do a simple
-0000ff70: 2064 6963 7420 636f 6d70 7265 6865 6e73   dict comprehens
-0000ff80: 696f 6e20 6265 6361 7573 6520 7765 206d  ion because we m
-0000ff90: 6179 2068 6176 6520 6475 706c 6963 6174  ay have duplicat
-0000ffa0: 6520 6178 6573 2073 6574 732e 2057 6520  e axes sets. We 
-0000ffb0: 7061 7373 2069 6e64 6976 6964 7561 6c20  pass individual 
-0000ffc0: 6461 7461 0d0a 2020 2020 2020 2020 6265  data..        be
-0000ffd0: 6361 7573 6520 7765 206d 6179 2068 6176  cause we may hav
-0000ffe0: 6520 616c 7265 6164 7920 636f 6e76 6572  e already conver
-0000fff0: 7465 6420 746f 2061 2064 6963 743b 2077  ted to a dict; w
-00010000: 6520 646f 6e27 7420 7761 6e74 2074 6f20  e don't want to 
-00010010: 646f 2074 6861 7420 6167 6169 6e2e 0d0a  do that again...
-00010020: 2020 2020 2020 2020 2222 220d 0a20 2020          """..   
-00010030: 2020 2020 2064 6174 6120 3d20 7b7d 0d0a       data = {}..
-00010040: 2020 2020 2020 2020 666f 7220 696d 675f          for img_
-00010050: 6964 782c 2069 6d67 2069 6e20 656e 756d  idx, img in enum
-00010060: 6572 6174 6528 7365 6c66 2e69 6d61 6765  erate(self.image
-00010070: 7329 3a0d 0a20 2020 2020 2020 2020 2020  s):..           
-00010080: 206b 6579 203d 2066 2247 7b69 6d67 2e67   key = f"G{img.g
-00010090: 616e 7472 795f 616e 676c 657d 427b 696d  antry_angle}B{im
-000100a0: 672e 636f 6c6c 696d 6174 6f72 5f61 6e67  g.collimator_ang
-000100b0: 6c65 7d50 7b69 6d67 2e63 6f75 6368 5f61  le}P{img.couch_a
-000100c0: 6e67 6c65 7d22 0d0a 2020 2020 2020 2020  ngle}"..        
-000100d0: 2020 2020 7375 6666 6978 203d 2022 220d      suffix = "".
-000100e0: 0a20 2020 2020 2020 2020 2020 2069 6478  .            idx
-000100f0: 203d 2031 0d0a 2020 2020 2020 2020 2020   = 1..          
-00010100: 2020 7768 696c 6520 6b65 7920 2b20 7375    while key + su
-00010110: 6666 6978 2069 6e20 6461 7461 2e6b 6579  ffix in data.key
-00010120: 7328 293a 0d0a 2020 2020 2020 2020 2020  s():..          
-00010130: 2020 2020 2020 7375 6666 6978 203d 2066        suffix = f
-00010140: 225f 7b69 6478 7d22 0d0a 2020 2020 2020  "_{idx}"..      
-00010150: 2020 2020 2020 2020 2020 6964 7820 2b3d            idx +=
-00010160: 2031 0d0a 2020 2020 2020 2020 2020 2020   1..            
-00010170: 6461 7461 5b6b 6579 202b 2073 7566 6669  data[key + suffi
-00010180: 785d 203d 2069 6e64 6976 6964 7561 6c5f  x] = individual_
-00010190: 696d 6167 655f 6461 7461 5b69 6d67 5f69  image_data[img_i
-000101a0: 6478 5d0d 0a20 2020 2020 2020 2072 6574  dx]..        ret
-000101b0: 7572 6e20 6461 7461 0d0a 0d0a 2020 2020  urn data....    
-000101c0: 6465 6620 7075 626c 6973 685f 7064 6628  def publish_pdf(
-000101d0: 0d0a 2020 2020 2020 2020 7365 6c66 2c0d  ..        self,.
-000101e0: 0a20 2020 2020 2020 2066 696c 656e 616d  .        filenam
-000101f0: 653a 2073 7472 2c0d 0a20 2020 2020 2020  e: str,..       
-00010200: 206e 6f74 6573 3a20 7374 7220 7c20 6c69   notes: str | li
-00010210: 7374 5b73 7472 5d20 7c20 4e6f 6e65 203d  st[str] | None =
-00010220: 204e 6f6e 652c 0d0a 2020 2020 2020 2020   None,..        
-00010230: 6f70 656e 5f66 696c 653a 2062 6f6f 6c20  open_file: bool 
-00010240: 3d20 4661 6c73 652c 0d0a 2020 2020 2020  = False,..      
-00010250: 2020 6d65 7461 6461 7461 3a20 6469 6374    metadata: dict
-00010260: 207c 204e 6f6e 6520 3d20 4e6f 6e65 2c0d   | None = None,.
-00010270: 0a20 2020 2020 2020 206c 6f67 6f3a 2050  .        logo: P
-00010280: 6174 6820 7c20 7374 7220 7c20 4e6f 6e65  ath | str | None
-00010290: 203d 204e 6f6e 652c 0d0a 2020 2020 293a   = None,..    ):
-000102a0: 0d0a 2020 2020 2020 2020 2222 2250 7562  ..        """Pub
-000102b0: 6c69 7368 2028 7072 696e 7429 2061 2050  lish (print) a P
-000102c0: 4446 2063 6f6e 7461 696e 696e 6720 7468  DF containing th
-000102d0: 6520 616e 616c 7973 6973 2c20 696d 6167  e analysis, imag
-000102e0: 6573 2c20 616e 6420 7175 616e 7469 7461  es, and quantita
-000102f0: 7469 7665 2072 6573 756c 7473 2e0d 0a0d  tive results....
-00010300: 0a20 2020 2020 2020 2050 6172 616d 6574  .        Paramet
-00010310: 6572 730d 0a20 2020 2020 2020 202d 2d2d  ers..        ---
-00010320: 2d2d 2d2d 2d2d 2d0d 0a20 2020 2020 2020  -------..       
-00010330: 2066 696c 656e 616d 6520 3a20 2873 7472   filename : (str
-00010340: 2c20 6669 6c65 2d6c 696b 6520 6f62 6a65  , file-like obje
-00010350: 6374 7d0d 0a20 2020 2020 2020 2020 2020  ct}..           
-00010360: 2054 6865 2066 696c 6520 746f 2077 7269   The file to wri
-00010370: 7465 2074 6865 2072 6573 756c 7473 2074  te the results t
-00010380: 6f2e 0d0a 2020 2020 2020 2020 6e6f 7465  o...        note
-00010390: 7320 3a20 7374 722c 206c 6973 7420 6f66  s : str, list of
-000103a0: 2073 7472 696e 6773 0d0a 2020 2020 2020   strings..      
-000103b0: 2020 2020 2020 5465 7874 3b20 6966 2073        Text; if s
-000103c0: 7472 2c20 7072 696e 7473 2073 696e 676c  tr, prints singl
-000103d0: 6520 6c69 6e65 2e0d 0a20 2020 2020 2020  e line...       
-000103e0: 2020 2020 2049 6620 6c69 7374 206f 6620       If list of 
-000103f0: 7374 7269 6e67 732c 2065 6163 6820 6c69  strings, each li
-00010400: 7374 2069 7465 6d20 6973 2070 7269 6e74  st item is print
-00010410: 6564 206f 6e20 6974 7320 6f77 6e20 6c69  ed on its own li
-00010420: 6e65 2e0d 0a20 2020 2020 2020 206f 7065  ne...        ope
-00010430: 6e5f 6669 6c65 203a 2062 6f6f 6c0d 0a20  n_file : bool.. 
-00010440: 2020 2020 2020 2020 2020 2057 6865 7468             Wheth
-00010450: 6572 2074 6f20 6f70 656e 2074 6865 2066  er to open the f
-00010460: 696c 6520 7573 696e 6720 7468 6520 6465  ile using the de
-00010470: 6661 756c 7420 7072 6f67 7261 6d20 6166  fault program af
-00010480: 7465 7220 6372 6561 7469 6f6e 2e0d 0a20  ter creation... 
-00010490: 2020 2020 2020 206d 6574 6164 6174 6120         metadata 
-000104a0: 3a20 6469 6374 0d0a 2020 2020 2020 2020  : dict..        
-000104b0: 2020 2020 4578 7472 6120 6461 7461 2074      Extra data t
-000104c0: 6f20 6265 2070 6173 7365 6420 616e 6420  o be passed and 
-000104d0: 7368 6f77 6e20 696e 2074 6865 2050 4446  shown in the PDF
-000104e0: 2e20 5468 6520 6b65 7920 616e 6420 7661  . The key and va
-000104f0: 6c75 6520 7769 6c6c 2062 6520 7368 6f77  lue will be show
-00010500: 6e20 7769 7468 2061 2063 6f6c 6f6e 2e0d  n with a colon..
-00010510: 0a20 2020 2020 2020 2020 2020 2045 2e67  .            E.g
-00010520: 2e20 7061 7373 696e 6720 7b27 4175 7468  . passing {'Auth
-00010530: 6f72 273a 2027 4a61 6d65 7327 2c20 2755  or': 'James', 'U
-00010540: 6e69 7427 3a20 2754 7275 6542 6561 6d27  nit': 'TrueBeam'
-00010550: 7d20 776f 756c 6420 7265 7375 6c74 2069  } would result i
-00010560: 6e20 7465 7874 2069 6e20 7468 6520 5044  n text in the PD
-00010570: 4620 6c69 6b65 3a0d 0a20 2020 2020 2020  F like:..       
-00010580: 2020 2020 202d 2d2d 2d2d 2d2d 2d2d 2d2d       -----------
-00010590: 2d2d 2d0d 0a20 2020 2020 2020 2020 2020  ---..           
-000105a0: 2041 7574 686f 723a 204a 616d 6573 0d0a   Author: James..
-000105b0: 2020 2020 2020 2020 2020 2020 556e 6974              Unit
-000105c0: 3a20 5472 7565 4265 616d 0d0a 2020 2020  : TrueBeam..    
-000105d0: 2020 2020 2020 2020 2d2d 2d2d 2d2d 2d2d          --------
-000105e0: 2d2d 2d2d 2d2d 0d0a 2020 2020 2020 2020  ------..        
-000105f0: 6c6f 676f 3a20 5061 7468 2c20 7374 720d  logo: Path, str.
-00010600: 0a20 2020 2020 2020 2020 2020 2041 2063  .            A c
-00010610: 7573 746f 6d20 6c6f 676f 2074 6f20 7573  ustom logo to us
-00010620: 6520 696e 2074 6865 2050 4446 2072 6570  e in the PDF rep
-00010630: 6f72 742e 2049 6620 6e6f 7468 696e 6720  ort. If nothing 
-00010640: 6973 2070 6173 7365 642c 2074 6865 2064  is passed, the d
-00010650: 6566 6175 6c74 2070 796c 696e 6163 206c  efault pylinac l
-00010660: 6f67 6f20 6973 2075 7365 642e 0d0a 2020  ogo is used...  
-00010670: 2020 2020 2020 2222 220d 0a20 2020 2020        """..     
-00010680: 2020 2069 6620 6e6f 7420 7365 6c66 2e5f     if not self._
-00010690: 6973 5f61 6e61 6c79 7a65 643a 0d0a 2020  is_analyzed:..  
-000106a0: 2020 2020 2020 2020 2020 7261 6973 6520            raise 
-000106b0: 5661 6c75 6545 7272 6f72 2822 5468 6520  ValueError("The 
-000106c0: 7365 7420 6973 206e 6f74 2061 6e61 6c79  set is not analy
-000106d0: 7a65 642e 2055 7365 202e 616e 616c 797a  zed. Use .analyz
-000106e0: 6528 2920 6669 7273 742e 2229 0d0a 2020  e() first.")..  
-000106f0: 2020 2020 2020 706c 742e 696f 6666 2829        plt.ioff()
-00010700: 0d0a 2020 2020 2020 2020 7469 746c 6520  ..        title 
-00010710: 3d20 2257 696e 7374 6f6e 2d4c 7574 7a20  = "Winston-Lutz 
-00010720: 416e 616c 7973 6973 220d 0a20 2020 2020  Analysis"..     
-00010730: 2020 2063 616e 7661 7320 3d20 7064 662e     canvas = pdf.
-00010740: 5079 6c69 6e61 6343 616e 7661 7328 0d0a  PylinacCanvas(..
-00010750: 2020 2020 2020 2020 2020 2020 6669 6c65              file
-00010760: 6e61 6d65 2c20 7061 6765 5f74 6974 6c65  name, page_title
-00010770: 3d74 6974 6c65 2c20 6d65 7461 6461 7461  =title, metadata
-00010780: 3d6d 6574 6164 6174 612c 206c 6f67 6f3d  =metadata, logo=
-00010790: 6c6f 676f 0d0a 2020 2020 2020 2020 290d  logo..        ).
-000107a0: 0a20 2020 2020 2020 2074 6578 7420 3d20  .        text = 
-000107b0: 7365 6c66 2e72 6573 756c 7473 2861 735f  self.results(as_
-000107c0: 6c69 7374 3d54 7275 6529 0d0a 2020 2020  list=True)..    
-000107d0: 2020 2020 6361 6e76 6173 2e61 6464 5f74      canvas.add_t
-000107e0: 6578 7428 7465 7874 3d74 6578 742c 206c  ext(text=text, l
-000107f0: 6f63 6174 696f 6e3d 2837 2c20 3235 2e35  ocation=(7, 25.5
-00010800: 2929 0d0a 2020 2020 2020 2020 2320 6472  ))..        # dr
-00010810: 6177 2073 756d 6d61 7279 2069 6d61 6765  aw summary image
-00010820: 206f 6e20 3173 7420 7061 6765 0d0a 2020   on 1st page..  
-00010830: 2020 2020 2020 6461 7461 203d 2069 6f2e        data = io.
-00010840: 4279 7465 7349 4f28 290d 0a20 2020 2020  BytesIO()..     
-00010850: 2020 2073 656c 662e 7361 7665 5f73 756d     self.save_sum
-00010860: 6d61 7279 2864 6174 612c 2066 6967 5f73  mary(data, fig_s
-00010870: 697a 653d 2838 2c20 3829 290d 0a20 2020  ize=(8, 8))..   
-00010880: 2020 2020 2063 616e 7661 732e 6164 645f       canvas.add_
-00010890: 696d 6167 6528 696d 6167 655f 6461 7461  image(image_data
-000108a0: 3d64 6174 612c 206c 6f63 6174 696f 6e3d  =data, location=
-000108b0: 2832 2c20 3329 2c20 6469 6d65 6e73 696f  (2, 3), dimensio
-000108c0: 6e73 3d28 3136 2c20 3136 2929 0d0a 2020  ns=(16, 16))..  
-000108d0: 2020 2020 2020 6966 206e 6f74 6573 2069        if notes i
-000108e0: 7320 6e6f 7420 4e6f 6e65 3a0d 0a20 2020  s not None:..   
-000108f0: 2020 2020 2020 2020 2063 616e 7661 732e           canvas.
-00010900: 6164 645f 7465 7874 2874 6578 743d 224e  add_text(text="N
-00010910: 6f74 6573 3a22 2c20 6c6f 6361 7469 6f6e  otes:", location
-00010920: 3d28 312c 2034 2e35 292c 2066 6f6e 745f  =(1, 4.5), font_
-00010930: 7369 7a65 3d31 3429 0d0a 2020 2020 2020  size=14)..      
-00010940: 2020 2020 2020 6361 6e76 6173 2e61 6464        canvas.add
-00010950: 5f74 6578 7428 7465 7874 3d6e 6f74 6573  _text(text=notes
-00010960: 2c20 6c6f 6361 7469 6f6e 3d28 312c 2034  , location=(1, 4
-00010970: 2929 0d0a 2020 2020 2020 2020 2320 6164  ))..        # ad
-00010980: 6420 6d6f 7265 2070 6167 6573 2073 686f  d more pages sho
-00010990: 7769 6e67 2069 6e64 6976 6964 7561 6c20  wing individual 
-000109a0: 6178 6973 2069 6d61 6765 730d 0a20 2020  axis images..   
-000109b0: 2020 2020 2066 6f72 2061 7820 696e 2028       for ax in (
-000109c0: 0d0a 2020 2020 2020 2020 2020 2020 4178  ..            Ax
-000109d0: 6973 2e47 414e 5452 592c 0d0a 2020 2020  is.GANTRY,..    
-000109e0: 2020 2020 2020 2020 4178 6973 2e43 4f4c          Axis.COL
-000109f0: 4c49 4d41 544f 522c 0d0a 2020 2020 2020  LIMATOR,..      
-00010a00: 2020 2020 2020 4178 6973 2e43 4f55 4348        Axis.COUCH
-00010a10: 2c0d 0a20 2020 2020 2020 2020 2020 2041  ,..            A
-00010a20: 7869 732e 4742 5f43 4f4d 424f 2c0d 0a20  xis.GB_COMBO,.. 
-00010a30: 2020 2020 2020 2020 2020 2041 7869 732e             Axis.
-00010a40: 4742 505f 434f 4d42 4f2c 0d0a 2020 2020  GBP_COMBO,..    
-00010a50: 2020 2020 293a 0d0a 2020 2020 2020 2020      ):..        
-00010a60: 2020 2020 6966 2073 656c 662e 5f63 6f6e      if self._con
-00010a70: 7461 696e 735f 6178 6973 5f69 6d61 6765  tains_axis_image
-00010a80: 7328 6178 293a 0d0a 2020 2020 2020 2020  s(ax):..        
-00010a90: 2020 2020 2020 2020 6361 6e76 6173 2e61          canvas.a
-00010aa0: 6464 5f6e 6577 5f70 6167 6528 290d 0a20  dd_new_page().. 
-00010ab0: 2020 2020 2020 2020 2020 2020 2020 2064                 d
-00010ac0: 6174 6120 3d20 696f 2e42 7974 6573 494f  ata = io.BytesIO
-00010ad0: 2829 0d0a 2020 2020 2020 2020 2020 2020  ()..            
-00010ae0: 2020 2020 7365 6c66 2e73 6176 655f 696d      self.save_im
-00010af0: 6167 6573 2864 6174 612c 2061 7869 733d  ages(data, axis=
-00010b00: 6178 290d 0a20 2020 2020 2020 2020 2020  ax)..           
-00010b10: 2020 2020 2063 616e 7661 732e 6164 645f       canvas.add_
-00010b20: 696d 6167 6528 6461 7461 2c20 6c6f 6361  image(data, loca
-00010b30: 7469 6f6e 3d28 322c 2037 292c 2064 696d  tion=(2, 7), dim
-00010b40: 656e 7369 6f6e 733d 2831 382c 2031 3829  ensions=(18, 18)
-00010b50: 290d 0a0d 0a20 2020 2020 2020 2063 616e  )....        can
-00010b60: 7661 732e 6669 6e69 7368 2829 0d0a 0d0a  vas.finish()....
-00010b70: 2020 2020 2020 2020 6966 206f 7065 6e5f          if open_
-00010b80: 6669 6c65 3a0d 0a20 2020 2020 2020 2020  file:..         
-00010b90: 2020 2077 6562 6272 6f77 7365 722e 6f70     webbrowser.op
-00010ba0: 656e 2866 696c 656e 616d 6529 0d0a 0d0a  en(filename)....
-00010bb0: 2020 2020 6465 6620 5f63 6f6e 7461 696e      def _contain
-00010bc0: 735f 6178 6973 5f69 6d61 6765 7328 7365  s_axis_images(se
-00010bd0: 6c66 2c20 6178 6973 3a20 4178 6973 203d  lf, axis: Axis =
-00010be0: 2041 7869 732e 4741 4e54 5259 2920 2d3e   Axis.GANTRY) ->
-00010bf0: 2062 6f6f 6c3a 0d0a 2020 2020 2020 2020   bool:..        
-00010c00: 2222 2252 6574 7572 6e20 7768 6574 6865  """Return whethe
-00010c10: 7220 6f72 206e 6f74 2074 6865 2073 6574  r or not the set
-00010c20: 206f 6620 574c 2069 6d61 6765 7320 636f   of WL images co
-00010c30: 6e74 6169 6e73 2069 6d61 6765 7320 7065  ntains images pe
-00010c40: 7274 6169 6e69 6e67 2074 6f20 6120 6769  rtaining to a gi
-00010c50: 7665 6e20 6178 6973 2222 220d 0a20 2020  ven axis"""..   
-00010c60: 2020 2020 2072 6574 7572 6e20 616e 7928       return any(
-00010c70: 5472 7565 2066 6f72 2069 6d61 6765 2069  True for image i
-00010c80: 6e20 7365 6c66 2e69 6d61 6765 7320 6966  n self.images if
-00010c90: 2069 6d61 6765 2e76 6172 6961 626c 655f   image.variable_
-00010ca0: 6178 6973 2069 6e20 2861 7869 732c 2929  axis in (axis,))
-00010cb0: 0d0a 0d0a 0d0a 636c 6173 7320 5769 6e73  ......class Wins
-00010cc0: 746f 6e4c 7574 7a32 444d 756c 7469 5461  tonLutz2DMultiTa
-00010cd0: 7267 6574 2857 696e 7374 6f6e 4c75 747a  rget(WinstonLutz
-00010ce0: 3244 293a 0d0a 2020 2020 2222 2241 2032  2D):..    """A 2
-00010cf0: 4420 696d 6167 6520 6f66 2061 2057 4c20  D image of a WL 
-00010d00: 6465 6c69 7665 7279 2c20 6275 7420 7768  delivery, but wh
-00010d10: 6572 6520 6d75 6c74 6970 6c65 2042 4273  ere multiple BBs
-00010d20: 2061 7265 2069 6e20 7573 652e 2222 220d   are in use.""".
-00010d30: 0a0d 0a20 2020 2064 6574 6563 7469 6f6e  ...    detection
-00010d40: 5f63 6f6e 6469 7469 6f6e 7320 3d20 5b69  _conditions = [i
-00010d50: 735f 726f 756e 642c 2069 735f 7379 6d6d  s_round, is_symm
-00010d60: 6574 7269 632c 2069 735f 6d6f 6465 7374  etric, is_modest
-00010d70: 5f73 697a 655d 0d0a 2020 2020 6669 656c  _size]..    fiel
-00010d80: 645f 636f 6e64 6974 696f 6e73 203d 205b  d_conditions = [
-00010d90: 6973 5f73 7175 6172 652c 2069 735f 7269  is_square, is_ri
-00010da0: 6768 745f 7371 7561 7265 5f73 697a 655d  ght_square_size]
-00010db0: 0d0a 0d0a 2020 2020 6465 6620 5f5f 696e  ....    def __in
-00010dc0: 6974 5f5f 2873 656c 662c 202a 6172 6773  it__(self, *args
-00010dd0: 2c20 2a2a 6b77 6172 6773 293a 0d0a 2020  , **kwargs):..  
-00010de0: 2020 2020 2020 7375 7065 7228 292e 5f5f        super().__
-00010df0: 696e 6974 5f5f 282a 6172 6773 2c20 2a2a  init__(*args, **
-00010e00: 6b77 6172 6773 290d 0a20 2020 2020 2020  kwargs)..       
-00010e10: 2073 656c 662e 666c 6970 7564 2829 2020   self.flipud()  
-00010e20: 2320 7265 7374 6f72 6520 746f 206f 7269  # restore to ori
-00010e30: 6769 6e61 6c20 7669 6577 3b20 7661 6e69  ginal view; vani
-00010e40: 6c6c 6120 574c 206d 6179 206e 6565 6420  lla WL may need 
-00010e50: 746f 2072 6576 6572 740d 0a0d 0a20 2020  to revert....   
-00010e60: 2064 6566 2061 735f 616e 616c 797a 6564   def as_analyzed
-00010e70: 2873 656c 662c 2062 625f 6c6f 6361 7469  (self, bb_locati
-00010e80: 6f6e 3a20 6469 6374 2920 2d3e 2057 696e  on: dict) -> Win
-00010e90: 7374 6f6e 4c75 747a 3244 4d75 6c74 6954  stonLutz2DMultiT
-00010ea0: 6172 6765 743a 0d0a 2020 2020 2020 2020  arget:..        
-00010eb0: 2222 2241 6e61 6c79 7a65 2074 6865 2069  """Analyze the i
-00010ec0: 6d61 6765 206f 6620 7468 6520 6d75 6c74  mage of the mult
-00010ed0: 692d 4242 2073 6574 7570 2e20 5765 2072  i-BB setup. We r
-00010ee0: 6574 7572 6e20 6120 636f 7079 206f 6620  eturn a copy of 
-00010ef0: 7468 650d 0a20 2020 2020 2020 2057 4c20  the..        WL 
-00010f00: 696d 6167 6520 6265 6361 7573 6520 7765  image because we
-00010f10: 2061 6e61 6c79 7a65 2069 6d61 6765 7320   analyze images 
-00010f20: 6d6f 7265 2074 6861 6e20 6f6e 6365 2e20  more than once. 
-00010f30: 4561 6368 2022 616e 616c 797a 6564 2220  Each "analyzed" 
-00010f40: 696d 6167 650d 0a20 2020 2020 2020 2069  image..        i
-00010f50: 7320 7265 616c 6c79 2074 6865 2061 6e61  s really the ana
-00010f60: 6c79 7369 7320 6f66 2061 2042 422f 696d  lysis of a BB/im
-00010f70: 6167 6520 636f 6d62 6f2e 0d0a 0d0a 2020  age combo.....  
-00010f80: 2020 2020 2020 5061 7261 6d65 7465 7273        Parameters
-00010f90: 0d0a 2020 2020 2020 2020 2d2d 2d2d 2d2d  ..        ------
-00010fa0: 2d2d 2d2d 0d0a 2020 2020 2020 2020 6262  ----..        bb
-00010fb0: 5f6c 6f63 6174 696f 6e0d 0a20 2020 2020  _location..     
-00010fc0: 2020 2020 2020 2041 6e20 6974 6572 6162         An iterab
-00010fd0: 6c65 206f 6620 6469 6374 696f 6e61 7269  le of dictionari
-00010fe0: 6573 2e20 4561 6368 2064 6963 7420 636f  es. Each dict co
-00010ff0: 6e74 6169 6e73 206b 6579 7320 666f 7220  ntains keys for 
-00011000: 7468 6520 6f66 6673 6574 7320 616e 6420  the offsets and 
-00011010: 7369 7a65 206f 6620 7468 6520 4242 2069  size of the BB i
-00011020: 6e20 6d6d 2e0d 0a20 2020 2020 2020 2020  n mm...         
-00011030: 2020 2055 7365 2074 6865 2060 6042 4241     Use the ``BBA
-00011040: 7272 616e 6765 6d65 6e74 6060 2063 6c61  rrangement`` cla
-00011050: 7373 2061 7320 6120 6775 6964 652e 0d0a  ss as a guide...
-00011060: 2020 2020 2020 2020 2222 220d 0a20 2020          """..   
-00011070: 2020 2020 2073 656c 662e 6669 656c 645f       self.field_
-00011080: 6361 782c 2073 656c 662e 5f72 6164 5f66  cax, self._rad_f
-00011090: 6965 6c64 5f62 6f75 6e64 696e 675f 626f  ield_bounding_bo
-000110a0: 7820 3d20 7365 6c66 2e5f 6669 6e64 5f66  x = self._find_f
-000110b0: 6965 6c64 5f63 656e 7472 6f69 6428 0d0a  ield_centroid(..
-000110c0: 2020 2020 2020 2020 2020 2020 6262 5f6c              bb_l
-000110d0: 6f63 6174 696f 6e0d 0a20 2020 2020 2020  ocation..       
-000110e0: 2029 0d0a 2020 2020 2020 2020 7365 6c66   )..        self
-000110f0: 2e62 6220 3d20 7365 6c66 2e5f 6669 6e64  .bb = self._find
-00011100: 5f62 6228 6262 5f6c 6f63 6174 696f 6e29  _bb(bb_location)
-00011110: 0d0a 2020 2020 2020 2020 7365 6c66 2e5f  ..        self._
-00011120: 6973 5f61 6e61 6c79 7a65 6420 3d20 5472  is_analyzed = Tr
-00011130: 7565 0d0a 2020 2020 2020 2020 7265 7475  ue..        retu
-00011140: 726e 2063 6f70 792e 6465 6570 636f 7079  rn copy.deepcopy
-00011150: 2873 656c 6629 0d0a 0d0a 2020 2020 6465  (self)....    de
-00011160: 6620 706c 6f74 280d 0a20 2020 2020 2020  f plot(..       
-00011170: 2073 656c 662c 2061 783a 2070 6c74 2e41   self, ax: plt.A
-00011180: 7865 7320 7c20 4e6f 6e65 203d 204e 6f6e  xes | None = Non
-00011190: 652c 2073 686f 773a 2062 6f6f 6c20 3d20  e, show: bool = 
-000111a0: 5472 7565 2c20 636c 6561 725f 6669 673a  True, clear_fig:
-000111b0: 2062 6f6f 6c20 3d20 4661 6c73 650d 0a20   bool = False.. 
-000111c0: 2020 2029 202d 3e20 706c 742e 4178 6573     ) -> plt.Axes
-000111d0: 3a0d 0a20 2020 2020 2020 2061 7820 3d20  :..        ax = 
-000111e0: 7375 7065 7228 4c69 6e61 6344 6963 6f6d  super(LinacDicom
-000111f0: 496d 6167 652c 2073 656c 6629 2e70 6c6f  Image, self).plo
-00011200: 7428 6178 3d61 782c 2073 686f 773d 4661  t(ax=ax, show=Fa
-00011210: 6c73 652c 2063 6c65 6172 5f66 6967 3d63  lse, clear_fig=c
-00011220: 6c65 6172 5f66 6967 290d 0a20 2020 2020  lear_fig)..     
-00011230: 2020 2061 782e 706c 6f74 2873 656c 662e     ax.plot(self.
-00011240: 6669 656c 645f 6361 782e 782c 2073 656c  field_cax.x, sel
-00011250: 662e 6669 656c 645f 6361 782e 792c 2022  f.field_cax.y, "
-00011260: 6773 222c 206d 733d 3829 0d0a 2020 2020  gs", ms=8)..    
-00011270: 2020 2020 6178 2e73 6574 5f79 6c69 6d28      ax.set_ylim(
-00011280: 5b73 656c 662e 5f72 6164 5f66 6965 6c64  [self._rad_field
-00011290: 5f62 6f75 6e64 696e 675f 626f 785b 305d  _bounding_box[0]
-000112a0: 2c20 7365 6c66 2e5f 7261 645f 6669 656c  , self._rad_fiel
-000112b0: 645f 626f 756e 6469 6e67 5f62 6f78 5b32  d_bounding_box[2
-000112c0: 5d5d 290d 0a20 2020 2020 2020 2061 782e  ]])..        ax.
-000112d0: 7365 745f 786c 696d 285b 7365 6c66 2e5f  set_xlim([self._
-000112e0: 7261 645f 6669 656c 645f 626f 756e 6469  rad_field_boundi
-000112f0: 6e67 5f62 6f78 5b31 5d2c 2073 656c 662e  ng_box[1], self.
-00011300: 5f72 6164 5f66 6965 6c64 5f62 6f75 6e64  _rad_field_bound
-00011310: 696e 675f 626f 785b 335d 5d29 0d0a 2020  ing_box[3]])..  
-00011320: 2020 2020 2020 6178 2e73 6574 5f79 7469        ax.set_yti
-00011330: 636b 6c61 6265 6c73 285b 5d29 0d0a 2020  cklabels([])..  
-00011340: 2020 2020 2020 6178 2e73 6574 5f78 7469        ax.set_xti
-00011350: 636b 6c61 6265 6c73 285b 5d29 0d0a 2020  cklabels([])..  
-00011360: 2020 2020 2020 6178 2e73 6574 5f74 6974        ax.set_tit
-00011370: 6c65 2822 5c6e 222e 6a6f 696e 2877 7261  le("\n".join(wra
-00011380: 7028 5061 7468 2873 656c 662e 7061 7468  p(Path(self.path
-00011390: 292e 6e61 6d65 2c20 3330 2929 2c20 666f  ).name, 30)), fo
-000113a0: 6e74 7369 7a65 3d31 3029 0d0a 2020 2020  ntsize=10)..    
-000113b0: 2020 2020 6178 2e73 6574 5f78 6c61 6265      ax.set_xlabe
-000113c0: 6c28 0d0a 2020 2020 2020 2020 2020 2020  l(..            
-000113d0: 6622 473d 7b73 656c 662e 6761 6e74 7279  f"G={self.gantry
-000113e0: 5f61 6e67 6c65 3a2e 3066 7d2c 2042 3d7b  _angle:.0f}, B={
-000113f0: 7365 6c66 2e63 6f6c 6c69 6d61 746f 725f  self.collimator_
-00011400: 616e 676c 653a 2e30 667d 2c20 503d 7b73  angle:.0f}, P={s
-00011410: 656c 662e 636f 7563 685f 616e 676c 653a  elf.couch_angle:
-00011420: 2e30 667d 220d 0a20 2020 2020 2020 2029  .0f}"..        )
-00011430: 0d0a 2020 2020 2020 2020 6178 2e73 6574  ..        ax.set
-00011440: 5f79 6c61 6265 6c28 6622 4341 5820 746f  _ylabel(f"CAX to
-00011450: 2042 423a 207b 7365 6c66 2e63 6178 3262   BB: {self.cax2b
-00011460: 625f 6469 7374 616e 6365 3a33 2e32 667d  b_distance:3.2f}
-00011470: 6d6d 2229 0d0a 2020 2020 2020 2020 6966  mm")..        if
-00011480: 2073 686f 773a 0d0a 2020 2020 2020 2020   show:..        
-00011490: 2020 2020 706c 742e 7368 6f77 2829 0d0a      plt.show()..
-000114a0: 2020 2020 2020 2020 7265 7475 726e 2061          return a
-000114b0: 780d 0a0d 0a20 2020 2064 6566 205f 6e6f  x....    def _no
-000114c0: 6d69 6e61 6c5f 706f 696e 7428 7365 6c66  minal_point(self
-000114d0: 2c20 6262 3a20 6469 6374 2920 2d3e 2050  , bb: dict) -> P
-000114e0: 6f69 6e74 3a0d 0a20 2020 2020 2020 2022  oint:..        "
-000114f0: 2222 4361 6c63 756c 6174 6520 7468 6520  ""Calculate the 
-00011500: 6578 7065 6374 6564 2070 6f69 6e74 2070  expected point p
-00011510: 6f73 6974 696f 6e20 696e 2032 4422 2222  osition in 2D"""
-00011520: 0d0a 2020 2020 2020 2020 7368 6966 745f  ..        shift_
-00011530: 795f 6d6d 203d 2062 625f 7072 6f6a 6563  y_mm = bb_projec
-00011540: 7469 6f6e 5f6c 6f6e 6728 0d0a 2020 2020  tion_long(..    
-00011550: 2020 2020 2020 2020 6f66 6673 6574 5f69          offset_i
-00011560: 6e3d 6262 5b22 6f66 6673 6574 5f69 6e5f  n=bb["offset_in_
-00011570: 6d6d 225d 2c0d 0a20 2020 2020 2020 2020  mm"],..         
-00011580: 2020 206f 6666 7365 745f 7570 3d62 625b     offset_up=bb[
-00011590: 226f 6666 7365 745f 7570 5f6d 6d22 5d2c  "offset_up_mm"],
-000115a0: 0d0a 2020 2020 2020 2020 2020 2020 6f66  ..            of
-000115b0: 6673 6574 5f6c 6566 743d 6262 5b22 6f66  fset_left=bb["of
-000115c0: 6673 6574 5f6c 6566 745f 6d6d 225d 2c0d  fset_left_mm"],.
-000115d0: 0a20 2020 2020 2020 2020 2020 2073 6164  .            sad
-000115e0: 3d73 656c 662e 7361 642c 0d0a 2020 2020  =self.sad,..    
-000115f0: 2020 2020 2020 2020 6761 6e74 7279 3d73          gantry=s
-00011600: 656c 662e 6761 6e74 7279 5f61 6e67 6c65  elf.gantry_angle
-00011610: 2c0d 0a20 2020 2020 2020 2029 0d0a 2020  ,..        )..  
-00011620: 2020 2020 2020 7368 6966 745f 785f 6d6d        shift_x_mm
-00011630: 203d 2062 625f 7072 6f6a 6563 7469 6f6e   = bb_projection
-00011640: 5f67 616e 7472 795f 706c 616e 6528 0d0a  _gantry_plane(..
-00011650: 2020 2020 2020 2020 2020 2020 6f66 6673              offs
-00011660: 6574 5f6c 6566 743d 6262 5b22 6f66 6673  et_left=bb["offs
-00011670: 6574 5f6c 6566 745f 6d6d 225d 2c0d 0a20  et_left_mm"],.. 
-00011680: 2020 2020 2020 2020 2020 206f 6666 7365             offse
-00011690: 745f 7570 3d62 625b 226f 6666 7365 745f  t_up=bb["offset_
-000116a0: 7570 5f6d 6d22 5d2c 0d0a 2020 2020 2020  up_mm"],..      
-000116b0: 2020 2020 2020 7361 643d 7365 6c66 2e73        sad=self.s
-000116c0: 6164 2c0d 0a20 2020 2020 2020 2020 2020  ad,..           
-000116d0: 2067 616e 7472 793d 7365 6c66 2e67 616e   gantry=self.gan
-000116e0: 7472 795f 616e 676c 652c 0d0a 2020 2020  try_angle,..    
-000116f0: 2020 2020 290d 0a20 2020 2020 2020 2023      )..        #
-00011700: 2075 6e6c 696b 6520 7661 6e69 6c6c 6120   unlike vanilla 
-00011710: 574c 2c20 7468 6520 6669 656c 6420 6361  WL, the field ca
-00011720: 6e20 6265 2061 7379 6d6d 6574 7269 632c  n be asymmetric,
-00011730: 2073 6f20 7573 6520 6365 6e74 6572 206f   so use center o
-00011740: 6620 696d 6167 650d 0a20 2020 2020 2020  f image..       
-00011750: 2065 7870 6563 7465 645f 7920 3d20 7365   expected_y = se
-00011760: 6c66 2e65 7069 642e 7920 2d20 7368 6966  lf.epid.y - shif
-00011770: 745f 795f 6d6d 202a 2073 656c 662e 6470  t_y_mm * self.dp
-00011780: 6d6d 0d0a 2020 2020 2020 2020 6578 7065  mm..        expe
-00011790: 6374 6564 5f78 203d 2073 656c 662e 6570  cted_x = self.ep
-000117a0: 6964 2e78 202b 2073 6869 6674 5f78 5f6d  id.x + shift_x_m
-000117b0: 6d20 2a20 7365 6c66 2e64 706d 6d0d 0a20  m * self.dpmm.. 
-000117c0: 2020 2020 2020 2072 6574 7572 6e20 506f         return Po
-000117d0: 696e 7428 783d 6578 7065 6374 6564 5f78  int(x=expected_x
-000117e0: 2c20 793d 6578 7065 6374 6564 5f79 290d  , y=expected_y).
-000117f0: 0a0d 0a20 2020 2064 6566 205f 6669 6e64  ...    def _find
-00011800: 5f66 6965 6c64 5f63 656e 7472 6f69 6428  _field_centroid(
-00011810: 7365 6c66 2c20 6c6f 6361 7469 6f6e 3a20  self, location: 
-00011820: 6469 6374 2920 2d3e 2074 7570 6c65 5b50  dict) -> tuple[P
-00011830: 6f69 6e74 2c20 6c69 7374 5d3a 0d0a 2020  oint, list]:..  
-00011840: 2020 2020 2020 2222 2246 696e 6420 7468        """Find th
-00011850: 6520 6365 6e74 726f 6964 206f 6620 7468  e centroid of th
-00011860: 6520 7261 6469 6174 696f 6e20 6669 656c  e radiation fiel
-00011870: 6420 6261 7365 6420 6f6e 2061 2035 3025  d based on a 50%
-00011880: 2068 6569 6768 7420 7468 7265 7368 6f6c   height threshol
-00011890: 642e 0d0a 2020 2020 2020 2020 5468 6973  d...        This
-000118a0: 2061 7070 6c69 6573 2074 6865 2066 6965   applies the fie
-000118b0: 6c64 2064 6574 6563 7469 6f6e 2063 6f6e  ld detection con
-000118c0: 6469 7469 6f6e 7320 616e 6420 616c 736f  ditions and also
-000118d0: 2061 206e 6561 726e 6573 7320 636f 6e64   a nearness cond
-000118e0: 6974 696f 6e2e 0d0a 0d0a 2020 2020 2020  ition.....      
-000118f0: 2020 5265 7475 726e 730d 0a20 2020 2020    Returns..     
-00011900: 2020 202d 2d2d 2d2d 2d2d 0d0a 2020 2020     -------..    
-00011910: 2020 2020 700d 0a20 2020 2020 2020 2020      p..         
-00011920: 2020 2054 6865 2043 4158 2070 6f69 6e74     The CAX point
-00011930: 206c 6f63 6174 696f 6e2e 0d0a 2020 2020   location...    
-00011940: 2020 2020 6564 6765 730d 0a20 2020 2020      edges..     
-00011950: 2020 2020 2020 2054 6865 2062 6f75 6e64         The bound
-00011960: 696e 6720 626f 7820 6f66 2074 6865 2066  ing box of the f
-00011970: 6965 6c64 2c20 706c 7573 2061 2073 6d61  ield, plus a sma
-00011980: 6c6c 206d 6172 6769 6e2e 0d0a 2020 2020  ll margin...    
-00011990: 2020 2020 2222 220d 0a20 2020 2020 2020      """..       
-000119a0: 206d 696e 2c20 6d61 7820 3d20 6e70 2e70   min, max = np.p
-000119b0: 6572 6365 6e74 696c 6528 7365 6c66 2e61  ercentile(self.a
-000119c0: 7272 6179 2c20 5b35 2c20 3939 2e39 5d29  rray, [5, 99.9])
-000119d0: 0d0a 2020 2020 2020 2020 7468 7265 7368  ..        thresh
-000119e0: 6f6c 645f 696d 6720 3d20 7365 6c66 2e61  old_img = self.a
-000119f0: 735f 6269 6e61 7279 2828 6d61 7820 2d20  s_binary((max - 
-00011a00: 6d69 6e29 202f 2032 202b 206d 696e 290d  min) / 2 + min).
-00011a10: 0a20 2020 2020 2020 2066 696c 6c65 645f  .        filled_
-00011a20: 696d 6720 3d20 6e64 696d 6167 652e 6269  img = ndimage.bi
-00011a30: 6e61 7279 5f66 696c 6c5f 686f 6c65 7328  nary_fill_holes(
-00011a40: 7468 7265 7368 6f6c 645f 696d 6729 0d0a  threshold_img)..
-00011a50: 2020 2020 2020 2020 6c61 6265 6c65 645f          labeled_
-00011a60: 6172 722c 206e 756d 5f72 6f69 203d 206e  arr, num_roi = n
-00011a70: 6469 6d61 6765 2e6c 6162 656c 2866 696c  dimage.label(fil
-00011a80: 6c65 645f 696d 6729 0d0a 2020 2020 2020  led_img)..      
-00011a90: 2020 7265 6769 6f6e 7320 3d20 6d65 6173    regions = meas
-00011aa0: 7572 652e 7265 6769 6f6e 7072 6f70 7328  ure.regionprops(
-00011ab0: 6c61 6265 6c65 645f 6172 7229 0d0a 2020  labeled_arr)..  
-00011ac0: 2020 2020 2020 6669 656c 645f 6361 6e64        field_cand
-00011ad0: 6964 6174 6573 203d 205b 0d0a 2020 2020  idates = [..    
-00011ae0: 2020 2020 2020 2020 616c 6c28 0d0a 2020          all(..  
-00011af0: 2020 2020 2020 2020 2020 2020 2020 636f                co
-00011b00: 6e64 6974 696f 6e28 0d0a 2020 2020 2020  ndition(..      
-00011b10: 2020 2020 2020 2020 2020 2020 2020 7265                re
-00011b20: 6769 6f6e 2c0d 0a20 2020 2020 2020 2020  gion,..         
-00011b30: 2020 2020 2020 2020 2020 2064 706d 6d3d             dpmm=
-00011b40: 7365 6c66 2e64 706d 6d2c 0d0a 2020 2020  self.dpmm,..    
-00011b50: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00011b60: 7261 645f 7369 7a65 3d6c 6f63 6174 696f  rad_size=locatio
-00011b70: 6e5b 2272 6164 5f73 697a 655f 6d6d 225d  n["rad_size_mm"]
-00011b80: 2c0d 0a20 2020 2020 2020 2020 2020 2020  ,..             
-00011b90: 2020 2020 2020 2073 6861 7065 3d6c 6162         shape=lab
-00011ba0: 656c 6564 5f61 7272 2e73 6861 7065 2c0d  eled_arr.shape,.
+0000ea20: 0a20 2020 2020 2020 202d 2d2d 2d2d 2d2d  .        -------
+0000ea30: 2d2d 2d0a 2020 2020 2020 2020 7368 6f77  ---.        show
+0000ea40: 203a 2062 6f6f 6c0a 2020 2020 2020 2020   : bool.        
+0000ea50: 2020 2020 5768 6574 6865 7220 746f 2070      Whether to p
+0000ea60: 6c6f 7420 7468 6520 696d 6167 652e 0a20  lot the image.. 
+0000ea70: 2020 2020 2020 2076 6965 7762 6f78 5f6d         viewbox_m
+0000ea80: 6d20 3a20 666c 6f61 740a 2020 2020 2020  m : float.      
+0000ea90: 2020 2020 2020 5468 6520 6465 6661 756c        The defaul
+0000eaa0: 7420 7369 7a65 206f 6620 7468 6520 3344  t size of the 3D
+0000eab0: 2073 7061 6365 2074 6f20 706c 6f74 2069   space to plot i
+0000eac0: 6e20 6d6d 2069 6e20 6561 6368 2061 7869  n mm in each axi
+0000ead0: 732e 0a20 2020 2020 2020 2070 6c6f 745f  s..        plot_
+0000eae0: 6262 203a 2062 6f6f 6c0a 2020 2020 2020  bb : bool.      
+0000eaf0: 2020 2020 2020 5768 6574 6865 7220 746f        Whether to
+0000eb00: 2070 6c6f 7420 7468 6520 4242 206c 6f63   plot the BB loc
+0000eb10: 6174 696f 6e3b 2074 6865 2073 697a 6520  ation; the size 
+0000eb20: 6973 2061 6c73 6f20 636f 6e73 6964 6572  is also consider
+0000eb30: 6564 2e0a 2020 2020 2020 2020 706c 6f74  ed..        plot
+0000eb40: 5f69 736f 6365 6e74 6572 5f73 7068 6572  _isocenter_spher
+0000eb50: 6520 3a20 626f 6f6c 0a20 2020 2020 2020  e : bool.       
+0000eb60: 2020 2020 2057 6865 7468 6572 2074 6f20       Whether to 
+0000eb70: 706c 6f74 2074 6865 2067 616e 7472 7920  plot the gantry 
+0000eb80: 2b20 636f 6c6c 696d 6174 6f72 2069 736f  + collimator iso
+0000eb90: 6365 6e74 6572 2073 697a 652e 0a20 2020  center size..   
+0000eba0: 2020 2020 2070 6c6f 745f 636f 7563 685f       plot_couch_
+0000ebb0: 6973 6f20 3a20 626f 6f6c 0a20 2020 2020  iso : bool.     
+0000ebc0: 2020 2020 2020 2057 6865 7468 6572 2074         Whether t
+0000ebd0: 6f20 706c 6f74 2074 6865 2063 6f75 6368  o plot the couch
+0000ebe0: 2d70 6c61 6e65 2d6f 6e6c 7920 6973 6f63  -plane-only isoc
+0000ebf0: 656e 7465 7220 7369 7a65 2e0a 2020 2020  enter size..    
+0000ec00: 2020 2020 2020 2020 5468 6973 2077 696c          This wil
+0000ec10: 6c20 6265 207a 6572 6f20 6966 2074 6865  l be zero if the
+0000ec20: 7265 2061 7265 206e 6f20 696d 6167 6573  re are no images
+0000ec30: 2077 6865 7265 2074 6865 2063 6f75 6368   where the couch
+0000ec40: 2072 6f74 6174 6564 2e0a 2020 2020 2020   rotated..      
+0000ec50: 2020 706c 6f74 5f63 6f6c 6c5f 6973 6f20    plot_coll_iso 
+0000ec60: 3a20 626f 6f6c 0a20 2020 2020 2020 2020  : bool.         
+0000ec70: 2020 2057 6865 7468 6572 2074 6f20 706c     Whether to pl
+0000ec80: 6f74 2074 6865 2063 6f6c 6c69 6d61 746f  ot the collimato
+0000ec90: 722d 706c 616e 652d 6f6e 6c79 2069 736f  r-plane-only iso
+0000eca0: 6365 6e74 6572 2073 697a 652e 0a20 2020  center size..   
+0000ecb0: 2020 2020 2020 2020 2054 6869 7320 6973           This is
+0000ecc0: 2073 686f 776e 2061 6c6f 6e67 2074 6865   shown along the
+0000ecd0: 205a 2f59 2070 6c61 6e65 206f 6e6c 7920   Z/Y plane only 
+0000ece0: 746f 2064 6966 6665 7265 6e74 6961 7465  to differentiate
+0000ecf0: 2066 726f 6d20 7468 6520 636f 7563 6820   from the couch 
+0000ed00: 6973 6f20 7669 7375 616c 697a 6174 696f  iso visualizatio
+0000ed10: 6e2e 0a20 2020 2020 2020 2020 2020 2054  n..            T
+0000ed20: 6865 2063 6f6c 6c69 6d61 746f 7220 706c  he collimator pl
+0000ed30: 616e 6520 6973 2061 6c77 6179 7320 6e6f  ane is always no
+0000ed40: 726d 616c 2074 6f20 7468 6520 6761 6e74  rmal to the gant
+0000ed50: 7279 2061 6e67 6c65 2e0a 2020 2020 2020  ry angle..      
+0000ed60: 2020 2020 2020 5468 6973 2077 696c 6c20        This will 
+0000ed70: 6265 207a 6572 6f20 6966 2074 6865 7265  be zero if there
+0000ed80: 2061 7265 206e 6f20 696d 6167 6573 2077   are no images w
+0000ed90: 6865 7265 2074 6865 2063 6f6c 6c69 6d61  here the collima
+0000eda0: 746f 7220 726f 7461 7465 642e 0a20 2020  tor rotated..   
+0000edb0: 2020 2020 2073 686f 775f 6c65 6765 6e64       show_legend
+0000edc0: 203a 2062 6f6f 6c0a 2020 2020 2020 2020   : bool.        
+0000edd0: 2020 2020 5768 6574 6865 7220 746f 2073      Whether to s
+0000ede0: 686f 7720 7468 6520 6c65 6765 6e64 2e0a  how the legend..
+0000edf0: 2020 2020 2020 2020 2222 220a 2020 2020          """.    
+0000ee00: 2020 2020 6c69 6d69 7420 3d20 280a 2020      limit = (.  
+0000ee10: 2020 2020 2020 2020 2020 7669 6577 626f            viewbo
+0000ee20: 785f 6d6d 0a20 2020 2020 2020 2020 2020  x_mm.           
+0000ee30: 206f 7220 6d61 7828 0a20 2020 2020 2020   or max(.       
+0000ee40: 2020 2020 2020 2020 206e 702e 6162 7328           np.abs(
+0000ee50: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000ee60: 2020 2020 2028 0a20 2020 2020 2020 2020       (.         
+0000ee70: 2020 2020 2020 2020 2020 2020 2020 2073                 s
+0000ee80: 656c 662e 6262 5f73 6869 6674 5f76 6563  elf.bb_shift_vec
+0000ee90: 746f 722e 782c 0a20 2020 2020 2020 2020  tor.x,.         
+0000eea0: 2020 2020 2020 2020 2020 2020 2020 2073                 s
+0000eeb0: 656c 662e 6262 5f73 6869 6674 5f76 6563  elf.bb_shift_vec
+0000eec0: 746f 722e 792c 0a20 2020 2020 2020 2020  tor.y,.         
+0000eed0: 2020 2020 2020 2020 2020 2020 2020 2073                 s
+0000eee0: 656c 662e 6262 5f73 6869 6674 5f76 6563  elf.bb_shift_vec
+0000eef0: 746f 722e 7a2c 0a20 2020 2020 2020 2020  tor.z,.         
+0000ef00: 2020 2020 2020 2020 2020 2029 0a20 2020             ).   
+0000ef10: 2020 2020 2020 2020 2020 2020 2029 0a20               ). 
+0000ef20: 2020 2020 2020 2020 2020 2029 0a20 2020             ).   
+0000ef30: 2020 2020 2020 2020 202b 2073 656c 662e           + self.
+0000ef40: 5f62 625f 6469 616d 6574 6572 0a20 2020  _bb_diameter.   
+0000ef50: 2020 2020 2029 0a20 2020 2020 2020 2061       ).        a
+0000ef60: 7820 3d20 706c 742e 6178 6573 2870 726f  x = plt.axes(pro
+0000ef70: 6a65 6374 696f 6e3d 2233 6422 290a 2020  jection="3d").  
+0000ef80: 2020 2020 2020 2320 7765 2063 616e 2072        # we can r
+0000ef90: 6570 7265 7365 6e74 2074 6865 2069 736f  epresent the iso
+0000efa0: 2073 7068 6572 6520 6173 2061 2042 4220   sphere as a BB 
+0000efb0: 6f62 6a65 6374 3b20 7468 6520 6e6f 6d69  object; the nomi
+0000efc0: 6e61 6c20 6f62 6a65 6374 2069 736e 2774  nal object isn't
+0000efd0: 2075 7365 642c 206a 7573 7420 7468 6520   used, just the 
+0000efe0: 4242 2073 697a 650a 2020 2020 2020 2020  BB size.        
+0000eff0: 2320 706c 6f74 2074 6865 2066 6965 6c64  # plot the field
+0000f000: 2069 736f 6365 6e74 6572 2061 7320 782c   isocenter as x,
+0000f010: 792c 7a20 6c69 6e65 730a 2020 2020 2020  y,z lines.      
+0000f020: 2020 785f 6c69 6e65 203d 204c 696e 6528    x_line = Line(
+0000f030: 0a20 2020 2020 2020 2020 2020 2050 6f69  .            Poi
+0000f040: 6e74 280a 2020 2020 2020 2020 2020 2020  nt(.            
+0000f050: 2020 2020 2d6c 696d 6974 2c0a 2020 2020      -limit,.    
+0000f060: 2020 2020 2020 2020 2020 2020 7365 6c66              self
+0000f070: 2e62 622e 6d65 6173 7572 6564 5f66 6965  .bb.measured_fie
+0000f080: 6c64 5f70 6f73 6974 696f 6e2e 792c 0a20  ld_position.y,. 
+0000f090: 2020 2020 2020 2020 2020 2020 2020 2073                 s
+0000f0a0: 656c 662e 6262 2e6d 6561 7375 7265 645f  elf.bb.measured_
+0000f0b0: 6669 656c 645f 706f 7369 7469 6f6e 2e7a  field_position.z
+0000f0c0: 2c0a 2020 2020 2020 2020 2020 2020 292c  ,.            ),
+0000f0d0: 0a20 2020 2020 2020 2020 2020 2050 6f69  .            Poi
+0000f0e0: 6e74 280a 2020 2020 2020 2020 2020 2020  nt(.            
+0000f0f0: 2020 2020 6c69 6d69 742c 2073 656c 662e      limit, self.
+0000f100: 6262 2e6d 6561 7375 7265 645f 6669 656c  bb.measured_fiel
+0000f110: 645f 706f 7369 7469 6f6e 2e79 2c20 7365  d_position.y, se
+0000f120: 6c66 2e62 622e 6d65 6173 7572 6564 5f62  lf.bb.measured_b
+0000f130: 625f 706f 7369 7469 6f6e 2e7a 0a20 2020  b_position.z.   
+0000f140: 2020 2020 2020 2020 2029 2c0a 2020 2020           ),.    
+0000f150: 2020 2020 290a 2020 2020 2020 2020 785f      ).        x_
+0000f160: 6c69 6e65 2e70 6c6f 7432 6178 6573 2861  line.plot2axes(a
+0000f170: 782c 2063 6f6c 6f72 3d22 6772 6565 6e22  x, color="green"
+0000f180: 2c20 616c 7068 613d 302e 3529 0a20 2020  , alpha=0.5).   
+0000f190: 2020 2020 2079 5f6c 696e 6520 3d20 4c69       y_line = Li
+0000f1a0: 6e65 280a 2020 2020 2020 2020 2020 2020  ne(.            
+0000f1b0: 506f 696e 7428 0a20 2020 2020 2020 2020  Point(.         
+0000f1c0: 2020 2020 2020 2073 656c 662e 6262 2e6d         self.bb.m
+0000f1d0: 6561 7375 7265 645f 6669 656c 645f 706f  easured_field_po
+0000f1e0: 7369 7469 6f6e 2e78 2c0a 2020 2020 2020  sition.x,.      
+0000f1f0: 2020 2020 2020 2020 2020 2d6c 696d 6974            -limit
+0000f200: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+0000f210: 2020 7365 6c66 2e62 622e 6d65 6173 7572    self.bb.measur
+0000f220: 6564 5f66 6965 6c64 5f70 6f73 6974 696f  ed_field_positio
+0000f230: 6e2e 7a2c 0a20 2020 2020 2020 2020 2020  n.z,.           
+0000f240: 2029 2c0a 2020 2020 2020 2020 2020 2020   ),.            
+0000f250: 506f 696e 7428 0a20 2020 2020 2020 2020  Point(.         
+0000f260: 2020 2020 2020 2073 656c 662e 6262 2e6d         self.bb.m
+0000f270: 6561 7375 7265 645f 6669 656c 645f 706f  easured_field_po
+0000f280: 7369 7469 6f6e 2e78 2c20 6c69 6d69 742c  sition.x, limit,
+0000f290: 2073 656c 662e 6262 2e6d 6561 7375 7265   self.bb.measure
+0000f2a0: 645f 6262 5f70 6f73 6974 696f 6e2e 7a0a  d_bb_position.z.
+0000f2b0: 2020 2020 2020 2020 2020 2020 292c 0a20              ),. 
+0000f2c0: 2020 2020 2020 2029 0a20 2020 2020 2020         ).       
+0000f2d0: 2079 5f6c 696e 652e 706c 6f74 3261 7865   y_line.plot2axe
+0000f2e0: 7328 6178 2c20 636f 6c6f 723d 2267 7265  s(ax, color="gre
+0000f2f0: 656e 222c 2061 6c70 6861 3d30 2e35 290a  en", alpha=0.5).
+0000f300: 2020 2020 2020 2020 7a5f 6c69 6e65 203d          z_line =
+0000f310: 204c 696e 6528 0a20 2020 2020 2020 2020   Line(.         
+0000f320: 2020 2050 6f69 6e74 280a 2020 2020 2020     Point(.      
+0000f330: 2020 2020 2020 2020 2020 7365 6c66 2e62            self.b
+0000f340: 622e 6d65 6173 7572 6564 5f66 6965 6c64  b.measured_field
+0000f350: 5f70 6f73 6974 696f 6e2e 782c 0a20 2020  _position.x,.   
+0000f360: 2020 2020 2020 2020 2020 2020 2073 656c               sel
+0000f370: 662e 6262 2e6d 6561 7375 7265 645f 6669  f.bb.measured_fi
+0000f380: 656c 645f 706f 7369 7469 6f6e 2e79 2c0a  eld_position.y,.
+0000f390: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000f3a0: 2d6c 696d 6974 2c0a 2020 2020 2020 2020  -limit,.        
+0000f3b0: 2020 2020 292c 0a20 2020 2020 2020 2020      ),.         
+0000f3c0: 2020 2050 6f69 6e74 280a 2020 2020 2020     Point(.      
+0000f3d0: 2020 2020 2020 2020 2020 7365 6c66 2e62            self.b
+0000f3e0: 622e 6d65 6173 7572 6564 5f66 6965 6c64  b.measured_field
+0000f3f0: 5f70 6f73 6974 696f 6e2e 782c 0a20 2020  _position.x,.   
+0000f400: 2020 2020 2020 2020 2020 2020 2073 656c               sel
+0000f410: 662e 6262 2e6d 6561 7375 7265 645f 6669  f.bb.measured_fi
+0000f420: 656c 645f 706f 7369 7469 6f6e 2e79 2c0a  eld_position.y,.
+0000f430: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000f440: 6c69 6d69 742c 0a20 2020 2020 2020 2020  limit,.         
+0000f450: 2020 2029 2c0a 2020 2020 2020 2020 290a     ),.        ).
+0000f460: 2020 2020 2020 2020 7a5f 6c69 6e65 2e70          z_line.p
+0000f470: 6c6f 7432 6178 6573 2861 782c 2063 6f6c  lot2axes(ax, col
+0000f480: 6f72 3d22 6772 6565 6e22 2c20 616c 7068  or="green", alph
+0000f490: 613d 302e 352c 206c 6162 656c 3d22 4669  a=0.5, label="Fi
+0000f4a0: 656c 6420 6973 6f63 656e 7465 7220 2878  eld isocenter (x
+0000f4b0: 2c79 2c7a 2922 290a 2020 2020 2020 2020  ,y,z)").        
+0000f4c0: 6966 2070 6c6f 745f 6262 3a0a 2020 2020  if plot_bb:.    
+0000f4d0: 2020 2020 2020 2020 7365 6c66 2e62 622e          self.bb.
+0000f4e0: 706c 6f74 5f6d 6561 7375 7265 6428 6178  plot_measured(ax
+0000f4f0: 2c20 636f 6c6f 723d 2263 7961 6e22 2c20  , color="cyan", 
+0000f500: 616c 7068 613d 302e 3629 0a20 2020 2020  alpha=0.6).     
+0000f510: 2020 2020 2020 2023 2063 7265 6174 6520         # create 
+0000f520: 616e 2065 6d70 7479 2c20 6661 6b65 206c  an empty, fake l
+0000f530: 696e 6520 736f 2077 6520 6361 6e20 6164  ine so we can ad
+0000f540: 6420 6120 6c61 6265 6c20 666f 7220 7468  d a label for th
+0000f550: 6520 6c65 6765 6e64 0a20 2020 2020 2020  e legend.       
+0000f560: 2020 2020 2066 616b 655f 6c69 6e65 203d       fake_line =
+0000f570: 204c 696e 6528 506f 696e 7428 302c 2030   Line(Point(0, 0
+0000f580: 2c20 3029 2c20 506f 696e 7428 302c 2030  , 0), Point(0, 0
+0000f590: 2c20 3029 290a 2020 2020 2020 2020 2020  , 0)).          
+0000f5a0: 2020 6661 6b65 5f6c 696e 652e 706c 6f74    fake_line.plot
+0000f5b0: 3261 7865 7328 6178 2c20 636f 6c6f 723d  2axes(ax, color=
+0000f5c0: 2263 7961 6e22 2c20 6c61 6265 6c3d 6622  "cyan", label=f"
+0000f5d0: 4242 2028 7b73 656c 662e 5f62 625f 6469  BB ({self._bb_di
+0000f5e0: 616d 6574 6572 7d6d 6d29 2229 0a20 2020  ameter}mm)").   
+0000f5f0: 2020 2020 2069 6620 706c 6f74 5f69 736f       if plot_iso
+0000f600: 6365 6e74 6572 5f73 7068 6572 653a 0a20  center_sphere:. 
+0000f610: 2020 2020 2020 2020 2020 2078 2c20 792c             x, y,
+0000f620: 207a 203d 2063 7265 6174 655f 7370 6865   z = create_sphe
+0000f630: 7265 5f73 7572 6661 6365 280a 2020 2020  re_surface(.    
+0000f640: 2020 2020 2020 2020 2020 2020 7261 6469              radi
+0000f650: 7573 3d73 656c 662e 6761 6e74 7279 5f63  us=self.gantry_c
+0000f660: 6f6c 6c5f 6973 6f5f 7369 7a65 202f 2032  oll_iso_size / 2
+0000f670: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+0000f680: 2020 6365 6e74 6572 3d50 6f69 6e74 280a    center=Point(.
+0000f690: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000f6a0: 2020 2020 7365 6c66 2e62 622e 6d65 6173      self.bb.meas
+0000f6b0: 7572 6564 5f62 625f 706f 7369 7469 6f6e  ured_bb_position
+0000f6c0: 2e78 2c0a 2020 2020 2020 2020 2020 2020  .x,.            
+0000f6d0: 2020 2020 2020 2020 7365 6c66 2e62 622e          self.bb.
+0000f6e0: 6d65 6173 7572 6564 5f62 625f 706f 7369  measured_bb_posi
+0000f6f0: 7469 6f6e 2e79 2c0a 2020 2020 2020 2020  tion.y,.        
+0000f700: 2020 2020 2020 2020 2020 2020 7365 6c66              self
+0000f710: 2e62 622e 6d65 6173 7572 6564 5f62 625f  .bb.measured_bb_
+0000f720: 706f 7369 7469 6f6e 2e7a 2c0a 2020 2020  position.z,.    
+0000f730: 2020 2020 2020 2020 2020 2020 292c 0a20              ),. 
+0000f740: 2020 2020 2020 2020 2020 2029 0a20 2020             ).   
+0000f750: 2020 2020 2020 2020 2061 782e 706c 6f74           ax.plot
+0000f760: 5f73 7572 6661 6365 2878 2c20 792c 207a  _surface(x, y, z
+0000f770: 2c20 616c 7068 613d 302e 332c 2063 6f6c  , alpha=0.3, col
+0000f780: 6f72 3d22 6d61 6765 6e74 6122 290a 2020  or="magenta").  
+0000f790: 2020 2020 2020 2020 2020 2320 6372 6561            # crea
+0000f7a0: 7465 2061 6e20 656d 7074 792c 2066 616b  te an empty, fak
+0000f7b0: 6520 6c69 6e65 2073 6f20 7765 2063 616e  e line so we can
+0000f7c0: 2061 6464 2061 206c 6162 656c 2066 6f72   add a label for
+0000f7d0: 2074 6865 206c 6567 656e 640a 2020 2020   the legend.    
+0000f7e0: 2020 2020 2020 2020 6661 6b65 5f6c 696e          fake_lin
+0000f7f0: 6520 3d20 4c69 6e65 2850 6f69 6e74 2830  e = Line(Point(0
+0000f800: 2c20 302c 2030 292c 2050 6f69 6e74 2830  , 0, 0), Point(0
+0000f810: 2c20 302c 2030 2929 0a20 2020 2020 2020  , 0, 0)).       
+0000f820: 2020 2020 2066 616b 655f 6c69 6e65 2e70       fake_line.p
+0000f830: 6c6f 7432 6178 6573 280a 2020 2020 2020  lot2axes(.      
+0000f840: 2020 2020 2020 2020 2020 6178 2c0a 2020            ax,.  
+0000f850: 2020 2020 2020 2020 2020 2020 2020 636f                co
+0000f860: 6c6f 723d 226d 6167 656e 7461 222c 0a20  lor="magenta",. 
+0000f870: 2020 2020 2020 2020 2020 2020 2020 206c                 l
+0000f880: 6162 656c 3d66 2247 616e 7472 7920 2b20  abel=f"Gantry + 
+0000f890: 436f 6c6c 2049 736f 7370 6865 7265 2028  Coll Isosphere (
+0000f8a0: 7b73 656c 662e 6761 6e74 7279 5f63 6f6c  {self.gantry_col
+0000f8b0: 6c5f 6973 6f5f 7369 7a65 3a33 2e32 667d  l_iso_size:3.2f}
+0000f8c0: 6d6d 2922 2c0a 2020 2020 2020 2020 2020  mm)",.          
+0000f8d0: 2020 290a 2020 2020 2020 2020 6966 2070    ).        if p
+0000f8e0: 6c6f 745f 636f 7563 685f 6973 6f3a 0a20  lot_couch_iso:. 
+0000f8f0: 2020 2020 2020 2020 2020 2063 6972 636c             circl
+0000f900: 6520 3d20 706c 742e 4369 7263 6c65 280a  e = plt.Circle(.
+0000f910: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000f920: 2873 656c 662e 6262 2e6d 6561 7375 7265  (self.bb.measure
+0000f930: 645f 6669 656c 645f 706f 7369 7469 6f6e  d_field_position
+0000f940: 2e78 2c20 7365 6c66 2e62 622e 6d65 6173  .x, self.bb.meas
+0000f950: 7572 6564 5f66 6965 6c64 5f70 6f73 6974  ured_field_posit
+0000f960: 696f 6e2e 7929 2c0a 2020 2020 2020 2020  ion.y),.        
+0000f970: 2020 2020 2020 2020 7261 6469 7573 3d73          radius=s
+0000f980: 656c 662e 636f 7563 685f 6973 6f5f 7369  elf.couch_iso_si
+0000f990: 7a65 202f 2032 2c0a 2020 2020 2020 2020  ze / 2,.        
+0000f9a0: 2020 2020 2020 2020 6669 6c6c 3d54 7275          fill=Tru
+0000f9b0: 652c 0a20 2020 2020 2020 2020 2020 2020  e,.             
+0000f9c0: 2020 2063 6f6c 6f72 3d22 7965 6c6c 6f77     color="yellow
+0000f9d0: 222c 0a20 2020 2020 2020 2020 2020 2020  ",.             
+0000f9e0: 2020 2061 6c70 6861 3d30 2e34 2c0a 2020     alpha=0.4,.  
+0000f9f0: 2020 2020 2020 2020 2020 2020 2020 6c61                la
+0000fa00: 6265 6c3d 6622 436f 7563 682d 6f6e 6c79  bel=f"Couch-only
+0000fa10: 2069 736f 2028 7b73 656c 662e 636f 7563   iso ({self.couc
+0000fa20: 685f 6973 6f5f 7369 7a65 3a33 2e32 667d  h_iso_size:3.2f}
+0000fa30: 6d6d 2922 2c0a 2020 2020 2020 2020 2020  mm)",.          
+0000fa40: 2020 290a 2020 2020 2020 2020 2020 2020    ).            
+0000fa50: 6178 2e61 6464 5f70 6174 6368 2863 6972  ax.add_patch(cir
+0000fa60: 636c 6529 0a20 2020 2020 2020 2020 2020  cle).           
+0000fa70: 2061 7274 3364 2e70 6174 6870 6174 6368   art3d.pathpatch
+0000fa80: 5f32 645f 746f 5f33 6428 0a20 2020 2020  _2d_to_3d(.     
+0000fa90: 2020 2020 2020 2020 2020 2063 6972 636c             circl
+0000faa0: 652c 207a 3d73 656c 662e 6262 2e6d 6561  e, z=self.bb.mea
+0000fab0: 7375 7265 645f 6669 656c 645f 706f 7369  sured_field_posi
+0000fac0: 7469 6f6e 2e7a 2c20 7a64 6972 3d22 7a22  tion.z, zdir="z"
+0000fad0: 0a20 2020 2020 2020 2020 2020 2029 0a20  .            ). 
+0000fae0: 2020 2020 2020 2069 6620 706c 6f74 5f63         if plot_c
+0000faf0: 6f6c 6c5f 6973 6f3a 0a20 2020 2020 2020  oll_iso:.       
+0000fb00: 2020 2020 2063 6972 636c 6520 3d20 706c       circle = pl
+0000fb10: 742e 4369 7263 6c65 280a 2020 2020 2020  t.Circle(.      
+0000fb20: 2020 2020 2020 2020 2020 2873 656c 662e            (self.
+0000fb30: 6262 2e6d 6561 7375 7265 645f 6669 656c  bb.measured_fiel
+0000fb40: 645f 706f 7369 7469 6f6e 2e79 2c20 7365  d_position.y, se
+0000fb50: 6c66 2e62 622e 6d65 6173 7572 6564 5f66  lf.bb.measured_f
+0000fb60: 6965 6c64 5f70 6f73 6974 696f 6e2e 7a29  ield_position.z)
+0000fb70: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+0000fb80: 2020 7261 6469 7573 3d73 656c 662e 636f    radius=self.co
+0000fb90: 6c6c 696d 6174 6f72 5f69 736f 5f73 697a  llimator_iso_siz
+0000fba0: 6520 2f20 322c 0a20 2020 2020 2020 2020  e / 2,.         
+0000fbb0: 2020 2020 2020 2066 696c 6c3d 5472 7565         fill=True
+0000fbc0: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+0000fbd0: 2020 636f 6c6f 723d 2262 6c75 6522 2c0a    color="blue",.
+0000fbe0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000fbf0: 616c 7068 613d 302e 342c 0a20 2020 2020  alpha=0.4,.     
+0000fc00: 2020 2020 2020 2020 2020 206c 6162 656c             label
+0000fc10: 3d66 2243 6f6c 6c69 6d61 746f 722d 6f6e  =f"Collimator-on
+0000fc20: 6c79 2069 736f 2028 7b73 656c 662e 636f  ly iso ({self.co
+0000fc30: 6c6c 696d 6174 6f72 5f69 736f 5f73 697a  llimator_iso_siz
+0000fc40: 653a 332e 3266 7d6d 6d29 222c 0a20 2020  e:3.2f}mm)",.   
+0000fc50: 2020 2020 2020 2020 2029 0a20 2020 2020           ).     
+0000fc60: 2020 2020 2020 2061 782e 6164 645f 7061         ax.add_pa
+0000fc70: 7463 6828 6369 7263 6c65 290a 2020 2020  tch(circle).    
+0000fc80: 2020 2020 2020 2020 6172 7433 642e 7061          art3d.pa
+0000fc90: 7468 7061 7463 685f 3264 5f74 6f5f 3364  thpatch_2d_to_3d
+0000fca0: 280a 2020 2020 2020 2020 2020 2020 2020  (.              
+0000fcb0: 2020 6369 7263 6c65 2c20 7a3d 7365 6c66    circle, z=self
+0000fcc0: 2e62 622e 6d65 6173 7572 6564 5f66 6965  .bb.measured_fie
+0000fcd0: 6c64 5f70 6f73 6974 696f 6e2e 782c 207a  ld_position.x, z
+0000fce0: 6469 723d 2278 220a 2020 2020 2020 2020  dir="x".        
+0000fcf0: 2020 2020 290a 2020 2020 2020 2020 6966      ).        if
+0000fd00: 2073 686f 775f 6c65 6765 6e64 3a0a 2020   show_legend:.  
+0000fd10: 2020 2020 2020 2020 2020 6178 2e6c 6567            ax.leg
+0000fd20: 656e 6428 290a 2020 2020 2020 2020 2320  end().        # 
+0000fd30: 7365 7420 7468 6520 6c69 6d69 7473 206f  set the limits o
+0000fd40: 6620 7468 6520 3344 2070 6c6f 743b 2074  f the 3D plot; t
+0000fd50: 6865 7920 6d75 7374 2062 6520 7468 6520  hey must be the 
+0000fd60: 7361 6d65 2069 6e20 616c 6c20 6178 6573  same in all axes
+0000fd70: 2066 6f72 2065 7175 616c 2061 7370 6563   for equal aspec
+0000fd80: 7420 7261 7469 6f0a 2020 2020 2020 2020  t ratio.        
+0000fd90: 6178 2e73 6574 280a 2020 2020 2020 2020  ax.set(.        
+0000fda0: 2020 2020 786c 6162 656c 3d22 5820 286d      xlabel="X (m
+0000fdb0: 6d29 2c20 5269 6768 7420 282b 2922 2c0a  m), Right (+)",.
+0000fdc0: 2020 2020 2020 2020 2020 2020 796c 6162              ylab
+0000fdd0: 656c 3d22 5920 286d 6d29 2c20 496e 2028  el="Y (mm), In (
+0000fde0: 2b29 222c 0a20 2020 2020 2020 2020 2020  +)",.           
+0000fdf0: 207a 6c61 6265 6c3d 225a 2028 6d6d 292c   zlabel="Z (mm),
+0000fe00: 2055 7020 282b 2922 2c0a 2020 2020 2020   Up (+)",.      
+0000fe10: 2020 2020 2020 7469 746c 653d 2249 736f        title="Iso
+0000fe20: 6365 6e74 6572 2056 6973 7561 6c69 7a61  center Visualiza
+0000fe30: 7469 6f6e 222c 0a20 2020 2020 2020 2020  tion",.         
+0000fe40: 2020 2079 6c69 6d3d 5b2d 6c69 6d69 742c     ylim=[-limit,
+0000fe50: 206c 696d 6974 5d2c 0a20 2020 2020 2020   limit],.       
+0000fe60: 2020 2020 2078 6c69 6d3d 5b2d 6c69 6d69       xlim=[-limi
+0000fe70: 742c 206c 696d 6974 5d2c 0a20 2020 2020  t, limit],.     
+0000fe80: 2020 2020 2020 207a 6c69 6d3d 5b2d 6c69         zlim=[-li
+0000fe90: 6d69 742c 206c 696d 6974 5d2c 0a20 2020  mit, limit],.   
+0000fea0: 2020 2020 2029 0a0a 2020 2020 2020 2020       )..        
+0000feb0: 6966 2073 686f 773a 0a20 2020 2020 2020  if show:.       
+0000fec0: 2020 2020 2070 6c74 2e73 686f 7728 290a       plt.show().
+0000fed0: 0a20 2020 2064 6566 2070 6c6f 745f 696d  .    def plot_im
+0000fee0: 6167 6573 280a 2020 2020 2020 2020 7365  ages(.        se
+0000fef0: 6c66 2c0a 2020 2020 2020 2020 6178 6973  lf,.        axis
+0000ff00: 3a20 4178 6973 203d 2041 7869 732e 4741  : Axis = Axis.GA
+0000ff10: 4e54 5259 2c0a 2020 2020 2020 2020 7368  NTRY,.        sh
+0000ff20: 6f77 3a20 626f 6f6c 203d 2054 7275 652c  ow: bool = True,
+0000ff30: 0a20 2020 2020 2020 207a 6f6f 6d3a 2062  .        zoom: b
+0000ff40: 6f6f 6c20 3d20 5472 7565 2c0a 2020 2020  ool = True,.    
+0000ff50: 2020 2020 6c65 6765 6e64 3a20 626f 6f6c      legend: bool
+0000ff60: 203d 2054 7275 652c 0a20 2020 2020 2020   = True,.       
+0000ff70: 2073 706c 6974 3a20 626f 6f6c 203d 2046   split: bool = F
+0000ff80: 616c 7365 2c0a 2020 2020 2020 2020 2a2a  alse,.        **
+0000ff90: 6b77 6172 6773 2c0a 2020 2020 2920 2d3e  kwargs,.    ) ->
+0000ffa0: 2028 6c69 7374 5b70 6c74 2e46 6967 7572   (list[plt.Figur
+0000ffb0: 655d 2c20 6c69 7374 5b73 7472 5d29 3a0a  e], list[str]):.
+0000ffc0: 2020 2020 2020 2020 2222 2250 6c6f 7420          """Plot 
+0000ffd0: 6120 6772 6964 206f 6620 616c 6c20 7468  a grid of all th
+0000ffe0: 6520 696d 6167 6573 2061 6371 7569 7265  e images acquire
+0000fff0: 642e 0a0a 2020 2020 2020 2020 466f 7572  d...        Four
+00010000: 2063 6f6c 756d 6e73 2061 7265 2070 6c6f   columns are plo
+00010010: 7474 6564 2077 6974 6820 7468 6520 7469  tted with the ti
+00010020: 746c 6573 2073 686f 7769 6e67 2077 6869  tles showing whi
+00010030: 6368 2061 7869 7320 7468 6174 2063 6f6c  ch axis that col
+00010040: 756d 6e20 7265 7072 6573 656e 7473 2e0a  umn represents..
+00010050: 0a20 2020 2020 2020 2050 6172 616d 6574  .        Paramet
+00010060: 6572 730a 2020 2020 2020 2020 2d2d 2d2d  ers.        ----
+00010070: 2d2d 2d2d 2d2d 0a20 2020 2020 2020 2061  ------.        a
+00010080: 7869 7320 3a20 7b27 4761 6e74 7279 272c  xis : {'Gantry',
+00010090: 2027 436f 6c6c 696d 6174 6f72 272c 2027   'Collimator', '
+000100a0: 436f 7563 6827 2c20 2747 4220 436f 6d62  Couch', 'GB Comb
+000100b0: 6f27 2c20 2747 4250 2043 6f6d 626f 272c  o', 'GBP Combo',
+000100c0: 2027 416c 6c27 7d0a 2020 2020 2020 2020   'All'}.        
+000100d0: 2020 2020 5468 6520 6178 6973 2074 6f20      The axis to 
+000100e0: 706c 6f74 2e0a 2020 2020 2020 2020 7368  plot..        sh
+000100f0: 6f77 203a 2062 6f6f 6c0a 2020 2020 2020  ow : bool.      
+00010100: 2020 2020 2020 5768 6574 6865 7220 746f        Whether to
+00010110: 2073 686f 7720 7468 6520 696d 6167 652e   show the image.
+00010120: 0a20 2020 2020 2020 207a 6f6f 6d20 3a20  .        zoom : 
+00010130: 626f 6f6c 0a20 2020 2020 2020 2020 2020  bool.           
+00010140: 2057 6865 7468 6572 2074 6f20 7a6f 6f6d   Whether to zoom
+00010150: 2069 6e20 6172 6f75 6e64 2074 6865 2042   in around the B
+00010160: 422e 0a20 2020 2020 2020 206c 6567 656e  B..        legen
+00010170: 6420 3a20 626f 6f6c 0a20 2020 2020 2020  d : bool.       
+00010180: 2020 2020 2057 6865 7468 6572 2074 6f20       Whether to 
+00010190: 7368 6f77 2074 6865 206c 6567 656e 642e  show the legend.
+000101a0: 0a20 2020 2020 2020 2073 706c 6974 203a  .        split :
+000101b0: 2062 6f6f 6c0a 2020 2020 2020 2020 2020   bool.          
+000101c0: 2020 5768 6574 6865 7220 746f 2073 686f    Whether to sho
+000101d0: 772f 706c 6f74 2074 6865 2069 6d61 6765  w/plot the image
+000101e0: 7320 696e 6469 7669 6475 616c 6c79 206f  s individually o
+000101f0: 7220 6173 206f 6e65 206c 6172 6765 2066  r as one large f
+00010200: 6967 7572 652e 0a20 2020 2020 2020 2022  igure..        "
+00010210: 2222 0a20 2020 2020 2020 2061 7869 7320  "".        axis 
+00010220: 3d20 636f 6e76 6572 745f 746f 5f65 6e75  = convert_to_enu
+00010230: 6d28 6178 6973 2c20 4178 6973 290a 2020  m(axis, Axis).  
+00010240: 2020 2020 2020 6966 206e 6f74 2073 656c        if not sel
+00010250: 662e 5f69 735f 616e 616c 797a 6564 3a0a  f._is_analyzed:.
+00010260: 2020 2020 2020 2020 2020 2020 7261 6973              rais
+00010270: 6520 5661 6c75 6545 7272 6f72 2822 5468  e ValueError("Th
+00010280: 6520 7365 7420 6973 206e 6f74 2061 6e61  e set is not ana
+00010290: 6c79 7a65 642e 2055 7365 202e 616e 616c  lyzed. Use .anal
+000102a0: 797a 6528 2920 6669 7273 742e 2229 0a0a  yze() first.")..
+000102b0: 2020 2020 2020 2020 2320 6765 7420 6178          # get ax
+000102c0: 6973 2069 6d61 6765 730a 2020 2020 2020  is images.      
+000102d0: 2020 6966 2061 7869 7320 3d3d 2041 7869    if axis == Axi
+000102e0: 732e 4741 4e54 5259 3a0a 2020 2020 2020  s.GANTRY:.      
+000102f0: 2020 2020 2020 696d 6167 6573 203d 205b        images = [
+00010300: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00010310: 2069 6d61 6765 0a20 2020 2020 2020 2020   image.         
+00010320: 2020 2020 2020 2066 6f72 2069 6d61 6765         for image
+00010330: 2069 6e20 7365 6c66 2e69 6d61 6765 730a   in self.images.
+00010340: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00010350: 6966 2069 6d61 6765 2e76 6172 6961 626c  if image.variabl
+00010360: 655f 6178 6973 2069 6e20 2841 7869 732e  e_axis in (Axis.
+00010370: 4741 4e54 5259 2c20 4178 6973 2e52 4546  GANTRY, Axis.REF
+00010380: 4552 454e 4345 290a 2020 2020 2020 2020  ERENCE).        
+00010390: 2020 2020 5d0a 2020 2020 2020 2020 656c      ].        el
+000103a0: 6966 2061 7869 7320 3d3d 2041 7869 732e  if axis == Axis.
+000103b0: 434f 4c4c 494d 4154 4f52 3a0a 2020 2020  COLLIMATOR:.    
+000103c0: 2020 2020 2020 2020 696d 6167 6573 203d          images =
+000103d0: 205b 0a20 2020 2020 2020 2020 2020 2020   [.             
+000103e0: 2020 2069 6d61 6765 0a20 2020 2020 2020     image.       
+000103f0: 2020 2020 2020 2020 2066 6f72 2069 6d61           for ima
+00010400: 6765 2069 6e20 7365 6c66 2e69 6d61 6765  ge in self.image
+00010410: 730a 2020 2020 2020 2020 2020 2020 2020  s.              
+00010420: 2020 6966 2069 6d61 6765 2e76 6172 6961    if image.varia
+00010430: 626c 655f 6178 6973 2069 6e20 2841 7869  ble_axis in (Axi
+00010440: 732e 434f 4c4c 494d 4154 4f52 2c20 4178  s.COLLIMATOR, Ax
+00010450: 6973 2e52 4546 4552 454e 4345 290a 2020  is.REFERENCE).  
+00010460: 2020 2020 2020 2020 2020 5d0a 2020 2020            ].    
+00010470: 2020 2020 656c 6966 2061 7869 7320 3d3d      elif axis ==
+00010480: 2041 7869 732e 434f 5543 483a 0a20 2020   Axis.COUCH:.   
+00010490: 2020 2020 2020 2020 2069 6d61 6765 7320           images 
+000104a0: 3d20 5b0a 2020 2020 2020 2020 2020 2020  = [.            
+000104b0: 2020 2020 696d 6167 650a 2020 2020 2020      image.      
+000104c0: 2020 2020 2020 2020 2020 666f 7220 696d            for im
+000104d0: 6167 6520 696e 2073 656c 662e 696d 6167  age in self.imag
+000104e0: 6573 0a20 2020 2020 2020 2020 2020 2020  es.             
+000104f0: 2020 2069 6620 696d 6167 652e 7661 7269     if image.vari
+00010500: 6162 6c65 5f61 7869 7320 696e 2028 4178  able_axis in (Ax
+00010510: 6973 2e43 4f55 4348 2c20 4178 6973 2e52  is.COUCH, Axis.R
+00010520: 4546 4552 454e 4345 290a 2020 2020 2020  EFERENCE).      
+00010530: 2020 2020 2020 5d0a 2020 2020 2020 2020        ].        
+00010540: 656c 6966 2061 7869 7320 3d3d 2041 7869  elif axis == Axi
+00010550: 732e 4742 5f43 4f4d 424f 3a0a 2020 2020  s.GB_COMBO:.    
+00010560: 2020 2020 2020 2020 696d 6167 6573 203d          images =
+00010570: 205b 0a20 2020 2020 2020 2020 2020 2020   [.             
+00010580: 2020 2069 6d61 6765 0a20 2020 2020 2020     image.       
+00010590: 2020 2020 2020 2020 2066 6f72 2069 6d61           for ima
+000105a0: 6765 2069 6e20 7365 6c66 2e69 6d61 6765  ge in self.image
+000105b0: 730a 2020 2020 2020 2020 2020 2020 2020  s.              
+000105c0: 2020 6966 2069 6d61 6765 2e76 6172 6961    if image.varia
+000105d0: 626c 655f 6178 6973 0a20 2020 2020 2020  ble_axis.       
+000105e0: 2020 2020 2020 2020 2069 6e20 2841 7869           in (Axi
+000105f0: 732e 4742 5f43 4f4d 424f 2c20 4178 6973  s.GB_COMBO, Axis
+00010600: 2e47 414e 5452 592c 2041 7869 732e 434f  .GANTRY, Axis.CO
+00010610: 4c4c 494d 4154 4f52 2c20 4178 6973 2e52  LLIMATOR, Axis.R
+00010620: 4546 4552 454e 4345 290a 2020 2020 2020  EFERENCE).      
+00010630: 2020 2020 2020 5d0a 2020 2020 2020 2020        ].        
+00010640: 656c 6966 2061 7869 7320 3d3d 2041 7869  elif axis == Axi
+00010650: 732e 4742 505f 434f 4d42 4f3a 0a20 2020  s.GBP_COMBO:.   
+00010660: 2020 2020 2020 2020 2069 6d61 6765 7320           images 
+00010670: 3d20 7365 6c66 2e69 6d61 6765 730a 0a20  = self.images.. 
+00010680: 2020 2020 2020 2023 2073 6574 2074 6865         # set the
+00010690: 2066 6967 7369 7a65 2069 6620 6974 2077   figsize if it w
+000106a0: 6173 6e27 7420 7061 7373 6564 0a20 2020  asn't passed.   
+000106b0: 2020 2020 2069 6620 6e6f 7420 6b77 6172       if not kwar
+000106c0: 6773 2e67 6574 2822 6669 6773 697a 6522  gs.get("figsize"
+000106d0: 293a 0a20 2020 2020 2020 2020 2020 2064  ):.            d
+000106e0: 7069 203d 2037 320a 2020 2020 2020 2020  pi = 72.        
+000106f0: 2020 2020 7769 6474 685f 7078 203d 2031      width_px = 1
+00010700: 3038 300a 2020 2020 2020 2020 2020 2020  080.            
+00010710: 7769 6474 685f 696e 203d 2077 6964 7468  width_in = width
+00010720: 5f70 7820 2f20 6470 690a 2020 2020 2020  _px / dpi.      
+00010730: 2020 2020 2020 6966 206e 6f74 2073 706c        if not spl
+00010740: 6974 3a0a 2020 2020 2020 2020 2020 2020  it:.            
+00010750: 2020 2020 6d61 785f 6e75 6d5f 696d 6167      max_num_imag
+00010760: 6573 203d 206d 6174 682e 6365 696c 286c  es = math.ceil(l
+00010770: 656e 2869 6d61 6765 7329 202f 2034 290a  en(images) / 4).
+00010780: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00010790: 6865 6967 6874 5f69 6e20 3d20 2877 6964  height_in = (wid
+000107a0: 7468 5f69 6e20 2f20 3429 202a 206d 6178  th_in / 4) * max
+000107b0: 5f6e 756d 5f69 6d61 6765 730a 2020 2020  _num_images.    
+000107c0: 2020 2020 2020 2020 656c 7365 3a0a 2020          else:.  
+000107d0: 2020 2020 2020 2020 2020 2020 2020 6865                he
+000107e0: 6967 6874 5f69 6e20 3d20 7769 6474 685f  ight_in = width_
+000107f0: 696e 203d 2033 0a20 2020 2020 2020 2020  in = 3.         
+00010800: 2020 206b 7761 7267 735b 2266 6967 7369     kwargs["figsi
+00010810: 7a65 225d 203d 2028 7769 6474 685f 696e  ze"] = (width_in
+00010820: 2c20 6865 6967 6874 5f69 6e29 0a0a 2020  , height_in)..  
+00010830: 2020 2020 2020 6669 6773 203d 205b 5d0a        figs = [].
+00010840: 2020 2020 2020 2020 6e61 6d65 7320 3d20          names = 
+00010850: 5b5d 0a20 2020 2020 2020 2023 2063 7265  [].        # cre
+00010860: 6174 6520 706c 6f74 730a 2020 2020 2020  ate plots.      
+00010870: 2020 6966 206e 6f74 2073 706c 6974 3a0a    if not split:.
+00010880: 2020 2020 2020 2020 2020 2020 6669 672c              fig,
+00010890: 2061 7865 7320 3d20 706c 742e 7375 6270   axes = plt.subp
+000108a0: 6c6f 7473 286e 726f 7773 3d6d 6178 5f6e  lots(nrows=max_n
+000108b0: 756d 5f69 6d61 6765 732c 206e 636f 6c73  um_images, ncols
+000108c0: 3d34 2c20 2a2a 6b77 6172 6773 290a 2020  =4, **kwargs).  
+000108d0: 2020 2020 2020 2020 2020 666f 7220 6d70            for mp
+000108e0: 6c5f 6178 6973 2c20 776c 5f69 6d61 6765  l_axis, wl_image
+000108f0: 2069 6e20 7a69 705f 6c6f 6e67 6573 7428   in zip_longest(
+00010900: 6178 6573 2e66 6c61 7474 656e 2829 2c20  axes.flatten(), 
+00010910: 696d 6167 6573 293a 0a20 2020 2020 2020  images):.       
+00010920: 2020 2020 2020 2020 2023 2070 6c6f 7420           # plot 
+00010930: 7468 6520 696d 6167 6573 2061 6e64 2074  the images and t
+00010940: 7572 6e20 6f66 6620 6578 7472 6120 6178  urn off extra ax
+00010950: 6573 0a20 2020 2020 2020 2020 2020 2020  es.             
+00010960: 2020 2069 6620 776c 5f69 6d61 6765 3a0a     if wl_image:.
+00010970: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00010980: 2020 2020 776c 5f69 6d61 6765 2e70 6c6f      wl_image.plo
+00010990: 7428 6178 3d6d 706c 5f61 7869 732c 2073  t(ax=mpl_axis, s
+000109a0: 686f 773d 4661 6c73 652c 207a 6f6f 6d3d  how=False, zoom=
+000109b0: 7a6f 6f6d 2c20 6c65 6765 6e64 3d6c 6567  zoom, legend=leg
+000109c0: 656e 6429 0a20 2020 2020 2020 2020 2020  end).           
+000109d0: 2020 2020 2065 6c73 653a 0a20 2020 2020       else:.     
+000109e0: 2020 2020 2020 2020 2020 2020 2020 206d                 m
+000109f0: 706c 5f61 7869 732e 7365 745f 6672 616d  pl_axis.set_fram
+00010a00: 655f 6f6e 2846 616c 7365 290a 2020 2020  e_on(False).    
+00010a10: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00010a20: 6d70 6c5f 6178 6973 2e61 7869 7328 226f  mpl_axis.axis("o
+00010a30: 6666 2229 0a0a 2020 2020 2020 2020 2020  ff")..          
+00010a40: 2020 2320 7365 7420 7469 746c 6573 0a20    # set titles. 
+00010a50: 2020 2020 2020 2020 2020 2066 6967 2e73             fig.s
+00010a60: 7570 7469 746c 6528 6622 7b61 7869 732e  uptitle(f"{axis.
+00010a70: 7661 6c75 657d 2069 6d61 6765 7322 2c20  value} images", 
+00010a80: 666f 6e74 7369 7a65 3d31 342c 2079 3d31  fontsize=14, y=1
+00010a90: 290a 2020 2020 2020 2020 2020 2020 6669  ).            fi
+00010aa0: 672e 7469 6768 745f 6c61 796f 7574 2829  g.tight_layout()
+00010ab0: 0a20 2020 2020 2020 2020 2020 2066 6967  .            fig
+00010ac0: 732e 6170 7065 6e64 2866 6967 290a 2020  s.append(fig).  
+00010ad0: 2020 2020 2020 2020 2020 6e61 6d65 732e            names.
+00010ae0: 6170 7065 6e64 2822 696d 6167 6522 290a  append("image").
+00010af0: 2020 2020 2020 2020 656c 7365 3a0a 2020          else:.  
+00010b00: 2020 2020 2020 2020 2020 666f 7220 776c            for wl
+00010b10: 5f69 6d61 6765 2069 6e20 696d 6167 6573  _image in images
+00010b20: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+00010b30: 2020 6669 672c 2061 7865 7320 3d20 706c    fig, axes = pl
+00010b40: 742e 7375 6270 6c6f 7473 282a 2a6b 7761  t.subplots(**kwa
+00010b50: 7267 7329 0a20 2020 2020 2020 2020 2020  rgs).           
+00010b60: 2020 2020 2077 6c5f 696d 6167 652e 706c       wl_image.pl
+00010b70: 6f74 2861 783d 6178 6573 2c20 7368 6f77  ot(ax=axes, show
+00010b80: 3d46 616c 7365 2c20 7a6f 6f6d 3d7a 6f6f  =False, zoom=zoo
+00010b90: 6d2c 206c 6567 656e 643d 6c65 6765 6e64  m, legend=legend
+00010ba0: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
+00010bb0: 2020 2320 706c 6f74 5f69 6d61 6765 2877    # plot_image(w
+00010bc0: 6c5f 696d 6167 652c 2061 7865 7329 0a20  l_image, axes). 
+00010bd0: 2020 2020 2020 2020 2020 2020 2020 2066                 f
+00010be0: 6967 732e 6170 7065 6e64 2866 6967 290a  igs.append(fig).
+00010bf0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00010c00: 6e61 6d65 732e 6170 7065 6e64 2873 7472  names.append(str
+00010c10: 2877 6c5f 696d 6167 6529 290a 0a20 2020  (wl_image))..   
+00010c20: 2020 2020 2069 6620 7368 6f77 3a0a 2020       if show:.  
+00010c30: 2020 2020 2020 2020 2020 706c 742e 7368            plt.sh
+00010c40: 6f77 2829 0a0a 2020 2020 2020 2020 7265  ow()..        re
+00010c50: 7475 726e 2066 6967 732c 206e 616d 6573  turn figs, names
+00010c60: 0a0a 2020 2020 6465 6620 7361 7665 5f69  ..    def save_i
+00010c70: 6d61 6765 7328 0a20 2020 2020 2020 2073  mages(.        s
+00010c80: 656c 662c 2066 696c 656e 616d 653a 2073  elf, filename: s
+00010c90: 7472 207c 2042 696e 6172 7949 4f2c 2061  tr | BinaryIO, a
+00010ca0: 7869 733a 2041 7869 7320 3d20 4178 6973  xis: Axis = Axis
+00010cb0: 2e47 414e 5452 592c 202a 2a6b 7761 7267  .GANTRY, **kwarg
+00010cc0: 730a 2020 2020 2920 2d3e 204e 6f6e 653a  s.    ) -> None:
+00010cd0: 0a20 2020 2020 2020 2022 2222 5361 7665  .        """Save
+00010ce0: 2074 6865 2066 6967 7572 6520 6f66 2060   the figure of `
+00010cf0: 706c 6f74 5f69 6d61 6765 7328 2960 2074  plot_images()` t
+00010d00: 6f20 6669 6c65 2e20 4b65 7977 6f72 6420  o file. Keyword 
+00010d10: 6172 6775 6d65 6e74 7320 6172 6520 7061  arguments are pa
+00010d20: 7373 6564 2074 6f20 606d 6174 706c 6f74  ssed to `matplot
+00010d30: 6c69 622e 7079 706c 6f74 2e73 6176 6566  lib.pyplot.savef
+00010d40: 6967 2829 602e 0a0a 2020 2020 2020 2020  ig()`...        
+00010d50: 5061 7261 6d65 7465 7273 0a20 2020 2020  Parameters.     
+00010d60: 2020 202d 2d2d 2d2d 2d2d 2d2d 2d0a 2020     ----------.  
+00010d70: 2020 2020 2020 6669 6c65 6e61 6d65 203a        filename :
+00010d80: 2073 7472 0a20 2020 2020 2020 2020 2020   str.           
+00010d90: 2054 6865 206e 616d 6520 6f66 2074 6865   The name of the
+00010da0: 2066 696c 6520 746f 2073 6176 6520 746f   file to save to
+00010db0: 2e0a 2020 2020 2020 2020 6178 6973 0a20  ..        axis. 
+00010dc0: 2020 2020 2020 2020 2020 2054 6865 2061             The a
+00010dd0: 7869 7320 746f 2073 6176 652e 0a20 2020  xis to save..   
+00010de0: 2020 2020 2022 2222 0a20 2020 2020 2020       """.       
+00010df0: 2073 656c 662e 706c 6f74 5f69 6d61 6765   self.plot_image
+00010e00: 7328 6178 6973 3d61 7869 732c 2073 686f  s(axis=axis, sho
+00010e10: 773d 4661 6c73 6529 0a20 2020 2020 2020  w=False).       
+00010e20: 2070 6c74 2e73 6176 6566 6967 2866 696c   plt.savefig(fil
+00010e30: 656e 616d 652c 202a 2a6b 7761 7267 7329  ename, **kwargs)
+00010e40: 0a0a 2020 2020 6465 6620 7361 7665 5f69  ..    def save_i
+00010e50: 6d61 6765 735f 746f 5f73 7472 6561 6d28  mages_to_stream(
+00010e60: 7365 6c66 2c20 2a2a 6b77 6172 6773 2920  self, **kwargs) 
+00010e70: 2d3e 2064 6963 745b 7374 722c 2069 6f2e  -> dict[str, io.
+00010e80: 4279 7465 7349 4f5d 3a0a 2020 2020 2020  BytesIO]:.      
+00010e90: 2020 2222 2253 6176 6520 7468 6520 696e    """Save the in
+00010ea0: 6469 7669 6475 616c 2069 6d61 6765 2070  dividual image p
+00010eb0: 6c6f 7473 2074 6f20 7374 7265 616d 2222  lots to stream""
+00010ec0: 220a 2020 2020 2020 2020 6669 6773 2c20  ".        figs, 
+00010ed0: 6e61 6d65 7320 3d20 7365 6c66 2e70 6c6f  names = self.plo
+00010ee0: 745f 696d 6167 6573 280a 2020 2020 2020  t_images(.      
+00010ef0: 2020 2020 2020 6178 6973 3d41 7869 732e        axis=Axis.
+00010f00: 4742 505f 434f 4d42 4f2c 2073 686f 773d  GBP_COMBO, show=
+00010f10: 4661 6c73 652c 2073 706c 6974 3d54 7275  False, split=Tru
+00010f20: 650a 2020 2020 2020 2020 2920 2023 2061  e.        )  # a
+00010f30: 6c6c 2069 6d61 6765 730a 2020 2020 2020  ll images.      
+00010f40: 2020 7374 7265 616d 7320 3d20 5b69 6f2e    streams = [io.
+00010f50: 4279 7465 7349 4f28 2920 666f 7220 5f20  BytesIO() for _ 
+00010f60: 696e 2066 6967 735d 0a20 2020 2020 2020  in figs].       
+00010f70: 2066 6f72 2066 6967 2c20 7374 7265 616d   for fig, stream
+00010f80: 2069 6e20 7a69 7028 6669 6773 2c20 7374   in zip(figs, st
+00010f90: 7265 616d 7329 3a0a 2020 2020 2020 2020  reams):.        
+00010fa0: 2020 2020 6669 672e 7361 7665 6669 6728      fig.savefig(
+00010fb0: 7374 7265 616d 2c20 2a2a 6b77 6172 6773  stream, **kwargs
+00010fc0: 290a 2020 2020 2020 2020 7265 7475 726e  ).        return
+00010fd0: 207b 6e61 6d65 3a20 7374 7265 616d 2066   {name: stream f
+00010fe0: 6f72 206e 616d 652c 2073 7472 6561 6d20  or name, stream 
+00010ff0: 696e 207a 6970 286e 616d 6573 2c20 7374  in zip(names, st
+00011000: 7265 616d 7329 7d0a 0a20 2020 2064 6566  reams)}..    def
+00011010: 2070 6c6f 745f 7375 6d6d 6172 7928 7365   plot_summary(se
+00011020: 6c66 2c20 7368 6f77 3a20 626f 6f6c 203d  lf, show: bool =
+00011030: 2054 7275 652c 2066 6967 5f73 697a 653a   True, fig_size:
+00011040: 2074 7570 6c65 207c 204e 6f6e 6520 3d20   tuple | None = 
+00011050: 4e6f 6e65 2920 2d3e 204e 6f6e 653a 0a20  None) -> None:. 
+00011060: 2020 2020 2020 2022 2222 506c 6f74 2061         """Plot a
+00011070: 2073 756d 6d61 7279 2066 6967 7572 6520   summary figure 
+00011080: 7368 6f77 696e 6720 7468 6520 6761 6e74  showing the gant
+00011090: 7279 2073 6167 2061 6e64 2077 6f62 626c  ry sag and wobbl
+000110a0: 6520 706c 6f74 7320 6f66 2074 6865 2074  e plots of the t
+000110b0: 6872 6565 2061 7865 732e 2222 220a 2020  hree axes.""".  
+000110c0: 2020 2020 2020 6966 206e 6f74 2073 656c        if not sel
+000110d0: 662e 5f69 735f 616e 616c 797a 6564 3a0a  f._is_analyzed:.
+000110e0: 2020 2020 2020 2020 2020 2020 7261 6973              rais
+000110f0: 6520 5661 6c75 6545 7272 6f72 2822 5468  e ValueError("Th
+00011100: 6520 7365 7420 6973 206e 6f74 2061 6e61  e set is not ana
+00011110: 6c79 7a65 642e 2055 7365 202e 616e 616c  lyzed. Use .anal
+00011120: 797a 6528 2920 6669 7273 742e 2229 0a20  yze() first."). 
+00011130: 2020 2020 2020 2066 6967 7369 7a65 203d         figsize =
+00011140: 2028 3131 2c20 3929 2069 6620 6669 675f   (11, 9) if fig_
+00011150: 7369 7a65 2069 7320 4e6f 6e65 2065 6c73  size is None els
+00011160: 6520 6669 675f 7369 7a65 0a20 2020 2020  e fig_size.     
+00011170: 2020 2070 6c74 2e66 6967 7572 6528 6669     plt.figure(fi
+00011180: 6773 697a 653d 6669 6773 697a 6529 0a20  gsize=figsize). 
+00011190: 2020 2020 2020 2067 7269 6420 3d20 2833         grid = (3
+000111a0: 2c20 3629 0a20 2020 2020 2020 2067 616e  , 6).        gan
+000111b0: 7472 795f 7361 675f 6178 203d 2070 6c74  try_sag_ax = plt
+000111c0: 2e73 7562 706c 6f74 3267 7269 6428 6772  .subplot2grid(gr
+000111d0: 6964 2c20 2830 2c20 3029 2c20 636f 6c73  id, (0, 0), cols
+000111e0: 7061 6e3d 3329 0a20 2020 2020 2020 2073  pan=3).        s
+000111f0: 656c 662e 5f70 6c6f 745f 6465 7669 6174  elf._plot_deviat
+00011200: 696f 6e28 4178 6973 2e47 414e 5452 592c  ion(Axis.GANTRY,
+00011210: 2067 616e 7472 795f 7361 675f 6178 2c20   gantry_sag_ax, 
+00011220: 7368 6f77 3d46 616c 7365 290a 2020 2020  show=False).    
+00011230: 2020 2020 6570 6964 5f73 6167 5f61 7820      epid_sag_ax 
+00011240: 3d20 706c 742e 7375 6270 6c6f 7432 6772  = plt.subplot2gr
+00011250: 6964 2867 7269 642c 2028 302c 2033 292c  id(grid, (0, 3),
+00011260: 2063 6f6c 7370 616e 3d33 290a 2020 2020   colspan=3).    
+00011270: 2020 2020 7365 6c66 2e5f 706c 6f74 5f64      self._plot_d
+00011280: 6576 6961 7469 6f6e 2841 7869 732e 4550  eviation(Axis.EP
+00011290: 4944 2c20 6570 6964 5f73 6167 5f61 782c  ID, epid_sag_ax,
+000112a0: 2073 686f 773d 4661 6c73 6529 0a20 2020   show=False).   
+000112b0: 2020 2020 2069 6620 7365 6c66 2e5f 6765       if self._ge
+000112c0: 745f 696d 6167 6573 2828 4178 6973 2e43  t_images((Axis.C
+000112d0: 4f4c 4c49 4d41 544f 522c 2041 7869 732e  OLLIMATOR, Axis.
+000112e0: 5245 4645 5245 4e43 4529 295b 305d 203e  REFERENCE))[0] >
+000112f0: 2031 3a0a 2020 2020 2020 2020 2020 2020   1:.            
+00011300: 636f 6c6c 5f73 6167 5f61 7820 3d20 706c  coll_sag_ax = pl
+00011310: 742e 7375 6270 6c6f 7432 6772 6964 2867  t.subplot2grid(g
+00011320: 7269 642c 2028 312c 2030 292c 2063 6f6c  rid, (1, 0), col
+00011330: 7370 616e 3d33 290a 2020 2020 2020 2020  span=3).        
+00011340: 2020 2020 7365 6c66 2e5f 706c 6f74 5f64      self._plot_d
+00011350: 6576 6961 7469 6f6e 2841 7869 732e 434f  eviation(Axis.CO
+00011360: 4c4c 494d 4154 4f52 2c20 636f 6c6c 5f73  LLIMATOR, coll_s
+00011370: 6167 5f61 782c 2073 686f 773d 4661 6c73  ag_ax, show=Fals
+00011380: 6529 0a20 2020 2020 2020 2069 6620 7365  e).        if se
+00011390: 6c66 2e5f 6765 745f 696d 6167 6573 2828  lf._get_images((
+000113a0: 4178 6973 2e43 4f55 4348 2c20 4178 6973  Axis.COUCH, Axis
+000113b0: 2e52 4546 4552 454e 4345 2929 5b30 5d20  .REFERENCE))[0] 
+000113c0: 3e20 313a 0a20 2020 2020 2020 2020 2020  > 1:.           
+000113d0: 2063 6f75 6368 5f73 6167 5f61 7820 3d20   couch_sag_ax = 
+000113e0: 706c 742e 7375 6270 6c6f 7432 6772 6964  plt.subplot2grid
+000113f0: 2867 7269 642c 2028 312c 2033 292c 2063  (grid, (1, 3), c
+00011400: 6f6c 7370 616e 3d33 290a 2020 2020 2020  olspan=3).      
+00011410: 2020 2020 2020 7365 6c66 2e5f 706c 6f74        self._plot
+00011420: 5f64 6576 6961 7469 6f6e 2841 7869 732e  _deviation(Axis.
+00011430: 434f 5543 482c 2063 6f75 6368 5f73 6167  COUCH, couch_sag
+00011440: 5f61 782c 2073 686f 773d 4661 6c73 6529  _ax, show=False)
+00011450: 0a0a 2020 2020 2020 2020 666f 7220 6178  ..        for ax
+00011460: 6973 2c20 6178 6e75 6d20 696e 207a 6970  is, axnum in zip
+00011470: 2828 4178 6973 2e47 414e 5452 592c 2041  ((Axis.GANTRY, A
+00011480: 7869 732e 434f 4c4c 494d 4154 4f52 2c20  xis.COLLIMATOR, 
+00011490: 4178 6973 2e43 4f55 4348 292c 2028 302c  Axis.COUCH), (0,
+000114a0: 2032 2c20 3429 293a 0a20 2020 2020 2020   2, 4)):.       
+000114b0: 2020 2020 2069 6620 7365 6c66 2e5f 6765       if self._ge
+000114c0: 745f 696d 6167 6573 2828 6178 6973 2c20  t_images((axis, 
+000114d0: 4178 6973 2e52 4546 4552 454e 4345 2929  Axis.REFERENCE))
+000114e0: 5b30 5d20 3e20 313a 0a20 2020 2020 2020  [0] > 1:.       
+000114f0: 2020 2020 2020 2020 2061 7820 3d20 706c           ax = pl
+00011500: 742e 7375 6270 6c6f 7432 6772 6964 2867  t.subplot2grid(g
+00011510: 7269 642c 2028 322c 2061 786e 756d 292c  rid, (2, axnum),
+00011520: 2063 6f6c 7370 616e 3d32 290a 2020 2020   colspan=2).    
+00011530: 2020 2020 2020 2020 2020 2020 7365 6c66              self
+00011540: 2e70 6c6f 745f 6178 6973 5f69 6d61 6765  .plot_axis_image
+00011550: 7328 6178 6973 3d61 7869 732c 2061 783d  s(axis=axis, ax=
+00011560: 6178 2c20 7368 6f77 3d46 616c 7365 290a  ax, show=False).
+00011570: 2020 2020 2020 2020 6966 2073 686f 773a          if show:
+00011580: 0a20 2020 2020 2020 2020 2020 2070 6c74  .            plt
+00011590: 2e74 6967 6874 5f6c 6179 6f75 7428 290a  .tight_layout().
+000115a0: 2020 2020 2020 2020 2020 2020 706c 742e              plt.
+000115b0: 7368 6f77 2829 0a0a 2020 2020 6465 6620  show()..    def 
+000115c0: 7361 7665 5f73 756d 6d61 7279 2873 656c  save_summary(sel
+000115d0: 662c 2066 696c 656e 616d 653a 2073 7472  f, filename: str
+000115e0: 207c 2042 696e 6172 7949 4f2c 202a 2a6b   | BinaryIO, **k
+000115f0: 7761 7267 7329 202d 3e20 4e6f 6e65 3a0a  wargs) -> None:.
+00011600: 2020 2020 2020 2020 2222 2253 6176 6520          """Save 
+00011610: 7468 6520 7375 6d6d 6172 7920 696d 6167  the summary imag
+00011620: 652e 2222 220a 2020 2020 2020 2020 7365  e.""".        se
+00011630: 6c66 2e70 6c6f 745f 7375 6d6d 6172 7928  lf.plot_summary(
+00011640: 7368 6f77 3d46 616c 7365 2c20 6669 675f  show=False, fig_
+00011650: 7369 7a65 3d6b 7761 7267 732e 706f 7028  size=kwargs.pop(
+00011660: 2266 6967 5f73 697a 6522 2c20 4e6f 6e65  "fig_size", None
+00011670: 2929 0a20 2020 2020 2020 2070 6c74 2e74  )).        plt.t
+00011680: 6967 6874 5f6c 6179 6f75 7428 290a 2020  ight_layout().  
+00011690: 2020 2020 2020 706c 742e 7361 7665 6669        plt.savefi
+000116a0: 6728 6669 6c65 6e61 6d65 2c20 2a2a 6b77  g(filename, **kw
+000116b0: 6172 6773 290a 0a20 2020 2064 6566 2072  args)..    def r
+000116c0: 6573 756c 7473 2873 656c 662c 2061 735f  esults(self, as_
+000116d0: 6c69 7374 3a20 626f 6f6c 203d 2046 616c  list: bool = Fal
+000116e0: 7365 2920 2d3e 2073 7472 3a0a 2020 2020  se) -> str:.    
+000116f0: 2020 2020 2222 2252 6574 7572 6e20 7468      """Return th
+00011700: 6520 616e 616c 7973 6973 2072 6573 756c  e analysis resul
+00011710: 7473 2073 756d 6d61 7279 2e0a 0a20 2020  ts summary...   
+00011720: 2020 2020 2050 6172 616d 6574 6572 730a       Parameters.
+00011730: 2020 2020 2020 2020 2d2d 2d2d 2d2d 2d2d          --------
+00011740: 2d2d 0a20 2020 2020 2020 2061 735f 6c69  --.        as_li
+00011750: 7374 203a 2062 6f6f 6c0a 2020 2020 2020  st : bool.      
+00011760: 2020 2020 2020 5768 6574 6865 7220 746f        Whether to
+00011770: 2072 6574 7572 6e20 6173 2061 206c 6973   return as a lis
+00011780: 7420 6f66 2073 7472 696e 6773 2076 7320  t of strings vs 
+00011790: 7369 6e67 6c65 2073 7472 696e 672e 2050  single string. P
+000117a0: 7265 7474 7920 6d75 6368 2066 6f72 2069  retty much for i
+000117b0: 6e74 6572 6e61 6c20 7573 6167 652e 0a20  nternal usage.. 
+000117c0: 2020 2020 2020 2022 2222 0a20 2020 2020         """.     
+000117d0: 2020 2069 6620 6e6f 7420 7365 6c66 2e5f     if not self._
+000117e0: 6973 5f61 6e61 6c79 7a65 643a 0a20 2020  is_analyzed:.   
+000117f0: 2020 2020 2020 2020 2072 6169 7365 2056           raise V
+00011800: 616c 7565 4572 726f 7228 2254 6865 2073  alueError("The s
+00011810: 6574 2069 7320 6e6f 7420 616e 616c 797a  et is not analyz
+00011820: 6564 2e20 5573 6520 2e61 6e61 6c79 7a65  ed. Use .analyze
+00011830: 2829 2066 6972 7374 2e22 290a 2020 2020  () first.").    
+00011840: 2020 2020 6e75 6d5f 6761 6e74 7279 5f69      num_gantry_i
+00011850: 6d67 7320 3d20 7365 6c66 2e5f 6765 745f  mgs = self._get_
+00011860: 696d 6167 6573 2861 7869 733d 2841 7869  images(axis=(Axi
+00011870: 732e 4741 4e54 5259 2c20 4178 6973 2e52  s.GANTRY, Axis.R
+00011880: 4546 4552 454e 4345 2929 5b30 5d0a 2020  EFERENCE))[0].  
+00011890: 2020 2020 2020 6e75 6d5f 6761 6e74 7279        num_gantry
+000118a0: 5f63 6f6c 6c5f 696d 6773 203d 2073 656c  _coll_imgs = sel
+000118b0: 662e 5f67 6574 5f69 6d61 6765 7328 0a20  f._get_images(. 
+000118c0: 2020 2020 2020 2020 2020 2061 7869 733d             axis=
+000118d0: 2841 7869 732e 4741 4e54 5259 2c20 4178  (Axis.GANTRY, Ax
+000118e0: 6973 2e43 4f4c 4c49 4d41 544f 522c 2041  is.COLLIMATOR, A
+000118f0: 7869 732e 4742 5f43 4f4d 424f 2c20 4178  xis.GB_COMBO, Ax
+00011900: 6973 2e52 4546 4552 454e 4345 290a 2020  is.REFERENCE).  
+00011910: 2020 2020 2020 295b 305d 0a20 2020 2020        )[0].     
+00011920: 2020 206e 756d 5f63 6f6c 6c5f 696d 6773     num_coll_imgs
+00011930: 203d 2073 656c 662e 5f67 6574 5f69 6d61   = self._get_ima
+00011940: 6765 7328 6178 6973 3d28 4178 6973 2e43  ges(axis=(Axis.C
+00011950: 4f4c 4c49 4d41 544f 522c 2041 7869 732e  OLLIMATOR, Axis.
+00011960: 5245 4645 5245 4e43 4529 295b 305d 0a20  REFERENCE))[0]. 
+00011970: 2020 2020 2020 206e 756d 5f63 6f75 6368         num_couch
+00011980: 5f69 6d67 7320 3d20 7365 6c66 2e5f 6765  _imgs = self._ge
+00011990: 745f 696d 6167 6573 2861 7869 733d 2841  t_images(axis=(A
+000119a0: 7869 732e 434f 5543 482c 2041 7869 732e  xis.COUCH, Axis.
+000119b0: 5245 4645 5245 4e43 4529 295b 305d 0a20  REFERENCE))[0]. 
+000119c0: 2020 2020 2020 206e 756d 5f69 6d67 7320         num_imgs 
+000119d0: 3d20 6c65 6e28 7365 6c66 2e69 6d61 6765  = len(self.image
+000119e0: 7329 0a20 2020 2020 2020 2072 6573 756c  s).        resul
+000119f0: 7420 3d20 5b0a 2020 2020 2020 2020 2020  t = [.          
+00011a00: 2020 2257 696e 7374 6f6e 2d4c 7574 7a20    "Winston-Lutz 
+00011a10: 416e 616c 7973 6973 222c 0a20 2020 2020  Analysis",.     
+00011a20: 2020 2020 2020 2022 3d3d 3d3d 3d3d 3d3d         "========
+00011a30: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
+00011a40: 3d3d 3d3d 3d3d 3d3d 3d22 2c0a 2020 2020  =========",.    
+00011a50: 2020 2020 2020 2020 6622 4e75 6d62 6572          f"Number
+00011a60: 206f 6620 696d 6167 6573 3a20 7b6e 756d   of images: {num
+00011a70: 5f69 6d67 737d 222c 0a20 2020 2020 2020  _imgs}",.       
+00011a80: 2020 2020 2066 224d 6178 696d 756d 2032       f"Maximum 2
+00011a90: 4420 4341 582d 3e42 4220 6469 7374 616e  D CAX->BB distan
+00011aa0: 6365 3a20 7b73 656c 662e 6361 7832 6262  ce: {self.cax2bb
+00011ab0: 5f64 6973 7461 6e63 6528 276d 6178 2729  _distance('max')
+00011ac0: 3a2e 3266 7d6d 6d22 2c0a 2020 2020 2020  :.2f}mm",.      
+00011ad0: 2020 2020 2020 6622 4d65 6469 616e 2032        f"Median 2
+00011ae0: 4420 4341 582d 3e42 4220 6469 7374 616e  D CAX->BB distan
+00011af0: 6365 3a20 7b73 656c 662e 6361 7832 6262  ce: {self.cax2bb
+00011b00: 5f64 6973 7461 6e63 6528 276d 6564 6961  _distance('media
+00011b10: 6e27 293a 2e32 667d 6d6d 222c 0a20 2020  n'):.2f}mm",.   
+00011b20: 2020 2020 2020 2020 2066 224d 6561 6e20           f"Mean 
+00011b30: 3244 2043 4158 2d3e 4242 2064 6973 7461  2D CAX->BB dista
+00011b40: 6e63 653a 207b 7365 6c66 2e63 6178 3262  nce: {self.cax2b
+00011b50: 625f 6469 7374 616e 6365 2827 6d65 616e  b_distance('mean
+00011b60: 2729 3a2e 3266 7d6d 6d22 2c0a 2020 2020  '):.2f}mm",.    
+00011b70: 2020 2020 5d0a 2020 2020 2020 2020 6966      ].        if
+00011b80: 2073 656c 662e 5f76 6972 7475 616c 5f73   self._virtual_s
+00011b90: 6869 6674 3a0a 2020 2020 2020 2020 2020  hift:.          
+00011ba0: 2020 7265 7375 6c74 2e61 7070 656e 6428    result.append(
 00011bb0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00011bc0: 2029 0d0a 2020 2020 2020 2020 2020 2020   )..            
-00011bd0: 2020 2020 666f 7220 636f 6e64 6974 696f      for conditio
-00011be0: 6e20 696e 2073 656c 662e 6669 656c 645f  n in self.field_
-00011bf0: 636f 6e64 6974 696f 6e73 0d0a 2020 2020  conditions..    
-00011c00: 2020 2020 2020 2020 290d 0a20 2020 2020          )..     
-00011c10: 2020 2020 2020 2066 6f72 2072 6567 696f         for regio
-00011c20: 6e20 696e 2072 6567 696f 6e73 0d0a 2020  n in regions..  
-00011c30: 2020 2020 2020 5d0d 0a20 2020 2020 2020        ]..       
-00011c40: 2069 6620 6e6f 7420 616e 7928 6669 656c   if not any(fiel
-00011c50: 645f 6361 6e64 6964 6174 6573 293a 0d0a  d_candidates):..
-00011c60: 2020 2020 2020 2020 2020 2020 7261 6973              rais
-00011c70: 6520 5661 6c75 6545 7272 6f72 280d 0a20  e ValueError(.. 
-00011c80: 2020 2020 2020 2020 2020 2020 2020 2022                 "
-00011c90: 4469 6420 6e6f 7420 6669 6e64 2061 6e20  Did not find an 
-00011ca0: 524f 4920 7468 6174 206c 6f6f 6b65 6420  ROI that looked 
-00011cb0: 6c69 6b65 2074 6865 2072 6164 6961 7469  like the radiati
-00011cc0: 6f6e 2066 6965 6c64 2e20 456e 7375 7265  on field. Ensure
-00011cd0: 2074 6865 2072 6164 5f73 697a 6520 7061   the rad_size pa
-00011ce0: 7261 6d65 7465 7220 6973 2063 6f72 7265  rameter is corre
-00011cf0: 6374 2e22 0d0a 2020 2020 2020 2020 2020  ct."..          
-00011d00: 2020 290d 0a20 2020 2020 2020 2066 6965    )..        fie
-00011d10: 6c64 5f6c 6f63 616c 697a 6564 203d 205b  ld_localized = [
-00011d20: 0d0a 2020 2020 2020 2020 2020 2020 7365  ..            se
-00011d30: 6c66 2e6c 6f63 6174 696f 6e5f 6e65 6172  lf.location_near
-00011d40: 5f6e 6f6d 696e 616c 2872 6567 696f 6e2c  _nominal(region,
-00011d50: 206c 6f63 6174 696f 6e29 2066 6f72 2072   location) for r
-00011d60: 6567 696f 6e20 696e 2072 6567 696f 6e73  egion in regions
-00011d70: 0d0a 2020 2020 2020 2020 5d0d 0a20 2020  ..        ]..   
-00011d80: 2020 2020 2069 6620 6e6f 7420 616e 7928       if not any(
-00011d90: 6669 656c 645f 6c6f 6361 6c69 7a65 6429  field_localized)
-00011da0: 3a0d 0a20 2020 2020 2020 2020 2020 2072  :..            r
-00011db0: 6169 7365 2056 616c 7565 4572 726f 7228  aise ValueError(
-00011dc0: 2244 6964 206e 6f74 2066 696e 6420 7468  "Did not find th
-00011dd0: 6520 7261 6469 6174 696f 6e20 6669 656c  e radiation fiel
-00011de0: 6420 7768 6572 6520 6974 2077 6173 2065  d where it was e
-00011df0: 7870 6563 7465 642e 2229 0d0a 2020 2020  xpected.")..    
-00011e00: 2020 2020 656c 7365 3a0d 0a20 2020 2020      else:..     
-00011e10: 2020 2020 2020 2072 6567 696f 6e5f 6964         region_id
-00011e20: 7820 3d20 5b0d 0a20 2020 2020 2020 2020  x = [..         
-00011e30: 2020 2020 2020 2069 6478 0d0a 2020 2020         idx..    
-00011e40: 2020 2020 2020 2020 2020 2020 666f 7220              for 
-00011e50: 6964 782c 205f 2069 6e20 656e 756d 6572  idx, _ in enumer
-00011e60: 6174 6528 7265 6769 6f6e 7329 0d0a 2020  ate(regions)..  
-00011e70: 2020 2020 2020 2020 2020 2020 2020 6966                if
-00011e80: 2066 6965 6c64 5f63 616e 6469 6461 7465   field_candidate
-00011e90: 735b 6964 785d 2061 6e64 2066 6965 6c64  s[idx] and field
-00011ea0: 5f6c 6f63 616c 697a 6564 5b69 6478 5d0d  _localized[idx].
-00011eb0: 0a20 2020 2020 2020 2020 2020 205d 5b30  .            ][0
-00011ec0: 5d0d 0a20 2020 2020 2020 2020 2020 2066  ]..            f
-00011ed0: 6965 6c64 5f72 6f69 203d 2072 6567 696f  ield_roi = regio
-00011ee0: 6e73 5b72 6567 696f 6e5f 6964 785d 0d0a  ns[region_idx]..
-00011ef0: 2020 2020 2020 2020 6262 6f78 203d 206c          bbox = l
-00011f00: 6973 7428 6669 656c 645f 726f 692e 6262  ist(field_roi.bb
-00011f10: 6f78 290d 0a20 2020 2020 2020 2062 626f  ox)..        bbo
-00011f20: 785b 305d 202d 3d20 3430 0d0a 2020 2020  x[0] -= 40..    
-00011f30: 2020 2020 6262 6f78 5b31 5d20 2d3d 2034      bbox[1] -= 4
-00011f40: 300d 0a20 2020 2020 2020 2062 626f 785b  0..        bbox[
-00011f50: 325d 202b 3d20 3430 0d0a 2020 2020 2020  2] += 40..      
-00011f60: 2020 6262 6f78 5b33 5d20 2b3d 2034 300d    bbox[3] += 40.
-00011f70: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
-00011f80: 506f 696e 7428 6669 656c 645f 726f 692e  Point(field_roi.
-00011f90: 6365 6e74 726f 6964 5b31 5d2c 2066 6965  centroid[1], fie
-00011fa0: 6c64 5f72 6f69 2e63 656e 7472 6f69 645b  ld_roi.centroid[
-00011fb0: 305d 292c 2062 626f 780d 0a0d 0a20 2020  0]), bbox....   
-00011fc0: 2064 6566 205f 6669 6e64 5f62 6228 7365   def _find_bb(se
-00011fd0: 6c66 2c20 6262 5f6f 665f 696e 7465 7265  lf, bb_of_intere
-00011fe0: 7374 3a20 6469 6374 2920 2d3e 2050 6f69  st: dict) -> Poi
-00011ff0: 6e74 3a0d 0a20 2020 2020 2020 2022 2222  nt:..        """
-00012000: 4669 6e64 2074 6865 2073 7065 6369 6669  Find the specifi
-00012010: 6320 4242 2062 6173 6564 206f 6e20 7468  c BB based on th
-00012020: 6520 6172 7261 6e67 656d 656e 7420 7261  e arrangement ra
-00012030: 7468 6572 2074 6861 6e20 6120 7369 6e67  ther than a sing
-00012040: 6c65 206f 6e65 2e20 5468 6973 2069 7320  le one. This is 
-00012050: 696e 206c 6f63 616c 2070 6978 656c 2063  in local pixel c
-00012060: 6f6f 7264 696e 6174 6573 2222 220d 0a20  oordinates""".. 
-00012070: 2020 2020 2020 2023 2067 6574 2069 6e69         # get ini
-00012080: 7469 616c 2073 7461 7274 696e 6720 636f  tial starting co
-00012090: 6e64 6974 696f 6e73 0d0a 2020 2020 2020  nditions..      
-000120a0: 2020 6262 5f64 6961 6d65 7465 7220 3d20    bb_diameter = 
-000120b0: 6262 5f6f 665f 696e 7465 7265 7374 5b22  bb_of_interest["
-000120c0: 6262 5f73 697a 655f 6d6d 225d 0d0a 2020  bb_size_mm"]..  
-000120d0: 2020 2020 2020 7769 6e64 6f77 203d 2062        window = b
-000120e0: 625f 6f66 5f69 6e74 6572 6573 745b 2272  b_of_interest["r
-000120f0: 6164 5f73 697a 655f 6d6d 225d 0d0a 2020  ad_size_mm"]..  
-00012100: 2020 2020 2020 6578 7065 6374 6564 5f70        expected_p
-00012110: 6f73 6974 696f 6e20 3d20 7365 6c66 2e5f  osition = self._
-00012120: 6e6f 6d69 6e61 6c5f 706f 696e 7428 6262  nominal_point(bb
-00012130: 5f6f 665f 696e 7465 7265 7374 290d 0a20  _of_interest).. 
-00012140: 2020 2020 2020 2065 7870 6563 7465 645f         expected_
-00012150: 706f 7369 7469 6f6e 5f6d 6d20 3d20 6578  position_mm = ex
-00012160: 7065 6374 6564 5f70 6f73 6974 696f 6e20  pected_position 
-00012170: 2f20 7365 6c66 2e64 706d 6d0d 0a20 2020  / self.dpmm..   
-00012180: 2020 2020 2062 625f 746f 6c65 7261 6e63       bb_toleranc
-00012190: 655f 6d6d 203d 2073 656c 662e 5f63 616c  e_mm = self._cal
-000121a0: 6375 6c61 7465 5f62 625f 746f 6c65 7261  culate_bb_tolera
-000121b0: 6e63 6528 6262 5f64 6961 6d65 7465 7229  nce(bb_diameter)
-000121c0: 0d0a 2020 2020 2020 2020 6365 6e74 6572  ..        center
-000121d0: 203d 2073 656c 662e 636f 6d70 7574 6528   = self.compute(
-000121e0: 0d0a 2020 2020 2020 2020 2020 2020 6d65  ..            me
-000121f0: 7472 6963 733d 5369 7a65 6444 6973 6b4c  trics=SizedDiskL
-00012200: 6f63 6174 6f72 2e66 726f 6d5f 7068 7973  ocator.from_phys
-00012210: 6963 616c 280d 0a20 2020 2020 2020 2020  ical(..         
-00012220: 2020 2020 2020 2065 7870 6563 7465 645f         expected_
-00012230: 706f 7369 7469 6f6e 5f6d 6d3d 6578 7065  position_mm=expe
-00012240: 6374 6564 5f70 6f73 6974 696f 6e5f 6d6d  cted_position_mm
-00012250: 2c0d 0a20 2020 2020 2020 2020 2020 2020  ,..             
-00012260: 2020 2073 6561 7263 685f 7769 6e64 6f77     search_window
-00012270: 5f6d 6d3d 2877 696e 646f 772c 2077 696e  _mm=(window, win
-00012280: 646f 7729 2c0d 0a20 2020 2020 2020 2020  dow),..         
-00012290: 2020 2020 2020 2072 6164 6975 735f 6d6d         radius_mm
-000122a0: 3d62 625f 6469 616d 6574 6572 202f 2032  =bb_diameter / 2
-000122b0: 2c0d 0a20 2020 2020 2020 2020 2020 2020  ,..             
-000122c0: 2020 2072 6164 6975 735f 746f 6c65 7261     radius_tolera
-000122d0: 6e63 655f 6d6d 3d62 625f 746f 6c65 7261  nce_mm=bb_tolera
-000122e0: 6e63 655f 6d6d 2c0d 0a20 2020 2020 2020  nce_mm,..       
-000122f0: 2020 2020 2020 2020 2069 6e76 6572 743d           invert=
-00012300: 5472 7565 2c20 2023 206f 6e6c 7920 4d56  True,  # only MV
-00012310: 2069 6d61 6765 7320 6172 6520 696e 766f   images are invo
-00012320: 6c76 6564 2066 6f72 204d 5457 4c20 4146  lved for MTWL AF
-00012330: 4149 4354 0d0a 2020 2020 2020 2020 2020  AICT..          
-00012340: 2020 2020 2020 6465 7465 6374 696f 6e5f        detection_
-00012350: 636f 6e64 6974 696f 6e73 3d73 656c 662e  conditions=self.
-00012360: 6465 7465 6374 696f 6e5f 636f 6e64 6974  detection_condit
-00012370: 696f 6e73 2c0d 0a20 2020 2020 2020 2020  ions,..         
-00012380: 2020 2029 0d0a 2020 2020 2020 2020 290d     )..        ).
-00012390: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
-000123a0: 6365 6e74 6572 0d0a 0d0a 2020 2020 6465  center....    de
-000123b0: 6620 6c6f 6361 7469 6f6e 5f6e 6561 725f  f location_near_
-000123c0: 6e6f 6d69 6e61 6c28 7365 6c66 2c20 7265  nominal(self, re
-000123d0: 6769 6f6e 3a20 5265 6769 6f6e 5072 6f70  gion: RegionProp
-000123e0: 6572 7469 6573 2c20 6c6f 6361 7469 6f6e  erties, location
-000123f0: 3a20 6469 6374 2920 2d3e 2062 6f6f 6c3a  : dict) -> bool:
-00012400: 0d0a 2020 2020 2020 2020 2222 2244 6574  ..        """Det
-00012410: 6572 6d69 6e65 2077 6865 7468 6572 2074  ermine whether t
-00012420: 6865 2067 6976 656e 2042 4220 524f 4920  he given BB ROI 
-00012430: 6973 206e 6561 7220 7768 6572 6520 7468  is near where th
-00012440: 6520 4242 2069 7320 6578 7065 6374 6564  e BB is expected
-00012450: 2074 6f20 6265 2222 220d 0a20 2020 2020   to be"""..     
-00012460: 2020 2023 2073 696e 6365 2077 6520 6172     # since we ar
-00012470: 6520 6465 616c 696e 6720 7769 7468 2069  e dealing with i
-00012480: 6d61 6765 7320 6174 2074 6865 2069 736f  mages at the iso
-00012490: 706c 616e 6520 7765 2068 6176 6520 746f  plane we have to
-000124a0: 2063 616c 6375 6c61 7465 2074 6865 2065   calculate the e
-000124b0: 7870 6563 7465 6420 706f 7369 7469 6f6e  xpected position
-000124c0: 0d0a 2020 2020 2020 2020 2320 6f66 2074  ..        # of t
-000124d0: 6865 2042 4220 6174 2074 6861 7420 706c  he BB at that pl
-000124e0: 616e 6520 6672 6f6d 2074 6865 2033 4420  ane from the 3D 
-000124f0: 636f 6f72 6469 6e61 7465 730d 0a20 2020  coordinates..   
-00012500: 2020 2020 2069 6620 7265 6769 6f6e 2e61       if region.a
-00012510: 7265 6120 3c20 353a 0d0a 2020 2020 2020  rea < 5:..      
-00012520: 2020 2020 2020 7265 7475 726e 2046 616c        return Fal
-00012530: 7365 2020 2320 736b 6970 2073 696e 676c  se  # skip singl
-00012540: 6520 6f72 2076 6572 7920 736d 616c 6c20  e or very small 
-00012550: 7069 7865 6c20 7265 6769 6f6e 730d 0a20  pixel regions.. 
-00012560: 2020 2020 2020 2065 7870 6563 7465 6420         expected 
-00012570: 3d20 7365 6c66 2e5f 6e6f 6d69 6e61 6c5f  = self._nominal_
-00012580: 706f 696e 7428 6c6f 6361 7469 6f6e 290d  point(location).
-00012590: 0a20 2020 2020 2020 206e 6561 725f 7920  .        near_y 
-000125a0: 3d20 6d61 7468 2e69 7363 6c6f 7365 2865  = math.isclose(e
-000125b0: 7870 6563 7465 642e 792c 2072 6567 696f  xpected.y, regio
-000125c0: 6e2e 6365 6e74 726f 6964 5b30 5d2c 2061  n.centroid[0], a
-000125d0: 6273 5f74 6f6c 3d35 202a 2073 656c 662e  bs_tol=5 * self.
-000125e0: 6470 6d6d 290d 0a20 2020 2020 2020 206e  dpmm)..        n
-000125f0: 6561 725f 7820 3d20 6d61 7468 2e69 7363  ear_x = math.isc
-00012600: 6c6f 7365 2865 7870 6563 7465 642e 782c  lose(expected.x,
-00012610: 2072 6567 696f 6e2e 6365 6e74 726f 6964   region.centroid
-00012620: 5b31 5d2c 2061 6273 5f74 6f6c 3d35 202a  [1], abs_tol=5 *
-00012630: 2073 656c 662e 6470 6d6d 290d 0a20 2020   self.dpmm)..   
-00012640: 2020 2020 2072 6574 7572 6e20 6e65 6172       return near
-00012650: 5f79 2061 6e64 206e 6561 725f 780d 0a0d  _y and near_x...
-00012660: 0a20 2020 2064 6566 2072 6573 756c 7473  .    def results
-00012670: 5f64 6174 6128 7365 6c66 2c20 6173 5f64  _data(self, as_d
-00012680: 6963 743a 2062 6f6f 6c20 3d20 4661 6c73  ict: bool = Fals
-00012690: 6529 202d 3e20 5769 6e73 746f 6e4c 7574  e) -> WinstonLut
-000126a0: 7a32 4452 6573 756c 7420 7c20 6469 6374  z2DResult | dict
-000126b0: 3a0d 0a20 2020 2020 2020 2072 6169 7365  :..        raise
-000126c0: 204e 6f74 496d 706c 656d 656e 7465 6445   NotImplementedE
-000126d0: 7272 6f72 280d 0a20 2020 2020 2020 2020  rror(..         
-000126e0: 2020 2022 5265 7375 6c74 7320 6461 7461     "Results data
-000126f0: 2069 7320 6e6f 7420 6176 6169 6c61 626c   is not availabl
-00012700: 6520 666f 7220 6120 6d75 6c74 692d 6262  e for a multi-bb
-00012710: 2032 4420 574c 2069 6d61 6765 220d 0a20   2D WL image".. 
-00012720: 2020 2020 2020 2029 0d0a 0d0a 0d0a 636c         )......cl
-00012730: 6173 7320 5769 6e73 746f 6e4c 7574 7a4d  ass WinstonLutzM
-00012740: 756c 7469 5461 7267 6574 4d75 6c74 6946  ultiTargetMultiF
-00012750: 6965 6c64 2857 696e 7374 6f6e 4c75 747a  ield(WinstonLutz
-00012760: 293a 0d0a 2020 2020 696d 6167 6573 3a20  ):..    images: 
-00012770: 5365 7175 656e 6365 5b57 696e 7374 6f6e  Sequence[Winston
-00012780: 4c75 747a 3244 4d75 6c74 6954 6172 6765  Lutz2DMultiTarge
-00012790: 745d 2020 233a 0d0a 2020 2020 616e 616c  t]  #:..    anal
-000127a0: 797a 6564 5f69 6d61 6765 733a 2064 6963  yzed_images: dic
-000127b0: 745b 7374 722c 206c 6973 745b 5769 6e73  t[str, list[Wins
-000127c0: 746f 6e4c 7574 7a32 444d 756c 7469 5461  tonLutz2DMultiTa
-000127d0: 7267 6574 5d5d 2020 233a 0d0a 2020 2020  rget]]  #:..    
-000127e0: 696d 6167 655f 7479 7065 203d 2057 696e  image_type = Win
-000127f0: 7374 6f6e 4c75 747a 3244 4d75 6c74 6954  stonLutz2DMultiT
-00012800: 6172 6765 740d 0a20 2020 2062 625f 6172  arget..    bb_ar
-00012810: 7261 6e67 656d 656e 743a 2053 6571 7565  rangement: Seque
-00012820: 6e63 655b 6469 6374 5d20 2023 3a0d 0a0d  nce[dict]  #:...
-00012830: 0a20 2020 2064 6566 205f 5f69 6e69 745f  .    def __init_
-00012840: 5f28 7365 6c66 2c20 2a61 7267 732c 202a  _(self, *args, *
-00012850: 2a6b 7761 7267 7329 3a0d 0a20 2020 2020  *kwargs):..     
-00012860: 2020 2022 2222 5765 2063 616e 6e6f 7420     """We cannot 
-00012870: 7965 7420 6861 6e64 6c65 206e 6f6e 2d30  yet handle non-0
-00012880: 2063 6f75 6368 2061 6e67 6c65 7320 736f   couch angles so
-00012890: 2077 6520 6472 6f70 2074 6865 6d2e 2041   we drop them. A
-000128a0: 6e61 6c79 7369 7320 6661 696c 7320 6f74  nalysis fails ot
-000128b0: 6865 7277 6973 6522 2222 0d0a 2020 2020  herwise"""..    
-000128c0: 2020 2020 7375 7065 7228 292e 5f5f 696e      super().__in
-000128d0: 6974 5f5f 282a 6172 6773 2c20 2a2a 6b77  it__(*args, **kw
-000128e0: 6172 6773 290d 0a20 2020 2020 2020 206f  args)..        o
-000128f0: 7269 675f 6c65 6e67 7468 203d 206c 656e  rig_length = len
-00012900: 2873 656c 662e 696d 6167 6573 290d 0a20  (self.images).. 
-00012910: 2020 2020 2020 2073 656c 662e 696d 6167         self.imag
-00012920: 6573 203d 205b 0d0a 2020 2020 2020 2020  es = [..        
-00012930: 2020 2020 6920 666f 7220 6920 696e 2073      i for i in s
-00012940: 656c 662e 696d 6167 6573 2069 6620 6973  elf.images if is
-00012950: 5f63 6c6f 7365 2869 2e63 6f75 6368 5f61  _close(i.couch_a
-00012960: 6e67 6c65 2c20 5b30 2c20 3336 305d 2c20  ngle, [0, 360], 
-00012970: 6465 6c74 613d 3529 0d0a 2020 2020 2020  delta=5)..      
-00012980: 2020 5d0d 0a20 2020 2020 2020 206e 6577    ]..        new
-00012990: 5f6c 656e 6774 6820 3d20 6c65 6e28 7365  _length = len(se
-000129a0: 6c66 2e69 6d61 6765 7329 0d0a 2020 2020  lf.images)..    
-000129b0: 2020 2020 6966 206e 6577 5f6c 656e 6774      if new_lengt
-000129c0: 6820 213d 206f 7269 675f 6c65 6e67 7468  h != orig_length
-000129d0: 3a0d 0a20 2020 2020 2020 2020 2020 2070  :..            p
-000129e0: 7269 6e74 280d 0a20 2020 2020 2020 2020  rint(..         
-000129f0: 2020 2020 2020 2066 224e 6f6e 2d7a 6572         f"Non-zer
-00012a00: 6f20 636f 7563 6820 616e 676c 6573 206e  o couch angles n
-00012a10: 6f74 2079 6574 2061 6c6c 6f77 6564 2e20  ot yet allowed. 
-00012a20: 4472 6f70 7065 6420 7b6f 7269 675f 6c65  Dropped {orig_le
-00012a30: 6e67 7468 2d6e 6577 5f6c 656e 6774 687d  ngth-new_length}
-00012a40: 2069 6d61 6765 7322 0d0a 2020 2020 2020   images"..      
-00012a50: 2020 2020 2020 290d 0a0d 0a20 2020 2040        )....    @
-00012a60: 636c 6173 736d 6574 686f 640d 0a20 2020  classmethod..   
-00012a70: 2064 6566 2066 726f 6d5f 6465 6d6f 5f69   def from_demo_i
-00012a80: 6d61 6765 7328 636c 7329 3a0d 0a20 2020  mages(cls):..   
-00012a90: 2020 2020 2022 2222 496e 7374 616e 7469       """Instanti
-00012aa0: 6174 6520 7573 696e 6720 7468 6520 6465  ate using the de
-00012ab0: 6d6f 2069 6d61 6765 732e 2222 220d 0a20  mo images.""".. 
-00012ac0: 2020 2020 2020 2064 656d 6f5f 6669 6c65         demo_file
-00012ad0: 203d 2072 6574 7269 6576 655f 6465 6d6f   = retrieve_demo
-00012ae0: 5f66 696c 6528 6e61 6d65 3d22 6d74 5f6d  _file(name="mt_m
-00012af0: 665f 776c 2e7a 6970 2229 0d0a 2020 2020  f_wl.zip")..    
-00012b00: 2020 2020 7265 7475 726e 2063 6c73 2e66      return cls.f
-00012b10: 726f 6d5f 7a69 7028 6465 6d6f 5f66 696c  rom_zip(demo_fil
-00012b20: 6529 0d0a 0d0a 2020 2020 4073 7461 7469  e)....    @stati
-00012b30: 636d 6574 686f 640d 0a20 2020 2064 6566  cmethod..    def
-00012b40: 2072 756e 5f64 656d 6f28 293a 0d0a 2020   run_demo():..  
-00012b50: 2020 2020 2020 2222 2252 756e 2074 6865        """Run the
-00012b60: 2057 696e 7374 6f6e 2d4c 7574 7a20 4d54   Winston-Lutz MT
-00012b70: 204d 4620 6465 6d6f 2c20 7768 6963 6820   MF demo, which 
-00012b80: 6c6f 6164 7320 7468 6520 6465 6d6f 2066  loads the demo f
-00012b90: 696c 6573 2c20 7072 696e 7473 2072 6573  iles, prints res
-00012ba0: 756c 7473 2c20 616e 6420 706c 6f74 7320  ults, and plots 
-00012bb0: 6120 7375 6d6d 6172 7920 696d 6167 652e  a summary image.
-00012bc0: 2222 220d 0a20 2020 2020 2020 2061 7272  """..        arr
-00012bd0: 616e 6765 6d65 6e74 203d 2028 0d0a 2020  angement = (..  
-00012be0: 2020 2020 2020 2020 2020 7b0d 0a20 2020            {..   
-00012bf0: 2020 2020 2020 2020 2020 2020 2022 6e61               "na
-00012c00: 6d65 223a 2022 4973 6f22 2c0d 0a20 2020  me": "Iso",..   
-00012c10: 2020 2020 2020 2020 2020 2020 2022 6f66               "of
-00012c20: 6673 6574 5f6c 6566 745f 6d6d 223a 2030  fset_left_mm": 0
-00012c30: 2c0d 0a20 2020 2020 2020 2020 2020 2020  ,..             
-00012c40: 2020 2022 6f66 6673 6574 5f75 705f 6d6d     "offset_up_mm
-00012c50: 223a 2030 2c0d 0a20 2020 2020 2020 2020  ": 0,..         
-00012c60: 2020 2020 2020 2022 6f66 6673 6574 5f69         "offset_i
-00012c70: 6e5f 6d6d 223a 2030 2c0d 0a20 2020 2020  n_mm": 0,..     
-00012c80: 2020 2020 2020 2020 2020 2022 6262 5f73             "bb_s
-00012c90: 697a 655f 6d6d 223a 2035 2c0d 0a20 2020  ize_mm": 5,..   
-00012ca0: 2020 2020 2020 2020 2020 2020 2022 7261               "ra
-00012cb0: 645f 7369 7a65 5f6d 6d22 3a20 3230 2c0d  d_size_mm": 20,.
-00012cc0: 0a20 2020 2020 2020 2020 2020 207d 2c0d  .            },.
-00012cd0: 0a20 2020 2020 2020 2020 2020 207b 0d0a  .            {..
-00012ce0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00012cf0: 226e 616d 6522 3a20 224c 6566 742c 446f  "name": "Left,Do
-00012d00: 776e 2c49 6e22 2c0d 0a20 2020 2020 2020  wn,In",..       
-00012d10: 2020 2020 2020 2020 2022 6f66 6673 6574           "offset
-00012d20: 5f6c 6566 745f 6d6d 223a 2032 302c 0d0a  _left_mm": 20,..
-00012d30: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00012d40: 226f 6666 7365 745f 7570 5f6d 6d22 3a20  "offset_up_mm": 
-00012d50: 2d32 302c 0d0a 2020 2020 2020 2020 2020  -20,..          
-00012d60: 2020 2020 2020 226f 6666 7365 745f 696e        "offset_in
-00012d70: 5f6d 6d22 3a20 3630 2c0d 0a20 2020 2020  _mm": 60,..     
-00012d80: 2020 2020 2020 2020 2020 2022 6262 5f73             "bb_s
-00012d90: 697a 655f 6d6d 223a 2035 2c0d 0a20 2020  ize_mm": 5,..   
-00012da0: 2020 2020 2020 2020 2020 2020 2022 7261               "ra
-00012db0: 645f 7369 7a65 5f6d 6d22 3a20 3230 2c0d  d_size_mm": 20,.
-00012dc0: 0a20 2020 2020 2020 2020 2020 207d 2c0d  .            },.
-00012dd0: 0a20 2020 2020 2020 2029 0d0a 2020 2020  .        )..    
-00012de0: 2020 2020 776c 203d 2057 696e 7374 6f6e      wl = Winston
-00012df0: 4c75 747a 4d75 6c74 6954 6172 6765 744d  LutzMultiTargetM
-00012e00: 756c 7469 4669 656c 642e 6672 6f6d 5f64  ultiField.from_d
-00012e10: 656d 6f5f 696d 6167 6573 2829 0d0a 2020  emo_images()..  
-00012e20: 2020 2020 2020 776c 2e61 6e61 6c79 7a65        wl.analyze
-00012e30: 2862 625f 6172 7261 6e67 656d 656e 743d  (bb_arrangement=
-00012e40: 6172 7261 6e67 656d 656e 7429 0d0a 2020  arrangement)..  
-00012e50: 2020 2020 2020 7072 696e 7428 776c 2e72        print(wl.r
-00012e60: 6573 756c 7473 2829 290d 0a20 2020 2020  esults())..     
-00012e70: 2020 2077 6c2e 706c 6f74 5f69 6d61 6765     wl.plot_image
-00012e80: 7328 290d 0a0d 0a20 2020 2064 6566 2061  s()....    def a
-00012e90: 6e61 6c79 7a65 2873 656c 662c 2062 625f  nalyze(self, bb_
-00012ea0: 6172 7261 6e67 656d 656e 743a 2053 6571  arrangement: Seq
-00012eb0: 7565 6e63 655b 6469 6374 5d29 3a0d 0a20  uence[dict]):.. 
-00012ec0: 2020 2020 2020 2022 2222 416e 616c 797a         """Analyz
-00012ed0: 6520 7468 6520 574c 2069 6d61 6765 732e  e the WL images.
-00012ee0: 0d0a 0d0a 2020 2020 2020 2020 5061 7261  ....        Para
-00012ef0: 6d65 7465 7273 0d0a 2020 2020 2020 2020  meters..        
-00012f00: 2d2d 2d2d 2d2d 2d2d 2d2d 0d0a 2020 2020  ----------..    
-00012f10: 2020 2020 6262 5f61 7272 616e 6765 6d65      bb_arrangeme
-00012f20: 6e74 0d0a 2020 2020 2020 2020 2020 2020  nt..            
-00012f30: 5468 6520 6172 7261 6e67 656d 656e 7420  The arrangement 
-00012f40: 6f66 2074 6865 2042 4273 2069 6e20 7468  of the BBs in th
-00012f50: 6520 7068 616e 746f 6d2e 2041 2064 6963  e phantom. A dic
-00012f60: 7420 7769 7468 206f 6666 7365 7420 616e  t with offset an
-00012f70: 6420 4242 2073 697a 6520 6b65 7973 2e20  d BB size keys. 
-00012f80: 5365 6520 7468 6520 6060 4242 4172 7261  See the ``BBArra
-00012f90: 6e67 656d 656e 7460 6020 636c 6173 7320  ngement`` class 
-00012fa0: 666f 720d 0a20 2020 2020 2020 2020 2020  for..           
-00012fb0: 206b 6579 7320 616e 6420 7379 6e74 6178   keys and syntax
-00012fc0: 2e0d 0a20 2020 2020 2020 2022 2222 0d0a  ...        """..
-00012fd0: 2020 2020 2020 2020 7365 6c66 2e61 6e61          self.ana
-00012fe0: 6c79 7a65 645f 696d 6167 6573 203d 207b  lyzed_images = {
-00012ff0: 7d0d 0a20 2020 2020 2020 2073 656c 662e  }..        self.
-00013000: 6262 5f61 7272 616e 6765 6d65 6e74 203d  bb_arrangement =
-00013010: 2062 625f 6172 7261 6e67 656d 656e 740d   bb_arrangement.
-00013020: 0a20 2020 2020 2020 2066 6f72 2069 6478  .        for idx
-00013030: 2c20 6262 2069 6e20 656e 756d 6572 6174  , bb in enumerat
-00013040: 6528 6262 5f61 7272 616e 6765 6d65 6e74  e(bb_arrangement
-00013050: 293a 0d0a 2020 2020 2020 2020 2020 2020  ):..            
-00013060: 696d 6167 655f 7365 7420 3d20 5b5d 0d0a  image_set = []..
-00013070: 2020 2020 2020 2020 2020 2020 666f 7220              for 
-00013080: 696d 6720 696e 2073 656c 662e 696d 6167  img in self.imag
-00013090: 6573 3a0d 0a20 2020 2020 2020 2020 2020  es:..           
-000130a0: 2020 2020 2074 7279 3a0d 0a20 2020 2020       try:..     
-000130b0: 2020 2020 2020 2020 2020 2020 2020 2069                 i
-000130c0: 6d61 6765 5f73 6574 2e61 7070 656e 6428  mage_set.append(
-000130d0: 696d 672e 6173 5f61 6e61 6c79 7a65 6428  img.as_analyzed(
-000130e0: 6262 2929 0d0a 2020 2020 2020 2020 2020  bb))..          
-000130f0: 2020 2020 2020 6578 6365 7074 2056 616c        except Val
-00013100: 7565 4572 726f 723a 0d0a 2020 2020 2020  ueError:..      
-00013110: 2020 2020 2020 2020 2020 2020 2020 7061                pa
-00013120: 7373 0d0a 2020 2020 2020 2020 2020 2020  ss..            
-00013130: 6966 206e 6f74 2069 6d61 6765 5f73 6574  if not image_set
-00013140: 3a0d 0a20 2020 2020 2020 2020 2020 2020  :..             
-00013150: 2020 2072 6169 7365 2056 616c 7565 4572     raise ValueEr
-00013160: 726f 7228 6622 4469 6420 6e6f 7420 6669  ror(f"Did not fi
-00013170: 6e64 2061 6e79 2066 6965 6c64 2f62 6220  nd any field/bb 
-00013180: 7061 6972 7320 666f 7220 6262 3a20 7b62  pairs for bb: {b
-00013190: 627d 2229 0d0a 2020 2020 2020 2020 2020  b}")..          
-000131a0: 2020 7365 6c66 2e61 6e61 6c79 7a65 645f    self.analyzed_
-000131b0: 696d 6167 6573 5b42 4241 7272 616e 6765  images[BBArrange
-000131c0: 6d65 6e74 2e74 6f5f 6875 6d61 6e28 6262  ment.to_human(bb
-000131d0: 295d 203d 2069 6d61 6765 5f73 6574 0d0a  )] = image_set..
-000131e0: 2020 2020 2020 2020 7365 6c66 2e5f 6973          self._is
-000131f0: 5f61 6e61 6c79 7a65 6420 3d20 5472 7565  _analyzed = True
-00013200: 0d0a 0d0a 2020 2020 6465 6620 706c 6f74  ....    def plot
-00013210: 5f69 6d61 6765 7328 7365 6c66 2c20 7368  _images(self, sh
-00013220: 6f77 3a20 626f 6f6c 203d 2054 7275 652c  ow: bool = True,
-00013230: 202a 2a6b 7761 7267 7329 202d 3e20 286c   **kwargs) -> (l
-00013240: 6973 745b 706c 742e 4669 6775 7265 5d2c  ist[plt.Figure],
-00013250: 206c 6973 745b 7374 725d 293a 0d0a 2020   list[str]):..  
-00013260: 2020 2020 2020 2222 224d 616b 6520 6120        """Make a 
-00013270: 706c 6f74 2066 6f72 2065 6163 6820 4242  plot for each BB
-00013280: 2e20 4561 6368 2070 6c6f 7420 636f 6e74  . Each plot cont
-00013290: 6169 6e73 2074 6865 2061 6e61 6c79 7369  ains the analysi
-000132a0: 7320 6f66 2074 6861 7420 4242 206f 6e20  s of that BB on 
-000132b0: 6561 6368 2069 6d61 6765 0d0a 2020 2020  each image..    
-000132c0: 2020 2020 6974 2077 6173 2066 6f75 6e64      it was found
-000132d0: 2e22 2222 0d0a 2020 2020 2020 2020 6669  ."""..        fi
-000132e0: 6773 2c20 6e61 6d65 7320 3d20 5b5d 2c20  gs, names = [], 
-000132f0: 5b5d 0d0a 2020 2020 2020 2020 6669 6773  []..        figs
-00013300: 697a 6520 3d20 6b77 6172 6773 2e70 6f70  ize = kwargs.pop
-00013310: 2822 6669 6773 697a 6522 2c20 4e6f 6e65  ("figsize", None
-00013320: 2920 6f72 2028 382c 2038 290d 0a20 2020  ) or (8, 8)..   
-00013330: 2020 2020 2066 6f72 2062 622c 2069 6d67       for bb, img
-00013340: 5f73 6574 2069 6e20 7365 6c66 2e61 6e61  _set in self.ana
-00013350: 6c79 7a65 645f 696d 6167 6573 2e69 7465  lyzed_images.ite
-00013360: 6d73 2829 3a0d 0a20 2020 2020 2020 2020  ms():..         
-00013370: 2020 2072 6f77 7320 3d20 6c65 6e28 696d     rows = len(im
-00013380: 675f 7365 7429 202f 2f20 3320 2b20 310d  g_set) // 3 + 1.
-00013390: 0a20 2020 2020 2020 2020 2020 2066 6967  .            fig
-000133a0: 2c20 6178 6573 203d 2070 6c74 2e73 7562  , axes = plt.sub
-000133b0: 706c 6f74 7328 6e72 6f77 733d 726f 7773  plots(nrows=rows
-000133c0: 2c20 6e63 6f6c 733d 332c 2066 6967 7369  , ncols=3, figsi
-000133d0: 7a65 3d66 6967 7369 7a65 2c20 2a2a 6b77  ze=figsize, **kw
-000133e0: 6172 6773 290d 0a20 2020 2020 2020 2020  args)..         
-000133f0: 2020 2066 6f72 206d 706c 5f61 7869 732c     for mpl_axis,
-00013400: 2077 6c5f 696d 6167 6520 696e 207a 6970   wl_image in zip
-00013410: 5f6c 6f6e 6765 7374 2861 7865 732e 666c  _longest(axes.fl
-00013420: 6174 7465 6e28 292c 2069 6d67 5f73 6574  atten(), img_set
-00013430: 293a 0d0a 2020 2020 2020 2020 2020 2020  ):..            
-00013440: 2020 2020 706c 6f74 5f69 6d61 6765 2877      plot_image(w
-00013450: 6c5f 696d 6167 652c 206d 706c 5f61 7869  l_image, mpl_axi
-00013460: 7329 0d0a 0d0a 2020 2020 2020 2020 2020  s)....          
-00013470: 2020 2320 7365 7420 7469 746c 6573 0d0a    # set titles..
-00013480: 2020 2020 2020 2020 2020 2020 6669 672e              fig.
-00013490: 7375 7074 6974 6c65 2866 2242 4220 7b62  suptitle(f"BB {b
-000134a0: 627d 222c 2066 6f6e 7473 697a 653d 3134  b}", fontsize=14
-000134b0: 2c20 793d 3129 0d0a 2020 2020 2020 2020  , y=1)..        
-000134c0: 2020 2020 6669 672e 7469 6768 745f 6c61      fig.tight_la
-000134d0: 796f 7574 2829 0d0a 2020 2020 2020 2020  yout()..        
-000134e0: 2020 2020 6669 6773 2e61 7070 656e 6428      figs.append(
-000134f0: 6669 6729 0d0a 2020 2020 2020 2020 2020  fig)..          
-00013500: 2020 6e61 6d65 732e 6170 7065 6e64 2866    names.append(f
-00013510: 2242 425f 7b62 627d 2229 0d0a 2020 2020  "BB_{bb}")..    
-00013520: 2020 2020 6966 2073 686f 773a 0d0a 2020      if show:..  
-00013530: 2020 2020 2020 2020 2020 706c 742e 7368            plt.sh
-00013540: 6f77 2829 0d0a 2020 2020 2020 2020 7265  ow()..        re
-00013550: 7475 726e 2066 6967 732c 206e 616d 6573  turn figs, names
-00013560: 0d0a 0d0a 2020 2020 6465 6620 7361 7665  ....    def save
-00013570: 5f69 6d61 6765 7328 7365 6c66 2c20 7072  _images(self, pr
-00013580: 6566 6978 3a20 7374 7220 3d20 2222 2c20  efix: str = "", 
-00013590: 2a2a 6b77 6172 6773 293a 0d0a 2020 2020  **kwargs):..    
-000135a0: 2020 2020 2222 2253 6176 6520 7468 6520      """Save the 
-000135b0: 6669 6775 7265 206f 6620 6070 6c6f 745f  figure of `plot_
-000135c0: 696d 6167 6573 2829 6020 746f 2066 696c  images()` to fil
-000135d0: 6520 6173 2050 4e47 2e20 4b65 7977 6f72  e as PNG. Keywor
-000135e0: 6420 6172 6775 6d65 6e74 7320 6172 6520  d arguments are 
-000135f0: 7061 7373 6564 2074 6f20 606d 6174 706c  passed to `matpl
-00013600: 6f74 6c69 622e 7079 706c 6f74 2e73 6176  otlib.pyplot.sav
-00013610: 6566 6967 2829 602e 0d0a 0d0a 2020 2020  efig()`.....    
-00013620: 2020 2020 5061 7261 6d65 7465 7273 0d0a      Parameters..
-00013630: 2020 2020 2020 2020 2d2d 2d2d 2d2d 2d2d          --------
-00013640: 2d2d 0d0a 2020 2020 2020 2020 7072 6566  --..        pref
-00013650: 6978 203a 2073 7472 0d0a 2020 2020 2020  ix : str..      
-00013660: 2020 2020 2020 5468 6520 7072 6566 6978        The prefix
-00013670: 206e 616d 6520 6f66 2074 6865 2066 696c   name of the fil
-00013680: 6520 746f 2073 6176 6520 746f 2e20 5468  e to save to. Th
-00013690: 6520 4242 206e 616d 6520 6973 2061 7070  e BB name is app
-000136a0: 656e 6465 6420 746f 2074 6865 2070 7265  ended to the pre
-000136b0: 6669 782e 0d0a 2020 2020 2020 2020 2222  fix...        ""
-000136c0: 220d 0a20 2020 2020 2020 2066 6967 732c  "..        figs,
-000136d0: 206e 616d 6573 203d 2073 656c 662e 706c   names = self.pl
-000136e0: 6f74 5f69 6d61 6765 7328 7368 6f77 3d46  ot_images(show=F
-000136f0: 616c 7365 2c20 2a2a 6b77 6172 6773 290d  alse, **kwargs).
-00013700: 0a20 2020 2020 2020 2066 6f72 2066 6967  .        for fig
-00013710: 2c20 6e61 6d65 2069 6e20 7a69 7028 6669  , name in zip(fi
-00013720: 6773 2c20 6e61 6d65 7329 3a0d 0a20 2020  gs, names):..   
-00013730: 2020 2020 2020 2020 2066 6967 2e73 6176           fig.sav
-00013740: 6566 6967 2870 7265 6669 7820 2b20 225f  efig(prefix + "_
-00013750: 2220 2b20 7374 7228 6e61 6d65 2920 2b20  " + str(name) + 
-00013760: 222e 706e 6722 2c20 2a2a 6b77 6172 6773  ".png", **kwargs
-00013770: 290d 0a0d 0a20 2020 2064 6566 2073 6176  )....    def sav
-00013780: 655f 696d 6167 6573 5f74 6f5f 7374 7265  e_images_to_stre
-00013790: 616d 2873 656c 662c 202a 2a6b 7761 7267  am(self, **kwarg
-000137a0: 7329 202d 3e20 6469 6374 5b73 7472 2c20  s) -> dict[str, 
-000137b0: 696f 2e42 7974 6573 494f 5d3a 0d0a 2020  io.BytesIO]:..  
-000137c0: 2020 2020 2020 2222 2253 6176 6520 7468        """Save th
-000137d0: 6520 696e 6469 7669 6475 616c 2069 6d61  e individual ima
-000137e0: 6765 2070 6c6f 7473 2074 6f20 7374 7265  ge plots to stre
-000137f0: 616d 2222 220d 0a20 2020 2020 2020 2066  am"""..        f
-00013800: 6967 732c 206e 616d 6573 203d 2073 656c  igs, names = sel
-00013810: 662e 706c 6f74 5f69 6d61 6765 7328 7368  f.plot_images(sh
-00013820: 6f77 3d46 616c 7365 2c20 2a2a 6b77 6172  ow=False, **kwar
-00013830: 6773 290d 0a20 2020 2020 2020 2073 7472  gs)..        str
-00013840: 6561 6d73 203d 205b 696f 2e42 7974 6573  eams = [io.Bytes
-00013850: 494f 2829 2066 6f72 205f 2069 6e20 6669  IO() for _ in fi
-00013860: 6773 5d0d 0a20 2020 2020 2020 2066 6f72  gs]..        for
-00013870: 2066 6967 2c20 7374 7265 616d 2069 6e20   fig, stream in 
-00013880: 7a69 7028 6669 6773 2c20 7374 7265 616d  zip(figs, stream
-00013890: 7329 3a0d 0a20 2020 2020 2020 2020 2020  s):..           
-000138a0: 2066 6967 2e73 6176 6566 6967 2873 7472   fig.savefig(str
-000138b0: 6561 6d2c 202a 2a6b 7761 7267 7329 0d0a  eam, **kwargs)..
-000138c0: 2020 2020 2020 2020 7265 7475 726e 207b          return {
-000138d0: 6e61 6d65 3a20 7374 7265 616d 2066 6f72  name: stream for
-000138e0: 206e 616d 652c 2073 7472 6561 6d20 696e   name, stream in
-000138f0: 207a 6970 286e 616d 6573 2c20 7374 7265   zip(names, stre
-00013900: 616d 7329 7d0d 0a0d 0a20 2020 2064 6566  ams)}....    def
-00013910: 2063 6178 3262 625f 6469 7374 616e 6365   cax2bb_distance
-00013920: 2873 656c 662c 2062 623a 2073 7472 2c20  (self, bb: str, 
-00013930: 6d65 7472 6963 3a20 7374 7220 3d20 226d  metric: str = "m
-00013940: 6178 2229 202d 3e20 666c 6f61 743a 0d0a  ax") -> float:..
-00013950: 2020 2020 2020 2020 2222 2254 6865 2064          """The d
-00013960: 6973 7461 6e63 6520 696e 206d 6d20 6265  istance in mm be
-00013970: 7477 6565 6e20 7468 6520 4341 5820 616e  tween the CAX an
-00013980: 6420 4242 2066 6f72 2061 6c6c 2069 6d61  d BB for all ima
-00013990: 6765 7320 6163 636f 7264 696e 6720 746f  ges according to
-000139a0: 2074 6865 2067 6976 656e 206d 6574 7269   the given metri
-000139b0: 632e 0d0a 0d0a 2020 2020 2020 2020 5061  c.....        Pa
-000139c0: 7261 6d65 7465 7273 0d0a 2020 2020 2020  rameters..      
-000139d0: 2020 2d2d 2d2d 2d2d 2d2d 2d2d 0d0a 2020    ----------..  
-000139e0: 2020 2020 2020 6d65 7472 6963 203a 207b        metric : {
-000139f0: 276d 6178 272c 2027 6d65 6469 616e 272c  'max', 'median',
-00013a00: 2027 6d65 616e 277d 0d0a 2020 2020 2020   'mean'}..      
-00013a10: 2020 2020 2020 5468 6520 6d65 7472 6963        The metric
-00013a20: 206f 6620 6469 7374 616e 6365 2074 6f20   of distance to 
-00013a30: 7573 652e 0d0a 2020 2020 2020 2020 6262  use...        bb
-00013a40: 203a 2073 7472 0d0a 2020 2020 2020 2020   : str..        
-00013a50: 2020 2020 5468 6520 4242 2074 6f20 616e      The BB to an
-00013a60: 616c 797a 650d 0a20 2020 2020 2020 2022  alyze..        "
-00013a70: 2222 0d0a 2020 2020 2020 2020 6966 206d  ""..        if m
-00013a80: 6574 7269 6320 3d3d 2022 6d61 7822 3a0d  etric == "max":.
-00013a90: 0a20 2020 2020 2020 2020 2020 2072 6574  .            ret
-00013aa0: 7572 6e20 6d61 7828 696d 6167 652e 6361  urn max(image.ca
-00013ab0: 7832 6262 5f64 6973 7461 6e63 6520 666f  x2bb_distance fo
-00013ac0: 7220 696d 6167 6520 696e 2073 656c 662e  r image in self.
-00013ad0: 616e 616c 797a 6564 5f69 6d61 6765 735b  analyzed_images[
-00013ae0: 6262 5d29 0d0a 2020 2020 2020 2020 656c  bb])..        el
-00013af0: 6966 206d 6574 7269 6320 3d3d 2022 6d65  if metric == "me
-00013b00: 6469 616e 223a 0d0a 2020 2020 2020 2020  dian":..        
-00013b10: 2020 2020 7265 7475 726e 2073 7461 7469      return stati
-00013b20: 7374 6963 732e 6d65 6469 616e 280d 0a20  stics.median(.. 
-00013b30: 2020 2020 2020 2020 2020 2020 2020 205b                 [
-00013b40: 696d 6167 652e 6361 7832 6262 5f64 6973  image.cax2bb_dis
-00013b50: 7461 6e63 6520 666f 7220 696d 6167 6520  tance for image 
-00013b60: 696e 2073 656c 662e 616e 616c 797a 6564  in self.analyzed
-00013b70: 5f69 6d61 6765 735b 6262 5d5d 0d0a 2020  _images[bb]]..  
-00013b80: 2020 2020 2020 2020 2020 290d 0a20 2020            )..   
-00013b90: 2020 2020 2065 6c69 6620 6d65 7472 6963       elif metric
-00013ba0: 203d 3d20 226d 6561 6e22 3a0d 0a20 2020   == "mean":..   
-00013bb0: 2020 2020 2020 2020 2072 6574 7572 6e20           return 
-00013bc0: 7374 6174 6973 7469 6373 2e6d 6561 6e28  statistics.mean(
-00013bd0: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-00013be0: 2020 5b69 6d61 6765 2e63 6178 3262 625f    [image.cax2bb_
-00013bf0: 6469 7374 616e 6365 2066 6f72 2069 6d61  distance for ima
-00013c00: 6765 2069 6e20 7365 6c66 2e61 6e61 6c79  ge in self.analy
-00013c10: 7a65 645f 696d 6167 6573 5b62 625d 5d0d  zed_images[bb]].
-00013c20: 0a20 2020 2020 2020 2020 2020 2029 0d0a  .            )..
-00013c30: 0d0a 2020 2020 6465 6620 7265 7375 6c74  ..    def result
-00013c40: 735f 6461 7461 280d 0a20 2020 2020 2020  s_data(..       
-00013c50: 2073 656c 662c 2061 735f 6469 6374 3a20   self, as_dict: 
-00013c60: 626f 6f6c 203d 2046 616c 7365 0d0a 2020  bool = False..  
-00013c70: 2020 2920 2d3e 2057 696e 7374 6f6e 4c75    ) -> WinstonLu
-00013c80: 747a 4d75 6c74 6954 6172 6765 744d 756c  tzMultiTargetMul
-00013c90: 7469 4669 656c 6452 6573 756c 7420 7c20  tiFieldResult | 
-00013ca0: 6469 6374 3a0d 0a20 2020 2020 2020 2022  dict:..        "
-00013cb0: 2222 5072 6573 656e 7420 7468 6520 7265  ""Present the re
-00013cc0: 7375 6c74 7320 6461 7461 2061 6e64 206d  sults data and m
-00013cd0: 6574 6164 6174 6120 6173 2061 2064 6174  etadata as a dat
-00013ce0: 6163 6c61 7373 206f 7220 6469 6374 2e0d  aclass or dict..
-00013cf0: 0a20 2020 2020 2020 2054 6865 2064 6566  .        The def
-00013d00: 6175 6c74 2072 6574 7572 6e20 7479 7065  ault return type
-00013d10: 2069 7320 6120 6461 7461 636c 6173 732e   is a dataclass.
-00013d20: 2222 220d 0a20 2020 2020 2020 2069 6620  """..        if 
-00013d30: 6e6f 7420 7365 6c66 2e5f 6973 5f61 6e61  not self._is_ana
-00013d40: 6c79 7a65 643a 0d0a 2020 2020 2020 2020  lyzed:..        
-00013d50: 2020 2020 7261 6973 6520 5661 6c75 6545      raise ValueE
-00013d60: 7272 6f72 2822 5468 6520 7365 7420 6973  rror("The set is
-00013d70: 206e 6f74 2061 6e61 6c79 7a65 642e 2055   not analyzed. U
-00013d80: 7365 202e 616e 616c 797a 6528 2920 6669  se .analyze() fi
-00013d90: 7273 742e 2229 0d0a 0d0a 2020 2020 2020  rst.")....      
-00013da0: 2020 6461 7461 203d 2057 696e 7374 6f6e    data = Winston
-00013db0: 4c75 747a 4d75 6c74 6954 6172 6765 744d  LutzMultiTargetM
-00013dc0: 756c 7469 4669 656c 6452 6573 756c 7428  ultiFieldResult(
-00013dd0: 0d0a 2020 2020 2020 2020 2020 2020 6e75  ..            nu
-00013de0: 6d5f 746f 7461 6c5f 696d 6167 6573 3d6c  m_total_images=l
-00013df0: 656e 2873 656c 662e 696d 6167 6573 292c  en(self.images),
-00013e00: 0d0a 2020 2020 2020 2020 2020 2020 6d61  ..            ma
-00013e10: 785f 3264 5f66 6965 6c64 5f74 6f5f 6262  x_2d_field_to_bb
-00013e20: 5f6d 6d3d 7365 6c66 2e6d 6178 5f62 625f  _mm=self.max_bb_
-00013e30: 6465 7669 6174 696f 6e5f 3264 2c0d 0a20  deviation_2d,.. 
-00013e40: 2020 2020 2020 2020 2020 206d 6561 6e5f             mean_
-00013e50: 3264 5f66 6965 6c64 5f74 6f5f 6262 5f6d  2d_field_to_bb_m
-00013e60: 6d3d 7365 6c66 2e6d 6561 6e5f 6262 5f64  m=self.mean_bb_d
-00013e70: 6576 6961 7469 6f6e 5f32 642c 0d0a 2020  eviation_2d,..  
-00013e80: 2020 2020 2020 2020 2020 6d65 6469 616e            median
-00013e90: 5f32 645f 6669 656c 645f 746f 5f62 625f  _2d_field_to_bb_
-00013ea0: 6d6d 3d73 656c 662e 6d65 6469 616e 5f62  mm=self.median_b
-00013eb0: 625f 6465 7669 6174 696f 6e5f 3264 2c0d  b_deviation_2d,.
-00013ec0: 0a20 2020 2020 2020 2020 2020 2062 625f  .            bb_
-00013ed0: 6d61 7865 733d 7b0d 0a20 2020 2020 2020  maxes={..       
-00013ee0: 2020 2020 2020 2020 2062 623a 2073 656c           bb: sel
-00013ef0: 662e 6361 7832 6262 5f64 6973 7461 6e63  f.cax2bb_distanc
-00013f00: 6528 6262 2920 666f 7220 6262 2069 6e20  e(bb) for bb in 
-00013f10: 7365 6c66 2e61 6e61 6c79 7a65 645f 696d  self.analyzed_im
-00013f20: 6167 6573 2e6b 6579 7328 290d 0a20 2020  ages.keys()..   
-00013f30: 2020 2020 2020 2020 207d 2c0d 0a20 2020           },..   
-00013f40: 2020 2020 2020 2020 2062 625f 6172 7261           bb_arra
-00013f50: 6e67 656d 656e 743d 7365 6c66 2e62 625f  ngement=self.bb_
-00013f60: 6172 7261 6e67 656d 656e 742c 0d0a 2020  arrangement,..  
-00013f70: 2020 2020 2020 290d 0a20 2020 2020 2020        )..       
-00013f80: 2069 6620 6173 5f64 6963 743a 0d0a 2020   if as_dict:..  
-00013f90: 2020 2020 2020 2020 2020 7265 7475 726e            return
-00013fa0: 2064 6174 6163 6c61 7373 6573 2e61 7364   dataclasses.asd
-00013fb0: 6963 7428 6461 7461 290d 0a20 2020 2020  ict(data)..     
-00013fc0: 2020 2072 6574 7572 6e20 6461 7461 0d0a     return data..
-00013fd0: 0d0a 2020 2020 6465 6620 706c 6f74 5f73  ..    def plot_s
-00013fe0: 756d 6d61 7279 2873 656c 662c 2073 686f  ummary(self, sho
-00013ff0: 773a 2062 6f6f 6c20 3d20 5472 7565 2c20  w: bool = True, 
-00014000: 6669 675f 7369 7a65 3a20 7475 706c 6520  fig_size: tuple 
-00014010: 7c20 4e6f 6e65 203d 204e 6f6e 6529 3a0d  | None = None):.
-00014020: 0a20 2020 2020 2020 2072 6169 7365 204e  .        raise N
-00014030: 6f74 496d 706c 656d 656e 7465 6445 7272  otImplementedErr
-00014040: 6f72 2822 4e6f 7420 7965 7420 696d 706c  or("Not yet impl
-00014050: 656d 656e 7465 6422 290d 0a0d 0a20 2020  emented")....   
-00014060: 2064 6566 2070 6c6f 745f 6178 6973 5f69   def plot_axis_i
-00014070: 6d61 6765 7328 0d0a 2020 2020 2020 2020  mages(..        
-00014080: 7365 6c66 2c20 6178 6973 3a20 4178 6973  self, axis: Axis
-00014090: 203d 2041 7869 732e 4741 4e54 5259 2c20   = Axis.GANTRY, 
-000140a0: 7368 6f77 3a20 626f 6f6c 203d 2054 7275  show: bool = Tru
-000140b0: 652c 2061 783a 2070 6c74 2e41 7865 7320  e, ax: plt.Axes 
-000140c0: 7c20 4e6f 6e65 203d 204e 6f6e 650d 0a20  | None = None.. 
-000140d0: 2020 2029 3a0d 0a20 2020 2020 2020 2072     ):..        r
-000140e0: 6169 7365 204e 6f74 496d 706c 656d 656e  aise NotImplemen
-000140f0: 7465 6445 7272 6f72 2822 4e6f 7420 7965  tedError("Not ye
-00014100: 7420 696d 706c 656d 656e 7465 6422 290d  t implemented").
-00014110: 0a0d 0a20 2020 2040 7072 6f70 6572 7479  ...    @property
-00014120: 0d0a 2020 2020 6465 6620 6d61 785f 6262  ..    def max_bb
-00014130: 5f64 6576 6961 7469 6f6e 5f32 6428 7365  _deviation_2d(se
-00014140: 6c66 2920 2d3e 2066 6c6f 6174 3a0d 0a20  lf) -> float:.. 
-00014150: 2020 2020 2020 2022 2222 5468 6520 6d61         """The ma
-00014160: 7869 6d75 6d20 6469 7374 616e 6365 2066  ximum distance f
-00014170: 726f 6d20 616e 7920 6d65 6173 7572 6564  rom any measured
-00014180: 2042 4220 746f 2069 7473 206e 6f6d 696e   BB to its nomin
-00014190: 616c 2070 6f73 6974 696f 6e22 2222 0d0a  al position"""..
-000141a0: 2020 2020 2020 2020 6469 7374 7320 3d20          dists = 
-000141b0: 5b5d 0d0a 2020 2020 2020 2020 666f 7220  []..        for 
-000141c0: 6262 2c20 696d 6167 6573 2069 6e20 7365  bb, images in se
-000141d0: 6c66 2e61 6e61 6c79 7a65 645f 696d 6167  lf.analyzed_imag
-000141e0: 6573 2e69 7465 6d73 2829 3a0d 0a20 2020  es.items():..   
-000141f0: 2020 2020 2020 2020 2064 6973 7473 2e61           dists.a
-00014200: 7070 656e 6428 7365 6c66 2e63 6178 3262  ppend(self.cax2b
-00014210: 625f 6469 7374 616e 6365 2862 6229 290d  b_distance(bb)).
-00014220: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
-00014230: 6d61 7828 6469 7374 7329 0d0a 0d0a 2020  max(dists)....  
-00014240: 2020 4070 726f 7065 7274 790d 0a20 2020    @property..   
-00014250: 2064 6566 206d 6561 6e5f 6262 5f64 6576   def mean_bb_dev
-00014260: 6961 7469 6f6e 5f32 6428 7365 6c66 2920  iation_2d(self) 
-00014270: 2d3e 2066 6c6f 6174 3a0d 0a20 2020 2020  -> float:..     
-00014280: 2020 2022 2222 5468 6520 6d65 616e 2064     """The mean d
-00014290: 6973 7461 6e63 6520 6672 6f6d 2061 6e79  istance from any
-000142a0: 206d 6561 7375 7265 6420 4242 2074 6f20   measured BB to 
-000142b0: 6974 7320 6e6f 6d69 6e61 6c20 706f 7369  its nominal posi
-000142c0: 7469 6f6e 2222 220d 0a20 2020 2020 2020  tion"""..       
-000142d0: 2064 6973 7473 203d 205b 5d0d 0a20 2020   dists = []..   
-000142e0: 2020 2020 2066 6f72 2062 622c 2069 6d61       for bb, ima
-000142f0: 6765 7320 696e 2073 656c 662e 616e 616c  ges in self.anal
-00014300: 797a 6564 5f69 6d61 6765 732e 6974 656d  yzed_images.item
-00014310: 7328 293a 0d0a 2020 2020 2020 2020 2020  s():..          
-00014320: 2020 6469 7374 732e 6170 7065 6e64 2873    dists.append(s
-00014330: 656c 662e 6361 7832 6262 5f64 6973 7461  elf.cax2bb_dista
-00014340: 6e63 6528 6262 2929 0d0a 2020 2020 2020  nce(bb))..      
-00014350: 2020 7265 7475 726e 2073 7461 7469 7374    return statist
-00014360: 6963 732e 6d65 616e 2864 6973 7473 290d  ics.mean(dists).
-00014370: 0a0d 0a20 2020 2040 7072 6f70 6572 7479  ...    @property
-00014380: 0d0a 2020 2020 6465 6620 6d65 6469 616e  ..    def median
-00014390: 5f62 625f 6465 7669 6174 696f 6e5f 3264  _bb_deviation_2d
-000143a0: 2873 656c 6629 202d 3e20 666c 6f61 743a  (self) -> float:
-000143b0: 0d0a 2020 2020 2020 2020 2222 2254 6865  ..        """The
-000143c0: 206d 6564 6961 6e20 6469 7374 616e 6365   median distance
-000143d0: 2066 726f 6d20 616e 7920 6d65 6173 7572   from any measur
-000143e0: 6564 2042 4220 746f 2069 7473 206e 6f6d  ed BB to its nom
-000143f0: 696e 616c 2070 6f73 6974 696f 6e22 2222  inal position"""
-00014400: 0d0a 2020 2020 2020 2020 6469 7374 7320  ..        dists 
-00014410: 3d20 5b5d 0d0a 2020 2020 2020 2020 666f  = []..        fo
-00014420: 7220 6262 2c20 696d 6167 6573 2069 6e20  r bb, images in 
-00014430: 7365 6c66 2e61 6e61 6c79 7a65 645f 696d  self.analyzed_im
-00014440: 6167 6573 2e69 7465 6d73 2829 3a0d 0a20  ages.items():.. 
-00014450: 2020 2020 2020 2020 2020 2064 6973 7473             dists
-00014460: 2e61 7070 656e 6428 7365 6c66 2e63 6178  .append(self.cax
-00014470: 3262 625f 6469 7374 616e 6365 2862 6229  2bb_distance(bb)
-00014480: 290d 0a20 2020 2020 2020 2072 6574 7572  )..        retur
-00014490: 6e20 7374 6174 6973 7469 6373 2e6d 6564  n statistics.med
-000144a0: 6961 6e28 6469 7374 7329 0d0a 0d0a 2020  ian(dists)....  
-000144b0: 2020 6465 6620 7265 7375 6c74 7328 7365    def results(se
-000144c0: 6c66 2c20 6173 5f6c 6973 743a 2062 6f6f  lf, as_list: boo
-000144d0: 6c20 3d20 4661 6c73 6529 202d 3e20 7374  l = False) -> st
-000144e0: 723a 0d0a 2020 2020 2020 2020 2222 2252  r:..        """R
-000144f0: 6574 7572 6e20 7468 6520 616e 616c 7973  eturn the analys
-00014500: 6973 2072 6573 756c 7473 2073 756d 6d61  is results summa
-00014510: 7279 2e0d 0a0d 0a20 2020 2020 2020 2050  ry.....        P
-00014520: 6172 616d 6574 6572 730d 0a20 2020 2020  arameters..     
-00014530: 2020 202d 2d2d 2d2d 2d2d 2d2d 2d0d 0a20     ----------.. 
-00014540: 2020 2020 2020 2061 735f 6c69 7374 203a         as_list :
-00014550: 2062 6f6f 6c0d 0a20 2020 2020 2020 2020   bool..         
-00014560: 2020 2057 6865 7468 6572 2074 6f20 7265     Whether to re
-00014570: 7475 726e 2061 7320 6120 6c69 7374 206f  turn as a list o
-00014580: 6620 7374 7269 6e67 7320 7673 2073 696e  f strings vs sin
-00014590: 676c 6520 7374 7269 6e67 2e20 5072 6574  gle string. Pret
-000145a0: 7479 206d 7563 6820 666f 7220 696e 7465  ty much for inte
-000145b0: 726e 616c 2075 7361 6765 2e0d 0a20 2020  rnal usage...   
-000145c0: 2020 2020 2022 2222 0d0a 2020 2020 2020       """..      
-000145d0: 2020 6966 206e 6f74 2073 656c 662e 5f69    if not self._i
-000145e0: 735f 616e 616c 797a 6564 3a0d 0a20 2020  s_analyzed:..   
-000145f0: 2020 2020 2020 2020 2072 6169 7365 2056           raise V
-00014600: 616c 7565 4572 726f 7228 2254 6865 2073  alueError("The s
-00014610: 6574 2069 7320 6e6f 7420 616e 616c 797a  et is not analyz
-00014620: 6564 2e20 5573 6520 2e61 6e61 6c79 7a65  ed. Use .analyze
-00014630: 2829 2066 6972 7374 2e22 290d 0a20 2020  () first.")..   
-00014640: 2020 2020 206e 756d 5f69 6d67 7320 3d20       num_imgs = 
-00014650: 6c65 6e28 7365 6c66 2e69 6d61 6765 7329  len(self.images)
-00014660: 0d0a 2020 2020 2020 2020 7265 7375 6c74  ..        result
-00014670: 203d 205b 0d0a 2020 2020 2020 2020 2020   = [..          
-00014680: 2020 2257 696e 7374 6f6e 2d4c 7574 7a20    "Winston-Lutz 
-00014690: 4d75 6c74 692d 5461 7267 6574 204d 756c  Multi-Target Mul
-000146a0: 7469 2d46 6965 6c64 2041 6e61 6c79 7369  ti-Field Analysi
-000146b0: 7322 2c0d 0a20 2020 2020 2020 2020 2020  s",..           
-000146c0: 2022 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d   "==============
-000146d0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-000146e0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-000146f0: 222c 0d0a 2020 2020 2020 2020 2020 2020  ",..            
-00014700: 6622 4e75 6d62 6572 206f 6620 696d 6167  f"Number of imag
-00014710: 6573 3a20 7b6e 756d 5f69 6d67 737d 222c  es: {num_imgs}",
-00014720: 0d0a 2020 2020 2020 2020 2020 2020 2222  ..            ""
-00014730: 2c0d 0a20 2020 2020 2020 2020 2020 2022  ,..            "
-00014740: 3244 2064 6973 7461 6e63 6573 222c 0d0a  2D distances",..
-00014750: 2020 2020 2020 2020 2020 2020 223d 3d3d              "===
-00014760: 3d3d 3d3d 3d3d 3d3d 3d22 2c0d 0a20 2020  =========",..   
-00014770: 2020 2020 2020 2020 2066 224d 6178 2032           f"Max 2
-00014780: 4420 6469 7374 616e 6365 206f 6620 616e  D distance of an
-00014790: 7920 4242 3a20 7b73 656c 662e 6d61 785f  y BB: {self.max_
-000147a0: 6262 5f64 6576 6961 7469 6f6e 5f32 643a  bb_deviation_2d:
-000147b0: 2e32 667d 206d 6d22 2c0d 0a20 2020 2020  .2f} mm",..     
-000147c0: 2020 2020 2020 2066 224d 6561 6e20 3244         f"Mean 2D
-000147d0: 2064 6973 7461 6e63 6520 6f66 2061 6e79   distance of any
-000147e0: 2042 423a 207b 7365 6c66 2e6d 6561 6e5f   BB: {self.mean_
-000147f0: 6262 5f64 6576 6961 7469 6f6e 5f32 643a  bb_deviation_2d:
-00014800: 2e32 667d 206d 6d22 2c0d 0a20 2020 2020  .2f} mm",..     
-00014810: 2020 2020 2020 2066 224d 6564 6961 6e20         f"Median 
-00014820: 3244 2064 6973 7461 6e63 6520 6f66 2061  2D distance of a
-00014830: 6e79 2042 423a 207b 7365 6c66 2e6d 6564  ny BB: {self.med
-00014840: 6961 6e5f 6262 5f64 6576 6961 7469 6f6e  ian_bb_deviation
-00014850: 5f32 643a 2e32 667d 206d 6d22 2c0d 0a20  _2d:.2f} mm",.. 
-00014860: 2020 2020 2020 2020 2020 2022 222c 0d0a             "",..
-00014870: 2020 2020 2020 2020 5d0d 0a20 2020 2020          ]..     
-00014880: 2020 2062 625f 6465 7363 7269 7074 696f     bb_descriptio
-00014890: 6e73 203d 205b 0d0a 2020 2020 2020 2020  ns = [..        
-000148a0: 2020 2020 5b69 6478 2c20 6262 5d20 666f      [idx, bb] fo
-000148b0: 7220 6964 782c 2062 6220 696e 2065 6e75  r idx, bb in enu
-000148c0: 6d65 7261 7465 2873 656c 662e 616e 616c  merate(self.anal
-000148d0: 797a 6564 5f69 6d61 6765 732e 6b65 7973  yzed_images.keys
-000148e0: 2829 290d 0a20 2020 2020 2020 205d 0d0a  ())..        ]..
-000148f0: 2020 2020 2020 2020 7265 7375 6c74 202b          result +
-00014900: 3d20 7461 6275 6c61 7465 2862 625f 6465  = tabulate(bb_de
-00014910: 7363 7269 7074 696f 6e73 2c20 6865 6164  scriptions, head
-00014920: 6572 733d 5b22 4242 2023 222c 2022 4465  ers=["BB #", "De
-00014930: 7363 7269 7074 696f 6e22 5d29 2e73 706c  scription"]).spl
-00014940: 6974 2822 5c6e 2229 0d0a 2020 2020 2020  it("\n")..      
-00014950: 2020 7265 7375 6c74 202b 3d20 5b0d 0a20    result += [.. 
-00014960: 2020 2020 2020 2020 2020 2022 222c 0d0a             "",..
-00014970: 2020 2020 2020 2020 5d0d 0a0d 0a20 2020          ]....   
-00014980: 2020 2020 2023 2063 6f6e 7374 7275 6374       # construct
-00014990: 2074 6865 2069 6d61 6765 202d 3e20 6262   the image -> bb
-000149a0: 2074 6162 6c65 0d0a 2020 2020 2020 2020   table..        
-000149b0: 2320 7765 2075 7365 2061 6262 7265 7669  # we use abbrevi
-000149c0: 6174 696f 6e73 2061 6e64 2074 7275 6e63  ations and trunc
-000149d0: 6174 696f 6e73 2073 6f20 7468 6174 2074  ations so that t
-000149e0: 6865 2074 6162 6c65 2077 696c 6c20 6d6f  he table will mo
-000149f0: 7265 206c 696b 656c 7920 6669 7420 7468  re likely fit th
-00014a00: 6520 5044 460d 0a20 2020 2020 2020 2064  e PDF..        d
-00014a10: 6174 6120 3d20 7b0d 0a20 2020 2020 2020  ata = {..       
-00014a20: 2020 2020 2022 496d 6167 6522 3a20 5b5d       "Image": []
-00014a30: 2c0d 0a20 2020 2020 2020 2020 2020 2022  ,..            "
-00014a40: 4722 3a20 5b5d 2c0d 0a20 2020 2020 2020  G": [],..       
-00014a50: 2020 2020 2022 436f 223a 205b 5d2c 0d0a       "Co": [],..
-00014a60: 2020 2020 2020 2020 2020 2020 2243 6822              "Ch"
-00014a70: 3a20 5b5d 2c0d 0a20 2020 2020 2020 207d  : [],..        }
-00014a80: 0d0a 2020 2020 2020 2020 6262 7320 3d20  ..        bbs = 
-00014a90: 7b66 2242 4220 237b 6964 787d 223a 205b  {f"BB #{idx}": [
-00014aa0: 5d20 666f 7220 6964 7820 696e 2072 616e  ] for idx in ran
-00014ab0: 6765 286c 656e 2873 656c 662e 616e 616c  ge(len(self.anal
-00014ac0: 797a 6564 5f69 6d61 6765 732e 6b65 7973  yzed_images.keys
-00014ad0: 2829 2929 7d0d 0a20 2020 2020 2020 2064  ()))}..        d
-00014ae0: 6174 612e 7570 6461 7465 2862 6273 290d  ata.update(bbs).
-00014af0: 0a20 2020 2020 2020 2066 6f72 2069 6d67  .        for img
-00014b00: 2069 6e20 7365 6c66 2e69 6d61 6765 733a   in self.images:
-00014b10: 0d0a 2020 2020 2020 2020 2020 2020 6461  ..            da
-00014b20: 7461 5b22 496d 6167 6522 5d2e 6170 7065  ta["Image"].appe
-00014b30: 6e64 280d 0a20 2020 2020 2020 2020 2020  nd(..           
-00014b40: 2020 2020 2069 6d67 2e62 6173 655f 7061       img.base_pa
-00014b50: 7468 5b2d 3230 3a5d 0d0a 2020 2020 2020  th[-20:]..      
-00014b60: 2020 2020 2020 2920 2023 2074 6578 7477        )  # textw
-00014b70: 7261 7020 646f 6573 6e27 7420 776f 726b  rap doesn't work
-00014b80: 2068 6572 6520 6265 6361 7573 6520 6669   here because fi
-00014b90: 6c65 7320 6d61 7920 6265 2061 6c6c 206f  les may be all o
-00014ba0: 6e65 2077 6f72 640d 0a20 2020 2020 2020  ne word..       
-00014bb0: 2020 2020 2064 6174 615b 2247 225d 2e61       data["G"].a
-00014bc0: 7070 656e 6428 6622 7b69 6d67 2e67 616e  ppend(f"{img.gan
-00014bd0: 7472 795f 616e 676c 653a 2e31 667d 2229  try_angle:.1f}")
-00014be0: 0d0a 2020 2020 2020 2020 2020 2020 6461  ..            da
-00014bf0: 7461 5b22 436f 225d 2e61 7070 656e 6428  ta["Co"].append(
-00014c00: 6622 7b69 6d67 2e63 6f6c 6c69 6d61 746f  f"{img.collimato
-00014c10: 725f 616e 676c 653a 2e31 667d 2229 0d0a  r_angle:.1f}")..
-00014c20: 2020 2020 2020 2020 2020 2020 6461 7461              data
-00014c30: 5b22 4368 225d 2e61 7070 656e 6428 6622  ["Ch"].append(f"
-00014c40: 7b69 6d67 2e63 6f75 6368 5f61 6e67 6c65  {img.couch_angle
-00014c50: 3a2e 3166 7d22 290d 0a20 2020 2020 2020  :.1f}")..       
-00014c60: 2020 2020 2066 6f72 2062 625f 6964 782c       for bb_idx,
-00014c70: 2028 6262 2c20 696d 675f 7365 7429 2069   (bb, img_set) i
-00014c80: 6e20 656e 756d 6572 6174 6528 7365 6c66  n enumerate(self
-00014c90: 2e61 6e61 6c79 7a65 645f 696d 6167 6573  .analyzed_images
-00014ca0: 2e69 7465 6d73 2829 293a 0d0a 2020 2020  .items()):..    
-00014cb0: 2020 2020 2020 2020 2020 2020 6861 735f              has_
-00014cc0: 7661 6c75 6520 3d20 4661 6c73 650d 0a20  value = False.. 
-00014cd0: 2020 2020 2020 2020 2020 2020 2020 2066                 f
-00014ce0: 6f72 2073 7562 5f69 6d67 2069 6e20 696d  or sub_img in im
-00014cf0: 675f 7365 743a 0d0a 2020 2020 2020 2020  g_set:..        
-00014d00: 2020 2020 2020 2020 2020 2020 6966 2069              if i
-00014d10: 6d67 2e62 6173 655f 7061 7468 203d 3d20  mg.base_path == 
-00014d20: 7375 625f 696d 672e 6261 7365 5f70 6174  sub_img.base_pat
-00014d30: 683a 0d0a 2020 2020 2020 2020 2020 2020  h:..            
-00014d40: 2020 2020 2020 2020 2020 2020 6461 7461              data
-00014d50: 5b66 2242 4220 237b 6262 5f69 6478 7d22  [f"BB #{bb_idx}"
-00014d60: 5d2e 6170 7065 6e64 2866 227b 7375 625f  ].append(f"{sub_
-00014d70: 696d 672e 6361 7832 6262 5f64 6973 7461  img.cax2bb_dista
-00014d80: 6e63 653a 2e32 667d 2229 0d0a 2020 2020  nce:.2f}")..    
-00014d90: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00014da0: 2020 2020 6861 735f 7661 6c75 6520 3d20      has_value = 
-00014db0: 5472 7565 0d0a 2020 2020 2020 2020 2020  True..          
-00014dc0: 2020 2020 2020 6966 206e 6f74 2068 6173        if not has
-00014dd0: 5f76 616c 7565 3a0d 0a20 2020 2020 2020  _value:..       
-00014de0: 2020 2020 2020 2020 2020 2020 2064 6174               dat
-00014df0: 615b 6622 4242 2023 7b62 625f 6964 787d  a[f"BB #{bb_idx}
-00014e00: 225d 2e61 7070 656e 6428 222d 2d2d 2229  "].append("---")
-00014e10: 0d0a 2020 2020 2020 2020 7265 7375 6c74  ..        result
-00014e20: 202b 3d20 7461 6275 6c61 7465 2864 6174   += tabulate(dat
-00014e30: 612c 2068 6561 6465 7273 3d22 6b65 7973  a, headers="keys
-00014e40: 2229 2e73 706c 6974 2822 5c6e 2229 0d0a  ").split("\n")..
-00014e50: 2020 2020 2020 2020 6966 206e 6f74 2061          if not a
-00014e60: 735f 6c69 7374 3a0d 0a20 2020 2020 2020  s_list:..       
-00014e70: 2020 2020 2072 6573 756c 7420 3d20 225c       result = "\
-00014e80: 6e22 2e6a 6f69 6e28 7265 7375 6c74 290d  n".join(result).
-00014e90: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
-00014ea0: 7265 7375 6c74 0d0a 0d0a 2020 2020 6465  result....    de
-00014eb0: 6620 7075 626c 6973 685f 7064 6628 0d0a  f publish_pdf(..
-00014ec0: 2020 2020 2020 2020 7365 6c66 2c0d 0a20          self,.. 
-00014ed0: 2020 2020 2020 2066 696c 656e 616d 653a         filename:
-00014ee0: 2073 7472 2c0d 0a20 2020 2020 2020 206e   str,..        n
-00014ef0: 6f74 6573 3a20 7374 7220 7c20 6c69 7374  otes: str | list
-00014f00: 5b73 7472 5d20 7c20 4e6f 6e65 203d 204e  [str] | None = N
-00014f10: 6f6e 652c 0d0a 2020 2020 2020 2020 6f70  one,..        op
-00014f20: 656e 5f66 696c 653a 2062 6f6f 6c20 3d20  en_file: bool = 
-00014f30: 4661 6c73 652c 0d0a 2020 2020 2020 2020  False,..        
-00014f40: 6d65 7461 6461 7461 3a20 6469 6374 207c  metadata: dict |
-00014f50: 204e 6f6e 6520 3d20 4e6f 6e65 2c0d 0a20   None = None,.. 
-00014f60: 2020 2020 2020 206c 6f67 6f3a 2050 6174         logo: Pat
-00014f70: 6820 7c20 7374 7220 7c20 4e6f 6e65 203d  h | str | None =
-00014f80: 204e 6f6e 652c 0d0a 2020 2020 293a 0d0a   None,..    ):..
-00014f90: 2020 2020 2020 2020 2222 2250 7562 6c69          """Publi
-00014fa0: 7368 2028 7072 696e 7429 2061 2050 4446  sh (print) a PDF
-00014fb0: 2063 6f6e 7461 696e 696e 6720 7468 6520   containing the 
-00014fc0: 616e 616c 7973 6973 2c20 696d 6167 6573  analysis, images
-00014fd0: 2c20 616e 6420 7175 616e 7469 7461 7469  , and quantitati
-00014fe0: 7665 2072 6573 756c 7473 2e0d 0a0d 0a20  ve results..... 
-00014ff0: 2020 2020 2020 2050 6172 616d 6574 6572         Parameter
-00015000: 730d 0a20 2020 2020 2020 202d 2d2d 2d2d  s..        -----
-00015010: 2d2d 2d2d 2d0d 0a20 2020 2020 2020 2066  -----..        f
-00015020: 696c 656e 616d 6520 3a20 2873 7472 2c20  ilename : (str, 
-00015030: 6669 6c65 2d6c 696b 6520 6f62 6a65 6374  file-like object
-00015040: 290d 0a20 2020 2020 2020 2020 2020 2054  )..            T
-00015050: 6865 2066 696c 6520 746f 2077 7269 7465  he file to write
-00015060: 2074 6865 2072 6573 756c 7473 2074 6f2e   the results to.
-00015070: 0d0a 2020 2020 2020 2020 6e6f 7465 7320  ..        notes 
-00015080: 3a20 7374 722c 206c 6973 7420 6f66 2073  : str, list of s
-00015090: 7472 696e 6773 0d0a 2020 2020 2020 2020  trings..        
-000150a0: 2020 2020 5465 7874 3b20 6966 2073 7472      Text; if str
-000150b0: 2c20 7072 696e 7473 2073 696e 676c 6520  , prints single 
-000150c0: 6c69 6e65 2e0d 0a20 2020 2020 2020 2020  line...         
-000150d0: 2020 2049 6620 6c69 7374 206f 6620 7374     If list of st
-000150e0: 7269 6e67 732c 2065 6163 6820 6c69 7374  rings, each list
-000150f0: 2069 7465 6d20 6973 2070 7269 6e74 6564   item is printed
-00015100: 206f 6e20 6974 7320 6f77 6e20 6c69 6e65   on its own line
-00015110: 2e0d 0a20 2020 2020 2020 206f 7065 6e5f  ...        open_
-00015120: 6669 6c65 203a 2062 6f6f 6c0d 0a20 2020  file : bool..   
-00015130: 2020 2020 2020 2020 2057 6865 7468 6572           Whether
-00015140: 2074 6f20 6f70 656e 2074 6865 2066 696c   to open the fil
-00015150: 6520 7573 696e 6720 7468 6520 6465 6661  e using the defa
-00015160: 756c 7420 7072 6f67 7261 6d20 6166 7465  ult program afte
-00015170: 7220 6372 6561 7469 6f6e 2e0d 0a20 2020  r creation...   
-00015180: 2020 2020 206d 6574 6164 6174 6120 3a20       metadata : 
-00015190: 6469 6374 0d0a 2020 2020 2020 2020 2020  dict..          
-000151a0: 2020 4578 7472 6120 6461 7461 2074 6f20    Extra data to 
-000151b0: 6265 2070 6173 7365 6420 616e 6420 7368  be passed and sh
-000151c0: 6f77 6e20 696e 2074 6865 2050 4446 2e20  own in the PDF. 
-000151d0: 5468 6520 6b65 7920 616e 6420 7661 6c75  The key and valu
-000151e0: 6520 7769 6c6c 2062 6520 7368 6f77 6e20  e will be shown 
-000151f0: 7769 7468 2061 2063 6f6c 6f6e 2e0d 0a20  with a colon... 
-00015200: 2020 2020 2020 2020 2020 2045 2e67 2e20             E.g. 
-00015210: 7061 7373 696e 6720 7b27 4175 7468 6f72  passing {'Author
-00015220: 273a 2027 4a61 6d65 7327 2c20 2755 6e69  ': 'James', 'Uni
-00015230: 7427 3a20 2754 7275 6542 6561 6d27 7d20  t': 'TrueBeam'} 
-00015240: 776f 756c 6420 7265 7375 6c74 2069 6e20  would result in 
-00015250: 7465 7874 2069 6e20 7468 6520 5044 4620  text in the PDF 
-00015260: 6c69 6b65 3a0d 0a20 2020 2020 2020 2020  like:..         
-00015270: 2020 202d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d     -------------
-00015280: 2d0d 0a20 2020 2020 2020 2020 2020 2041  -..            A
-00015290: 7574 686f 723a 204a 616d 6573 0d0a 2020  uthor: James..  
-000152a0: 2020 2020 2020 2020 2020 556e 6974 3a20            Unit: 
-000152b0: 5472 7565 4265 616d 0d0a 2020 2020 2020  TrueBeam..      
-000152c0: 2020 2020 2020 2d2d 2d2d 2d2d 2d2d 2d2d        ----------
-000152d0: 2d2d 2d2d 0d0a 2020 2020 2020 2020 6c6f  ----..        lo
-000152e0: 676f 3a20 5061 7468 2c20 7374 720d 0a20  go: Path, str.. 
-000152f0: 2020 2020 2020 2020 2020 2041 2063 7573             A cus
-00015300: 746f 6d20 6c6f 676f 2074 6f20 7573 6520  tom logo to use 
-00015310: 696e 2074 6865 2050 4446 2072 6570 6f72  in the PDF repor
-00015320: 742e 2049 6620 6e6f 7468 696e 6720 6973  t. If nothing is
-00015330: 2070 6173 7365 642c 2074 6865 2064 6566   passed, the def
-00015340: 6175 6c74 2070 796c 696e 6163 206c 6f67  ault pylinac log
-00015350: 6f20 6973 2075 7365 642e 0d0a 2020 2020  o is used...    
-00015360: 2020 2020 2222 220d 0a20 2020 2020 2020      """..       
-00015370: 2069 6620 6e6f 7420 7365 6c66 2e5f 6973   if not self._is
-00015380: 5f61 6e61 6c79 7a65 643a 0d0a 2020 2020  _analyzed:..    
-00015390: 2020 2020 2020 2020 7261 6973 6520 5661          raise Va
-000153a0: 6c75 6545 7272 6f72 2822 5468 6520 7365  lueError("The se
-000153b0: 7420 6973 206e 6f74 2061 6e61 6c79 7a65  t is not analyze
-000153c0: 642e 2055 7365 202e 616e 616c 797a 6528  d. Use .analyze(
-000153d0: 2920 6669 7273 742e 2229 0d0a 2020 2020  ) first.")..    
-000153e0: 2020 2020 706c 742e 696f 6666 2829 0d0a      plt.ioff()..
-000153f0: 2020 2020 2020 2020 7469 746c 6520 3d20          title = 
-00015400: 2257 696e 7374 6f6e 2d4c 7574 7a20 4d75  "Winston-Lutz Mu
-00015410: 6c74 692d 4242 2041 6e61 6c79 7369 7322  lti-BB Analysis"
-00015420: 0d0a 2020 2020 2020 2020 6361 6e76 6173  ..        canvas
-00015430: 203d 2070 6466 2e50 796c 696e 6163 4361   = pdf.PylinacCa
-00015440: 6e76 6173 280d 0a20 2020 2020 2020 2020  nvas(..         
-00015450: 2020 2066 696c 656e 616d 652c 0d0a 2020     filename,..  
-00015460: 2020 2020 2020 2020 2020 7061 6765 5f74            page_t
-00015470: 6974 6c65 3d74 6974 6c65 2c0d 0a20 2020  itle=title,..   
-00015480: 2020 2020 2020 2020 206d 6574 6164 6174           metadat
-00015490: 613d 6d65 7461 6461 7461 2c0d 0a20 2020  a=metadata,..   
-000154a0: 2020 2020 2020 2020 206c 6f67 6f3d 6c6f           logo=lo
-000154b0: 676f 2c0d 0a20 2020 2020 2020 2020 2020  go,..           
-000154c0: 206d 6574 6164 6174 615f 6c6f 6361 7469   metadata_locati
-000154d0: 6f6e 3d28 3135 2c20 3235 2e35 292c 0d0a  on=(15, 25.5),..
-000154e0: 2020 2020 2020 2020 290d 0a20 2020 2020          )..     
-000154f0: 2020 2074 6578 7420 3d20 7365 6c66 2e72     text = self.r
-00015500: 6573 756c 7473 2861 735f 6c69 7374 3d54  esults(as_list=T
-00015510: 7275 6529 0d0a 2020 2020 2020 2020 6361  rue)..        ca
-00015520: 6e76 6173 2e61 6464 5f74 6578 7428 7465  nvas.add_text(te
-00015530: 7874 3d74 6578 742c 206c 6f63 6174 696f  xt=text, locatio
-00015540: 6e3d 2831 2c20 3235 2e35 292c 2066 6f6e  n=(1, 25.5), fon
-00015550: 743d 2243 6f75 7269 6572 2229 0d0a 2020  t="Courier")..  
-00015560: 2020 2020 2020 2320 6472 6177 2073 756d        # draw sum
-00015570: 6d61 7279 2069 6d61 6765 206f 6e20 3173  mary image on 1s
-00015580: 7420 7061 6765 0d0a 2020 2020 2020 2020  t page..        
-00015590: 6966 206e 6f74 6573 2069 7320 6e6f 7420  if notes is not 
-000155a0: 4e6f 6e65 3a0d 0a20 2020 2020 2020 2020  None:..         
-000155b0: 2020 2063 616e 7661 732e 6164 645f 7465     canvas.add_te
-000155c0: 7874 2874 6578 743d 224e 6f74 6573 3a22  xt(text="Notes:"
-000155d0: 2c20 6c6f 6361 7469 6f6e 3d28 312c 2034  , location=(1, 4
-000155e0: 2e35 292c 2066 6f6e 745f 7369 7a65 3d31  .5), font_size=1
-000155f0: 3429 0d0a 2020 2020 2020 2020 2020 2020  4)..            
-00015600: 6361 6e76 6173 2e61 6464 5f74 6578 7428  canvas.add_text(
-00015610: 7465 7874 3d6e 6f74 6573 2c20 6c6f 6361  text=notes, loca
-00015620: 7469 6f6e 3d28 312c 2034 2929 0d0a 2020  tion=(1, 4))..  
-00015630: 2020 2020 2020 2320 706c 6f74 2065 6163        # plot eac
-00015640: 6820 4242 2773 2069 6d61 6765 730d 0a20  h BB's images.. 
-00015650: 2020 2020 2020 2062 625f 7374 7265 616d         bb_stream
-00015660: 7320 3d20 7365 6c66 2e73 6176 655f 696d  s = self.save_im
-00015670: 6167 6573 5f74 6f5f 7374 7265 616d 2829  ages_to_stream()
-00015680: 0d0a 2020 2020 2020 2020 666f 7220 7374  ..        for st
-00015690: 7265 616d 2069 6e20 6262 5f73 7472 6561  ream in bb_strea
-000156a0: 6d73 2e76 616c 7565 7328 293a 0d0a 2020  ms.values():..  
-000156b0: 2020 2020 2020 2020 2020 6361 6e76 6173            canvas
-000156c0: 2e61 6464 5f6e 6577 5f70 6167 6528 290d  .add_new_page().
-000156d0: 0a20 2020 2020 2020 2020 2020 2063 616e  .            can
-000156e0: 7661 732e 6164 645f 696d 6167 6528 7374  vas.add_image(st
-000156f0: 7265 616d 2c20 6c6f 6361 7469 6f6e 3d28  ream, location=(
-00015700: 322c 2037 292c 2064 696d 656e 7369 6f6e  2, 7), dimension
-00015710: 733d 2831 382c 2031 3829 290d 0a20 2020  s=(18, 18))..   
-00015720: 2020 2020 2063 616e 7661 732e 6669 6e69       canvas.fini
-00015730: 7368 2829 0d0a 0d0a 2020 2020 2020 2020  sh()....        
-00015740: 6966 206f 7065 6e5f 6669 6c65 3a0d 0a20  if open_file:.. 
-00015750: 2020 2020 2020 2020 2020 2077 6562 6272             webbr
-00015760: 6f77 7365 722e 6f70 656e 2866 696c 656e  owser.open(filen
-00015770: 616d 6529 0d0a 0d0a 0d0a 6465 6620 6d61  ame)......def ma
-00015780: 785f 6469 7374 616e 6365 5f74 6f5f 6c69  x_distance_to_li
-00015790: 6e65 7328 702c 206c 696e 6573 3a20 4974  nes(p, lines: It
-000157a0: 6572 6162 6c65 5b4c 696e 655d 2920 2d3e  erable[Line]) ->
-000157b0: 2066 6c6f 6174 3a0d 0a20 2020 2022 2222   float:..    """
-000157c0: 4361 6c63 756c 6174 6520 7468 6520 6d61  Calculate the ma
-000157d0: 7869 6d75 6d20 6469 7374 616e 6365 2074  ximum distance t
-000157e0: 6f20 616e 7920 6c69 6e65 2066 726f 6d20  o any line from 
-000157f0: 7468 6520 6769 7665 6e20 706f 696e 742e  the given point.
-00015800: 2222 220d 0a20 2020 2070 6f69 6e74 203d  """..    point =
-00015810: 2050 6f69 6e74 2870 5b30 5d2c 2070 5b31   Point(p[0], p[1
-00015820: 5d2c 2070 5b32 5d29 0d0a 2020 2020 7265  ], p[2])..    re
-00015830: 7475 726e 206d 6178 286c 696e 652e 6469  turn max(line.di
-00015840: 7374 616e 6365 5f74 6f28 706f 696e 7429  stance_to(point)
-00015850: 2066 6f72 206c 696e 6520 696e 206c 696e   for line in lin
-00015860: 6573 290d 0a0d 0a0d 0a64 6566 2062 625f  es)......def bb_
-00015870: 7072 6f6a 6563 7469 6f6e 5f6c 6f6e 6728  projection_long(
-00015880: 0d0a 2020 2020 6f66 6673 6574 5f69 6e3a  ..    offset_in:
-00015890: 2066 6c6f 6174 2c20 6f66 6673 6574 5f75   float, offset_u
-000158a0: 703a 2066 6c6f 6174 2c20 6f66 6673 6574  p: float, offset
-000158b0: 5f6c 6566 743a 2066 6c6f 6174 2c20 7361  _left: float, sa
-000158c0: 643a 2066 6c6f 6174 2c20 6761 6e74 7279  d: float, gantry
-000158d0: 3a20 666c 6f61 740d 0a29 202d 3e20 666c  : float..) -> fl
-000158e0: 6f61 743a 0d0a 2020 2020 2222 2243 616c  oat:..    """Cal
-000158f0: 6375 6c61 7465 2074 6865 2069 736f 706c  culate the isopl
-00015900: 616e 6520 7072 6f6a 6563 7469 6f6e 2069  ane projection i
-00015910: 6e20 7468 6520 7375 702f 696e 662f 6c6f  n the sup/inf/lo
-00015920: 6e67 6974 7564 696e 616c 2064 6972 6563  ngitudinal direc
-00015930: 7469 6f6e 2069 6e20 6d6d 2222 220d 0a20  tion in mm""".. 
-00015940: 2020 2023 2074 6865 2064 6976 6572 6765     # the diverge
-00015950: 6e63 6520 6f66 2074 6865 2062 6561 6d20  nce of the beam 
-00015960: 6361 7573 6573 2074 6865 2042 4220 746f  causes the BB to
-00015970: 2062 6520 636c 6f73 6572 206f 7220 6675   be closer or fu
-00015980: 7274 6865 7220 6465 7065 6e64 696e 6720  rther depending 
-00015990: 6f6e 2074 6865 0d0a 2020 2020 2320 7570  on the..    # up
-000159a0: 2f64 6f77 6e20 706f 7369 7469 6f6e 2c20  /down position, 
-000159b0: 6c65 6674 2f72 6967 6874 2070 6f73 6974  left/right posit
-000159c0: 696f 6e20 616e 6420 6761 6e74 7279 2061  ion and gantry a
-000159d0: 6e67 6c65 0d0a 2020 2020 6164 6474 6c5f  ngle..    addtl_
-000159e0: 6c6f 6e67 5f73 6869 6674 5f63 6f73 203d  long_shift_cos =
-000159f0: 2028 0d0a 2020 2020 2020 2020 6f66 6673   (..        offs
-00015a00: 6574 5f75 7020 2a20 6f66 6673 6574 5f69  et_up * offset_i
-00015a10: 6e20 2f20 2873 6164 202d 2063 6f73 2867  n / (sad - cos(g
-00015a20: 616e 7472 7929 202a 206f 6666 7365 745f  antry) * offset_
-00015a30: 7570 2920 2a20 636f 7328 6761 6e74 7279  up) * cos(gantry
-00015a40: 290d 0a20 2020 2029 0d0a 2020 2020 6164  )..    )..    ad
-00015a50: 6474 6c5f 6c65 6674 5f73 6869 6674 5f73  dtl_left_shift_s
-00015a60: 696e 203d 2028 0d0a 2020 2020 2020 2020  in = (..        
-00015a70: 6f66 6673 6574 5f6c 6566 7420 2a20 6f66  offset_left * of
-00015a80: 6673 6574 5f69 6e20 2f20 2873 6164 202b  fset_in / (sad +
-00015a90: 2073 696e 2867 616e 7472 7929 202a 206f   sin(gantry) * o
-00015aa0: 6666 7365 745f 6c65 6674 2920 2a20 2d73  ffset_left) * -s
-00015ab0: 696e 2867 616e 7472 7929 0d0a 2020 2020  in(gantry)..    
-00015ac0: 290d 0a20 2020 2072 6574 7572 6e20 6f66  )..    return of
-00015ad0: 6673 6574 5f69 6e20 2b20 6164 6474 6c5f  fset_in + addtl_
-00015ae0: 6c6f 6e67 5f73 6869 6674 5f63 6f73 202b  long_shift_cos +
-00015af0: 2061 6464 746c 5f6c 6566 745f 7368 6966   addtl_left_shif
-00015b00: 745f 7369 6e0d 0a0d 0a0d 0a64 6566 2062  t_sin......def b
-00015b10: 625f 7072 6f6a 6563 7469 6f6e 5f67 616e  b_projection_gan
-00015b20: 7472 795f 706c 616e 6528 0d0a 2020 2020  try_plane(..    
-00015b30: 6f66 6673 6574 5f6c 6566 743a 2066 6c6f  offset_left: flo
-00015b40: 6174 2c20 6f66 6673 6574 5f75 703a 2066  at, offset_up: f
-00015b50: 6c6f 6174 2c20 7361 643a 2066 6c6f 6174  loat, sad: float
-00015b60: 2c20 6761 6e74 7279 3a20 666c 6f61 740d  , gantry: float.
-00015b70: 0a29 202d 3e20 666c 6f61 743a 0d0a 2020  .) -> float:..  
-00015b80: 2020 2222 2243 616c 6375 6c61 7465 2074    """Calculate t
-00015b90: 6865 2069 736f 706c 616e 6520 7072 6f6a  he isoplane proj
-00015ba0: 6563 7469 6f6e 2069 6e20 7468 6520 706c  ection in the pl
-00015bb0: 616e 6520 6f66 2067 616e 7472 7920 726f  ane of gantry ro
-00015bc0: 7461 7469 6f6e 2028 582f 5a29 2222 220d  tation (X/Z)""".
-00015bd0: 0a20 2020 2061 6464 746c 5f6c 6566 745f  .    addtl_left_
-00015be0: 7368 6966 7420 3d20 280d 0a20 2020 2020  shift = (..     
-00015bf0: 2020 202d 6f66 6673 6574 5f75 7020 2a20     -offset_up * 
-00015c00: 6f66 6673 6574 5f6c 6566 7420 2f20 2873  offset_left / (s
-00015c10: 6164 202b 2063 6f73 2867 616e 7472 7929  ad + cos(gantry)
-00015c20: 202a 206f 6666 7365 745f 7570 2920 2a20   * offset_up) * 
-00015c30: 6162 7328 636f 7328 6761 6e74 7279 2929  abs(cos(gantry))
-00015c40: 0d0a 2020 2020 290d 0a20 2020 2061 6464  ..    )..    add
-00015c50: 746c 5f75 705f 7368 6966 7420 3d20 280d  tl_up_shift = (.
-00015c60: 0a20 2020 2020 2020 206f 6666 7365 745f  .        offset_
-00015c70: 6c65 6674 202a 206f 6666 7365 745f 7570  left * offset_up
-00015c80: 202f 2028 7361 6420 2b20 7369 6e28 6761   / (sad + sin(ga
-00015c90: 6e74 7279 2920 2a20 6f66 6673 6574 5f6c  ntry) * offset_l
-00015ca0: 6566 7429 202a 2061 6273 2873 696e 2867  eft) * abs(sin(g
-00015cb0: 616e 7472 7929 290d 0a20 2020 2029 0d0a  antry))..    )..
-00015cc0: 2020 2020 7265 7475 726e 2028 0d0a 2020      return (..  
-00015cd0: 2020 2020 2020 6f66 6673 6574 5f75 7020        offset_up 
-00015ce0: 2a20 2d73 696e 2867 616e 7472 7929 0d0a  * -sin(gantry)..
-00015cf0: 2020 2020 2020 2020 2b20 6164 6474 6c5f          + addtl_
-00015d00: 7570 5f73 6869 6674 0d0a 2020 2020 2020  up_shift..      
-00015d10: 2020 2b20 6f66 6673 6574 5f6c 6566 7420    + offset_left 
-00015d20: 2a20 2d63 6f73 2867 616e 7472 7929 0d0a  * -cos(gantry)..
-00015d30: 2020 2020 2020 2020 2b20 6164 6474 6c5f          + addtl_
-00015d40: 6c65 6674 5f73 6869 6674 0d0a 2020 2020  left_shift..    
-00015d50: 290d 0a0d 0a0d 0a64 6566 205f 6262 5f70  )......def _bb_p
-00015d60: 726f 6a65 6374 696f 6e5f 7769 7468 5f72  rojection_with_r
-00015d70: 6f74 6174 696f 6e28 0d0a 2020 2020 6f66  otation(..    of
-00015d80: 6673 6574 5f6c 6566 743a 2066 6c6f 6174  fset_left: float
-00015d90: 2c0d 0a20 2020 206f 6666 7365 745f 7570  ,..    offset_up
-00015da0: 3a20 666c 6f61 742c 0d0a 2020 2020 6f66  : float,..    of
-00015db0: 6673 6574 5f69 6e3a 2066 6c6f 6174 2c0d  fset_in: float,.
-00015dc0: 0a20 2020 2067 616e 7472 793a 2066 6c6f  .    gantry: flo
-00015dd0: 6174 2c0d 0a20 2020 2063 6f75 6368 3a20  at,..    couch: 
-00015de0: 666c 6f61 7420 3d20 302c 0d0a 2020 2020  float = 0,..    
-00015df0: 7361 643a 2066 6c6f 6174 203d 2031 3030  sad: float = 100
-00015e00: 302c 0d0a 2920 2d3e 2028 666c 6f61 742c  0,..) -> (float,
-00015e10: 2066 6c6f 6174 293a 0d0a 2020 2020 2222   float):..    ""
-00015e20: 2243 616c 6375 6c61 7465 2074 6865 2069  "Calculate the i
-00015e30: 736f 706c 616e 6520 7072 6f6a 6563 7469  soplane projecti
-00015e40: 6f6e 206f 6e74 6f20 7468 6520 7061 6e65  on onto the pane
-00015e50: 6c20 6174 2074 6865 2067 6976 656e 2053  l at the given S
-00015e60: 5344 2e0d 0a0d 0a20 2020 2054 6869 7320  SD.....    This 
-00015e70: 6675 6e63 7469 6f6e 2061 7070 6c69 6573  function applies
-00015e80: 2061 2072 6f74 6174 696f 6e20 6172 6f75   a rotation arou
-00015e90: 6e64 2074 6865 2067 616e 7472 7920 706c  nd the gantry pl
-00015ea0: 616e 6520 2858 2f5a 2920 746f 2074 6865  ane (X/Z) to the
-00015eb0: 0d0a 2020 2020 6261 6c6c 2062 6561 7269  ..    ball beari
-00015ec0: 6e67 2028 4242 2920 706f 7369 7469 6f6e  ng (BB) position
-00015ed0: 2061 6e64 2063 616c 6375 6c61 7465 7320   and calculates 
-00015ee0: 6974 7320 7072 6f6a 6563 7469 6f6e 206f  its projection o
-00015ef0: 6e74 6f20 7468 6520 6973 6f63 656e 7472  nto the isocentr
-00015f00: 6520 706c 616e 6520 696e 2074 6865 2062  e plane in the b
-00015f10: 6561 6d27 7320 6579 6520 7669 6577 2e0d  eam's eye view..
-00015f20: 0a0d 0a20 2020 2043 6f75 6c64 2062 6520  ...    Could be 
-00015f30: 7573 6564 2074 6f20 6361 6c63 756c 6174  used to calculat
-00015f40: 6520 636f 7563 6820 726f 7461 7469 6f6e  e couch rotation
-00015f50: 732c 2062 7574 206e 6f74 2076 616c 6964  s, but not valid
-00015f60: 6174 6564 2079 6574 2e0d 0a0d 0a20 2020  ated yet.....   
-00015f70: 2041 7267 730d 0a20 2020 202d 2d2d 2d0d   Args..    ----.
-00015f80: 0a20 2020 206f 6666 7365 745f 6c65 6674  .    offset_left
-00015f90: 2028 666c 6f61 7429 3a20 5468 6520 4242   (float): The BB
-00015fa0: 2070 6f73 6974 696f 6e20 696e 2074 6865   position in the
-00015fb0: 206c 6566 742f 7269 6768 7420 6469 7265   left/right dire
-00015fc0: 6374 696f 6e2e 0d0a 2020 2020 6f66 6673  ction...    offs
-00015fd0: 6574 5f75 7020 2866 6c6f 6174 293a 2054  et_up (float): T
-00015fe0: 6865 2042 4220 706f 7369 7469 6f6e 2069  he BB position i
-00015ff0: 6e20 7468 6520 7375 7065 7269 6f72 2f69  n the superior/i
-00016000: 6e66 6572 696f 7220 6469 7265 6374 696f  nferior directio
-00016010: 6e2e 0d0a 2020 2020 6f66 6673 6574 5f69  n...    offset_i
-00016020: 6e20 2866 6c6f 6174 293a 2054 6865 2042  n (float): The B
-00016030: 4220 706f 7369 7469 6f6e 2069 6e20 7468  B position in th
-00016040: 6520 616e 7465 7269 6f72 2f70 6f73 7465  e anterior/poste
-00016050: 7269 6f72 2064 6972 6563 7469 6f6e 2e0d  rior direction..
-00016060: 0a20 2020 2067 616e 7472 7920 2866 6c6f  .    gantry (flo
-00016070: 6174 293a 2054 6865 2067 616e 7472 7920  at): The gantry 
-00016080: 616e 676c 6520 696e 2064 6567 7265 6573  angle in degrees
-00016090: 2e0d 0a20 2020 2063 6f75 6368 2028 666c  ...    couch (fl
-000160a0: 6f61 742c 206f 7074 696f 6e61 6c29 3a20  oat, optional): 
-000160b0: 5468 6520 636f 7563 6820 616e 676c 6520  The couch angle 
-000160c0: 696e 2064 6567 7265 6573 2e20 4465 6661  in degrees. Defa
-000160d0: 756c 7473 2074 6f20 302e 0d0a 2020 2020  ults to 0...    
-000160e0: 7361 6420 2866 6c6f 6174 2c20 6f70 7469  sad (float, opti
-000160f0: 6f6e 616c 293a 2054 6865 2073 6f75 7263  onal): The sourc
-00016100: 652d 746f 2d61 7869 7320 6469 7374 616e  e-to-axis distan
-00016110: 6365 2069 6e20 6d6d 2e20 4465 6661 756c  ce in mm. Defaul
-00016120: 7473 2074 6f20 3130 3030 2e0d 0a0d 0a20  ts to 1000..... 
-00016130: 2020 2052 6574 7572 6e73 0d0a 2020 2020     Returns..    
-00016140: 2d2d 2d2d 2d2d 2d0d 0a20 2020 206e 702e  -------..    np.
-00016150: 6e64 6172 7261 793a 2054 6865 2070 726f  ndarray: The pro
-00016160: 6a65 6374 696f 6e20 6f66 2074 6865 2042  jection of the B
-00016170: 4220 6f6e 746f 2074 6865 2070 616e 656c  B onto the panel
-00016180: 2061 7420 7468 6520 6769 7665 6e20 5353   at the given SS
-00016190: 442e 0d0a 2020 2020 2020 2020 5468 6520  D...        The 
-000161a0: 6172 7261 7920 6861 7320 7368 6170 6520  array has shape 
-000161b0: 2832 2c29 2077 6865 7265 2074 6865 2066  (2,) where the f
-000161c0: 6972 7374 2065 6c65 6d65 6e74 2069 7320  irst element is 
-000161d0: 7468 6520 7072 6f6a 6563 7469 6f6e 2069  the projection i
-000161e0: 6e20 7468 650d 0a20 2020 2020 2020 206c  n the..        l
-000161f0: 6566 742f 7269 6768 7420 6469 7265 6374  eft/right direct
-00016200: 696f 6e20 616e 6420 7468 6520 7365 636f  ion and the seco
-00016210: 6e64 2065 6c65 6d65 6e74 2069 7320 7468  nd element is th
-00016220: 6520 7072 6f6a 6563 7469 6f6e 2069 6e20  e projection in 
-00016230: 7468 650d 0a20 2020 2020 2020 2073 7570  the..        sup
-00016240: 6572 696f 722f 696e 6665 7269 6f72 2064  erior/inferior d
-00016250: 6972 6563 7469 6f6e 2e0d 0a20 2020 2022  irection...    "
-00016260: 2222 0d0a 2020 2020 2320 4465 6669 6e65  ""..    # Define
-00016270: 2074 6865 2042 4220 706f 7369 7469 6f6e   the BB position
-00016280: 7320 696e 2074 6865 2070 6174 6965 6e74  s in the patient
-00016290: 2063 6f6f 7264 696e 6174 6520 7379 7374   coordinate syst
-000162a0: 656d 2028 6170 2c20 6c72 2c20 7369 290d  em (ap, lr, si).
-000162b0: 0a20 2020 2062 625f 706f 7369 7469 6f6e  .    bb_position
-000162c0: 7320 3d20 6e70 2e61 7272 6179 285b 6f66  s = np.array([of
-000162d0: 6673 6574 5f75 702c 206f 6666 7365 745f  fset_up, offset_
-000162e0: 6c65 6674 2c20 6f66 6673 6574 5f69 6e5d  left, offset_in]
-000162f0: 290d 0a0d 0a20 2020 2023 2041 7070 6c79  )....    # Apply
-00016300: 2074 6865 2072 6f74 6174 696f 6e20 6d61   the rotation ma
-00016310: 7472 6978 2074 6f20 7468 6520 4242 2070  trix to the BB p
-00016320: 6f73 6974 696f 6e73 0d0a 2020 2020 636f  ositions..    co
-00016330: 6c6c 696d 6174 6f72 203d 2030 2020 2320  llimator = 0  # 
-00016340: 436f 6c6c 696d 6174 6f72 2064 6f65 736e  Collimator doesn
-00016350: 2774 2063 6861 6e67 6520 706f 7369 7469  't change positi
-00016360: 6f6e 616c 2070 726f 6a65 6374 696f 6e20  onal projection 
-00016370: 6f6e 746f 2070 616e 656c 0d0a 2020 2020  onto panel..    
-00016380: 726f 7461 7469 6f6e 5f6d 6174 7269 7820  rotation_matrix 
-00016390: 3d20 526f 7461 7469 6f6e 2e66 726f 6d5f  = Rotation.from_
-000163a0: 6575 6c65 7228 0d0a 2020 2020 2020 2020  euler(..        
-000163b0: 2278 797a 222c 205b 636f 7563 682c 2063  "xyz", [couch, c
-000163c0: 6f6c 6c69 6d61 746f 722c 2067 616e 7472  ollimator, gantr
-000163d0: 795d 2c20 6465 6772 6565 733d 5472 7565  y], degrees=True
-000163e0: 0d0a 2020 2020 290d 0a20 2020 2072 6f74  ..    )..    rot
-000163f0: 6174 6564 5f70 6f73 6974 696f 6e73 203d  ated_positions =
-00016400: 2072 6f74 6174 696f 6e5f 6d61 7472 6978   rotation_matrix
-00016410: 2e61 7070 6c79 2862 625f 706f 7369 7469  .apply(bb_positi
-00016420: 6f6e 7329 0d0a 0d0a 2020 2020 2320 4361  ons)....    # Ca
-00016430: 6c63 756c 6174 6520 7468 6520 7072 6f6a  lculate the proj
-00016440: 6563 7469 6f6e 206f 6e74 6f20 7468 6520  ection onto the 
-00016450: 7061 6e65 6c20 6174 2074 6865 2067 6976  panel at the giv
-00016460: 656e 2053 5344 0d0a 2020 2020 6262 5f6d  en SSD..    bb_m
-00016470: 6167 6e69 6669 6361 7469 6f6e 203d 2073  agnification = s
-00016480: 6164 202f 2028 0d0a 2020 2020 2020 2020  ad / (..        
-00016490: 7361 6420 2d20 726f 7461 7465 645f 706f  sad - rotated_po
-000164a0: 7369 7469 6f6e 735b 305d 0d0a 2020 2020  sitions[0]..    
-000164b0: 2920 2023 2044 6973 7461 6e63 6520 6672  )  # Distance fr
-000164c0: 6f6d 2073 6f75 7263 6520 746f 2070 616e  om source to pan
-000164d0: 656c 0d0a 2020 2020 696d 6167 6572 5f70  el..    imager_p
-000164e0: 726f 6a65 6374 696f 6e20 3d20 280d 0a20  rojection = (.. 
-000164f0: 2020 2020 2020 206e 702e 6172 7261 7928         np.array(
-00016500: 5b72 6f74 6174 6564 5f70 6f73 6974 696f  [rotated_positio
-00016510: 6e73 5b31 5d2c 2072 6f74 6174 6564 5f70  ns[1], rotated_p
-00016520: 6f73 6974 696f 6e73 5b32 5d5d 2920 2a20  ositions[2]]) * 
-00016530: 6262 5f6d 6167 6e69 6669 6361 7469 6f6e  bb_magnification
-00016540: 0d0a 2020 2020 290d 0a20 2020 2072 6574  ..    )..    ret
-00016550: 7572 6e20 696d 6167 6572 5f70 726f 6a65  urn imager_proje
-00016560: 6374 696f 6e5b 305d 2c20 696d 6167 6572  ction[0], imager
-00016570: 5f70 726f 6a65 6374 696f 6e5b 315d 0d0a  _projection[1]..
+00011bc0: 2066 2256 6972 7475 616c 2073 6869 6674   f"Virtual shift
+00011bd0: 2061 7070 6c69 6564 2074 6f20 4242 2074   applied to BB t
+00011be0: 6f20 706c 6163 6520 6174 2069 736f 6365  o place at isoce
+00011bf0: 6e74 6572 3a20 7b73 656c 662e 5f76 6972  nter: {self._vir
+00011c00: 7475 616c 5f73 6869 6674 7d22 0a20 2020  tual_shift}".   
+00011c10: 2020 2020 2020 2020 2029 0a20 2020 2020           ).     
+00011c20: 2020 2065 6c73 653a 0a20 2020 2020 2020     else:.       
+00011c30: 2020 2020 2072 6573 756c 742e 6170 7065       result.appe
+00011c40: 6e64 280a 2020 2020 2020 2020 2020 2020  nd(.            
+00011c50: 2020 2020 6622 5368 6966 7420 746f 2069      f"Shift to i
+00011c60: 736f 3a20 6661 6369 6e67 2067 616e 7472  so: facing gantr
+00011c70: 792c 206d 6f76 6520 4242 3a20 7b73 656c  y, move BB: {sel
+00011c80: 662e 6262 5f73 6869 6674 5f69 6e73 7472  f.bb_shift_instr
+00011c90: 7563 7469 6f6e 7328 297d 220a 2020 2020  uctions()}".    
+00011ca0: 2020 2020 2020 2020 290a 2020 2020 2020          ).      
+00011cb0: 2020 7265 7375 6c74 202b 3d20 5b0a 2020    result += [.  
+00011cc0: 2020 2020 2020 2020 2020 6622 4761 6e74            f"Gant
+00011cd0: 7279 2033 4420 6973 6f63 656e 7465 7220  ry 3D isocenter 
+00011ce0: 6469 616d 6574 6572 3a20 7b73 656c 662e  diameter: {self.
+00011cf0: 6761 6e74 7279 5f69 736f 5f73 697a 653a  gantry_iso_size:
+00011d00: 2e32 667d 6d6d 2028 7b6e 756d 5f67 616e  .2f}mm ({num_gan
+00011d10: 7472 795f 696d 6773 7d2f 7b6e 756d 5f69  try_imgs}/{num_i
+00011d20: 6d67 737d 2069 6d61 6765 7320 636f 6e73  mgs} images cons
+00011d30: 6964 6572 6564 2922 2c0a 2020 2020 2020  idered)",.      
+00011d40: 2020 2020 2020 6622 4d61 7869 6d75 6d20        f"Maximum 
+00011d50: 4761 6e74 7279 2052 4d53 2064 6576 6961  Gantry RMS devia
+00011d60: 7469 6f6e 2028 6d6d 293a 207b 6d61 7828  tion (mm): {max(
+00011d70: 7365 6c66 2e61 7869 735f 726d 735f 6465  self.axis_rms_de
+00011d80: 7669 6174 696f 6e28 2841 7869 732e 4741  viation((Axis.GA
+00011d90: 4e54 5259 2c20 4178 6973 2e52 4546 4552  NTRY, Axis.REFER
+00011da0: 454e 4345 2929 293a 2e32 667d 6d6d 222c  ENCE))):.2f}mm",
+00011db0: 0a20 2020 2020 2020 2020 2020 2066 224d  .            f"M
+00011dc0: 6178 696d 756d 2045 5049 4420 524d 5320  aximum EPID RMS 
+00011dd0: 6465 7669 6174 696f 6e20 286d 6d29 3a20  deviation (mm): 
+00011de0: 7b6d 6178 2873 656c 662e 6178 6973 5f72  {max(self.axis_r
+00011df0: 6d73 5f64 6576 6961 7469 6f6e 2841 7869  ms_deviation(Axi
+00011e00: 732e 4550 4944 2929 3a2e 3266 7d6d 6d22  s.EPID)):.2f}mm"
+00011e10: 2c0a 2020 2020 2020 2020 2020 2020 6622  ,.            f"
+00011e20: 4761 6e74 7279 2b43 6f6c 6c69 6d61 746f  Gantry+Collimato
+00011e30: 7220 3344 2069 736f 6365 6e74 6572 2064  r 3D isocenter d
+00011e40: 6961 6d65 7465 723a 207b 7365 6c66 2e67  iameter: {self.g
+00011e50: 616e 7472 795f 636f 6c6c 5f69 736f 5f73  antry_coll_iso_s
+00011e60: 697a 653a 2e32 667d 6d6d 2028 7b6e 756d  ize:.2f}mm ({num
+00011e70: 5f67 616e 7472 795f 636f 6c6c 5f69 6d67  _gantry_coll_img
+00011e80: 737d 2f7b 6e75 6d5f 696d 6773 7d20 696d  s}/{num_imgs} im
+00011e90: 6167 6573 2063 6f6e 7369 6465 7265 6429  ages considered)
+00011ea0: 222c 0a20 2020 2020 2020 2020 2020 2066  ",.            f
+00011eb0: 2243 6f6c 6c69 6d61 746f 7220 3244 2069  "Collimator 2D i
+00011ec0: 736f 6365 6e74 6572 2064 6961 6d65 7465  socenter diamete
+00011ed0: 723a 207b 7365 6c66 2e63 6f6c 6c69 6d61  r: {self.collima
+00011ee0: 746f 725f 6973 6f5f 7369 7a65 3a2e 3266  tor_iso_size:.2f
+00011ef0: 7d6d 6d20 287b 6e75 6d5f 636f 6c6c 5f69  }mm ({num_coll_i
+00011f00: 6d67 737d 2f7b 6e75 6d5f 696d 6773 7d20  mgs}/{num_imgs} 
+00011f10: 696d 6167 6573 2063 6f6e 7369 6465 7265  images considere
+00011f20: 6429 222c 0a20 2020 2020 2020 2020 2020  d)",.           
+00011f30: 2066 224d 6178 696d 756d 2043 6f6c 6c69   f"Maximum Colli
+00011f40: 6d61 746f 7220 524d 5320 6465 7669 6174  mator RMS deviat
+00011f50: 696f 6e20 286d 6d29 3a20 7b6d 6178 2873  ion (mm): {max(s
+00011f60: 656c 662e 6178 6973 5f72 6d73 5f64 6576  elf.axis_rms_dev
+00011f70: 6961 7469 6f6e 2828 4178 6973 2e43 4f4c  iation((Axis.COL
+00011f80: 4c49 4d41 544f 522c 2041 7869 732e 5245  LIMATOR, Axis.RE
+00011f90: 4645 5245 4e43 4529 2929 3a2e 3266 7d22  FERENCE))):.2f}"
+00011fa0: 2c0a 2020 2020 2020 2020 2020 2020 6622  ,.            f"
+00011fb0: 436f 7563 6820 3244 2069 736f 6365 6e74  Couch 2D isocent
+00011fc0: 6572 2064 6961 6d65 7465 723a 207b 7365  er diameter: {se
+00011fd0: 6c66 2e63 6f75 6368 5f69 736f 5f73 697a  lf.couch_iso_siz
+00011fe0: 653a 2e32 667d 6d6d 2028 7b6e 756d 5f63  e:.2f}mm ({num_c
+00011ff0: 6f75 6368 5f69 6d67 737d 2f7b 6e75 6d5f  ouch_imgs}/{num_
+00012000: 696d 6773 7d20 696d 6167 6573 2063 6f6e  imgs} images con
+00012010: 7369 6465 7265 6429 222c 0a20 2020 2020  sidered)",.     
+00012020: 2020 2020 2020 2066 224d 6178 696d 756d         f"Maximum
+00012030: 2043 6f75 6368 2052 4d53 2064 6576 6961   Couch RMS devia
+00012040: 7469 6f6e 2028 6d6d 293a 207b 6d61 7828  tion (mm): {max(
+00012050: 7365 6c66 2e61 7869 735f 726d 735f 6465  self.axis_rms_de
+00012060: 7669 6174 696f 6e28 2841 7869 732e 434f  viation((Axis.CO
+00012070: 5543 482c 2041 7869 732e 5245 4645 5245  UCH, Axis.REFERE
+00012080: 4e43 4529 2929 3a2e 3266 7d22 2c0a 2020  NCE))):.2f}",.  
+00012090: 2020 2020 2020 5d0a 2020 2020 2020 2020        ].        
+000120a0: 6966 206e 6f74 2061 735f 6c69 7374 3a0a  if not as_list:.
+000120b0: 2020 2020 2020 2020 2020 2020 7265 7375              resu
+000120c0: 6c74 203d 2022 5c6e 222e 6a6f 696e 2872  lt = "\n".join(r
+000120d0: 6573 756c 7429 0a20 2020 2020 2020 2072  esult).        r
+000120e0: 6574 7572 6e20 7265 7375 6c74 0a0a 2020  eturn result..  
+000120f0: 2020 6465 6620 5f67 656e 6572 6174 655f    def _generate_
+00012100: 7265 7375 6c74 735f 6461 7461 2873 656c  results_data(sel
+00012110: 6629 202d 3e20 5769 6e73 746f 6e4c 7574  f) -> WinstonLut
+00012120: 7a52 6573 756c 743a 0a20 2020 2020 2020  zResult:.       
+00012130: 2022 2222 5072 6573 656e 7420 7468 6520   """Present the 
+00012140: 7265 7375 6c74 7320 6461 7461 2061 6e64  results data and
+00012150: 206d 6574 6164 6174 6120 6173 2061 2064   metadata as a d
+00012160: 6174 6163 6c61 7373 206f 7220 6469 6374  ataclass or dict
+00012170: 2e0a 2020 2020 2020 2020 5468 6520 6465  ..        The de
+00012180: 6661 756c 7420 7265 7475 726e 2074 7970  fault return typ
+00012190: 6520 6973 2061 2064 6174 6163 6c61 7373  e is a dataclass
+000121a0: 2e22 2222 0a20 2020 2020 2020 2069 6620  .""".        if 
+000121b0: 6e6f 7420 7365 6c66 2e5f 6973 5f61 6e61  not self._is_ana
+000121c0: 6c79 7a65 643a 0a20 2020 2020 2020 2020  lyzed:.         
+000121d0: 2020 2072 6169 7365 2056 616c 7565 4572     raise ValueEr
+000121e0: 726f 7228 2254 6865 2073 6574 2069 7320  ror("The set is 
+000121f0: 6e6f 7420 616e 616c 797a 6564 2e20 5573  not analyzed. Us
+00012200: 6520 2e61 6e61 6c79 7a65 2829 2066 6972  e .analyze() fir
+00012210: 7374 2e22 290a 2020 2020 2020 2020 6e75  st.").        nu
+00012220: 6d5f 6761 6e74 7279 5f69 6d67 7320 3d20  m_gantry_imgs = 
+00012230: 7365 6c66 2e5f 6765 745f 696d 6167 6573  self._get_images
+00012240: 2861 7869 733d 2841 7869 732e 4741 4e54  (axis=(Axis.GANT
+00012250: 5259 2c20 4178 6973 2e52 4546 4552 454e  RY, Axis.REFEREN
+00012260: 4345 2929 5b30 5d0a 2020 2020 2020 2020  CE))[0].        
+00012270: 6e75 6d5f 6761 6e74 7279 5f63 6f6c 6c5f  num_gantry_coll_
+00012280: 696d 6773 203d 2073 656c 662e 5f67 6574  imgs = self._get
+00012290: 5f69 6d61 6765 7328 0a20 2020 2020 2020  _images(.       
+000122a0: 2020 2020 2061 7869 733d 2841 7869 732e       axis=(Axis.
+000122b0: 4741 4e54 5259 2c20 4178 6973 2e43 4f4c  GANTRY, Axis.COL
+000122c0: 4c49 4d41 544f 522c 2041 7869 732e 4742  LIMATOR, Axis.GB
+000122d0: 5f43 4f4d 424f 2c20 4178 6973 2e52 4546  _COMBO, Axis.REF
+000122e0: 4552 454e 4345 290a 2020 2020 2020 2020  ERENCE).        
+000122f0: 295b 305d 0a20 2020 2020 2020 206e 756d  )[0].        num
+00012300: 5f63 6f6c 6c5f 696d 6773 203d 2073 656c  _coll_imgs = sel
+00012310: 662e 5f67 6574 5f69 6d61 6765 7328 6178  f._get_images(ax
+00012320: 6973 3d28 4178 6973 2e43 4f4c 4c49 4d41  is=(Axis.COLLIMA
+00012330: 544f 522c 2041 7869 732e 5245 4645 5245  TOR, Axis.REFERE
+00012340: 4e43 4529 295b 305d 0a20 2020 2020 2020  NCE))[0].       
+00012350: 206e 756d 5f63 6f75 6368 5f69 6d67 7320   num_couch_imgs 
+00012360: 3d20 7365 6c66 2e5f 6765 745f 696d 6167  = self._get_imag
+00012370: 6573 2861 7869 733d 2841 7869 732e 434f  es(axis=(Axis.CO
+00012380: 5543 482c 2041 7869 732e 5245 4645 5245  UCH, Axis.REFERE
+00012390: 4e43 4529 295b 305d 0a0a 2020 2020 2020  NCE))[0]..      
+000123a0: 2020 696e 6469 7669 6475 616c 5f69 6d61    individual_ima
+000123b0: 6765 5f64 6174 6120 3d20 5b69 2e72 6573  ge_data = [i.res
+000123c0: 756c 7473 5f64 6174 6128 2920 666f 7220  ults_data() for 
+000123d0: 6920 696e 2073 656c 662e 696d 6167 6573  i in self.images
+000123e0: 5d0a 0a20 2020 2020 2020 2072 6574 7572  ]..        retur
+000123f0: 6e20 5769 6e73 746f 6e4c 7574 7a52 6573  n WinstonLutzRes
+00012400: 756c 7428 0a20 2020 2020 2020 2020 2020  ult(.           
+00012410: 206e 756d 5f74 6f74 616c 5f69 6d61 6765   num_total_image
+00012420: 733d 6c65 6e28 7365 6c66 2e69 6d61 6765  s=len(self.image
+00012430: 7329 2c0a 2020 2020 2020 2020 2020 2020  s),.            
+00012440: 6e75 6d5f 6761 6e74 7279 5f69 6d61 6765  num_gantry_image
+00012450: 733d 6e75 6d5f 6761 6e74 7279 5f69 6d67  s=num_gantry_img
+00012460: 732c 0a20 2020 2020 2020 2020 2020 206e  s,.            n
+00012470: 756d 5f63 6f6c 6c5f 696d 6167 6573 3d6e  um_coll_images=n
+00012480: 756d 5f63 6f6c 6c5f 696d 6773 2c0a 2020  um_coll_imgs,.  
+00012490: 2020 2020 2020 2020 2020 6e75 6d5f 6761            num_ga
+000124a0: 6e74 7279 5f63 6f6c 6c5f 696d 6167 6573  ntry_coll_images
+000124b0: 3d6e 756d 5f67 616e 7472 795f 636f 6c6c  =num_gantry_coll
+000124c0: 5f69 6d67 732c 0a20 2020 2020 2020 2020  _imgs,.         
+000124d0: 2020 206e 756d 5f63 6f75 6368 5f69 6d61     num_couch_ima
+000124e0: 6765 733d 6e75 6d5f 636f 7563 685f 696d  ges=num_couch_im
+000124f0: 6773 2c0a 2020 2020 2020 2020 2020 2020  gs,.            
+00012500: 6d61 785f 3264 5f63 6178 5f74 6f5f 6262  max_2d_cax_to_bb
+00012510: 5f6d 6d3d 7365 6c66 2e63 6178 3262 625f  _mm=self.cax2bb_
+00012520: 6469 7374 616e 6365 2822 6d61 7822 292c  distance("max"),
+00012530: 0a20 2020 2020 2020 2020 2020 206d 6564  .            med
+00012540: 6961 6e5f 3264 5f63 6178 5f74 6f5f 6262  ian_2d_cax_to_bb
+00012550: 5f6d 6d3d 7365 6c66 2e63 6178 3262 625f  _mm=self.cax2bb_
+00012560: 6469 7374 616e 6365 2822 6d65 6469 616e  distance("median
+00012570: 2229 2c0a 2020 2020 2020 2020 2020 2020  "),.            
+00012580: 6d65 616e 5f32 645f 6361 785f 746f 5f62  mean_2d_cax_to_b
+00012590: 625f 6d6d 3d73 656c 662e 6361 7832 6262  b_mm=self.cax2bb
+000125a0: 5f64 6973 7461 6e63 6528 226d 6561 6e22  _distance("mean"
+000125b0: 292c 0a20 2020 2020 2020 2020 2020 206d  ),.            m
+000125c0: 6178 5f32 645f 6361 785f 746f 5f65 7069  ax_2d_cax_to_epi
+000125d0: 645f 6d6d 3d73 656c 662e 6361 7832 6570  d_mm=self.cax2ep
+000125e0: 6964 5f64 6973 7461 6e63 6528 226d 6178  id_distance("max
+000125f0: 2229 2c0a 2020 2020 2020 2020 2020 2020  "),.            
+00012600: 6d65 6469 616e 5f32 645f 6361 785f 746f  median_2d_cax_to
+00012610: 5f65 7069 645f 6d6d 3d73 656c 662e 6361  _epid_mm=self.ca
+00012620: 7832 6570 6964 5f64 6973 7461 6e63 6528  x2epid_distance(
+00012630: 226d 6564 6961 6e22 292c 0a20 2020 2020  "median"),.     
+00012640: 2020 2020 2020 206d 6561 6e5f 3264 5f63         mean_2d_c
+00012650: 6178 5f74 6f5f 6570 6964 5f6d 6d3d 7365  ax_to_epid_mm=se
+00012660: 6c66 2e63 6178 3265 7069 645f 6469 7374  lf.cax2epid_dist
+00012670: 616e 6365 2822 6d65 616e 2229 2c0a 2020  ance("mean"),.  
+00012680: 2020 2020 2020 2020 2020 636f 6c6c 5f32            coll_2
+00012690: 645f 6973 6f5f 6469 616d 6574 6572 5f6d  d_iso_diameter_m
+000126a0: 6d3d 7365 6c66 2e63 6f6c 6c69 6d61 746f  m=self.collimato
+000126b0: 725f 6973 6f5f 7369 7a65 2c0a 2020 2020  r_iso_size,.    
+000126c0: 2020 2020 2020 2020 636f 7563 685f 3264          couch_2d
+000126d0: 5f69 736f 5f64 6961 6d65 7465 725f 6d6d  _iso_diameter_mm
+000126e0: 3d73 656c 662e 636f 7563 685f 6973 6f5f  =self.couch_iso_
+000126f0: 7369 7a65 2c0a 2020 2020 2020 2020 2020  size,.          
+00012700: 2020 6761 6e74 7279 5f33 645f 6973 6f5f    gantry_3d_iso_
+00012710: 6469 616d 6574 6572 5f6d 6d3d 7365 6c66  diameter_mm=self
+00012720: 2e67 616e 7472 795f 6973 6f5f 7369 7a65  .gantry_iso_size
+00012730: 2c0a 2020 2020 2020 2020 2020 2020 6761  ,.            ga
+00012740: 6e74 7279 5f63 6f6c 6c5f 3364 5f69 736f  ntry_coll_3d_iso
+00012750: 5f64 6961 6d65 7465 725f 6d6d 3d73 656c  _diameter_mm=sel
+00012760: 662e 6761 6e74 7279 5f63 6f6c 6c5f 6973  f.gantry_coll_is
+00012770: 6f5f 7369 7a65 2c0a 2020 2020 2020 2020  o_size,.        
+00012780: 2020 2020 6d61 785f 6761 6e74 7279 5f72      max_gantry_r
+00012790: 6d73 5f64 6576 6961 7469 6f6e 5f6d 6d3d  ms_deviation_mm=
+000127a0: 6d61 7828 0a20 2020 2020 2020 2020 2020  max(.           
+000127b0: 2020 2020 2073 656c 662e 6178 6973 5f72       self.axis_r
+000127c0: 6d73 5f64 6576 6961 7469 6f6e 2861 7869  ms_deviation(axi
+000127d0: 733d 2841 7869 732e 4741 4e54 5259 2c20  s=(Axis.GANTRY, 
+000127e0: 4178 6973 2e52 4546 4552 454e 4345 2929  Axis.REFERENCE))
+000127f0: 0a20 2020 2020 2020 2020 2020 2029 2c0a  .            ),.
+00012800: 2020 2020 2020 2020 2020 2020 6d61 785f              max_
+00012810: 636f 6c6c 5f72 6d73 5f64 6576 6961 7469  coll_rms_deviati
+00012820: 6f6e 5f6d 6d3d 6d61 7828 0a20 2020 2020  on_mm=max(.     
+00012830: 2020 2020 2020 2020 2020 2073 656c 662e             self.
+00012840: 6178 6973 5f72 6d73 5f64 6576 6961 7469  axis_rms_deviati
+00012850: 6f6e 2861 7869 733d 2841 7869 732e 434f  on(axis=(Axis.CO
+00012860: 4c4c 494d 4154 4f52 2c20 4178 6973 2e52  LLIMATOR, Axis.R
+00012870: 4546 4552 454e 4345 2929 0a20 2020 2020  EFERENCE)).     
+00012880: 2020 2020 2020 2029 2c0a 2020 2020 2020         ),.      
+00012890: 2020 2020 2020 6d61 785f 636f 7563 685f        max_couch_
+000128a0: 726d 735f 6465 7669 6174 696f 6e5f 6d6d  rms_deviation_mm
+000128b0: 3d6d 6178 280a 2020 2020 2020 2020 2020  =max(.          
+000128c0: 2020 2020 2020 7365 6c66 2e61 7869 735f        self.axis_
+000128d0: 726d 735f 6465 7669 6174 696f 6e28 6178  rms_deviation(ax
+000128e0: 6973 3d28 4178 6973 2e43 4f55 4348 2c20  is=(Axis.COUCH, 
+000128f0: 4178 6973 2e52 4546 4552 454e 4345 2929  Axis.REFERENCE))
+00012900: 0a20 2020 2020 2020 2020 2020 2029 2c0a  .            ),.
+00012910: 2020 2020 2020 2020 2020 2020 6d61 785f              max_
+00012920: 6570 6964 5f72 6d73 5f64 6576 6961 7469  epid_rms_deviati
+00012930: 6f6e 5f6d 6d3d 6d61 7828 7365 6c66 2e61  on_mm=max(self.a
+00012940: 7869 735f 726d 735f 6465 7669 6174 696f  xis_rms_deviatio
+00012950: 6e28 6178 6973 3d41 7869 732e 4550 4944  n(axis=Axis.EPID
+00012960: 2929 2c0a 2020 2020 2020 2020 2020 2020  )),.            
+00012970: 696d 6167 655f 6465 7461 696c 733d 696e  image_details=in
+00012980: 6469 7669 6475 616c 5f69 6d61 6765 5f64  dividual_image_d
+00012990: 6174 612c 0a20 2020 2020 2020 2020 2020  ata,.           
+000129a0: 206b 6579 6564 5f69 6d61 6765 5f64 6574   keyed_image_det
+000129b0: 6169 6c73 3d73 656c 662e 5f67 656e 6572  ails=self._gener
+000129c0: 6174 655f 6b65 7965 645f 696d 6167 6573  ate_keyed_images
+000129d0: 2869 6e64 6976 6964 7561 6c5f 696d 6167  (individual_imag
+000129e0: 655f 6461 7461 292c 0a20 2020 2020 2020  e_data),.       
+000129f0: 2029 0a0a 2020 2020 6465 6620 5f67 656e   )..    def _gen
+00012a00: 6572 6174 655f 6b65 7965 645f 696d 6167  erate_keyed_imag
+00012a10: 6573 280a 2020 2020 2020 2020 7365 6c66  es(.        self
+00012a20: 2c20 696e 6469 7669 6475 616c 5f69 6d61  , individual_ima
+00012a30: 6765 5f64 6174 613a 206c 6973 745b 5769  ge_data: list[Wi
+00012a40: 6e73 746f 6e4c 7574 7a32 4452 6573 756c  nstonLutz2DResul
+00012a50: 745d 0a20 2020 2029 202d 3e20 6469 6374  t].    ) -> dict
+00012a60: 5b73 7472 2c20 5769 6e73 746f 6e4c 7574  [str, WinstonLut
+00012a70: 7a32 4452 6573 756c 745d 3a0a 2020 2020  z2DResult]:.    
+00012a80: 2020 2020 2222 2247 656e 6572 6174 6520      """Generate 
+00012a90: 6120 6469 6374 2077 6865 7265 2065 6163  a dict where eac
+00012aa0: 6820 6b65 7920 6973 2062 6173 6564 206f  h key is based o
+00012ab0: 6e20 7468 6520 6178 6573 2076 616c 7565  n the axes value
+00012ac0: 7320 616e 6420 7468 6520 6b65 7920 6973  s and the key is
+00012ad0: 2061 6e20 696d 6167 652e 2055 7365 6420   an image. Used 
+00012ae0: 696e 2074 6865 2072 6573 756c 7473 5f64  in the results_d
+00012af0: 6174 6120 6d65 7468 6f64 2e0a 2020 2020  ata method..    
+00012b00: 2020 2020 5765 2063 616e 2774 2064 6f20      We can't do 
+00012b10: 6120 7369 6d70 6c65 2064 6963 7420 636f  a simple dict co
+00012b20: 6d70 7265 6865 6e73 696f 6e20 6265 6361  mprehension beca
+00012b30: 7573 6520 7765 206d 6179 2068 6176 6520  use we may have 
+00012b40: 6475 706c 6963 6174 6520 6178 6573 2073  duplicate axes s
+00012b50: 6574 732e 2057 6520 7061 7373 2069 6e64  ets. We pass ind
+00012b60: 6976 6964 7561 6c20 6461 7461 0a20 2020  ividual data.   
+00012b70: 2020 2020 2062 6563 6175 7365 2077 6520       because we 
+00012b80: 6d61 7920 6861 7665 2061 6c72 6561 6479  may have already
+00012b90: 2063 6f6e 7665 7274 6564 2074 6f20 6120   converted to a 
+00012ba0: 6469 6374 3b20 7765 2064 6f6e 2774 2077  dict; we don't w
+00012bb0: 616e 7420 746f 2064 6f20 7468 6174 2061  ant to do that a
+00012bc0: 6761 696e 2e0a 2020 2020 2020 2020 2222  gain..        ""
+00012bd0: 220a 2020 2020 2020 2020 6461 7461 203d  ".        data =
+00012be0: 207b 7d0a 2020 2020 2020 2020 666f 7220   {}.        for 
+00012bf0: 696d 675f 6964 782c 2069 6d67 2069 6e20  img_idx, img in 
+00012c00: 656e 756d 6572 6174 6528 7365 6c66 2e69  enumerate(self.i
+00012c10: 6d61 6765 7329 3a0a 2020 2020 2020 2020  mages):.        
+00012c20: 2020 2020 6b65 7920 3d20 6622 477b 696d      key = f"G{im
+00012c30: 672e 6761 6e74 7279 5f61 6e67 6c65 7d42  g.gantry_angle}B
+00012c40: 7b69 6d67 2e63 6f6c 6c69 6d61 746f 725f  {img.collimator_
+00012c50: 616e 676c 657d 507b 696d 672e 636f 7563  angle}P{img.couc
+00012c60: 685f 616e 676c 657d 220a 2020 2020 2020  h_angle}".      
+00012c70: 2020 2020 2020 7375 6666 6978 203d 2022        suffix = "
+00012c80: 220a 2020 2020 2020 2020 2020 2020 6964  ".            id
+00012c90: 7820 3d20 310a 2020 2020 2020 2020 2020  x = 1.          
+00012ca0: 2020 7768 696c 6520 6b65 7920 2b20 7375    while key + su
+00012cb0: 6666 6978 2069 6e20 6461 7461 2e6b 6579  ffix in data.key
+00012cc0: 7328 293a 0a20 2020 2020 2020 2020 2020  s():.           
+00012cd0: 2020 2020 2073 7566 6669 7820 3d20 6622       suffix = f"
+00012ce0: 5f7b 6964 787d 220a 2020 2020 2020 2020  _{idx}".        
+00012cf0: 2020 2020 2020 2020 6964 7820 2b3d 2031          idx += 1
+00012d00: 0a20 2020 2020 2020 2020 2020 2064 6174  .            dat
+00012d10: 615b 6b65 7920 2b20 7375 6666 6978 5d20  a[key + suffix] 
+00012d20: 3d20 696e 6469 7669 6475 616c 5f69 6d61  = individual_ima
+00012d30: 6765 5f64 6174 615b 696d 675f 6964 785d  ge_data[img_idx]
+00012d40: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
+00012d50: 6461 7461 0a0a 2020 2020 6465 6620 7075  data..    def pu
+00012d60: 626c 6973 685f 7064 6628 0a20 2020 2020  blish_pdf(.     
+00012d70: 2020 2073 656c 662c 0a20 2020 2020 2020     self,.       
+00012d80: 2066 696c 656e 616d 653a 2073 7472 2c0a   filename: str,.
+00012d90: 2020 2020 2020 2020 6e6f 7465 733a 2073          notes: s
+00012da0: 7472 207c 206c 6973 745b 7374 725d 207c  tr | list[str] |
+00012db0: 204e 6f6e 6520 3d20 4e6f 6e65 2c0a 2020   None = None,.  
+00012dc0: 2020 2020 2020 6f70 656e 5f66 696c 653a        open_file:
+00012dd0: 2062 6f6f 6c20 3d20 4661 6c73 652c 0a20   bool = False,. 
+00012de0: 2020 2020 2020 206d 6574 6164 6174 613a         metadata:
+00012df0: 2064 6963 7420 7c20 4e6f 6e65 203d 204e   dict | None = N
+00012e00: 6f6e 652c 0a20 2020 2020 2020 206c 6f67  one,.        log
+00012e10: 6f3a 2050 6174 6820 7c20 7374 7220 7c20  o: Path | str | 
+00012e20: 4e6f 6e65 203d 204e 6f6e 652c 0a20 2020  None = None,.   
+00012e30: 2029 3a0a 2020 2020 2020 2020 2222 2250   ):.        """P
+00012e40: 7562 6c69 7368 2028 7072 696e 7429 2061  ublish (print) a
+00012e50: 2050 4446 2063 6f6e 7461 696e 696e 6720   PDF containing 
+00012e60: 7468 6520 616e 616c 7973 6973 2c20 696d  the analysis, im
+00012e70: 6167 6573 2c20 616e 6420 7175 616e 7469  ages, and quanti
+00012e80: 7461 7469 7665 2072 6573 756c 7473 2e0a  tative results..
+00012e90: 0a20 2020 2020 2020 2050 6172 616d 6574  .        Paramet
+00012ea0: 6572 730a 2020 2020 2020 2020 2d2d 2d2d  ers.        ----
+00012eb0: 2d2d 2d2d 2d2d 0a20 2020 2020 2020 2066  ------.        f
+00012ec0: 696c 656e 616d 6520 3a20 2873 7472 2c20  ilename : (str, 
+00012ed0: 6669 6c65 2d6c 696b 6520 6f62 6a65 6374  file-like object
+00012ee0: 7d0a 2020 2020 2020 2020 2020 2020 5468  }.            Th
+00012ef0: 6520 6669 6c65 2074 6f20 7772 6974 6520  e file to write 
+00012f00: 7468 6520 7265 7375 6c74 7320 746f 2e0a  the results to..
+00012f10: 2020 2020 2020 2020 6e6f 7465 7320 3a20          notes : 
+00012f20: 7374 722c 206c 6973 7420 6f66 2073 7472  str, list of str
+00012f30: 696e 6773 0a20 2020 2020 2020 2020 2020  ings.           
+00012f40: 2054 6578 743b 2069 6620 7374 722c 2070   Text; if str, p
+00012f50: 7269 6e74 7320 7369 6e67 6c65 206c 696e  rints single lin
+00012f60: 652e 0a20 2020 2020 2020 2020 2020 2049  e..            I
+00012f70: 6620 6c69 7374 206f 6620 7374 7269 6e67  f list of string
+00012f80: 732c 2065 6163 6820 6c69 7374 2069 7465  s, each list ite
+00012f90: 6d20 6973 2070 7269 6e74 6564 206f 6e20  m is printed on 
+00012fa0: 6974 7320 6f77 6e20 6c69 6e65 2e0a 2020  its own line..  
+00012fb0: 2020 2020 2020 6f70 656e 5f66 696c 6520        open_file 
+00012fc0: 3a20 626f 6f6c 0a20 2020 2020 2020 2020  : bool.         
+00012fd0: 2020 2057 6865 7468 6572 2074 6f20 6f70     Whether to op
+00012fe0: 656e 2074 6865 2066 696c 6520 7573 696e  en the file usin
+00012ff0: 6720 7468 6520 6465 6661 756c 7420 7072  g the default pr
+00013000: 6f67 7261 6d20 6166 7465 7220 6372 6561  ogram after crea
+00013010: 7469 6f6e 2e0a 2020 2020 2020 2020 6d65  tion..        me
+00013020: 7461 6461 7461 203a 2064 6963 740a 2020  tadata : dict.  
+00013030: 2020 2020 2020 2020 2020 4578 7472 6120            Extra 
+00013040: 6461 7461 2074 6f20 6265 2070 6173 7365  data to be passe
+00013050: 6420 616e 6420 7368 6f77 6e20 696e 2074  d and shown in t
+00013060: 6865 2050 4446 2e20 5468 6520 6b65 7920  he PDF. The key 
+00013070: 616e 6420 7661 6c75 6520 7769 6c6c 2062  and value will b
+00013080: 6520 7368 6f77 6e20 7769 7468 2061 2063  e shown with a c
+00013090: 6f6c 6f6e 2e0a 2020 2020 2020 2020 2020  olon..          
+000130a0: 2020 452e 672e 2070 6173 7369 6e67 207b    E.g. passing {
+000130b0: 2741 7574 686f 7227 3a20 274a 616d 6573  'Author': 'James
+000130c0: 272c 2027 556e 6974 273a 2027 5472 7565  ', 'Unit': 'True
+000130d0: 4265 616d 277d 2077 6f75 6c64 2072 6573  Beam'} would res
+000130e0: 756c 7420 696e 2074 6578 7420 696e 2074  ult in text in t
+000130f0: 6865 2050 4446 206c 696b 653a 0a20 2020  he PDF like:.   
+00013100: 2020 2020 2020 2020 202d 2d2d 2d2d 2d2d           -------
+00013110: 2d2d 2d2d 2d2d 2d0a 2020 2020 2020 2020  -------.        
+00013120: 2020 2020 4175 7468 6f72 3a20 4a61 6d65      Author: Jame
+00013130: 730a 2020 2020 2020 2020 2020 2020 556e  s.            Un
+00013140: 6974 3a20 5472 7565 4265 616d 0a20 2020  it: TrueBeam.   
+00013150: 2020 2020 2020 2020 202d 2d2d 2d2d 2d2d           -------
+00013160: 2d2d 2d2d 2d2d 2d0a 2020 2020 2020 2020  -------.        
+00013170: 6c6f 676f 3a20 5061 7468 2c20 7374 720a  logo: Path, str.
+00013180: 2020 2020 2020 2020 2020 2020 4120 6375              A cu
+00013190: 7374 6f6d 206c 6f67 6f20 746f 2075 7365  stom logo to use
+000131a0: 2069 6e20 7468 6520 5044 4620 7265 706f   in the PDF repo
+000131b0: 7274 2e20 4966 206e 6f74 6869 6e67 2069  rt. If nothing i
+000131c0: 7320 7061 7373 6564 2c20 7468 6520 6465  s passed, the de
+000131d0: 6661 756c 7420 7079 6c69 6e61 6320 6c6f  fault pylinac lo
+000131e0: 676f 2069 7320 7573 6564 2e0a 2020 2020  go is used..    
+000131f0: 2020 2020 2222 220a 2020 2020 2020 2020      """.        
+00013200: 6966 206e 6f74 2073 656c 662e 5f69 735f  if not self._is_
+00013210: 616e 616c 797a 6564 3a0a 2020 2020 2020  analyzed:.      
+00013220: 2020 2020 2020 7261 6973 6520 5661 6c75        raise Valu
+00013230: 6545 7272 6f72 2822 5468 6520 7365 7420  eError("The set 
+00013240: 6973 206e 6f74 2061 6e61 6c79 7a65 642e  is not analyzed.
+00013250: 2055 7365 202e 616e 616c 797a 6528 2920   Use .analyze() 
+00013260: 6669 7273 742e 2229 0a20 2020 2020 2020  first.").       
+00013270: 2070 6c74 2e69 6f66 6628 290a 2020 2020   plt.ioff().    
+00013280: 2020 2020 7469 746c 6520 3d20 2257 696e      title = "Win
+00013290: 7374 6f6e 2d4c 7574 7a20 416e 616c 7973  ston-Lutz Analys
+000132a0: 6973 220a 2020 2020 2020 2020 6361 6e76  is".        canv
+000132b0: 6173 203d 2070 6466 2e50 796c 696e 6163  as = pdf.Pylinac
+000132c0: 4361 6e76 6173 280a 2020 2020 2020 2020  Canvas(.        
+000132d0: 2020 2020 6669 6c65 6e61 6d65 2c20 7061      filename, pa
+000132e0: 6765 5f74 6974 6c65 3d74 6974 6c65 2c20  ge_title=title, 
+000132f0: 6d65 7461 6461 7461 3d6d 6574 6164 6174  metadata=metadat
+00013300: 612c 206c 6f67 6f3d 6c6f 676f 0a20 2020  a, logo=logo.   
+00013310: 2020 2020 2029 0a20 2020 2020 2020 2074       ).        t
+00013320: 6578 7420 3d20 7365 6c66 2e72 6573 756c  ext = self.resul
+00013330: 7473 2861 735f 6c69 7374 3d54 7275 6529  ts(as_list=True)
+00013340: 0a20 2020 2020 2020 2063 616e 7661 732e  .        canvas.
+00013350: 6164 645f 7465 7874 2874 6578 743d 7465  add_text(text=te
+00013360: 7874 2c20 6c6f 6361 7469 6f6e 3d28 372c  xt, location=(7,
+00013370: 2032 352e 3529 290a 2020 2020 2020 2020   25.5)).        
+00013380: 2320 6472 6177 2073 756d 6d61 7279 2069  # draw summary i
+00013390: 6d61 6765 206f 6e20 3173 7420 7061 6765  mage on 1st page
+000133a0: 0a20 2020 2020 2020 2064 6174 6120 3d20  .        data = 
+000133b0: 696f 2e42 7974 6573 494f 2829 0a20 2020  io.BytesIO().   
+000133c0: 2020 2020 2073 656c 662e 7361 7665 5f73       self.save_s
+000133d0: 756d 6d61 7279 2864 6174 612c 2066 6967  ummary(data, fig
+000133e0: 5f73 697a 653d 2838 2c20 3829 290a 2020  _size=(8, 8)).  
+000133f0: 2020 2020 2020 6361 6e76 6173 2e61 6464        canvas.add
+00013400: 5f69 6d61 6765 2869 6d61 6765 5f64 6174  _image(image_dat
+00013410: 613d 6461 7461 2c20 6c6f 6361 7469 6f6e  a=data, location
+00013420: 3d28 322c 2033 292c 2064 696d 656e 7369  =(2, 3), dimensi
+00013430: 6f6e 733d 2831 362c 2031 3629 290a 2020  ons=(16, 16)).  
+00013440: 2020 2020 2020 6966 206e 6f74 6573 2069        if notes i
+00013450: 7320 6e6f 7420 4e6f 6e65 3a0a 2020 2020  s not None:.    
+00013460: 2020 2020 2020 2020 6361 6e76 6173 2e61          canvas.a
+00013470: 6464 5f74 6578 7428 7465 7874 3d22 4e6f  dd_text(text="No
+00013480: 7465 733a 222c 206c 6f63 6174 696f 6e3d  tes:", location=
+00013490: 2831 2c20 342e 3529 2c20 666f 6e74 5f73  (1, 4.5), font_s
+000134a0: 697a 653d 3134 290a 2020 2020 2020 2020  ize=14).        
+000134b0: 2020 2020 6361 6e76 6173 2e61 6464 5f74      canvas.add_t
+000134c0: 6578 7428 7465 7874 3d6e 6f74 6573 2c20  ext(text=notes, 
+000134d0: 6c6f 6361 7469 6f6e 3d28 312c 2034 2929  location=(1, 4))
+000134e0: 0a20 2020 2020 2020 2023 2061 6464 206d  .        # add m
+000134f0: 6f72 6520 7061 6765 7320 7368 6f77 696e  ore pages showin
+00013500: 6720 696e 6469 7669 6475 616c 2061 7869  g individual axi
+00013510: 7320 696d 6167 6573 0a20 2020 2020 2020  s images.       
+00013520: 2066 6f72 2061 7820 696e 2028 0a20 2020   for ax in (.   
+00013530: 2020 2020 2020 2020 2041 7869 732e 4741           Axis.GA
+00013540: 4e54 5259 2c0a 2020 2020 2020 2020 2020  NTRY,.          
+00013550: 2020 4178 6973 2e43 4f4c 4c49 4d41 544f    Axis.COLLIMATO
+00013560: 522c 0a20 2020 2020 2020 2020 2020 2041  R,.            A
+00013570: 7869 732e 434f 5543 482c 0a20 2020 2020  xis.COUCH,.     
+00013580: 2020 2020 2020 2041 7869 732e 4742 5f43         Axis.GB_C
+00013590: 4f4d 424f 2c0a 2020 2020 2020 2020 2020  OMBO,.          
+000135a0: 2020 4178 6973 2e47 4250 5f43 4f4d 424f    Axis.GBP_COMBO
+000135b0: 2c0a 2020 2020 2020 2020 293a 0a20 2020  ,.        ):.   
+000135c0: 2020 2020 2020 2020 2069 6620 7365 6c66           if self
+000135d0: 2e5f 636f 6e74 6169 6e73 5f61 7869 735f  ._contains_axis_
+000135e0: 696d 6167 6573 2861 7829 3a0a 2020 2020  images(ax):.    
+000135f0: 2020 2020 2020 2020 2020 2020 6361 6e76              canv
+00013600: 6173 2e61 6464 5f6e 6577 5f70 6167 6528  as.add_new_page(
+00013610: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
+00013620: 2020 6461 7461 203d 2069 6f2e 4279 7465    data = io.Byte
+00013630: 7349 4f28 290a 2020 2020 2020 2020 2020  sIO().          
+00013640: 2020 2020 2020 7365 6c66 2e73 6176 655f        self.save_
+00013650: 696d 6167 6573 2864 6174 612c 2061 7869  images(data, axi
+00013660: 733d 6178 290a 2020 2020 2020 2020 2020  s=ax).          
+00013670: 2020 2020 2020 6361 6e76 6173 2e61 6464        canvas.add
+00013680: 5f69 6d61 6765 2864 6174 612c 206c 6f63  _image(data, loc
+00013690: 6174 696f 6e3d 2832 2c20 3729 2c20 6469  ation=(2, 7), di
+000136a0: 6d65 6e73 696f 6e73 3d28 3138 2c20 3138  mensions=(18, 18
+000136b0: 2929 0a0a 2020 2020 2020 2020 6361 6e76  ))..        canv
+000136c0: 6173 2e66 696e 6973 6828 290a 0a20 2020  as.finish()..   
+000136d0: 2020 2020 2069 6620 6f70 656e 5f66 696c       if open_fil
+000136e0: 653a 0a20 2020 2020 2020 2020 2020 2077  e:.            w
+000136f0: 6562 6272 6f77 7365 722e 6f70 656e 2866  ebbrowser.open(f
+00013700: 696c 656e 616d 6529 0a0a 2020 2020 6465  ilename)..    de
+00013710: 6620 5f63 6f6e 7461 696e 735f 6178 6973  f _contains_axis
+00013720: 5f69 6d61 6765 7328 7365 6c66 2c20 6178  _images(self, ax
+00013730: 6973 3a20 4178 6973 203d 2041 7869 732e  is: Axis = Axis.
+00013740: 4741 4e54 5259 2920 2d3e 2062 6f6f 6c3a  GANTRY) -> bool:
+00013750: 0a20 2020 2020 2020 2022 2222 5265 7475  .        """Retu
+00013760: 726e 2077 6865 7468 6572 206f 7220 6e6f  rn whether or no
+00013770: 7420 7468 6520 7365 7420 6f66 2057 4c20  t the set of WL 
+00013780: 696d 6167 6573 2063 6f6e 7461 696e 7320  images contains 
+00013790: 696d 6167 6573 2070 6572 7461 696e 696e  images pertainin
+000137a0: 6720 746f 2061 2067 6976 656e 2061 7869  g to a given axi
+000137b0: 7322 2222 0a20 2020 2020 2020 2072 6574  s""".        ret
+000137c0: 7572 6e20 616e 7928 5472 7565 2066 6f72  urn any(True for
+000137d0: 2069 6d61 6765 2069 6e20 7365 6c66 2e69   image in self.i
+000137e0: 6d61 6765 7320 6966 2069 6d61 6765 2e76  mages if image.v
+000137f0: 6172 6961 626c 655f 6178 6973 2069 6e20  ariable_axis in 
+00013800: 2861 7869 732c 2929 0a0a 0a63 6c61 7373  (axis,))...class
+00013810: 2057 696e 7374 6f6e 4c75 747a 4d75 6c74   WinstonLutzMult
+00013820: 6954 6172 6765 744d 756c 7469 4669 656c  iTargetMultiFiel
+00013830: 6449 6d61 6765 2857 4c42 6173 6549 6d61  dImage(WLBaseIma
+00013840: 6765 293a 0a20 2020 2022 2222 4120 3244  ge):.    """A 2D
+00013850: 2069 6d61 6765 206f 6620 6120 574c 2064   image of a WL d
+00013860: 656c 6976 6572 792c 2062 7574 2077 6865  elivery, but whe
+00013870: 7265 206d 756c 7469 706c 6520 4242 7320  re multiple BBs 
+00013880: 6172 6520 696e 2075 7365 2e22 2222 0a0a  are in use."""..
+00013890: 2020 2020 6465 7465 6374 696f 6e5f 636f      detection_co
+000138a0: 6e64 6974 696f 6e73 203d 205b 6973 5f72  nditions = [is_r
+000138b0: 6f75 6e64 2c20 6973 5f73 796d 6d65 7472  ound, is_symmetr
+000138c0: 6963 2c20 6973 5f6d 6f64 6573 745f 7369  ic, is_modest_si
+000138d0: 7a65 5d0a 2020 2020 6669 656c 645f 636f  ze].    field_co
+000138e0: 6e64 6974 696f 6e73 203d 205b 6973 5f73  nditions = [is_s
+000138f0: 7175 6172 652c 2069 735f 7269 6768 745f  quare, is_right_
+00013900: 7371 7561 7265 5f73 697a 655d 0a0a 2020  square_size]..  
+00013910: 2020 6465 6620 6669 6e64 5f66 6965 6c64    def find_field
+00013920: 5f63 656e 7472 6f69 6473 2873 656c 662c  _centroids(self,
+00013930: 2069 735f 6f70 656e 5f66 6965 6c64 3a20   is_open_field: 
+00013940: 626f 6f6c 2920 2d3e 206c 6973 745b 506f  bool) -> list[Po
+00013950: 696e 745d 3a0a 2020 2020 2020 2020 2222  int]:.        ""
+00013960: 2246 696e 6420 7468 6520 6365 6e74 726f  "Find the centro
+00013970: 6964 206f 6620 7468 6520 7261 6469 6174  id of the radiat
+00013980: 696f 6e20 6669 656c 6420 6261 7365 6420  ion field based 
+00013990: 6f6e 2061 2035 3025 2068 6569 6768 7420  on a 50% height 
+000139a0: 7468 7265 7368 6f6c 642e 0a20 2020 2020  threshold..     
+000139b0: 2020 2054 6869 7320 6170 706c 6965 7320     This applies 
+000139c0: 7468 6520 6669 656c 6420 6465 7465 6374  the field detect
+000139d0: 696f 6e20 636f 6e64 6974 696f 6e73 2061  ion conditions a
+000139e0: 6e64 2061 6c73 6f20 6120 6e65 6172 6e65  nd also a nearne
+000139f0: 7373 2063 6f6e 6469 7469 6f6e 2e0a 0a20  ss condition... 
+00013a00: 2020 2020 2020 2052 6574 7572 6e73 0a20         Returns. 
+00013a10: 2020 2020 2020 202d 2d2d 2d2d 2d2d 0a20         -------. 
+00013a20: 2020 2020 2020 2070 6f69 6e74 730a 2020         points.  
+00013a30: 2020 2020 2020 2020 2020 5468 6520 4341            The CA
+00013a40: 5820 706f 696e 7420 6c6f 6361 7469 6f6e  X point location
+00013a50: 732e 0a20 2020 2020 2020 2022 2222 0a20  s..        """. 
+00013a60: 2020 2020 2020 2069 6620 6973 5f6f 7065         if is_ope
+00013a70: 6e5f 6669 656c 643a 0a20 2020 2020 2020  n_field:.       
+00013a80: 2020 2020 2072 6574 7572 6e20 5b73 656c       return [sel
+00013a90: 662e 6365 6e74 6572 5d0a 0a20 2020 2020  f.center]..     
+00013aa0: 2020 2023 2066 696e 6420 616c 6c20 7468     # find all th
+00013ab0: 6520 6669 656c 6473 2062 7920 7365 7474  e fields by sett
+00013ac0: 696e 6720 7468 6520 6669 656c 6420 746f  ing the field to
+00013ad0: 2074 6865 206d 6561 6e20 7261 6420 7369   the mean rad si
+00013ae0: 7a65 2061 6e64 2074 6f6c 6572 616e 6365  ze and tolerance
+00013af0: 0a20 2020 2020 2020 2023 2074 6f20 6d61  .        # to ma
+00013b00: 782d 6d69 6e20 6669 656c 6420 7369 7a65  x-min field size
+00013b10: 7320 6163 726f 7373 2074 6865 2061 7272  s across the arr
+00013b20: 616e 6765 6d65 6e74 730a 2020 2020 2020  angements.      
+00013b30: 2020 6d61 785f 6669 656c 645f 7369 7a65    max_field_size
+00013b40: 203d 206d 6178 280a 2020 2020 2020 2020   = max(.        
+00013b50: 2020 2020 7365 6c66 2e62 625f 6172 7261      self.bb_arra
+00013b60: 6e67 656d 656e 742c 206b 6579 3d6c 616d  ngement, key=lam
+00013b70: 6264 6120 783a 2078 2e72 6164 5f73 697a  bda x: x.rad_siz
+00013b80: 655f 6d6d 0a20 2020 2020 2020 2029 2e72  e_mm.        ).r
+00013b90: 6164 5f73 697a 655f 6d6d 0a20 2020 2020  ad_size_mm.     
+00013ba0: 2020 206d 696e 5f66 6965 6c64 5f73 697a     min_field_siz
+00013bb0: 6520 3d20 6d69 6e28 0a20 2020 2020 2020  e = min(.       
+00013bc0: 2020 2020 2073 656c 662e 6262 5f61 7272       self.bb_arr
+00013bd0: 616e 6765 6d65 6e74 2c20 6b65 793d 6c61  angement, key=la
+00013be0: 6d62 6461 2078 3a20 782e 7261 645f 7369  mbda x: x.rad_si
+00013bf0: 7a65 5f6d 6d0a 2020 2020 2020 2020 292e  ze_mm.        ).
+00013c00: 7261 645f 7369 7a65 5f6d 6d0a 2020 2020  rad_size_mm.    
+00013c10: 2020 2020 6d65 616e 5f66 6965 6c64 5f73      mean_field_s
+00013c20: 697a 6520 3d20 286d 6178 5f66 6965 6c64  ize = (max_field
+00013c30: 5f73 697a 6520 2b20 6d69 6e5f 6669 656c  _size + min_fiel
+00013c40: 645f 7369 7a65 2920 2f20 320a 2020 2020  d_size) / 2.    
+00013c50: 2020 2020 746f 6c65 7261 6e63 655f 6669      tolerance_fi
+00013c60: 656c 645f 7369 7a65 203d 206d 6178 280a  eld_size = max(.
+00013c70: 2020 2020 2020 2020 2020 2020 286d 6178              (max
+00013c80: 5f66 6965 6c64 5f73 697a 6520 2d20 6d69  _field_size - mi
+00013c90: 6e5f 6669 656c 645f 7369 7a65 2920 2a20  n_field_size) * 
+00013ca0: 312e 322c 2030 2e31 202a 206d 6561 6e5f  1.2, 0.1 * mean_
+00013cb0: 6669 656c 645f 7369 7a65 0a20 2020 2020  field_size.     
+00013cc0: 2020 2029 0a20 2020 2020 2020 2070 6f69     ).        poi
+00013cd0: 6e74 7320 3d20 7365 6c66 2e63 6f6d 7075  nts = self.compu
+00013ce0: 7465 280a 2020 2020 2020 2020 2020 2020  te(.            
+00013cf0: 6d65 7472 6963 733d 476c 6f62 616c 5369  metrics=GlobalSi
+00013d00: 7a65 6446 6965 6c64 4c6f 6361 746f 722e  zedFieldLocator.
+00013d10: 6672 6f6d 5f70 6879 7369 6361 6c28 0a20  from_physical(. 
+00013d20: 2020 2020 2020 2020 2020 2020 2020 206d                 m
+00013d30: 6178 5f6e 756d 6265 723d 6c65 6e28 7365  ax_number=len(se
+00013d40: 6c66 2e62 625f 6172 7261 6e67 656d 656e  lf.bb_arrangemen
+00013d50: 7429 2c0a 2020 2020 2020 2020 2020 2020  t),.            
+00013d60: 2020 2020 6669 656c 645f 6865 6967 6874      field_height
+00013d70: 5f6d 6d3d 6d65 616e 5f66 6965 6c64 5f73  _mm=mean_field_s
+00013d80: 697a 652c 0a20 2020 2020 2020 2020 2020  ize,.           
+00013d90: 2020 2020 2066 6965 6c64 5f77 6964 7468       field_width
+00013da0: 5f6d 6d3d 6d65 616e 5f66 6965 6c64 5f73  _mm=mean_field_s
+00013db0: 697a 652c 0a20 2020 2020 2020 2020 2020  ize,.           
+00013dc0: 2020 2020 2066 6965 6c64 5f74 6f6c 6572       field_toler
+00013dd0: 616e 6365 5f6d 6d3d 746f 6c65 7261 6e63  ance_mm=toleranc
+00013de0: 655f 6669 656c 645f 7369 7a65 2c0a 2020  e_field_size,.  
+00013df0: 2020 2020 2020 2020 2020 290a 2020 2020            ).    
+00013e00: 2020 2020 290a 2020 2020 2020 2020 7265      ).        re
+00013e10: 7475 726e 2070 6f69 6e74 730a 0a20 2020  turn points..   
+00013e20: 2064 6566 2066 696e 645f 6262 5f63 656e   def find_bb_cen
+00013e30: 7472 6f69 6473 280a 2020 2020 2020 2020  troids(.        
+00013e40: 7365 6c66 2c20 6262 5f64 6961 6d65 7465  self, bb_diamete
+00013e50: 725f 6d6d 3a20 666c 6f61 742c 206c 6f77  r_mm: float, low
+00013e60: 5f64 656e 7369 7479 3a20 626f 6f6c 0a20  _density: bool. 
+00013e70: 2020 2029 202d 3e20 6c69 7374 5b50 6f69     ) -> list[Poi
+00013e80: 6e74 5d3a 0a20 2020 2020 2020 2022 2222  nt]:.        """
+00013e90: 4669 6e64 2074 6865 2073 7065 6369 6669  Find the specifi
+00013ea0: 6320 4242 2062 6173 6564 206f 6e20 7468  c BB based on th
+00013eb0: 6520 6172 7261 6e67 656d 656e 7420 7261  e arrangement ra
+00013ec0: 7468 6572 2074 6861 6e20 6120 7369 6e67  ther than a sing
+00013ed0: 6c65 206f 6e65 2e20 5468 6973 2069 7320  le one. This is 
+00013ee0: 696e 206c 6f63 616c 2070 6978 656c 2063  in local pixel c
+00013ef0: 6f6f 7264 696e 6174 6573 2222 220a 2020  oordinates""".  
+00013f00: 2020 2020 2020 2320 6765 7420 696e 6974        # get init
+00013f10: 6961 6c20 7374 6172 7469 6e67 2063 6f6e  ial starting con
+00013f20: 6469 7469 6f6e 730a 2020 2020 2020 2020  ditions.        
+00013f30: 6262 5f74 6f6c 6572 616e 6365 5f6d 6d20  bb_tolerance_mm 
+00013f40: 3d20 7365 6c66 2e5f 6361 6c63 756c 6174  = self._calculat
+00013f50: 655f 6262 5f74 6f6c 6572 616e 6365 2862  e_bb_tolerance(b
+00013f60: 625f 6469 616d 6574 6572 5f6d 6d29 0a20  b_diameter_mm). 
+00013f70: 2020 2020 2020 2063 656e 7465 7273 203d         centers =
+00013f80: 2073 656c 662e 636f 6d70 7574 6528 0a20   self.compute(. 
+00013f90: 2020 2020 2020 2020 2020 206d 6574 7269             metri
+00013fa0: 6373 3d47 6c6f 6261 6c53 697a 6564 4469  cs=GlobalSizedDi
+00013fb0: 736b 4c6f 6361 746f 7228 0a20 2020 2020  skLocator(.     
+00013fc0: 2020 2020 2020 2020 2020 2072 6164 6975             radiu
+00013fd0: 735f 6d6d 3d62 625f 6469 616d 6574 6572  s_mm=bb_diameter
+00013fe0: 5f6d 6d20 2f20 322c 0a20 2020 2020 2020  _mm / 2,.       
+00013ff0: 2020 2020 2020 2020 2072 6164 6975 735f           radius_
+00014000: 746f 6c65 7261 6e63 655f 6d6d 3d62 625f  tolerance_mm=bb_
+00014010: 746f 6c65 7261 6e63 655f 6d6d 2c0a 2020  tolerance_mm,.  
+00014020: 2020 2020 2020 2020 2020 2020 2020 696e                in
+00014030: 7665 7274 3d6e 6f74 206c 6f77 5f64 656e  vert=not low_den
+00014040: 7369 7479 2c0a 2020 2020 2020 2020 2020  sity,.          
+00014050: 2020 2020 2020 6465 7465 6374 696f 6e5f        detection_
+00014060: 636f 6e64 6974 696f 6e73 3d73 656c 662e  conditions=self.
+00014070: 6465 7465 6374 696f 6e5f 636f 6e64 6974  detection_condit
+00014080: 696f 6e73 2c0a 2020 2020 2020 2020 2020  ions,.          
+00014090: 2020 2020 2020 6d61 785f 6e75 6d62 6572        max_number
+000140a0: 3d6c 656e 2873 656c 662e 6262 5f61 7272  =len(self.bb_arr
+000140b0: 616e 6765 6d65 6e74 292c 0a20 2020 2020  angement),.     
+000140c0: 2020 2020 2020 2029 0a20 2020 2020 2020         ).       
+000140d0: 2029 0a20 2020 2020 2020 2072 6574 7572   ).        retur
+000140e0: 6e20 6365 6e74 6572 730a 0a0a 636c 6173  n centers...clas
+000140f0: 7320 5769 6e73 746f 6e4c 7574 7a4d 756c  s WinstonLutzMul
+00014100: 7469 5461 7267 6574 4d75 6c74 6946 6965  tiTargetMultiFie
+00014110: 6c64 2857 696e 7374 6f6e 4c75 747a 293a  ld(WinstonLutz):
+00014120: 0a20 2020 206d 6163 6869 6e65 5f73 6361  .    machine_sca
+00014130: 6c65 3a20 4d61 6368 696e 6553 6361 6c65  le: MachineScale
+00014140: 2020 233a 0a20 2020 2069 6d61 6765 733a    #:.    images:
+00014150: 2053 6571 7565 6e63 655b 5769 6e73 746f   Sequence[Winsto
+00014160: 6e4c 7574 7a4d 756c 7469 5461 7267 6574  nLutzMultiTarget
+00014170: 4d75 6c74 6946 6965 6c64 496d 6167 655d  MultiFieldImage]
+00014180: 2020 233a 0a20 2020 2069 6d61 6765 5f74    #:.    image_t
+00014190: 7970 6520 3d20 5769 6e73 746f 6e4c 7574  ype = WinstonLut
+000141a0: 7a4d 756c 7469 5461 7267 6574 4d75 6c74  zMultiTargetMult
+000141b0: 6946 6965 6c64 496d 6167 650a 2020 2020  iFieldImage.    
+000141c0: 6262 5f61 7272 616e 6765 6d65 6e74 3a20  bb_arrangement: 
+000141d0: 7475 706c 655b 4242 436f 6e66 6967 5d20  tuple[BBConfig] 
+000141e0: 2023 3a0a 2020 2020 6262 733a 206c 6973   #:.    bbs: lis
+000141f0: 745b 4242 3344 5d20 2023 3a20 2033 4420  t[BB3D]  #:  3D 
+00014200: 7265 7072 6573 656e 7461 7469 6f6e 206f  representation o
+00014210: 6620 7468 6520 4242 730a 0a20 2020 2040  f the BBs..    @
+00014220: 636c 6173 736d 6574 686f 640a 2020 2020  classmethod.    
+00014230: 6465 6620 6672 6f6d 5f64 656d 6f5f 696d  def from_demo_im
+00014240: 6167 6573 2863 6c73 293a 0a20 2020 2020  ages(cls):.     
+00014250: 2020 2022 2222 496e 7374 616e 7469 6174     """Instantiat
+00014260: 6520 7573 696e 6720 7468 6520 6465 6d6f  e using the demo
+00014270: 2069 6d61 6765 732e 2222 220a 2020 2020   images.""".    
+00014280: 2020 2020 6465 6d6f 5f66 696c 6520 3d20      demo_file = 
+00014290: 7265 7472 6965 7665 5f64 656d 6f5f 6669  retrieve_demo_fi
+000142a0: 6c65 286e 616d 653d 226d 745f 6d66 5f77  le(name="mt_mf_w
+000142b0: 6c2e 7a69 7022 290a 2020 2020 2020 2020  l.zip").        
+000142c0: 7265 7475 726e 2063 6c73 2e66 726f 6d5f  return cls.from_
+000142d0: 7a69 7028 6465 6d6f 5f66 696c 6529 0a0a  zip(demo_file)..
+000142e0: 2020 2020 4073 7461 7469 636d 6574 686f      @staticmetho
+000142f0: 640a 2020 2020 6465 6620 7275 6e5f 6465  d.    def run_de
+00014300: 6d6f 2829 3a0a 2020 2020 2020 2020 2222  mo():.        ""
+00014310: 2252 756e 2074 6865 2057 696e 7374 6f6e  "Run the Winston
+00014320: 2d4c 7574 7a20 4d54 204d 4620 6465 6d6f  -Lutz MT MF demo
+00014330: 2c20 7768 6963 6820 6c6f 6164 7320 7468  , which loads th
+00014340: 6520 6465 6d6f 2066 696c 6573 2c20 7072  e demo files, pr
+00014350: 696e 7473 2072 6573 756c 7473 2c20 616e  ints results, an
+00014360: 6420 706c 6f74 7320 6120 7375 6d6d 6172  d plots a summar
+00014370: 7920 696d 6167 652e 2222 220a 2020 2020  y image.""".    
+00014380: 2020 2020 776c 203d 2057 696e 7374 6f6e      wl = Winston
+00014390: 4c75 747a 4d75 6c74 6954 6172 6765 744d  LutzMultiTargetM
+000143a0: 756c 7469 4669 656c 642e 6672 6f6d 5f64  ultiField.from_d
+000143b0: 656d 6f5f 696d 6167 6573 2829 0a20 2020  emo_images().   
+000143c0: 2020 2020 2077 6c2e 616e 616c 797a 6528       wl.analyze(
+000143d0: 6262 5f61 7272 616e 6765 6d65 6e74 3d42  bb_arrangement=B
+000143e0: 4241 7272 616e 6765 6d65 6e74 2e44 454d  BArrangement.DEM
+000143f0: 4f29 0a20 2020 2020 2020 2070 7269 6e74  O).        print
+00014400: 2877 6c2e 7265 7375 6c74 7328 2929 0a20  (wl.results()). 
+00014410: 2020 2020 2020 2077 6c2e 706c 6f74 5f69         wl.plot_i
+00014420: 6d61 6765 7328 290a 0a20 2020 2064 6566  mages()..    def
+00014430: 2061 6e61 6c79 7a65 280a 2020 2020 2020   analyze(.      
+00014440: 2020 7365 6c66 2c0a 2020 2020 2020 2020    self,.        
+00014450: 6262 5f61 7272 616e 6765 6d65 6e74 3a20  bb_arrangement: 
+00014460: 7475 706c 655b 4242 436f 6e66 6967 2c20  tuple[BBConfig, 
+00014470: 2e2e 2e5d 2c0a 2020 2020 2020 2020 6973  ...],.        is
+00014480: 5f6f 7065 6e5f 6669 656c 643a 2062 6f6f  _open_field: boo
+00014490: 6c20 3d20 4661 6c73 652c 0a20 2020 2020  l = False,.     
+000144a0: 2020 2069 735f 6c6f 775f 6465 6e73 6974     is_low_densit
+000144b0: 793a 2062 6f6f 6c20 3d20 4661 6c73 652c  y: bool = False,
+000144c0: 0a20 2020 2020 2020 206d 6163 6869 6e65  .        machine
+000144d0: 5f73 6361 6c65 3a20 4d61 6368 696e 6553  _scale: MachineS
+000144e0: 6361 6c65 203d 204d 6163 6869 6e65 5363  cale = MachineSc
+000144f0: 616c 652e 4945 4336 3132 3137 2c0a 2020  ale.IEC61217,.  
+00014500: 2020 293a 0a20 2020 2020 2020 2022 2222    ):.        """
+00014510: 416e 616c 797a 6520 7468 6520 574c 2069  Analyze the WL i
+00014520: 6d61 6765 732e 0a0a 2020 2020 2020 2020  mages...        
+00014530: 5061 7261 6d65 7465 7273 0a20 2020 2020  Parameters.     
+00014540: 2020 202d 2d2d 2d2d 2d2d 2d2d 2d0a 2020     ----------.  
+00014550: 2020 2020 2020 6262 5f61 7272 616e 6765        bb_arrange
+00014560: 6d65 6e74 0a20 2020 2020 2020 2020 2020  ment.           
+00014570: 2054 6865 2061 7272 616e 6765 6d65 6e74   The arrangement
+00014580: 206f 6620 7468 6520 4242 7320 696e 2074   of the BBs in t
+00014590: 6865 2070 6861 6e74 6f6d 2e20 4120 6469  he phantom. A di
+000145a0: 6374 2077 6974 6820 6f66 6673 6574 2061  ct with offset a
+000145b0: 6e64 2042 4220 7369 7a65 206b 6579 732e  nd BB size keys.
+000145c0: 2053 6565 2074 6865 2060 6042 4241 7272   See the ``BBArr
+000145d0: 616e 6765 6d65 6e74 6060 2063 6c61 7373  angement`` class
+000145e0: 2066 6f72 0a20 2020 2020 2020 2020 2020   for.           
+000145f0: 206b 6579 7320 616e 6420 7379 6e74 6178   keys and syntax
+00014600: 2e0a 2020 2020 2020 2020 2222 220a 2020  ..        """.  
+00014610: 2020 2020 2020 7365 6c66 2e6d 6163 6869        self.machi
+00014620: 6e65 5f73 6361 6c65 203d 206d 6163 6869  ne_scale = machi
+00014630: 6e65 5f73 6361 6c65 0a20 2020 2020 2020  ne_scale.       
+00014640: 2073 656c 662e 6262 5f61 7272 616e 6765   self.bb_arrange
+00014650: 6d65 6e74 203d 2062 625f 6172 7261 6e67  ment = bb_arrang
+00014660: 656d 656e 740a 2020 2020 2020 2020 666f  ement.        fo
+00014670: 7220 696d 6720 696e 2073 656c 662e 696d  r img in self.im
+00014680: 6167 6573 3a0a 2020 2020 2020 2020 2020  ages:.          
+00014690: 2020 696d 672e 616e 616c 797a 6528 0a20    img.analyze(. 
+000146a0: 2020 2020 2020 2020 2020 2020 2020 2062                 b
+000146b0: 625f 6172 7261 6e67 656d 656e 743d 6262  b_arrangement=bb
+000146c0: 5f61 7272 616e 6765 6d65 6e74 2c0a 2020  _arrangement,.  
+000146d0: 2020 2020 2020 2020 2020 2020 2020 6973                is
+000146e0: 5f6f 7065 6e5f 6669 656c 643d 6973 5f6f  _open_field=is_o
+000146f0: 7065 6e5f 6669 656c 642c 0a20 2020 2020  pen_field,.     
+00014700: 2020 2020 2020 2020 2020 2069 735f 6c6f             is_lo
+00014710: 775f 6465 6e73 6974 793d 6973 5f6c 6f77  w_density=is_low
+00014720: 5f64 656e 7369 7479 2c0a 2020 2020 2020  _density,.      
+00014730: 2020 2020 2020 290a 0a20 2020 2020 2020        )..       
+00014740: 2073 656c 662e 6262 7320 3d20 5b5d 0a20   self.bbs = []. 
+00014750: 2020 2020 2020 2066 6f72 2061 7272 616e         for arran
+00014760: 6765 6d65 6e74 2069 6e20 7365 6c66 2e62  gement in self.b
+00014770: 625f 6172 7261 6e67 656d 656e 743a 0a20  b_arrangement:. 
+00014780: 2020 2020 2020 2020 2020 2023 2061 6464             # add
+00014790: 2062 6273 2074 6f20 7468 6520 6d61 7463   bbs to the matc
+000147a0: 6865 7320 6966 2074 6865 206d 6174 6368  hes if the match
+000147b0: 2069 7320 696e 2074 6865 2067 6976 656e   is in the given
+000147c0: 2069 6d61 6765 0a20 2020 2020 2020 2020   image.         
+000147d0: 2020 206d 6174 6368 6573 203d 205b 5d0a     matches = [].
+000147e0: 2020 2020 2020 2020 2020 2020 666f 7220              for 
+000147f0: 696d 6720 696e 2073 656c 662e 696d 6167  img in self.imag
+00014800: 6573 3a0a 2020 2020 2020 2020 2020 2020  es:.            
+00014810: 2020 2020 6966 2061 7272 616e 6765 6d65      if arrangeme
+00014820: 6e74 2e6e 616d 6520 696e 2069 6d67 2e61  nt.name in img.a
+00014830: 7272 616e 6765 6d65 6e74 5f6d 6174 6368  rrangement_match
+00014840: 6573 3a0a 2020 2020 2020 2020 2020 2020  es:.            
+00014850: 2020 2020 2020 2020 6d61 7463 6820 3d20          match = 
+00014860: 696d 672e 6172 7261 6e67 656d 656e 745f  img.arrangement_
+00014870: 6d61 7463 6865 735b 6172 7261 6e67 656d  matches[arrangem
+00014880: 656e 742e 6e61 6d65 5d0a 2020 2020 2020  ent.name].      
+00014890: 2020 2020 2020 2020 2020 2020 2020 6d61                ma
+000148a0: 7463 6865 732e 6170 7065 6e64 286d 6174  tches.append(mat
+000148b0: 6368 290a 2020 2020 2020 2020 2020 2020  ch).            
+000148c0: 2320 7261 7920 6c69 6e65 7320 6172 6520  # ray lines are 
+000148d0: 7573 6564 2066 6f72 2070 6c6f 7474 696e  used for plottin
+000148e0: 670a 2020 2020 2020 2020 2020 2020 6262  g.            bb
+000148f0: 203d 2042 4233 4428 0a20 2020 2020 2020   = BB3D(.       
+00014900: 2020 2020 2020 2020 2062 625f 636f 6e66           bb_conf
+00014910: 6967 3d61 7272 616e 6765 6d65 6e74 2c0a  ig=arrangement,.
+00014920: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00014930: 6262 5f6d 6174 6368 6573 3d6d 6174 6368  bb_matches=match
+00014940: 6573 2c0a 2020 2020 2020 2020 2020 2020  es,.            
+00014950: 2020 2020 7363 616c 653d 7365 6c66 2e6d      scale=self.m
+00014960: 6163 6869 6e65 5f73 6361 6c65 2c0a 2020  achine_scale,.  
+00014970: 2020 2020 2020 2020 2020 290a 2020 2020            ).    
+00014980: 2020 2020 2020 2020 7365 6c66 2e62 6273          self.bbs
+00014990: 2e61 7070 656e 6428 6262 290a 2020 2020  .append(bb).    
+000149a0: 2020 2020 7365 6c66 2e5f 6973 5f61 6e61      self._is_ana
+000149b0: 6c79 7a65 6420 3d20 5472 7565 0a0a 2020  lyzed = True..  
+000149c0: 2020 6465 6620 706c 6f74 5f6c 6f63 6174    def plot_locat
+000149d0: 696f 6e28 0a20 2020 2020 2020 2073 656c  ion(.        sel
+000149e0: 662c 0a20 2020 2020 2020 2073 686f 773a  f,.        show:
+000149f0: 2062 6f6f 6c20 3d20 5472 7565 2c0a 2020   bool = True,.  
+00014a00: 2020 2020 2020 7669 6577 626f 785f 6d6d        viewbox_mm
+00014a10: 3a20 666c 6f61 7420 7c20 4e6f 6e65 203d  : float | None =
+00014a20: 204e 6f6e 652c 0a20 2020 2020 2020 2070   None,.        p
+00014a30: 6c6f 745f 6262 3a20 626f 6f6c 203d 2054  lot_bb: bool = T
+00014a40: 7275 652c 0a20 2020 2020 2020 2070 6c6f  rue,.        plo
+00014a50: 745f 6973 6f63 656e 7465 725f 7370 6865  t_isocenter_sphe
+00014a60: 7265 3a20 626f 6f6c 203d 2054 7275 652c  re: bool = True,
+00014a70: 0a20 2020 2020 2020 2070 6c6f 745f 636f  .        plot_co
+00014a80: 7563 685f 6973 6f3a 2062 6f6f 6c20 3d20  uch_iso: bool = 
+00014a90: 5472 7565 2c0a 2020 2020 2020 2020 706c  True,.        pl
+00014aa0: 6f74 5f63 6f6c 6c5f 6973 6f3a 2062 6f6f  ot_coll_iso: boo
+00014ab0: 6c20 3d20 5472 7565 2c0a 2020 2020 2020  l = True,.      
+00014ac0: 2020 7368 6f77 5f6c 6567 656e 643a 2062    show_legend: b
+00014ad0: 6f6f 6c20 3d20 5472 7565 2c0a 2020 2020  ool = True,.    
+00014ae0: 293a 0a20 2020 2020 2020 2078 5f6c 696d  ):.        x_lim
+00014af0: 203d 206d 6178 280a 2020 2020 2020 2020   = max(.        
+00014b00: 2020 2020 6d61 7828 5b6e 702e 6162 7328      max([np.abs(
+00014b10: 6262 2e6d 6561 7375 7265 645f 6262 5f70  bb.measured_bb_p
+00014b20: 6f73 6974 696f 6e2e 7829 2066 6f72 2062  osition.x) for b
+00014b30: 6220 696e 2073 656c 662e 6262 735d 2920  b in self.bbs]) 
+00014b40: 2a20 312e 332c 2031 300a 2020 2020 2020  * 1.3, 10.      
+00014b50: 2020 290a 2020 2020 2020 2020 795f 6c69    ).        y_li
+00014b60: 6d20 3d20 6d61 7828 0a20 2020 2020 2020  m = max(.       
+00014b70: 2020 2020 206d 6178 285b 6e70 2e61 6273       max([np.abs
+00014b80: 2862 622e 6d65 6173 7572 6564 5f62 625f  (bb.measured_bb_
+00014b90: 706f 7369 7469 6f6e 2e79 2920 666f 7220  position.y) for 
+00014ba0: 6262 2069 6e20 7365 6c66 2e62 6273 5d29  bb in self.bbs])
+00014bb0: 202a 2031 2e33 2c20 3130 0a20 2020 2020   * 1.3, 10.     
+00014bc0: 2020 2029 0a20 2020 2020 2020 207a 5f6c     ).        z_l
+00014bd0: 696d 203d 206d 6178 280a 2020 2020 2020  im = max(.      
+00014be0: 2020 2020 2020 6d61 7828 5b6e 702e 6162        max([np.ab
+00014bf0: 7328 6262 2e6d 6561 7375 7265 645f 6262  s(bb.measured_bb
+00014c00: 5f70 6f73 6974 696f 6e2e 7a29 2066 6f72  _position.z) for
+00014c10: 2062 6220 696e 2073 656c 662e 6262 735d   bb in self.bbs]
+00014c20: 2920 2a20 312e 332c 2031 300a 2020 2020  ) * 1.3, 10.    
+00014c30: 2020 2020 290a 2020 2020 2020 2020 6c69      ).        li
+00014c40: 6d69 7420 3d20 7669 6577 626f 785f 6d6d  mit = viewbox_mm
+00014c50: 206f 7220 6d61 7828 785f 6c69 6d2c 2079   or max(x_lim, y
+00014c60: 5f6c 696d 2c20 7a5f 6c69 6d29 0a20 2020  _lim, z_lim).   
+00014c70: 2020 2020 2066 6967 203d 2070 6c74 2e66       fig = plt.f
+00014c80: 6967 7572 6528 290a 2020 2020 2020 2020  igure().        
+00014c90: 6178 203d 2066 6967 2e61 6464 5f73 7562  ax = fig.add_sub
+00014ca0: 706c 6f74 2870 726f 6a65 6374 696f 6e3d  plot(projection=
+00014cb0: 2233 6422 290a 2020 2020 2020 2020 5f2c  "3d").        _,
+00014cc0: 2072 656c 6576 616e 745f 696d 6167 6573   relevant_images
+00014cd0: 203d 2073 656c 662e 5f67 6574 5f69 6d61   = self._get_ima
+00014ce0: 6765 7328 0a20 2020 2020 2020 2020 2020  ges(.           
+00014cf0: 2061 7869 733d 2841 7869 732e 5245 4645   axis=(Axis.REFE
+00014d00: 5245 4e43 452c 2041 7869 732e 4742 5f43  RENCE, Axis.GB_C
+00014d10: 4f4d 424f 2c20 4178 6973 2e43 4f4c 4c49  OMBO, Axis.COLLI
+00014d20: 4d41 544f 522c 2041 7869 732e 4741 4e54  MATOR, Axis.GANT
+00014d30: 5259 290a 2020 2020 2020 2020 290a 2020  RY).        ).  
+00014d40: 2020 2020 2020 2320 7765 2063 616e 2072        # we can r
+00014d50: 6570 7265 7365 6e74 2074 6865 2069 736f  epresent the iso
+00014d60: 2073 7068 6572 6520 6173 2061 2042 4220   sphere as a BB 
+00014d70: 6f62 6a65 6374 3b20 7468 6520 6e6f 6d69  object; the nomi
+00014d80: 6e61 6c20 6f62 6a65 6374 2069 736e 2774  nal object isn't
+00014d90: 2075 7365 642c 206a 7573 7420 7468 6520   used, just the 
+00014da0: 4242 2073 697a 650a 2020 2020 2020 2020  BB size.        
+00014db0: 2320 7468 6520 7261 7920 6c69 6e65 7320  # the ray lines 
+00014dc0: 6172 6520 7768 6174 2077 6520 7761 6e74  are what we want
+00014dd0: 2074 6f20 706c 6f74 2061 7320 6120 7370   to plot as a sp
+00014de0: 6865 7265 0a20 2020 2020 2020 2023 2070  here.        # p
+00014df0: 6c6f 7420 7468 6520 782c 792c 7a20 6f72  lot the x,y,z or
+00014e00: 6967 696e 206c 696e 6573 0a20 2020 2020  igin lines.     
+00014e10: 2020 2078 5f6c 696e 6520 3d20 4c69 6e65     x_line = Line
+00014e20: 2850 6f69 6e74 282d 3130 302c 2030 2c20  (Point(-100, 0, 
+00014e30: 3029 2c20 506f 696e 7428 3130 302c 2030  0), Point(100, 0
+00014e40: 2c20 3029 290a 2020 2020 2020 2020 785f  , 0)).        x_
+00014e50: 6c69 6e65 2e70 6c6f 7432 6178 6573 2861  line.plot2axes(a
+00014e60: 782c 2063 6f6c 6f72 3d22 6772 6565 6e22  x, color="green"
+00014e70: 2c20 616c 7068 613d 302e 3529 0a20 2020  , alpha=0.5).   
+00014e80: 2020 2020 2079 5f6c 696e 6520 3d20 4c69       y_line = Li
+00014e90: 6e65 2850 6f69 6e74 2830 2c20 2d31 3030  ne(Point(0, -100
+00014ea0: 2c20 3029 2c20 506f 696e 7428 302c 2031  , 0), Point(0, 1
+00014eb0: 3030 2c20 3029 290a 2020 2020 2020 2020  00, 0)).        
+00014ec0: 795f 6c69 6e65 2e70 6c6f 7432 6178 6573  y_line.plot2axes
+00014ed0: 2861 782c 2063 6f6c 6f72 3d22 6772 6565  (ax, color="gree
+00014ee0: 6e22 2c20 616c 7068 613d 302e 3529 0a20  n", alpha=0.5). 
+00014ef0: 2020 2020 2020 207a 5f6c 696e 6520 3d20         z_line = 
+00014f00: 4c69 6e65 2850 6f69 6e74 2830 2c20 302c  Line(Point(0, 0,
+00014f10: 202d 3130 3029 2c20 506f 696e 7428 302c   -100), Point(0,
+00014f20: 2030 2c20 3130 3029 290a 2020 2020 2020   0, 100)).      
+00014f30: 2020 7a5f 6c69 6e65 2e70 6c6f 7432 6178    z_line.plot2ax
+00014f40: 6573 280a 2020 2020 2020 2020 2020 2020  es(.            
+00014f50: 6178 2c20 636f 6c6f 723d 2267 7265 656e  ax, color="green
+00014f60: 222c 2061 6c70 6861 3d30 2e35 2c20 6c61  ", alpha=0.5, la
+00014f70: 6265 6c3d 224e 6f6d 696e 616c 2069 736f  bel="Nominal iso
+00014f80: 6365 6e74 6572 2028 782c 792c 7a29 220a  center (x,y,z)".
+00014f90: 2020 2020 2020 2020 290a 2020 2020 2020          ).      
+00014fa0: 2020 6966 2070 6c6f 745f 6262 3a0a 2020    if plot_bb:.  
+00014fb0: 2020 2020 2020 2020 2020 666f 7220 6262            for bb
+00014fc0: 2069 6e20 7365 6c66 2e62 6273 3a0a 2020   in self.bbs:.  
+00014fd0: 2020 2020 2020 2020 2020 2020 2020 6262                bb
+00014fe0: 2e70 6c6f 745f 6d65 6173 7572 6564 2861  .plot_measured(a
+00014ff0: 782c 2063 6f6c 6f72 3d22 6379 616e 222c  x, color="cyan",
+00015000: 2061 6c70 6861 3d30 2e36 290a 2020 2020   alpha=0.6).    
+00015010: 2020 2020 2020 2020 2020 2020 6262 2e70              bb.p
+00015020: 6c6f 745f 6e6f 6d69 6e61 6c28 6178 2c20  lot_nominal(ax, 
+00015030: 636f 6c6f 723d 2267 7265 656e 222c 2061  color="green", a
+00015040: 6c70 6861 3d30 2e36 290a 0a20 2020 2020  lpha=0.6)..     
+00015050: 2020 2020 2020 2023 2063 7265 6174 6520         # create 
+00015060: 616e 2065 6d70 7479 2c20 6661 6b65 206c  an empty, fake l
+00015070: 696e 6520 736f 2077 6520 6361 6e20 6164  ine so we can ad
+00015080: 6420 6120 6c61 6265 6c20 666f 7220 7468  d a label for th
+00015090: 6520 6c65 6765 6e64 0a20 2020 2020 2020  e legend.       
+000150a0: 2020 2020 2066 616b 655f 6c69 6e65 203d       fake_line =
+000150b0: 204c 696e 6528 506f 696e 7428 302c 2030   Line(Point(0, 0
+000150c0: 2c20 3029 2c20 506f 696e 7428 302c 2030  , 0), Point(0, 0
+000150d0: 2c20 3029 290a 2020 2020 2020 2020 2020  , 0)).          
+000150e0: 2020 6661 6b65 5f6c 696e 652e 706c 6f74    fake_line.plot
+000150f0: 3261 7865 7328 6178 2c20 636f 6c6f 723d  2axes(ax, color=
+00015100: 2263 7961 6e22 2c20 6c61 6265 6c3d 224d  "cyan", label="M
+00015110: 6561 7375 7265 6420 4242 2229 0a20 2020  easured BB").   
+00015120: 2020 2020 2020 2020 2066 616b 655f 6c69           fake_li
+00015130: 6e65 203d 204c 696e 6528 506f 696e 7428  ne = Line(Point(
+00015140: 302c 2030 2c20 3029 2c20 506f 696e 7428  0, 0, 0), Point(
+00015150: 302c 2030 2c20 3029 290a 2020 2020 2020  0, 0, 0)).      
+00015160: 2020 2020 2020 6661 6b65 5f6c 696e 652e        fake_line.
+00015170: 706c 6f74 3261 7865 7328 6178 2c20 636f  plot2axes(ax, co
+00015180: 6c6f 723d 2267 7265 656e 222c 206c 6162  lor="green", lab
+00015190: 656c 3d22 4e6f 6d69 6e61 6c20 4242 2229  el="Nominal BB")
+000151a0: 0a0a 2020 2020 2020 2020 6966 2073 686f  ..        if sho
+000151b0: 775f 6c65 6765 6e64 3a0a 2020 2020 2020  w_legend:.      
+000151c0: 2020 2020 2020 6178 2e6c 6567 656e 6428        ax.legend(
+000151d0: 290a 2020 2020 2020 2020 2320 7365 7420  ).        # set 
+000151e0: 7468 6520 6c69 6d69 7473 206f 6620 7468  the limits of th
+000151f0: 6520 3344 2070 6c6f 743b 2074 6865 7920  e 3D plot; they 
+00015200: 6d75 7374 2062 6520 7468 6520 7361 6d65  must be the same
+00015210: 2069 6e20 616c 6c20 6178 6573 2066 6f72   in all axes for
+00015220: 2065 7175 616c 2061 7370 6563 7420 7261   equal aspect ra
+00015230: 7469 6f0a 2020 2020 2020 2020 6178 2e73  tio.        ax.s
+00015240: 6574 280a 2020 2020 2020 2020 2020 2020  et(.            
+00015250: 786c 6162 656c 3d22 5820 286d 6d29 2c20  xlabel="X (mm), 
+00015260: 5269 6768 7420 282b 2922 2c0a 2020 2020  Right (+)",.    
+00015270: 2020 2020 2020 2020 796c 6162 656c 3d22          ylabel="
+00015280: 5920 286d 6d29 2c20 496e 2028 2b29 222c  Y (mm), In (+)",
+00015290: 0a20 2020 2020 2020 2020 2020 207a 6c61  .            zla
+000152a0: 6265 6c3d 225a 2028 6d6d 292c 2055 7020  bel="Z (mm), Up 
+000152b0: 282b 2922 2c0a 2020 2020 2020 2020 2020  (+)",.          
+000152c0: 2020 7469 746c 653d 2249 736f 6365 6e74    title="Isocent
+000152d0: 6572 2056 6973 7561 6c69 7a61 7469 6f6e  er Visualization
+000152e0: 222c 0a20 2020 2020 2020 2020 2020 2079  ",.            y
+000152f0: 6c69 6d3d 5b2d 6c69 6d69 742c 206c 696d  lim=[-limit, lim
+00015300: 6974 5d2c 0a20 2020 2020 2020 2020 2020  it],.           
+00015310: 2078 6c69 6d3d 5b2d 6c69 6d69 742c 206c   xlim=[-limit, l
+00015320: 696d 6974 5d2c 0a20 2020 2020 2020 2020  imit],.         
+00015330: 2020 207a 6c69 6d3d 5b2d 6c69 6d69 742c     zlim=[-limit,
+00015340: 206c 696d 6974 5d2c 0a20 2020 2020 2020   limit],.       
+00015350: 2029 0a0a 2020 2020 2020 2020 6966 2073   )..        if s
+00015360: 686f 773a 0a20 2020 2020 2020 2020 2020  how:.           
+00015370: 2070 6c74 2e73 686f 7728 290a 2020 2020   plt.show().    
+00015380: 2020 2020 7265 7475 726e 2066 6967 2c20      return fig, 
+00015390: 6178 0a0a 2020 2020 4070 726f 7065 7274  ax..    @propert
+000153a0: 790a 2020 2020 6465 6620 6262 5f73 6869  y.    def bb_shi
+000153b0: 6674 5f76 6563 746f 7228 7365 6c66 2920  ft_vector(self) 
+000153c0: 2d3e 2028 5665 6374 6f72 2c20 666c 6f61  -> (Vector, floa
+000153d0: 742c 2066 6c6f 6174 2c20 666c 6f61 7429  t, float, float)
+000153e0: 3a0a 2020 2020 2020 2020 2222 2243 616c  :.        """Cal
+000153f0: 6375 6c61 7465 2074 6865 2069 6465 616c  culate the ideal
+00015400: 2073 6869 6674 2069 6e20 3620 6465 6772   shift in 6 degr
+00015410: 6565 7320 6f66 2066 7265 6564 6f6d 2074  ees of freedom t
+00015420: 6f20 706c 6163 6520 7468 6520 4242 2061  o place the BB a
+00015430: 7420 7468 6520 6973 6f63 656e 7465 722e  t the isocenter.
+00015440: 0a0a 2020 2020 2020 2020 5265 7475 726e  ..        Return
+00015450: 730a 2020 2020 2020 2020 2d2d 2d2d 2d2d  s.        ------
+00015460: 2d0a 2020 2020 2020 2020 5665 6374 6f72  -.        Vector
+00015470: 0a20 2020 2020 2020 2020 2020 2054 6865  .            The
+00015480: 2069 6465 616c 2073 6869 6674 2076 6563   ideal shift vec
+00015490: 746f 7220 696e 206d 6d20 666f 7220 7468  tor in mm for th
+000154a0: 6520 6361 7274 6573 6961 6e20 636f 6f72  e cartesian coor
+000154b0: 6469 6e61 7465 732e 2058 2c59 2c20 616e  dinates. X,Y, an
+000154c0: 6420 5a20 666f 6c6c 6f77 2074 6865 2070  d Z follow the p
+000154d0: 796c 696e 6163 2063 6f6f 7264 696e 6174  ylinac coordinat
+000154e0: 6520 636f 6e76 656e 7469 6f6e 2e0a 2020  e convention..  
+000154f0: 2020 2020 2020 666c 6f61 740a 2020 2020        float.    
+00015500: 2020 2020 2020 2020 5961 773b 2054 6865          Yaw; The
+00015510: 2069 6465 616c 2072 6f74 6174 696f 6e20   ideal rotation 
+00015520: 6162 6f75 7420 7468 6520 5a2d 6178 6973  about the Z-axis
+00015530: 2069 6e20 6465 6772 6565 732e 0a20 2020   in degrees..   
+00015540: 2020 2020 2066 6c6f 6174 0a20 2020 2020       float.     
+00015550: 2020 2020 2020 2050 6974 6368 3b20 5468         Pitch; Th
+00015560: 6520 6964 6561 6c20 726f 7461 7469 6f6e  e ideal rotation
+00015570: 2061 626f 7574 2074 6865 2058 2d61 7869   about the X-axi
+00015580: 7320 696e 2064 6567 7265 6573 2e0a 2020  s in degrees..  
+00015590: 2020 2020 2020 666c 6f61 740a 2020 2020        float.    
+000155a0: 2020 2020 2020 2020 526f 6c6c 3b20 5468          Roll; Th
+000155b0: 6520 6964 6561 6c20 726f 7461 7469 6f6e  e ideal rotation
+000155c0: 2061 626f 7574 2074 6865 2059 2d61 7869   about the Y-axi
+000155d0: 7320 696e 2064 6567 7265 6573 2e0a 0a20  s in degrees... 
+000155e0: 2020 2020 2020 2053 6565 2041 6c73 6f0a         See Also.
+000155f0: 2020 2020 2020 2020 2d2d 2d2d 2d2d 2d2d          --------
+00015600: 0a20 2020 2020 2020 2045 756c 6572 2041  .        Euler A
+00015610: 6e67 6c65 733a 2068 7474 7073 3a2f 2f65  ngles: https://e
+00015620: 6e2e 7769 6b69 7065 6469 612e 6f72 672f  n.wikipedia.org/
+00015630: 7769 6b69 2f45 756c 6572 5f61 6e67 6c65  wiki/Euler_angle
+00015640: 730a 2020 2020 2020 2020 4769 6d62 616c  s.        Gimbal
+00015650: 204c 6f63 6b3a 2068 7474 7073 3a2f 2f65   Lock: https://e
+00015660: 6e2e 7769 6b69 7065 6469 612e 6f72 672f  n.wikipedia.org/
+00015670: 7769 6b69 2f47 696d 6261 6c5f 6c6f 636b  wiki/Gimbal_lock
+00015680: 0a20 2020 2020 2020 2022 2222 0a20 2020  .        """.   
+00015690: 2020 2020 2072 6574 7572 6e20 616c 6967       return alig
+000156a0: 6e5f 706f 696e 7473 280a 2020 2020 2020  n_points(.      
+000156b0: 2020 2020 2020 6d65 6173 7572 6564 5f70        measured_p
+000156c0: 6f69 6e74 733d 5b62 622e 6d65 6173 7572  oints=[bb.measur
+000156d0: 6564 5f62 625f 706f 7369 7469 6f6e 2066  ed_bb_position f
+000156e0: 6f72 2062 6220 696e 2073 656c 662e 6262  or bb in self.bb
+000156f0: 735d 2c0a 2020 2020 2020 2020 2020 2020  s],.            
+00015700: 6964 6561 6c5f 706f 696e 7473 3d5b 6262  ideal_points=[bb
+00015710: 2e6d 6561 7375 7265 645f 6669 656c 645f  .measured_field_
+00015720: 706f 7369 7469 6f6e 2066 6f72 2062 6220  position for bb 
+00015730: 696e 2073 656c 662e 6262 735d 2c0a 2020  in self.bbs],.  
+00015740: 2020 2020 2020 290a 0a20 2020 2064 6566        )..    def
+00015750: 2062 625f 7368 6966 745f 696e 7374 7275   bb_shift_instru
+00015760: 6374 696f 6e73 2873 656c 6629 202d 3e20  ctions(self) -> 
+00015770: 7374 723a 0a20 2020 2020 2020 2022 2222  str:.        """
+00015780: 5265 7475 726e 2061 2073 7472 696e 6720  Return a string 
+00015790: 7468 6174 2070 726f 7669 6465 7320 696e  that provides in
+000157a0: 7374 7275 6374 696f 6e73 206f 6e20 686f  structions on ho
+000157b0: 7720 746f 2073 6869 6674 2074 6865 2042  w to shift the B
+000157c0: 4220 746f 2074 6865 2069 736f 6365 6e74  B to the isocent
+000157d0: 6572 2e22 2222 0a20 2020 2020 2020 2074  er.""".        t
+000157e0: 7261 6e73 6c61 7469 6f6e 2c20 7961 772c  ranslation, yaw,
+000157f0: 2070 6974 6368 2c20 726f 6c6c 203d 2073   pitch, roll = s
+00015800: 656c 662e 6262 5f73 6869 6674 5f76 6563  elf.bb_shift_vec
+00015810: 746f 720a 2020 2020 2020 2020 785f 6469  tor.        x_di
+00015820: 7220 3d20 224c 4546 5422 2069 6620 7472  r = "LEFT" if tr
+00015830: 616e 736c 6174 696f 6e2e 7820 3c20 3020  anslation.x < 0 
+00015840: 656c 7365 2022 5249 4748 5422 0a20 2020  else "RIGHT".   
+00015850: 2020 2020 2079 5f64 6972 203d 2022 494e       y_dir = "IN
+00015860: 2220 6966 2074 7261 6e73 6c61 7469 6f6e  " if translation
+00015870: 2e79 203e 2030 2065 6c73 6520 224f 5554  .y > 0 else "OUT
+00015880: 220a 2020 2020 2020 2020 7a5f 6469 7220  ".        z_dir 
+00015890: 3d20 2255 5022 2069 6620 7472 616e 736c  = "UP" if transl
+000158a0: 6174 696f 6e2e 7a20 3e20 3020 656c 7365  ation.z > 0 else
+000158b0: 2022 444f 574e 220a 2020 2020 2020 2020   "DOWN".        
+000158c0: 6d6f 7665 203d 2066 227b 785f 6469 727d  move = f"{x_dir}
+000158d0: 207b 6162 7328 7472 616e 736c 6174 696f   {abs(translatio
+000158e0: 6e2e 7829 3a32 2e32 667d 6d6d 3b20 7b79  n.x):2.2f}mm; {y
+000158f0: 5f64 6972 7d20 7b61 6273 2874 7261 6e73  _dir} {abs(trans
+00015900: 6c61 7469 6f6e 2e79 293a 322e 3266 7d6d  lation.y):2.2f}m
+00015910: 6d3b 207b 7a5f 6469 727d 207b 6162 7328  m; {z_dir} {abs(
+00015920: 7472 616e 736c 6174 696f 6e2e 7a29 3a32  translation.z):2
+00015930: 2e32 667d 6d6d 3b20 526f 7461 7469 6f6e  .2f}mm; Rotation
+00015940: 207b 7961 773a 322e 3266 7dc2 b03b 2050   {yaw:2.2f}..; P
+00015950: 6974 6368 207b 7069 7463 683a 322e 3266  itch {pitch:2.2f
+00015960: 7dc2 b03b 2052 6f6c 6c20 7b72 6f6c 6c3a  }..; Roll {roll:
+00015970: 322e 3266 7dc2 b022 0a20 2020 2020 2020  2.2f}..".       
+00015980: 2072 6574 7572 6e20 6d6f 7665 0a0a 2020   return move..  
+00015990: 2020 6465 6620 5f63 6f75 6368 5f72 6f74    def _couch_rot
+000159a0: 6174 696f 6e5f 6572 726f 7228 7365 6c66  ation_error(self
+000159b0: 2920 2d3e 2064 6963 745b 7374 722c 2064  ) -> dict[str, d
+000159c0: 6963 745b 7374 722c 2066 6c6f 6174 5d5d  ict[str, float]]
+000159d0: 3a0a 2020 2020 2020 2020 2222 2243 616c  :.        """Cal
+000159e0: 6375 6c61 7465 2074 6865 2063 6f75 6368  culate the couch
+000159f0: 2072 6f74 6174 696f 6e20 6572 726f 7220   rotation error 
+00015a00: 696e 2064 6567 7265 6573 2066 6f72 2072  in degrees for r
+00015a10: 6566 6572 656e 6365 2061 6e64 2063 6f75  eference and cou
+00015a20: 6368 2d6b 6963 6b65 6420 696d 6167 6573  ch-kicked images
+00015a30: 2e0a 2020 2020 2020 2020 5468 6973 206a  ..        This j
+00015a40: 7573 7420 666f 7220 6665 6174 7572 6520  ust for feature 
+00015a50: 7061 7269 7479 2077 6974 6820 534e 4320  parity with SNC 
+00015a60: f09f a4a6 3b20 7468 6520 4242 2073 6869  ....; the BB shi
+00015a70: 6674 2076 6563 746f 7220 6973 206d 6f72  ft vector is mor
+00015a80: 6520 696d 706f 7274 616e 742e 0a0a 2020  e important...  
+00015a90: 2020 2020 2020 5265 7475 726e 730a 2020        Returns.  
+00015aa0: 2020 2020 2020 2d2d 2d2d 2d2d 2d0a 2020        -------.  
+00015ab0: 2020 2020 2020 6469 6374 0a20 2020 2020        dict.     
+00015ac0: 2020 2020 2020 2041 2064 6963 7469 6f6e         A diction
+00015ad0: 6172 7920 7768 6572 6520 7468 6520 6b65  ary where the ke
+00015ae0: 7973 2061 7265 2074 6865 2069 6d61 6765  ys are the image
+00015af0: 2070 6174 6873 2061 6e64 2074 6865 2076   paths and the v
+00015b00: 616c 7565 7320 6172 6520 6120 6469 6374  alues are a dict
+00015b10: 696f 6e61 7279 2077 6974 6820 7468 6520  ionary with the 
+00015b20: 7961 7720 6572 726f 7220 616e 6420 6e6f  yaw error and no
+00015b30: 6d69 6e61 6c20 636f 7563 6820 616e 676c  minal couch angl
+00015b40: 652e 0a20 2020 2020 2020 2022 2222 0a20  e..        """. 
+00015b50: 2020 2020 2020 2063 6f75 6368 5f72 6573         couch_res
+00015b60: 756c 7473 203d 207b 7d0a 2020 2020 2020  ults = {}.      
+00015b70: 2020 636f 7563 685f 696d 6167 6573 203d    couch_images =
+00015b80: 205b 0a20 2020 2020 2020 2020 2020 2069   [.            i
+00015b90: 6d67 0a20 2020 2020 2020 2020 2020 2066  mg.            f
+00015ba0: 6f72 2069 6d67 2069 6e20 7365 6c66 2e69  or img in self.i
+00015bb0: 6d61 6765 730a 2020 2020 2020 2020 2020  mages.          
+00015bc0: 2020 6966 2069 6d67 2e76 6172 6961 626c    if img.variabl
+00015bd0: 655f 6178 6973 2069 6e20 2841 7869 732e  e_axis in (Axis.
+00015be0: 434f 5543 482c 2041 7869 732e 5245 4645  COUCH, Axis.REFE
+00015bf0: 5245 4e43 4529 0a20 2020 2020 2020 205d  RENCE).        ]
+00015c00: 0a20 2020 2020 2020 2066 6f72 2069 6d67  .        for img
+00015c10: 2069 6e20 636f 7563 685f 696d 6167 6573   in couch_images
+00015c20: 3a0a 2020 2020 2020 2020 2020 2020 6d65  :.            me
+00015c30: 6173 7572 6564 5f70 6f69 6e74 7320 3d20  asured_points = 
+00015c40: 5b6d 2e62 6220 666f 7220 6d20 696e 2069  [m.bb for m in i
+00015c50: 6d67 2e61 7272 616e 6765 6d65 6e74 5f6d  mg.arrangement_m
+00015c60: 6174 6368 6573 2e76 616c 7565 7328 295d  atches.values()]
+00015c70: 0a20 2020 2020 2020 2020 2020 2069 6465  .            ide
+00015c80: 616c 5f70 6f69 6e74 7320 3d20 5b6d 2e66  al_points = [m.f
+00015c90: 6965 6c64 2066 6f72 206d 2069 6e20 696d  ield for m in im
+00015ca0: 672e 6172 7261 6e67 656d 656e 745f 6d61  g.arrangement_ma
+00015cb0: 7463 6865 732e 7661 6c75 6573 2829 5d0a  tches.values()].
+00015cc0: 2020 2020 2020 2020 2020 2020 5f2c 2079              _, y
+00015cd0: 6177 2c20 5f2c 205f 203d 2061 6c69 676e  aw, _, _ = align
+00015ce0: 5f70 6f69 6e74 7328 6d65 6173 7572 6564  _points(measured
+00015cf0: 5f70 6f69 6e74 732c 2069 6465 616c 5f70  _points, ideal_p
+00015d00: 6f69 6e74 7329 0a20 2020 2020 2020 2020  oints).         
+00015d10: 2020 2063 6f75 6368 5f72 6573 756c 7473     couch_results
+00015d20: 5b69 6d67 2e62 6173 655f 7061 7468 5d20  [img.base_path] 
+00015d30: 3d20 7b0a 2020 2020 2020 2020 2020 2020  = {.            
+00015d40: 2020 2020 2279 6177 2065 7272 6f72 223a      "yaw error":
+00015d50: 2079 6177 2c0a 2020 2020 2020 2020 2020   yaw,.          
+00015d60: 2020 2020 2020 2263 6f75 6368 2061 6e67        "couch ang
+00015d70: 6c65 223a 2069 6d67 2e63 6f75 6368 5f61  le": img.couch_a
+00015d80: 6e67 6c65 2c0a 2020 2020 2020 2020 2020  ngle,.          
+00015d90: 2020 7d0a 2020 2020 2020 2020 7265 7475    }.        retu
+00015da0: 726e 2063 6f75 6368 5f72 6573 756c 7473  rn couch_results
+00015db0: 0a0a 2020 2020 4070 726f 7065 7274 790a  ..    @property.
+00015dc0: 2020 2020 6465 6620 6761 6e74 7279 5f63      def gantry_c
+00015dd0: 6f6c 6c5f 6973 6f5f 7369 7a65 2873 656c  oll_iso_size(sel
+00015de0: 6629 202d 3e20 666c 6f61 743a 0a20 2020  f) -> float:.   
+00015df0: 2020 2020 2072 6169 7365 204e 6f74 496d       raise NotIm
+00015e00: 706c 656d 656e 7465 6445 7272 6f72 2822  plementedError("
+00015e10: 4e6f 7420 7965 7420 696d 706c 656d 656e  Not yet implemen
+00015e20: 7465 6422 290a 0a20 2020 2040 7072 6f70  ted")..    @prop
+00015e30: 6572 7479 0a20 2020 2064 6566 2063 6f6c  erty.    def col
+00015e40: 6c69 6d61 746f 725f 6973 6f5f 7369 7a65  limator_iso_size
+00015e50: 2873 656c 6629 202d 3e20 666c 6f61 743a  (self) -> float:
+00015e60: 0a20 2020 2020 2020 2072 6169 7365 204e  .        raise N
+00015e70: 6f74 496d 706c 656d 656e 7465 6445 7272  otImplementedErr
+00015e80: 6f72 2822 4e6f 7420 7965 7420 696d 706c  or("Not yet impl
+00015e90: 656d 656e 7465 6422 290a 0a20 2020 2040  emented")..    @
+00015ea0: 7072 6f70 6572 7479 0a20 2020 2064 6566  property.    def
+00015eb0: 2063 6f75 6368 5f69 736f 5f73 697a 6528   couch_iso_size(
+00015ec0: 7365 6c66 2920 2d3e 2066 6c6f 6174 3a0a  self) -> float:.
+00015ed0: 2020 2020 2020 2020 7261 6973 6520 4e6f          raise No
+00015ee0: 7449 6d70 6c65 6d65 6e74 6564 4572 726f  tImplementedErro
+00015ef0: 7228 224e 6f74 2079 6574 2069 6d70 6c65  r("Not yet imple
+00015f00: 6d65 6e74 6564 2229 0a0a 2020 2020 4070  mented")..    @p
+00015f10: 726f 7065 7274 790a 2020 2020 6465 6620  roperty.    def 
+00015f20: 6761 6e74 7279 5f69 736f 5f73 697a 6528  gantry_iso_size(
+00015f30: 7365 6c66 2920 2d3e 2066 6c6f 6174 3a0a  self) -> float:.
+00015f40: 2020 2020 2020 2020 7261 6973 6520 4e6f          raise No
+00015f50: 7449 6d70 6c65 6d65 6e74 6564 4572 726f  tImplementedErro
+00015f60: 7228 224e 6f74 2079 6574 2069 6d70 6c65  r("Not yet imple
+00015f70: 6d65 6e74 6564 2229 0a0a 2020 2020 6465  mented")..    de
+00015f80: 6620 706c 6f74 5f69 6d61 6765 7328 0a20  f plot_images(. 
+00015f90: 2020 2020 2020 2073 656c 662c 2073 686f         self, sho
+00015fa0: 773a 2062 6f6f 6c20 3d20 5472 7565 2c20  w: bool = True, 
+00015fb0: 7a6f 6f6d 6564 3a20 626f 6f6c 203d 2054  zoomed: bool = T
+00015fc0: 7275 652c 206c 6567 656e 643a 2062 6f6f  rue, legend: boo
+00015fd0: 6c20 3d20 5472 7565 2c20 2a2a 6b77 6172  l = True, **kwar
+00015fe0: 6773 0a20 2020 2029 202d 3e20 286c 6973  gs.    ) -> (lis
+00015ff0: 745b 706c 742e 4669 6775 7265 5d2c 206c  t[plt.Figure], l
+00016000: 6973 745b 7374 725d 293a 0a20 2020 2020  ist[str]):.     
+00016010: 2020 2022 2222 4d61 6b65 2061 2070 6c6f     """Make a plo
+00016020: 7420 666f 7220 6561 6368 2042 422e 2045  t for each BB. E
+00016030: 6163 6820 706c 6f74 2063 6f6e 7461 696e  ach plot contain
+00016040: 7320 7468 6520 616e 616c 7973 6973 206f  s the analysis o
+00016050: 6620 7468 6174 2042 4220 6f6e 2065 6163  f that BB on eac
+00016060: 6820 696d 6167 650a 2020 2020 2020 2020  h image.        
+00016070: 6974 2077 6173 2066 6f75 6e64 2e22 2222  it was found."""
+00016080: 0a20 2020 2020 2020 2066 6967 732c 206e  .        figs, n
+00016090: 616d 6573 203d 205b 5d2c 205b 5d0a 2020  ames = [], [].  
+000160a0: 2020 2020 2020 6669 6773 697a 6520 3d20        figsize = 
+000160b0: 6b77 6172 6773 2e70 6f70 2822 6669 6773  kwargs.pop("figs
+000160c0: 697a 6522 2c20 4e6f 6e65 2920 6f72 2028  ize", None) or (
+000160d0: 382c 2038 290a 2020 2020 2020 2020 666f  8, 8).        fo
+000160e0: 7220 696d 6720 696e 2073 656c 662e 696d  r img in self.im
+000160f0: 6167 6573 3a0a 2020 2020 2020 2020 2020  ages:.          
+00016100: 2020 6669 672c 2061 7865 7320 3d20 706c    fig, axes = pl
+00016110: 742e 7375 6270 6c6f 7473 2866 6967 7369  t.subplots(figsi
+00016120: 7a65 3d66 6967 7369 7a65 2c20 2a2a 6b77  ze=figsize, **kw
+00016130: 6172 6773 290a 2020 2020 2020 2020 2020  args).          
+00016140: 2020 696d 672e 706c 6f74 2861 783d 6178    img.plot(ax=ax
+00016150: 6573 2c20 7368 6f77 3d46 616c 7365 2c20  es, show=False, 
+00016160: 7a6f 6f6d 3d7a 6f6f 6d65 642c 206c 6567  zoom=zoomed, leg
+00016170: 656e 643d 6c65 6765 6e64 290a 2020 2020  end=legend).    
+00016180: 2020 2020 2020 2020 6669 672e 7469 6768          fig.tigh
+00016190: 745f 6c61 796f 7574 2829 0a20 2020 2020  t_layout().     
+000161a0: 2020 2020 2020 2066 6967 732e 6170 7065         figs.appe
+000161b0: 6e64 2866 6967 290a 2020 2020 2020 2020  nd(fig).        
+000161c0: 2020 2020 6e61 6d65 732e 6170 7065 6e64      names.append
+000161d0: 2869 6d67 2e62 6173 655f 7061 7468 290a  (img.base_path).
+000161e0: 2020 2020 2020 2020 6966 2073 686f 773a          if show:
+000161f0: 0a20 2020 2020 2020 2020 2020 2070 6c74  .            plt
+00016200: 2e73 686f 7728 290a 2020 2020 2020 2020  .show().        
+00016210: 7265 7475 726e 2066 6967 732c 206e 616d  return figs, nam
+00016220: 6573 0a0a 2020 2020 6465 6620 7361 7665  es..    def save
+00016230: 5f69 6d61 6765 7328 7365 6c66 2c20 7072  _images(self, pr
+00016240: 6566 6978 3a20 7374 7220 3d20 2222 2c20  efix: str = "", 
+00016250: 2a2a 6b77 6172 6773 293a 0a20 2020 2020  **kwargs):.     
+00016260: 2020 2022 2222 5361 7665 2074 6865 2066     """Save the f
+00016270: 6967 7572 6520 6f66 2060 706c 6f74 5f69  igure of `plot_i
+00016280: 6d61 6765 7328 2960 2074 6f20 6669 6c65  mages()` to file
+00016290: 2061 7320 504e 472e 204b 6579 776f 7264   as PNG. Keyword
+000162a0: 2061 7267 756d 656e 7473 2061 7265 2070   arguments are p
+000162b0: 6173 7365 6420 746f 2060 6d61 7470 6c6f  assed to `matplo
+000162c0: 746c 6962 2e70 7970 6c6f 742e 7361 7665  tlib.pyplot.save
+000162d0: 6669 6728 2960 2e0a 0a20 2020 2020 2020  fig()`...       
+000162e0: 2050 6172 616d 6574 6572 730a 2020 2020   Parameters.    
+000162f0: 2020 2020 2d2d 2d2d 2d2d 2d2d 2d2d 0a20      ----------. 
+00016300: 2020 2020 2020 2070 7265 6669 7820 3a20         prefix : 
+00016310: 7374 720a 2020 2020 2020 2020 2020 2020  str.            
+00016320: 5468 6520 7072 6566 6978 206e 616d 6520  The prefix name 
+00016330: 6f66 2074 6865 2066 696c 6520 746f 2073  of the file to s
+00016340: 6176 6520 746f 2e20 5468 6520 4242 206e  ave to. The BB n
+00016350: 616d 6520 6973 2061 7070 656e 6465 6420  ame is appended 
+00016360: 746f 2074 6865 2070 7265 6669 782e 0a20  to the prefix.. 
+00016370: 2020 2020 2020 2022 2222 0a20 2020 2020         """.     
+00016380: 2020 2066 6967 732c 206e 616d 6573 203d     figs, names =
+00016390: 2073 656c 662e 706c 6f74 5f69 6d61 6765   self.plot_image
+000163a0: 7328 7368 6f77 3d46 616c 7365 2c20 2a2a  s(show=False, **
+000163b0: 6b77 6172 6773 290a 2020 2020 2020 2020  kwargs).        
+000163c0: 666f 7220 6669 672c 206e 616d 6520 696e  for fig, name in
+000163d0: 207a 6970 2866 6967 732c 206e 616d 6573   zip(figs, names
+000163e0: 293a 0a20 2020 2020 2020 2020 2020 2066  ):.            f
+000163f0: 6967 2e73 6176 6566 6967 2870 7265 6669  ig.savefig(prefi
+00016400: 7820 2b20 225f 2220 2b20 7374 7228 6e61  x + "_" + str(na
+00016410: 6d65 2920 2b20 222e 706e 6722 2c20 2a2a  me) + ".png", **
+00016420: 6b77 6172 6773 290a 0a20 2020 2064 6566  kwargs)..    def
+00016430: 2073 6176 655f 696d 6167 6573 5f74 6f5f   save_images_to_
+00016440: 7374 7265 616d 2873 656c 662c 202a 2a6b  stream(self, **k
+00016450: 7761 7267 7329 202d 3e20 6469 6374 5b73  wargs) -> dict[s
+00016460: 7472 2c20 696f 2e42 7974 6573 494f 5d3a  tr, io.BytesIO]:
+00016470: 0a20 2020 2020 2020 2022 2222 5361 7665  .        """Save
+00016480: 2074 6865 2069 6e64 6976 6964 7561 6c20   the individual 
+00016490: 696d 6167 6520 706c 6f74 7320 746f 2073  image plots to s
+000164a0: 7472 6561 6d22 2222 0a20 2020 2020 2020  tream""".       
+000164b0: 2066 6967 732c 206e 616d 6573 203d 2073   figs, names = s
+000164c0: 656c 662e 706c 6f74 5f69 6d61 6765 7328  elf.plot_images(
+000164d0: 7368 6f77 3d46 616c 7365 2c20 2a2a 6b77  show=False, **kw
+000164e0: 6172 6773 290a 2020 2020 2020 2020 7374  args).        st
+000164f0: 7265 616d 7320 3d20 5b69 6f2e 4279 7465  reams = [io.Byte
+00016500: 7349 4f28 2920 666f 7220 5f20 696e 2066  sIO() for _ in f
+00016510: 6967 735d 0a20 2020 2020 2020 2066 6f72  igs].        for
+00016520: 2066 6967 2c20 7374 7265 616d 2069 6e20   fig, stream in 
+00016530: 7a69 7028 6669 6773 2c20 7374 7265 616d  zip(figs, stream
+00016540: 7329 3a0a 2020 2020 2020 2020 2020 2020  s):.            
+00016550: 6669 672e 7361 7665 6669 6728 7374 7265  fig.savefig(stre
+00016560: 616d 2c20 2a2a 6b77 6172 6773 290a 2020  am, **kwargs).  
+00016570: 2020 2020 2020 7265 7475 726e 207b 6e61        return {na
+00016580: 6d65 3a20 7374 7265 616d 2066 6f72 206e  me: stream for n
+00016590: 616d 652c 2073 7472 6561 6d20 696e 207a  ame, stream in z
+000165a0: 6970 286e 616d 6573 2c20 7374 7265 616d  ip(names, stream
+000165b0: 7329 7d0a 0a20 2020 2064 6566 205f 6765  s)}..    def _ge
+000165c0: 6e65 7261 7465 5f72 6573 756c 7473 5f64  nerate_results_d
+000165d0: 6174 6128 7365 6c66 2920 2d3e 2057 696e  ata(self) -> Win
+000165e0: 7374 6f6e 4c75 747a 4d75 6c74 6954 6172  stonLutzMultiTar
+000165f0: 6765 744d 756c 7469 4669 656c 6452 6573  getMultiFieldRes
+00016600: 756c 743a 0a20 2020 2020 2020 2022 2222  ult:.        """
+00016610: 5072 6573 656e 7420 7468 6520 7265 7375  Present the resu
+00016620: 6c74 7320 6461 7461 2061 6e64 206d 6574  lts data and met
+00016630: 6164 6174 6120 6173 2061 2064 6174 6163  adata as a datac
+00016640: 6c61 7373 206f 7220 6469 6374 2e0a 2020  lass or dict..  
+00016650: 2020 2020 2020 5468 6520 6465 6661 756c        The defaul
+00016660: 7420 7265 7475 726e 2074 7970 6520 6973  t return type is
+00016670: 2061 2064 6174 6163 6c61 7373 2e22 2222   a dataclass."""
+00016680: 0a20 2020 2020 2020 2069 6620 6e6f 7420  .        if not 
+00016690: 7365 6c66 2e5f 6973 5f61 6e61 6c79 7a65  self._is_analyze
+000166a0: 643a 0a20 2020 2020 2020 2020 2020 2072  d:.            r
+000166b0: 6169 7365 2056 616c 7565 4572 726f 7228  aise ValueError(
+000166c0: 2254 6865 2073 6574 2069 7320 6e6f 7420  "The set is not 
+000166d0: 616e 616c 797a 6564 2e20 5573 6520 2e61  analyzed. Use .a
+000166e0: 6e61 6c79 7a65 2829 2066 6972 7374 2e22  nalyze() first."
+000166f0: 290a 0a20 2020 2020 2020 2023 2066 6f72  )..        # for
+00016700: 2062 6163 6b77 6172 642d 636f 6d70 6174   backward-compat
+00016710: 6962 696c 6974 792c 2077 6520 6861 7665  ibility, we have
+00016720: 2074 6f20 6669 6e64 2074 6865 206d 6178   to find the max
+00016730: 2064 6973 7461 6e63 6520 666f 7220 6561   distance for ea
+00016740: 6368 2042 420a 2020 2020 2020 2020 2320  ch BB.        # 
+00016750: 6163 726f 7373 2074 6865 2069 6d61 6765  across the image
+00016760: 732e 0a20 2020 2020 2020 2062 625f 6d61  s..        bb_ma
+00016770: 7865 7320 3d20 7b7d 0a20 2020 2020 2020  xes = {}.       
+00016780: 2066 6f72 2062 6220 696e 2073 656c 662e   for bb in self.
+00016790: 6262 5f61 7272 616e 6765 6d65 6e74 3a0a  bb_arrangement:.
+000167a0: 2020 2020 2020 2020 2020 2020 6d61 785f              max_
+000167b0: 6420 3d20 302e 300a 2020 2020 2020 2020  d = 0.0.        
+000167c0: 2020 2020 666f 7220 696d 6720 696e 2073      for img in s
+000167d0: 656c 662e 696d 6167 6573 3a0a 2020 2020  elf.images:.    
+000167e0: 2020 2020 2020 2020 2020 2020 6966 2062              if b
+000167f0: 622e 6e61 6d65 2069 6e20 696d 672e 6172  b.name in img.ar
+00016800: 7261 6e67 656d 656e 745f 6d61 7463 6865  rangement_matche
+00016810: 733a 0a20 2020 2020 2020 2020 2020 2020  s:.             
+00016820: 2020 2020 2020 206d 6178 5f64 203d 206d         max_d = m
+00016830: 6178 280a 2020 2020 2020 2020 2020 2020  ax(.            
+00016840: 2020 2020 2020 2020 2020 2020 6d61 785f              max_
+00016850: 642c 2069 6d67 2e61 7272 616e 6765 6d65  d, img.arrangeme
+00016860: 6e74 5f6d 6174 6368 6573 5b62 622e 6e61  nt_matches[bb.na
+00016870: 6d65 5d2e 6262 5f66 6965 6c64 5f64 6973  me].bb_field_dis
+00016880: 7461 6e63 655f 6d6d 0a20 2020 2020 2020  tance_mm.       
+00016890: 2020 2020 2020 2020 2020 2020 2029 0a20               ). 
+000168a0: 2020 2020 2020 2020 2020 2062 625f 6d61             bb_ma
+000168b0: 7865 735b 6262 2e6e 616d 655d 203d 206d  xes[bb.name] = m
+000168c0: 6178 5f64 0a0a 2020 2020 2020 2020 7472  ax_d..        tr
+000168d0: 616e 736c 6174 696f 6e2c 2079 6177 2c20  anslation, yaw, 
+000168e0: 7069 7463 682c 2072 6f6c 6c20 3d20 7365  pitch, roll = se
+000168f0: 6c66 2e62 625f 7368 6966 745f 7665 6374  lf.bb_shift_vect
+00016900: 6f72 0a20 2020 2020 2020 2072 6574 7572  or.        retur
+00016910: 6e20 5769 6e73 746f 6e4c 7574 7a4d 756c  n WinstonLutzMul
+00016920: 7469 5461 7267 6574 4d75 6c74 6946 6965  tiTargetMultiFie
+00016930: 6c64 5265 7375 6c74 280a 2020 2020 2020  ldResult(.      
+00016940: 2020 2020 2020 6e75 6d5f 746f 7461 6c5f        num_total_
+00016950: 696d 6167 6573 3d6c 656e 2873 656c 662e  images=len(self.
+00016960: 696d 6167 6573 292c 0a20 2020 2020 2020  images),.       
+00016970: 2020 2020 206d 6178 5f32 645f 6669 656c       max_2d_fiel
+00016980: 645f 746f 5f62 625f 6d6d 3d73 656c 662e  d_to_bb_mm=self.
+00016990: 6d61 785f 6262 5f64 6576 6961 7469 6f6e  max_bb_deviation
+000169a0: 5f32 642c 0a20 2020 2020 2020 2020 2020  _2d,.           
+000169b0: 206d 6561 6e5f 3264 5f66 6965 6c64 5f74   mean_2d_field_t
+000169c0: 6f5f 6262 5f6d 6d3d 7365 6c66 2e6d 6561  o_bb_mm=self.mea
+000169d0: 6e5f 6262 5f64 6576 6961 7469 6f6e 5f32  n_bb_deviation_2
+000169e0: 642c 0a20 2020 2020 2020 2020 2020 206d  d,.            m
+000169f0: 6564 6961 6e5f 3264 5f66 6965 6c64 5f74  edian_2d_field_t
+00016a00: 6f5f 6262 5f6d 6d3d 7365 6c66 2e6d 6564  o_bb_mm=self.med
+00016a10: 6961 6e5f 6262 5f64 6576 6961 7469 6f6e  ian_bb_deviation
+00016a20: 5f32 642c 0a20 2020 2020 2020 2020 2020  _2d,.           
+00016a30: 2062 625f 6d61 7865 733d 6262 5f6d 6178   bb_maxes=bb_max
+00016a40: 6573 2c0a 2020 2020 2020 2020 2020 2020  es,.            
+00016a50: 6262 5f61 7272 616e 6765 6d65 6e74 3d73  bb_arrangement=s
+00016a60: 656c 662e 6262 5f61 7272 616e 6765 6d65  elf.bb_arrangeme
+00016a70: 6e74 2c0a 2020 2020 2020 2020 2020 2020  nt,.            
+00016a80: 6262 5f73 6869 6674 5f76 6563 746f 723d  bb_shift_vector=
+00016a90: 7472 616e 736c 6174 696f 6e2c 0a20 2020  translation,.   
+00016aa0: 2020 2020 2020 2020 2062 625f 7368 6966           bb_shif
+00016ab0: 745f 7961 773d 7961 772c 0a20 2020 2020  t_yaw=yaw,.     
+00016ac0: 2020 2020 2020 2062 625f 7368 6966 745f         bb_shift_
+00016ad0: 7069 7463 683d 7069 7463 682c 0a20 2020  pitch=pitch,.   
+00016ae0: 2020 2020 2020 2020 2062 625f 7368 6966           bb_shif
+00016af0: 745f 726f 6c6c 3d72 6f6c 6c2c 0a20 2020  t_roll=roll,.   
+00016b00: 2020 2020 2029 0a0a 2020 2020 6465 6620       )..    def 
+00016b10: 706c 6f74 5f73 756d 6d61 7279 2873 656c  plot_summary(sel
+00016b20: 662c 2073 686f 773a 2062 6f6f 6c20 3d20  f, show: bool = 
+00016b30: 5472 7565 2c20 6669 675f 7369 7a65 3a20  True, fig_size: 
+00016b40: 7475 706c 6520 7c20 4e6f 6e65 203d 204e  tuple | None = N
+00016b50: 6f6e 6529 3a0a 2020 2020 2020 2020 7261  one):.        ra
+00016b60: 6973 6520 4e6f 7449 6d70 6c65 6d65 6e74  ise NotImplement
+00016b70: 6564 4572 726f 7228 224e 6f74 2079 6574  edError("Not yet
+00016b80: 2069 6d70 6c65 6d65 6e74 6564 2229 0a0a   implemented")..
+00016b90: 2020 2020 6465 6620 706c 6f74 5f61 7869      def plot_axi
+00016ba0: 735f 696d 6167 6573 280a 2020 2020 2020  s_images(.      
+00016bb0: 2020 7365 6c66 2c20 6178 6973 3a20 4178    self, axis: Ax
+00016bc0: 6973 203d 2041 7869 732e 4741 4e54 5259  is = Axis.GANTRY
+00016bd0: 2c20 7368 6f77 3a20 626f 6f6c 203d 2054  , show: bool = T
+00016be0: 7275 652c 2061 783a 2070 6c74 2e41 7865  rue, ax: plt.Axe
+00016bf0: 7320 7c20 4e6f 6e65 203d 204e 6f6e 650a  s | None = None.
+00016c00: 2020 2020 293a 0a20 2020 2020 2020 2072      ):.        r
+00016c10: 6169 7365 204e 6f74 496d 706c 656d 656e  aise NotImplemen
+00016c20: 7465 6445 7272 6f72 2822 4e6f 7420 7965  tedError("Not ye
+00016c30: 7420 696d 706c 656d 656e 7465 6422 290a  t implemented").
+00016c40: 0a20 2020 2040 7072 6f70 6572 7479 0a20  .    @property. 
+00016c50: 2020 2064 6566 206d 6178 5f62 625f 6465     def max_bb_de
+00016c60: 7669 6174 696f 6e5f 3264 2873 656c 6629  viation_2d(self)
+00016c70: 202d 3e20 666c 6f61 743a 0a20 2020 2020   -> float:.     
+00016c80: 2020 2022 2222 5468 6520 6d61 7869 6d75     """The maximu
+00016c90: 6d20 6469 7374 616e 6365 2066 726f 6d20  m distance from 
+00016ca0: 616e 7920 6d65 6173 7572 6564 2042 4220  any measured BB 
+00016cb0: 746f 2069 7473 206e 6f6d 696e 616c 2070  to its nominal p
+00016cc0: 6f73 6974 696f 6e22 2222 0a20 2020 2020  osition""".     
+00016cd0: 2020 2072 6574 7572 6e20 7365 6c66 2e63     return self.c
+00016ce0: 6178 3262 625f 6469 7374 616e 6365 286d  ax2bb_distance(m
+00016cf0: 6574 7269 633d 226d 6178 2229 0a0a 2020  etric="max")..  
+00016d00: 2020 4070 726f 7065 7274 790a 2020 2020    @property.    
+00016d10: 6465 6620 6d65 616e 5f62 625f 6465 7669  def mean_bb_devi
+00016d20: 6174 696f 6e5f 3264 2873 656c 6629 202d  ation_2d(self) -
+00016d30: 3e20 666c 6f61 743a 0a20 2020 2020 2020  > float:.       
+00016d40: 2022 2222 5468 6520 6d65 616e 2064 6973   """The mean dis
+00016d50: 7461 6e63 6520 6672 6f6d 2061 6e79 206d  tance from any m
+00016d60: 6561 7375 7265 6420 4242 2074 6f20 6974  easured BB to it
+00016d70: 7320 6e6f 6d69 6e61 6c20 706f 7369 7469  s nominal positi
+00016d80: 6f6e 2222 220a 2020 2020 2020 2020 7265  on""".        re
+00016d90: 7475 726e 2073 656c 662e 6361 7832 6262  turn self.cax2bb
+00016da0: 5f64 6973 7461 6e63 6528 6d65 7472 6963  _distance(metric
+00016db0: 3d22 6d65 616e 2229 0a0a 2020 2020 4070  ="mean")..    @p
+00016dc0: 726f 7065 7274 790a 2020 2020 6465 6620  roperty.    def 
+00016dd0: 6d65 6469 616e 5f62 625f 6465 7669 6174  median_bb_deviat
+00016de0: 696f 6e5f 3264 2873 656c 6629 202d 3e20  ion_2d(self) -> 
+00016df0: 666c 6f61 743a 0a20 2020 2020 2020 2022  float:.        "
+00016e00: 2222 5468 6520 6d65 6469 616e 2064 6973  ""The median dis
+00016e10: 7461 6e63 6520 6672 6f6d 2061 6e79 206d  tance from any m
+00016e20: 6561 7375 7265 6420 4242 2074 6f20 6974  easured BB to it
+00016e30: 7320 6e6f 6d69 6e61 6c20 706f 7369 7469  s nominal positi
+00016e40: 6f6e 2222 220a 2020 2020 2020 2020 7265  on""".        re
+00016e50: 7475 726e 2073 656c 662e 6361 7832 6262  turn self.cax2bb
+00016e60: 5f64 6973 7461 6e63 6528 6d65 7472 6963  _distance(metric
+00016e70: 3d22 6d65 6469 616e 2229 0a0a 2020 2020  ="median")..    
+00016e80: 6465 6620 7265 7375 6c74 7328 7365 6c66  def results(self
+00016e90: 2c20 6173 5f6c 6973 743a 2062 6f6f 6c20  , as_list: bool 
+00016ea0: 3d20 4661 6c73 6529 202d 3e20 7374 723a  = False) -> str:
+00016eb0: 0a20 2020 2020 2020 2022 2222 5265 7475  .        """Retu
+00016ec0: 726e 2074 6865 2061 6e61 6c79 7369 7320  rn the analysis 
+00016ed0: 7265 7375 6c74 7320 7375 6d6d 6172 792e  results summary.
+00016ee0: 0a0a 2020 2020 2020 2020 5061 7261 6d65  ..        Parame
+00016ef0: 7465 7273 0a20 2020 2020 2020 202d 2d2d  ters.        ---
+00016f00: 2d2d 2d2d 2d2d 2d0a 2020 2020 2020 2020  -------.        
+00016f10: 6173 5f6c 6973 7420 3a20 626f 6f6c 0a20  as_list : bool. 
+00016f20: 2020 2020 2020 2020 2020 2057 6865 7468             Wheth
+00016f30: 6572 2074 6f20 7265 7475 726e 2061 7320  er to return as 
+00016f40: 6120 6c69 7374 206f 6620 7374 7269 6e67  a list of string
+00016f50: 7320 7673 2073 696e 676c 6520 7374 7269  s vs single stri
+00016f60: 6e67 2e20 5072 6574 7479 206d 7563 6820  ng. Pretty much 
+00016f70: 666f 7220 696e 7465 726e 616c 2075 7361  for internal usa
+00016f80: 6765 2e0a 2020 2020 2020 2020 2222 220a  ge..        """.
+00016f90: 2020 2020 2020 2020 6966 206e 6f74 2073          if not s
+00016fa0: 656c 662e 5f69 735f 616e 616c 797a 6564  elf._is_analyzed
+00016fb0: 3a0a 2020 2020 2020 2020 2020 2020 7261  :.            ra
+00016fc0: 6973 6520 5661 6c75 6545 7272 6f72 2822  ise ValueError("
+00016fd0: 5468 6520 7365 7420 6973 206e 6f74 2061  The set is not a
+00016fe0: 6e61 6c79 7a65 642e 2055 7365 202e 616e  nalyzed. Use .an
+00016ff0: 616c 797a 6528 2920 6669 7273 742e 2229  alyze() first.")
+00017000: 0a20 2020 2020 2020 206e 756d 5f69 6d67  .        num_img
+00017010: 7320 3d20 6c65 6e28 7365 6c66 2e69 6d61  s = len(self.ima
+00017020: 6765 7329 0a20 2020 2020 2020 2072 6573  ges).        res
+00017030: 756c 7420 3d20 5b0a 2020 2020 2020 2020  ult = [.        
+00017040: 2020 2020 2257 696e 7374 6f6e 2d4c 7574      "Winston-Lut
+00017050: 7a20 4d75 6c74 692d 5461 7267 6574 204d  z Multi-Target M
+00017060: 756c 7469 2d46 6965 6c64 2041 6e61 6c79  ulti-Field Analy
+00017070: 7369 7322 2c0a 2020 2020 2020 2020 2020  sis",.          
+00017080: 2020 223d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d    "=============
+00017090: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
+000170a0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
+000170b0: 3d22 2c0a 2020 2020 2020 2020 2020 2020  =",.            
+000170c0: 6622 4e75 6d62 6572 206f 6620 696d 6167  f"Number of imag
+000170d0: 6573 3a20 7b6e 756d 5f69 6d67 737d 222c  es: {num_imgs}",
+000170e0: 0a20 2020 2020 2020 2020 2020 2022 222c  .            "",
+000170f0: 0a20 2020 2020 2020 2020 2020 2022 3244  .            "2D
+00017100: 2064 6973 7461 6e63 6573 222c 0a20 2020   distances",.   
+00017110: 2020 2020 2020 2020 2022 3d3d 3d3d 3d3d           "======
+00017120: 3d3d 3d3d 3d3d 222c 0a20 2020 2020 2020  ======",.       
+00017130: 2020 2020 2066 224d 6178 2032 4420 6469       f"Max 2D di
+00017140: 7374 616e 6365 206f 6620 616e 7920 4242  stance of any BB
+00017150: 2d3e 4669 656c 643a 207b 7365 6c66 2e6d  ->Field: {self.m
+00017160: 6178 5f62 625f 6465 7669 6174 696f 6e5f  ax_bb_deviation_
+00017170: 3264 3a2e 3266 7d20 6d6d 222c 0a20 2020  2d:.2f} mm",.   
+00017180: 2020 2020 2020 2020 2066 224d 6561 6e20           f"Mean 
+00017190: 3244 2064 6973 7461 6e63 6520 6f66 2061  2D distance of a
+000171a0: 6e79 2042 422d 3e46 6965 6c64 3a20 7b73  ny BB->Field: {s
+000171b0: 656c 662e 6d65 616e 5f62 625f 6465 7669  elf.mean_bb_devi
+000171c0: 6174 696f 6e5f 3264 3a2e 3266 7d20 6d6d  ation_2d:.2f} mm
+000171d0: 222c 0a20 2020 2020 2020 2020 2020 2066  ",.            f
+000171e0: 224d 6564 6961 6e20 3244 2064 6973 7461  "Median 2D dista
+000171f0: 6e63 6520 6f66 2061 6e79 2042 422d 3e46  nce of any BB->F
+00017200: 6965 6c64 3a20 7b73 656c 662e 6d65 6469  ield: {self.medi
+00017210: 616e 5f62 625f 6465 7669 6174 696f 6e5f  an_bb_deviation_
+00017220: 3264 3a2e 3266 7d20 6d6d 222c 0a20 2020  2d:.2f} mm",.   
+00017230: 2020 2020 2020 2020 2022 222c 0a20 2020           "",.   
+00017240: 2020 2020 205d 0a20 2020 2020 2020 2062       ].        b
+00017250: 625f 6465 7363 7269 7074 696f 6e73 203d  b_descriptions =
+00017260: 205b 5b62 622e 6e61 6d65 2c20 6262 2e74   [[bb.name, bb.t
+00017270: 6f5f 6875 6d61 6e28 295d 2066 6f72 2062  o_human()] for b
+00017280: 6220 696e 2073 656c 662e 6262 5f61 7272  b in self.bb_arr
+00017290: 616e 6765 6d65 6e74 5d0a 2020 2020 2020  angement].      
+000172a0: 2020 6262 5f6e 616d 6573 203d 205b 6262    bb_names = [bb
+000172b0: 5b30 5d20 666f 7220 6262 2069 6e20 6262  [0] for bb in bb
+000172c0: 5f64 6573 6372 6970 7469 6f6e 735d 0a20  _descriptions]. 
+000172d0: 2020 2020 2020 2072 6573 756c 7420 2b3d         result +=
+000172e0: 2074 6162 756c 6174 6528 6262 5f64 6573   tabulate(bb_des
+000172f0: 6372 6970 7469 6f6e 732c 2068 6561 6465  criptions, heade
+00017300: 7273 3d5b 2242 4220 2322 2c20 2244 6573  rs=["BB #", "Des
+00017310: 6372 6970 7469 6f6e 225d 292e 7370 6c69  cription"]).spli
+00017320: 7428 225c 6e22 290a 2020 2020 2020 2020  t("\n").        
+00017330: 7265 7375 6c74 202b 3d20 5b0a 2020 2020  result += [.    
+00017340: 2020 2020 2020 2020 2222 2c0a 2020 2020          "",.    
+00017350: 2020 2020 5d0a 0a20 2020 2020 2020 2064      ]..        d
+00017360: 6174 6120 3d20 5b5d 0a20 2020 2020 2020  ata = [].       
+00017370: 2066 6f72 2069 6d67 2069 6e20 7365 6c66   for img in self
+00017380: 2e69 6d61 6765 733a 0a20 2020 2020 2020  .images:.       
+00017390: 2020 2020 2069 6d67 5f6e 616d 6520 3d20       img_name = 
+000173a0: 696d 672e 6261 7365 5f70 6174 685b 2d32  img.base_path[-2
+000173b0: 303a 5d0a 2020 2020 2020 2020 2020 2020  0:].            
+000173c0: 6761 6e74 7279 203d 2066 227b 696d 672e  gantry = f"{img.
+000173d0: 6761 6e74 7279 5f61 6e67 6c65 3a2e 3166  gantry_angle:.1f
+000173e0: 7d22 0a20 2020 2020 2020 2020 2020 2063  }".            c
+000173f0: 6f6c 6c69 6d61 746f 7220 3d20 6622 7b69  ollimator = f"{i
+00017400: 6d67 2e63 6f6c 6c69 6d61 746f 725f 616e  mg.collimator_an
+00017410: 676c 653a 2e31 667d 220a 2020 2020 2020  gle:.1f}".      
+00017420: 2020 2020 2020 636f 7563 6820 3d20 6622        couch = f"
+00017430: 7b69 6d67 2e63 6f75 6368 5f61 6e67 6c65  {img.couch_angle
+00017440: 3a2e 3166 7d22 0a20 2020 2020 2020 2020  :.1f}".         
+00017450: 2020 2064 6576 6961 7469 6f6e 7320 3d20     deviations = 
+00017460: 5b5d 0a20 2020 2020 2020 2020 2020 2023  [].            #
+00017470: 206c 6f6f 7020 7468 726f 7567 6820 7468   loop through th
+00017480: 6520 6578 7065 6374 6564 2042 4273 2e0a  e expected BBs..
+00017490: 2020 2020 2020 2020 2020 2020 2320 6e6f              # no
+000174a0: 7420 6576 6572 7920 4242 206d 6179 2062  t every BB may b
+000174b0: 6520 696e 2065 7665 7279 2069 6d61 6765  e in every image
+000174c0: 2c20 736f 2077 6520 6861 7665 2074 6f20  , so we have to 
+000174d0: 6c6f 6f70 2074 6872 6f75 6768 2074 6865  loop through the
+000174e0: 0a20 2020 2020 2020 2020 2020 2023 2042  .            # B
+000174f0: 4273 2061 6e64 2066 696e 6420 7468 6520  Bs and find the 
+00017500: 6d61 7463 6820 6966 2074 6865 7265 2069  match if there i
+00017510: 7320 6f6e 652e 0a20 2020 2020 2020 2020  s one..         
+00017520: 2020 2066 6f72 2062 6220 696e 2073 656c     for bb in sel
+00017530: 662e 6262 5f61 7272 616e 6765 6d65 6e74  f.bb_arrangement
+00017540: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+00017550: 2020 6d61 7463 6820 3d20 456e 756d 6572    match = Enumer
+00017560: 6162 6c65 2869 6d67 2e61 7272 616e 6765  able(img.arrange
+00017570: 6d65 6e74 5f6d 6174 6368 6573 2e69 7465  ment_matches.ite
+00017580: 6d73 2829 292e 7369 6e67 6c65 5f6f 725f  ms()).single_or_
+00017590: 6465 6661 756c 7428 0a20 2020 2020 2020  default(.       
+000175a0: 2020 2020 2020 2020 2020 2020 206c 616d               lam
+000175b0: 6264 6120 783a 2078 5b30 5d20 3d3d 2062  bda x: x[0] == b
+000175c0: 622e 6e61 6d65 0a20 2020 2020 2020 2020  b.name.         
+000175d0: 2020 2020 2020 2029 0a20 2020 2020 2020         ).       
+000175e0: 2020 2020 2020 2020 2069 6620 6d61 7463           if matc
+000175f0: 683a 0a20 2020 2020 2020 2020 2020 2020  h:.             
+00017600: 2020 2020 2020 2064 6576 6961 7469 6f6e         deviation
+00017610: 732e 6170 7065 6e64 2866 227b 6d61 7463  s.append(f"{matc
+00017620: 685b 315d 2e62 625f 6669 656c 645f 6469  h[1].bb_field_di
+00017630: 7374 616e 6365 5f6d 6d3a 2e32 667d 2229  stance_mm:.2f}")
+00017640: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00017650: 2065 6c73 653a 0a20 2020 2020 2020 2020   else:.         
+00017660: 2020 2020 2020 2020 2020 2064 6576 6961             devia
+00017670: 7469 6f6e 732e 6170 7065 6e64 2822 2d2d  tions.append("--
+00017680: 2d22 290a 2020 2020 2020 2020 2020 2020  -").            
+00017690: 6461 7461 2e61 7070 656e 6428 5b69 6d67  data.append([img
+000176a0: 5f6e 616d 652c 2067 616e 7472 792c 2063  _name, gantry, c
+000176b0: 6f6c 6c69 6d61 746f 722c 2063 6f75 6368  ollimator, couch
+000176c0: 2c20 2a64 6576 6961 7469 6f6e 735d 290a  , *deviations]).
+000176d0: 2020 2020 2020 2020 7265 7375 6c74 202b          result +
+000176e0: 3d20 7461 6275 6c61 7465 2864 6174 612c  = tabulate(data,
+000176f0: 2068 6561 6465 7273 3d5b 2249 6d61 6765   headers=["Image
+00017700: 222c 2022 4722 2c20 2243 222c 2022 5022  ", "G", "C", "P"
+00017710: 2c20 2a62 625f 6e61 6d65 735d 292e 7370  , *bb_names]).sp
+00017720: 6c69 7428 0a20 2020 2020 2020 2020 2020  lit(.           
+00017730: 2022 5c6e 220a 2020 2020 2020 2020 290a   "\n".        ).
+00017740: 2020 2020 2020 2020 7265 7375 6c74 202b          result +
+00017750: 3d20 5b22 225d 0a0a 2020 2020 2020 2020  = [""]..        
+00017760: 2320 6361 6c63 756c 6174 6520 636f 7563  # calculate couc
+00017770: 682d 6b69 636b 2065 7272 6f72 730a 2020  h-kick errors.  
+00017780: 2020 2020 2020 636f 7563 685f 7265 7375        couch_resu
+00017790: 6c74 7320 3d20 7365 6c66 2e5f 636f 7563  lts = self._couc
+000177a0: 685f 726f 7461 7469 6f6e 5f65 7272 6f72  h_rotation_error
+000177b0: 2829 0a20 2020 2020 2020 2063 6f75 6368  ().        couch
+000177c0: 5f64 6174 6120 3d20 5b0a 2020 2020 2020  _data = [.      
+000177d0: 2020 2020 2020 5b6e 616d 655b 2d32 303a        [name[-20:
+000177e0: 5d2c 2076 5b22 636f 7563 6820 616e 676c  ], v["couch angl
+000177f0: 6522 5d2c 2066 227b 765b 2779 6177 2065  e"], f"{v['yaw e
+00017800: 7272 6f72 275d 3a2e 3266 7d22 5d0a 2020  rror']:.2f}"].  
+00017810: 2020 2020 2020 2020 2020 666f 7220 6e61            for na
+00017820: 6d65 2c20 7620 696e 2063 6f75 6368 5f72  me, v in couch_r
+00017830: 6573 756c 7473 2e69 7465 6d73 2829 0a20  esults.items(). 
+00017840: 2020 2020 2020 205d 0a20 2020 2020 2020         ].       
+00017850: 2072 6573 756c 7420 2b3d 2074 6162 756c   result += tabul
+00017860: 6174 6528 0a20 2020 2020 2020 2020 2020  ate(.           
+00017870: 2063 6f75 6368 5f64 6174 612c 2068 6561   couch_data, hea
+00017880: 6465 7273 3d5b 2249 6d61 6765 222c 2022  ders=["Image", "
+00017890: 436f 7563 6820 416e 676c 6522 2c20 2259  Couch Angle", "Y
+000178a0: 6177 2045 7272 6f72 2028 5c4e 7b44 4547  aw Error (\N{DEG
+000178b0: 5245 4520 5349 474e 7d29 225d 0a20 2020  REE SIGN})"].   
+000178c0: 2020 2020 2029 2e73 706c 6974 2822 5c6e       ).split("\n
+000178d0: 2229 0a20 2020 2020 2020 2069 6620 6e6f  ").        if no
+000178e0: 7420 6173 5f6c 6973 743a 0a20 2020 2020  t as_list:.     
+000178f0: 2020 2020 2020 2072 6573 756c 7420 3d20         result = 
+00017900: 225c 6e22 2e6a 6f69 6e28 7265 7375 6c74  "\n".join(result
+00017910: 290a 2020 2020 2020 2020 7265 7475 726e  ).        return
+00017920: 2072 6573 756c 740a 0a20 2020 2064 6566   result..    def
+00017930: 2070 7562 6c69 7368 5f70 6466 280a 2020   publish_pdf(.  
+00017940: 2020 2020 2020 7365 6c66 2c0a 2020 2020        self,.    
+00017950: 2020 2020 6669 6c65 6e61 6d65 3a20 7374      filename: st
+00017960: 722c 0a20 2020 2020 2020 206e 6f74 6573  r,.        notes
+00017970: 3a20 7374 7220 7c20 6c69 7374 5b73 7472  : str | list[str
+00017980: 5d20 7c20 4e6f 6e65 203d 204e 6f6e 652c  ] | None = None,
+00017990: 0a20 2020 2020 2020 206f 7065 6e5f 6669  .        open_fi
+000179a0: 6c65 3a20 626f 6f6c 203d 2046 616c 7365  le: bool = False
+000179b0: 2c0a 2020 2020 2020 2020 6d65 7461 6461  ,.        metada
+000179c0: 7461 3a20 6469 6374 207c 204e 6f6e 6520  ta: dict | None 
+000179d0: 3d20 4e6f 6e65 2c0a 2020 2020 2020 2020  = None,.        
+000179e0: 6c6f 676f 3a20 5061 7468 207c 2073 7472  logo: Path | str
+000179f0: 207c 204e 6f6e 6520 3d20 4e6f 6e65 2c0a   | None = None,.
+00017a00: 2020 2020 293a 0a20 2020 2020 2020 2022      ):.        "
+00017a10: 2222 5075 626c 6973 6820 2870 7269 6e74  ""Publish (print
+00017a20: 2920 6120 5044 4620 636f 6e74 6169 6e69  ) a PDF containi
+00017a30: 6e67 2074 6865 2061 6e61 6c79 7369 732c  ng the analysis,
+00017a40: 2069 6d61 6765 732c 2061 6e64 2071 7561   images, and qua
+00017a50: 6e74 6974 6174 6976 6520 7265 7375 6c74  ntitative result
+00017a60: 732e 0a0a 2020 2020 2020 2020 5061 7261  s...        Para
+00017a70: 6d65 7465 7273 0a20 2020 2020 2020 202d  meters.        -
+00017a80: 2d2d 2d2d 2d2d 2d2d 2d0a 2020 2020 2020  ---------.      
+00017a90: 2020 6669 6c65 6e61 6d65 203a 2028 7374    filename : (st
+00017aa0: 722c 2066 696c 652d 6c69 6b65 206f 626a  r, file-like obj
+00017ab0: 6563 7429 0a20 2020 2020 2020 2020 2020  ect).           
+00017ac0: 2054 6865 2066 696c 6520 746f 2077 7269   The file to wri
+00017ad0: 7465 2074 6865 2072 6573 756c 7473 2074  te the results t
+00017ae0: 6f2e 0a20 2020 2020 2020 206e 6f74 6573  o..        notes
+00017af0: 203a 2073 7472 2c20 6c69 7374 206f 6620   : str, list of 
+00017b00: 7374 7269 6e67 730a 2020 2020 2020 2020  strings.        
+00017b10: 2020 2020 5465 7874 3b20 6966 2073 7472      Text; if str
+00017b20: 2c20 7072 696e 7473 2073 696e 676c 6520  , prints single 
+00017b30: 6c69 6e65 2e0a 2020 2020 2020 2020 2020  line..          
+00017b40: 2020 4966 206c 6973 7420 6f66 2073 7472    If list of str
+00017b50: 696e 6773 2c20 6561 6368 206c 6973 7420  ings, each list 
+00017b60: 6974 656d 2069 7320 7072 696e 7465 6420  item is printed 
+00017b70: 6f6e 2069 7473 206f 776e 206c 696e 652e  on its own line.
+00017b80: 0a20 2020 2020 2020 206f 7065 6e5f 6669  .        open_fi
+00017b90: 6c65 203a 2062 6f6f 6c0a 2020 2020 2020  le : bool.      
+00017ba0: 2020 2020 2020 5768 6574 6865 7220 746f        Whether to
+00017bb0: 206f 7065 6e20 7468 6520 6669 6c65 2075   open the file u
+00017bc0: 7369 6e67 2074 6865 2064 6566 6175 6c74  sing the default
+00017bd0: 2070 726f 6772 616d 2061 6674 6572 2063   program after c
+00017be0: 7265 6174 696f 6e2e 0a20 2020 2020 2020  reation..       
+00017bf0: 206d 6574 6164 6174 6120 3a20 6469 6374   metadata : dict
+00017c00: 0a20 2020 2020 2020 2020 2020 2045 7874  .            Ext
+00017c10: 7261 2064 6174 6120 746f 2062 6520 7061  ra data to be pa
+00017c20: 7373 6564 2061 6e64 2073 686f 776e 2069  ssed and shown i
+00017c30: 6e20 7468 6520 5044 462e 2054 6865 206b  n the PDF. The k
+00017c40: 6579 2061 6e64 2076 616c 7565 2077 696c  ey and value wil
+00017c50: 6c20 6265 2073 686f 776e 2077 6974 6820  l be shown with 
+00017c60: 6120 636f 6c6f 6e2e 0a20 2020 2020 2020  a colon..       
+00017c70: 2020 2020 2045 2e67 2e20 7061 7373 696e       E.g. passin
+00017c80: 6720 7b27 4175 7468 6f72 273a 2027 4a61  g {'Author': 'Ja
+00017c90: 6d65 7327 2c20 2755 6e69 7427 3a20 2754  mes', 'Unit': 'T
+00017ca0: 7275 6542 6561 6d27 7d20 776f 756c 6420  rueBeam'} would 
+00017cb0: 7265 7375 6c74 2069 6e20 7465 7874 2069  result in text i
+00017cc0: 6e20 7468 6520 5044 4620 6c69 6b65 3a0a  n the PDF like:.
+00017cd0: 2020 2020 2020 2020 2020 2020 2d2d 2d2d              ----
+00017ce0: 2d2d 2d2d 2d2d 2d2d 2d2d 0a20 2020 2020  ----------.     
+00017cf0: 2020 2020 2020 2041 7574 686f 723a 204a         Author: J
+00017d00: 616d 6573 0a20 2020 2020 2020 2020 2020  ames.           
+00017d10: 2055 6e69 743a 2054 7275 6542 6561 6d0a   Unit: TrueBeam.
+00017d20: 2020 2020 2020 2020 2020 2020 2d2d 2d2d              ----
+00017d30: 2d2d 2d2d 2d2d 2d2d 2d2d 0a20 2020 2020  ----------.     
+00017d40: 2020 206c 6f67 6f3a 2050 6174 682c 2073     logo: Path, s
+00017d50: 7472 0a20 2020 2020 2020 2020 2020 2041  tr.            A
+00017d60: 2063 7573 746f 6d20 6c6f 676f 2074 6f20   custom logo to 
+00017d70: 7573 6520 696e 2074 6865 2050 4446 2072  use in the PDF r
+00017d80: 6570 6f72 742e 2049 6620 6e6f 7468 696e  eport. If nothin
+00017d90: 6720 6973 2070 6173 7365 642c 2074 6865  g is passed, the
+00017da0: 2064 6566 6175 6c74 2070 796c 696e 6163   default pylinac
+00017db0: 206c 6f67 6f20 6973 2075 7365 642e 0a20   logo is used.. 
+00017dc0: 2020 2020 2020 2022 2222 0a20 2020 2020         """.     
+00017dd0: 2020 2069 6620 6e6f 7420 7365 6c66 2e5f     if not self._
+00017de0: 6973 5f61 6e61 6c79 7a65 643a 0a20 2020  is_analyzed:.   
+00017df0: 2020 2020 2020 2020 2072 6169 7365 2056           raise V
+00017e00: 616c 7565 4572 726f 7228 2254 6865 2073  alueError("The s
+00017e10: 6574 2069 7320 6e6f 7420 616e 616c 797a  et is not analyz
+00017e20: 6564 2e20 5573 6520 2e61 6e61 6c79 7a65  ed. Use .analyze
+00017e30: 2829 2066 6972 7374 2e22 290a 2020 2020  () first.").    
+00017e40: 2020 2020 706c 742e 696f 6666 2829 0a20      plt.ioff(). 
+00017e50: 2020 2020 2020 2074 6974 6c65 203d 2022         title = "
+00017e60: 5769 6e73 746f 6e2d 4c75 747a 204d 756c  Winston-Lutz Mul
+00017e70: 7469 2d42 4220 416e 616c 7973 6973 220a  ti-BB Analysis".
+00017e80: 2020 2020 2020 2020 6361 6e76 6173 203d          canvas =
+00017e90: 2070 6466 2e50 796c 696e 6163 4361 6e76   pdf.PylinacCanv
+00017ea0: 6173 280a 2020 2020 2020 2020 2020 2020  as(.            
+00017eb0: 6669 6c65 6e61 6d65 2c0a 2020 2020 2020  filename,.      
+00017ec0: 2020 2020 2020 7061 6765 5f74 6974 6c65        page_title
+00017ed0: 3d74 6974 6c65 2c0a 2020 2020 2020 2020  =title,.        
+00017ee0: 2020 2020 6d65 7461 6461 7461 3d6d 6574      metadata=met
+00017ef0: 6164 6174 612c 0a20 2020 2020 2020 2020  adata,.         
+00017f00: 2020 206c 6f67 6f3d 6c6f 676f 2c0a 2020     logo=logo,.  
+00017f10: 2020 2020 2020 2020 2020 6d65 7461 6461            metada
+00017f20: 7461 5f6c 6f63 6174 696f 6e3d 2831 352c  ta_location=(15,
+00017f30: 2032 352e 3529 2c0a 2020 2020 2020 2020   25.5),.        
+00017f40: 290a 2020 2020 2020 2020 7465 7874 203d  ).        text =
+00017f50: 2073 656c 662e 7265 7375 6c74 7328 6173   self.results(as
+00017f60: 5f6c 6973 743d 5472 7565 290a 2020 2020  _list=True).    
+00017f70: 2020 2020 6361 6e76 6173 2e61 6464 5f74      canvas.add_t
+00017f80: 6578 7428 7465 7874 3d74 6578 742c 206c  ext(text=text, l
+00017f90: 6f63 6174 696f 6e3d 2831 2c20 3235 2e35  ocation=(1, 25.5
+00017fa0: 292c 2066 6f6e 743d 2243 6f75 7269 6572  ), font="Courier
+00017fb0: 2229 0a20 2020 2020 2020 2023 2064 7261  ").        # dra
+00017fc0: 7720 7375 6d6d 6172 7920 696d 6167 6520  w summary image 
+00017fd0: 6f6e 2031 7374 2070 6167 650a 2020 2020  on 1st page.    
+00017fe0: 2020 2020 6966 206e 6f74 6573 2069 7320      if notes is 
+00017ff0: 6e6f 7420 4e6f 6e65 3a0a 2020 2020 2020  not None:.      
+00018000: 2020 2020 2020 6361 6e76 6173 2e61 6464        canvas.add
+00018010: 5f74 6578 7428 7465 7874 3d22 4e6f 7465  _text(text="Note
+00018020: 733a 222c 206c 6f63 6174 696f 6e3d 2831  s:", location=(1
+00018030: 2c20 342e 3529 2c20 666f 6e74 5f73 697a  , 4.5), font_siz
+00018040: 653d 3134 290a 2020 2020 2020 2020 2020  e=14).          
+00018050: 2020 6361 6e76 6173 2e61 6464 5f74 6578    canvas.add_tex
+00018060: 7428 7465 7874 3d6e 6f74 6573 2c20 6c6f  t(text=notes, lo
+00018070: 6361 7469 6f6e 3d28 312c 2034 2929 0a20  cation=(1, 4)). 
+00018080: 2020 2020 2020 2023 2070 6c6f 7420 6561         # plot ea
+00018090: 6368 2042 4227 7320 696d 6167 6573 0a20  ch BB's images. 
+000180a0: 2020 2020 2020 2062 625f 7374 7265 616d         bb_stream
+000180b0: 7320 3d20 7365 6c66 2e73 6176 655f 696d  s = self.save_im
+000180c0: 6167 6573 5f74 6f5f 7374 7265 616d 2829  ages_to_stream()
+000180d0: 0a20 2020 2020 2020 2066 6f72 2073 7472  .        for str
+000180e0: 6561 6d20 696e 2062 625f 7374 7265 616d  eam in bb_stream
+000180f0: 732e 7661 6c75 6573 2829 3a0a 2020 2020  s.values():.    
+00018100: 2020 2020 2020 2020 6361 6e76 6173 2e61          canvas.a
+00018110: 6464 5f6e 6577 5f70 6167 6528 290a 2020  dd_new_page().  
+00018120: 2020 2020 2020 2020 2020 6361 6e76 6173            canvas
+00018130: 2e61 6464 5f69 6d61 6765 2873 7472 6561  .add_image(strea
+00018140: 6d2c 206c 6f63 6174 696f 6e3d 2832 2c20  m, location=(2, 
+00018150: 3729 2c20 6469 6d65 6e73 696f 6e73 3d28  7), dimensions=(
+00018160: 3138 2c20 3138 2929 0a20 2020 2020 2020  18, 18)).       
+00018170: 2063 616e 7661 732e 6669 6e69 7368 2829   canvas.finish()
+00018180: 0a0a 2020 2020 2020 2020 6966 206f 7065  ..        if ope
+00018190: 6e5f 6669 6c65 3a0a 2020 2020 2020 2020  n_file:.        
+000181a0: 2020 2020 7765 6262 726f 7773 6572 2e6f      webbrowser.o
+000181b0: 7065 6e28 6669 6c65 6e61 6d65 290a 0a0a  pen(filename)...
+000181c0: 2320 636c 6173 7320 5769 6e73 746f 6e4c  # class WinstonL
+000181d0: 7574 7a4d 756c 7469 5461 7267 6574 5369  utzMultiTargetSi
+000181e0: 6e67 6c65 4669 656c 6449 6d61 6765 2857  ngleFieldImage(W
+000181f0: 696e 7374 6f6e 4c75 747a 4d75 6c74 6954  instonLutzMultiT
+00018200: 6172 6765 744d 756c 7469 4669 656c 6449  argetMultiFieldI
+00018210: 6d61 6765 293a 0a23 2020 2020 2064 6566  mage):.#     def
+00018220: 2066 696e 645f 6669 656c 645f 6365 6e74   find_field_cent
+00018230: 726f 6964 7328 7365 6c66 2c20 6973 5f6f  roids(self, is_o
+00018240: 7065 6e5f 6669 656c 643a 2062 6f6f 6c29  pen_field: bool)
+00018250: 202d 3e20 6c69 7374 5b50 6f69 6e74 5d3a   -> list[Point]:
+00018260: 0a23 2020 2020 2020 2020 2022 2222 466f  .#         """Fo
+00018270: 7220 7468 6520 7369 6e67 6c65 2066 6965  r the single fie
+00018280: 6c64 2063 6173 652c 2074 6865 2066 6965  ld case, the fie
+00018290: 6c64 2063 656e 7472 6f69 6420 6973 2074  ld centroid is t
+000182a0: 6865 2073 616d 6520 6173 2074 6865 2043  he same as the C
+000182b0: 4158 2e22 2222 0a23 2020 2020 2020 2020  AX.""".#        
+000182c0: 2023 2054 4f44 4f3a 2075 7365 2074 6865   # TODO: use the
+000182d0: 2067 6c6f 6261 6c20 6669 656c 6420 6669   global field fi
+000182e0: 6e64 6572 0a23 2020 2020 2020 2020 2072  nder.#         r
+000182f0: 6574 7572 6e20 5b73 656c 662e 6365 6e74  eturn [self.cent
+00018300: 6572 5d0a 230a 2320 2020 2020 6465 6620  er].#.#     def 
+00018310: 6669 6e64 5f66 6965 6c64 5f6d 6174 6368  find_field_match
+00018320: 6573 2873 656c 662c 2064 6574 6563 7465  es(self, detecte
+00018330: 645f 706f 696e 7473 3a20 6c69 7374 5b50  d_points: list[P
+00018340: 6f69 6e74 5d29 202d 3e20 6469 6374 5b73  oint]) -> dict[s
+00018350: 7472 2c20 506f 696e 745d 3a0a 2320 2020  tr, Point]:.#   
+00018360: 2020 2020 2020 2222 2246 6f72 2074 6865        """For the
+00018370: 2073 696e 676c 6520 6669 656c 6420 6361   single field ca
+00018380: 7365 2c20 7468 6520 6669 656c 6420 6365  se, the field ce
+00018390: 6e74 726f 6964 2069 7320 7468 6520 7361  ntroid is the sa
+000183a0: 6d65 2061 7320 7468 6520 4341 5820 666f  me as the CAX fo
+000183b0: 7220 6576 6572 7920 4242 2e22 2222 0a23  r every BB.""".#
+000183c0: 2020 2020 2020 2020 2072 6574 7572 6e20           return 
+000183d0: 7b62 622e 6e61 6d65 3a20 6465 7465 6374  {bb.name: detect
+000183e0: 6564 5f70 6f69 6e74 735b 305d 2066 6f72  ed_points[0] for
+000183f0: 2062 6220 696e 2073 656c 662e 6262 5f61   bb in self.bb_a
+00018400: 7272 616e 6765 6d65 6e74 7d0a 230a 2320  rrangement}.#.# 
+00018410: 2020 2020 6465 6620 6669 656c 645f 746f      def field_to
+00018420: 5f62 625f 6469 7374 616e 6365 7328 7365  _bb_distances(se
+00018430: 6c66 2920 2d3e 206c 6973 745b 666c 6f61  lf) -> list[floa
+00018440: 745d 3a0a 2320 2020 2020 2020 2020 2222  t]:.#         ""
+00018450: 2246 6f72 2061 2073 696e 676c 652d 6669  "For a single-fi
+00018460: 656c 642c 206d 756c 7469 2d42 4220 7365  eld, multi-BB se
+00018470: 7475 7020 7765 2073 6869 6674 2074 6865  tup we shift the
+00018480: 2042 4273 2074 6f20 7468 6520 6973 6f63   BBs to the isoc
+00018490: 656e 7465 7220 6279 2073 6869 6674 696e  enter by shiftin
+000184a0: 6720 6279 2074 6865 206e 6f6d 696e 616c  g by the nominal
+000184b0: 206f 6666 7365 742e 0a23 2020 2020 2020   offset..#      
+000184c0: 2020 2054 6865 2064 656c 7461 2062 6574     The delta bet
+000184d0: 7765 656e 2074 6865 206e 6f6d 696e 616c  ween the nominal
+000184e0: 2061 6e64 2061 6374 7561 6c20 4242 2070   and actual BB p
+000184f0: 6f73 6974 696f 6e20 6973 2074 6865 2073  osition is the s
+00018500: 616d 6520 6469 7374 616e 6365 2061 7320  ame distance as 
+00018510: 6966 2077 6520 7765 7265 2061 7420 6973  if we were at is
+00018520: 6f2e 0a23 2020 2020 2020 2020 2022 2222  o..#         """
+00018530: 0a23 2020 2020 2020 2020 2064 6973 7461  .#         dista
+00018540: 6e63 6573 203d 205b 5d0a 2320 2020 2020  nces = [].#     
+00018550: 2020 2020 666f 7220 6d61 7463 6820 696e      for match in
+00018560: 2073 656c 662e 6172 7261 6e67 656d 656e   self.arrangemen
+00018570: 745f 6d61 7463 6865 732e 7661 6c75 6573  t_matches.values
+00018580: 2829 3a0a 2320 2020 2020 2020 2020 2020  ():.#           
+00018590: 2020 6469 7374 616e 6365 732e 6170 7065    distances.appe
+000185a0: 6e64 286d 6174 6368 5b22 6262 206e 6f6d  nd(match["bb nom
+000185b0: 696e 616c 225d 2e64 6973 7461 6e63 655f  inal"].distance_
+000185c0: 746f 286d 6174 6368 5b22 6262 225d 2920  to(match["bb"]) 
+000185d0: 2f20 7365 6c66 2e64 706d 6d29 0a23 2020  / self.dpmm).#  
+000185e0: 2020 2020 2020 2072 6574 7572 6e20 6469         return di
+000185f0: 7374 616e 6365 730a 230a 230a 2320 636c  stances.#.#.# cl
+00018600: 6173 7320 5769 6e73 746f 6e4c 7574 7a4d  ass WinstonLutzM
+00018610: 756c 7469 5461 7267 6574 5369 6e67 6c65  ultiTargetSingle
+00018620: 4669 656c 6428 5769 6e73 746f 6e4c 7574  Field(WinstonLut
+00018630: 7a4d 756c 7469 5461 7267 6574 4d75 6c74  zMultiTargetMult
+00018640: 6946 6965 6c64 293a 0a23 2020 2020 2069  iField):.#     i
+00018650: 6d61 6765 5f74 7970 6520 3d20 5769 6e73  mage_type = Wins
+00018660: 746f 6e4c 7574 7a4d 756c 7469 5461 7267  tonLutzMultiTarg
+00018670: 6574 5369 6e67 6c65 4669 656c 6449 6d61  etSingleFieldIma
+00018680: 6765 0a23 2020 2020 2069 6d61 6765 733a  ge.#     images:
+00018690: 2053 6571 7565 6e63 655b 5769 6e73 746f   Sequence[Winsto
+000186a0: 6e4c 7574 7a4d 756c 7469 5461 7267 6574  nLutzMultiTarget
+000186b0: 5369 6e67 6c65 4669 656c 6449 6d61 6765  SingleFieldImage
+000186c0: 5d0a 0a0a 6465 6620 6d61 785f 6469 7374  ]...def max_dist
+000186d0: 616e 6365 5f74 6f5f 6c69 6e65 7328 702c  ance_to_lines(p,
+000186e0: 206c 696e 6573 3a20 4974 6572 6162 6c65   lines: Iterable
+000186f0: 5b4c 696e 655d 2920 2d3e 2066 6c6f 6174  [Line]) -> float
+00018700: 3a0a 2020 2020 2222 2243 616c 6375 6c61  :.    """Calcula
+00018710: 7465 2074 6865 206d 6178 696d 756d 2064  te the maximum d
+00018720: 6973 7461 6e63 6520 746f 2061 6e79 206c  istance to any l
+00018730: 696e 6520 6672 6f6d 2074 6865 2067 6976  ine from the giv
+00018740: 656e 2070 6f69 6e74 2e22 2222 0a20 2020  en point.""".   
+00018750: 2070 6f69 6e74 203d 2050 6f69 6e74 2870   point = Point(p
+00018760: 5b30 5d2c 2070 5b31 5d2c 2070 5b32 5d29  [0], p[1], p[2])
+00018770: 0a20 2020 2072 6574 7572 6e20 6d61 7828  .    return max(
+00018780: 6c69 6e65 2e64 6973 7461 6e63 655f 746f  line.distance_to
+00018790: 2870 6f69 6e74 2920 666f 7220 6c69 6e65  (point) for line
+000187a0: 2069 6e20 6c69 6e65 7329 0a0a 0a64 6566   in lines)...def
+000187b0: 2062 625f 7072 6f6a 6563 7469 6f6e 5f77   bb_projection_w
+000187c0: 6974 685f 726f 7461 7469 6f6e 280a 2020  ith_rotation(.  
+000187d0: 2020 6f66 6673 6574 5f6c 6566 743a 2066    offset_left: f
+000187e0: 6c6f 6174 2c0a 2020 2020 6f66 6673 6574  loat,.    offset
+000187f0: 5f75 703a 2066 6c6f 6174 2c0a 2020 2020  _up: float,.    
+00018800: 6f66 6673 6574 5f69 6e3a 2066 6c6f 6174  offset_in: float
+00018810: 2c0a 2020 2020 6761 6e74 7279 3a20 666c  ,.    gantry: fl
+00018820: 6f61 742c 0a20 2020 2063 6f75 6368 3a20  oat,.    couch: 
+00018830: 666c 6f61 742c 0a20 2020 2073 6164 3a20  float,.    sad: 
+00018840: 666c 6f61 7420 3d20 3130 3030 2c0a 2920  float = 1000,.) 
+00018850: 2d3e 2028 666c 6f61 742c 2066 6c6f 6174  -> (float, float
+00018860: 293a 0a20 2020 2022 2222 4361 6c63 756c  ):.    """Calcul
+00018870: 6174 6520 7468 6520 6973 6f70 6c61 6e65  ate the isoplane
+00018880: 2070 726f 6a65 6374 696f 6e20 6f6e 746f   projection onto
+00018890: 2074 6865 2070 616e 656c 2061 7420 7468   the panel at th
+000188a0: 6520 6769 7665 6e20 5353 442e 0a0a 2020  e given SSD...  
+000188b0: 2020 5468 6973 2066 756e 6374 696f 6e20    This function 
+000188c0: 6170 706c 6965 7320 6120 726f 7461 7469  applies a rotati
+000188d0: 6f6e 2061 726f 756e 6420 7468 6520 6761  on around the ga
+000188e0: 6e74 7279 2070 6c61 6e65 2028 582f 5a29  ntry plane (X/Z)
+000188f0: 2074 6f20 7468 650a 2020 2020 6261 6c6c   to the.    ball
+00018900: 2062 6561 7269 6e67 2028 4242 2920 706f   bearing (BB) po
+00018910: 7369 7469 6f6e 2061 6e64 2063 616c 6375  sition and calcu
+00018920: 6c61 7465 7320 6974 7320 7072 6f6a 6563  lates its projec
+00018930: 7469 6f6e 206f 6e74 6f20 7468 6520 6973  tion onto the is
+00018940: 6f63 656e 7465 7220 706c 616e 6520 696e  ocenter plane in
+00018950: 2074 6865 2062 6561 6d27 7320 6579 6520   the beam's eye 
+00018960: 7669 6577 2e0a 0a20 2020 2043 6f75 6c64  view...    Could
+00018970: 2062 6520 7573 6564 2074 6f20 6361 6c63   be used to calc
+00018980: 756c 6174 6520 636f 7563 6820 726f 7461  ulate couch rota
+00018990: 7469 6f6e 732c 2062 7574 206e 6f74 2076  tions, but not v
+000189a0: 616c 6964 6174 6564 2079 6574 2e0a 0a20  alidated yet... 
+000189b0: 2020 2041 7267 730a 2020 2020 2d2d 2d2d     Args.    ----
+000189c0: 0a20 2020 206f 6666 7365 745f 6c65 6674  .    offset_left
+000189d0: 2028 666c 6f61 7429 3a20 5468 6520 4242   (float): The BB
+000189e0: 2070 6f73 6974 696f 6e20 696e 2074 6865   position in the
+000189f0: 206c 6566 742f 7269 6768 7420 6469 7265   left/right dire
+00018a00: 6374 696f 6e2e 0a20 2020 206f 6666 7365  ction..    offse
+00018a10: 745f 7570 2028 666c 6f61 7429 3a20 5468  t_up (float): Th
+00018a20: 6520 4242 2070 6f73 6974 696f 6e20 696e  e BB position in
+00018a30: 2074 6865 2073 7570 6572 696f 722f 696e   the superior/in
+00018a40: 6665 7269 6f72 2064 6972 6563 7469 6f6e  ferior direction
+00018a50: 2e0a 2020 2020 6f66 6673 6574 5f69 6e20  ..    offset_in 
+00018a60: 2866 6c6f 6174 293a 2054 6865 2042 4220  (float): The BB 
+00018a70: 706f 7369 7469 6f6e 2069 6e20 7468 6520  position in the 
+00018a80: 616e 7465 7269 6f72 2f70 6f73 7465 7269  anterior/posteri
+00018a90: 6f72 2064 6972 6563 7469 6f6e 2e0a 2020  or direction..  
+00018aa0: 2020 6761 6e74 7279 2028 666c 6f61 7429    gantry (float)
+00018ab0: 3a20 5468 6520 6761 6e74 7279 2061 6e67  : The gantry ang
+00018ac0: 6c65 2069 6e20 6465 6772 6565 732e 0a20  le in degrees.. 
+00018ad0: 2020 2063 6f75 6368 2028 666c 6f61 742c     couch (float,
+00018ae0: 206f 7074 696f 6e61 6c29 3a20 5468 6520   optional): The 
+00018af0: 636f 7563 6820 616e 676c 6520 696e 2064  couch angle in d
+00018b00: 6567 7265 6573 2e20 4465 6661 756c 7473  egrees. Defaults
+00018b10: 2074 6f20 302e 0a20 2020 2073 6164 2028   to 0..    sad (
+00018b20: 666c 6f61 742c 206f 7074 696f 6e61 6c29  float, optional)
+00018b30: 3a20 5468 6520 736f 7572 6365 2d74 6f2d  : The source-to-
+00018b40: 6178 6973 2064 6973 7461 6e63 6520 696e  axis distance in
+00018b50: 206d 6d2e 2044 6566 6175 6c74 7320 746f   mm. Defaults to
+00018b60: 2031 3030 302e 0a0a 2020 2020 5265 7475   1000...    Retu
+00018b70: 726e 730a 2020 2020 2d2d 2d2d 2d2d 2d0a  rns.    -------.
+00018b80: 2020 2020 6c65 6674 5f72 6967 6874 5f70      left_right_p
+00018b90: 726f 6a65 6374 696f 6e20 2866 6c6f 6174  rojection (float
+00018ba0: 293a 2054 6865 2070 726f 6a65 6374 696f  ): The projectio
+00018bb0: 6e20 6f66 2074 6865 2042 4220 6f6e 746f  n of the BB onto
+00018bc0: 2074 6865 2070 616e 656c 2069 6e20 7468   the panel in th
+00018bd0: 6520 6c65 6674 2f72 6967 6874 2064 6972  e left/right dir
+00018be0: 6563 7469 6f6e 2e0a 2020 2020 2020 2020  ection..        
+00018bf0: 4c65 6674 2069 7320 6e65 6761 7469 7665  Left is negative
+00018c00: 2c20 7269 6768 7420 6973 2070 6f73 6974  , right is posit
+00018c10: 6976 652e 2054 6869 7320 6973 2061 6c77  ive. This is alw
+00018c20: 6179 7320 696e 2074 6865 2070 6c61 6e65  ays in the plane
+00018c30: 206e 6f72 6d61 6c20 746f 2074 6865 2043   normal to the C
+00018c40: 4158 2e0a 2020 2020 7375 7065 7269 6f72  AX..    superior
+00018c50: 5f69 6e66 6572 696f 725f 7072 6f6a 6563  _inferior_projec
+00018c60: 7469 6f6e 2028 666c 6f61 7429 3a20 5468  tion (float): Th
+00018c70: 6520 7072 6f6a 6563 7469 6f6e 206f 6620  e projection of 
+00018c80: 7468 6520 4242 206f 6e74 6f20 7468 6520  the BB onto the 
+00018c90: 7061 6e65 6c20 696e 2074 6865 2073 7570  panel in the sup
+00018ca0: 6572 696f 722f 696e 6665 7269 6f72 2064  erior/inferior d
+00018cb0: 6972 6563 7469 6f6e 2e0a 2020 2020 2020  irection..      
+00018cc0: 2020 5375 7065 7269 6f72 2069 7320 706f    Superior is po
+00018cd0: 7369 7469 7665 2c20 696e 6665 7269 6f72  sitive, inferior
+00018ce0: 2069 7320 6e65 6761 7469 7665 2e20 5468   is negative. Th
+00018cf0: 6973 2069 7320 616c 7761 7973 2069 6e20  is is always in 
+00018d00: 7468 6520 706c 616e 6520 6e6f 726d 616c  the plane normal
+00018d10: 2074 6f20 7468 6520 4341 5820 7768 6963   to the CAX whic
+00018d20: 680a 2020 2020 2020 2020 696e 2074 6869  h.        in thi
+00018d30: 7320 6361 7365 2069 7320 616c 736f 2074  s case is also t
+00018d40: 6865 2061 6273 6f6c 7574 6520 5920 636f  he absolute Y co
+00018d50: 6f72 6469 6e61 7465 2073 7973 7465 6d20  ordinate system 
+00018d60: 6178 6973 2e0a 2020 2020 2222 220a 2020  axis..    """.  
+00018d70: 2020 2320 4465 6669 6e65 2074 6865 2042    # Define the B
+00018d80: 4220 706f 7369 7469 6f6e 7320 696e 2074  B positions in t
+00018d90: 6865 2070 6174 6965 6e74 2063 6f6f 7264  he patient coord
+00018da0: 696e 6174 6520 7379 7374 656d 2028 6170  inate system (ap
+00018db0: 2c20 6c72 2c20 7369 290a 2020 2020 6262  , lr, si).    bb
+00018dc0: 5f70 6f73 6974 696f 6e73 203d 206e 702e  _positions = np.
+00018dd0: 6172 7261 7928 5b6f 6666 7365 745f 7570  array([offset_up
+00018de0: 2c20 6f66 6673 6574 5f6c 6566 742c 206f  , offset_left, o
+00018df0: 6666 7365 745f 696e 5d29 0a0a 2020 2020  ffset_in])..    
+00018e00: 2320 4170 706c 7920 7468 6520 726f 7461  # Apply the rota
+00018e10: 7469 6f6e 206d 6174 7269 7820 746f 2074  tion matrix to t
+00018e20: 6865 2042 4220 706f 7369 7469 6f6e 730a  he BB positions.
+00018e30: 2020 2020 636f 6c6c 696d 6174 6f72 203d      collimator =
+00018e40: 2030 2020 2320 436f 6c6c 696d 6174 6f72   0  # Collimator
+00018e50: 2064 6f65 736e 2774 2063 6861 6e67 6520   doesn't change 
+00018e60: 706f 7369 7469 6f6e 616c 2070 726f 6a65  positional proje
+00018e70: 6374 696f 6e20 6f6e 746f 2070 616e 656c  ction onto panel
+00018e80: 0a20 2020 2072 6f74 6174 696f 6e5f 6d61  .    rotation_ma
+00018e90: 7472 6978 203d 2052 6f74 6174 696f 6e2e  trix = Rotation.
+00018ea0: 6672 6f6d 5f65 756c 6572 280a 2020 2020  from_euler(.    
+00018eb0: 2020 2020 2278 797a 222c 0a20 2020 2020      "xyz",.     
+00018ec0: 2020 205b 2d63 6f75 6368 2c20 636f 6c6c     [-couch, coll
+00018ed0: 696d 6174 6f72 2c20 6761 6e74 7279 5d2c  imator, gantry],
+00018ee0: 0a20 2020 2020 2020 2064 6567 7265 6573  .        degrees
+00018ef0: 3d54 7275 652c 2020 2320 6e65 6761 7469  =True,  # negati
+00018f00: 7665 2063 6f75 6368 2064 7565 2074 6f20  ve couch due to 
+00018f10: 6f72 6967 696e 2073 6869 6674 2076 7320  origin shift vs 
+00018f20: 636f 6f72 6469 6e61 7465 2073 7061 6365  coordinate space
+00018f30: 0a20 2020 2029 0a20 2020 2072 6f74 6174  .    ).    rotat
+00018f40: 6564 5f70 6f73 6974 696f 6e73 203d 2072  ed_positions = r
+00018f50: 6f74 6174 696f 6e5f 6d61 7472 6978 2e61  otation_matrix.a
+00018f60: 7070 6c79 2862 625f 706f 7369 7469 6f6e  pply(bb_position
+00018f70: 7329 0a0a 2020 2020 2320 4361 6c63 756c  s)..    # Calcul
+00018f80: 6174 6520 7468 6520 7072 6f6a 6563 7469  ate the projecti
+00018f90: 6f6e 206f 6e74 6f20 7468 6520 7061 6e65  on onto the pane
+00018fa0: 6c20 6174 2074 6865 2067 6976 656e 2053  l at the given S
+00018fb0: 4144 0a20 2020 2062 625f 6d61 676e 6966  AD.    bb_magnif
+00018fc0: 6963 6174 696f 6e20 3d20 7361 6420 2f20  ication = sad / 
+00018fd0: 280a 2020 2020 2020 2020 7361 6420 2d20  (.        sad - 
+00018fe0: 726f 7461 7465 645f 706f 7369 7469 6f6e  rotated_position
+00018ff0: 735b 305d 0a20 2020 2029 2020 2320 4469  s[0].    )  # Di
+00019000: 7374 616e 6365 2066 726f 6d20 736f 7572  stance from sour
+00019010: 6365 2074 6f20 7061 6e65 6c0a 2020 2020  ce to panel.    
+00019020: 696d 6167 6572 5f70 726f 6a65 6374 696f  imager_projectio
+00019030: 6e20 3d20 280a 2020 2020 2020 2020 6e70  n = (.        np
+00019040: 2e61 7272 6179 285b 726f 7461 7465 645f  .array([rotated_
+00019050: 706f 7369 7469 6f6e 735b 315d 2c20 726f  positions[1], ro
+00019060: 7461 7465 645f 706f 7369 7469 6f6e 735b  tated_positions[
+00019070: 325d 5d29 202a 2062 625f 6d61 676e 6966  2]]) * bb_magnif
+00019080: 6963 6174 696f 6e0a 2020 2020 290a 2020  ication.    ).  
+00019090: 2020 7265 7475 726e 202d 696d 6167 6572    return -imager
+000190a0: 5f70 726f 6a65 6374 696f 6e5b 305d 2c20  _projection[0], 
+000190b0: 696d 6167 6572 5f70 726f 6a65 6374 696f  imager_projectio
+000190c0: 6e5b 315d 0a0a 0a64 6566 2073 7472 6169  n[1]...def strai
+000190d0: 6768 745f 7261 7928 7665 6374 6f72 3a20  ght_ray(vector: 
+000190e0: 5665 6374 6f72 2c20 6761 6e74 7279 5f61  Vector, gantry_a
+000190f0: 6e67 6c65 3a20 666c 6f61 7429 202d 3e20  ngle: float) -> 
+00019100: 4c69 6e65 3a0a 2020 2020 2222 2241 2072  Line:.    """A r
+00019110: 6179 2070 726f 6a65 6374 696e 6720 6672  ay projecting fr
+00019120: 6f6d 2074 6865 2067 616e 7472 7920 736f  om the gantry so
+00019130: 7572 6365 2070 6f69 6e74 2069 6e20 7468  urce point in th
+00019140: 6520 6769 7665 6e20 6469 7265 6374 696f  e given directio
+00019150: 6e2e 0a0a 2020 2020 4e6f 7465 730a 2020  n...    Notes.  
+00019160: 2020 2d2d 2d2d 2d0a 2020 2020 5468 6973    -----.    This
+00019170: 2064 6f65 7320 4e4f 5420 6163 636f 756e   does NOT accoun
+00019180: 7420 666f 7220 636f 7563 6820 726f 7461  t for couch rota
+00019190: 7469 6f6e 2e20 4974 2061 6c73 6f20 6765  tion. It also ge
+000191a0: 6e65 7261 7465 7320 6120 7374 7261 6967  nerates a straig
+000191b0: 6874 206c 696e 650a 2020 2020 7468 6174  ht line.    that
+000191c0: 2067 6f65 7320 7468 726f 7567 6820 7468   goes through th
+000191d0: 6520 7665 6374 6f72 2e20 492e 652e 2069  e vector. I.e. i
+000191e0: 6620 7468 6520 7665 6374 6f72 2069 7320  f the vector is 
+000191f0: 356d 6d20 6c65 6674 2c20 7468 6520 6c69  5mm left, the li
+00019200: 6e65 2077 696c 6c20 6265 2073 7472 6169  ne will be strai
+00019210: 6768 740a 2020 2020 7570 2061 6e64 2064  ght.    up and d
+00019220: 6f77 6e20 356d 6d20 6c65 6674 2e20 4974  own 5mm left. It
+00019230: 2064 6f65 7320 6e6f 7420 6163 636f 756e   does not accoun
+00019240: 7420 666f 7220 3244 2070 726f 6a65 6374  t for 2D project
+00019250: 696f 6e20 6672 6f6d 2074 6865 2067 616e  ion from the gan
+00019260: 7472 7920 736f 7572 6365 2e0a 2020 2020  try source..    
+00019270: 5468 6520 7265 6173 6f6e 2069 7320 7468  The reason is th
+00019280: 6174 2069 6e20 7661 6e69 6c6c 6120 574c  at in vanilla WL
+00019290: 2c20 7468 6520 6173 7375 6d70 7469 6f6e  , the assumption
+000192a0: 2069 7320 7468 6174 2074 6865 2066 6965   is that the fie
+000192b0: 6c64 2069 7320 6162 6f75 7420 6973 6f63  ld is about isoc
+000192c0: 656e 7465 7220 2869 2e65 2e20 6e6f 7420  enter (i.e. not 
+000192d0: 7075 7270 6f73 656c 7920 6f66 6673 6574  purposely offset
+000192e0: 290a 2020 2020 616e 6420 7468 7573 2063  ).    and thus c
+000192f0: 7265 6174 696e 6720 7374 7261 6967 6874  reating straight
+00019300: 206c 696e 6573 2069 7320 6120 676f 6f64   lines is a good
+00019310: 2061 7070 726f 7869 6d61 7469 6f6e 2e0a   approximation..
+00019320: 2020 2020 496e 2074 6865 204d 756c 7469      In the Multi
+00019330: 2d42 4220 6361 7365 2c20 6f75 7220 6669  -BB case, our fi
+00019340: 656c 6473 2061 7265 2070 7572 706f 7365  elds are purpose
+00019350: 6c79 206f 6666 2d63 656e 7465 722c 0a20  ly off-center,. 
+00019360: 2020 2073 6f20 7468 6973 2061 7373 756d     so this assum
+00019370: 7074 696f 6e20 646f 6573 206e 6f74 2068  ption does not h
+00019380: 6f6c 6420 666f 7220 7468 6174 2063 6173  old for that cas
+00019390: 652e 2053 6565 2074 6865 2060 6072 6179  e. See the ``ray
+000193a0: 6060 2066 756e 6374 696f 6e20 666f 7220  `` function for 
+000193b0: 7468 6174 2e0a 0a20 2020 2054 4c3b 4452  that...    TL;DR
+000193c0: 3a20 7468 6973 2069 7320 7573 6566 756c  : this is useful
+000193d0: 2066 6f72 2076 616e 696c 6c61 2057 4c20   for vanilla WL 
+000193e0: 6275 7420 6e6f 7420 4d75 6c74 692d 4242  but not Multi-BB
+000193f0: 2e0a 2020 2020 2222 220a 2020 2020 7031  ..    """.    p1
+00019400: 203d 2050 6f69 6e74 2829 0a20 2020 2070   = Point().    p
+00019410: 3220 3d20 506f 696e 7428 290a 2020 2020  2 = Point().    
+00019420: 2320 706f 696e 7420 3120 2d20 7261 7920  # point 1 - ray 
+00019430: 6f72 6967 696e 0a20 2020 2070 312e 7820  origin.    p1.x 
+00019440: 3d20 7665 6374 6f72 2e78 202a 2063 6f73  = vector.x * cos
+00019450: 2867 616e 7472 795f 616e 676c 6529 202b  (gantry_angle) +
+00019460: 2032 3020 2a20 7369 6e28 6761 6e74 7279   20 * sin(gantry
+00019470: 5f61 6e67 6c65 290a 2020 2020 7031 2e7a  _angle).    p1.z
+00019480: 203d 2076 6563 746f 722e 7820 2a20 2d73   = vector.x * -s
+00019490: 696e 2867 616e 7472 795f 616e 676c 6529  in(gantry_angle)
+000194a0: 202b 2032 3020 2a20 636f 7328 6761 6e74   + 20 * cos(gant
+000194b0: 7279 5f61 6e67 6c65 290a 2020 2020 7031  ry_angle).    p1
+000194c0: 2e79 203d 2076 6563 746f 722e 790a 2020  .y = vector.y.  
+000194d0: 2020 2320 706f 696e 7420 3220 2d20 7261    # point 2 - ra
+000194e0: 7920 6465 7374 696e 6174 696f 6e0a 2020  y destination.  
+000194f0: 2020 7032 2e78 203d 2076 6563 746f 722e    p2.x = vector.
+00019500: 7820 2a20 636f 7328 6761 6e74 7279 5f61  x * cos(gantry_a
+00019510: 6e67 6c65 2920 2d20 3230 202a 2073 696e  ngle) - 20 * sin
+00019520: 2867 616e 7472 795f 616e 676c 6529 0a20  (gantry_angle). 
+00019530: 2020 2070 322e 7a20 3d20 7665 6374 6f72     p2.z = vector
+00019540: 2e78 202a 202d 7369 6e28 6761 6e74 7279  .x * -sin(gantry
+00019550: 5f61 6e67 6c65 2920 2d20 3230 202a 2063  _angle) - 20 * c
+00019560: 6f73 2867 616e 7472 795f 616e 676c 6529  os(gantry_angle)
+00019570: 0a20 2020 2070 322e 7920 3d20 7665 6374  .    p2.y = vect
+00019580: 6f72 2e79 0a20 2020 206c 696e 6520 3d20  or.y.    line = 
+00019590: 4c69 6e65 2870 312c 2070 3229 0a20 2020  Line(p1, p2).   
+000195a0: 2072 6574 7572 6e20 6c69 6e65 0a0a 0a64   return line...d
+000195b0: 6566 2073 6f6c 7665 5f33 645f 7368 6966  ef solve_3d_shif
+000195c0: 745f 7665 6374 6f72 5f66 726f 6d5f 3264  t_vector_from_2d
+000195d0: 5f70 6c61 6e65 7328 0a20 2020 2078 733a  _planes(.    xs:
+000195e0: 2053 6571 7565 6e63 655b 666c 6f61 745d   Sequence[float]
+000195f0: 2c0a 2020 2020 7973 3a20 5365 7175 656e  ,.    ys: Sequen
+00019600: 6365 5b66 6c6f 6174 5d2c 0a20 2020 2074  ce[float],.    t
+00019610: 6865 7461 733a 2053 6571 7565 6e63 655b  hetas: Sequence[
+00019620: 666c 6f61 745d 2c0a 2020 2020 7068 6973  float],.    phis
+00019630: 3a20 5365 7175 656e 6365 5b66 6c6f 6174  : Sequence[float
+00019640: 5d2c 0a20 2020 2073 6361 6c65 3a20 4d61  ],.    scale: Ma
+00019650: 6368 696e 6553 6361 6c65 2c0a 2920 2d3e  chineScale,.) ->
+00019660: 2056 6563 746f 723a 0a20 2020 2022 2222   Vector:.    """
+00019670: 536f 6c76 6520 666f 7220 6c6f 6e67 2c20  Solve for long, 
+00019680: 6c61 742c 2061 6e64 2076 6572 7420 6769  lat, and vert gi
+00019690: 7665 6e20 6172 7261 7973 206f 6620 7827  ven arrays of x'
+000196a0: 732c 2079 2773 2c20 7468 6574 6127 732c  s, y's, theta's,
+000196b0: 2061 6e64 2070 6869 2773 2e0a 2020 2020   and phi's..    
+000196c0: 5468 6973 2069 7320 592c 2058 2c20 616e  This is Y, X, an
+000196d0: 6420 5a20 696e 2070 796c 696e 6163 2063  d Z in pylinac c
+000196e0: 6f6f 7264 696e 6174 6520 636f 6e76 656e  oordinate conven
+000196f0: 7469 6f6e 732e 0a0a 2020 2020 5468 6973  tions...    This
+00019700: 2069 7320 6120 6765 6e65 7261 6c69 7a61   is a generaliza
+00019710: 7469 6f6e 206f 6620 7468 6520 4c6f 7720  tion of the Low 
+00019720: 6574 2061 6c2e 2065 7175 6174 696f 6e20  et al. equation 
+00019730: 3620 616e 6420 372e 2054 6869 7320 6973  6 and 7. This is
+00019740: 2075 7365 6420 666f 7220 626f 7468 2076   used for both v
+00019750: 616e 696c 6c61 2057 4c20 616e 6420 4d75  anilla WL and Mu
+00019760: 6c74 692d 4242 2057 4c2e 0a20 2020 2054  lti-BB WL..    T
+00019770: 6869 7320 6973 2069 6e74 656e 6465 6420  his is intended 
+00019780: 746f 2062 6520 6120 7265 6c61 7469 7665  to be a relative
+00019790: 6c79 2073 7472 6963 7420 696e 7465 7270  ly strict interp
+000197a0: 7265 7461 7469 6f6e 206f 6620 7468 6520  retation of the 
+000197b0: 4c6f 7720 6574 2061 6c2e 2065 7175 6174  Low et al. equat
+000197c0: 696f 6e73 2e0a 2020 2020 452e 672e 2074  ions..    E.g. t
+000197d0: 6865 2067 616e 7472 7920 616e 6420 636f  he gantry and co
+000197e0: 7563 6820 616e 676c 6573 2061 7265 2063  uch angles are c
+000197f0: 6f6e 7665 7274 6564 2074 6f20 5661 7269  onverted to Vari
+00019800: 616e 2053 7461 6e64 6172 6420 7363 616c  an Standard scal
+00019810: 652e 0a20 2020 2054 6865 2069 6465 6120  e..    The idea 
+00019820: 6973 2074 6869 7320 6973 206d 6561 6e74  is this is meant
+00019830: 2066 6f72 2068 6967 6820 7265 6164 6162   for high readab
+00019840: 696c 6974 7920 7768 656e 2063 6f6d 7061  ility when compa
+00019850: 7269 6e67 2074 6f20 7468 6520 4c6f 7720  ring to the Low 
+00019860: 6574 2061 6c2e 2065 7175 6174 696f 6e73  et al. equations
+00019870: 2e0a 2020 2020 486f 7765 7665 722c 2074  ..    However, t
+00019880: 6869 7320 646f 6573 206d 6561 6e20 7765  his does mean we
+00019890: 2068 6176 6520 746f 2069 6e76 6572 7420   have to invert 
+000198a0: 7468 6520 4c4f 4e47 2f59 2061 7869 732e  the LONG/Y axis.
+000198b0: 2053 6565 2074 6865 2063 6f6e 7665 7273   See the convers
+000198c0: 696f 6e20 7461 626c 6520 696e 2074 6865  ion table in the
+000198d0: 2064 6f63 730a 0a20 2020 2050 6172 616d   docs..    Param
+000198e0: 6574 6572 730a 2020 2020 2d2d 2d2d 2d2d  eters.    ------
+000198f0: 2d2d 2d2d 0a20 2020 2078 7320 3a20 6172  ----.    xs : ar
+00019900: 7261 795f 6c69 6b65 0a20 2020 2020 2020  ray_like.       
+00019910: 2041 7272 6179 206f 6620 7820 636f 6f72   Array of x coor
+00019920: 6469 6e61 7465 732e 2050 6f73 6974 6976  dinates. Positiv
+00019930: 6520 6973 2074 6f20 7468 6520 7269 6768  e is to the righ
+00019940: 7420 696e 2074 6865 206c 6f63 616c 2070  t in the local p
+00019950: 6c61 6e65 2e0a 2020 2020 7973 203a 2061  lane..    ys : a
+00019960: 7272 6179 5f6c 696b 650a 2020 2020 2020  rray_like.      
+00019970: 2020 4172 7261 7920 6f66 2079 2063 6f6f    Array of y coo
+00019980: 7264 696e 6174 6573 2e20 506f 7369 7469  rdinates. Positi
+00019990: 7665 2069 7320 7570 2069 6e20 7468 6520  ve is up in the 
+000199a0: 6c6f 6361 6c20 706c 616e 652e 0a20 2020  local plane..   
+000199b0: 2074 6865 7461 7320 3a20 6172 7261 795f   thetas : array_
+000199c0: 6c69 6b65 0a20 2020 2020 2020 2041 7272  like.        Arr
+000199d0: 6179 206f 6620 6761 6e74 7279 2061 6e67  ay of gantry ang
+000199e0: 6c65 732e 0a20 2020 2070 6869 7320 3a20  les..    phis : 
+000199f0: 6172 7261 795f 6c69 6b65 0a20 2020 2020  array_like.     
+00019a00: 2020 2041 7272 6179 206f 6620 636f 7563     Array of couc
+00019a10: 6820 616e 676c 6573 2e0a 2020 2020 7363  h angles..    sc
+00019a20: 616c 653a 204d 6163 6869 6e65 5363 616c  ale: MachineScal
+00019a30: 650a 2020 2020 2020 2020 5468 6520 7363  e.        The sc
+00019a40: 616c 6520 6f66 2074 6865 206d 6163 6869  ale of the machi
+00019a50: 6e65 2e20 4945 4336 3132 3137 2069 7320  ne. IEC61217 is 
+00019a60: 7468 6520 6465 6661 756c 742e 2054 6869  the default. Thi
+00019a70: 7320 636f 6e76 6572 7473 2074 6865 2067  s converts the g
+00019a80: 616e 7472 7920 616e 6420 636f 7563 6820  antry and couch 
+00019a90: 616e 676c 6573 2074 6f20 5661 7269 616e  angles to Varian
+00019aa0: 2053 7461 6e64 6172 6420 7363 616c 650a   Standard scale.
+00019ab0: 2020 2020 2020 2020 7768 6963 6820 6973          which is
+00019ac0: 2074 6f20 6d61 7463 6820 4c6f 7727 7320   to match Low's 
+00019ad0: 6571 7561 7469 6f6e 732e 0a0a 2020 2020  equations...    
+00019ae0: 5265 7475 726e 730a 2020 2020 2d2d 2d2d  Returns.    ----
+00019af0: 2d2d 2d0a 2020 2020 5665 6374 6f72 0a20  ---.    Vector. 
+00019b00: 2020 2020 2020 2054 6865 2063 6f6f 7264         The coord
+00019b10: 696e 6174 6573 2061 7265 2069 6e20 7468  inates are in th
+00019b20: 6520 7079 6c69 6e61 6320 636f 6f72 6469  e pylinac coordi
+00019b30: 6e61 7465 2073 7973 7465 6d2e 2053 6565  nate system. See
+00019b40: 2064 6f63 732e 0a20 2020 2022 2222 0a20   docs..    """. 
+00019b50: 2020 2069 6620 6e6f 7420 286c 656e 2878     if not (len(x
+00019b60: 7329 203d 3d20 6c65 6e28 7973 2920 3d3d  s) == len(ys) ==
+00019b70: 206c 656e 2874 6865 7461 7329 203d 3d20   len(thetas) == 
+00019b80: 6c65 6e28 7068 6973 2929 3a0a 2020 2020  len(phis)):.    
+00019b90: 2020 2020 7261 6973 6520 5661 6c75 6545      raise ValueE
+00019ba0: 7272 6f72 2822 5468 6520 782c 2079 2c20  rror("The x, y, 
+00019bb0: 7468 6574 612c 2061 6e64 2070 6869 2061  theta, and phi a
+00019bc0: 7272 6179 7320 6d75 7374 2061 6c6c 2062  rrays must all b
+00019bd0: 6520 7468 6520 7361 6d65 206c 656e 6774  e the same lengt
+00019be0: 682e 2229 0a20 2020 206e 203d 206c 656e  h.").    n = len
+00019bf0: 2878 7329 0a0a 2020 2020 2320 636f 6e76  (xs)..    # conv
+00019c00: 6572 7420 7468 6520 616e 676c 6573 2074  ert the angles t
+00019c10: 6f20 5661 7269 616e 2053 7461 6e64 6172  o Varian Standar
+00019c20: 6420 7363 616c 650a 2020 2020 665f 7468  d scale.    f_th
+00019c30: 6574 6173 2c20 665f 7068 6973 203d 205b  etas, f_phis = [
+00019c40: 5d2c 205b 5d0a 2020 2020 666f 7220 7468  ], [].    for th
+00019c50: 6574 612c 2070 6869 2069 6e20 7a69 7028  eta, phi in zip(
+00019c60: 7468 6574 6173 2c20 7068 6973 293a 0a20  thetas, phis):. 
+00019c70: 2020 2020 2020 2067 2c20 5f2c 2063 203d         g, _, c =
+00019c80: 2063 6f6e 7665 7274 280a 2020 2020 2020   convert(.      
+00019c90: 2020 2020 2020 7363 616c 652c 0a20 2020        scale,.   
+00019ca0: 2020 2020 2020 2020 204d 6163 6869 6e65           Machine
+00019cb0: 5363 616c 652e 5641 5249 414e 5f53 5441  Scale.VARIAN_STA
+00019cc0: 4e44 4152 442c 0a20 2020 2020 2020 2020  NDARD,.         
+00019cd0: 2020 2067 616e 7472 793d 7468 6574 612c     gantry=theta,
+00019ce0: 0a20 2020 2020 2020 2020 2020 2063 6f6c  .            col
+00019cf0: 6c69 6d61 746f 723d 302c 0a20 2020 2020  limator=0,.     
+00019d00: 2020 2020 2020 2072 6f74 6174 696f 6e3d         rotation=
+00019d10: 7068 692c 0a20 2020 2020 2020 2029 0a20  phi,.        ). 
+00019d20: 2020 2020 2020 2066 5f74 6865 7461 732e         f_thetas.
+00019d30: 6170 7065 6e64 2867 290a 2020 2020 2020  append(g).      
+00019d40: 2020 665f 7068 6973 2e61 7070 656e 6428    f_phis.append(
+00019d50: 6329 0a0a 2020 2020 2320 496e 6974 6961  c)..    # Initia
+00019d60: 6c69 7a65 2041 206d 6174 7269 7820 616e  lize A matrix an
+00019d70: 6420 7869 206d 6174 7269 6365 730a 2020  d xi matrices.  
+00019d80: 2020 4120 3d20 6e70 2e7a 6572 6f73 2828    A = np.zeros((
+00019d90: 3220 2a20 6e2c 2033 2929 0a20 2020 2078  2 * n, 3)).    x
+00019da0: 6920 3d20 6e70 2e7a 6572 6f73 2832 202a  i = np.zeros(2 *
+00019db0: 206e 290a 0a20 2020 2066 6f72 2069 2069   n)..    for i i
+00019dc0: 6e20 7261 6e67 6528 6e29 3a0a 2020 2020  n range(n):.    
+00019dd0: 2020 2020 2320 4120 6765 6e65 7261 6c20      # A general 
+00019de0: 726f 7461 7469 6f6e 206d 6174 7269 7820  rotation matrix 
+00019df0: 616e 6420 616c 736f 204c 6f77 2065 716e  and also Low eqn
+00019e00: 2036 610a 2020 2020 2020 2020 415b 3220   6a.        A[2 
+00019e10: 2a20 692c 203a 5d20 3d20 5b2d 636f 7328  * i, :] = [-cos(
+00019e20: 665f 7068 6973 5b69 5d29 2c20 2d73 696e  f_phis[i]), -sin
+00019e30: 2866 5f70 6869 735b 695d 292c 2030 5d0a  (f_phis[i]), 0].
+00019e40: 2020 2020 2020 2020 415b 3220 2a20 6920          A[2 * i 
+00019e50: 2b20 312c 203a 5d20 3d20 5b0a 2020 2020  + 1, :] = [.    
+00019e60: 2020 2020 2020 2020 2d63 6f73 2866 5f74          -cos(f_t
+00019e70: 6865 7461 735b 695d 2920 2a20 7369 6e28  hetas[i]) * sin(
+00019e80: 665f 7068 6973 5b69 5d29 2c0a 2020 2020  f_phis[i]),.    
+00019e90: 2020 2020 2020 2020 636f 7328 665f 7468          cos(f_th
+00019ea0: 6574 6173 5b69 5d29 202a 2063 6f73 2866  etas[i]) * cos(f
+00019eb0: 5f70 6869 735b 695d 292c 0a20 2020 2020  _phis[i]),.     
+00019ec0: 2020 2020 2020 202d 7369 6e28 665f 7468         -sin(f_th
+00019ed0: 6574 6173 5b69 5d29 2c0a 2020 2020 2020  etas[i]),.      
+00019ee0: 2020 5d0a 2020 2020 2020 2020 2320 4c6f    ].        # Lo
+00019ef0: 7720 6571 6e20 370a 2020 2020 2020 2020  w eqn 7.        
+00019f00: 7869 5b32 202a 2069 5d20 3d20 7973 5b0a  xi[2 * i] = ys[.
+00019f10: 2020 2020 2020 2020 2020 2020 690a 2020              i.  
+00019f20: 2020 2020 2020 5d20 2023 2075 7375 616c        ]  # usual
+00019f30: 6c79 2074 6869 7320 776f 756c 6420 6265  ly this would be
+00019f40: 2028 782c 2079 2920 6275 7420 4669 6775   (x, y) but Figu
+00019f50: 7265 2031 206f 6620 4c6f 7720 6973 2072  re 1 of Low is r
+00019f60: 6f74 6174 6564 2039 3020 6465 6772 6565  otated 90 degree
+00019f70: 732e 0a20 2020 2020 2020 2078 695b 3220  s..        xi[2 
+00019f80: 2a20 6920 2b20 315d 203d 202d 7873 5b69  * i + 1] = -xs[i
+00019f90: 5d0a 0a20 2020 2023 2065 7175 6174 696f  ]..    # equatio
+00019fa0: 6e20 3961 3b20 4220 6973 2074 6865 2070  n 9a; B is the p
+00019fb0: 7365 7564 6f2d 696e 7665 7273 6520 6f66  seudo-inverse of
+00019fc0: 2041 0a20 2020 2042 203d 206e 702e 6c69   A.    B = np.li
+00019fd0: 6e61 6c67 2e70 696e 7628 4129 0a20 2020  nalg.pinv(A).   
+00019fe0: 2023 2066 756c 6c20 6571 7561 7469 6f6e   # full equation
+00019ff0: 2039 0a20 2020 206c 6f6e 672c 206c 6174   9.    long, lat
+0001a000: 2c20 7665 7274 203d 2042 2e64 6f74 2878  , vert = B.dot(x
+0001a010: 6929 2e73 7175 6565 7a65 2829 0a0a 2020  i).squeeze()..  
+0001a020: 2020 2320 4174 2074 6869 7320 706f 696e    # At this poin
+0001a030: 7420 7765 2068 6176 6520 7468 6520 2a2a  t we have the **
+0001a040: 4c6f 7720 6574 2061 6c20 7368 6966 7420  Low et al shift 
+0001a050: 7665 6374 6f72 2a2a 2e20 436f 6e76 6572  vector**. Conver
+0001a060: 7369 6f6e 2074 6f20 7079 6c69 6e61 6320  sion to pylinac 
+0001a070: 636f 6f72 6469 6e61 7465 730a 2020 2020  coordinates.    
+0001a080: 2320 7265 7175 6972 6573 2066 6c69 7070  # requires flipp
+0001a090: 696e 6720 7468 6520 4c4f 4e47 2061 7869  ing the LONG axi
+0001a0a0: 733b 2073 6565 2074 6865 2063 6f6e 7665  s; see the conve
+0001a0b0: 7273 696f 6e20 7461 626c 6520 696e 2074  rsion table in t
+0001a0c0: 6865 2064 6f63 732e 0a20 2020 2023 2077  he docs..    # w
+0001a0d0: 6520 7573 6520 7468 6520 582f 592f 5a20  e use the X/Y/Z 
+0001a0e0: 7465 726d 7320 666f 7220 7468 6520 7368  terms for the sh
+0001a0f0: 6966 7420 746f 2062 6520 636f 6e73 6973  ift to be consis
+0001a100: 7465 6e74 2077 6974 6820 6f75 7220 6f77  tent with our ow
+0001a110: 6e20 636f 6e76 656e 7469 6f6e 0a20 2020  n convention.   
+0001a120: 2023 2061 6e64 2066 6f72 2063 6c61 7269   # and for clari
+0001a130: 7479 206f 6620 7468 6520 636f 6e76 6572  ty of the conver
+0001a140: 7369 6f6e 0a20 2020 2023 2046 696e 616c  sion.    # Final
+0001a150: 6c79 2c20 7468 6973 2069 7320 7468 6520  ly, this is the 
+0001a160: 2a2a 5348 4946 5420 5645 4354 4f52 2a2a  **SHIFT VECTOR**
+0001a170: 2e20 5468 6520 3344 2070 6f73 6974 696f  . The 3D positio
+0001a180: 6e20 696e 2073 7061 6365 2069 7320 7468  n in space is th
+0001a190: 6520 696e 7665 7273 6520 6f66 2074 6869  e inverse of thi
+0001a1a0: 730a 2020 2020 7920 3d20 2d6c 6f6e 670a  s.    y = -long.
+0001a1b0: 2020 2020 7820 3d20 6c61 740a 2020 2020      x = lat.    
+0001a1c0: 7a20 3d20 7665 7274 0a20 2020 2072 6574  z = vert.    ret
+0001a1d0: 7572 6e20 5665 6374 6f72 2878 3d78 2c20  urn Vector(x=x, 
+0001a1e0: 793d 792c 207a 3d7a 290a 0a0a 6465 6620  y=y, z=z)...def 
+0001a1f0: 736f 6c76 655f 3364 5f70 6f73 6974 696f  solve_3d_positio
+0001a200: 6e5f 6672 6f6d 5f32 645f 706c 616e 6573  n_from_2d_planes
+0001a210: 280a 2020 2020 7873 3a20 5365 7175 656e  (.    xs: Sequen
+0001a220: 6365 5b66 6c6f 6174 5d2c 0a20 2020 2079  ce[float],.    y
+0001a230: 733a 2053 6571 7565 6e63 655b 666c 6f61  s: Sequence[floa
+0001a240: 745d 2c0a 2020 2020 7468 6574 6173 3a20  t],.    thetas: 
+0001a250: 5365 7175 656e 6365 5b66 6c6f 6174 5d2c  Sequence[float],
+0001a260: 0a20 2020 2070 6869 733a 2053 6571 7565  .    phis: Seque
+0001a270: 6e63 655b 666c 6f61 745d 2c0a 2020 2020  nce[float],.    
+0001a280: 7363 616c 653a 204d 6163 6869 6e65 5363  scale: MachineSc
+0001a290: 616c 652c 0a29 202d 3e20 5665 6374 6f72  ale,.) -> Vector
+0001a2a0: 3a0a 2020 2020 2222 2253 6f6c 7665 2066  :.    """Solve f
+0001a2b0: 6f72 2074 6865 2033 4420 706f 7369 7469  or the 3D positi
+0001a2c0: 6f6e 206f 6620 6120 4242 2069 6e20 7370  on of a BB in sp
+0001a2d0: 6163 6520 6769 7665 6e20 3244 2069 6d61  ace given 2D ima
+0001a2e0: 6765 732f 7665 6374 6f72 7320 616e 6420  ges/vectors and 
+0001a2f0: 7468 6520 6761 6e74 7279 2f63 6f75 6368  the gantry/couch
+0001a300: 2061 6e67 6c65 732e 0a0a 2020 2020 5468   angles...    Th
+0001a310: 6520 676f 6f64 206e 6577 7320 6973 2074  e good news is t
+0001a320: 6861 7420 7468 6520 706f 7369 7469 6f6e  hat the position
+0001a330: 2069 6e20 7370 6163 6520 6973 2074 6865   in space is the
+0001a340: 2069 6e76 6572 7365 206f 6620 7468 6520   inverse of the 
+0001a350: 7368 6966 7420 7665 6374 6f72 210a 2020  shift vector!.  
+0001a360: 2020 2222 220a 2020 2020 7265 7475 726e    """.    return
+0001a370: 202d 736f 6c76 655f 3364 5f73 6869 6674   -solve_3d_shift
+0001a380: 5f76 6563 746f 725f 6672 6f6d 5f32 645f  _vector_from_2d_
+0001a390: 706c 616e 6573 2878 732c 2079 732c 2074  planes(xs, ys, t
+0001a3a0: 6865 7461 732c 2070 6869 732c 2073 6361  hetas, phis, sca
+0001a3b0: 6c65 290a 0a0a 6465 6620 636f 6e76 656e  le)...def conven
+0001a3c0: 7469 6f6e 616c 5f74 6f5f 6575 6c65 725f  tional_to_euler_
+0001a3d0: 6e6f 7461 7469 6f6e 2861 7865 735f 7265  notation(axes_re
+0001a3e0: 736f 6c75 7469 6f6e 3a20 7374 7229 202d  solution: str) -
+0001a3f0: 3e20 7374 723a 0a20 2020 2022 2222 436f  > str:.    """Co
+0001a400: 6e76 6572 7420 636f 6e76 656e 7469 6f6e  nvert convention
+0001a410: 616c 2075 6e64 6572 7374 616e 6469 6e67  al understanding
+0001a420: 7320 6f66 2036 444f 4620 726f 7461 7469  s of 6DOF rotati
+0001a430: 6f6e 7320 696e 746f 2045 756c 6572 206e  ons into Euler n
+0001a440: 6f74 6174 696f 6e2e 0a0a 2020 2020 456e  otation...    En
+0001a450: 7375 7265 7320 7765 2064 6f6e 2774 206d  sures we don't m
+0001a460: 6978 2075 7020 782c 2079 2c20 7a20 7769  ix up x, y, z wi
+0001a470: 7468 2074 6865 2070 796c 696e 6163 2063  th the pylinac c
+0001a480: 6f6f 7264 696e 6174 6520 7379 7374 656d  oordinate system
+0001a490: 2e0a 2020 2020 2222 220a 2020 2020 4555  ..    """.    EU
+0001a4a0: 4c45 5220 3d20 7b0a 2020 2020 2020 2020  LER = {.        
+0001a4b0: 2320 4652 4f4d 2054 4845 2043 4f55 4348  # FROM THE COUCH
+0001a4c0: 2050 4552 5350 4543 5449 5645 0a20 2020   PERSPECTIVE.   
+0001a4d0: 2020 2020 2022 7069 7463 6822 3a20 2278       "pitch": "x
+0001a4e0: 222c 2020 2320 706f 7369 7469 7665 2070  ",  # positive p
+0001a4f0: 6974 6368 2067 6f65 7320 7570 0a20 2020  itch goes up.   
+0001a500: 2020 2020 2022 7961 7722 3a20 227a 222c       "yaw": "z",
+0001a510: 0a20 2020 2020 2020 2022 726f 6c6c 223a  .        "roll":
+0001a520: 2022 7922 2c20 2023 2070 6f73 6974 6976   "y",  # positiv
+0001a530: 6520 616e 676c 6520 726f 6c6c 7320 746f  e angle rolls to
+0001a540: 2074 6865 2072 6967 6874 0a20 2020 207d   the right.    }
+0001a550: 0a20 2020 2061 7865 7320 3d20 6178 6573  .    axes = axes
+0001a560: 5f72 6573 6f6c 7574 696f 6e2e 7370 6c69  _resolution.spli
+0001a570: 7428 222c 2229 0a20 2020 2065 756c 6572  t(",").    euler
+0001a580: 203d 2022 222e 6a6f 696e 285b 4555 4c45   = "".join([EULE
+0001a590: 525b 612e 7374 7269 7028 295d 2066 6f72  R[a.strip()] for
+0001a5a0: 2061 2069 6e20 6178 6573 5d29 0a20 2020   a in axes]).   
+0001a5b0: 2072 6574 7572 6e20 6575 6c65 720a 0a0a   return euler...
+0001a5c0: 6465 6620 616c 6967 6e5f 706f 696e 7473  def align_points
+0001a5d0: 280a 2020 2020 6d65 6173 7572 6564 5f70  (.    measured_p
+0001a5e0: 6f69 6e74 733a 2053 6571 7565 6e63 655b  oints: Sequence[
+0001a5f0: 506f 696e 745d 2c0a 2020 2020 6964 6561  Point],.    idea
+0001a600: 6c5f 706f 696e 7473 3a20 5365 7175 656e  l_points: Sequen
+0001a610: 6365 5b50 6f69 6e74 5d2c 0a20 2020 2061  ce[Point],.    a
+0001a620: 7865 735f 6f72 6465 723a 2073 7472 203d  xes_order: str =
+0001a630: 2022 726f 6c6c 2c70 6974 6368 2c79 6177   "roll,pitch,yaw
+0001a640: 222c 0a29 202d 3e20 2856 6563 746f 722c  ",.) -> (Vector,
+0001a650: 2066 6c6f 6174 2c20 666c 6f61 742c 2066   float, float, f
+0001a660: 6c6f 6174 293a 0a20 2020 2022 2222 0a20  loat):.    """. 
+0001a670: 2020 2041 6c69 676e 7320 6120 7365 7420     Aligns a set 
+0001a680: 6f66 206d 6561 7375 7265 6420 706f 696e  of measured poin
+0001a690: 7473 2074 6f20 6120 7365 7420 6f66 2069  ts to a set of i
+0001a6a0: 6465 616c 2070 6f69 6e74 7320 696e 2033  deal points in 3
+0001a6b0: 4420 7370 6163 652c 2072 6574 7572 6e69  D space, returni
+0001a6c0: 6e67 2074 6865 0a20 2020 2074 7261 6e73  ng the.    trans
+0001a6d0: 6c61 7469 6f6e 2061 6e64 2079 6177 2072  lation and yaw r
+0001a6e0: 6f74 6174 696f 6e20 6e65 6564 6564 2e0a  otation needed..
+0001a6f0: 0a20 2020 2050 6172 616d 6574 6572 730a  .    Parameters.
+0001a700: 2020 2020 2d2d 2d2d 2d2d 2d2d 2d2d 0a20      ----------. 
+0001a710: 2020 206d 6561 7375 7265 645f 706f 696e     measured_poin
+0001a720: 7473 203a 206e 702e 6e64 6172 7261 790a  ts : np.ndarray.
+0001a730: 2020 2020 2020 2020 5468 6520 6d65 6173          The meas
+0001a740: 7572 6564 2070 6f69 6e74 7320 6173 2061  ured points as a
+0001a750: 6e20 4e78 3320 6e75 6d70 7920 6172 7261  n Nx3 numpy arra
+0001a760: 792e 0a20 2020 2069 6465 616c 5f70 6f69  y..    ideal_poi
+0001a770: 6e74 7320 3a20 6e70 2e6e 6461 7272 6179  nts : np.ndarray
+0001a780: 0a20 2020 2020 2020 2054 6865 2069 6465  .        The ide
+0001a790: 616c 2070 6f69 6e74 7320 6173 2061 6e20  al points as an 
+0001a7a0: 4e78 3320 6e75 6d70 7920 6172 7261 792e  Nx3 numpy array.
+0001a7b0: 0a20 2020 2061 7865 735f 6f72 6465 7220  .    axes_order 
+0001a7c0: 3a20 7374 720a 2020 2020 2020 2020 5468  : str.        Th
+0001a7d0: 6520 6f72 6465 7220 696e 2077 6869 6368  e order in which
+0001a7e0: 2074 6f20 7265 736f 6c76 6520 7468 6520   to resolve the 
+0001a7f0: 6178 6573 2e0a 2020 2020 2020 2020 5265  axes..        Re
+0001a800: 736f 6c75 7469 6f6e 2069 7320 2a2a 6e6f  solution is **no
+0001a810: 742a 2a20 696e 6465 7065 6e64 656e 7420  t** independent 
+0001a820: 6f66 2074 6865 2061 7865 7320 6f72 6465  of the axes orde
+0001a830: 722e 2049 2e65 2e20 646f 696e 6720 2779  r. I.e. doing 'y
+0001a840: 6177 2c70 6974 6368 2c72 6f6c 6c27 206d  aw,pitch,roll' m
+0001a850: 6179 2072 6573 756c 740a 2020 2020 2020  ay result.      
+0001a860: 2020 696e 2061 2064 6966 6665 7265 6e74    in a different
+0001a870: 206f 7574 636f 6d65 2e0a 0a20 2020 2052   outcome...    R
+0001a880: 6574 7572 6e73 0a20 2020 202d 2d2d 2d2d  eturns.    -----
+0001a890: 2d2d 0a20 2020 2056 6563 746f 722c 2066  --.    Vector, f
+0001a8a0: 6c6f 6174 2c20 666c 6f61 742c 2066 6c6f  loat, float, flo
+0001a8b0: 6174 0a20 2020 2020 2020 2054 6865 2076  at.        The v
+0001a8c0: 6563 746f 7220 6973 2074 6865 2063 6172  ector is the car
+0001a8d0: 7465 7369 616e 2074 7261 6e73 6c61 7469  tesian translati
+0001a8e0: 6f6e 2028 6478 2c20 6479 2c20 647a 2920  on (dx, dy, dz) 
+0001a8f0: 616e 6420 7961 772c 2070 6974 6368 2c20  and yaw, pitch, 
+0001a900: 616e 6420 726f 6c6c 2061 6e67 6c65 2069  and roll angle i
+0001a910: 6e20 6465 6772 6565 7320 7265 7175 6972  n degrees requir
+0001a920: 6564 2074 6f20 616c 6967 6e20 7468 6520  ed to align the 
+0001a930: 6d65 6173 7572 6564 2070 6f69 6e74 730a  measured points.
+0001a940: 2020 2020 2020 2020 746f 2074 6865 2069          to the i
+0001a950: 6465 616c 2070 6f69 6e74 732e 0a20 2020  deal points..   
+0001a960: 2022 2222 0a20 2020 2023 2063 6f6e 7665   """.    # conve
+0001a970: 7274 2066 726f 6d20 506f 696e 7420 746f  rt from Point to
+0001a980: 2073 7461 636b 6564 2061 7272 6179 2028   stacked array (
+0001a990: 782c 2079 2c20 7a29 2078 204e 0a20 2020  x, y, z) x N.   
+0001a9a0: 206d 6561 7375 7265 645f 6172 7261 7920   measured_array 
+0001a9b0: 3d20 5b5b 702e 782c 2070 2e79 2c20 702e  = [[p.x, p.y, p.
+0001a9c0: 7a5d 2066 6f72 2070 2069 6e20 6d65 6173  z] for p in meas
+0001a9d0: 7572 6564 5f70 6f69 6e74 735d 0a20 2020  ured_points].   
+0001a9e0: 2069 6465 616c 5f61 7272 6179 203d 205b   ideal_array = [
+0001a9f0: 5b70 2e78 2c20 702e 792c 2070 2e7a 5d20  [p.x, p.y, p.z] 
+0001aa00: 666f 7220 7020 696e 2069 6465 616c 5f70  for p in ideal_p
+0001aa10: 6f69 6e74 735d 0a20 2020 2023 2045 6e73  oints].    # Ens
+0001aa20: 7572 6520 7468 6520 706f 696e 7473 2061  ure the points a
+0001aa30: 7265 2063 656e 7465 7265 6420 6174 2074  re centered at t
+0001aa40: 6865 6972 2063 656e 7472 6f69 6473 0a20  heir centroids. 
+0001aa50: 2020 206d 6561 7375 7265 645f 6365 6e74     measured_cent
+0001aa60: 726f 6964 203d 206e 702e 6d65 616e 286d  roid = np.mean(m
+0001aa70: 6561 7375 7265 645f 6172 7261 792c 2061  easured_array, a
+0001aa80: 7869 733d 3029 0a20 2020 2069 6465 616c  xis=0).    ideal
+0001aa90: 5f63 656e 7472 6f69 6420 3d20 6e70 2e6d  _centroid = np.m
+0001aaa0: 6561 6e28 6964 6561 6c5f 6172 7261 792c  ean(ideal_array,
+0001aab0: 2061 7869 733d 3029 0a20 2020 206d 6561   axis=0).    mea
+0001aac0: 7375 7265 645f 6365 6e74 6572 6564 203d  sured_centered =
+0001aad0: 206d 6561 7375 7265 645f 6172 7261 7920   measured_array 
+0001aae0: 2d20 6d65 6173 7572 6564 5f63 656e 7472  - measured_centr
+0001aaf0: 6f69 640a 2020 2020 6964 6561 6c5f 6365  oid.    ideal_ce
+0001ab00: 6e74 6572 6564 203d 2069 6465 616c 5f61  ntered = ideal_a
+0001ab10: 7272 6179 202d 2069 6465 616c 5f63 656e  rray - ideal_cen
+0001ab20: 7472 6f69 640a 0a20 2020 2023 2043 6f6d  troid..    # Com
+0001ab30: 7075 7465 2074 6865 2063 6f76 6172 6961  pute the covaria
+0001ab40: 6e63 6520 6d61 7472 6978 0a20 2020 2048  nce matrix.    H
+0001ab50: 203d 206d 6561 7375 7265 645f 6365 6e74   = measured_cent
+0001ab60: 6572 6564 2e54 2040 2069 6465 616c 5f63  ered.T @ ideal_c
+0001ab70: 656e 7465 7265 640a 0a20 2020 2023 2053  entered..    # S
+0001ab80: 696e 6775 6c61 7220 5661 6c75 6520 4465  ingular Value De
+0001ab90: 636f 6d70 6f73 6974 696f 6e0a 2020 2020  composition.    
+0001aba0: 552c 205f 2c20 5674 203d 206e 702e 6c69  U, _, Vt = np.li
+0001abb0: 6e61 6c67 2e73 7664 2848 290a 2020 2020  nalg.svd(H).    
+0001abc0: 726f 7461 7469 6f6e 5f6d 6174 7269 7820  rotation_matrix 
+0001abd0: 3d20 5674 2e54 2040 2055 2e54 0a0a 2020  = Vt.T @ U.T..  
+0001abe0: 2020 2320 456e 7375 7265 2061 2072 6967    # Ensure a rig
+0001abf0: 6874 2d68 616e 6465 6420 636f 6f72 6469  ht-handed coordi
+0001ac00: 6e61 7465 2073 7973 7465 6d0a 2020 2020  nate system.    
+0001ac10: 6966 206e 702e 6c69 6e61 6c67 2e64 6574  if np.linalg.det
+0001ac20: 2872 6f74 6174 696f 6e5f 6d61 7472 6978  (rotation_matrix
+0001ac30: 2920 3c20 303a 0a20 2020 2020 2020 2056  ) < 0:.        V
+0001ac40: 745b 322c 203a 5d20 2a3d 202d 310a 2020  t[2, :] *= -1.  
+0001ac50: 2020 2020 2020 726f 7461 7469 6f6e 5f6d        rotation_m
+0001ac60: 6174 7269 7820 3d20 5674 2e54 2040 2055  atrix = Vt.T @ U
+0001ac70: 2e54 0a0a 2020 2020 2320 436f 6d70 7574  .T..    # Comput
+0001ac80: 6520 7468 6520 6575 6c65 7220 616e 676c  e the euler angl
+0001ac90: 6573 0a20 2020 2072 6f74 6174 696f 6e20  es.    rotation 
+0001aca0: 3d20 526f 7461 7469 6f6e 2e66 726f 6d5f  = Rotation.from_
+0001acb0: 6d61 7472 6978 2872 6f74 6174 696f 6e5f  matrix(rotation_
+0001acc0: 6d61 7472 6978 290a 2020 2020 6575 6c65  matrix).    eule
+0001acd0: 7220 3d20 636f 6e76 656e 7469 6f6e 616c  r = conventional
+0001ace0: 5f74 6f5f 6575 6c65 725f 6e6f 7461 7469  _to_euler_notati
+0001acf0: 6f6e 2861 7865 735f 6f72 6465 7229 0a20  on(axes_order). 
+0001ad00: 2020 2072 6f6c 6c2c 2070 6974 6368 2c20     roll, pitch, 
+0001ad10: 7961 7720 3d20 726f 7461 7469 6f6e 2e61  yaw = rotation.a
+0001ad20: 735f 6575 6c65 7228 6575 6c65 722c 2064  s_euler(euler, d
+0001ad30: 6567 7265 6573 3d54 7275 6529 0a0a 2020  egrees=True)..  
+0001ad40: 2020 726f 7461 7465 645f 6d65 6173 7572    rotated_measur
+0001ad50: 6564 5f63 656e 7472 6f69 6420 3d20 726f  ed_centroid = ro
+0001ad60: 7461 7469 6f6e 2e61 7070 6c79 286d 6561  tation.apply(mea
+0001ad70: 7375 7265 645f 6365 6e74 726f 6964 290a  sured_centroid).
+0001ad80: 2020 2020 7472 616e 736c 6174 696f 6e20      translation 
+0001ad90: 3d20 6964 6561 6c5f 6365 6e74 726f 6964  = ideal_centroid
+0001ada0: 202d 2072 6f74 6174 6564 5f6d 6561 7375   - rotated_measu
+0001adb0: 7265 645f 6365 6e74 726f 6964 0a0a 2020  red_centroid..  
+0001adc0: 2020 7265 7475 726e 2056 6563 746f 7228    return Vector(
+0001add0: 2a74 7261 6e73 6c61 7469 6f6e 292c 2079  *translation), y
+0001ade0: 6177 2c20 7069 7463 682c 2072 6f6c 6c0a  aw, pitch, roll.
```

### Comparing `manteia_qa_pylinac-1.0.0/setup.py` & `manteia_qa_pylinac-1.1.0/setup.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 from distutils.core import setup
 from setuptools import find_packages
 
 with open("README.rst", "r") as f:
   long_description = f.read()
 
 setup(name='manteia_qa_pylinac',  # 
-      version='1.0.0',  # 
+      version='1.1.0',  # 
       description='pylinac custom made by manteia',
       long_description=long_description,
       author='dengjianping',
       author_email='1601246283@qq.com',
       url='',
       install_requires=[],
       license='BSD License',
```

