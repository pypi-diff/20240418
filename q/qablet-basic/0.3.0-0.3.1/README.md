# Comparing `tmp/qablet_basic-0.3.0-pp39-pypy39_pp73-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.zip` & `tmp/qablet_basic-0.3.1-cp310-none-win_amd64.whl.zip`

## zipinfo {}

```diff
@@ -1,19 +1,19 @@
-Zip file size: 610889 bytes, number of entries: 17
--rw-r--r--  4.6 unx      215 b- defN 24-Apr-09 21:36 qablet_basic-0.3.0.dist-info/METADATA
--rw-r--r--  4.6 unx      134 b- defN 24-Apr-09 21:36 qablet_basic-0.3.0.dist-info/WHEEL
--rw-r--r--  4.6 unx      349 b- defN 24-Apr-09 21:36 qablet/hullwhite/fd.py
--rw-r--r--  4.6 unx      446 b- defN 24-Apr-09 21:36 qablet/backtest/csv.py
--rw-r--r--  4.6 unx     2145 b- defN 24-Apr-09 21:36 qablet/black_scholes/mc.py
--rw-r--r--  4.6 unx      359 b- defN 24-Apr-09 21:36 qablet/black_scholes/fd.py
--rw-r--r--  4.6 unx        0 b- defN 24-Apr-09 21:36 qablet/black_scholes/__init__.py
--rw-r--r--  4.6 unx        0 b- defN 24-Apr-09 21:36 qablet/__init__.py
--rw-r--r--  4.6 unx     5507 b- defN 24-Apr-09 21:36 qablet/heston/mc.py
--rw-r--r--  4.6 unx      849 b- defN 24-Apr-09 21:36 qablet/base/mc.py
--rw-r--r--  4.6 unx      294 b- defN 24-Apr-09 21:36 qablet/base/fixed.py
--rw-r--r--  4.6 unx     2265 b- defN 24-Apr-09 21:36 qablet/base/base.py
--rw-r--r--  4.6 unx     1637 b- defN 24-Apr-09 21:36 qablet/base/utils.py
--rw-r--r--  4.6 unx      113 b- defN 24-Apr-09 21:36 qablet/base/flags.py
--rw-r--r--  4.6 unx      326 b- defN 24-Apr-09 21:36 qablet/local_vol/mc.py
--rwxr-xr-x  4.6 unx  1632904 b- defN 24-Apr-09 21:36 qablet/_qablet.pypy39-pp73-x86_64-linux-gnu.so
--rw-r--r--  4.6 unx     1338 b- defN 24-Apr-09 21:36 qablet_basic-0.3.0.dist-info/RECORD
-17 files, 1648881 bytes uncompressed, 608705 bytes compressed:  63.1%
+Zip file size: 492794 bytes, number of entries: 17
+-rw-r--r--  4.6 unx      215 b- defN 24-Apr-18 19:28 qablet_basic-0.3.1.dist-info/METADATA
+-rw-r--r--  4.6 unx       95 b- defN 24-Apr-18 19:28 qablet_basic-0.3.1.dist-info/WHEEL
+-rw-r--r--  4.6 unx     2343 b- defN 24-Apr-18 19:28 qablet/base/base.py
+-rw-r--r--  4.6 unx     1342 b- defN 24-Apr-18 19:28 qablet/base/cf.py
+-rw-r--r--  4.6 unx      307 b- defN 24-Apr-18 19:28 qablet/base/fixed.py
+-rw-r--r--  4.6 unx      121 b- defN 24-Apr-18 19:28 qablet/base/flags.py
+-rw-r--r--  4.6 unx      879 b- defN 24-Apr-18 19:28 qablet/base/mc.py
+-rw-r--r--  4.6 unx     1693 b- defN 24-Apr-18 19:28 qablet/base/utils.py
+-rw-r--r--  4.6 unx      376 b- defN 24-Apr-18 19:28 qablet/black_scholes/fd.py
+-rw-r--r--  4.6 unx     2212 b- defN 24-Apr-18 19:28 qablet/black_scholes/mc.py
+-rw-r--r--  4.6 unx        0 b- defN 24-Apr-18 19:28 qablet/black_scholes/__init__.py
+-rw-r--r--  4.6 unx     5895 b- defN 24-Apr-18 19:28 qablet/heston/mc.py
+-rw-r--r--  4.6 unx      366 b- defN 24-Apr-18 19:28 qablet/hullwhite/fd.py
+-rw-r--r--  4.6 unx      343 b- defN 24-Apr-18 19:28 qablet/local_vol/mc.py
+-rw-r--r--  4.6 unx        0 b- defN 24-Apr-18 19:28 qablet/__init__.py
+-rwxr-xr-x  4.6 unx  1368064 b- defN 24-Apr-18 19:28 qablet/_qablet.cp310-win_amd64.pyd
+-rw-r--r--  4.6 unx     1321 b- defN 24-Apr-18 19:28 qablet_basic-0.3.1.dist-info/RECORD
+17 files, 1385572 bytes uncompressed, 490644 bytes compressed:  64.6%
```

## zipnote {}

```diff
@@ -1,52 +1,52 @@
-Filename: qablet_basic-0.3.0.dist-info/METADATA
+Filename: qablet_basic-0.3.1.dist-info/METADATA
 Comment: 
 
-Filename: qablet_basic-0.3.0.dist-info/WHEEL
+Filename: qablet_basic-0.3.1.dist-info/WHEEL
 Comment: 
 
-Filename: qablet/hullwhite/fd.py
+Filename: qablet/base/base.py
 Comment: 
 
-Filename: qablet/backtest/csv.py
+Filename: qablet/base/cf.py
 Comment: 
 
-Filename: qablet/black_scholes/mc.py
+Filename: qablet/base/fixed.py
 Comment: 
 
-Filename: qablet/black_scholes/fd.py
+Filename: qablet/base/flags.py
 Comment: 
 
-Filename: qablet/black_scholes/__init__.py
+Filename: qablet/base/mc.py
 Comment: 
 
-Filename: qablet/__init__.py
+Filename: qablet/base/utils.py
 Comment: 
 
-Filename: qablet/heston/mc.py
+Filename: qablet/black_scholes/fd.py
 Comment: 
 
-Filename: qablet/base/mc.py
+Filename: qablet/black_scholes/mc.py
 Comment: 
 
-Filename: qablet/base/fixed.py
+Filename: qablet/black_scholes/__init__.py
 Comment: 
 
-Filename: qablet/base/base.py
+Filename: qablet/heston/mc.py
 Comment: 
 
-Filename: qablet/base/utils.py
+Filename: qablet/hullwhite/fd.py
 Comment: 
 
-Filename: qablet/base/flags.py
+Filename: qablet/local_vol/mc.py
 Comment: 
 
-Filename: qablet/local_vol/mc.py
+Filename: qablet/__init__.py
 Comment: 
 
-Filename: qablet/_qablet.pypy39-pp73-x86_64-linux-gnu.so
+Filename: qablet/_qablet.cp310-win_amd64.pyd
 Comment: 
 
-Filename: qablet_basic-0.3.0.dist-info/RECORD
+Filename: qablet_basic-0.3.1.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## qablet/hullwhite/fd.py

 * *Ordering differences only*

```diff
@@ -1,17 +1,17 @@
-# Hullwhite model using finite difference method
-
-
-from qablet.base.base import Model, ModelStateBase
-
-from .._qablet import fd_hullwhite_price
-
-
-# Define the Model Class
-class HWFDModel(Model):
-    __PARAM_SCHEMA_NAME__ = "HW"
-
-    def state_class(self):
-        return ModelStateBase
-
-    def price_method(self):
-        return fd_hullwhite_price
+# Hullwhite model using finite difference method
+
+
+from qablet.base.base import Model, ModelStateBase
+
+from .._qablet import fd_hullwhite_price
+
+
+# Define the Model Class
+class HWFDModel(Model):
+    __PARAM_SCHEMA_NAME__ = "HW"
+
+    def state_class(self):
+        return ModelStateBase
+
+    def price_method(self):
+        return fd_hullwhite_price
```

## qablet/black_scholes/mc.py

 * *Ordering differences only*

```diff
@@ -1,67 +1,67 @@
-from math import sqrt
-
-import numpy as np
-from numpy.random import SFC64, Generator
-
-from qablet.base.mc import MCModel, MCStateBase
-from qablet.base.utils import Forwards
-
-
-# Define a class for the state of a single asset BS Local Vol MC process
-class LVMCState(MCStateBase):
-    def __init__(self, timetable, dataset):
-        super().__init__(timetable, dataset)
-
-        # fetch the model parameters from the dataset
-        self.n = dataset["MC"]["PATHS"]
-        self.asset = dataset["LV"]["ASSET"]
-        self.asset_fwd = Forwards(dataset["ASSETS"][self.asset])
-        self.spot = self.asset_fwd.forward(0)
-        self.volfn = dataset["LV"]["VOL"]
-
-        # Initialize rng and any arrays
-        self.rng = Generator(SFC64(dataset["MC"]["SEED"]))
-        self.x_vec = np.zeros(self.n)  # process x (log stock)
-        self.dz_vec = np.empty(self.n, dtype=np.float64)
-        self.tmp = np.empty(self.n, dtype=np.float64)
-
-        self.cur_time = 0
-
-    def advance(self, new_time):
-        """Update x_vec in place when we move simulation by time dt."""
-
-        dt = new_time - self.cur_time
-        if dt < 1e-10:
-            return
-        fwd_rate = self.asset_fwd.rate(new_time, self.cur_time)
-        if callable(self.volfn):
-            vol = self.volfn((self.cur_time, self.x_vec))
-        else:
-            vol = self.volfn
-
-        # # generate the random numbers and advance the log stock process
-        self.rng.standard_normal(self.n, out=self.dz_vec)
-        self.dz_vec *= sqrt(dt)
-        self.dz_vec *= vol
-
-        # add drift to x_vec: (fwd_rate - vol * vol / 2.0) * dt
-        np.multiply(vol, vol, out=self.tmp)
-        self.tmp *= -0.5 * dt
-        self.tmp += fwd_rate * dt
-        self.x_vec += self.tmp
-        # add the random part to x_vec
-        self.x_vec += self.dz_vec
-
-        self.cur_time = new_time
-
-    def get_value(self, unit):
-        """Return the value of the modeled asset at the current time.
-        otherwise return none."""
-
-        if unit == self.asset:
-            return self.spot * np.exp(self.x_vec)
-
-
-class LVMCModel(MCModel):
-    def state_class(self):
-        return LVMCState
+from math import sqrt
+
+import numpy as np
+from numpy.random import SFC64, Generator
+
+from qablet.base.mc import MCModel, MCStateBase
+from qablet.base.utils import Forwards
+
+
+# Define a class for the state of a single asset BS Local Vol MC process
+class LVMCState(MCStateBase):
+    def __init__(self, timetable, dataset):
+        super().__init__(timetable, dataset)
+
+        # fetch the model parameters from the dataset
+        self.n = dataset["MC"]["PATHS"]
+        self.asset = dataset["LV"]["ASSET"]
+        self.asset_fwd = Forwards(dataset["ASSETS"][self.asset])
+        self.spot = self.asset_fwd.forward(0)
+        self.volfn = dataset["LV"]["VOL"]
+
+        # Initialize rng and any arrays
+        self.rng = Generator(SFC64(dataset["MC"]["SEED"]))
+        self.x_vec = np.zeros(self.n)  # process x (log stock)
+        self.dz_vec = np.empty(self.n, dtype=np.float64)
+        self.tmp = np.empty(self.n, dtype=np.float64)
+
+        self.cur_time = 0
+
+    def advance(self, new_time):
+        """Update x_vec in place when we move simulation by time dt."""
+
+        dt = new_time - self.cur_time
+        if dt < 1e-10:
+            return
+        fwd_rate = self.asset_fwd.rate(new_time, self.cur_time)
+        if callable(self.volfn):
+            vol = self.volfn((self.cur_time, self.x_vec))
+        else:
+            vol = self.volfn
+
+        # # generate the random numbers and advance the log stock process
+        self.rng.standard_normal(self.n, out=self.dz_vec)
+        self.dz_vec *= sqrt(dt)
+        self.dz_vec *= vol
+
+        # add drift to x_vec: (fwd_rate - vol * vol / 2.0) * dt
+        np.multiply(vol, vol, out=self.tmp)
+        self.tmp *= -0.5 * dt
+        self.tmp += fwd_rate * dt
+        self.x_vec += self.tmp
+        # add the random part to x_vec
+        self.x_vec += self.dz_vec
+
+        self.cur_time = new_time
+
+    def get_value(self, unit):
+        """Return the value of the modeled asset at the current time.
+        otherwise return none."""
+
+        if unit == self.asset:
+            return self.spot * np.exp(self.x_vec)
+
+
+class LVMCModel(MCModel):
+    def state_class(self):
+        return LVMCState
```

## qablet/black_scholes/fd.py

 * *Ordering differences only*

```diff
@@ -1,17 +1,17 @@
-# Black Scholes model using finite difference method
-
-
-from qablet.base.base import Model, ModelStateBase
-
-from .._qablet import fd_blackscholes_price
-
-
-# Define the Model Class
-class BSFDModel(Model):
-    __PARAM_SCHEMA_NAME__ = "BS"
-
-    def state_class(self):
-        return ModelStateBase
-
-    def price_method(self):
-        return fd_blackscholes_price
+# Black Scholes model using finite difference method
+
+
+from qablet.base.base import Model, ModelStateBase
+
+from .._qablet import fd_blackscholes_price
+
+
+# Define the Model Class
+class BSFDModel(Model):
+    __PARAM_SCHEMA_NAME__ = "BS"
+
+    def state_class(self):
+        return ModelStateBase
+
+    def price_method(self):
+        return fd_blackscholes_price
```

## qablet/heston/mc.py

```diff
@@ -1,146 +1,151 @@
-# Monte Carlo Pricer for Heston Model
-
-from math import sqrt
-
-import numpy as np
-from numpy.random import SFC64, Generator
-
-from qablet.base.mc import MCModel, MCStateBase
-from qablet.base.utils import Forwards
-
-
-# Define a class for the state of a single asset Heston MC process
-class HestonStateMC(MCStateBase):
-    def __init__(self, timetable, dataset):
-        super().__init__(timetable, dataset)
-
-        self.shape = dataset["MC"]["PATHS"]
-        assert self.shape % 2 == 0, "Number of paths must be even"
-        self.n = self.shape >> 1  # divide by 2
-
-        # create a random number generator
-        self.rng = Generator(SFC64(dataset["MC"]["SEED"]))
-
-        self.asset = dataset["HESTON"]["ASSET"]
-        self.asset_fwd = Forwards(dataset["ASSETS"][self.asset])
-        self.spot = self.asset_fwd.forward(0)
-
-        self.heston_params = (
-            dataset["HESTON"]["LONG_VAR"],
-            dataset["HESTON"]["VOL_OF_VAR"],
-            dataset["HESTON"]["MEANREV"],
-            dataset["HESTON"]["CORRELATION"],
-        )
-
-        # Initialize the arrays
-        self.x_vec = np.zeros(self.shape)  # processes x (log stock)
-        self.v_vec = np.full(
-            self.shape, dataset["HESTON"]["INITIAL_VAR"]
-        )  # processes v (variance)
-
-        # We will reduce time spent in memory allocation by creating arrays in advance
-        # and reusing them in the `advance` function which is called repeatedly.
-        # though the values from one timestep are not reused in the next.
-        self.tmp_vec = np.empty(self.shape, dtype=np.float64)
-        self.dz1_vec = np.empty(self.shape, dtype=np.float64)
-        self.dz2_vec = np.empty(self.shape, dtype=np.float64)
-        self.vol_vec = np.empty(self.shape, dtype=np.float64)
-        self.sv_vec = np.empty(self.shape, dtype=np.float64)
-        self.cur_time = 0
-
-    def advance(self, new_time):
-        """Update x_vec, v_vec in place when we move simulation by time dt."""
-        dt = new_time - self.cur_time
-        if dt < 1e-10:
-            return
-
-        (
-            theta,
-            vol_of_variance,
-            mean_reversion_speed,
-            correlation,
-        ) = self.heston_params
-        fwd_rate = self.asset_fwd.rate(new_time, self.cur_time)
-
-        sqrtdt = sqrt(dt)
-        n = self.n
-
-        # To improve preformance we will break up the operations into np.multiply,
-        # np.add, etc. and use the `out` parameter to avoid creating temporary arrays.
-
-        # generate the random numbers
-        # we calculate dz1 = normal(0,1) * sqrtdt
-        self.rng.standard_normal(
-            n, out=self.dz1_vec[0:n]
-        )  # not much difference using out= or not
-        np.multiply(sqrtdt, self.dz1_vec[0:n], out=self.dz1_vec[0:n])
-        np.negative(
-            self.dz1_vec[0:n], out=self.dz1_vec[n:]
-        )  # antithetic variates
-
-        # we calculate dz2 = normal(0,1) * sqrtdt * sqrt(1 - correlation * correlation) + correlation * dz1
-        self.rng.standard_normal(n, out=self.dz2_vec[0:n])
-        np.multiply(
-            sqrtdt * sqrt(1 - correlation * correlation),
-            self.dz2_vec[0:n],
-            out=self.dz2_vec[0:n],
-        )
-        np.negative(
-            self.dz2_vec[0:n], out=self.dz2_vec[n:]
-        )  # antithetic variates
-        np.multiply(correlation, self.dz1_vec, out=self.tmp_vec)  # second term
-        np.add(self.dz2_vec, self.tmp_vec, out=self.dz2_vec)
-
-        # vol = sqrt(max(v, 0))
-        np.maximum(0.0, self.v_vec, out=self.vol_vec)
-        np.sqrt(self.vol_vec, out=self.vol_vec)
-
-        # update the current value of x (log Stock process)
-        # first term: x += (fwd_rate - vol * vol / 2.) * dt
-        np.multiply(self.vol_vec, self.vol_vec, out=self.tmp_vec)
-        np.divide(self.tmp_vec, 2, out=self.tmp_vec)
-        np.subtract(fwd_rate, self.tmp_vec, out=self.tmp_vec)
-        np.multiply(self.tmp_vec, dt, out=self.tmp_vec)
-        np.add(self.x_vec, self.tmp_vec, out=self.x_vec)
-
-        # second term: x += vol * dz1
-        np.multiply(self.vol_vec, self.dz1_vec, out=self.tmp_vec)
-        np.add(self.x_vec, self.tmp_vec, out=self.x_vec)
-
-        # update the current value of v (variance process)
-        # first term: v += mean_reversion_speed * (theta - v) * dt
-        np.subtract(theta, self.v_vec, out=self.tmp_vec)
-        np.multiply(
-            self.tmp_vec, (mean_reversion_speed * dt), out=self.tmp_vec
-        )
-        np.add(self.v_vec, self.tmp_vec, out=self.v_vec)
-
-        # second term: v += vol_of_variance * vol * dz2
-        np.multiply(vol_of_variance, self.vol_vec, out=self.tmp_vec)
-        np.multiply(self.tmp_vec, self.dz2_vec, out=self.tmp_vec)
-        np.add(self.v_vec, self.tmp_vec, out=self.v_vec)
-
-        # Millstein correction
-        # third term: v += 0.25 * vol_of_variance * vol_of_variance * (dz2 ** 2 - dt)
-        np.multiply(self.dz2_vec, self.dz2_vec, out=self.tmp_vec)
-        np.subtract(self.tmp_vec, dt, out=self.tmp_vec)
-        np.multiply(
-            0.25 * vol_of_variance * vol_of_variance,
-            self.tmp_vec,
-            out=self.tmp_vec,
-        )
-        np.add(self.v_vec, self.tmp_vec, out=self.v_vec)
-
-        self.cur_time = new_time
-
-    def get_value(self, unit):
-        """Return the value of the unit at the current time."""
-        if unit == self.asset:
-            return self.spot * np.exp(self.x_vec)
-        else:
-            return None
-
-
-class HestonMCModel(MCModel):
-    def state_class(self):
-        return HestonStateMC
+# Monte Carlo Pricer for Heston Model
+
+from math import sqrt
+
+import numpy as np
+from numpy.random import SFC64, Generator
+
+from qablet.base.mc import MCModel, MCStateBase
+from qablet.base.utils import Forwards
+
+
+# Define a class for the state of a single asset Heston MC process
+class HestonStateMC(MCStateBase):
+    def __init__(self, timetable, dataset):
+        super().__init__(timetable, dataset)
+
+        self.shape = dataset["MC"]["PATHS"]
+        assert self.shape % 2 == 0, "Number of paths must be even"
+        self.n = self.shape >> 1  # divide by 2
+
+        # create a random number generator
+        self.rng = Generator(SFC64(dataset["MC"]["SEED"]))
+
+        self.asset = dataset["HESTON"]["ASSET"]
+        self.asset_fwd = Forwards(dataset["ASSETS"][self.asset])
+        self.spot = self.asset_fwd.forward(0)
+
+        self.heston_params = (
+            dataset["HESTON"]["LONG_VAR"],
+            dataset["HESTON"]["VOL_OF_VAR"],
+            dataset["HESTON"]["MEANREV"],
+            dataset["HESTON"]["CORRELATION"],
+        )
+
+        # Initialize the arrays
+        self.x_vec = np.zeros(self.shape)  # processes x (log stock)
+        self.v_vec = np.full(
+            self.shape, dataset["HESTON"]["INITIAL_VAR"]
+        )  # processes v (variance)
+
+        # We will reduce time spent in memory allocation by creating arrays in advance
+        # and reusing them in the `advance` function which is called repeatedly.
+        # though the values from one timestep are not reused in the next.
+        self.tmp_vec = np.empty(self.shape, dtype=np.float64)
+        self.dz1_vec = np.empty(self.shape, dtype=np.float64)
+        self.dz2_vec = np.empty(self.shape, dtype=np.float64)
+        self.vol_vec = np.empty(self.shape, dtype=np.float64)
+        self.sv_vec = np.empty(self.shape, dtype=np.float64)
+        self.cur_time = 0
+
+    def advance(self, new_time):
+        """Update x_vec, v_vec in place when we move simulation by time dt."""
+        dt = new_time - self.cur_time
+        if dt < 1e-10:
+            return
+
+        (
+            theta,
+            vol_of_variance,
+            mean_reversion_speed,
+            correlation,
+        ) = self.heston_params
+        fwd_rate = self.asset_fwd.rate(new_time, self.cur_time)
+
+        sqrtdt = sqrt(dt)
+        n = self.n
+
+        # To improve preformance we will break up the operations into np.multiply,
+        # np.add, etc. and use the `out` parameter to avoid creating temporary arrays.
+
+        # generate the random numbers
+        # we calculate dz1 = normal(0,1) * sqrtdt
+        self.rng.standard_normal(
+            n, out=self.dz1_vec[0:n]
+        )  # not much difference using out= or not
+        np.multiply(sqrtdt, self.dz1_vec[0:n], out=self.dz1_vec[0:n])
+        np.negative(
+            self.dz1_vec[0:n], out=self.dz1_vec[n:]
+        )  # antithetic variates
+
+        # TODO : test performance of using multivariate normal
+        # rhosq = correlation * correlatio
+        # cov = [[dt, rhosq * dt], [rhosq * dt, dt]]
+        # dz_vec = np.random.multivariate_normal([0, 0], cov, n).transpose()
+
+        # we calculate dz2 = normal(0,1) * sqrtdt * sqrt(1 - correlation * correlation) + correlation * dz1
+        self.rng.standard_normal(n, out=self.dz2_vec[0:n])
+        np.multiply(
+            sqrtdt * sqrt(1 - correlation * correlation),
+            self.dz2_vec[0:n],
+            out=self.dz2_vec[0:n],
+        )
+        np.negative(
+            self.dz2_vec[0:n], out=self.dz2_vec[n:]
+        )  # antithetic variates
+        np.multiply(correlation, self.dz1_vec, out=self.tmp_vec)  # second term
+        np.add(self.dz2_vec, self.tmp_vec, out=self.dz2_vec)
+
+        # vol = sqrt(max(v, 0))
+        np.maximum(0.0, self.v_vec, out=self.vol_vec)
+        np.sqrt(self.vol_vec, out=self.vol_vec)
+
+        # update the current value of x (log Stock process)
+        # first term: x += (fwd_rate - vol * vol / 2.) * dt
+        np.multiply(self.vol_vec, self.vol_vec, out=self.tmp_vec)
+        np.divide(self.tmp_vec, 2, out=self.tmp_vec)
+        np.subtract(fwd_rate, self.tmp_vec, out=self.tmp_vec)
+        np.multiply(self.tmp_vec, dt, out=self.tmp_vec)
+        np.add(self.x_vec, self.tmp_vec, out=self.x_vec)
+
+        # second term: x += vol * dz1
+        np.multiply(self.vol_vec, self.dz1_vec, out=self.tmp_vec)
+        np.add(self.x_vec, self.tmp_vec, out=self.x_vec)
+
+        # update the current value of v (variance process)
+        # first term: v += mean_reversion_speed * (theta - v) * dt
+        np.subtract(theta, self.v_vec, out=self.tmp_vec)
+        np.multiply(
+            self.tmp_vec, (mean_reversion_speed * dt), out=self.tmp_vec
+        )
+        np.add(self.v_vec, self.tmp_vec, out=self.v_vec)
+
+        # second term: v += vol_of_variance * vol * dz2
+        np.multiply(vol_of_variance, self.vol_vec, out=self.tmp_vec)
+        np.multiply(self.tmp_vec, self.dz2_vec, out=self.tmp_vec)
+        np.add(self.v_vec, self.tmp_vec, out=self.v_vec)
+
+        # Millstein correction
+        # third term: v += 0.25 * vol_of_variance * vol_of_variance * (dz2 ** 2 - dt)
+        np.multiply(self.dz2_vec, self.dz2_vec, out=self.tmp_vec)
+        np.subtract(self.tmp_vec, dt, out=self.tmp_vec)
+        np.multiply(
+            0.25 * vol_of_variance * vol_of_variance,
+            self.tmp_vec,
+            out=self.tmp_vec,
+        )
+        np.add(self.v_vec, self.tmp_vec, out=self.v_vec)
+
+        self.cur_time = new_time
+
+    def get_value(self, unit):
+        """Return the value of the unit at the current time."""
+        if unit == self.asset:
+            return self.spot * np.exp(self.x_vec)
+        else:
+            return None
+
+
+class HestonMCModel(MCModel):
+    def state_class(self):
+        return HestonStateMC
```

## qablet/base/mc.py

 * *Ordering differences only*

```diff
@@ -1,30 +1,30 @@
-# Generic MC model
-
-from abc import abstractmethod
-
-from .._qablet import mc_price
-from .base import Model, ModelStateBase
-
-
-# Define Base Class for State Object for MC Models
-# Todo add the abstract methods and what else is expected from this class.
-class MCStateBase(ModelStateBase):
-    """Class to maintain the state of a single asset MC process."""
-
-    def get_value(self, unit):
-        """Return the value of the asset at the current time,
-        if this asset is handled by the model, otherwise return None."""
-        return None
-
-    @abstractmethod
-    def advance(self, new_time: float):
-        ...
-
-
-# Define Base Class for MC Models
-class MCModel(Model):
-    """Abstract base class for all Monte Carlo models where the stochastic model
-    is implemented in the python class."""
-
-    def price_method(self):
-        return mc_price
+# Generic MC model
+
+from abc import abstractmethod
+
+from .._qablet import mc_price
+from .base import Model, ModelStateBase
+
+
+# Define Base Class for State Object for MC Models
+# Todo add the abstract methods and what else is expected from this class.
+class MCStateBase(ModelStateBase):
+    """Class to maintain the state of a single asset MC process."""
+
+    def get_value(self, unit):
+        """Return the value of the asset at the current time,
+        if this asset is handled by the model, otherwise return None."""
+        return None
+
+    @abstractmethod
+    def advance(self, new_time: float):
+        ...
+
+
+# Define Base Class for MC Models
+class MCModel(Model):
+    """Abstract base class for all Monte Carlo models where the stochastic model
+    is implemented in the python class."""
+
+    def price_method(self):
+        return mc_price
```

## qablet/base/fixed.py

 * *Ordering differences only*

```diff
@@ -1,13 +1,13 @@
-# Define the fixed model
-
-from .._qablet import fixed_price
-from .base import Model, ModelStateBase
-
-
-# Define a determinitic Model that just uses forwards
-class FixedModel(Model):
-    def state_class(self):
-        return ModelStateBase
-
-    def price_method(self):
-        return fixed_price
+# Define the fixed model
+
+from .._qablet import fixed_price
+from .base import Model, ModelStateBase
+
+
+# Define a determinitic Model that just uses forwards
+class FixedModel(Model):
+    def state_class(self):
+        return ModelStateBase
+
+    def price_method(self):
+        return fixed_price
```

## qablet/base/base.py

 * *Ordering differences only*

```diff
@@ -1,78 +1,78 @@
-# Define Base Class for Models
-from abc import ABC, abstractmethod
-from datetime import datetime
-
-import pyarrow as pa
-from qablet_contracts.timetable import TS_EVENT_SCHEMA, py_to_ts
-
-
-def convert_time_to_ts(timetable, base_ts):
-    """Convert events of timetable in place, changing time column into timestamp column.
-    This function is used convert timetables created by legacy methods that use floating point
-    for time into timetables with timestamp for time."""
-    events = timetable["events"]
-
-    if events["time"].type == pa.float64():
-        ts_list = [
-            base_ts + t.as_py() * 31_536_000_000 for t in events["time"]
-        ]
-
-        timetable["events"] = pa.RecordBatch.from_arrays(
-            [
-                events["track"],
-                ts_list,
-                events["op"],
-                events["quantity"],
-                events["unit"],
-            ],
-            schema=TS_EVENT_SCHEMA,
-        )
-
-
-# Define Base Class for State Object for all Models
-class ModelStateBase(ABC):
-    """Class to maintain the state during a model execution."""
-
-    def __init__(self, timetable, dataset):
-        self.stats = {}
-
-    def set_stat(self, key: str, val):
-        self.stats[key] = val
-
-
-class Model(ABC):
-    """Base class for all models."""
-
-    @abstractmethod
-    def state_class(self):
-        """The class that maintains state for this model."""
-        ...
-
-    @abstractmethod
-    def price_method(self):
-        """The method that calculates price."""
-        ...
-
-    def price(self, timetable, dataset):
-        """Calculate price of contract.
-
-        Parameters:
-            timetable (dict): timetable for the contract.
-            dataset (dict): dataset for the model.
-
-        Returns:
-            price (float): price of contract
-            stats (dict): stats such as standard error
-
-        """
-
-        if "PRICING_TS" not in dataset:
-            dataset["PRICING_TS"] = py_to_ts(datetime(2023, 12, 31)).value
-        convert_time_to_ts(timetable, dataset["PRICING_TS"])
-
-        model_state = (self.state_class())(timetable, dataset)
-        price = self.price_method()(
-            timetable["events"], model_state, dataset, timetable["expressions"]
-        )
-
-        return price, model_state.stats
+# Define Base Class for Models
+from abc import ABC, abstractmethod
+from datetime import datetime
+
+import pyarrow as pa
+from qablet_contracts.timetable import TS_EVENT_SCHEMA, py_to_ts
+
+
+def convert_time_to_ts(timetable, base_ts):
+    """Convert events of timetable in place, changing time column into timestamp column.
+    This function is used convert timetables created by legacy methods that use floating point
+    for time into timetables with timestamp for time."""
+    events = timetable["events"]
+
+    if events["time"].type == pa.float64():
+        ts_list = [
+            base_ts + t.as_py() * 31_536_000_000 for t in events["time"]
+        ]
+
+        timetable["events"] = pa.RecordBatch.from_arrays(
+            [
+                events["track"],
+                ts_list,
+                events["op"],
+                events["quantity"],
+                events["unit"],
+            ],
+            schema=TS_EVENT_SCHEMA,
+        )
+
+
+# Define Base Class for State Object for all Models
+class ModelStateBase(ABC):
+    """Class to maintain the state during a model execution."""
+
+    def __init__(self, timetable, dataset):
+        self.stats = {}
+
+    def set_stat(self, key: str, val):
+        self.stats[key] = val
+
+
+class Model(ABC):
+    """Base class for all models."""
+
+    @abstractmethod
+    def state_class(self):
+        """The class that maintains state for this model."""
+        ...
+
+    @abstractmethod
+    def price_method(self):
+        """The method that calculates price."""
+        ...
+
+    def price(self, timetable, dataset):
+        """Calculate price of contract.
+
+        Parameters:
+            timetable (dict): timetable for the contract.
+            dataset (dict): dataset for the model.
+
+        Returns:
+            price (float): price of contract
+            stats (dict): stats such as standard error
+
+        """
+
+        if "PRICING_TS" not in dataset:
+            dataset["PRICING_TS"] = py_to_ts(datetime(2023, 12, 31)).value
+        convert_time_to_ts(timetable, dataset["PRICING_TS"])
+
+        model_state = (self.state_class())(timetable, dataset)
+        price = self.price_method()(
+            timetable["events"], model_state, dataset, timetable["expressions"]
+        )
+
+        return price, model_state.stats
```

## qablet/base/utils.py

 * *Ordering differences only*

```diff
@@ -1,56 +1,56 @@
-# Utility classes and functions for models.
-
-import numpy as np
-from scipy import interpolate
-
-
-# Define a class for discount factors and rates.
-class Discounter:
-    """A class for discount factors and rates."""
-
-    def __init__(self, discount_data):
-        data_type, data = discount_data
-        if data_type == "LOG_DISCOUNTS":
-            # the columns are times and log discounts
-            times = data[:, 0]
-            log_discounts = data[:, 1]
-        elif data_type == "ZERO_RATES":
-            # the columns are times and zero rates
-            times = data[:, 0]
-            zero_rates = data[:, 1]
-            log_discounts = -zero_rates * times
-
-        self.log_discount_fn = interpolate.interp1d(times, log_discounts)
-
-    def rate(self, end, start=0):
-        ld_end, ld_start = self.log_discount_fn([end, start])
-
-        return (ld_start - ld_end) / (end - start)
-
-    def discount(self, t):
-        return np.exp(self.log_discount_fn(t))
-
-
-# Define a class for forwards of an asset.
-class Forwards:
-    """A class for forwards and forward rates."""
-
-    def __init__(self, forwards_data):
-        _, data = forwards_data
-
-        times = data[:, 0]
-        fwds = data[:, 1]
-
-        self.log_forward_fn = interpolate.interp1d(times, np.log(fwds))
-
-    def rate(self, end, start=0):
-        ld_end, ld_start = self.log_forward_fn([end, start])
-        return (ld_end - ld_start) / (end - start)
-
-    def forward(self, t):
-        return np.exp(self.log_forward_fn(t))
-
-
-def discounter_from_dataset(dataset):
-    """Return a discounter from a dataset."""
-    return Discounter(dataset["ASSETS"][dataset["BASE"]])
+# Utility classes and functions for models.
+
+import numpy as np
+from scipy import interpolate
+
+
+# Define a class for discount factors and rates.
+class Discounter:
+    """A class for discount factors and rates."""
+
+    def __init__(self, discount_data):
+        data_type, data = discount_data
+        if data_type == "LOG_DISCOUNTS":
+            # the columns are times and log discounts
+            times = data[:, 0]
+            log_discounts = data[:, 1]
+        elif data_type == "ZERO_RATES":
+            # the columns are times and zero rates
+            times = data[:, 0]
+            zero_rates = data[:, 1]
+            log_discounts = -zero_rates * times
+
+        self.log_discount_fn = interpolate.interp1d(times, log_discounts)
+
+    def rate(self, end, start=0):
+        ld_end, ld_start = self.log_discount_fn([end, start])
+
+        return (ld_start - ld_end) / (end - start)
+
+    def discount(self, t):
+        return np.exp(self.log_discount_fn(t))
+
+
+# Define a class for forwards of an asset.
+class Forwards:
+    """A class for forwards and forward rates."""
+
+    def __init__(self, forwards_data):
+        _, data = forwards_data
+
+        times = data[:, 0]
+        fwds = data[:, 1]
+
+        self.log_forward_fn = interpolate.interp1d(times, np.log(fwds))
+
+    def rate(self, end, start=0):
+        ld_end, ld_start = self.log_forward_fn([end, start])
+        return (ld_end - ld_start) / (end - start)
+
+    def forward(self, t):
+        return np.exp(self.log_forward_fn(t))
+
+
+def discounter_from_dataset(dataset):
+    """Return a discounter from a dataset."""
+    return Discounter(dataset["ASSETS"][dataset["BASE"]])
```

## qablet/base/flags.py

 * *Ordering differences only*

```diff
@@ -1,8 +1,8 @@
-from enum import IntFlag
-
-
-class Stats(IntFlag):
-    PV_VEC = 1
-    CHOICES = 2
-    PV_GRID = 4
-    CASHFLOW = 8
+from enum import IntFlag
+
+
+class Stats(IntFlag):
+    PV_VEC = 1
+    CHOICES = 2
+    PV_GRID = 4
+    CASHFLOW = 8
```

## qablet/local_vol/mc.py

 * *Ordering differences only*

```diff
@@ -1,17 +1,17 @@
-# Local Vol model using Monte Carlo method
-
-
-from qablet.base.base import Model, ModelStateBase
-
-from .. import _qablet
-
-
-# Define the Model Class
-class LVMCModel(Model):
-    __PARAM_SCHEMA_NAME__ = "LV"
-
-    def state_class(self):
-        return ModelStateBase
-
-    def price_method(self):
-        return _qablet.mc_lv_price
+# Local Vol model using Monte Carlo method
+
+
+from qablet.base.base import Model, ModelStateBase
+
+from .. import _qablet
+
+
+# Define the Model Class
+class LVMCModel(Model):
+    __PARAM_SCHEMA_NAME__ = "LV"
+
+    def state_class(self):
+        return ModelStateBase
+
+    def price_method(self):
+        return _qablet.mc_lv_price
```

